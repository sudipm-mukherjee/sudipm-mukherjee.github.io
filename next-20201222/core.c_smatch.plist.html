<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/sched/core.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  kernel/sched/core.c\n *\n *  Core kernel scheduler code and related syscalls\n *\n *  Copyright (C) 1991-2002  Linus Torvalds\n */\n#define CREATE_TRACE_POINTS\n#include <trace/events/sched.h>\n#undef CREATE_TRACE_POINTS\n\n#include \"sched.h\"\n\n#include <linux/nospec.h>\n\n#include <linux/kcov.h>\n#include <linux/scs.h>\n\n#include <asm/switch_to.h>\n#include <asm/tlb.h>\n\n#include \"../workqueue_internal.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../smpboot.h\"\n\n#include \"pelt.h\"\n#include \"smp.h\"\n\n/*\n * Export tracepoints that act as a bare tracehook (ie: have no trace event\n * associated with them) to allow external modules to probe them.\n */\nEXPORT_TRACEPOINT_SYMBOL_GPL(pelt_cfs_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(pelt_rt_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(pelt_dl_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(pelt_irq_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(pelt_se_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(sched_cpu_capacity_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(sched_overutilized_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(sched_util_est_cfs_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(sched_util_est_se_tp);\nEXPORT_TRACEPOINT_SYMBOL_GPL(sched_update_nr_running_tp);\n\nDEFINE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);\n\n#ifdef CONFIG_SCHED_DEBUG\n/*\n * Debugging: various feature bits\n *\n * If SCHED_DEBUG is disabled, each compilation unit has its own copy of\n * sysctl_sched_features, defined in sched.h, to allow constants propagation\n * at compile time and compiler optimization based on features default.\n */\n#define SCHED_FEAT(name, enabled)\t\\\n\t(1UL << __SCHED_FEAT_##name) * enabled |\nconst_debug unsigned int sysctl_sched_features =\n#include \"features.h\"\n\t0;\n#undef SCHED_FEAT\n#endif\n\n/*\n * Number of tasks to iterate in a single balance run.\n * Limited because this is done with IRQs disabled.\n */\nconst_debug unsigned int sysctl_sched_nr_migrate = 32;\n\n/*\n * period over which we measure -rt task CPU usage in us.\n * default: 1s\n */\nunsigned int sysctl_sched_rt_period = 1000000;\n\n__read_mostly int scheduler_running;\n\n/*\n * part of the period that we allow rt tasks to run in us.\n * default: 0.95s\n */\nint sysctl_sched_rt_runtime = 950000;\n\n\n/*\n * Serialization rules:\n *\n * Lock order:\n *\n *   p->pi_lock\n *     rq->lock\n *       hrtimer_cpu_base->lock (hrtimer_start() for bandwidth controls)\n *\n *  rq1->lock\n *    rq2->lock  where: rq1 < rq2\n *\n * Regular state:\n *\n * Normal scheduling state is serialized by rq->lock. __schedule() takes the\n * local CPU's rq->lock, it optionally removes the task from the runqueue and\n * always looks at the local rq data structures to find the most eligible task\n * to run next.\n *\n * Task enqueue is also under rq->lock, possibly taken from another CPU.\n * Wakeups from another LLC domain might use an IPI to transfer the enqueue to\n * the local CPU to avoid bouncing the runqueue state around [ see\n * ttwu_queue_wakelist() ]\n *\n * Task wakeup, specifically wakeups that involve migration, are horribly\n * complicated to avoid having to take two rq->locks.\n *\n * Special state:\n *\n * System-calls and anything external will use task_rq_lock() which acquires\n * both p->pi_lock and rq->lock. As a consequence the state they change is\n * stable while holding either lock:\n *\n *  - sched_setaffinity()/\n *    set_cpus_allowed_ptr():\tp->cpus_ptr, p->nr_cpus_allowed\n *  - set_user_nice():\t\tp->se.load, p->*prio\n *  - __sched_setscheduler():\tp->sched_class, p->policy, p->*prio,\n *\t\t\t\tp->se.load, p->rt_priority,\n *\t\t\t\tp->dl.dl_{runtime, deadline, period, flags, bw, density}\n *  - sched_setnuma():\t\tp->numa_preferred_nid\n *  - sched_move_task()/\n *    cpu_cgroup_fork():\tp->sched_task_group\n *  - uclamp_update_active()\tp->uclamp*\n *\n * p->state <- TASK_*:\n *\n *   is changed locklessly using set_current_state(), __set_current_state() or\n *   set_special_state(), see their respective comments, or by\n *   try_to_wake_up(). This latter uses p->pi_lock to serialize against\n *   concurrent self.\n *\n * p->on_rq <- { 0, 1 = TASK_ON_RQ_QUEUED, 2 = TASK_ON_RQ_MIGRATING }:\n *\n *   is set by activate_task() and cleared by deactivate_task(), under\n *   rq->lock. Non-zero indicates the task is runnable, the special\n *   ON_RQ_MIGRATING state is used for migration without holding both\n *   rq->locks. It indicates task_cpu() is not stable, see task_rq_lock().\n *\n * p->on_cpu <- { 0, 1 }:\n *\n *   is set by prepare_task() and cleared by finish_task() such that it will be\n *   set before p is scheduled-in and cleared after p is scheduled-out, both\n *   under rq->lock. Non-zero indicates the task is running on its CPU.\n *\n *   [ The astute reader will observe that it is possible for two tasks on one\n *     CPU to have ->on_cpu = 1 at the same time. ]\n *\n * task_cpu(p): is changed by set_task_cpu(), the rules are:\n *\n *  - Don't call set_task_cpu() on a blocked task:\n *\n *    We don't care what CPU we're not running on, this simplifies hotplug,\n *    the CPU assignment of blocked tasks isn't required to be valid.\n *\n *  - for try_to_wake_up(), called under p->pi_lock:\n *\n *    This allows try_to_wake_up() to only take one rq->lock, see its comment.\n *\n *  - for migration called under rq->lock:\n *    [ see task_on_rq_migrating() in task_rq_lock() ]\n *\n *    o move_queued_task()\n *    o detach_task()\n *\n *  - for migration called under double_rq_lock():\n *\n *    o __migrate_swap_task()\n *    o push_rt_task() / pull_rt_task()\n *    o push_dl_task() / pull_dl_task()\n *    o dl_task_offline_migration()\n *\n */\n\n/*\n * __task_rq_lock - lock the rq @p resides on.\n */\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}\n\n/*\n * task_rq_lock - lock p->pi_lock and lock the rq @p resides on.\n */\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}\n\n/*\n * RQ-clock updating methods:\n */\n\nstatic void update_rq_clock_task(struct rq *rq, s64 delta)\n{\n/*\n * In theory, the compile should just see 0 here, and optimize out the call\n * to sched_rt_avg_update. But I don't trust it...\n */\n\ts64 __maybe_unused steal = 0, irq_delta = 0;\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tirq_delta = irq_time_read(cpu_of(rq)) - rq->prev_irq_time;\n\n\t/*\n\t * Since irq_time is only updated on {soft,}irq_exit, we might run into\n\t * this case when a previous update_rq_clock() happened inside a\n\t * {soft,}irq region.\n\t *\n\t * When this happens, we stop ->clock_task and only update the\n\t * prev_irq_time stamp to account for the part that fit, so that a next\n\t * update will consume the rest. This ensures ->clock_task is\n\t * monotonic.\n\t *\n\t * It does however cause some slight miss-attribution of {soft,}irq\n\t * time, a more accurate solution would be to update the irq_time using\n\t * the current rq->clock timestamp, except that would require using\n\t * atomic ops.\n\t */\n\tif (irq_delta > delta)\n\t\tirq_delta = delta;\n\n\trq->prev_irq_time += irq_delta;\n\tdelta -= irq_delta;\n#endif\n#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING\n\tif (static_key_false((&paravirt_steal_rq_enabled))) {\n\t\tsteal = paravirt_steal_clock(cpu_of(rq));\n\t\tsteal -= rq->prev_steal_time_rq;\n\n\t\tif (unlikely(steal > delta))\n\t\t\tsteal = delta;\n\n\t\trq->prev_steal_time_rq += steal;\n\t\tdelta -= steal;\n\t}\n#endif\n\n\trq->clock_task += delta;\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tif ((irq_delta + steal) && sched_feat(NONTASK_CAPACITY))\n\t\tupdate_irq_load_avg(rq, irq_delta + steal);\n#endif\n\tupdate_rq_clock_pelt(rq, delta);\n}\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}\n\n#ifdef CONFIG_SCHED_HRTICK\n/*\n * Use HR-timers to deliver accurate preemption points.\n */\n\nstatic void hrtick_clear(struct rq *rq)\n{\n\tif (hrtimer_active(&rq->hrtick_timer))\n\t\thrtimer_cancel(&rq->hrtick_timer);\n}\n\n/*\n * High-resolution timer tick.\n * Runs from hardirq context with interrupts disabled.\n */\nstatic enum hrtimer_restart hrtick(struct hrtimer *timer)\n{\n\tstruct rq *rq = container_of(timer, struct rq, hrtick_timer);\n\tstruct rq_flags rf;\n\n\tWARN_ON_ONCE(cpu_of(rq) != smp_processor_id());\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\trq->curr->sched_class->task_tick(rq, rq->curr, 1);\n\trq_unlock(rq, &rf);\n\n\treturn HRTIMER_NORESTART;\n}\n\n#ifdef CONFIG_SMP\n\nstatic void __hrtick_restart(struct rq *rq)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\n\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n}\n\n/*\n * called from hardirq (IPI) context\n */\nstatic void __hrtick_start(void *arg)\n{\n\tstruct rq *rq = arg;\n\tstruct rq_flags rf;\n\n\trq_lock(rq, &rf);\n\t__hrtick_restart(rq);\n\trq_unlock(rq, &rf);\n}\n\n/*\n * Called to set the hrtick timer state.\n *\n * called with rq->lock held and irqs disabled\n */\nvoid hrtick_start(struct rq *rq, u64 delay)\n{\n\tstruct hrtimer *timer = &rq->hrtick_timer;\n\tktime_t time;\n\ts64 delta;\n\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense and can cause timer DoS.\n\t */\n\tdelta = max_t(s64, delay, 10000LL);\n\ttime = ktime_add_ns(timer->base->get_time(), delta);\n\n\thrtimer_set_expires(timer, time);\n\n\tif (rq == this_rq())\n\t\t__hrtick_restart(rq);\n\telse\n\t\tsmp_call_function_single_async(cpu_of(rq), &rq->hrtick_csd);\n}\n\n#else\n/*\n * Called to set the hrtick timer state.\n *\n * called with rq->lock held and irqs disabled\n */\nvoid hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n}\n\n#endif /* CONFIG_SMP */\n\nstatic void hrtick_rq_init(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\tINIT_CSD(&rq->hrtick_csd, __hrtick_start, rq);\n#endif\n\thrtimer_init(&rq->hrtick_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\trq->hrtick_timer.function = hrtick;\n}\n#else\t/* CONFIG_SCHED_HRTICK */\nstatic inline void hrtick_clear(struct rq *rq)\n{\n}\n\nstatic inline void hrtick_rq_init(struct rq *rq)\n{\n}\n#endif\t/* CONFIG_SCHED_HRTICK */\n\n/*\n * cmpxchg based fetch_or, macro so it works for different integer types\n */\n#define fetch_or(ptr, mask)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(ptr) _ptr = (ptr);\t\t\t\t\\\n\t\ttypeof(mask) _mask = (mask);\t\t\t\t\\\n\t\ttypeof(*_ptr) _old, _val = *_ptr;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (;;) {\t\t\t\t\t\t\\\n\t\t\t_old = cmpxchg(_ptr, _val, _val | _mask);\t\\\n\t\t\tif (_old == _val)\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t_val = _old;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t_old;\t\t\t\t\t\t\t\t\\\n})\n\n#if defined(CONFIG_SMP) && defined(TIF_POLLING_NRFLAG)\n/*\n * Atomically set TIF_NEED_RESCHED and test for TIF_POLLING_NRFLAG,\n * this avoids any races wrt polling state changes and thereby avoids\n * spurious IPIs.\n */\nstatic bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tstruct thread_info *ti = task_thread_info(p);\n\treturn !(fetch_or(&ti->flags, _TIF_NEED_RESCHED) & _TIF_POLLING_NRFLAG);\n}\n\n/*\n * Atomically set TIF_NEED_RESCHED if TIF_POLLING_NRFLAG is set.\n *\n * If this returns true, then the idle task promises to call\n * sched_ttwu_pending() and reschedule soon.\n */\nstatic bool set_nr_if_polling(struct task_struct *p)\n{\n\tstruct thread_info *ti = task_thread_info(p);\n\ttypeof(ti->flags) old, val = READ_ONCE(ti->flags);\n\n\tfor (;;) {\n\t\tif (!(val & _TIF_POLLING_NRFLAG))\n\t\t\treturn false;\n\t\tif (val & _TIF_NEED_RESCHED)\n\t\t\treturn true;\n\t\told = cmpxchg(&ti->flags, val, val | _TIF_NEED_RESCHED);\n\t\tif (old == val)\n\t\t\tbreak;\n\t\tval = old;\n\t}\n\treturn true;\n}\n\n#else\nstatic bool set_nr_and_not_polling(struct task_struct *p)\n{\n\tset_tsk_need_resched(p);\n\treturn true;\n}\n\n#ifdef CONFIG_SMP\nstatic bool set_nr_if_polling(struct task_struct *p)\n{\n\treturn false;\n}\n#endif\n#endif\n\nstatic bool __wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tstruct wake_q_node *node = &task->wake_q;\n\n\t/*\n\t * Atomically grab the task, if ->wake_q is !nil already it means\n\t * it's already queued (either by us or someone else) and will get the\n\t * wakeup due to that.\n\t *\n\t * In order to ensure that a pending wakeup will observe our pending\n\t * state, even in the failed case, an explicit smp_mb() must be used.\n\t */\n\tsmp_mb__before_atomic();\n\tif (unlikely(cmpxchg_relaxed(&node->next, NULL, WAKE_Q_TAIL)))\n\t\treturn false;\n\n\t/*\n\t * The head is context local, there can be no concurrency.\n\t */\n\t*head->lastp = node;\n\thead->lastp = &node->next;\n\treturn true;\n}\n\n/**\n * wake_q_add() - queue a wakeup for 'later' waking.\n * @head: the wake_q_head to add @task to\n * @task: the task to queue for 'later' wakeup\n *\n * Queue a task for later wakeup, most likely by the wake_up_q() call in the\n * same context, _HOWEVER_ this is not guaranteed, the wakeup can come\n * instantly.\n *\n * This function must be used as-if it were wake_up_process(); IOW the task\n * must be ready to be woken at this location.\n */\nvoid wake_q_add(struct wake_q_head *head, struct task_struct *task)\n{\n\tif (__wake_q_add(head, task))\n\t\tget_task_struct(task);\n}\n\n/**\n * wake_q_add_safe() - safely queue a wakeup for 'later' waking.\n * @head: the wake_q_head to add @task to\n * @task: the task to queue for 'later' wakeup\n *\n * Queue a task for later wakeup, most likely by the wake_up_q() call in the\n * same context, _HOWEVER_ this is not guaranteed, the wakeup can come\n * instantly.\n *\n * This function must be used as-if it were wake_up_process(); IOW the task\n * must be ready to be woken at this location.\n *\n * This function is essentially a task-safe equivalent to wake_q_add(). Callers\n * that already hold reference to @task can call the 'safe' version and trust\n * wake_q to do the right thing depending whether or not the @task is already\n * queued for wakeup.\n */\nvoid wake_q_add_safe(struct wake_q_head *head, struct task_struct *task)\n{\n\tif (!__wake_q_add(head, task))\n\t\tput_task_struct(task);\n}\n\nvoid wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\t/* Task can safely be re-inserted now: */\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\n\t\t/*\n\t\t * wake_up_process() executes a full barrier, which pairs with\n\t\t * the queueing in wake_q_add() so as not to miss wakeups.\n\t\t */\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}\n\n/*\n * resched_curr - mark rq's current task 'to be rescheduled now'.\n *\n * On UP this means the setting of the need_resched flag, on SMP it\n * might also involve a cross-CPU call to trigger the scheduler on\n * the target CPU.\n */\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}\n\nvoid resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n}\n\n#ifdef CONFIG_SMP\n#ifdef CONFIG_NO_HZ_COMMON\n/*\n * In the semi idle case, use the nearest busy CPU for migrating timers\n * from an idle CPU.  This is good for power-savings.\n *\n * We don't do similar optimization for completely idle system, as\n * selecting an idle CPU will add more delays to the timers than intended\n * (as that CPU's timer base may not be uptodate wrt jiffies etc).\n */\nint get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id(), default_cpu = -1;\n\tstruct sched_domain *sd;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TIMER)) {\n\t\tif (!idle_cpu(cpu))\n\t\t\treturn cpu;\n\t\tdefault_cpu = cpu;\n\t}\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu_and(i, sched_domain_span(sd),\n\t\t\thousekeeping_cpumask(HK_FLAG_TIMER)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_cpu == -1)\n\t\tdefault_cpu = housekeeping_any_cpu(HK_FLAG_TIMER);\n\tcpu = default_cpu;\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}\n\n/*\n * When add_timer_on() enqueues a timer into the timer wheel of an\n * idle CPU then this timer might expire before the next timer event\n * which is scheduled to wake up that CPU. In case of a completely\n * idle system the next event might even be infinite time into the\n * future. wake_up_idle_cpu() ensures that the CPU is woken up and\n * leaves the inner idle loop so the newly added timer is taken into\n * account when the CPU goes back to idle and evaluates the timer\n * wheel for the next timer event.\n */\nstatic void wake_up_idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (cpu == smp_processor_id())\n\t\treturn;\n\n\tif (set_nr_and_not_polling(rq->idle))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}\n\nstatic bool wake_up_full_nohz_cpu(int cpu)\n{\n\t/*\n\t * We just need the target to call irq_exit() and re-evaluate\n\t * the next tick. The nohz full kick at least implies that.\n\t * If needed we can still optimize that later with an\n\t * empty IRQ.\n\t */\n\tif (cpu_is_offline(cpu))\n\t\treturn true;  /* Don't try to wake offline CPUs. */\n\tif (tick_nohz_full_cpu(cpu)) {\n\t\tif (cpu != smp_processor_id() ||\n\t\t    tick_nohz_tick_stopped())\n\t\t\ttick_nohz_full_kick_cpu(cpu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * Wake up the specified CPU.  If the CPU is going offline, it is the\n * caller's responsibility to deal with the lost wakeup, for example,\n * by hooking into the CPU_DEAD notifier like timers and hrtimers do.\n */\nvoid wake_up_nohz_cpu(int cpu)\n{\n\tif (!wake_up_full_nohz_cpu(cpu))\n\t\twake_up_idle_cpu(cpu);\n}\n\nstatic void nohz_csd_func(void *info)\n{\n\tstruct rq *rq = info;\n\tint cpu = cpu_of(rq);\n\tunsigned int flags;\n\n\t/*\n\t * Release the rq::nohz_csd.\n\t */\n\tflags = atomic_fetch_andnot(NOHZ_KICK_MASK, nohz_flags(cpu));\n\tWARN_ON(!(flags & NOHZ_KICK_MASK));\n\n\trq->idle_balance = idle_cpu(cpu);\n\tif (rq->idle_balance && !need_resched()) {\n\t\trq->nohz_idle_balance = flags;\n\t\traise_softirq_irqoff(SCHED_SOFTIRQ);\n\t}\n}\n\n#endif /* CONFIG_NO_HZ_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nbool sched_can_stop_tick(struct rq *rq)\n{\n\tint fifo_nr_running;\n\n\t/* Deadline tasks, even if single, need the tick */\n\tif (rq->dl.dl_nr_running)\n\t\treturn false;\n\n\t/*\n\t * If there are more than one RR tasks, we need the tick to affect the\n\t * actual RR behaviour.\n\t */\n\tif (rq->rt.rr_nr_running) {\n\t\tif (rq->rt.rr_nr_running == 1)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\t/*\n\t * If there's no RR tasks, but FIFO tasks, we can skip the tick, no\n\t * forced preemption between FIFO tasks.\n\t */\n\tfifo_nr_running = rq->rt.rt_nr_running - rq->rt.rr_nr_running;\n\tif (fifo_nr_running)\n\t\treturn true;\n\n\t/*\n\t * If there are no DL,RR/FIFO tasks, there must only be CFS tasks left;\n\t * if there's more than one we need the tick for involuntary\n\t * preemption.\n\t */\n\tif (rq->nr_running > 1)\n\t\treturn false;\n\n\treturn true;\n}\n#endif /* CONFIG_NO_HZ_FULL */\n#endif /* CONFIG_SMP */\n\n#if defined(CONFIG_RT_GROUP_SCHED) || (defined(CONFIG_FAIR_GROUP_SCHED) && \\\n\t\t\t(defined(CONFIG_SMP) || defined(CONFIG_CFS_BANDWIDTH)))\n/*\n * Iterate task_group tree rooted at *from, calling @down when first entering a\n * node and @up when leaving it for the final time.\n *\n * Caller must hold rcu_lock or sufficient equivalent.\n */\nint walk_tg_tree_from(struct task_group *from,\n\t\t\t     tg_visitor down, tg_visitor up, void *data)\n{\n\tstruct task_group *parent, *child;\n\tint ret;\n\n\tparent = from;\n\ndown:\n\tret = (*down)(parent, data);\n\tif (ret)\n\t\tgoto out;\n\tlist_for_each_entry_rcu(child, &parent->children, siblings) {\n\t\tparent = child;\n\t\tgoto down;\n\nup:\n\t\tcontinue;\n\t}\n\tret = (*up)(parent, data);\n\tif (ret || parent == from)\n\t\tgoto out;\n\n\tchild = parent;\n\tparent = parent->parent;\n\tif (parent)\n\t\tgoto up;\nout:\n\treturn ret;\n}\n\nint tg_nop(struct task_group *tg, void *data)\n{\n\treturn 0;\n}\n#endif\n\nstatic void set_load_weight(struct task_struct *p, bool update_load)\n{\n\tint prio = p->static_prio - MAX_RT_PRIO;\n\tstruct load_weight *load = &p->se.load;\n\n\t/*\n\t * SCHED_IDLE tasks get minimal weight:\n\t */\n\tif (task_has_idle_policy(p)) {\n\t\tload->weight = scale_load(WEIGHT_IDLEPRIO);\n\t\tload->inv_weight = WMULT_IDLEPRIO;\n\t\treturn;\n\t}\n\n\t/*\n\t * SCHED_OTHER tasks have to update their load when changing their\n\t * weight\n\t */\n\tif (update_load && p->sched_class == &fair_sched_class) {\n\t\treweight_task(p, prio);\n\t} else {\n\t\tload->weight = scale_load(sched_prio_to_weight[prio]);\n\t\tload->inv_weight = sched_prio_to_wmult[prio];\n\t}\n}\n\n#ifdef CONFIG_UCLAMP_TASK\n/*\n * Serializes updates of utilization clamp values\n *\n * The (slow-path) user-space triggers utilization clamp value updates which\n * can require updates on (fast-path) scheduler's data structures used to\n * support enqueue/dequeue operations.\n * While the per-CPU rq lock protects fast-path update operations, user-space\n * requests are serialized using a mutex to reduce the risk of conflicting\n * updates or API abuses.\n */\nstatic DEFINE_MUTEX(uclamp_mutex);\n\n/* Max allowed minimum utilization */\nunsigned int sysctl_sched_uclamp_util_min = SCHED_CAPACITY_SCALE;\n\n/* Max allowed maximum utilization */\nunsigned int sysctl_sched_uclamp_util_max = SCHED_CAPACITY_SCALE;\n\n/*\n * By default RT tasks run at the maximum performance point/capacity of the\n * system. Uclamp enforces this by always setting UCLAMP_MIN of RT tasks to\n * SCHED_CAPACITY_SCALE.\n *\n * This knob allows admins to change the default behavior when uclamp is being\n * used. In battery powered devices, particularly, running at the maximum\n * capacity and frequency will increase energy consumption and shorten the\n * battery life.\n *\n * This knob only affects RT tasks that their uclamp_se->user_defined == false.\n *\n * This knob will not override the system default sched_util_clamp_min defined\n * above.\n */\nunsigned int sysctl_sched_uclamp_util_min_rt_default = SCHED_CAPACITY_SCALE;\n\n/* All clamps are required to be less or equal than these values */\nstatic struct uclamp_se uclamp_default[UCLAMP_CNT];\n\n/*\n * This static key is used to reduce the uclamp overhead in the fast path. It\n * primarily disables the call to uclamp_rq_{inc, dec}() in\n * enqueue/dequeue_task().\n *\n * This allows users to continue to enable uclamp in their kernel config with\n * minimum uclamp overhead in the fast path.\n *\n * As soon as userspace modifies any of the uclamp knobs, the static key is\n * enabled, since we have an actual users that make use of uclamp\n * functionality.\n *\n * The knobs that would enable this static key are:\n *\n *   * A task modifying its uclamp value with sched_setattr().\n *   * An admin modifying the sysctl_sched_uclamp_{min, max} via procfs.\n *   * An admin modifying the cgroup cpu.uclamp.{min, max}\n */\nDEFINE_STATIC_KEY_FALSE(sched_uclamp_used);\n\n/* Integer rounded range for each bucket */\n#define UCLAMP_BUCKET_DELTA DIV_ROUND_CLOSEST(SCHED_CAPACITY_SCALE, UCLAMP_BUCKETS)\n\n#define for_each_clamp_id(clamp_id) \\\n\tfor ((clamp_id) = 0; (clamp_id) < UCLAMP_CNT; (clamp_id)++)\n\nstatic inline unsigned int uclamp_bucket_id(unsigned int clamp_value)\n{\n\treturn clamp_value / UCLAMP_BUCKET_DELTA;\n}\n\nstatic inline unsigned int uclamp_none(enum uclamp_id clamp_id)\n{\n\tif (clamp_id == UCLAMP_MIN)\n\t\treturn 0;\n\treturn SCHED_CAPACITY_SCALE;\n}\n\nstatic inline void uclamp_se_set(struct uclamp_se *uc_se,\n\t\t\t\t unsigned int value, bool user_defined)\n{\n\tuc_se->value = value;\n\tuc_se->bucket_id = uclamp_bucket_id(value);\n\tuc_se->user_defined = user_defined;\n}\n\nstatic inline unsigned int\nuclamp_idle_value(struct rq *rq, enum uclamp_id clamp_id,\n\t\t  unsigned int clamp_value)\n{\n\t/*\n\t * Avoid blocked utilization pushing up the frequency when we go\n\t * idle (which drops the max-clamp) by retaining the last known\n\t * max-clamp.\n\t */\n\tif (clamp_id == UCLAMP_MAX) {\n\t\trq->uclamp_flags |= UCLAMP_FLAG_IDLE;\n\t\treturn clamp_value;\n\t}\n\n\treturn uclamp_none(UCLAMP_MIN);\n}\n\nstatic inline void uclamp_idle_reset(struct rq *rq, enum uclamp_id clamp_id,\n\t\t\t\t     unsigned int clamp_value)\n{\n\t/* Reset max-clamp retention only on idle exit */\n\tif (!(rq->uclamp_flags & UCLAMP_FLAG_IDLE))\n\t\treturn;\n\n\tWRITE_ONCE(rq->uclamp[clamp_id].value, clamp_value);\n}\n\nstatic inline\nunsigned int uclamp_rq_max_value(struct rq *rq, enum uclamp_id clamp_id,\n\t\t\t\t   unsigned int clamp_value)\n{\n\tstruct uclamp_bucket *bucket = rq->uclamp[clamp_id].bucket;\n\tint bucket_id = UCLAMP_BUCKETS - 1;\n\n\t/*\n\t * Since both min and max clamps are max aggregated, find the\n\t * top most bucket with tasks in.\n\t */\n\tfor ( ; bucket_id >= 0; bucket_id--) {\n\t\tif (!bucket[bucket_id].tasks)\n\t\t\tcontinue;\n\t\treturn bucket[bucket_id].value;\n\t}\n\n\t/* No tasks -- default clamp values */\n\treturn uclamp_idle_value(rq, clamp_id, clamp_value);\n}\n\nstatic void __uclamp_update_util_min_rt_default(struct task_struct *p)\n{\n\tunsigned int default_util_min;\n\tstruct uclamp_se *uc_se;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tuc_se = &p->uclamp_req[UCLAMP_MIN];\n\n\t/* Only sync if user didn't override the default */\n\tif (uc_se->user_defined)\n\t\treturn;\n\n\tdefault_util_min = sysctl_sched_uclamp_util_min_rt_default;\n\tuclamp_se_set(uc_se, default_util_min, false);\n}\n\nstatic void uclamp_update_util_min_rt_default(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (!rt_task(p))\n\t\treturn;\n\n\t/* Protect updates to p->uclamp_* */\n\trq = task_rq_lock(p, &rf);\n\t__uclamp_update_util_min_rt_default(p);\n\ttask_rq_unlock(rq, p, &rf);\n}\n\nstatic void uclamp_sync_util_min_rt_default(void)\n{\n\tstruct task_struct *g, *p;\n\n\t/*\n\t * copy_process()\t\t\tsysctl_uclamp\n\t *\t\t\t\t\t  uclamp_min_rt = X;\n\t *   write_lock(&tasklist_lock)\t\t  read_lock(&tasklist_lock)\n\t *   // link thread\t\t\t  smp_mb__after_spinlock()\n\t *   write_unlock(&tasklist_lock)\t  read_unlock(&tasklist_lock);\n\t *   sched_post_fork()\t\t\t  for_each_process_thread()\n\t *     __uclamp_sync_rt()\t\t    __uclamp_sync_rt()\n\t *\n\t * Ensures that either sched_post_fork() will observe the new\n\t * uclamp_min_rt or for_each_process_thread() will observe the new\n\t * task.\n\t */\n\tread_lock(&tasklist_lock);\n\tsmp_mb__after_spinlock();\n\tread_unlock(&tasklist_lock);\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p)\n\t\tuclamp_update_util_min_rt_default(p);\n\trcu_read_unlock();\n}\n\nstatic inline struct uclamp_se\nuclamp_tg_restrict(struct task_struct *p, enum uclamp_id clamp_id)\n{\n\tstruct uclamp_se uc_req = p->uclamp_req[clamp_id];\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\tstruct uclamp_se uc_max;\n\n\t/*\n\t * Tasks in autogroups or root task group will be\n\t * restricted by system defaults.\n\t */\n\tif (task_group_is_autogroup(task_group(p)))\n\t\treturn uc_req;\n\tif (task_group(p) == &root_task_group)\n\t\treturn uc_req;\n\n\tuc_max = task_group(p)->uclamp[clamp_id];\n\tif (uc_req.value > uc_max.value || !uc_req.user_defined)\n\t\treturn uc_max;\n#endif\n\n\treturn uc_req;\n}\n\n/*\n * The effective clamp bucket index of a task depends on, by increasing\n * priority:\n * - the task specific clamp value, when explicitly requested from userspace\n * - the task group effective clamp value, for tasks not either in the root\n *   group or in an autogroup\n * - the system default clamp value, defined by the sysadmin\n */\nstatic inline struct uclamp_se\nuclamp_eff_get(struct task_struct *p, enum uclamp_id clamp_id)\n{\n\tstruct uclamp_se uc_req = uclamp_tg_restrict(p, clamp_id);\n\tstruct uclamp_se uc_max = uclamp_default[clamp_id];\n\n\t/* System default restrictions always apply */\n\tif (unlikely(uc_req.value > uc_max.value))\n\t\treturn uc_max;\n\n\treturn uc_req;\n}\n\nunsigned long uclamp_eff_value(struct task_struct *p, enum uclamp_id clamp_id)\n{\n\tstruct uclamp_se uc_eff;\n\n\t/* Task currently refcounted: use back-annotated (effective) value */\n\tif (p->uclamp[clamp_id].active)\n\t\treturn (unsigned long)p->uclamp[clamp_id].value;\n\n\tuc_eff = uclamp_eff_get(p, clamp_id);\n\n\treturn (unsigned long)uc_eff.value;\n}\n\n/*\n * When a task is enqueued on a rq, the clamp bucket currently defined by the\n * task's uclamp::bucket_id is refcounted on that rq. This also immediately\n * updates the rq's clamp value if required.\n *\n * Tasks can have a task-specific value requested from user-space, track\n * within each bucket the maximum value for tasks refcounted in it.\n * This \"local max aggregation\" allows to track the exact \"requested\" value\n * for each bucket when all its RUNNABLE tasks require the same clamp.\n */\nstatic inline void uclamp_rq_inc_id(struct rq *rq, struct task_struct *p,\n\t\t\t\t    enum uclamp_id clamp_id)\n{\n\tstruct uclamp_rq *uc_rq = &rq->uclamp[clamp_id];\n\tstruct uclamp_se *uc_se = &p->uclamp[clamp_id];\n\tstruct uclamp_bucket *bucket;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/* Update task effective clamp */\n\tp->uclamp[clamp_id] = uclamp_eff_get(p, clamp_id);\n\n\tbucket = &uc_rq->bucket[uc_se->bucket_id];\n\tbucket->tasks++;\n\tuc_se->active = true;\n\n\tuclamp_idle_reset(rq, clamp_id, uc_se->value);\n\n\t/*\n\t * Local max aggregation: rq buckets always track the max\n\t * \"requested\" clamp value of its RUNNABLE tasks.\n\t */\n\tif (bucket->tasks == 1 || uc_se->value > bucket->value)\n\t\tbucket->value = uc_se->value;\n\n\tif (uc_se->value > READ_ONCE(uc_rq->value))\n\t\tWRITE_ONCE(uc_rq->value, uc_se->value);\n}\n\n/*\n * When a task is dequeued from a rq, the clamp bucket refcounted by the task\n * is released. If this is the last task reference counting the rq's max\n * active clamp value, then the rq's clamp value is updated.\n *\n * Both refcounted tasks and rq's cached clamp values are expected to be\n * always valid. If it's detected they are not, as defensive programming,\n * enforce the expected state and warn.\n */\nstatic inline void uclamp_rq_dec_id(struct rq *rq, struct task_struct *p,\n\t\t\t\t    enum uclamp_id clamp_id)\n{\n\tstruct uclamp_rq *uc_rq = &rq->uclamp[clamp_id];\n\tstruct uclamp_se *uc_se = &p->uclamp[clamp_id];\n\tstruct uclamp_bucket *bucket;\n\tunsigned int bkt_clamp;\n\tunsigned int rq_clamp;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * If sched_uclamp_used was enabled after task @p was enqueued,\n\t * we could end up with unbalanced call to uclamp_rq_dec_id().\n\t *\n\t * In this case the uc_se->active flag should be false since no uclamp\n\t * accounting was performed at enqueue time and we can just return\n\t * here.\n\t *\n\t * Need to be careful of the following enqueue/dequeue ordering\n\t * problem too\n\t *\n\t *\tenqueue(taskA)\n\t *\t// sched_uclamp_used gets enabled\n\t *\tenqueue(taskB)\n\t *\tdequeue(taskA)\n\t *\t// Must not decrement bucket->tasks here\n\t *\tdequeue(taskB)\n\t *\n\t * where we could end up with stale data in uc_se and\n\t * bucket[uc_se->bucket_id].\n\t *\n\t * The following check here eliminates the possibility of such race.\n\t */\n\tif (unlikely(!uc_se->active))\n\t\treturn;\n\n\tbucket = &uc_rq->bucket[uc_se->bucket_id];\n\n\tSCHED_WARN_ON(!bucket->tasks);\n\tif (likely(bucket->tasks))\n\t\tbucket->tasks--;\n\n\tuc_se->active = false;\n\n\t/*\n\t * Keep \"local max aggregation\" simple and accept to (possibly)\n\t * overboost some RUNNABLE tasks in the same bucket.\n\t * The rq clamp bucket value is reset to its base value whenever\n\t * there are no more RUNNABLE tasks refcounting it.\n\t */\n\tif (likely(bucket->tasks))\n\t\treturn;\n\n\trq_clamp = READ_ONCE(uc_rq->value);\n\t/*\n\t * Defensive programming: this should never happen. If it happens,\n\t * e.g. due to future modification, warn and fixup the expected value.\n\t */\n\tSCHED_WARN_ON(bucket->value > rq_clamp);\n\tif (bucket->value >= rq_clamp) {\n\t\tbkt_clamp = uclamp_rq_max_value(rq, clamp_id, uc_se->value);\n\t\tWRITE_ONCE(uc_rq->value, bkt_clamp);\n\t}\n}\n\nstatic inline void uclamp_rq_inc(struct rq *rq, struct task_struct *p)\n{\n\tenum uclamp_id clamp_id;\n\n\t/*\n\t * Avoid any overhead until uclamp is actually used by the userspace.\n\t *\n\t * The condition is constructed such that a NOP is generated when\n\t * sched_uclamp_used is disabled.\n\t */\n\tif (!static_branch_unlikely(&sched_uclamp_used))\n\t\treturn;\n\n\tif (unlikely(!p->sched_class->uclamp_enabled))\n\t\treturn;\n\n\tfor_each_clamp_id(clamp_id)\n\t\tuclamp_rq_inc_id(rq, p, clamp_id);\n\n\t/* Reset clamp idle holding when there is one RUNNABLE task */\n\tif (rq->uclamp_flags & UCLAMP_FLAG_IDLE)\n\t\trq->uclamp_flags &= ~UCLAMP_FLAG_IDLE;\n}\n\nstatic inline void uclamp_rq_dec(struct rq *rq, struct task_struct *p)\n{\n\tenum uclamp_id clamp_id;\n\n\t/*\n\t * Avoid any overhead until uclamp is actually used by the userspace.\n\t *\n\t * The condition is constructed such that a NOP is generated when\n\t * sched_uclamp_used is disabled.\n\t */\n\tif (!static_branch_unlikely(&sched_uclamp_used))\n\t\treturn;\n\n\tif (unlikely(!p->sched_class->uclamp_enabled))\n\t\treturn;\n\n\tfor_each_clamp_id(clamp_id)\n\t\tuclamp_rq_dec_id(rq, p, clamp_id);\n}\n\nstatic inline void\nuclamp_update_active(struct task_struct *p, enum uclamp_id clamp_id)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\t/*\n\t * Lock the task and the rq where the task is (or was) queued.\n\t *\n\t * We might lock the (previous) rq of a !RUNNABLE task, but that's the\n\t * price to pay to safely serialize util_{min,max} updates with\n\t * enqueues, dequeues and migration operations.\n\t * This is the same locking schema used by __set_cpus_allowed_ptr().\n\t */\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * Setting the clamp bucket is serialized by task_rq_lock().\n\t * If the task is not yet RUNNABLE and its task_struct is not\n\t * affecting a valid clamp bucket, the next time it's enqueued,\n\t * it will already see the updated clamp bucket value.\n\t */\n\tif (p->uclamp[clamp_id].active) {\n\t\tuclamp_rq_dec_id(rq, p, clamp_id);\n\t\tuclamp_rq_inc_id(rq, p, clamp_id);\n\t}\n\n\ttask_rq_unlock(rq, p, &rf);\n}\n\n#ifdef CONFIG_UCLAMP_TASK_GROUP\nstatic inline void\nuclamp_update_active_tasks(struct cgroup_subsys_state *css,\n\t\t\t   unsigned int clamps)\n{\n\tenum uclamp_id clamp_id;\n\tstruct css_task_iter it;\n\tstruct task_struct *p;\n\n\tcss_task_iter_start(css, 0, &it);\n\twhile ((p = css_task_iter_next(&it))) {\n\t\tfor_each_clamp_id(clamp_id) {\n\t\t\tif ((0x1 << clamp_id) & clamps)\n\t\t\t\tuclamp_update_active(p, clamp_id);\n\t\t}\n\t}\n\tcss_task_iter_end(&it);\n}\n\nstatic void cpu_util_update_eff(struct cgroup_subsys_state *css);\nstatic void uclamp_update_root_tg(void)\n{\n\tstruct task_group *tg = &root_task_group;\n\n\tuclamp_se_set(&tg->uclamp_req[UCLAMP_MIN],\n\t\t      sysctl_sched_uclamp_util_min, false);\n\tuclamp_se_set(&tg->uclamp_req[UCLAMP_MAX],\n\t\t      sysctl_sched_uclamp_util_max, false);\n\n\trcu_read_lock();\n\tcpu_util_update_eff(&root_task_group.css);\n\trcu_read_unlock();\n}\n#else\nstatic void uclamp_update_root_tg(void) { }\n#endif\n\nint sysctl_sched_uclamp_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tbool update_root_tg = false;\n\tint old_min, old_max, old_min_rt;\n\tint result;\n\n\tmutex_lock(&uclamp_mutex);\n\told_min = sysctl_sched_uclamp_util_min;\n\told_max = sysctl_sched_uclamp_util_max;\n\told_min_rt = sysctl_sched_uclamp_util_min_rt_default;\n\n\tresult = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (result)\n\t\tgoto undo;\n\tif (!write)\n\t\tgoto done;\n\n\tif (sysctl_sched_uclamp_util_min > sysctl_sched_uclamp_util_max ||\n\t    sysctl_sched_uclamp_util_max > SCHED_CAPACITY_SCALE\t||\n\t    sysctl_sched_uclamp_util_min_rt_default > SCHED_CAPACITY_SCALE) {\n\n\t\tresult = -EINVAL;\n\t\tgoto undo;\n\t}\n\n\tif (old_min != sysctl_sched_uclamp_util_min) {\n\t\tuclamp_se_set(&uclamp_default[UCLAMP_MIN],\n\t\t\t      sysctl_sched_uclamp_util_min, false);\n\t\tupdate_root_tg = true;\n\t}\n\tif (old_max != sysctl_sched_uclamp_util_max) {\n\t\tuclamp_se_set(&uclamp_default[UCLAMP_MAX],\n\t\t\t      sysctl_sched_uclamp_util_max, false);\n\t\tupdate_root_tg = true;\n\t}\n\n\tif (update_root_tg) {\n\t\tstatic_branch_enable(&sched_uclamp_used);\n\t\tuclamp_update_root_tg();\n\t}\n\n\tif (old_min_rt != sysctl_sched_uclamp_util_min_rt_default) {\n\t\tstatic_branch_enable(&sched_uclamp_used);\n\t\tuclamp_sync_util_min_rt_default();\n\t}\n\n\t/*\n\t * We update all RUNNABLE tasks only when task groups are in use.\n\t * Otherwise, keep it simple and do just a lazy update at each next\n\t * task enqueue time.\n\t */\n\n\tgoto done;\n\nundo:\n\tsysctl_sched_uclamp_util_min = old_min;\n\tsysctl_sched_uclamp_util_max = old_max;\n\tsysctl_sched_uclamp_util_min_rt_default = old_min_rt;\ndone:\n\tmutex_unlock(&uclamp_mutex);\n\n\treturn result;\n}\n\nstatic int uclamp_validate(struct task_struct *p,\n\t\t\t   const struct sched_attr *attr)\n{\n\tint util_min = p->uclamp_req[UCLAMP_MIN].value;\n\tint util_max = p->uclamp_req[UCLAMP_MAX].value;\n\n\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MIN) {\n\t\tutil_min = attr->sched_util_min;\n\n\t\tif (util_min + 1 > SCHED_CAPACITY_SCALE + 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MAX) {\n\t\tutil_max = attr->sched_util_max;\n\n\t\tif (util_max + 1 > SCHED_CAPACITY_SCALE + 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (util_min != -1 && util_max != -1 && util_min > util_max)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We have valid uclamp attributes; make sure uclamp is enabled.\n\t *\n\t * We need to do that here, because enabling static branches is a\n\t * blocking operation which obviously cannot be done while holding\n\t * scheduler locks.\n\t */\n\tstatic_branch_enable(&sched_uclamp_used);\n\n\treturn 0;\n}\n\nstatic bool uclamp_reset(const struct sched_attr *attr,\n\t\t\t enum uclamp_id clamp_id,\n\t\t\t struct uclamp_se *uc_se)\n{\n\t/* Reset on sched class change for a non user-defined clamp value. */\n\tif (likely(!(attr->sched_flags & SCHED_FLAG_UTIL_CLAMP)) &&\n\t    !uc_se->user_defined)\n\t\treturn true;\n\n\t/* Reset on sched_util_{min,max} == -1. */\n\tif (clamp_id == UCLAMP_MIN &&\n\t    attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MIN &&\n\t    attr->sched_util_min == -1) {\n\t\treturn true;\n\t}\n\n\tif (clamp_id == UCLAMP_MAX &&\n\t    attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MAX &&\n\t    attr->sched_util_max == -1) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void __setscheduler_uclamp(struct task_struct *p,\n\t\t\t\t  const struct sched_attr *attr)\n{\n\tenum uclamp_id clamp_id;\n\n\tfor_each_clamp_id(clamp_id) {\n\t\tstruct uclamp_se *uc_se = &p->uclamp_req[clamp_id];\n\t\tunsigned int value;\n\n\t\tif (!uclamp_reset(attr, clamp_id, uc_se))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * RT by default have a 100% boost value that could be modified\n\t\t * at runtime.\n\t\t */\n\t\tif (unlikely(rt_task(p) && clamp_id == UCLAMP_MIN))\n\t\t\tvalue = sysctl_sched_uclamp_util_min_rt_default;\n\t\telse\n\t\t\tvalue = uclamp_none(clamp_id);\n\n\t\tuclamp_se_set(uc_se, value, false);\n\n\t}\n\n\tif (likely(!(attr->sched_flags & SCHED_FLAG_UTIL_CLAMP)))\n\t\treturn;\n\n\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MIN &&\n\t    attr->sched_util_min != -1) {\n\t\tuclamp_se_set(&p->uclamp_req[UCLAMP_MIN],\n\t\t\t      attr->sched_util_min, true);\n\t}\n\n\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP_MAX &&\n\t    attr->sched_util_max != -1) {\n\t\tuclamp_se_set(&p->uclamp_req[UCLAMP_MAX],\n\t\t\t      attr->sched_util_max, true);\n\t}\n}\n\nstatic void uclamp_fork(struct task_struct *p)\n{\n\tenum uclamp_id clamp_id;\n\n\t/*\n\t * We don't need to hold task_rq_lock() when updating p->uclamp_* here\n\t * as the task is still at its early fork stages.\n\t */\n\tfor_each_clamp_id(clamp_id)\n\t\tp->uclamp[clamp_id].active = false;\n\n\tif (likely(!p->sched_reset_on_fork))\n\t\treturn;\n\n\tfor_each_clamp_id(clamp_id) {\n\t\tuclamp_se_set(&p->uclamp_req[clamp_id],\n\t\t\t      uclamp_none(clamp_id), false);\n\t}\n}\n\nstatic void uclamp_post_fork(struct task_struct *p)\n{\n\tuclamp_update_util_min_rt_default(p);\n}\n\nstatic void __init init_uclamp_rq(struct rq *rq)\n{\n\tenum uclamp_id clamp_id;\n\tstruct uclamp_rq *uc_rq = rq->uclamp;\n\n\tfor_each_clamp_id(clamp_id) {\n\t\tuc_rq[clamp_id] = (struct uclamp_rq) {\n\t\t\t.value = uclamp_none(clamp_id)\n\t\t};\n\t}\n\n\trq->uclamp_flags = 0;\n}\n\nstatic void __init init_uclamp(void)\n{\n\tstruct uclamp_se uc_max = {};\n\tenum uclamp_id clamp_id;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinit_uclamp_rq(cpu_rq(cpu));\n\n\tfor_each_clamp_id(clamp_id) {\n\t\tuclamp_se_set(&init_task.uclamp_req[clamp_id],\n\t\t\t      uclamp_none(clamp_id), false);\n\t}\n\n\t/* System defaults allow max clamp values for both indexes */\n\tuclamp_se_set(&uc_max, uclamp_none(UCLAMP_MAX), false);\n\tfor_each_clamp_id(clamp_id) {\n\t\tuclamp_default[clamp_id] = uc_max;\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\t\troot_task_group.uclamp_req[clamp_id] = uc_max;\n\t\troot_task_group.uclamp[clamp_id] = uc_max;\n#endif\n\t}\n}\n\n#else /* CONFIG_UCLAMP_TASK */\nstatic inline void uclamp_rq_inc(struct rq *rq, struct task_struct *p) { }\nstatic inline void uclamp_rq_dec(struct rq *rq, struct task_struct *p) { }\nstatic inline int uclamp_validate(struct task_struct *p,\n\t\t\t\t  const struct sched_attr *attr)\n{\n\treturn -EOPNOTSUPP;\n}\nstatic void __setscheduler_uclamp(struct task_struct *p,\n\t\t\t\t  const struct sched_attr *attr) { }\nstatic inline void uclamp_fork(struct task_struct *p) { }\nstatic inline void uclamp_post_fork(struct task_struct *p) { }\nstatic inline void init_uclamp(void) { }\n#endif /* CONFIG_UCLAMP_TASK */\n\nstatic inline void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & ENQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & ENQUEUE_RESTORE)) {\n\t\tsched_info_queued(rq, p);\n\t\tpsi_enqueue(p, flags & ENQUEUE_WAKEUP);\n\t}\n\n\tuclamp_rq_inc(rq, p);\n\tp->sched_class->enqueue_task(rq, p, flags);\n}\n\nstatic inline void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (!(flags & DEQUEUE_NOCLOCK))\n\t\tupdate_rq_clock(rq);\n\n\tif (!(flags & DEQUEUE_SAVE)) {\n\t\tsched_info_dequeued(rq, p);\n\t\tpsi_dequeue(p, flags & DEQUEUE_SLEEP);\n\t}\n\n\tuclamp_rq_dec(rq, p);\n\tp->sched_class->dequeue_task(rq, p, flags);\n}\n\nvoid activate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tenqueue_task(rq, p, flags);\n\n\tp->on_rq = TASK_ON_RQ_QUEUED;\n}\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tp->on_rq = (flags & DEQUEUE_SLEEP) ? 0 : TASK_ON_RQ_MIGRATING;\n\n\tdequeue_task(rq, p, flags);\n}\n\n/*\n * __normal_prio - return the priority that is based on the static prio\n */\nstatic inline int __normal_prio(struct task_struct *p)\n{\n\treturn p->static_prio;\n}\n\n/*\n * Calculate the expected normal priority: i.e. priority\n * without taking RT-inheritance into account. Might be\n * boosted by interactivity modifiers. Changes upon fork,\n * setprio syscalls, and whenever the interactivity\n * estimator recalculates.\n */\nstatic inline int normal_prio(struct task_struct *p)\n{\n\tint prio;\n\n\tif (task_has_dl_policy(p))\n\t\tprio = MAX_DL_PRIO-1;\n\telse if (task_has_rt_policy(p))\n\t\tprio = MAX_RT_PRIO-1 - p->rt_priority;\n\telse\n\t\tprio = __normal_prio(p);\n\treturn prio;\n}\n\n/*\n * Calculate the current priority, i.e. the priority\n * taken into account by the scheduler. This value might\n * be boosted by RT tasks, or might be boosted by\n * interactivity modifiers. Will be RT if the task got\n * RT-boosted. If not then it returns p->normal_prio.\n */\nstatic int effective_prio(struct task_struct *p)\n{\n\tp->normal_prio = normal_prio(p);\n\t/*\n\t * If we are RT tasks or we were boosted to RT priority,\n\t * keep the priority unchanged. Otherwise, update priority\n\t * to the normal priority:\n\t */\n\tif (!rt_prio(p->prio))\n\t\treturn p->normal_prio;\n\treturn p->prio;\n}\n\n/**\n * task_curr - is this task currently executing on a CPU?\n * @p: the task in question.\n *\n * Return: 1 if the task is currently executing. 0 otherwise.\n */\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}\n\n/*\n * switched_from, switched_to and prio_changed must _NOT_ drop rq->lock,\n * use the balance_callback list if you want balancing.\n *\n * this means any call to check_class_changed() must be followed by a call to\n * balance_callback().\n */\nstatic inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}\n\nvoid check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (p->sched_class == rq->curr->sched_class)\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\telse if (p->sched_class > rq->curr->sched_class)\n\t\tresched_curr(rq);\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (task_on_rq_queued(rq->curr) && test_tsk_need_resched(rq->curr))\n\t\trq_clock_skip_update(rq);\n}\n\n#ifdef CONFIG_SMP\n\nstatic void\n__do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask, u32 flags);\n\nstatic int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t  const struct cpumask *new_mask,\n\t\t\t\t  u32 flags);\n\nstatic void migrate_disable_switch(struct rq *rq, struct task_struct *p)\n{\n\tif (likely(!p->migration_disabled))\n\t\treturn;\n\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\treturn;\n\n\t/*\n\t * Violates locking rules! see comment in __do_set_cpus_allowed().\n\t */\n\t__do_set_cpus_allowed(p, cpumask_of(rq->cpu), SCA_MIGRATE_DISABLE);\n}\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}\nEXPORT_SYMBOL_GPL(migrate_disable);\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}\nEXPORT_SYMBOL_GPL(migrate_enable);\n\nstatic inline bool rq_has_pinned_tasks(struct rq *rq)\n{\n\treturn rq->nr_pinned;\n}\n\n/*\n * Per-CPU kthreads are allowed to run on !active && online CPUs, see\n * __set_cpus_allowed_ptr() and select_fallback_rq().\n */\nstatic inline bool is_cpu_allowed(struct task_struct *p, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, p->cpus_ptr))\n\t\treturn false;\n\n\tif (is_per_cpu_kthread(p) || is_migration_disabled(p))\n\t\treturn cpu_online(cpu);\n\n\treturn cpu_active(cpu);\n}\n\n/*\n * This is how migration works:\n *\n * 1) we invoke migration_cpu_stop() on the target CPU using\n *    stop_one_cpu().\n * 2) stopper starts to run (implicitly forcing the migrated thread\n *    off the CPU)\n * 3) it checks whether the migrated task is still in the wrong runqueue.\n * 4) if it's in the wrong runqueue then the migration thread removes\n *    it and puts it into the right queue.\n * 5) stopper completes and stop_one_cpu() returns and the migration\n *    is done.\n */\n\n/*\n * move_queued_task - move a queued task to new rq.\n *\n * Returns (locked) new rq. Old rq's lock is released.\n */\nstatic struct rq *move_queued_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t   struct task_struct *p, int new_cpu)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tdeactivate_task(rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, new_cpu);\n\trq_unlock(rq, rf);\n\n\trq = cpu_rq(new_cpu);\n\n\trq_lock(rq, rf);\n\tBUG_ON(task_cpu(p) != new_cpu);\n\tactivate_task(rq, p, 0);\n\tcheck_preempt_curr(rq, p, 0);\n\n\treturn rq;\n}\n\nstruct migration_arg {\n\tstruct task_struct\t\t*task;\n\tint\t\t\t\tdest_cpu;\n\tstruct set_affinity_pending\t*pending;\n};\n\nstruct set_affinity_pending {\n\trefcount_t\t\trefs;\n\tstruct completion\tdone;\n\tstruct cpu_stop_work\tstop_work;\n\tstruct migration_arg\targ;\n};\n\n/*\n * Move (not current) task off this CPU, onto the destination CPU. We're doing\n * this because either it can't run here any more (set_cpus_allowed()\n * away from this CPU, or CPU going down), or because we're\n * attempting to rebalance this task on exec (sched_exec).\n *\n * So we race with normal scheduler movements, but that's OK, as long\n * as the task is no longer on this CPU.\n */\nstatic struct rq *__migrate_task(struct rq *rq, struct rq_flags *rf,\n\t\t\t\t struct task_struct *p, int dest_cpu)\n{\n\t/* Affinity changed (again). */\n\tif (!is_cpu_allowed(p, dest_cpu))\n\t\treturn rq;\n\n\tupdate_rq_clock(rq);\n\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\treturn rq;\n}\n\n/*\n * migration_cpu_stop - this will be executed by a highprio stopper thread\n * and performs thread migration by bumping thread off CPU then\n * 'pushing' onto another runqueue.\n */\nstatic int migration_cpu_stop(void *data)\n{\n\tstruct set_affinity_pending *pending;\n\tstruct migration_arg *arg = data;\n\tstruct task_struct *p = arg->task;\n\tint dest_cpu = arg->dest_cpu;\n\tstruct rq *rq = this_rq();\n\tbool complete = false;\n\tstruct rq_flags rf;\n\n\t/*\n\t * The original target CPU might have gone down and we might\n\t * be on another CPU but it doesn't matter.\n\t */\n\tlocal_irq_save(rf.flags);\n\t/*\n\t * We need to explicitly wake pending tasks before running\n\t * __migrate_task() such that we will not miss enforcing cpus_ptr\n\t * during wakeups, see set_cpus_allowed_ptr()'s TASK_WAKING test.\n\t */\n\tflush_smp_call_function_from_idle();\n\n\traw_spin_lock(&p->pi_lock);\n\trq_lock(rq, &rf);\n\n\tpending = p->migration_pending;\n\t/*\n\t * If task_rq(p) != rq, it cannot be migrated here, because we're\n\t * holding rq->lock, if p->on_rq == 0 it cannot get enqueued because\n\t * we're holding p->pi_lock.\n\t */\n\tif (task_rq(p) == rq) {\n\t\tif (is_migration_disabled(p))\n\t\t\tgoto out;\n\n\t\tif (pending) {\n\t\t\tp->migration_pending = NULL;\n\t\t\tcomplete = true;\n\t\t}\n\n\t\t/* migrate_enable() --  we must not race against SCA */\n\t\tif (dest_cpu < 0) {\n\t\t\t/*\n\t\t\t * When this was migrate_enable() but we no longer\n\t\t\t * have a @pending, a concurrent SCA 'fixed' things\n\t\t\t * and we should be valid again. Nothing to do.\n\t\t\t */\n\t\t\tif (!pending) {\n\t\t\t\tWARN_ON_ONCE(!cpumask_test_cpu(task_cpu(p), &p->cpus_mask));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdest_cpu = cpumask_any_distribute(&p->cpus_mask);\n\t\t}\n\n\t\tif (task_on_rq_queued(p))\n\t\t\trq = __migrate_task(rq, &rf, p, dest_cpu);\n\t\telse\n\t\t\tp->wake_cpu = dest_cpu;\n\n\t} else if (dest_cpu < 0 || pending) {\n\t\t/*\n\t\t * This happens when we get migrated between migrate_enable()'s\n\t\t * preempt_enable() and scheduling the stopper task. At that\n\t\t * point we're a regular task again and not current anymore.\n\t\t *\n\t\t * A !PREEMPT kernel has a giant hole here, which makes it far\n\t\t * more likely.\n\t\t */\n\n\t\t/*\n\t\t * The task moved before the stopper got to run. We're holding\n\t\t * ->pi_lock, so the allowed mask is stable - if it got\n\t\t * somewhere allowed, we're done.\n\t\t */\n\t\tif (pending && cpumask_test_cpu(task_cpu(p), p->cpus_ptr)) {\n\t\t\tp->migration_pending = NULL;\n\t\t\tcomplete = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * When this was migrate_enable() but we no longer have an\n\t\t * @pending, a concurrent SCA 'fixed' things and we should be\n\t\t * valid again. Nothing to do.\n\t\t */\n\t\tif (!pending) {\n\t\t\tWARN_ON_ONCE(!cpumask_test_cpu(task_cpu(p), &p->cpus_mask));\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * When migrate_enable() hits a rq mis-match we can't reliably\n\t\t * determine is_migration_disabled() and so have to chase after\n\t\t * it.\n\t\t */\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tstop_one_cpu_nowait(task_cpu(p), migration_cpu_stop,\n\t\t\t\t    &pending->arg, &pending->stop_work);\n\t\treturn 0;\n\t}\nout:\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (complete)\n\t\tcomplete_all(&pending->done);\n\n\t/* For pending->{arg,stop_work} */\n\tpending = arg->pending;\n\tif (pending && refcount_dec_and_test(&pending->refs))\n\t\twake_up_var(&pending->refs);\n\n\treturn 0;\n}\n\nint push_cpu_stop(void *arg)\n{\n\tstruct rq *lowest_rq = NULL, *rq = this_rq();\n\tstruct task_struct *p = arg;\n\n\traw_spin_lock_irq(&p->pi_lock);\n\traw_spin_lock(&rq->lock);\n\n\tif (task_rq(p) != rq)\n\t\tgoto out_unlock;\n\n\tif (is_migration_disabled(p)) {\n\t\tp->migration_flags |= MDF_PUSH;\n\t\tgoto out_unlock;\n\t}\n\n\tp->migration_flags &= ~MDF_PUSH;\n\n\tif (p->sched_class->find_lock_rq)\n\t\tlowest_rq = p->sched_class->find_lock_rq(p, rq);\n\n\tif (!lowest_rq)\n\t\tgoto out_unlock;\n\n\t// XXX validate p is still the highest prio task\n\tif (task_rq(p) == rq) {\n\t\tdeactivate_task(rq, p, 0);\n\t\tset_task_cpu(p, lowest_rq->cpu);\n\t\tactivate_task(lowest_rq, p, 0);\n\t\tresched_curr(lowest_rq);\n\t}\n\n\tdouble_unlock_balance(rq, lowest_rq);\n\nout_unlock:\n\trq->push_busy = false;\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\treturn 0;\n}\n\n/*\n * sched_class::set_cpus_allowed must do the below, but is not required to\n * actually call this function.\n */\nvoid set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask, u32 flags)\n{\n\tif (flags & (SCA_MIGRATE_ENABLE | SCA_MIGRATE_DISABLE)) {\n\t\tp->cpus_ptr = new_mask;\n\t\treturn;\n\t}\n\n\tcpumask_copy(&p->cpus_mask, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}\n\nstatic void\n__do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask, u32 flags)\n{\n\tstruct rq *rq = task_rq(p);\n\tbool queued, running;\n\n\t/*\n\t * This here violates the locking rules for affinity, since we're only\n\t * supposed to change these variables while holding both rq->lock and\n\t * p->pi_lock.\n\t *\n\t * HOWEVER, it magically works, because ttwu() is the only code that\n\t * accesses these variables under p->pi_lock and only does so after\n\t * smp_cond_load_acquire(&p->on_cpu, !VAL), and we're in __schedule()\n\t * before finish_task().\n\t *\n\t * XXX do further audits, this smells like something putrid.\n\t */\n\tif (flags & SCA_MIGRATE_DISABLE)\n\t\tSCHED_WARN_ON(!p->on_cpu);\n\telse\n\t\tlockdep_assert_held(&p->pi_lock);\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued) {\n\t\t/*\n\t\t * Because __kthread_bind() calls this on blocked tasks without\n\t\t * holding rq->lock.\n\t\t */\n\t\tlockdep_assert_held(&rq->lock);\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\t}\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->sched_class->set_cpus_allowed(p, new_mask, flags);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n}\n\nvoid do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\t__do_set_cpus_allowed(p, new_mask, 0);\n}\n\n/*\n * This function is wildly self concurrent; here be dragons.\n *\n *\n * When given a valid mask, __set_cpus_allowed_ptr() must block until the\n * designated task is enqueued on an allowed CPU. If that task is currently\n * running, we have to kick it out using the CPU stopper.\n *\n * Migrate-Disable comes along and tramples all over our nice sandcastle.\n * Consider:\n *\n *     Initial conditions: P0->cpus_mask = [0, 1]\n *\n *     P0@CPU0                  P1\n *\n *     migrate_disable();\n *     <preempted>\n *                              set_cpus_allowed_ptr(P0, [1]);\n *\n * P1 *cannot* return from this set_cpus_allowed_ptr() call until P0 executes\n * its outermost migrate_enable() (i.e. it exits its Migrate-Disable region).\n * This means we need the following scheme:\n *\n *     P0@CPU0                  P1\n *\n *     migrate_disable();\n *     <preempted>\n *                              set_cpus_allowed_ptr(P0, [1]);\n *                                <blocks>\n *     <resumes>\n *     migrate_enable();\n *       __set_cpus_allowed_ptr();\n *       <wakes local stopper>\n *                         `--> <woken on migration completion>\n *\n * Now the fun stuff: there may be several P1-like tasks, i.e. multiple\n * concurrent set_cpus_allowed_ptr(P0, [*]) calls. CPU affinity changes of any\n * task p are serialized by p->pi_lock, which we can leverage: the one that\n * should come into effect at the end of the Migrate-Disable region is the last\n * one. This means we only need to track a single cpumask (i.e. p->cpus_mask),\n * but we still need to properly signal those waiting tasks at the appropriate\n * moment.\n *\n * This is implemented using struct set_affinity_pending. The first\n * __set_cpus_allowed_ptr() caller within a given Migrate-Disable region will\n * setup an instance of that struct and install it on the targeted task_struct.\n * Any and all further callers will reuse that instance. Those then wait for\n * a completion signaled at the tail of the CPU stopper callback (1), triggered\n * on the end of the Migrate-Disable region (i.e. outermost migrate_enable()).\n *\n *\n * (1) In the cases covered above. There is one more where the completion is\n * signaled within affine_move_task() itself: when a subsequent affinity request\n * cancels the need for an active migration. Consider:\n *\n *     Initial conditions: P0->cpus_mask = [0, 1]\n *\n *     P0@CPU0            P1                             P2\n *\n *     migrate_disable();\n *     <preempted>\n *                        set_cpus_allowed_ptr(P0, [1]);\n *                          <blocks>\n *                                                       set_cpus_allowed_ptr(P0, [0, 1]);\n *                                                         <signal completion>\n *                          <awakes>\n *\n * Note that the above is safe vs a concurrent migrate_enable(), as any\n * pending affinity completion is preceded by an uninstallation of\n * p->migration_pending done with p->pi_lock held.\n */\nstatic int affine_move_task(struct rq *rq, struct task_struct *p, struct rq_flags *rf,\n\t\t\t    int dest_cpu, unsigned int flags)\n{\n\tstruct set_affinity_pending my_pending = { }, *pending = NULL;\n\tstruct migration_arg arg = {\n\t\t.task = p,\n\t\t.dest_cpu = dest_cpu,\n\t};\n\tbool complete = false;\n\n\t/* Can the task run on the task's current CPU? If so, we're done */\n\tif (cpumask_test_cpu(task_cpu(p), &p->cpus_mask)) {\n\t\tstruct task_struct *push_task = NULL;\n\n\t\tif ((flags & SCA_MIGRATE_ENABLE) &&\n\t\t    (p->migration_flags & MDF_PUSH) && !rq->push_busy) {\n\t\t\trq->push_busy = true;\n\t\t\tpush_task = get_task_struct(p);\n\t\t}\n\n\t\tpending = p->migration_pending;\n\t\tif (pending) {\n\t\t\trefcount_inc(&pending->refs);\n\t\t\tp->migration_pending = NULL;\n\t\t\tcomplete = true;\n\t\t}\n\t\ttask_rq_unlock(rq, p, rf);\n\n\t\tif (push_task) {\n\t\t\tstop_one_cpu_nowait(rq->cpu, push_cpu_stop,\n\t\t\t\t\t    p, &rq->push_work);\n\t\t}\n\n\t\tif (complete)\n\t\t\tgoto do_complete;\n\n\t\treturn 0;\n\t}\n\n\tif (!(flags & SCA_MIGRATE_ENABLE)) {\n\t\t/* serialized by p->pi_lock */\n\t\tif (!p->migration_pending) {\n\t\t\t/* Install the request */\n\t\t\trefcount_set(&my_pending.refs, 1);\n\t\t\tinit_completion(&my_pending.done);\n\t\t\tp->migration_pending = &my_pending;\n\t\t} else {\n\t\t\tpending = p->migration_pending;\n\t\t\trefcount_inc(&pending->refs);\n\t\t}\n\t}\n\tpending = p->migration_pending;\n\t/*\n\t * - !MIGRATE_ENABLE:\n\t *   we'll have installed a pending if there wasn't one already.\n\t *\n\t * - MIGRATE_ENABLE:\n\t *   we're here because the current CPU isn't matching anymore,\n\t *   the only way that can happen is because of a concurrent\n\t *   set_cpus_allowed_ptr() call, which should then still be\n\t *   pending completion.\n\t *\n\t * Either way, we really should have a @pending here.\n\t */\n\tif (WARN_ON_ONCE(!pending)) {\n\t\ttask_rq_unlock(rq, p, rf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & SCA_MIGRATE_ENABLE) {\n\n\t\trefcount_inc(&pending->refs); /* pending->{arg,stop_work} */\n\t\tp->migration_flags &= ~MDF_PUSH;\n\t\ttask_rq_unlock(rq, p, rf);\n\n\t\tpending->arg = (struct migration_arg) {\n\t\t\t.task = p,\n\t\t\t.dest_cpu = -1,\n\t\t\t.pending = pending,\n\t\t};\n\n\t\tstop_one_cpu_nowait(cpu_of(rq), migration_cpu_stop,\n\t\t\t\t    &pending->arg, &pending->stop_work);\n\n\t\treturn 0;\n\t}\n\n\tif (task_running(rq, p) || p->state == TASK_WAKING) {\n\t\t/*\n\t\t * Lessen races (and headaches) by delegating\n\t\t * is_migration_disabled(p) checks to the stopper, which will\n\t\t * run on the same CPU as said p.\n\t\t */\n\t\ttask_rq_unlock(rq, p, rf);\n\t\tstop_one_cpu(cpu_of(rq), migration_cpu_stop, &arg);\n\n\t} else {\n\n\t\tif (!is_migration_disabled(p)) {\n\t\t\tif (task_on_rq_queued(p))\n\t\t\t\trq = move_queued_task(rq, rf, p, dest_cpu);\n\n\t\t\tp->migration_pending = NULL;\n\t\t\tcomplete = true;\n\t\t}\n\t\ttask_rq_unlock(rq, p, rf);\n\ndo_complete:\n\t\tif (complete)\n\t\t\tcomplete_all(&pending->done);\n\t}\n\n\twait_for_completion(&pending->done);\n\n\tif (refcount_dec_and_test(&pending->refs))\n\t\twake_up_var(&pending->refs);\n\n\t/*\n\t * Block the original owner of &pending until all subsequent callers\n\t * have seen the completion and decremented the refcount\n\t */\n\twait_var_event(&my_pending.refs, !refcount_read(&my_pending.refs));\n\n\treturn 0;\n}\n\n/*\n * Change a given task's CPU affinity. Migrate the thread to a\n * proper CPU and schedule it away if the CPU it's executing on\n * is removed from the allowed bitmask.\n *\n * NOTE: the caller must have a valid reference to the task, the\n * task must not exit() & deallocate itself prematurely. The\n * call is not atomic; no spinlocks may be held.\n */\nstatic int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t  const struct cpumask *new_mask,\n\t\t\t\t  u32 flags)\n{\n\tconst struct cpumask *cpu_valid_mask = cpu_active_mask;\n\tunsigned int dest_cpu;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\tif (p->flags & PF_KTHREAD || is_migration_disabled(p)) {\n\t\t/*\n\t\t * Kernel threads are allowed on online && !active CPUs.\n\t\t *\n\t\t * Specifically, migration_disabled() tasks must not fail the\n\t\t * cpumask_any_and_distribute() pick below, esp. so on\n\t\t * SCA_MIGRATE_ENABLE, otherwise we'll not call\n\t\t * set_cpus_allowed_common() and actually reset p->cpus_ptr.\n\t\t */\n\t\tcpu_valid_mask = cpu_online_mask;\n\t}\n\n\t/*\n\t * Must re-check here, to close a race against __kthread_bind(),\n\t * sched_setaffinity() is not guaranteed to observe the flag.\n\t */\n\tif ((flags & SCA_CHECK) && (p->flags & PF_NO_SETAFFINITY)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!(flags & SCA_MIGRATE_ENABLE)) {\n\t\tif (cpumask_equal(&p->cpus_mask, new_mask))\n\t\t\tgoto out;\n\n\t\tif (WARN_ON_ONCE(p == current &&\n\t\t\t\t is_migration_disabled(p) &&\n\t\t\t\t !cpumask_test_cpu(task_cpu(p), new_mask))) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Picking a ~random cpu helps in cases where we are changing affinity\n\t * for groups of tasks (ie. cpuset), so that load balancing is not\n\t * immediately required to distribute the tasks within their new mask.\n\t */\n\tdest_cpu = cpumask_any_and_distribute(cpu_valid_mask, new_mask);\n\tif (dest_cpu >= nr_cpu_ids) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t__do_set_cpus_allowed(p, new_mask, flags);\n\n\tif (p->flags & PF_KTHREAD) {\n\t\t/*\n\t\t * For kernel threads that do indeed end up on online &&\n\t\t * !active we want to ensure they are strict per-CPU threads.\n\t\t */\n\t\tWARN_ON(cpumask_intersects(new_mask, cpu_online_mask) &&\n\t\t\t!cpumask_intersects(new_mask, cpu_active_mask) &&\n\t\t\tp->nr_cpus_allowed != 1);\n\t}\n\n\treturn affine_move_task(rq, p, &rf, dest_cpu, flags);\n\nout:\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ret;\n}\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}\nEXPORT_SYMBOL_GPL(set_cpus_allowed_ptr);\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}\n\n#ifdef CONFIG_NUMA_BALANCING\nstatic void __migrate_swap_task(struct task_struct *p, int cpu)\n{\n\tif (task_on_rq_queued(p)) {\n\t\tstruct rq *src_rq, *dst_rq;\n\t\tstruct rq_flags srf, drf;\n\n\t\tsrc_rq = task_rq(p);\n\t\tdst_rq = cpu_rq(cpu);\n\n\t\trq_pin_lock(src_rq, &srf);\n\t\trq_pin_lock(dst_rq, &drf);\n\n\t\tdeactivate_task(src_rq, p, 0);\n\t\tset_task_cpu(p, cpu);\n\t\tactivate_task(dst_rq, p, 0);\n\t\tcheck_preempt_curr(dst_rq, p, 0);\n\n\t\trq_unpin_lock(dst_rq, &drf);\n\t\trq_unpin_lock(src_rq, &srf);\n\n\t} else {\n\t\t/*\n\t\t * Task isn't running anymore; make it appear like we migrated\n\t\t * it before it went to sleep. This means on wakeup we make the\n\t\t * previous CPU our target instead of where it really is.\n\t\t */\n\t\tp->wake_cpu = cpu;\n\t}\n}\n\nstruct migration_swap_arg {\n\tstruct task_struct *src_task, *dst_task;\n\tint src_cpu, dst_cpu;\n};\n\nstatic int migrate_swap_stop(void *data)\n{\n\tstruct migration_swap_arg *arg = data;\n\tstruct rq *src_rq, *dst_rq;\n\tint ret = -EAGAIN;\n\n\tif (!cpu_active(arg->src_cpu) || !cpu_active(arg->dst_cpu))\n\t\treturn -EAGAIN;\n\n\tsrc_rq = cpu_rq(arg->src_cpu);\n\tdst_rq = cpu_rq(arg->dst_cpu);\n\n\tdouble_raw_lock(&arg->src_task->pi_lock,\n\t\t\t&arg->dst_task->pi_lock);\n\tdouble_rq_lock(src_rq, dst_rq);\n\n\tif (task_cpu(arg->dst_task) != arg->dst_cpu)\n\t\tgoto unlock;\n\n\tif (task_cpu(arg->src_task) != arg->src_cpu)\n\t\tgoto unlock;\n\n\tif (!cpumask_test_cpu(arg->dst_cpu, arg->src_task->cpus_ptr))\n\t\tgoto unlock;\n\n\tif (!cpumask_test_cpu(arg->src_cpu, arg->dst_task->cpus_ptr))\n\t\tgoto unlock;\n\n\t__migrate_swap_task(arg->src_task, arg->dst_cpu);\n\t__migrate_swap_task(arg->dst_task, arg->src_cpu);\n\n\tret = 0;\n\nunlock:\n\tdouble_rq_unlock(src_rq, dst_rq);\n\traw_spin_unlock(&arg->dst_task->pi_lock);\n\traw_spin_unlock(&arg->src_task->pi_lock);\n\n\treturn ret;\n}\n\n/*\n * Cross migrate two tasks\n */\nint migrate_swap(struct task_struct *cur, struct task_struct *p,\n\t\tint target_cpu, int curr_cpu)\n{\n\tstruct migration_swap_arg arg;\n\tint ret = -EINVAL;\n\n\targ = (struct migration_swap_arg){\n\t\t.src_task = cur,\n\t\t.src_cpu = curr_cpu,\n\t\t.dst_task = p,\n\t\t.dst_cpu = target_cpu,\n\t};\n\n\tif (arg.src_cpu == arg.dst_cpu)\n\t\tgoto out;\n\n\t/*\n\t * These three tests are all lockless; this is OK since all of them\n\t * will be re-checked with proper locks held further down the line.\n\t */\n\tif (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.dst_cpu, arg.src_task->cpus_ptr))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.src_cpu, arg.dst_task->cpus_ptr))\n\t\tgoto out;\n\n\ttrace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);\n\tret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);\n\nout:\n\treturn ret;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n/*\n * wait_task_inactive - wait for a thread to unschedule.\n *\n * If @match_state is nonzero, it's the @p->state value just checked and\n * not expected to change.  If it changes, i.e. @p might have woken up,\n * then return zero.  When we succeed in waiting for @p to be off its CPU,\n * we return a positive number (its total switch count).  If a second call\n * a short while later returns the same number, the caller can be sure that\n * @p has remained unscheduled the whole time.\n *\n * The caller must ensure that the task *will* unschedule sometime soon,\n * else this function might spin for a *long* time. This function can't\n * be called with interrupts off, or it may introduce deadlock with\n * smp_call_function() if an IPI is sent by the same process we are\n * waiting to become inactive.\n */\nunsigned long wait_task_inactive(struct task_struct *p, long match_state)\n{\n\tint running, queued;\n\tstruct rq_flags rf;\n\tunsigned long ncsw;\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\t/*\n\t\t * We do the initial early heuristics without holding\n\t\t * any task-queue locks at all. We'll only try to get\n\t\t * the runqueue lock when things look like they will\n\t\t * work out!\n\t\t */\n\t\trq = task_rq(p);\n\n\t\t/*\n\t\t * If the task is actively running on another CPU\n\t\t * still, just relax and busy-wait without holding\n\t\t * any locks.\n\t\t *\n\t\t * NOTE! Since we don't hold any locks, it's not\n\t\t * even sure that \"rq\" stays as the right runqueue!\n\t\t * But we don't care, since \"task_running()\" will\n\t\t * return false if the runqueue has changed and p\n\t\t * is actually now running somewhere else!\n\t\t */\n\t\twhile (task_running(rq, p)) {\n\t\t\tif (match_state && unlikely(p->state != match_state))\n\t\t\t\treturn 0;\n\t\t\tcpu_relax();\n\t\t}\n\n\t\t/*\n\t\t * Ok, time to look more closely! We need the rq\n\t\t * lock now, to be *sure*. If we're wrong, we'll\n\t\t * just go back and repeat.\n\t\t */\n\t\trq = task_rq_lock(p, &rf);\n\t\ttrace_sched_wait_task(p);\n\t\trunning = task_running(rq, p);\n\t\tqueued = task_on_rq_queued(p);\n\t\tncsw = 0;\n\t\tif (!match_state || p->state == match_state)\n\t\t\tncsw = p->nvcsw | LONG_MIN; /* sets MSB */\n\t\ttask_rq_unlock(rq, p, &rf);\n\n\t\t/*\n\t\t * If it changed from the expected state, bail out now.\n\t\t */\n\t\tif (unlikely(!ncsw))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Was it really running after all now that we\n\t\t * checked with the proper locks actually held?\n\t\t *\n\t\t * Oops. Go back and try again..\n\t\t */\n\t\tif (unlikely(running)) {\n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * It's not enough that it's not actively running,\n\t\t * it must be off the runqueue _entirely_, and not\n\t\t * preempted!\n\t\t *\n\t\t * So if it was still runnable (but just not actively\n\t\t * running right now), it's preempted, and we should\n\t\t * yield - it could be a while.\n\t\t */\n\t\tif (unlikely(queued)) {\n\t\t\tktime_t to = NSEC_PER_SEC / HZ;\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&to, HRTIMER_MODE_REL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Ahh, all good. It wasn't running, and it wasn't\n\t\t * runnable, which means that it will never become\n\t\t * running in the future either. We're all done!\n\t\t */\n\t\tbreak;\n\t}\n\n\treturn ncsw;\n}\n\n/***\n * kick_process - kick a running thread to enter/exit the kernel\n * @p: the to-be-kicked thread\n *\n * Cause a process which is running on another CPU to enter\n * kernel-mode, without any delay. (to get signals handled.)\n *\n * NOTE: this function doesn't have to take the runqueue lock,\n * because all it wants to ensure is that the remote task enters\n * the kernel. If the IPI races and the task has been migrated\n * to another CPU then no harm is done and the purpose has been\n * achieved as well.\n */\nvoid kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}\nEXPORT_SYMBOL_GPL(kick_process);\n\n/*\n * ->cpus_ptr is protected by both rq->lock and p->pi_lock\n *\n * A few notes on cpu_active vs cpu_online:\n *\n *  - cpu_active must be a subset of cpu_online\n *\n *  - on CPU-up we allow per-CPU kthreads on the online && !active CPU,\n *    see __set_cpus_allowed_ptr(). At this point the newly online\n *    CPU isn't yet part of the sched domains, and balancing will not\n *    see it.\n *\n *  - on CPU-down we clear cpu_active() to mask the sched domains and\n *    avoid the load balancer to place new tasks on the to be removed\n *    CPU. Existing tasks will remain running there and will be taken\n *    off.\n *\n * This means that fallback selection must not select !active CPUs.\n * And can assume that any active CPU must be online. Conversely\n * select_task_rq() below may allow selection of !active CPUs in order\n * to satisfy the above rules.\n */\nstatic int select_fallback_rq(int cpu, struct task_struct *p)\n{\n\tint nid = cpu_to_node(cpu);\n\tconst struct cpumask *nodemask = NULL;\n\tenum { cpuset, possible, fail } state = cpuset;\n\tint dest_cpu;\n\n\t/*\n\t * If the node that the CPU is on has been offlined, cpu_to_node()\n\t * will return -1. There is no CPU on the node, and we should\n\t * select the CPU on the other node.\n\t */\n\tif (nid != -1) {\n\t\tnodemask = cpumask_of_node(nid);\n\n\t\t/* Look for allowed, online CPU in same node. */\n\t\tfor_each_cpu(dest_cpu, nodemask) {\n\t\t\tif (!cpu_active(dest_cpu))\n\t\t\t\tcontinue;\n\t\t\tif (cpumask_test_cpu(dest_cpu, p->cpus_ptr))\n\t\t\t\treturn dest_cpu;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* Any allowed, online CPU? */\n\t\tfor_each_cpu(dest_cpu, p->cpus_ptr) {\n\t\t\tif (!is_cpu_allowed(p, dest_cpu))\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* No more Mr. Nice Guy. */\n\t\tswitch (state) {\n\t\tcase cpuset:\n\t\t\tif (IS_ENABLED(CONFIG_CPUSETS)) {\n\t\t\t\tcpuset_cpus_allowed_fallback(p);\n\t\t\t\tstate = possible;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase possible:\n\t\t\t/*\n\t\t\t * XXX When called from select_task_rq() we only\n\t\t\t * hold p->pi_lock and again violate locking order.\n\t\t\t *\n\t\t\t * More yuck to audit.\n\t\t\t */\n\t\t\tdo_set_cpus_allowed(p, cpu_possible_mask);\n\t\t\tstate = fail;\n\t\t\tbreak;\n\n\t\tcase fail:\n\t\t\tBUG();\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (state != cpuset) {\n\t\t/*\n\t\t * Don't tell them about moving exiting tasks or\n\t\t * kernel threads (both mm NULL), since they never\n\t\t * leave kernel.\n\t\t */\n\t\tif (p->mm && printk_ratelimit()) {\n\t\t\tprintk_deferred(\"process %d (%s) no longer affine to cpu%d\\n\",\n\t\t\t\t\ttask_pid_nr(p), p->comm, cpu);\n\t\t}\n\t}\n\n\treturn dest_cpu;\n}\n\n/*\n * The caller (fork, wakeup) owns p->pi_lock, ->cpus_ptr is stable.\n */\nstatic inline\nint select_task_rq(struct task_struct *p, int cpu, int wake_flags)\n{\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (p->nr_cpus_allowed > 1 && !is_migration_disabled(p))\n\t\tcpu = p->sched_class->select_task_rq(p, cpu, wake_flags);\n\telse\n\t\tcpu = cpumask_any(p->cpus_ptr);\n\n\t/*\n\t * In order not to call set_task_cpu() on a blocking task we need\n\t * to rely on ttwu() to place the task on a valid ->cpus_ptr\n\t * CPU.\n\t *\n\t * Since this is common to all placement strategies, this lives here.\n\t *\n\t * [ this allows ->select_task() to simply return task_cpu(p) and\n\t *   not worry about this generic constraint ]\n\t */\n\tif (unlikely(!is_cpu_allowed(p, cpu)))\n\t\tcpu = select_fallback_rq(task_cpu(p), p);\n\n\treturn cpu;\n}\n\nvoid sched_set_stop_task(int cpu, struct task_struct *stop)\n{\n\tstatic struct lock_class_key stop_pi_lock;\n\tstruct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };\n\tstruct task_struct *old_stop = cpu_rq(cpu)->stop;\n\n\tif (stop) {\n\t\t/*\n\t\t * Make it appear like a SCHED_FIFO task, its something\n\t\t * userspace knows about and won't get confused about.\n\t\t *\n\t\t * Also, it will make PI more or less work without too\n\t\t * much confusion -- but then, stop work should not\n\t\t * rely on PI working anyway.\n\t\t */\n\t\tsched_setscheduler_nocheck(stop, SCHED_FIFO, &param);\n\n\t\tstop->sched_class = &stop_sched_class;\n\n\t\t/*\n\t\t * The PI code calls rt_mutex_setprio() with ->pi_lock held to\n\t\t * adjust the effective priority of a task. As a result,\n\t\t * rt_mutex_setprio() can trigger (RT) balancing operations,\n\t\t * which can then trigger wakeups of the stop thread to push\n\t\t * around the current task.\n\t\t *\n\t\t * The stop task itself will never be part of the PI-chain, it\n\t\t * never blocks, therefore that ->pi_lock recursion is safe.\n\t\t * Tell lockdep about this by placing the stop->pi_lock in its\n\t\t * own class.\n\t\t */\n\t\tlockdep_set_class(&stop->pi_lock, &stop_pi_lock);\n\t}\n\n\tcpu_rq(cpu)->stop = stop;\n\n\tif (old_stop) {\n\t\t/*\n\t\t * Reset it back to a normal scheduling class so that\n\t\t * it can die in pieces.\n\t\t */\n\t\told_stop->sched_class = &rt_sched_class;\n\t}\n}\n\n#else /* CONFIG_SMP */\n\nstatic inline int __set_cpus_allowed_ptr(struct task_struct *p,\n\t\t\t\t\t const struct cpumask *new_mask,\n\t\t\t\t\t u32 flags)\n{\n\treturn set_cpus_allowed_ptr(p, new_mask);\n}\n\nstatic inline void migrate_disable_switch(struct rq *rq, struct task_struct *p) { }\n\nstatic inline bool rq_has_pinned_tasks(struct rq *rq)\n{\n\treturn false;\n}\n\n#endif /* !CONFIG_SMP */\n\nstatic void\nttwu_stat(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\trq = this_rq();\n\n#ifdef CONFIG_SMP\n\tif (cpu == rq->cpu) {\n\t\t__schedstat_inc(rq->ttwu_local);\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_local);\n\t} else {\n\t\tstruct sched_domain *sd;\n\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_remote);\n\t\trcu_read_lock();\n\t\tfor_each_domain(rq->cpu, sd) {\n\t\t\tif (cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\t\t\t__schedstat_inc(sd->ttwu_wake_remote);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (wake_flags & WF_MIGRATED)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_migrate);\n#endif /* CONFIG_SMP */\n\n\t__schedstat_inc(rq->ttwu_count);\n\t__schedstat_inc(p->se.statistics.nr_wakeups);\n\n\tif (wake_flags & WF_SYNC)\n\t\t__schedstat_inc(p->se.statistics.nr_wakeups_sync);\n}\n\n/*\n * Mark the task runnable and perform wakeup-preemption.\n */\nstatic void ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t\t   struct rq_flags *rf)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Our task @p is fully woken up and running; so it's safe to\n\t\t * drop the rq->lock, hereafter rq is only used for statistics.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\n\t\tupdate_avg(&rq->avg_idle, delta);\n\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}\n\nstatic void\nttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags,\n\t\t struct rq_flags *rf)\n{\n\tint en_flags = ENQUEUE_WAKEUP | ENQUEUE_NOCLOCK;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n\n#ifdef CONFIG_SMP\n\tif (wake_flags & WF_MIGRATED)\n\t\ten_flags |= ENQUEUE_MIGRATED;\n\telse\n#endif\n\tif (p->in_iowait) {\n\t\tdelayacct_blkio_end(p);\n\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t}\n\n\tactivate_task(rq, p, en_flags);\n\tttwu_do_wakeup(rq, p, wake_flags, rf);\n}\n\n/*\n * Consider @p being inside a wait loop:\n *\n *   for (;;) {\n *      set_current_state(TASK_UNINTERRUPTIBLE);\n *\n *      if (CONDITION)\n *         break;\n *\n *      schedule();\n *   }\n *   __set_current_state(TASK_RUNNING);\n *\n * between set_current_state() and schedule(). In this case @p is still\n * runnable, so all that needs doing is change p->state back to TASK_RUNNING in\n * an atomic manner.\n *\n * By taking task_rq(p)->lock we serialize against schedule(), if @p->on_rq\n * then schedule() must still happen and p->state can be changed to\n * TASK_RUNNING. Otherwise we lost the race, schedule() has happened, and we\n * need to do a full wakeup with enqueue.\n *\n * Returns: %true when the wakeup is done,\n *          %false otherwise.\n */\nstatic int ttwu_runnable(struct task_struct *p, int wake_flags)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint ret = 0;\n\n\trq = __task_rq_lock(p, &rf);\n\tif (task_on_rq_queued(p)) {\n\t\t/* check_preempt_curr() may use rq clock */\n\t\tupdate_rq_clock(rq);\n\t\tttwu_do_wakeup(rq, p, wake_flags, &rf);\n\t\tret = 1;\n\t}\n\t__task_rq_unlock(rq, &rf);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SMP\nvoid sched_ttwu_pending(void *arg)\n{\n\tstruct llist_node *llist = arg;\n\tstruct rq *rq = this_rq();\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\t/*\n\t * rq::ttwu_pending racy indication of out-standing wakeups.\n\t * Races such that false-negatives are possible, since they\n\t * are shorter lived that false-positives would be.\n\t */\n\tWRITE_ONCE(rq->ttwu_pending, 0);\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry.llist) {\n\t\tif (WARN_ON_ONCE(p->on_cpu))\n\t\t\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\t\tif (WARN_ON_ONCE(task_cpu(p) != cpu_of(rq)))\n\t\t\tset_task_cpu(p, cpu_of(rq));\n\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\t}\n\n\trq_unlock_irqrestore(rq, &rf);\n}\n\nvoid send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}\n\n/*\n * Queue a task on the target CPUs wake_list and wake the CPU via IPI if\n * necessary. The wakee CPU on receipt of the IPI will queue the task\n * via sched_ttwu_wakeup() for activation so the wakee incurs the cost\n * of the wakeup instead of the waker.\n */\nstatic void __ttwu_queue_wakelist(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tp->sched_remote_wakeup = !!(wake_flags & WF_MIGRATED);\n\n\tWRITE_ONCE(rq->ttwu_pending, 1);\n\t__smp_call_single_queue(cpu, &p->wake_entry.llist);\n}\n\nvoid wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\tif (set_nr_if_polling(rq->idle)) {\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n\t} else {\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (is_idle_task(rq->curr))\n\t\t\tsmp_send_reschedule(cpu);\n\t\t/* Else CPU is not idle, do nothing here: */\n\t\trq_unlock_irqrestore(rq, &rf);\n\t}\n\nout:\n\trcu_read_unlock();\n}\n\nbool cpus_share_cache(int this_cpu, int that_cpu)\n{\n\treturn per_cpu(sd_llc_id, this_cpu) == per_cpu(sd_llc_id, that_cpu);\n}\n\nstatic inline bool ttwu_queue_cond(int cpu, int wake_flags)\n{\n\t/*\n\t * If the CPU does not share cache, then queue the task on the\n\t * remote rqs wakelist to avoid accessing remote data.\n\t */\n\tif (!cpus_share_cache(smp_processor_id(), cpu))\n\t\treturn true;\n\n\t/*\n\t * If the task is descheduling and the only running task on the\n\t * CPU then use the wakelist to offload the task activation to\n\t * the soon-to-be-idle CPU as the current CPU is likely busy.\n\t * nr_running is checked to avoid unnecessary task stacking.\n\t */\n\tif ((wake_flags & WF_ON_CPU) && cpu_rq(cpu)->nr_running <= 1)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool ttwu_queue_wakelist(struct task_struct *p, int cpu, int wake_flags)\n{\n\tif (sched_feat(TTWU_QUEUE) && ttwu_queue_cond(cpu, wake_flags)) {\n\t\tif (WARN_ON_ONCE(cpu == smp_processor_id()))\n\t\t\treturn false;\n\n\t\tsched_clock_cpu(cpu); /* Sync clocks across CPUs */\n\t\t__ttwu_queue_wakelist(p, cpu, wake_flags);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#else /* !CONFIG_SMP */\n\nstatic inline bool ttwu_queue_wakelist(struct task_struct *p, int cpu, int wake_flags)\n{\n\treturn false;\n}\n\n#endif /* CONFIG_SMP */\n\nstatic void ttwu_queue(struct task_struct *p, int cpu, int wake_flags)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\tif (ttwu_queue_wakelist(p, cpu, wake_flags))\n\t\treturn;\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\tttwu_do_activate(rq, p, wake_flags, &rf);\n\trq_unlock(rq, &rf);\n}\n\n/*\n * Notes on Program-Order guarantees on SMP systems.\n *\n *  MIGRATION\n *\n * The basic program-order guarantee on SMP systems is that when a task [t]\n * migrates, all its activity on its old CPU [c0] happens-before any subsequent\n * execution on its new CPU [c1].\n *\n * For migration (of runnable tasks) this is provided by the following means:\n *\n *  A) UNLOCK of the rq(c0)->lock scheduling out task t\n *  B) migration for t is required to synchronize *both* rq(c0)->lock and\n *     rq(c1)->lock (if not at the same time, then in that order).\n *  C) LOCK of the rq(c1)->lock scheduling in task\n *\n * Release/acquire chaining guarantees that B happens after A and C after B.\n * Note: the CPU doing B need not be c0 or c1\n *\n * Example:\n *\n *   CPU0            CPU1            CPU2\n *\n *   LOCK rq(0)->lock\n *   sched-out X\n *   sched-in Y\n *   UNLOCK rq(0)->lock\n *\n *                                   LOCK rq(0)->lock // orders against CPU0\n *                                   dequeue X\n *                                   UNLOCK rq(0)->lock\n *\n *                                   LOCK rq(1)->lock\n *                                   enqueue X\n *                                   UNLOCK rq(1)->lock\n *\n *                   LOCK rq(1)->lock // orders against CPU2\n *                   sched-out Z\n *                   sched-in X\n *                   UNLOCK rq(1)->lock\n *\n *\n *  BLOCKING -- aka. SLEEP + WAKEUP\n *\n * For blocking we (obviously) need to provide the same guarantee as for\n * migration. However the means are completely different as there is no lock\n * chain to provide order. Instead we do:\n *\n *   1) smp_store_release(X->on_cpu, 0)   -- finish_task()\n *   2) smp_cond_load_acquire(!X->on_cpu) -- try_to_wake_up()\n *\n * Example:\n *\n *   CPU0 (schedule)  CPU1 (try_to_wake_up) CPU2 (schedule)\n *\n *   LOCK rq(0)->lock LOCK X->pi_lock\n *   dequeue X\n *   sched-out X\n *   smp_store_release(X->on_cpu, 0);\n *\n *                    smp_cond_load_acquire(&X->on_cpu, !VAL);\n *                    X->state = WAKING\n *                    set_task_cpu(X,2)\n *\n *                    LOCK rq(2)->lock\n *                    enqueue X\n *                    X->state = RUNNING\n *                    UNLOCK rq(2)->lock\n *\n *                                          LOCK rq(2)->lock // orders against CPU1\n *                                          sched-out Z\n *                                          sched-in X\n *                                          UNLOCK rq(2)->lock\n *\n *                    UNLOCK X->pi_lock\n *   UNLOCK rq(0)->lock\n *\n *\n * However, for wakeups there is a second guarantee we must provide, namely we\n * must ensure that CONDITION=1 done by the caller can not be reordered with\n * accesses to the task state; see try_to_wake_up() and set_current_state().\n */\n\n/**\n * try_to_wake_up - wake up a thread\n * @p: the thread to be awakened\n * @state: the mask of task states that can be woken\n * @wake_flags: wake modifier flags (WF_*)\n *\n * Conceptually does:\n *\n *   If (@state & @p->state) @p->state = TASK_RUNNING.\n *\n * If the task was not queued/runnable, also place it back on a runqueue.\n *\n * This function is atomic against schedule() which would dequeue the task.\n *\n * It issues a full memory barrier before accessing @p->state, see the comment\n * with set_current_state().\n *\n * Uses p->pi_lock to serialize against concurrent wake-ups.\n *\n * Relies on p->pi_lock stabilizing:\n *  - p->sched_class\n *  - p->cpus_ptr\n *  - p->sched_task_group\n * in order to do migration, see its use of select_task_rq()/set_task_cpu().\n *\n * Tries really hard to only take one task_rq(p)->lock for performance.\n * Takes rq->lock in:\n *  - ttwu_runnable()    -- old rq, unavoidable, see comment there;\n *  - ttwu_queue()       -- new rq, for enqueue of the task;\n *  - psi_ttwu_dequeue() -- much sadness :-( accounting will kill us.\n *\n * As a consequence we race really badly with just about everything. See the\n * many memory barriers and their comments for details.\n *\n * Return: %true if @p->state changes (an actual wakeup was done),\n *\t   %false otherwise.\n */\nstatic int\ntry_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)\n{\n\tunsigned long flags;\n\tint cpu, success = 0;\n\n\tpreempt_disable();\n\tif (p == current) {\n\t\t/*\n\t\t * We're waking current, this means 'p->on_rq' and 'task_cpu(p)\n\t\t * == smp_processor_id()'. Together this means we can special\n\t\t * case the whole 'p->on_rq && ttwu_runnable()' case below\n\t\t * without taking any locks.\n\t\t *\n\t\t * In particular:\n\t\t *  - we rely on Program-Order guarantees for all the ordering,\n\t\t *  - we're serialized against set_special_state() by virtue of\n\t\t *    it disabling IRQs (this allows not taking ->pi_lock).\n\t\t */\n\t\tif (!(p->state & state))\n\t\t\tgoto out;\n\n\t\tsuccess = 1;\n\t\ttrace_sched_waking(p);\n\t\tp->state = TASK_RUNNING;\n\t\ttrace_sched_wakeup(p);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If we are going to wake up a thread waiting for CONDITION we\n\t * need to ensure that CONDITION=1 done by the caller can not be\n\t * reordered with p->state check below. This pairs with smp_store_mb()\n\t * in set_current_state() that the waiting thread does.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tsmp_mb__after_spinlock();\n\tif (!(p->state & state))\n\t\tgoto unlock;\n\n\ttrace_sched_waking(p);\n\n\t/* We're going to change ->state: */\n\tsuccess = 1;\n\n\t/*\n\t * Ensure we load p->on_rq _after_ p->state, otherwise it would\n\t * be possible to, falsely, observe p->on_rq == 0 and get stuck\n\t * in smp_cond_load_acquire() below.\n\t *\n\t * sched_ttwu_pending()\t\t\ttry_to_wake_up()\n\t *   STORE p->on_rq = 1\t\t\t  LOAD p->state\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   UNLOCK rq->lock\n\t *\n\t * [task p]\n\t *   STORE p->state = UNINTERRUPTIBLE\t  LOAD p->on_rq\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t *\n\t * A similar smb_rmb() lives in try_invoke_on_locked_down_task().\n\t */\n\tsmp_rmb();\n\tif (READ_ONCE(p->on_rq) && ttwu_runnable(p, wake_flags))\n\t\tgoto unlock;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Ensure we load p->on_cpu _after_ p->on_rq, otherwise it would be\n\t * possible to, falsely, observe p->on_cpu == 0.\n\t *\n\t * One must be running (->on_cpu == 1) in order to remove oneself\n\t * from the runqueue.\n\t *\n\t * __schedule() (switch to task 'p')\ttry_to_wake_up()\n\t *   STORE p->on_cpu = 1\t\t  LOAD p->on_rq\n\t *   UNLOCK rq->lock\n\t *\n\t * __schedule() (put 'p' to sleep)\n\t *   LOCK rq->lock\t\t\t  smp_rmb();\n\t *   smp_mb__after_spinlock();\n\t *   STORE p->on_rq = 0\t\t\t  LOAD p->on_cpu\n\t *\n\t * Pairs with the LOCK+smp_mb__after_spinlock() on rq->lock in\n\t * __schedule().  See the comment for smp_mb__after_spinlock().\n\t *\n\t * Form a control-dep-acquire with p->on_rq == 0 above, to ensure\n\t * schedule()'s deactivate_task() has 'happened' and p will no longer\n\t * care about it's own p->state. See the comment in __schedule().\n\t */\n\tsmp_acquire__after_ctrl_dep();\n\n\t/*\n\t * We're doing the wakeup (@success == 1), they did a dequeue (p->on_rq\n\t * == 0), which means we need to do an enqueue, change p->state to\n\t * TASK_WAKING such that we can unlock p->pi_lock before doing the\n\t * enqueue, such as ttwu_queue_wakelist().\n\t */\n\tp->state = TASK_WAKING;\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, considering queueing p on the remote CPUs wake_list\n\t * which potentially sends an IPI instead of spinning on p->on_cpu to\n\t * let the waker make forward progress. This is safe because IRQs are\n\t * disabled and the IPI will deliver after on_cpu is cleared.\n\t *\n\t * Ensure we load task_cpu(p) after p->on_cpu:\n\t *\n\t * set_task_cpu(p, cpu);\n\t *   STORE p->cpu = @cpu\n\t * __schedule() (switch to task 'p')\n\t *   LOCK rq->lock\n\t *   smp_mb__after_spin_lock()\t\tsmp_cond_load_acquire(&p->on_cpu)\n\t *   STORE p->on_cpu = 1\t\tLOAD p->cpu\n\t *\n\t * to ensure we observe the correct CPU on which the task is currently\n\t * scheduling.\n\t */\n\tif (smp_load_acquire(&p->on_cpu) &&\n\t    ttwu_queue_wakelist(p, task_cpu(p), wake_flags | WF_ON_CPU))\n\t\tgoto unlock;\n\n\t/*\n\t * If the owning (remote) CPU is still in the middle of schedule() with\n\t * this task as prev, wait until it's done referencing the task.\n\t *\n\t * Pairs with the smp_store_release() in finish_task().\n\t *\n\t * This ensures that tasks getting woken will be fully ordered against\n\t * their previous state and preserve Program Order.\n\t */\n\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\tcpu = select_task_rq(p, p->wake_cpu, wake_flags | WF_TTWU);\n\tif (task_cpu(p) != cpu) {\n\t\tif (p->in_iowait) {\n\t\t\tdelayacct_blkio_end(p);\n\t\t\tatomic_dec(&task_rq(p)->nr_iowait);\n\t\t}\n\n\t\twake_flags |= WF_MIGRATED;\n\t\tpsi_ttwu_dequeue(p);\n\t\tset_task_cpu(p, cpu);\n\t}\n#else\n\tcpu = task_cpu(p);\n#endif /* CONFIG_SMP */\n\n\tttwu_queue(p, cpu, wake_flags);\nunlock:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\nout:\n\tif (success)\n\t\tttwu_stat(p, task_cpu(p), wake_flags);\n\tpreempt_enable();\n\n\treturn success;\n}\n\n/**\n * try_invoke_on_locked_down_task - Invoke a function on task in fixed state\n * @p: Process for which the function is to be invoked.\n * @func: Function to invoke.\n * @arg: Argument to function.\n *\n * If the specified task can be quickly locked into a definite state\n * (either sleeping or on a given runqueue), arrange to keep it in that\n * state while invoking @func(@arg).  This function can use ->on_rq and\n * task_curr() to work out what the state is, if required.  Given that\n * @func can be invoked with a runqueue lock held, it had better be quite\n * lightweight.\n *\n * Returns:\n *\t@false if the task slipped out from under the locks.\n *\t@true if the task was locked onto a runqueue or is sleeping.\n *\t\tHowever, @func can override this by returning @false.\n */\nbool try_invoke_on_locked_down_task(struct task_struct *p, bool (*func)(struct task_struct *t, void *arg), void *arg)\n{\n\tbool ret = false;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tlockdep_assert_irqs_enabled();\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (p->on_rq) {\n\t\trq = __task_rq_lock(p, &rf);\n\t\tif (task_rq(p) == rq)\n\t\t\tret = func(p, arg);\n\t\trq_unlock(rq, &rf);\n\t} else {\n\t\tswitch (p->state) {\n\t\tcase TASK_RUNNING:\n\t\tcase TASK_WAKING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsmp_rmb(); // See smp_rmb() comment in try_to_wake_up().\n\t\t\tif (!p->on_rq)\n\t\t\t\tret = func(p, arg);\n\t\t}\n\t}\n\traw_spin_unlock_irq(&p->pi_lock);\n\treturn ret;\n}\n\n/**\n * wake_up_process - Wake up a specific process\n * @p: The process to be woken up.\n *\n * Attempt to wake up the nominated process and move it to the set of runnable\n * processes.\n *\n * Return: 1 if the process was woken up, 0 if it was already running.\n *\n * This function executes a full memory barrier before accessing the task state.\n */\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}\nEXPORT_SYMBOL(wake_up_process);\n\nint wake_up_state(struct task_struct *p, unsigned int state)\n{\n\treturn try_to_wake_up(p, state, 0);\n}\n\n/*\n * Perform scheduler related setup for a newly forked process p.\n * p is forked by current.\n *\n * __sched_fork() is basic setup used by init_idle() too:\n */\nstatic void __sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tp->on_rq\t\t\t= 0;\n\n\tp->se.on_rq\t\t\t= 0;\n\tp->se.exec_start\t\t= 0;\n\tp->se.sum_exec_runtime\t\t= 0;\n\tp->se.prev_sum_exec_runtime\t= 0;\n\tp->se.nr_migrations\t\t= 0;\n\tp->se.vruntime\t\t\t= 0;\n\tINIT_LIST_HEAD(&p->se.group_node);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tp->se.cfs_rq\t\t\t= NULL;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* Even if schedstat is disabled, there should not be garbage */\n\tmemset(&p->se.statistics, 0, sizeof(p->se.statistics));\n#endif\n\n\tRB_CLEAR_NODE(&p->dl.rb_node);\n\tinit_dl_task_timer(&p->dl);\n\tinit_dl_inactive_task_timer(&p->dl);\n\t__dl_clear_params(p);\n\n\tINIT_LIST_HEAD(&p->rt.run_list);\n\tp->rt.timeout\t\t= 0;\n\tp->rt.time_slice\t= sched_rr_timeslice;\n\tp->rt.on_rq\t\t= 0;\n\tp->rt.on_list\t\t= 0;\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tINIT_HLIST_HEAD(&p->preempt_notifiers);\n#endif\n\n#ifdef CONFIG_COMPACTION\n\tp->capture_control = NULL;\n#endif\n\tinit_numa_balancing(clone_flags, p);\n#ifdef CONFIG_SMP\n\tp->wake_entry.u_flags = CSD_TYPE_TTWU;\n\tp->migration_pending = NULL;\n#endif\n}\n\nDEFINE_STATIC_KEY_FALSE(sched_numa_balancing);\n\n#ifdef CONFIG_NUMA_BALANCING\n\nvoid set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}\n\n#ifdef CONFIG_PROC_SYSCTL\nint sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}\n#endif\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\nDEFINE_STATIC_KEY_FALSE(sched_schedstats);\nstatic bool __initdata __sched_schedstats = false;\n\nstatic void set_schedstats(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_schedstats);\n\telse\n\t\tstatic_branch_disable(&sched_schedstats);\n}\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}\n\nstatic int __init setup_schedstats(char *str)\n{\n\tint ret = 0;\n\tif (!str)\n\t\tgoto out;\n\n\t/*\n\t * This code is called before jump labels have been set up, so we can't\n\t * change the static branch directly just yet.  Instead set a temporary\n\t * variable so init_schedstats() can do it later.\n\t */\n\tif (!strcmp(str, \"enable\")) {\n\t\t__sched_schedstats = true;\n\t\tret = 1;\n\t} else if (!strcmp(str, \"disable\")) {\n\t\t__sched_schedstats = false;\n\t\tret = 1;\n\t}\nout:\n\tif (!ret)\n\t\tpr_warn(\"Unable to parse schedstats=\\n\");\n\n\treturn ret;\n}\n__setup(\"schedstats=\", setup_schedstats);\n\nstatic void __init init_schedstats(void)\n{\n\tset_schedstats(__sched_schedstats);\n}\n\n#ifdef CONFIG_PROC_SYSCTL\nint sysctl_schedstats(struct ctl_table *table, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_schedstats);\n\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_schedstats(state);\n\treturn err;\n}\n#endif /* CONFIG_PROC_SYSCTL */\n#else  /* !CONFIG_SCHEDSTATS */\nstatic inline void init_schedstats(void) {}\n#endif /* CONFIG_SCHEDSTATS */\n\n/*\n * fork()/clone()-time setup:\n */\nint sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long flags;\n\n\t__sched_fork(clone_flags, p);\n\t/*\n\t * We mark the process as NEW here. This guarantees that\n\t * nobody will actually run it, and a signal or other external\n\t * event cannot wake it up and insert it on the runqueue either.\n\t */\n\tp->state = TASK_NEW;\n\n\t/*\n\t * Make sure we do not leak PI boosting priority to the child.\n\t */\n\tp->prio = current->normal_prio;\n\n\tuclamp_fork(p);\n\n\t/*\n\t * Revert to default priority/policy on fork if requested.\n\t */\n\tif (unlikely(p->sched_reset_on_fork)) {\n\t\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\t\tp->policy = SCHED_NORMAL;\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\t\t\tp->rt_priority = 0;\n\t\t} else if (PRIO_TO_NICE(p->static_prio) < 0)\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\n\t\tp->prio = p->normal_prio = __normal_prio(p);\n\t\tset_load_weight(p, false);\n\n\t\t/*\n\t\t * We don't need the reset flag anymore after the fork. It has\n\t\t * fulfilled its duty:\n\t\t */\n\t\tp->sched_reset_on_fork = 0;\n\t}\n\n\tif (dl_prio(p->prio))\n\t\treturn -EAGAIN;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n\n\tinit_entity_runnable_average(&p->se);\n\n\t/*\n\t * The child is not yet in the pid-hash so no cgroup attach races,\n\t * and the cgroup is pinned to this child due to cgroup_fork()\n\t * is ran before sched_fork().\n\t *\n\t * Silence PROVE_RCU.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\trseq_migrate(p);\n\t/*\n\t * We're setting the CPU for the first time, we don't migrate,\n\t * so use __set_task_cpu().\n\t */\n\t__set_task_cpu(p, smp_processor_id());\n\tif (p->sched_class->task_fork)\n\t\tp->sched_class->task_fork(p);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n#ifdef CONFIG_SCHED_INFO\n\tif (likely(sched_info_on()))\n\t\tmemset(&p->sched_info, 0, sizeof(p->sched_info));\n#endif\n#if defined(CONFIG_SMP)\n\tp->on_cpu = 0;\n#endif\n\tinit_task_preempt_count(p);\n#ifdef CONFIG_SMP\n\tplist_node_init(&p->pushable_tasks, MAX_PRIO);\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n#endif\n\treturn 0;\n}\n\nvoid sched_post_fork(struct task_struct *p)\n{\n\tuclamp_post_fork(p);\n}\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}\n\n/*\n * wake_up_new_task - wake up a newly created task for the first time.\n *\n * This function will do some initial scheduler statistics housekeeping\n * that must be done for every newly created context, then puts the task\n * on the runqueue and wakes it.\n */\nvoid wake_up_new_task(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tp->state = TASK_RUNNING;\n#ifdef CONFIG_SMP\n\t/*\n\t * Fork balancing, do it here and not earlier because:\n\t *  - cpus_ptr can change in the fork path\n\t *  - any previously selected CPU might disappear through hotplug\n\t *\n\t * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,\n\t * as we're not fully set-up yet.\n\t */\n\tp->recent_used_cpu = task_cpu(p);\n\trseq_migrate(p);\n\t__set_task_cpu(p, select_task_rq(p, task_cpu(p), WF_FORK));\n#endif\n\trq = __task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\tpost_init_entity_util_avg(p);\n\n\tactivate_task(rq, p, ENQUEUE_NOCLOCK);\n\ttrace_sched_wakeup_new(p);\n\tcheck_preempt_curr(rq, p, WF_FORK);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so it's fine to\n\t\t * drop it.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tp->sched_class->task_woken(rq, p);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\ttask_rq_unlock(rq, p, &rf);\n}\n\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\nstatic DEFINE_STATIC_KEY_FALSE(preempt_notifier_key);\n\nvoid preempt_notifier_inc(void)\n{\n\tstatic_branch_inc(&preempt_notifier_key);\n}\nEXPORT_SYMBOL_GPL(preempt_notifier_inc);\n\nvoid preempt_notifier_dec(void)\n{\n\tstatic_branch_dec(&preempt_notifier_key);\n}\nEXPORT_SYMBOL_GPL(preempt_notifier_dec);\n\n/**\n * preempt_notifier_register - tell me when current is being preempted & rescheduled\n * @notifier: notifier struct to register\n */\nvoid preempt_notifier_register(struct preempt_notifier *notifier)\n{\n\tif (!static_branch_unlikely(&preempt_notifier_key))\n\t\tWARN(1, \"registering preempt_notifier while notifiers disabled\\n\");\n\n\thlist_add_head(&notifier->link, &current->preempt_notifiers);\n}\nEXPORT_SYMBOL_GPL(preempt_notifier_register);\n\n/**\n * preempt_notifier_unregister - no longer interested in preemption notifications\n * @notifier: notifier struct to unregister\n *\n * This is *not* safe to call from within a preemption notifier.\n */\nvoid preempt_notifier_unregister(struct preempt_notifier *notifier)\n{\n\thlist_del(&notifier->link);\n}\nEXPORT_SYMBOL_GPL(preempt_notifier_unregister);\n\nstatic void __fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_in(notifier, raw_smp_processor_id());\n}\n\nstatic __always_inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n\tif (static_branch_unlikely(&preempt_notifier_key))\n\t\t__fire_sched_in_preempt_notifiers(curr);\n}\n\nstatic void\n__fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t   struct task_struct *next)\n{\n\tstruct preempt_notifier *notifier;\n\n\thlist_for_each_entry(notifier, &curr->preempt_notifiers, link)\n\t\tnotifier->ops->sched_out(notifier, next);\n}\n\nstatic __always_inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n\tif (static_branch_unlikely(&preempt_notifier_key))\n\t\t__fire_sched_out_preempt_notifiers(curr, next);\n}\n\n#else /* !CONFIG_PREEMPT_NOTIFIERS */\n\nstatic inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)\n{\n}\n\nstatic inline void\nfire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n}\n\n#endif /* CONFIG_PREEMPT_NOTIFIERS */\n\nstatic inline void prepare_task(struct task_struct *next)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * Claim the task as running, we do this before switching to it\n\t * such that any running task will have this set.\n\t *\n\t * See the ttwu() WF_ON_CPU case and its ordering comment.\n\t */\n\tWRITE_ONCE(next->on_cpu, 1);\n#endif\n}\n\nstatic inline void finish_task(struct task_struct *prev)\n{\n#ifdef CONFIG_SMP\n\t/*\n\t * This must be the very last reference to @prev from this CPU. After\n\t * p->on_cpu is cleared, the task can be moved to a different CPU. We\n\t * must ensure this doesn't happen until the switch is completely\n\t * finished.\n\t *\n\t * In particular, the load of prev->state in finish_task_switch() must\n\t * happen before this.\n\t *\n\t * Pairs with the smp_cond_load_acquire() in try_to_wake_up().\n\t */\n\tsmp_store_release(&prev->on_cpu, 0);\n#endif\n}\n\n#ifdef CONFIG_SMP\n\nstatic void do_balance_callbacks(struct rq *rq, struct callback_head *head)\n{\n\tvoid (*func)(struct rq *rq);\n\tstruct callback_head *next;\n\n\tlockdep_assert_held(&rq->lock);\n\n\twhile (head) {\n\t\tfunc = (void (*)(struct rq *))head->func;\n\t\tnext = head->next;\n\t\thead->next = NULL;\n\t\thead = next;\n\n\t\tfunc(rq);\n\t}\n}\n\nstatic inline struct callback_head *splice_balance_callbacks(struct rq *rq)\n{\n\tstruct callback_head *head = rq->balance_callback;\n\n\tlockdep_assert_held(&rq->lock);\n\tif (head) {\n\t\trq->balance_callback = NULL;\n\t\trq->balance_flags &= ~BALANCE_WORK;\n\t}\n\n\treturn head;\n}\n\nstatic void __balance_callbacks(struct rq *rq)\n{\n\tdo_balance_callbacks(rq, splice_balance_callbacks(rq));\n}\n\nstatic inline void balance_callbacks(struct rq *rq, struct callback_head *head)\n{\n\tunsigned long flags;\n\n\tif (unlikely(head)) {\n\t\traw_spin_lock_irqsave(&rq->lock, flags);\n\t\tdo_balance_callbacks(rq, head);\n\t\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\t}\n}\n\nstatic void balance_push(struct rq *rq);\n\nstatic inline void balance_switch(struct rq *rq)\n{\n\tif (likely(!rq->balance_flags))\n\t\treturn;\n\n\tif (rq->balance_flags & BALANCE_PUSH) {\n\t\tbalance_push(rq);\n\t\treturn;\n\t}\n\n\t__balance_callbacks(rq);\n}\n\n#else\n\nstatic inline void __balance_callbacks(struct rq *rq)\n{\n}\n\nstatic inline struct callback_head *splice_balance_callbacks(struct rq *rq)\n{\n\treturn NULL;\n}\n\nstatic inline void balance_callbacks(struct rq *rq, struct callback_head *head)\n{\n}\n\nstatic inline void balance_switch(struct rq *rq)\n{\n}\n\n#endif\n\nstatic inline void\nprepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)\n{\n\t/*\n\t * Since the runqueue lock will be released by the next\n\t * task (which is an invalid locking op but in the case\n\t * of the scheduler it's an obvious special-case), so we\n\t * do an early lockdep release here:\n\t */\n\trq_unpin_lock(rq, rf);\n\tspin_release(&rq->lock.dep_map, _THIS_IP_);\n#ifdef CONFIG_DEBUG_SPINLOCK\n\t/* this is a valid case when another task releases the spinlock */\n\trq->lock.owner = next;\n#endif\n}\n\nstatic inline void finish_lock_switch(struct rq *rq)\n{\n\t/*\n\t * If we are tracking spinlock dependencies then we have to\n\t * fix up the runqueue lock - which gets 'carried over' from\n\t * prev into current:\n\t */\n\tspin_acquire(&rq->lock.dep_map, 0, 0, _THIS_IP_);\n\tbalance_switch(rq);\n\traw_spin_unlock_irq(&rq->lock);\n}\n\n/*\n * NOP if the arch has not defined these:\n */\n\n#ifndef prepare_arch_switch\n# define prepare_arch_switch(next)\tdo { } while (0)\n#endif\n\n#ifndef finish_arch_post_lock_switch\n# define finish_arch_post_lock_switch()\tdo { } while (0)\n#endif\n\nstatic inline void kmap_local_sched_out(void)\n{\n#ifdef CONFIG_KMAP_LOCAL\n//\tif (unlikely(current->kmap_ctrl.idx))\n//\t\t__kmap_local_sched_out();\n#endif\n}\n\nstatic inline void kmap_local_sched_in(void)\n{\n#ifdef CONFIG_KMAP_LOCAL\n//\tif (unlikely(current->kmap_ctrl.idx))\n//\t\t__kmap_local_sched_in();\n#endif\n}\n\n/**\n * prepare_task_switch - prepare to switch tasks\n * @rq: the runqueue preparing to switch\n * @prev: the current task that is being switched out\n * @next: the task we are going to switch to.\n *\n * This is called with the rq lock held and interrupts off. It must\n * be paired with a subsequent finish_task_switch after the context\n * switch.\n *\n * prepare_task_switch sets up locking and calls architecture specific\n * hooks.\n */\nstatic inline void\nprepare_task_switch(struct rq *rq, struct task_struct *prev,\n\t\t    struct task_struct *next)\n{\n\tkcov_prepare_switch(prev);\n\tsched_info_switch(rq, prev, next);\n\tperf_event_task_sched_out(prev, next);\n\trseq_preempt(prev);\n\tfire_sched_out_preempt_notifiers(prev, next);\n\tkmap_local_sched_out();\n\tprepare_task(next);\n\tprepare_arch_switch(next);\n}\n\n/**\n * finish_task_switch - clean up after a task-switch\n * @prev: the thread we just switched away from.\n *\n * finish_task_switch must be called after the context switch, paired\n * with a prepare_task_switch call before the context switch.\n * finish_task_switch will reconcile locking set up by prepare_task_switch,\n * and do any other architecture-specific cleanup actions.\n *\n * Note that we may have delayed dropping an mm in context_switch(). If\n * so, we finish that here outside of the runqueue lock. (Doing it\n * with the lock held can cause deadlocks; see schedule() for\n * details.)\n *\n * The context switch have flipped the stack from under us and restored the\n * local variables which were saved when this task called schedule() in the\n * past. prev == current is still correct but we need to recalculate this_rq\n * because prev may have moved to another CPU.\n */\nstatic struct rq *finish_task_switch(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\t/*\n\t * kmap_local_sched_out() is invoked with rq::lock held and\n\t * interrupts disabled. There is no requirement for that, but the\n\t * sched out code does not have an interrupt enabled section.\n\t * Restoring the maps on sched in does not require interrupts being\n\t * disabled either.\n\t */\n\tkmap_local_sched_in();\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);\n\t}\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\n\t\t/*\n\t\t * Remove function-return probe instances associated with this\n\t\t * task and put them back on the free list.\n\t\t */\n\t\tkprobe_flush_task(prev);\n\n\t\t/* Task is done with its stack. */\n\t\tput_task_stack(prev);\n\n\t\tput_task_struct_rcu_user(prev);\n\t}\n\n\ttick_nohz_task_switch();\n\treturn rq;\n}\n\n/**\n * schedule_tail - first thing a freshly forked thread must call.\n * @prev: the thread we just switched away from.\n */\nasmlinkage __visible void schedule_tail(struct task_struct *prev)\n\t__releases(rq->lock)\n{\n\tstruct rq *rq;\n\n\t/*\n\t * New tasks start with FORK_PREEMPT_COUNT, see there and\n\t * finish_task_switch() for details.\n\t *\n\t * finish_task_switch() will drop rq->lock() and lower preempt_count\n\t * and the preempt_enable() will end up enabling preemption (on\n\t * PREEMPT_COUNT kernels).\n\t */\n\n\trq = finish_task_switch(prev);\n\tpreempt_enable();\n\n\tif (current->set_child_tid)\n\t\tput_user(task_pid_vnr(current), current->set_child_tid);\n\n\tcalculate_sigpending();\n}\n\n/*\n * context_switch - switch to the new MM and the new thread's register state.\n */\nstatic __always_inline struct rq *\ncontext_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tprepare_task_switch(rq, prev, next);\n\n\t/*\n\t * For paravirt, this is coupled with an exit in switch_to to\n\t * combine the page table reload and the switch backend into\n\t * one hypercall.\n\t */\n\tarch_start_context_switch(prev);\n\n\t/*\n\t * kernel -> kernel   lazy + transfer active\n\t *   user -> kernel   lazy + mmgrab() active\n\t *\n\t * kernel ->   user   switch + mmdrop() active\n\t *   user ->   user   switch\n\t */\n\tif (!next->mm) {                                // to kernel\n\t\tenter_lazy_tlb(prev->active_mm, next);\n\n\t\tnext->active_mm = prev->active_mm;\n\t\tif (prev->mm)                           // from user\n\t\t\tmmgrab(prev->active_mm);\n\t\telse\n\t\t\tprev->active_mm = NULL;\n\t} else {                                        // to user\n\t\tmembarrier_switch_mm(rq, prev->active_mm, next->mm);\n\t\t/*\n\t\t * sys_membarrier() requires an smp_mb() between setting\n\t\t * rq->curr / membarrier_switch_mm() and returning to userspace.\n\t\t *\n\t\t * The below provides this either through switch_mm(), or in\n\t\t * case 'prev->active_mm == next->mm' through\n\t\t * finish_task_switch()'s mmdrop().\n\t\t */\n\t\tswitch_mm_irqs_off(prev->active_mm, next->mm, next);\n\n\t\tif (!prev->mm) {                        // from kernel\n\t\t\t/* will mmdrop() in finish_task_switch(). */\n\t\t\trq->prev_mm = prev->active_mm;\n\t\t\tprev->active_mm = NULL;\n\t\t}\n\t}\n\n\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\tprepare_lock_switch(rq, next, rf);\n\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\n\treturn finish_task_switch(prev);\n}\n\n/*\n * nr_running and nr_context_switches:\n *\n * externally visible scheduler statistics: current number of runnable\n * threads, total number of context switches performed since bootup.\n */\nunsigned long nr_running(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_online_cpu(i)\n\t\tsum += cpu_rq(i)->nr_running;\n\n\treturn sum;\n}\n\n/*\n * Check if only the current task is running on the CPU.\n *\n * Caution: this function does not check that the caller has disabled\n * preemption, thus the result might have a time-of-check-to-time-of-use\n * race.  The caller is responsible to use it correctly, for example:\n *\n * - from a non-preemptible section (of course)\n *\n * - from a thread that is bound to a single CPU\n *\n * - in a loop with very short iterations (e.g. a polling loop)\n */\nbool single_task_running(void)\n{\n\treturn raw_rq()->nr_running == 1;\n}\nEXPORT_SYMBOL(single_task_running);\n\nunsigned long long nr_context_switches(void)\n{\n\tint i;\n\tunsigned long long sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned long nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}\n\n/*\n * IO-wait accounting, and how it's mostly bollocks (on SMP).\n *\n * The idea behind IO-wait account is to account the idle time that we could\n * have spend running if it were not for IO. That is, if we were to improve the\n * storage performance, we'd have a proportional reduction in IO-wait time.\n *\n * This all works nicely on UP, where, when a task blocks on IO, we account\n * idle time as IO-wait, because if the storage were faster, it could've been\n * running and we'd not be idle.\n *\n * This has been extended to SMP, by doing the same for each CPU. This however\n * is broken.\n *\n * Imagine for instance the case where two tasks block on one CPU, only the one\n * CPU will have IO-wait accounted, while the other has regular idle. Even\n * though, if the storage were faster, both could've ran at the same time,\n * utilising both CPUs.\n *\n * This means, that when looking globally, the current IO-wait accounting on\n * SMP is a lower bound, by reason of under accounting.\n *\n * Worse, since the numbers are provided per CPU, they are sometimes\n * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly\n * associated with any one particular CPU, it can wake to another CPU than it\n * blocked on. This means the per CPU IO-wait number is meaningless.\n *\n * Task CPU affinities can make all that even more 'interesting'.\n */\n\nunsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += nr_iowait_cpu(i);\n\n\treturn sum;\n}\n\n#ifdef CONFIG_SMP\n\n/*\n * sched_exec - execve() is a valuable balancing opportunity, because at\n * this point the task has the smallest effective memory and cache footprint.\n */\nvoid sched_exec(void)\n{\n\tstruct task_struct *p = current;\n\tunsigned long flags;\n\tint dest_cpu;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tdest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), WF_EXEC);\n\tif (dest_cpu == smp_processor_id())\n\t\tgoto unlock;\n\n\tif (likely(cpu_active(dest_cpu))) {\n\t\tstruct migration_arg arg = { p, dest_cpu };\n\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\t\tstop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);\n\t\treturn;\n\t}\nunlock:\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n}\n\n#endif\n\nDEFINE_PER_CPU(struct kernel_stat, kstat);\nDEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);\n\nEXPORT_PER_CPU_SYMBOL(kstat);\nEXPORT_PER_CPU_SYMBOL(kernel_cpustat);\n\n/*\n * The function fair_sched_class.update_curr accesses the struct curr\n * and its field curr->exec_start; when called from task_sched_runtime(),\n * we observe a high rate of cache misses in practice.\n * Prefetching this data results in improved performance.\n */\nstatic inline void prefetch_curr_exec_start(struct task_struct *p)\n{\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct sched_entity *curr = (&p->se)->cfs_rq->curr;\n#else\n\tstruct sched_entity *curr = (&task_rq(p)->cfs)->curr;\n#endif\n\tprefetch(curr);\n\tprefetch(&curr->exec_start);\n}\n\n/*\n * Return accounted runtime for the task.\n * In case the task is currently running, return the runtime plus current's\n * pending runtime that have not been accounted yet.\n */\nunsigned long long task_sched_runtime(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tu64 ns;\n\n#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)\n\t/*\n\t * 64-bit doesn't need locks to atomically read a 64-bit value.\n\t * So we have a optimization chance when the task's delta_exec is 0.\n\t * Reading ->on_cpu is racy, but this is ok.\n\t *\n\t * If we race with it leaving CPU, we'll take a lock. So we're correct.\n\t * If we race with it entering CPU, unaccounted time is 0. This is\n\t * indistinguishable from the read occurring a few cycles earlier.\n\t * If we see ->on_cpu without ->on_rq, the task is leaving, and has\n\t * been accounted, so we're correct here as well.\n\t */\n\tif (!p->on_cpu || !task_on_rq_queued(p))\n\t\treturn p->se.sum_exec_runtime;\n#endif\n\n\trq = task_rq_lock(p, &rf);\n\t/*\n\t * Must be ->curr _and_ ->on_rq.  If dequeued, we would\n\t * project cycles that may never be accounted to this\n\t * thread, breaking clock_gettime().\n\t */\n\tif (task_current(rq, p) && task_on_rq_queued(p)) {\n\t\tprefetch_curr_exec_start(p);\n\t\tupdate_rq_clock(rq);\n\t\tp->sched_class->update_curr(rq);\n\t}\n\tns = p->se.sum_exec_runtime;\n\ttask_rq_unlock(rq, p, &rf);\n\n\treturn ns;\n}\n\n/*\n * This function gets called by the timer code, with HZ frequency.\n * We call it with interrupts disabled.\n */\nvoid scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tstruct rq_flags rf;\n\tunsigned long thermal_pressure;\n\n\tarch_scale_freq_tick();\n\tsched_clock_tick();\n\n\trq_lock(rq, &rf);\n\n\tupdate_rq_clock(rq);\n\tthermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));\n\tupdate_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tcalc_global_load_tick(rq);\n\tpsi_task_tick(rq);\n\n\trq_unlock(rq, &rf);\n\n\tperf_event_task_tick();\n\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n}\n\n#ifdef CONFIG_NO_HZ_FULL\n\nstruct tick_work {\n\tint\t\t\tcpu;\n\tatomic_t\t\tstate;\n\tstruct delayed_work\twork;\n};\n/* Values for ->state, see diagram below. */\n#define TICK_SCHED_REMOTE_OFFLINE\t0\n#define TICK_SCHED_REMOTE_OFFLINING\t1\n#define TICK_SCHED_REMOTE_RUNNING\t2\n\n/*\n * State diagram for ->state:\n *\n *\n *          TICK_SCHED_REMOTE_OFFLINE\n *                    |   ^\n *                    |   |\n *                    |   | sched_tick_remote()\n *                    |   |\n *                    |   |\n *                    +--TICK_SCHED_REMOTE_OFFLINING\n *                    |   ^\n *                    |   |\n * sched_tick_start() |   | sched_tick_stop()\n *                    |   |\n *                    V   |\n *          TICK_SCHED_REMOTE_RUNNING\n *\n *\n * Other transitions get WARN_ON_ONCE(), except that sched_tick_remote()\n * and sched_tick_start() are happy to leave the state in RUNNING.\n */\n\nstatic struct tick_work __percpu *tick_work_cpu;\n\nstatic void sched_tick_remote(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tick_work *twork = container_of(dwork, struct tick_work, work);\n\tint cpu = twork->cpu;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr;\n\tstruct rq_flags rf;\n\tu64 delta;\n\tint os;\n\n\t/*\n\t * Handle the tick only if it appears the remote CPU is running in full\n\t * dynticks mode. The check is racy by nature, but missing a tick or\n\t * having one too much is no big deal because the scheduler tick updates\n\t * statistics and checks timeslices in a time-independent way, regardless\n\t * of when exactly it is running.\n\t */\n\tif (!tick_nohz_tick_stopped_cpu(cpu))\n\t\tgoto out_requeue;\n\n\trq_lock_irq(rq, &rf);\n\tcurr = rq->curr;\n\tif (cpu_is_offline(cpu))\n\t\tgoto out_unlock;\n\n\tupdate_rq_clock(rq);\n\n\tif (!is_idle_task(curr)) {\n\t\t/*\n\t\t * Make sure the next tick runs within a reasonable\n\t\t * amount of time.\n\t\t */\n\t\tdelta = rq_clock_task(rq) - curr->se.exec_start;\n\t\tWARN_ON_ONCE(delta > (u64)NSEC_PER_SEC * 3);\n\t}\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\n\tcalc_load_nohz_remote(rq);\nout_unlock:\n\trq_unlock_irq(rq, &rf);\nout_requeue:\n\n\t/*\n\t * Run the remote tick once per second (1Hz). This arbitrary\n\t * frequency is large enough to avoid overload but short enough\n\t * to keep scheduler internal stats reasonably up to date.  But\n\t * first update state to reflect hotplug activity if required.\n\t */\n\tos = atomic_fetch_add_unless(&twork->state, -1, TICK_SCHED_REMOTE_RUNNING);\n\tWARN_ON_ONCE(os == TICK_SCHED_REMOTE_OFFLINE);\n\tif (os == TICK_SCHED_REMOTE_RUNNING)\n\t\tqueue_delayed_work(system_unbound_wq, dwork, HZ);\n}\n\nstatic void sched_tick_start(int cpu)\n{\n\tint os;\n\tstruct tick_work *twork;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\tos = atomic_xchg(&twork->state, TICK_SCHED_REMOTE_RUNNING);\n\tWARN_ON_ONCE(os == TICK_SCHED_REMOTE_RUNNING);\n\tif (os == TICK_SCHED_REMOTE_OFFLINE) {\n\t\ttwork->cpu = cpu;\n\t\tINIT_DELAYED_WORK(&twork->work, sched_tick_remote);\n\t\tqueue_delayed_work(system_unbound_wq, &twork->work, HZ);\n\t}\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic void sched_tick_stop(int cpu)\n{\n\tstruct tick_work *twork;\n\tint os;\n\n\tif (housekeeping_cpu(cpu, HK_FLAG_TICK))\n\t\treturn;\n\n\tWARN_ON_ONCE(!tick_work_cpu);\n\n\ttwork = per_cpu_ptr(tick_work_cpu, cpu);\n\t/* There cannot be competing actions, but don't rely on stop-machine. */\n\tos = atomic_xchg(&twork->state, TICK_SCHED_REMOTE_OFFLINING);\n\tWARN_ON_ONCE(os != TICK_SCHED_REMOTE_RUNNING);\n\t/* Don't cancel, as this would mess up the state machine. */\n}\n#endif /* CONFIG_HOTPLUG_CPU */\n\nint __init sched_tick_offload_init(void)\n{\n\ttick_work_cpu = alloc_percpu(struct tick_work);\n\tBUG_ON(!tick_work_cpu);\n\treturn 0;\n}\n\n#else /* !CONFIG_NO_HZ_FULL */\nstatic inline void sched_tick_start(int cpu) { }\nstatic inline void sched_tick_stop(int cpu) { }\n#endif\n\n#if defined(CONFIG_PREEMPTION) && (defined(CONFIG_DEBUG_PREEMPT) || \\\n\t\t\t\tdefined(CONFIG_TRACE_PREEMPT_TOGGLE))\n/*\n * If the value passed in is equal to the current preempt count\n * then we just disabled preemption. Start timing the latency.\n */\nstatic inline void preempt_latency_start(int val)\n{\n\tif (preempt_count() == val) {\n\t\tunsigned long ip = get_lock_parent_ip();\n#ifdef CONFIG_DEBUG_PREEMPT\n\t\tcurrent->preempt_disable_ip = ip;\n#endif\n\t\ttrace_preempt_off(CALLER_ADDR0, ip);\n\t}\n}\n\nvoid preempt_count_add(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Spinlock count overflowing soon?\n\t */\n\tDEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=\n\t\t\t\tPREEMPT_MASK - 10);\n#endif\n\tpreempt_latency_start(val);\n}\nEXPORT_SYMBOL(preempt_count_add);\nNOKPROBE_SYMBOL(preempt_count_add);\n\n/*\n * If the value passed in equals to the current preempt count\n * then we just enabled preemption. Stop timing the latency.\n */\nstatic inline void preempt_latency_stop(int val)\n{\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());\n}\n\nvoid preempt_count_sub(int val)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\t/*\n\t * Underflow?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(val > preempt_count()))\n\t\treturn;\n\t/*\n\t * Is the spinlock portion underflowing?\n\t */\n\tif (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&\n\t\t\t!(preempt_count() & PREEMPT_MASK)))\n\t\treturn;\n#endif\n\n\tpreempt_latency_stop(val);\n\t__preempt_count_sub(val);\n}\nEXPORT_SYMBOL(preempt_count_sub);\nNOKPROBE_SYMBOL(preempt_count_sub);\n\n#else\nstatic inline void preempt_latency_start(int val) { }\nstatic inline void preempt_latency_stop(int val) { }\n#endif\n\nstatic inline unsigned long get_preempt_disable_ip(struct task_struct *p)\n{\n#ifdef CONFIG_DEBUG_PREEMPT\n\treturn p->preempt_disable_ip;\n#else\n\treturn 0;\n#endif\n}\n\n/*\n * Print scheduling while atomic bug:\n */\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\t/* Save this before calling printk(), since that will clobber it */\n\tunsigned long preempt_disable_ip = get_preempt_disable_ip(current);\n\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(KERN_ERR, preempt_disable_ip);\n\t}\n\tif (panic_on_warn)\n\t\tpanic(\"scheduling while atomic\\n\");\n\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\n\n/*\n * Various schedule()-time debugging checks and statistics:\n */\nstatic inline void schedule_debug(struct task_struct *prev, bool preempt)\n{\n#ifdef CONFIG_SCHED_STACK_END_CHECK\n\tif (task_stack_end_corrupted(prev))\n\t\tpanic(\"corrupted stack end detected inside scheduler\\n\");\n\n\tif (task_scs_end_corrupted(prev))\n\t\tpanic(\"corrupted shadow stack detected inside scheduler\\n\");\n#endif\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\n\tif (!preempt && prev->state && prev->non_block_count) {\n\t\tprintk(KERN_ERR \"BUG: scheduling in a non-blocking section: %s/%d/%i\\n\",\n\t\t\tprev->comm, prev->pid, prev->non_block_count);\n\t\tdump_stack();\n\t\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n\t}\n#endif\n\n\tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\tSCHED_WARN_ON(ct_state() == CONTEXT_USER);\n\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\n\tschedstat_inc(this_rq()->sched_count);\n}\n\nstatic void put_prev_task_balance(struct rq *rq, struct task_struct *prev,\n\t\t\t\t  struct rq_flags *rf)\n{\n#ifdef CONFIG_SMP\n\tconst struct sched_class *class;\n\t/*\n\t * We must do the balancing pass before put_prev_task(), such\n\t * that when we release the rq->lock the task is in the same\n\t * state as before we took rq->lock.\n\t *\n\t * We can terminate the balance pass as soon as we know there is\n\t * a runnable task of @class priority or higher.\n\t */\n\tfor_class_range(class, prev->sched_class, &idle_sched_class) {\n\t\tif (class->balance(rq, prev, rf))\n\t\t\tbreak;\n\t}\n#endif\n\n\tput_prev_task(rq, prev);\n}\n\n/*\n * Pick up the highest-prio task:\n */\nstatic inline struct task_struct *\npick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\n\t/*\n\t * Optimization: we know that if all tasks are in the fair class we can\n\t * call that function directly, but only if the @prev task wasn't of a\n\t * higher scheduling class, because otherwise those lose the\n\t * opportunity to pull in more work from other CPUs.\n\t */\n\tif (likely(prev->sched_class <= &fair_sched_class &&\n\t\t   rq->nr_running == rq->cfs.h_nr_running)) {\n\n\t\tp = pick_next_task_fair(rq, prev, rf);\n\t\tif (unlikely(p == RETRY_TASK))\n\t\t\tgoto restart;\n\n\t\t/* Assumes fair_sched_class->next == idle_sched_class */\n\t\tif (!p) {\n\t\t\tput_prev_task(rq, prev);\n\t\t\tp = pick_next_task_idle(rq);\n\t\t}\n\n\t\treturn p;\n\t}\n\nrestart:\n\tput_prev_task_balance(rq, prev, rf);\n\n\tfor_each_class(class) {\n\t\tp = class->pick_next_task(rq);\n\t\tif (p)\n\t\t\treturn p;\n\t}\n\n\t/* The idle class should always have a runnable task: */\n\tBUG();\n}\n\n/*\n * __schedule() is the main scheduler function.\n *\n * The main means of driving the scheduler and thus entering this function are:\n *\n *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.\n *\n *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return\n *      paths. For example, see arch/x86/entry_64.S.\n *\n *      To drive preemption between tasks, the scheduler sets the flag in timer\n *      interrupt handler scheduler_tick().\n *\n *   3. Wakeups don't really cause entry into schedule(). They add a\n *      task to the run-queue and that's it.\n *\n *      Now, if the new task added to the run-queue preempts the current\n *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets\n *      called on the nearest possible occasion:\n *\n *       - If the kernel is preemptible (CONFIG_PREEMPTION=y):\n *\n *         - in syscall or exception context, at the next outmost\n *           preempt_enable(). (this might be as soon as the wake_up()'s\n *           spin_unlock()!)\n *\n *         - in IRQ context, return from interrupt-handler to\n *           preemptible context\n *\n *       - If the kernel is not preemptible (CONFIG_PREEMPTION is not set)\n *         then at the next:\n *\n *          - cond_resched() call\n *          - explicit schedule() call\n *          - return from syscall or exception to user-space\n *          - return from interrupt-handler to user-space\n *\n * WARNING: must be called with preemption disabled!\n */\nstatic void __sched notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tunsigned long prev_state;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev, preempt);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up():\n\t *\n\t * __set_current_state(@state)\t\tsignal_wake_up()\n\t * schedule()\t\t\t\t  set_tsk_thread_flag(p, TIF_SIGPENDING)\n\t *\t\t\t\t\t  wake_up_state(p, state)\n\t *   LOCK rq->lock\t\t\t    LOCK p->pi_state\n\t *   smp_mb__after_spinlock()\t\t    smp_mb__after_spinlock()\n\t *     if (signal_pending_state())\t    if (p->state & @state)\n\t *\n\t * Also, the membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\n\t/*\n\t * We must load prev->state once (task_struct::state is volatile), such\n\t * that:\n\t *\n\t *  - we form a control dependency vs deactivate_task() below.\n\t *  - ptrace_{,un}freeze_traced() can change ->state underneath us.\n\t */\n\tprev_state = prev->state;\n\tif (!preempt && prev_state) {\n\t\tif (signal_pending_state(prev_state, prev)) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tprev->sched_contributes_to_load =\n\t\t\t\t(prev_state & TASK_UNINTERRUPTIBLE) &&\n\t\t\t\t!(prev_state & TASK_NOLOAD) &&\n\t\t\t\t!(prev->flags & PF_FROZEN);\n\n\t\t\tif (prev->sched_contributes_to_load)\n\t\t\t\trq->nr_uninterruptible++;\n\n\t\t\t/*\n\t\t\t * __schedule()\t\t\tttwu()\n\t\t\t *   prev_state = prev->state;    if (p->on_rq && ...)\n\t\t\t *   if (prev_state)\t\t    goto out;\n\t\t\t *     p->on_rq = 0;\t\t  smp_acquire__after_ctrl_dep();\n\t\t\t *\t\t\t\t  p->state = TASK_WAKING\n\t\t\t *\n\t\t\t * Where __schedule() and ttwu() have matching control dependencies.\n\t\t\t *\n\t\t\t * After this, schedule() must not care about p->state any more.\n\t\t\t */\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\t/*\n\t\t * RCU users of rcu_dereference(rq->curr) may not see\n\t\t * changes to task_struct made by pick_next_task().\n\t\t */\n\t\tRCU_INIT_POINTER(rq->curr, next);\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\tmigrate_disable_switch(rq, prev);\n\t\tpsi_sched_switch(prev, next, !task_on_rq_queued(prev));\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);\n\t} else {\n\t\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\t\trq_unpin_lock(rq, &rf);\n\t\t__balance_callbacks(rq);\n\t\traw_spin_unlock_irq(&rq->lock);\n\t}\n}\n\nvoid __noreturn do_task_dead(void)\n{\n\t/* Causes final put_task_struct in finish_task_switch(): */\n\tset_special_state(TASK_DEAD);\n\n\t/* Tell freezer to ignore us: */\n\tcurrent->flags |= PF_NOFREEZE;\n\n\t__schedule(false);\n\tBUG();\n\n\t/* Avoid \"noreturn function does return\" - but don't continue if BUG() is a NOP: */\n\tfor (;;)\n\t\tcpu_relax();\n}\n\nstatic inline void sched_submit_work(struct task_struct *tsk)\n{\n\tunsigned int task_flags;\n\n\tif (!tsk->state)\n\t\treturn;\n\n\ttask_flags = tsk->flags;\n\t/*\n\t * If a worker went to sleep, notify and ask workqueue whether\n\t * it wants to wake up a task to maintain concurrency.\n\t * As this function is called inside the schedule() context,\n\t * we disable preemption to avoid it calling schedule() again\n\t * in the possible wakeup of a kworker and because wq_worker_sleeping()\n\t * requires it.\n\t */\n\tif (task_flags & (PF_WQ_WORKER | PF_IO_WORKER)) {\n\t\tpreempt_disable();\n\t\tif (task_flags & PF_WQ_WORKER)\n\t\t\twq_worker_sleeping(tsk);\n\t\telse\n\t\t\tio_wq_worker_sleeping(tsk);\n\t\tpreempt_enable_no_resched();\n\t}\n\n\tif (tsk_is_pi_blocked(tsk))\n\t\treturn;\n\n\t/*\n\t * If we are going to sleep and we have plugged IO queued,\n\t * make sure to submit it to avoid deadlocks.\n\t */\n\tif (blk_needs_flush_plug(tsk))\n\t\tblk_schedule_flush_plug(tsk);\n}\n\nstatic void sched_update_worker(struct task_struct *tsk)\n{\n\tif (tsk->flags & (PF_WQ_WORKER | PF_IO_WORKER)) {\n\t\tif (tsk->flags & PF_WQ_WORKER)\n\t\t\twq_worker_running(tsk);\n\t\telse\n\t\t\tio_wq_worker_running(tsk);\n\t}\n}\n\nasmlinkage __visible void __sched schedule(void)\n{\n\tstruct task_struct *tsk = current;\n\n\tsched_submit_work(tsk);\n\tdo {\n\t\tpreempt_disable();\n\t\t__schedule(false);\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\tsched_update_worker(tsk);\n}\nEXPORT_SYMBOL(schedule);\n\n/*\n * synchronize_rcu_tasks() makes sure that no task is stuck in preempted\n * state (have scheduled out non-voluntarily) by making sure that all\n * tasks have either left the run queue or have gone into user space.\n * As idle tasks do not do either, they must not ever be preempted\n * (schedule out non-voluntarily).\n *\n * schedule_idle() is similar to schedule_preempt_disable() except that it\n * never enables preemption because it does not call sched_submit_work().\n */\nvoid __sched schedule_idle(void)\n{\n\t/*\n\t * As this skips calling sched_submit_work(), which the idle task does\n\t * regardless because that function is a nop when the task is in a\n\t * TASK_RUNNING state, make sure this isn't used someplace that the\n\t * current task can be in any other state. Note, idle is always in the\n\t * TASK_RUNNING state.\n\t */\n\tWARN_ON_ONCE(current->state);\n\tdo {\n\t\t__schedule(false);\n\t} while (need_resched());\n}\n\n#if defined(CONFIG_CONTEXT_TRACKING) && !defined(CONFIG_HAVE_CONTEXT_TRACKING_OFFSTACK)\nasmlinkage __visible void __sched schedule_user(void)\n{\n\t/*\n\t * If we come here after a random call to set_need_resched(),\n\t * or we have been woken up remotely but the IPI has not yet arrived,\n\t * we haven't yet exited the RCU idle mode. Do it here manually until\n\t * we find a better solution.\n\t *\n\t * NB: There are buggy callers of this function.  Ideally we\n\t * should warn if prev_state != CONTEXT_USER, but that will trigger\n\t * too frequently to make sense yet.\n\t */\n\tenum ctx_state prev_state = exception_enter();\n\tschedule();\n\texception_exit(prev_state);\n}\n#endif\n\n/**\n * schedule_preempt_disabled - called with preemption disabled\n *\n * Returns with preemption disabled. Note: preempt_count must be 1\n */\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}\n\nstatic void __sched notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}\n\n#ifdef CONFIG_PREEMPTION\n/*\n * This is the entry point to schedule() from in-kernel preemption\n * off of preempt_enable.\n */\nasmlinkage __visible void __sched notrace preempt_schedule(void)\n{\n\t/*\n\t * If there is a non-zero preempt_count or interrupts are disabled,\n\t * we do not want to preempt the current task. Just return..\n\t */\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tpreempt_schedule_common();\n}\nNOKPROBE_SYMBOL(preempt_schedule);\nEXPORT_SYMBOL(preempt_schedule);\n\n/**\n * preempt_schedule_notrace - preempt_schedule called by tracing\n *\n * The tracing infrastructure uses preempt_enable_notrace to prevent\n * recursion and tracing preempt enabling caused by the tracing\n * infrastructure itself. But as tracing can happen in areas coming\n * from userspace or just about to enter userspace, a preempt enable\n * can occur before user_exit() is called. This will cause the scheduler\n * to be called when the system is still in usermode.\n *\n * To prevent this, the preempt_enable_notrace will use this function\n * instead of preempt_schedule() to exit user context if needed before\n * calling the scheduler.\n */\nasmlinkage __visible void __sched notrace preempt_schedule_notrace(void)\n{\n\tenum ctx_state prev_ctx;\n\n\tif (likely(!preemptible()))\n\t\treturn;\n\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t/*\n\t\t * Needs preempt disabled in case user_exit() is traced\n\t\t * and the tracer calls preempt_enable_notrace() causing\n\t\t * an infinite recursion.\n\t\t */\n\t\tprev_ctx = exception_enter();\n\t\t__schedule(true);\n\t\texception_exit(prev_ctx);\n\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\t} while (need_resched());\n}\nEXPORT_SYMBOL_GPL(preempt_schedule_notrace);\n\n#endif /* CONFIG_PREEMPTION */\n\n/*\n * This is the entry point to schedule() from kernel preemption\n * off of irq context.\n * Note, that this is called and return with irqs disabled. This will\n * protect us against recursive calling from irq.\n */\nasmlinkage __visible void __sched preempt_schedule_irq(void)\n{\n\tenum ctx_state prev_state;\n\n\t/* Catch callers which need to be fixed */\n\tBUG_ON(preempt_count() || !irqs_disabled());\n\n\tprev_state = exception_enter();\n\n\tdo {\n\t\tpreempt_disable();\n\t\tlocal_irq_enable();\n\t\t__schedule(true);\n\t\tlocal_irq_disable();\n\t\tsched_preempt_enable_no_resched();\n\t} while (need_resched());\n\n\texception_exit(prev_state);\n}\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}\nEXPORT_SYMBOL(default_wake_function);\n\n#ifdef CONFIG_RT_MUTEXES\n\nstatic inline int __rt_effective_prio(struct task_struct *pi_task, int prio)\n{\n\tif (pi_task)\n\t\tprio = min(prio, pi_task->prio);\n\n\treturn prio;\n}\n\nstatic inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\n\treturn __rt_effective_prio(pi_task, prio);\n}\n\n/*\n * rt_mutex_setprio - set the current priority of a task\n * @p: task to boost\n * @pi_task: donor task\n *\n * This function changes the 'effective' priority of a task. It does\n * not touch ->normal_prio like __setscheduler().\n *\n * Used by the rt_mutex code to implement priority inheritance\n * logic. Call site only calls if the priority of the task changed.\n */\nvoid rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task)\n{\n\tint prio, oldprio, queued, running, queue_flag =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tconst struct sched_class *prev_class;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\t/* XXX used to be waiter->prio, not waiter->task->prio */\n\tprio = __rt_effective_prio(pi_task, p->normal_prio);\n\n\t/*\n\t * If nothing changed; bail early.\n\t */\n\tif (p->pi_top_task == pi_task && prio == p->prio && !dl_prio(prio))\n\t\treturn;\n\n\trq = __task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\t/*\n\t * Set under pi_lock && rq->lock, such that the value can be used under\n\t * either lock.\n\t *\n\t * Note that there is loads of tricky to make this pointer cache work\n\t * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to\n\t * ensure a task is de-boosted (pi_task is set to NULL) before the\n\t * task is allowed to run again (and can exit). This ensures the pointer\n\t * points to a blocked task -- which guarantees the task is present.\n\t */\n\tp->pi_top_task = pi_task;\n\n\t/*\n\t * For FIFO/RR we only need to set prio, if that matches we're done.\n\t */\n\tif (prio == p->prio && !dl_prio(prio))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Idle task boosting is a nono in general. There is one\n\t * exception, when PREEMPT_RT and NOHZ is active:\n\t *\n\t * The idle task calls get_next_timer_interrupt() and holds\n\t * the timer wheel base->lock on the CPU and another CPU wants\n\t * to access the timer (probably to cancel it). We can safely\n\t * ignore the boosting request, as the idle CPU runs this code\n\t * with interrupts disabled and will complete the lock\n\t * protected section without being interrupted. So there is no\n\t * real need to boost.\n\t */\n\tif (unlikely(p == rq->idle)) {\n\t\tWARN_ON(p != rq->curr);\n\t\tWARN_ON(p->pi_blocked_on);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_sched_pi_setprio(p, pi_task);\n\toldprio = p->prio;\n\n\tif (oldprio == prio)\n\t\tqueue_flag &= ~DEQUEUE_MOVE;\n\n\tprev_class = p->sched_class;\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flag);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\t/*\n\t * Boosting condition are:\n\t * 1. -rt task is running and holds mutex A\n\t *      --> -dl task blocks on mutex A\n\t *\n\t * 2. -dl task is running and holds mutex A\n\t *      --> -dl task blocks on mutex A and could preempt the\n\t *          running task\n\t */\n\tif (dl_prio(prio)) {\n\t\tif (!dl_prio(p->normal_prio) ||\n\t\t    (pi_task && dl_prio(pi_task->prio) &&\n\t\t     dl_entity_preempt(&pi_task->dl, &p->dl))) {\n\t\t\tp->dl.pi_se = pi_task->dl.pi_se;\n\t\t\tqueue_flag |= ENQUEUE_REPLENISH;\n\t\t} else {\n\t\t\tp->dl.pi_se = &p->dl;\n\t\t}\n\t\tp->sched_class = &dl_sched_class;\n\t} else if (rt_prio(prio)) {\n\t\tif (dl_prio(oldprio))\n\t\t\tp->dl.pi_se = &p->dl;\n\t\tif (oldprio < prio)\n\t\t\tqueue_flag |= ENQUEUE_HEAD;\n\t\tp->sched_class = &rt_sched_class;\n\t} else {\n\t\tif (dl_prio(oldprio))\n\t\t\tp->dl.pi_se = &p->dl;\n\t\tif (rt_prio(oldprio))\n\t\t\tp->rt.timeout = 0;\n\t\tp->sched_class = &fair_sched_class;\n\t}\n\n\tp->prio = prio;\n\n\tif (queued)\n\t\tenqueue_task(rq, p, queue_flag);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\nout_unlock:\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\n\trq_unpin_lock(rq, &rf);\n\t__balance_callbacks(rq);\n\traw_spin_unlock(&rq->lock);\n\n\tpreempt_enable();\n}\n#else\nstatic inline int rt_effective_prio(struct task_struct *p, int prio)\n{\n\treturn prio;\n}\n#endif\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}\nEXPORT_SYMBOL(set_user_nice);\n\n/*\n * can_nice - check if a task can reduce its nice value\n * @p: task\n * @nice: nice value\n */\nint can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}\n\n#ifdef __ARCH_WANT_SYS_NICE\n\n/*\n * sys_nice - change the priority of the current process.\n * @increment: priority increment\n *\n * sys_setpriority is a more generic, but much slower function that\n * does similar things.\n */\nSYSCALL_DEFINE1(nice, int, increment)\n{\n\tlong nice, retval;\n\n\t/*\n\t * Setpriority might change our priority at the same moment.\n\t * We don't have to worry. Conceptually one call occurs first\n\t * and we have a single winner.\n\t */\n\tincrement = clamp(increment, -NICE_WIDTH, NICE_WIDTH);\n\tnice = task_nice(current) + increment;\n\n\tnice = clamp_val(nice, MIN_NICE, MAX_NICE);\n\tif (increment < 0 && !can_nice(current, nice))\n\t\treturn -EPERM;\n\n\tretval = security_task_setnice(current, nice);\n\tif (retval)\n\t\treturn retval;\n\n\tset_user_nice(current, nice);\n\treturn 0;\n}\n\n#endif\n\n/**\n * task_prio - return the priority value of a given task.\n * @p: the task in question.\n *\n * Return: The priority value as seen by users in /proc.\n * RT tasks are offset by -200. Normal tasks are centered\n * around 0, value goes from -16 to +15.\n */\nint task_prio(const struct task_struct *p)\n{\n\treturn p->prio - MAX_RT_PRIO;\n}\n\n/**\n * idle_cpu - is a given CPU idle currently?\n * @cpu: the processor in question.\n *\n * Return: 1 if the CPU is currently idle. 0 otherwise.\n */\nint idle_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (rq->curr != rq->idle)\n\t\treturn 0;\n\n\tif (rq->nr_running)\n\t\treturn 0;\n\n#ifdef CONFIG_SMP\n\tif (rq->ttwu_pending)\n\t\treturn 0;\n#endif\n\n\treturn 1;\n}\n\n/**\n * available_idle_cpu - is a given CPU idle for enqueuing work.\n * @cpu: the CPU in question.\n *\n * Return: 1 if the CPU is currently idle. 0 otherwise.\n */\nint available_idle_cpu(int cpu)\n{\n\tif (!idle_cpu(cpu))\n\t\treturn 0;\n\n\tif (vcpu_is_preempted(cpu))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * idle_task - return the idle task for a given CPU.\n * @cpu: the processor in question.\n *\n * Return: The idle task for the CPU @cpu.\n */\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}\n\n/**\n * find_process_by_pid - find a process with a matching PID value.\n * @pid: the pid in question.\n *\n * The task of @pid, if found. %NULL otherwise.\n */\nstatic struct task_struct *find_process_by_pid(pid_t pid)\n{\n\treturn pid ? find_task_by_vpid(pid) : current;\n}\n\n/*\n * sched_setparam() passes in -1 for its policy, to let the functions\n * it calls know not to change it.\n */\n#define SETPARAM_POLICY\t-1\n\nstatic void __setscheduler_params(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tint policy = attr->sched_policy;\n\n\tif (policy == SETPARAM_POLICY)\n\t\tpolicy = p->policy;\n\n\tp->policy = policy;\n\n\tif (dl_policy(policy))\n\t\t__setparam_dl(p, attr);\n\telse if (fair_policy(policy))\n\t\tp->static_prio = NICE_TO_PRIO(attr->sched_nice);\n\n\t/*\n\t * __sched_setscheduler() ensures attr->sched_priority == 0 when\n\t * !rt_policy. Always setting this ensures that things like\n\t * getparam()/getattr() don't report silly values for !rt tasks.\n\t */\n\tp->rt_priority = attr->sched_priority;\n\tp->normal_prio = normal_prio(p);\n\tset_load_weight(p, true);\n}\n\n/* Actually do priority change: must hold pi & rq lock. */\nstatic void __setscheduler(struct rq *rq, struct task_struct *p,\n\t\t\t   const struct sched_attr *attr, bool keep_boost)\n{\n\t/*\n\t * If params can't change scheduling class changes aren't allowed\n\t * either.\n\t */\n\tif (attr->sched_flags & SCHED_FLAG_KEEP_PARAMS)\n\t\treturn;\n\n\t__setscheduler_params(p, attr);\n\n\t/*\n\t * Keep a potential priority boosting if called from\n\t * sched_setscheduler().\n\t */\n\tp->prio = normal_prio(p);\n\tif (keep_boost)\n\t\tp->prio = rt_effective_prio(p, p->prio);\n\n\tif (dl_prio(p->prio))\n\t\tp->sched_class = &dl_sched_class;\n\telse if (rt_prio(p->prio))\n\t\tp->sched_class = &rt_sched_class;\n\telse\n\t\tp->sched_class = &fair_sched_class;\n}\n\n/*\n * Check the target process has a UID that matches the current process's:\n */\nstatic bool check_same_owner(struct task_struct *p)\n{\n\tconst struct cred *cred = current_cred(), *pcred;\n\tbool match;\n\n\trcu_read_lock();\n\tpcred = __task_cred(p);\n\tmatch = (uid_eq(cred->euid, pcred->euid) ||\n\t\t uid_eq(cred->euid, pcred->uid));\n\trcu_read_unlock();\n\treturn match;\n}\n\nstatic int __sched_setscheduler(struct task_struct *p,\n\t\t\t\tconst struct sched_attr *attr,\n\t\t\t\tbool user, bool pi)\n{\n\tint newprio = dl_policy(attr->sched_policy) ? MAX_DL_PRIO - 1 :\n\t\t      MAX_RT_PRIO - 1 - attr->sched_priority;\n\tint retval, oldprio, oldpolicy = -1, queued, running;\n\tint new_effective_prio, policy = attr->sched_policy;\n\tconst struct sched_class *prev_class;\n\tstruct callback_head *head;\n\tstruct rq_flags rf;\n\tint reset_on_fork;\n\tint queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq *rq;\n\n\t/* The pi code expects interrupts enabled */\n\tBUG_ON(pi && in_interrupt());\nrecheck:\n\t/* Double check policy once rq lock held: */\n\tif (policy < 0) {\n\t\treset_on_fork = p->sched_reset_on_fork;\n\t\tpolicy = oldpolicy = p->policy;\n\t} else {\n\t\treset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);\n\n\t\tif (!valid_policy(policy))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Valid priorities for SCHED_FIFO and SCHED_RR are\n\t * 1..MAX_USER_RT_PRIO-1, valid priority for SCHED_NORMAL,\n\t * SCHED_BATCH and SCHED_IDLE is 0.\n\t */\n\tif ((p->mm && attr->sched_priority > MAX_USER_RT_PRIO-1) ||\n\t    (!p->mm && attr->sched_priority > MAX_RT_PRIO-1))\n\t\treturn -EINVAL;\n\tif ((dl_policy(policy) && !__checkparam_dl(attr)) ||\n\t    (rt_policy(policy) != (attr->sched_priority != 0)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Allow unprivileged RT tasks to decrease priority:\n\t */\n\tif (user && !capable(CAP_SYS_NICE)) {\n\t\tif (fair_policy(policy)) {\n\t\t\tif (attr->sched_nice < task_nice(p) &&\n\t\t\t    !can_nice(p, attr->sched_nice))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (rt_policy(policy)) {\n\t\t\tunsigned long rlim_rtprio =\n\t\t\t\t\ttask_rlimit(p, RLIMIT_RTPRIO);\n\n\t\t\t/* Can't set/change the rt policy: */\n\t\t\tif (policy != p->policy && !rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\n\t\t\t/* Can't increase priority: */\n\t\t\tif (attr->sched_priority > p->rt_priority &&\n\t\t\t    attr->sched_priority > rlim_rtprio)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t /*\n\t\t  * Can't set/change SCHED_DEADLINE policy at all for now\n\t\t  * (safest behavior); in the future we would like to allow\n\t\t  * unprivileged DL tasks to increase their relative deadline\n\t\t  * or reduce their runtime (both ways reducing utilization)\n\t\t  */\n\t\tif (dl_policy(policy))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Treat SCHED_IDLE as nice 20. Only allow a switch to\n\t\t * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.\n\t\t */\n\t\tif (task_has_idle_policy(p) && !idle_policy(policy)) {\n\t\t\tif (!can_nice(p, task_nice(p)))\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Can't change other user's priorities: */\n\t\tif (!check_same_owner(p))\n\t\t\treturn -EPERM;\n\n\t\t/* Normal users shall not reset the sched_reset_on_fork flag: */\n\t\tif (p->sched_reset_on_fork && !reset_on_fork)\n\t\t\treturn -EPERM;\n\t}\n\n\tif (user) {\n\t\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\t\treturn -EINVAL;\n\n\t\tretval = security_task_setscheduler(p);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t/* Update task specific \"requested\" clamps */\n\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP) {\n\t\tretval = uclamp_validate(p, attr);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tif (pi)\n\t\tcpuset_read_lock();\n\n\t/*\n\t * Make sure no PI-waiters arrive (or leave) while we are\n\t * changing the priority of the task:\n\t *\n\t * To be able to change p->policy safely, the appropriate\n\t * runqueue lock must be held.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Changing the policy of the stop threads its a very bad idea:\n\t */\n\tif (p == rq->stop) {\n\t\tretval = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * If not changing anything there's no need to proceed further,\n\t * but store a possible modification of reset_on_fork.\n\t */\n\tif (unlikely(policy == p->policy)) {\n\t\tif (fair_policy(policy) && attr->sched_nice != task_nice(p))\n\t\t\tgoto change;\n\t\tif (rt_policy(policy) && attr->sched_priority != p->rt_priority)\n\t\t\tgoto change;\n\t\tif (dl_policy(policy) && dl_param_changed(p, attr))\n\t\t\tgoto change;\n\t\tif (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP)\n\t\t\tgoto change;\n\n\t\tp->sched_reset_on_fork = reset_on_fork;\n\t\tretval = 0;\n\t\tgoto unlock;\n\t}\nchange:\n\n\tif (user) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\t/*\n\t\t * Do not allow realtime tasks into groups that have no runtime\n\t\t * assigned.\n\t\t */\n\t\tif (rt_bandwidth_enabled() && rt_policy(policy) &&\n\t\t\t\ttask_group(p)->rt_bandwidth.rt_runtime == 0 &&\n\t\t\t\t!task_group_is_autogroup(task_group(p))) {\n\t\t\tretval = -EPERM;\n\t\t\tgoto unlock;\n\t\t}\n#endif\n#ifdef CONFIG_SMP\n\t\tif (dl_bandwidth_enabled() && dl_policy(policy) &&\n\t\t\t\t!(attr->sched_flags & SCHED_FLAG_SUGOV)) {\n\t\t\tcpumask_t *span = rq->rd->span;\n\n\t\t\t/*\n\t\t\t * Don't allow tasks with an affinity mask smaller than\n\t\t\t * the entire root_domain to become SCHED_DEADLINE. We\n\t\t\t * will also fail if there's no bandwidth available.\n\t\t\t */\n\t\t\tif (!cpumask_subset(span, p->cpus_ptr) ||\n\t\t\t    rq->rd->dl_bw.bw == 0) {\n\t\t\t\tretval = -EPERM;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Re-check policy now with rq lock held: */\n\tif (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {\n\t\tpolicy = oldpolicy = -1;\n\t\ttask_rq_unlock(rq, p, &rf);\n\t\tif (pi)\n\t\t\tcpuset_read_unlock();\n\t\tgoto recheck;\n\t}\n\n\t/*\n\t * If setscheduling to SCHED_DEADLINE (or changing the parameters\n\t * of a SCHED_DEADLINE task) we need to check if enough bandwidth\n\t * is available.\n\t */\n\tif ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {\n\t\tretval = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tp->sched_reset_on_fork = reset_on_fork;\n\toldprio = p->prio;\n\n\tif (pi) {\n\t\t/*\n\t\t * Take priority boosted tasks into account. If the new\n\t\t * effective priority is unchanged, we just store the new\n\t\t * normal parameters and do not touch the scheduler class and\n\t\t * the runqueue. This will be done when the task deboost\n\t\t * itself.\n\t\t */\n\t\tnew_effective_prio = rt_effective_prio(p, newprio);\n\t\tif (new_effective_prio == oldprio)\n\t\t\tqueue_flags &= ~DEQUEUE_MOVE;\n\t}\n\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tprev_class = p->sched_class;\n\n\t__setscheduler(rq, p, attr, pi);\n\t__setscheduler_uclamp(p, attr);\n\n\tif (queued) {\n\t\t/*\n\t\t * We enqueue to tail when the priority of a task is\n\t\t * increased (user space view).\n\t\t */\n\t\tif (oldprio < p->prio)\n\t\t\tqueue_flags |= ENQUEUE_HEAD;\n\n\t\tenqueue_task(rq, p, queue_flags);\n\t}\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\tcheck_class_changed(rq, p, prev_class, oldprio);\n\n\t/* Avoid rq from going away on us: */\n\tpreempt_disable();\n\thead = splice_balance_callbacks(rq);\n\ttask_rq_unlock(rq, p, &rf);\n\n\tif (pi) {\n\t\tcpuset_read_unlock();\n\t\trt_mutex_adjust_pi(p);\n\t}\n\n\t/* Run balance callbacks after we've adjusted the PI chain: */\n\tbalance_callbacks(rq, head);\n\tpreempt_enable();\n\n\treturn 0;\n\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\tif (pi)\n\t\tcpuset_read_unlock();\n\treturn retval;\n}\n\nstatic int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\n\t/* Fixup the legacy SCHED_RESET_ON_FORK hack. */\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\n\treturn __sched_setscheduler(p, &attr, check, true);\n}\n/**\n * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.\n * @p: the task in question.\n * @policy: new policy.\n * @param: structure containing the new RT priority.\n *\n * Use sched_set_fifo(), read its comment.\n *\n * Return: 0 on success. An error code otherwise.\n *\n * NOTE that the task may be already dead.\n */\nint sched_setscheduler(struct task_struct *p, int policy,\n\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, true);\n}\n\nint sched_setattr(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, true, true);\n}\n\nint sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}\n\n/**\n * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.\n * @p: the task in question.\n * @policy: new policy.\n * @param: structure containing the new RT priority.\n *\n * Just like sched_setscheduler, only don't bother checking if the\n * current context has permission.  For example, this is needed in\n * stop_machine(): we create temporary high priority worker threads,\n * but our caller might not have that capability.\n *\n * Return: 0 on success. An error code otherwise.\n */\nint sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param)\n{\n\treturn _sched_setscheduler(p, policy, param, false);\n}\n\n/*\n * SCHED_FIFO is a broken scheduler model; that is, it is fundamentally\n * incapable of resource management, which is the one thing an OS really should\n * be doing.\n *\n * This is of course the reason it is limited to privileged users only.\n *\n * Worse still; it is fundamentally impossible to compose static priority\n * workloads. You cannot take two correctly working static prio workloads\n * and smash them together and still expect them to work.\n *\n * For this reason 'all' FIFO tasks the kernel creates are basically at:\n *\n *   MAX_RT_PRIO / 2\n *\n * The administrator _MUST_ configure the system, the kernel simply doesn't\n * know enough information to make a sensible choice.\n */\nvoid sched_set_fifo(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = MAX_RT_PRIO / 2 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}\nEXPORT_SYMBOL_GPL(sched_set_fifo);\n\n/*\n * For when you don't much care about FIFO, but want to be above SCHED_NORMAL.\n */\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}\nEXPORT_SYMBOL_GPL(sched_set_fifo_low);\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}\nEXPORT_SYMBOL_GPL(sched_set_normal);\n\nstatic int\ndo_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)\n{\n\tstruct sched_param lparam;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -EFAULT;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (likely(p))\n\t\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (likely(p)) {\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\t\tput_task_struct(p);\n\t}\n\n\treturn retval;\n}\n\n/*\n * Mimics kernel/events/core.c perf_copy_attr().\n */\nstatic int sched_copy_attr(struct sched_attr __user *uattr, struct sched_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\t/* Zero the full structure, so that a short copy will be nice: */\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* ABI compatibility quirk: */\n\tif (!size)\n\t\tsize = SCHED_ATTR_SIZE_VER0;\n\tif (size < SCHED_ATTR_SIZE_VER0 || size > PAGE_SIZE)\n\t\tgoto err_size;\n\n\tret = copy_struct_from_user(attr, sizeof(*attr), uattr, size);\n\tif (ret) {\n\t\tif (ret == -E2BIG)\n\t\t\tgoto err_size;\n\t\treturn ret;\n\t}\n\n\tif ((attr->sched_flags & SCHED_FLAG_UTIL_CLAMP) &&\n\t    size < SCHED_ATTR_SIZE_VER1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * XXX: Do we want to be lenient like existing syscalls; or do we want\n\t * to be strict and return an error on out-of-bounds values?\n\t */\n\tattr->sched_nice = clamp(attr->sched_nice, MIN_NICE, MAX_NICE);\n\n\treturn 0;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\treturn -E2BIG;\n}\n\n/**\n * sys_sched_setscheduler - set/change the scheduler policy and RT priority\n * @pid: the pid in question.\n * @policy: new policy.\n * @param: structure containing the new RT priority.\n *\n * Return: 0 on success. An error code otherwise.\n */\nSYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, struct sched_param __user *, param)\n{\n\tif (policy < 0)\n\t\treturn -EINVAL;\n\n\treturn do_sched_setscheduler(pid, policy, param);\n}\n\n/**\n * sys_sched_setparam - set/change the RT priority of a thread\n * @pid: the pid in question.\n * @param: structure containing the new RT priority.\n *\n * Return: 0 on success. An error code otherwise.\n */\nSYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)\n{\n\treturn do_sched_setscheduler(pid, SETPARAM_POLICY, param);\n}\n\n/**\n * sys_sched_setattr - same as above, but with extended sched_attr\n * @pid: the pid in question.\n * @uattr: structure containing the extended parameters.\n * @flags: for future extension.\n */\nSYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\tif (attr.sched_flags & SCHED_FLAG_KEEP_POLICY)\n\t\tattr.sched_policy = SETPARAM_POLICY;\n\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (likely(p))\n\t\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (likely(p)) {\n\t\tretval = sched_setattr(p, &attr);\n\t\tput_task_struct(p);\n\t}\n\n\treturn retval;\n}\n\n/**\n * sys_sched_getscheduler - get the policy (scheduling class) of a thread\n * @pid: the pid in question.\n *\n * Return: On success, the policy of the thread. Otherwise, a negative error\n * code.\n */\nSYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (p) {\n\t\tretval = security_task_getscheduler(p);\n\t\tif (!retval)\n\t\t\tretval = p->policy\n\t\t\t\t| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);\n\t}\n\trcu_read_unlock();\n\treturn retval;\n}\n\n/**\n * sys_sched_getparam - get the RT priority of a thread\n * @pid: the pid in question.\n * @param: structure containing the RT priority.\n *\n * Return: On success, 0 and the RT priority is in @param. Otherwise, an error\n * code.\n */\nSYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)\n{\n\tstruct sched_param lp = { .sched_priority = 0 };\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!param || pid < 0)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tif (task_has_rt_policy(p))\n\t\tlp.sched_priority = p->rt_priority;\n\trcu_read_unlock();\n\n\t/*\n\t * This one might sleep, we cannot do it with a spinlock held ...\n\t */\n\tretval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;\n\n\treturn retval;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}\n\n/*\n * Copy the kernel size attribute structure (which might be larger\n * than what user-space knows about) to user-space.\n *\n * Note that all cases are valid: user-space buffer can be larger or\n * smaller than the kernel-space buffer. The usual case is that both\n * have the same size.\n */\nstatic int\nsched_attr_copy_to_user(struct sched_attr __user *uattr,\n\t\t\tstruct sched_attr *kattr,\n\t\t\tunsigned int usize)\n{\n\tunsigned int ksize = sizeof(*kattr);\n\n\tif (!access_ok(uattr, usize))\n\t\treturn -EFAULT;\n\n\t/*\n\t * sched_getattr() ABI forwards and backwards compatibility:\n\t *\n\t * If usize == ksize then we just copy everything to user-space and all is good.\n\t *\n\t * If usize < ksize then we only copy as much as user-space has space for,\n\t * this keeps ABI compatibility as well. We skip the rest.\n\t *\n\t * If usize > ksize then user-space is using a newer version of the ABI,\n\t * which part the kernel doesn't know about. Just ignore it - tooling can\n\t * detect the kernel's knowledge of attributes from the attr->size value\n\t * which is set to ksize in this case.\n\t */\n\tkattr->size = min(usize, ksize);\n\n\tif (copy_to_user(uattr, kattr, kattr->size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n/**\n * sys_sched_getattr - similar to sched_getparam, but with sched_attr\n * @pid: the pid in question.\n * @uattr: structure containing the extended parameters.\n * @usize: sizeof(attr) for fwd/bwd comp.\n * @flags: for future extension.\n */\nSYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\tunsigned int, usize, unsigned int, flags)\n{\n\tstruct sched_attr kattr = { };\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || usize > PAGE_SIZE ||\n\t    usize < SCHED_ATTR_SIZE_VER0 || flags)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tkattr.sched_policy = p->policy;\n\tif (p->sched_reset_on_fork)\n\t\tkattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\tif (task_has_dl_policy(p))\n\t\t__getparam_dl(p, &kattr);\n\telse if (task_has_rt_policy(p))\n\t\tkattr.sched_priority = p->rt_priority;\n\telse\n\t\tkattr.sched_nice = task_nice(p);\n\n#ifdef CONFIG_UCLAMP_TASK\n\t/*\n\t * This could race with another potential updater, but this is fine\n\t * because it'll correctly read the old or the new value. We don't need\n\t * to guarantee who wins the race as long as it doesn't return garbage.\n\t */\n\tkattr.sched_util_min = p->uclamp_req[UCLAMP_MIN].value;\n\tkattr.sched_util_max = p->uclamp_req[UCLAMP_MAX].value;\n#endif\n\n\trcu_read_unlock();\n\n\treturn sched_attr_copy_to_user(uattr, &kattr, usize);\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}\n\nlong sched_setaffinity(pid_t pid, const struct cpumask *in_mask)\n{\n\tcpumask_var_t cpus_allowed, new_mask;\n\tstruct task_struct *p;\n\tint retval;\n\n\trcu_read_lock();\n\n\tp = find_process_by_pid(pid);\n\tif (!p) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\n\t/* Prevent p going away */\n\tget_task_struct(p);\n\trcu_read_unlock();\n\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tretval = -EINVAL;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_put_task;\n\t}\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free_cpus_allowed;\n\t}\n\tretval = -EPERM;\n\tif (!check_same_owner(p)) {\n\t\trcu_read_lock();\n\t\tif (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tretval = security_task_setscheduler(p);\n\tif (retval)\n\t\tgoto out_free_new_mask;\n\n\n\tcpuset_cpus_allowed(p, cpus_allowed);\n\tcpumask_and(new_mask, in_mask, cpus_allowed);\n\n\t/*\n\t * Since bandwidth control happens on root_domain basis,\n\t * if admission test is enabled, we only admit -deadline\n\t * tasks allowed to run on all the CPUs in the task's\n\t * root_domain.\n\t */\n#ifdef CONFIG_SMP\n\tif (task_has_dl_policy(p) && dl_bandwidth_enabled()) {\n\t\trcu_read_lock();\n\t\tif (!cpumask_subset(task_rq(p)->rd->span, new_mask)) {\n\t\t\tretval = -EBUSY;\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_free_new_mask;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n#endif\nagain:\n\tretval = __set_cpus_allowed_ptr(p, new_mask, SCA_CHECK);\n\n\tif (!retval) {\n\t\tcpuset_cpus_allowed(p, cpus_allowed);\n\t\tif (!cpumask_subset(new_mask, cpus_allowed)) {\n\t\t\t/*\n\t\t\t * We must have raced with a concurrent cpuset\n\t\t\t * update. Just reset the cpus_allowed to the\n\t\t\t * cpuset's cpus_allowed\n\t\t\t */\n\t\t\tcpumask_copy(new_mask, cpus_allowed);\n\t\t\tgoto again;\n\t\t}\n\t}\nout_free_new_mask:\n\tfree_cpumask_var(new_mask);\nout_free_cpus_allowed:\n\tfree_cpumask_var(cpus_allowed);\nout_put_task:\n\tput_task_struct(p);\n\treturn retval;\n}\n\nstatic int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,\n\t\t\t     struct cpumask *new_mask)\n{\n\tif (len < cpumask_size())\n\t\tcpumask_clear(new_mask);\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\treturn copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;\n}\n\n/**\n * sys_sched_setaffinity - set the CPU affinity of a process\n * @pid: pid of the process\n * @len: length in bytes of the bitmask pointed to by user_mask_ptr\n * @user_mask_ptr: user-space pointer to the new CPU mask\n *\n * Return: 0 on success. An error code otherwise.\n */\nSYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,\n\t\tunsigned long __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval == 0)\n\t\tretval = sched_setaffinity(pid, new_mask);\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}\n\nlong sched_getaffinity(pid_t pid, struct cpumask *mask)\n{\n\tstruct task_struct *p;\n\tunsigned long flags;\n\tint retval;\n\n\trcu_read_lock();\n\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tcpumask_and(mask, &p->cpus_mask, cpu_active_mask);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\nout_unlock:\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n/**\n * sys_sched_getaffinity - get the CPU affinity of a process\n * @pid: pid of the process\n * @len: length in bytes of the bitmask pointed to by user_mask_ptr\n * @user_mask_ptr: user-space pointer to hold the current CPU mask\n *\n * Return: size of CPU mask copied to user_mask_ptr on success. An\n * error code otherwise.\n */\nSYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,\n\t\tunsigned long __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(unsigned long)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (copy_to_user(user_mask_ptr, mask, retlen))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\nstatic void do_sched_yield(void)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = this_rq_lock_irq(&rf);\n\n\tschedstat_inc(rq->yld_count);\n\tcurrent->sched_class->yield_task(rq);\n\n\tpreempt_disable();\n\trq_unlock_irq(rq, &rf);\n\tsched_preempt_enable_no_resched();\n\n\tschedule();\n}\n\n/**\n * sys_sched_yield - yield the current processor to other threads.\n *\n * This function yields the current CPU to other tasks. If there are no\n * other threads running on this CPU then this function will return.\n *\n * Return: 0.\n */\nSYSCALL_DEFINE0(sched_yield)\n{\n\tdo_sched_yield();\n\treturn 0;\n}\n\n#ifndef CONFIG_PREEMPTION\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}\nEXPORT_SYMBOL(_cond_resched);\n#endif\n\n/*\n * __cond_resched_lock() - if a reschedule is pending, drop the given lock,\n * call schedule, and on return reacquire the lock.\n *\n * This works OK both with and without CONFIG_PREEMPTION. We do strange low-level\n * operations here to prevent schedule() from being called twice (once via\n * spin_unlock(), once by hand).\n */\nint __cond_resched_lock(spinlock_t *lock)\n{\n\tint resched = should_resched(PREEMPT_LOCK_OFFSET);\n\tint ret = 0;\n\n\tlockdep_assert_held(lock);\n\n\tif (spin_needbreak(lock) || resched) {\n\t\tspin_unlock(lock);\n\t\tif (resched)\n\t\t\tpreempt_schedule_common();\n\t\telse\n\t\t\tcpu_relax();\n\t\tret = 1;\n\t\tspin_lock(lock);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(__cond_resched_lock);\n\n/**\n * yield - yield the current processor to other threads.\n *\n * Do not ever use this function, there's a 99% chance you're doing it wrong.\n *\n * The scheduler is at all times free to pick the calling task as the most\n * eligible task to run, if removing the yield() call from your code breaks\n * it, it's already broken.\n *\n * Typical broken usage is:\n *\n * while (!event)\n *\tyield();\n *\n * where one assumes that yield() will let 'the other' process run that will\n * make event true. If the current task is a SCHED_FIFO task that will never\n * happen. Never use yield() as a progress guarantee!!\n *\n * If you want to use yield() to wait for something, use wait_event().\n * If you want to use yield() to be 'nice' for others, use cond_resched().\n * If you still want to use yield(), do not!\n */\nvoid __sched yield(void)\n{\n\tset_current_state(TASK_RUNNING);\n\tdo_sched_yield();\n}\nEXPORT_SYMBOL(yield);\n\n/**\n * yield_to - yield the current processor to another thread in\n * your thread group, or accelerate that thread toward the\n * processor it's on.\n * @p: target task\n * @preempt: whether task preemption is allowed or not\n *\n * It's the caller's job to ensure that the target task struct\n * can't go away on us before we can do any checks.\n *\n * Return:\n *\ttrue (>0) if we indeed boosted the target task.\n *\tfalse (0) if we failed to boost the target.\n *\t-ESRCH if there's no task to yield to.\n */\nint __sched yield_to(struct task_struct *p, bool preempt)\n{\n\tstruct task_struct *curr = current;\n\tstruct rq *rq, *p_rq;\n\tunsigned long flags;\n\tint yielded = 0;\n\n\tlocal_irq_save(flags);\n\trq = this_rq();\n\nagain:\n\tp_rq = task_rq(p);\n\t/*\n\t * If we're the only runnable task on the rq and target rq also\n\t * has only one task, there's absolutely no point in yielding.\n\t */\n\tif (rq->nr_running == 1 && p_rq->nr_running == 1) {\n\t\tyielded = -ESRCH;\n\t\tgoto out_irq;\n\t}\n\n\tdouble_rq_lock(rq, p_rq);\n\tif (task_rq(p) != p_rq) {\n\t\tdouble_rq_unlock(rq, p_rq);\n\t\tgoto again;\n\t}\n\n\tif (!curr->sched_class->yield_to_task)\n\t\tgoto out_unlock;\n\n\tif (curr->sched_class != p->sched_class)\n\t\tgoto out_unlock;\n\n\tif (task_running(p_rq, p) || p->state)\n\t\tgoto out_unlock;\n\n\tyielded = curr->sched_class->yield_to_task(rq, p);\n\tif (yielded) {\n\t\tschedstat_inc(rq->yld_count);\n\t\t/*\n\t\t * Make p's CPU reschedule; pick_next_entity takes care of\n\t\t * fairness.\n\t\t */\n\t\tif (preempt && rq != p_rq)\n\t\t\tresched_curr(p_rq);\n\t}\n\nout_unlock:\n\tdouble_rq_unlock(rq, p_rq);\nout_irq:\n\tlocal_irq_restore(flags);\n\n\tif (yielded > 0)\n\t\tschedule();\n\n\treturn yielded;\n}\nEXPORT_SYMBOL_GPL(yield_to);\n\nint io_schedule_prepare(void)\n{\n\tint old_iowait = current->in_iowait;\n\n\tcurrent->in_iowait = 1;\n\tblk_schedule_flush_plug(current);\n\n\treturn old_iowait;\n}\n\nvoid io_schedule_finish(int token)\n{\n\tcurrent->in_iowait = token;\n}\n\n/*\n * This task is about to go to sleep on IO. Increment rq->nr_iowait so\n * that process accounting knows that this is a task in IO wait state.\n */\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(io_schedule_timeout);\n\nvoid __sched io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}\nEXPORT_SYMBOL(io_schedule);\n\n/**\n * sys_sched_get_priority_max - return maximum RT priority.\n * @policy: scheduling class.\n *\n * Return: On success, this syscall returns the maximum\n * rt_priority that can be used by a given scheduling class.\n * On failure, a negative error code is returned.\n */\nSYSCALL_DEFINE1(sched_get_priority_max, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = MAX_USER_RT_PRIO-1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n/**\n * sys_sched_get_priority_min - return minimum RT priority.\n * @policy: scheduling class.\n *\n * Return: On success, this syscall returns the minimum\n * rt_priority that can be used by a given scheduling class.\n * On failure, a negative error code is returned.\n */\nSYSCALL_DEFINE1(sched_get_priority_min, int, policy)\n{\n\tint ret = -EINVAL;\n\n\tswitch (policy) {\n\tcase SCHED_FIFO:\n\tcase SCHED_RR:\n\t\tret = 1;\n\t\tbreak;\n\tcase SCHED_DEADLINE:\n\tcase SCHED_NORMAL:\n\tcase SCHED_BATCH:\n\tcase SCHED_IDLE:\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic int sched_rr_get_interval(pid_t pid, struct timespec64 *t)\n{\n\tstruct task_struct *p;\n\tunsigned int time_slice;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -EINVAL;\n\n\tretval = -ESRCH;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &rf);\n\ttime_slice = 0;\n\tif (p->sched_class->get_rr_interval)\n\t\ttime_slice = p->sched_class->get_rr_interval(rq, p);\n\ttask_rq_unlock(rq, p, &rf);\n\n\trcu_read_unlock();\n\tjiffies_to_timespec64(time_slice, t);\n\treturn 0;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}\n\n/**\n * sys_sched_rr_get_interval - return the default timeslice of a process.\n * @pid: pid of the process.\n * @interval: userspace pointer to the timeslice value.\n *\n * this syscall writes the default timeslice value of a given process\n * into the user-space timespec buffer. A value of '0' means infinity.\n *\n * Return: On success, 0 and the timeslice is in @interval. Otherwise,\n * an error code.\n */\nSYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,\n\t\tstruct __kernel_timespec __user *, interval)\n{\n\tstruct timespec64 t;\n\tint retval = sched_rr_get_interval(pid, &t);\n\n\tif (retval == 0)\n\t\tretval = put_timespec64(&t, interval);\n\n\treturn retval;\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nSYSCALL_DEFINE2(sched_rr_get_interval_time32, pid_t, pid,\n\t\tstruct old_timespec32 __user *, interval)\n{\n\tstruct timespec64 t;\n\tint retval = sched_rr_get_interval(pid, &t);\n\n\tif (retval == 0)\n\t\tretval = put_old_timespec32(&t, interval);\n\treturn retval;\n}\n#endif\n\nvoid sched_show_task(struct task_struct *p)\n{\n\tunsigned long free = 0;\n\tint ppid;\n\n\tif (!try_get_task_stack(p))\n\t\treturn;\n\n\tpr_info(\"task:%-15.15s state:%c\", p->comm, task_state_to_char(p));\n\n\tif (p->state == TASK_RUNNING)\n\t\tpr_cont(\"  running task    \");\n#ifdef CONFIG_DEBUG_STACK_USAGE\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpr_cont(\" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\\n\",\n\t\tfree, task_pid_nr(p), ppid,\n\t\t(unsigned long)task_thread_info(p)->flags);\n\n\tprint_worker_info(KERN_INFO, p);\n\tprint_stop_info(KERN_INFO, p);\n\tshow_stack(p, NULL, KERN_INFO);\n\tput_task_stack(p);\n}\nEXPORT_SYMBOL_GPL(sched_show_task);\n\nstatic inline bool\nstate_filter_match(unsigned long state_filter, struct task_struct *p)\n{\n\t/* no filter, everything matches */\n\tif (!state_filter)\n\t\treturn true;\n\n\t/* filter, but doesn't match */\n\tif (!(p->state & state_filter))\n\t\treturn false;\n\n\t/*\n\t * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows\n\t * TASK_KILLABLE).\n\t */\n\tif (state_filter == TASK_UNINTERRUPTIBLE && p->state == TASK_IDLE)\n\t\treturn false;\n\n\treturn true;\n}\n\n\nvoid show_state_filter(unsigned long state_filter)\n{\n\tstruct task_struct *g, *p;\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * reset the NMI-timeout, listing all files on a slow\n\t\t * console might take a lot of time:\n\t\t * Also, reset softlockup watchdogs on all CPUs, because\n\t\t * another CPU might be blocked waiting for us to process\n\t\t * an IPI.\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\ttouch_all_softlockup_watchdogs();\n\t\tif (state_filter_match(state_filter, p))\n\t\t\tsched_show_task(p);\n\t}\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (!state_filter)\n\t\tsysrq_sched_debug_show();\n#endif\n\trcu_read_unlock();\n\t/*\n\t * Only show locks if all tasks are dumped:\n\t */\n\tif (!state_filter)\n\t\tdebug_show_all_locks();\n}\n\n/**\n * init_idle - set up an idle thread for a given CPU\n * @idle: task in question\n * @cpu: CPU the idle task belongs to\n *\n * NOTE: this function does not set the idle thread's NEED_RESCHED\n * flag, to make booting more robust.\n */\nvoid init_idle(struct task_struct *idle, int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\t__sched_fork(0, idle);\n\n\traw_spin_lock_irqsave(&idle->pi_lock, flags);\n\traw_spin_lock(&rq->lock);\n\n\tidle->state = TASK_RUNNING;\n\tidle->se.exec_start = sched_clock();\n\tidle->flags |= PF_IDLE;\n\n\tscs_task_reset(idle);\n\tkasan_unpoison_task_stack(idle);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * It's possible that init_idle() gets called multiple times on a task,\n\t * in that case do_set_cpus_allowed() will not do the right thing.\n\t *\n\t * And since this is boot we can forgo the serialization.\n\t */\n\tset_cpus_allowed_common(idle, cpumask_of(cpu), 0);\n#endif\n\t/*\n\t * We're having a chicken and egg problem, even though we are\n\t * holding rq->lock, the CPU isn't yet set to this CPU so the\n\t * lockdep check in task_group() will fail.\n\t *\n\t * Similar case to sched_fork(). / Alternatively we could\n\t * use task_rq_lock() here and obtain the other rq->lock.\n\t *\n\t * Silence PROVE_RCU\n\t */\n\trcu_read_lock();\n\t__set_task_cpu(idle, cpu);\n\trcu_read_unlock();\n\n\trq->idle = idle;\n\trcu_assign_pointer(rq->curr, idle);\n\tidle->on_rq = TASK_ON_RQ_QUEUED;\n#ifdef CONFIG_SMP\n\tidle->on_cpu = 1;\n#endif\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&idle->pi_lock, flags);\n\n\t/* Set the preempt count _outside_ the spinlocks! */\n\tinit_idle_preempt_count(idle, cpu);\n\n\t/*\n\t * The idle tasks have their own, simple scheduling class:\n\t */\n\tidle->sched_class = &idle_sched_class;\n\tftrace_graph_init_idle_task(idle, cpu);\n\tvtime_init_idle(idle, cpu);\n#ifdef CONFIG_SMP\n\tsprintf(idle->comm, \"%s/%d\", INIT_TASK_COMM, cpu);\n#endif\n}\n\n#ifdef CONFIG_SMP\n\nint cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t      const struct cpumask *trial)\n{\n\tint ret = 1;\n\n\tif (!cpumask_weight(cur))\n\t\treturn ret;\n\n\tret = dl_cpuset_cpumask_can_shrink(cur, trial);\n\n\treturn ret;\n}\n\nint task_can_attach(struct task_struct *p,\n\t\t    const struct cpumask *cs_cpus_allowed)\n{\n\tint ret = 0;\n\n\t/*\n\t * Kthreads which disallow setaffinity shouldn't be moved\n\t * to a new cpuset; we don't want to change their CPU\n\t * affinity and isolating such threads by their set of\n\t * allowed nodes is unnecessary.  Thus, cpusets are not\n\t * applicable for such threads.  This prevents checking for\n\t * success of set_cpus_allowed_ptr() on all attached tasks\n\t * before cpus_mask may be changed.\n\t */\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dl_task(p) && !cpumask_intersects(task_rq(p)->rd->span,\n\t\t\t\t\t      cs_cpus_allowed))\n\t\tret = dl_task_can_attach(p, cs_cpus_allowed);\n\nout:\n\treturn ret;\n}\n\nbool sched_smp_initialized __read_mostly;\n\n#ifdef CONFIG_NUMA_BALANCING\n/* Migrate current task p to target_cpu */\nint migrate_task_to(struct task_struct *p, int target_cpu)\n{\n\tstruct migration_arg arg = { p, target_cpu };\n\tint curr_cpu = task_cpu(p);\n\n\tif (curr_cpu == target_cpu)\n\t\treturn 0;\n\n\tif (!cpumask_test_cpu(target_cpu, p->cpus_ptr))\n\t\treturn -EINVAL;\n\n\t/* TODO: This is not properly updating schedstats */\n\n\ttrace_sched_move_numa(p, curr_cpu, target_cpu);\n\treturn stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);\n}\n\n/*\n * Requeue a task on a given node and accurately track the number of NUMA\n * tasks on the runqueues\n */\nvoid sched_setnuma(struct task_struct *p, int nid)\n{\n\tbool queued, running;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->numa_preferred_nid = nid;\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\ttask_rq_unlock(rq, p, &rf);\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n#ifdef CONFIG_HOTPLUG_CPU\n/*\n * Ensure that the idle task is using init_mm right before its CPU goes\n * offline.\n */\nvoid idle_task_exit(void)\n{\n\tstruct mm_struct *mm = current->active_mm;\n\n\tBUG_ON(cpu_online(smp_processor_id()));\n\tBUG_ON(current != this_rq()->idle);\n\n\tif (mm != &init_mm) {\n\t\tswitch_mm(mm, &init_mm, current);\n\t\tfinish_arch_post_lock_switch();\n\t}\n\n\t/* finish_cpu(), as ran on the BP, will clean up the active_mm state */\n}\n\nstatic int __balance_push_cpu_stop(void *arg)\n{\n\tstruct task_struct *p = arg;\n\tstruct rq *rq = this_rq();\n\tstruct rq_flags rf;\n\tint cpu;\n\n\traw_spin_lock_irq(&p->pi_lock);\n\trq_lock(rq, &rf);\n\n\tupdate_rq_clock(rq);\n\n\tif (task_rq(p) == rq && task_on_rq_queued(p)) {\n\t\tcpu = select_fallback_rq(rq->cpu, p);\n\t\trq = __migrate_task(rq, &rf, p, cpu);\n\t}\n\n\trq_unlock(rq, &rf);\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(struct cpu_stop_work, push_work);\n\n/*\n * Ensure we only run per-cpu kthreads once the CPU goes !active.\n */\nstatic void balance_push(struct rq *rq)\n{\n\tstruct task_struct *push_task = rq->curr;\n\n\tlockdep_assert_held(&rq->lock);\n\tSCHED_WARN_ON(rq->cpu != smp_processor_id());\n\n\t/*\n\t * Both the cpu-hotplug and stop task are in this case and are\n\t * required to complete the hotplug process.\n\t */\n\tif (is_per_cpu_kthread(push_task) || is_migration_disabled(push_task)) {\n\t\t/*\n\t\t * If this is the idle task on the outgoing CPU try to wake\n\t\t * up the hotplug control thread which might wait for the\n\t\t * last task to vanish. The rcuwait_active() check is\n\t\t * accurate here because the waiter is pinned on this CPU\n\t\t * and can't obviously be running in parallel.\n\t\t *\n\t\t * On RT kernels this also has to check whether there are\n\t\t * pinned and scheduled out tasks on the runqueue. They\n\t\t * need to leave the migrate disabled section first.\n\t\t */\n\t\tif (!rq->nr_running && !rq_has_pinned_tasks(rq) &&\n\t\t    rcuwait_active(&rq->hotplug_wait)) {\n\t\t\traw_spin_unlock(&rq->lock);\n\t\t\trcuwait_wake_up(&rq->hotplug_wait);\n\t\t\traw_spin_lock(&rq->lock);\n\t\t}\n\t\treturn;\n\t}\n\n\tget_task_struct(push_task);\n\t/*\n\t * Temporarily drop rq->lock such that we can wake-up the stop task.\n\t * Both preemption and IRQs are still disabled.\n\t */\n\traw_spin_unlock(&rq->lock);\n\tstop_one_cpu_nowait(rq->cpu, __balance_push_cpu_stop, push_task,\n\t\t\t    this_cpu_ptr(&push_work));\n\t/*\n\t * At this point need_resched() is true and we'll take the loop in\n\t * schedule(). The next pick is obviously going to be the stop task\n\t * which is_per_cpu_kthread() and will push this task away.\n\t */\n\traw_spin_lock(&rq->lock);\n}\n\nstatic void balance_push_set(int cpu, bool on)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trq_lock_irqsave(rq, &rf);\n\tif (on)\n\t\trq->balance_flags |= BALANCE_PUSH;\n\telse\n\t\trq->balance_flags &= ~BALANCE_PUSH;\n\trq_unlock_irqrestore(rq, &rf);\n}\n\n/*\n * Invoked from a CPUs hotplug control thread after the CPU has been marked\n * inactive. All tasks which are not per CPU kernel threads are either\n * pushed off this CPU now via balance_push() or placed on a different CPU\n * during wakeup. Wait until the CPU is quiescent.\n */\nstatic void balance_hotplug_wait(void)\n{\n\tstruct rq *rq = this_rq();\n\n\trcuwait_wait_event(&rq->hotplug_wait,\n\t\t\t   rq->nr_running == 1 && !rq_has_pinned_tasks(rq),\n\t\t\t   TASK_UNINTERRUPTIBLE);\n}\n\n#else\n\nstatic inline void balance_push(struct rq *rq)\n{\n}\n\nstatic inline void balance_push_set(int cpu, bool on)\n{\n}\n\nstatic inline void balance_hotplug_wait(void)\n{\n}\n\n#endif /* CONFIG_HOTPLUG_CPU */\n\nvoid set_rq_online(struct rq *rq)\n{\n\tif (!rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tcpumask_set_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 1;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_online)\n\t\t\t\tclass->rq_online(rq);\n\t\t}\n\t}\n}\n\nvoid set_rq_offline(struct rq *rq)\n{\n\tif (rq->online) {\n\t\tconst struct sched_class *class;\n\n\t\tfor_each_class(class) {\n\t\t\tif (class->rq_offline)\n\t\t\t\tclass->rq_offline(rq);\n\t\t}\n\n\t\tcpumask_clear_cpu(rq->cpu, rq->rd->online);\n\t\trq->online = 0;\n\t}\n}\n\n/*\n * used to mark begin/end of suspend/resume:\n */\nstatic int num_cpus_frozen;\n\n/*\n * Update cpusets according to cpu_active mask.  If cpusets are\n * disabled, cpuset_update_active_cpus() becomes a simple wrapper\n * around partition_sched_domains().\n *\n * If we come here as part of a suspend/resume, don't touch cpusets because we\n * want to restore it back to its original state upon resume anyway.\n */\nstatic void cpuset_cpu_active(void)\n{\n\tif (cpuhp_tasks_frozen) {\n\t\t/*\n\t\t * num_cpus_frozen tracks how many CPUs are involved in suspend\n\t\t * resume sequence. As long as this is not the last online\n\t\t * operation in the resume sequence, just build a single sched\n\t\t * domain, ignoring cpusets.\n\t\t */\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t\tif (--num_cpus_frozen)\n\t\t\treturn;\n\t\t/*\n\t\t * This is the last CPU online operation. So fall through and\n\t\t * restore the original sched domains by considering the\n\t\t * cpuset configurations.\n\t\t */\n\t\tcpuset_force_rebuild();\n\t}\n\tcpuset_update_active_cpus();\n}\n\nstatic int cpuset_cpu_inactive(unsigned int cpu)\n{\n\tif (!cpuhp_tasks_frozen) {\n\t\tif (dl_cpu_busy(cpu))\n\t\t\treturn -EBUSY;\n\t\tcpuset_update_active_cpus();\n\t} else {\n\t\tnum_cpus_frozen++;\n\t\tpartition_sched_domains(1, NULL, NULL);\n\t}\n\treturn 0;\n}\n\nint sched_cpu_activate(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\tbalance_push_set(cpu, false);\n\n#ifdef CONFIG_SCHED_SMT\n\t/*\n\t * When going up, increment the number of cores with SMT present.\n\t */\n\tif (cpumask_weight(cpu_smt_mask(cpu)) == 2)\n\t\tstatic_branch_inc_cpuslocked(&sched_smt_present);\n#endif\n\tset_cpu_active(cpu, true);\n\n\tif (sched_smp_initialized) {\n\t\tsched_domains_numa_masks_set(cpu);\n\t\tcpuset_cpu_active();\n\t}\n\n\t/*\n\t * Put the rq online, if not already. This happens:\n\t *\n\t * 1) In the early boot process, because we build the real domains\n\t *    after all CPUs have been brought up.\n\t *\n\t * 2) At runtime, if cpuset_cpu_active() fails to rebuild the\n\t *    domains.\n\t */\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->rd) {\n\t\tBUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));\n\t\tset_rq_online(rq);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n\treturn 0;\n}\n\nint sched_cpu_deactivate(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\tint ret;\n\n\tset_cpu_active(cpu, false);\n\t/*\n\t * We've cleared cpu_active_mask, wait for all preempt-disabled and RCU\n\t * users of this state to go away such that all new such users will\n\t * observe it.\n\t *\n\t * Do sync before park smpboot threads to take care the rcu boost case.\n\t */\n\tsynchronize_rcu();\n\n\tbalance_push_set(cpu, true);\n\n\trq_lock_irqsave(rq, &rf);\n\tif (rq->rd) {\n\t\tupdate_rq_clock(rq);\n\t\tBUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));\n\t\tset_rq_offline(rq);\n\t}\n\trq_unlock_irqrestore(rq, &rf);\n\n#ifdef CONFIG_SCHED_SMT\n\t/*\n\t * When going down, decrement the number of cores with SMT present.\n\t */\n\tif (cpumask_weight(cpu_smt_mask(cpu)) == 2)\n\t\tstatic_branch_dec_cpuslocked(&sched_smt_present);\n#endif\n\n\tif (!sched_smp_initialized)\n\t\treturn 0;\n\n\tret = cpuset_cpu_inactive(cpu);\n\tif (ret) {\n\t\tbalance_push_set(cpu, false);\n\t\tset_cpu_active(cpu, true);\n\t\treturn ret;\n\t}\n\tsched_domains_numa_masks_clear(cpu);\n\treturn 0;\n}\n\nstatic void sched_rq_cpu_starting(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\trq->calc_load_update = calc_load_update;\n\tupdate_max_interval();\n}\n\nint sched_cpu_starting(unsigned int cpu)\n{\n\tsched_rq_cpu_starting(cpu);\n\tsched_tick_start(cpu);\n\treturn 0;\n}\n\n#ifdef CONFIG_HOTPLUG_CPU\n\n/*\n * Invoked immediately before the stopper thread is invoked to bring the\n * CPU down completely. At this point all per CPU kthreads except the\n * hotplug thread (current) and the stopper thread (inactive) have been\n * either parked or have been unbound from the outgoing CPU. Ensure that\n * any of those which might be on the way out are gone.\n *\n * If after this point a bound task is being woken on this CPU then the\n * responsible hotplug callback has failed to do it's job.\n * sched_cpu_dying() will catch it with the appropriate fireworks.\n */\nint sched_cpu_wait_empty(unsigned int cpu)\n{\n\tbalance_hotplug_wait();\n\treturn 0;\n}\n\n/*\n * Since this CPU is going 'away' for a while, fold any nr_active delta we\n * might have. Called from the CPU stopper task after ensuring that the\n * stopper is the last running task on the CPU, so nr_active count is\n * stable. We need to take the teardown thread which is calling this into\n * account, so we hand in adjust = 1 to the load calculation.\n *\n * Also see the comment \"Global load-average calculations\".\n */\nstatic void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq, 1);\n\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}\n\nint sched_cpu_dying(unsigned int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\t/* Handle pending wakeups and then migrate everything off */\n\tsched_tick_stop(cpu);\n\n\trq_lock_irqsave(rq, &rf);\n\tBUG_ON(rq->nr_running != 1 || rq_has_pinned_tasks(rq));\n\trq_unlock_irqrestore(rq, &rf);\n\n\tcalc_load_migrate(rq);\n\tupdate_max_interval();\n\tnohz_balance_exit_idle(rq);\n\thrtick_clear(rq);\n\treturn 0;\n}\n#endif\n\nvoid __init sched_init_smp(void)\n{\n\tsched_init_numa();\n\n\t/*\n\t * There's no userspace yet to cause hotplug operations; hence all the\n\t * CPU masks are stable and all blatant races in the below code cannot\n\t * happen.\n\t */\n\tmutex_lock(&sched_domains_mutex);\n\tsched_init_domains(cpu_active_mask);\n\tmutex_unlock(&sched_domains_mutex);\n\n\t/* Move init over to a non-isolated CPU */\n\tif (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_FLAG_DOMAIN)) < 0)\n\t\tBUG();\n\tsched_init_granularity();\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n\n\tsched_smp_initialized = true;\n}\n\nstatic int __init migration_init(void)\n{\n\tsched_cpu_starting(smp_processor_id());\n\treturn 0;\n}\nearly_initcall(migration_init);\n\n#else\nvoid __init sched_init_smp(void)\n{\n\tsched_init_granularity();\n}\n#endif /* CONFIG_SMP */\n\nint in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >= (unsigned long)__sched_text_start\n\t\t&& addr < (unsigned long)__sched_text_end);\n}\n\n#ifdef CONFIG_CGROUP_SCHED\n/*\n * Default task group.\n * Every task in system belongs to this group at bootup.\n */\nstruct task_group root_task_group;\nLIST_HEAD(task_groups);\n\n/* Cacheline aligned slab cache for task_group */\nstatic struct kmem_cache *task_group_cache __read_mostly;\n#endif\n\nDECLARE_PER_CPU(cpumask_var_t, load_balance_mask);\nDECLARE_PER_CPU(cpumask_var_t, select_idle_mask);\n\nvoid __init sched_init(void)\n{\n\tunsigned long ptr = 0;\n\tint i;\n\n\t/* Make sure the linker didn't screw up */\n\tBUG_ON(&idle_sched_class + 1 != &fair_sched_class ||\n\t       &fair_sched_class + 1 != &rt_sched_class ||\n\t       &rt_sched_class + 1   != &dl_sched_class);\n#ifdef CONFIG_SMP\n\tBUG_ON(&dl_sched_class + 1 != &stop_sched_class);\n#endif\n\n\twait_bit_init();\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tptr += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n#ifdef CONFIG_RT_GROUP_SCHED\n\tptr += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n\tif (ptr) {\n\t\tptr = (unsigned long)kzalloc(ptr, GFP_NOWAIT);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\troot_task_group.se = (struct sched_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.cfs_rq = (struct cfs_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.shares = ROOT_TASK_GROUP_LOAD;\n\t\tinit_cfs_bandwidth(&root_task_group.cfs_bandwidth);\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\troot_task_group.rt_se = (struct sched_rt_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.rt_rq = (struct rt_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif /* CONFIG_RT_GROUP_SCHED */\n\t}\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(load_balance_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), GFP_KERNEL, cpu_to_node(i));\n\t\tper_cpu(select_idle_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), GFP_KERNEL, cpu_to_node(i));\n\t}\n#endif /* CONFIG_CPUMASK_OFFSTACK */\n\n\tinit_rt_bandwidth(&def_rt_bandwidth, global_rt_period(), global_rt_runtime());\n\tinit_dl_bandwidth(&def_dl_bandwidth, global_rt_period(), global_rt_runtime());\n\n#ifdef CONFIG_SMP\n\tinit_defrootdomain();\n#endif\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\tinit_rt_bandwidth(&root_task_group.rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n#endif /* CONFIG_RT_GROUP_SCHED */\n\n#ifdef CONFIG_CGROUP_SCHED\n\ttask_group_cache = KMEM_CACHE(task_group, 0);\n\n\tlist_add(&root_task_group.list, &task_groups);\n\tINIT_LIST_HEAD(&root_task_group.children);\n\tINIT_LIST_HEAD(&root_task_group.siblings);\n\tautogroup_init(&init_task);\n#endif /* CONFIG_CGROUP_SCHED */\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct rq *rq;\n\n\t\trq = cpu_rq(i);\n\t\traw_spin_lock_init(&rq->lock);\n\t\trq->nr_running = 0;\n\t\trq->calc_load_active = 0;\n\t\trq->calc_load_update = jiffies + LOAD_FREQ;\n\t\tinit_cfs_rq(&rq->cfs);\n\t\tinit_rt_rq(&rq->rt);\n\t\tinit_dl_rq(&rq->dl);\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\tINIT_LIST_HEAD(&rq->leaf_cfs_rq_list);\n\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\t/*\n\t\t * How much CPU bandwidth does root_task_group get?\n\t\t *\n\t\t * In case of task-groups formed thr' the cgroup filesystem, it\n\t\t * gets 100% of the CPU resources in the system. This overall\n\t\t * system CPU resource is divided among the tasks of\n\t\t * root_task_group and its child task-groups in a fair manner,\n\t\t * based on each entity's (task or task-group's) weight\n\t\t * (se->load.weight).\n\t\t *\n\t\t * In other words, if root_task_group has 10 tasks of weight\n\t\t * 1024) and two child groups A0 and A1 (of weight 1024 each),\n\t\t * then A0's share of the CPU resource is:\n\t\t *\n\t\t *\tA0's bandwidth = 1024 / (10*1024 + 1024 + 1024) = 8.33%\n\t\t *\n\t\t * We achieve this by letting root_task_group's tasks sit\n\t\t * directly in rq->cfs (i.e root_task_group->se[] = NULL).\n\t\t */\n\t\tinit_tg_cfs_entry(&root_task_group, &rq->cfs, NULL, i, NULL);\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n\t\trq->rt.rt_runtime = def_rt_bandwidth.rt_runtime;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\tinit_tg_rt_entry(&root_task_group, &rq->rt, NULL, i, NULL);\n#endif\n#ifdef CONFIG_SMP\n\t\trq->sd = NULL;\n\t\trq->rd = NULL;\n\t\trq->cpu_capacity = rq->cpu_capacity_orig = SCHED_CAPACITY_SCALE;\n\t\trq->balance_callback = NULL;\n\t\trq->active_balance = 0;\n\t\trq->next_balance = jiffies;\n\t\trq->push_cpu = 0;\n\t\trq->cpu = i;\n\t\trq->online = 0;\n\t\trq->idle_stamp = 0;\n\t\trq->avg_idle = 2*sysctl_sched_migration_cost;\n\t\trq->max_idle_balance_cost = sysctl_sched_migration_cost;\n\n\t\tINIT_LIST_HEAD(&rq->cfs_tasks);\n\n\t\trq_attach_root(rq, &def_root_domain);\n#ifdef CONFIG_NO_HZ_COMMON\n\t\trq->last_blocked_load_update_tick = jiffies;\n\t\tatomic_set(&rq->nohz_flags, 0);\n\n\t\tINIT_CSD(&rq->nohz_csd, nohz_csd_func, rq);\n#endif\n#ifdef CONFIG_HOTPLUG_CPU\n\t\trcuwait_init(&rq->hotplug_wait);\n#endif\n#endif /* CONFIG_SMP */\n\t\thrtick_rq_init(rq);\n\t\tatomic_set(&rq->nr_iowait, 0);\n\t}\n\n\tset_load_weight(&init_task, false);\n\n\t/*\n\t * The boot idle thread does lazy MMU switching as well:\n\t */\n\tmmgrab(&init_mm);\n\tenter_lazy_tlb(&init_mm, current);\n\n\t/*\n\t * Make us the idle thread. Technically, schedule() should not be\n\t * called from this thread, however somewhere below it might be,\n\t * but because we are the idle thread, we just pick up running again\n\t * when this runqueue becomes \"idle\".\n\t */\n\tinit_idle(current, smp_processor_id());\n\n\tcalc_load_update = jiffies + LOAD_FREQ;\n\n#ifdef CONFIG_SMP\n\tidle_thread_set_boot_cpu();\n#endif\n\tinit_sched_fair_class();\n\n\tinit_schedstats();\n\n\tpsi_init();\n\n\tinit_uclamp();\n\n\tscheduler_running = 1;\n}\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nstatic inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\n\treturn (nested == preempt_offset);\n}\n\nvoid __might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/*\n\t * Blocking primitives will set (and therefore destroy) current->state,\n\t * since we will exit with TASK_RUNNING make sure we enter with it,\n\t * otherwise we will destroy state.\n\t */\n\tWARN_ONCE(current->state != TASK_RUNNING && current->task_state_change,\n\t\t\t\"do not call blocking ops when !TASK_RUNNING; \"\n\t\t\t\"state=%lx set at [<%p>] %pS\\n\",\n\t\t\tcurrent->state,\n\t\t\t(void *)current->task_state_change,\n\t\t\t(void *)current->task_state_change);\n\n\t___might_sleep(file, line, preempt_offset);\n}\nEXPORT_SYMBOL(__might_sleep);\n\nvoid ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\t/* Ratelimiting timestamp: */\n\tstatic unsigned long prev_jiffy;\n\n\tunsigned long preempt_disable_ip;\n\n\t/* WARN_ON_ONCE() by default, no rate limit required: */\n\trcu_sleep_check();\n\n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current) && !current->non_block_count) ||\n\t    system_state == SYSTEM_BOOTING || system_state > SYSTEM_RUNNING ||\n\t    oops_in_progress)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\t/* Save this before calling printk(), since that will clobber it: */\n\tpreempt_disable_ip = get_preempt_disable_ip(current);\n\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, non_block: %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(), current->non_block_count,\n\t\t\tcurrent->pid, current->comm);\n\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n\tif (IS_ENABLED(CONFIG_DEBUG_PREEMPT)\n\t    && !preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(KERN_ERR, preempt_disable_ip);\n\t}\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\nEXPORT_SYMBOL(___might_sleep);\n\nvoid __cant_sleep(const char *file, int line, int preempt_offset)\n{\n\tstatic unsigned long prev_jiffy;\n\n\tif (irqs_disabled())\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_COUNT))\n\t\treturn;\n\n\tif (preempt_count() > preempt_offset)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\tprintk(KERN_ERR \"BUG: assuming atomic context at %s:%d\\n\", file, line);\n\tprintk(KERN_ERR \"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\n\tdebug_show_held_locks(current);\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\nEXPORT_SYMBOL_GPL(__cant_sleep);\n\n#ifdef CONFIG_SMP\nvoid __cant_migrate(const char *file, int line)\n{\n\tstatic unsigned long prev_jiffy;\n\n\tif (irqs_disabled())\n\t\treturn;\n\n\tif (is_migration_disabled(current))\n\t\treturn;\n\n\tif (!IS_ENABLED(CONFIG_PREEMPT_COUNT))\n\t\treturn;\n\n\tif (preempt_count() > 0)\n\t\treturn;\n\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\n\tpr_err(\"BUG: assuming non migratable context at %s:%d\\n\", file, line);\n\tpr_err(\"in_atomic(): %d, irqs_disabled(): %d, migration_disabled() %u pid: %d, name: %s\\n\",\n\t       in_atomic(), irqs_disabled(), is_migration_disabled(current),\n\t       current->pid, current->comm);\n\n\tdebug_show_held_locks(current);\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}\nEXPORT_SYMBOL_GPL(__cant_migrate);\n#endif\n#endif\n\n#ifdef CONFIG_MAGIC_SYSRQ\nvoid normalize_rt_tasks(void)\n{\n\tstruct task_struct *g, *p;\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t};\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, p) {\n\t\t/*\n\t\t * Only normalize user tasks:\n\t\t */\n\t\tif (p->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tp->se.exec_start = 0;\n\t\tschedstat_set(p->se.statistics.wait_start,  0);\n\t\tschedstat_set(p->se.statistics.sleep_start, 0);\n\t\tschedstat_set(p->se.statistics.block_start, 0);\n\n\t\tif (!dl_task(p) && !rt_task(p)) {\n\t\t\t/*\n\t\t\t * Renice negative nice level userspace\n\t\t\t * tasks back to 0:\n\t\t\t */\n\t\t\tif (task_nice(p) < 0)\n\t\t\t\tset_user_nice(p, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__sched_setscheduler(p, &attr, false, false);\n\t}\n\tread_unlock(&tasklist_lock);\n}\n\n#endif /* CONFIG_MAGIC_SYSRQ */\n\n#if defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB)\n/*\n * These functions are only useful for the IA64 MCA handling, or kdb.\n *\n * They can only be called when the whole system has been\n * stopped - every CPU needs to be quiescent, and no scheduling\n * activity can take place. Using them for anything else would\n * be a serious bug, and as a result, they aren't even visible\n * under any other configuration.\n */\n\n/**\n * curr_task - return the current task for a given CPU.\n * @cpu: the processor in question.\n *\n * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!\n *\n * Return: The current task for @cpu.\n */\nstruct task_struct *curr_task(int cpu)\n{\n\treturn cpu_curr(cpu);\n}\n\n#endif /* defined(CONFIG_IA64) || defined(CONFIG_KGDB_KDB) */\n\n#ifdef CONFIG_IA64\n/**\n * ia64_set_curr_task - set the current task for a given CPU.\n * @cpu: the processor in question.\n * @p: the task pointer to set.\n *\n * Description: This function must only be used when non-maskable interrupts\n * are serviced on a separate stack. It allows the architecture to switch the\n * notion of the current task on a CPU in a non-blocking manner. This function\n * must be called with all CPU's synchronized, and interrupts disabled, the\n * and caller must save the original value of the current task (see\n * curr_task() above) and restore that value before reenabling interrupts and\n * re-starting the system.\n *\n * ONLY VALID WHEN THE WHOLE SYSTEM IS STOPPED!\n */\nvoid ia64_set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}\n\n#endif\n\n#ifdef CONFIG_CGROUP_SCHED\n/* task_group_lock serializes the addition/removal of task groups */\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nstatic inline void alloc_uclamp_sched_group(struct task_group *tg,\n\t\t\t\t\t    struct task_group *parent)\n{\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\tenum uclamp_id clamp_id;\n\n\tfor_each_clamp_id(clamp_id) {\n\t\tuclamp_se_set(&tg->uclamp_req[clamp_id],\n\t\t\t      uclamp_none(clamp_id), false);\n\t\ttg->uclamp[clamp_id] = parent->uclamp[clamp_id];\n\t}\n#endif\n}\n\nstatic void sched_free_group(struct task_group *tg)\n{\n\tfree_fair_sched_group(tg);\n\tfree_rt_sched_group(tg);\n\tautogroup_free(tg);\n\tkmem_cache_free(task_group_cache, tg);\n}\n\n/* allocate runqueue etc for a new task group */\nstruct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\talloc_uclamp_sched_group(tg, parent);\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nvoid sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}\n\n/* rcu callback to free various structures associated with a task group */\nstatic void sched_free_group_rcu(struct rcu_head *rhp)\n{\n\t/* Now it should be safe to free those cfs_rqs: */\n\tsched_free_group(container_of(rhp, struct task_group, rcu));\n}\n\nvoid sched_destroy_group(struct task_group *tg)\n{\n\t/* Wait for possible concurrent references to cfs_rqs complete: */\n\tcall_rcu(&tg->rcu, sched_free_group_rcu);\n}\n\nvoid sched_offline_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/* End participation in shares distribution: */\n\tunregister_fair_sched_group(tg);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}\n\nstatic void sched_change_group(struct task_struct *tsk, int type)\n{\n\tstruct task_group *tg;\n\n\t/*\n\t * All callers are synchronized by task_rq_lock(); we do not use RCU\n\t * which is pointless here. Thus, we pass \"true\" to task_css_check()\n\t * to prevent lockdep warnings.\n\t */\n\ttg = container_of(task_css_check(tsk, cpu_cgrp_id, true),\n\t\t\t  struct task_group, css);\n\ttg = autogroup_task_group(tsk, tg);\n\ttsk->sched_task_group = tg;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (tsk->sched_class->task_change_group)\n\t\ttsk->sched_class->task_change_group(tsk, type);\n\telse\n#endif\n\t\tset_task_rq(tsk, task_cpu(tsk));\n}\n\n/*\n * Change task's runqueue when it moves between groups.\n *\n * The caller of this function should have put the task in its new group by\n * now. This function just updates tsk->se.cfs_rq and tsk->se.parent to reflect\n * its new group.\n */\nvoid sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running) {\n\t\tset_next_task(rq, tsk);\n\t\t/*\n\t\t * After changing group, the running task may have joined a\n\t\t * throttled one but it's still the running task. Trigger a\n\t\t * resched to make sure that task can still run.\n\t\t */\n\t\tresched_curr(rq);\n\t}\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : NULL;\n}\n\nstatic struct cgroup_subsys_state *\ncpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct task_group *parent = css_tg(parent_css);\n\tstruct task_group *tg;\n\n\tif (!parent) {\n\t\t/* This is early initialization for the top cgroup */\n\t\treturn &root_task_group.css;\n\t}\n\n\ttg = sched_create_group(parent);\n\tif (IS_ERR(tg))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn &tg->css;\n}\n\n/* Expose task group only after completing cgroup initialization */\nstatic int cpu_cgroup_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\tstruct task_group *parent = css_tg(css->parent);\n\n\tif (parent)\n\t\tsched_online_group(tg, parent);\n\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\t/* Propagate the effective uclamp value for the new group */\n\tcpu_util_update_eff(css);\n#endif\n\n\treturn 0;\n}\n\nstatic void cpu_cgroup_css_released(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\tsched_offline_group(tg);\n}\n\nstatic void cpu_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\t/*\n\t * Relies on the RCU grace period between css_released() and this.\n\t */\n\tsched_free_group(tg);\n}\n\n/*\n * This is called before wake_up_new_task(), therefore we really only\n * have to set its group bits, all the other stuff does not apply.\n */\nstatic void cpu_cgroup_fork(struct task_struct *task)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(task, &rf);\n\n\tupdate_rq_clock(rq);\n\tsched_change_group(task, TASK_SET_GROUP);\n\n\ttask_rq_unlock(rq, task, &rf);\n}\n\nstatic int cpu_cgroup_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\tint ret = 0;\n\n\tcgroup_taskset_for_each(task, css, tset) {\n#ifdef CONFIG_RT_GROUP_SCHED\n\t\tif (!sched_rt_can_attach(css_tg(css), task))\n\t\t\treturn -EINVAL;\n#endif\n\t\t/*\n\t\t * Serialize against wake_up_new_task() such that if it's\n\t\t * running, we're sure to observe its full state.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\t/*\n\t\t * Avoid calling sched_move_task() before wake_up_new_task()\n\t\t * has happened. This would lead to problems with PELT, due to\n\t\t * move wanting to detach+attach while we're not attached yet.\n\t\t */\n\t\tif (task->state == TASK_NEW)\n\t\t\tret = -EINVAL;\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void cpu_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\tsched_move_task(task);\n}\n\n#ifdef CONFIG_UCLAMP_TASK_GROUP\nstatic void cpu_util_update_eff(struct cgroup_subsys_state *css)\n{\n\tstruct cgroup_subsys_state *top_css = css;\n\tstruct uclamp_se *uc_parent = NULL;\n\tstruct uclamp_se *uc_se = NULL;\n\tunsigned int eff[UCLAMP_CNT];\n\tenum uclamp_id clamp_id;\n\tunsigned int clamps;\n\n\tcss_for_each_descendant_pre(css, top_css) {\n\t\tuc_parent = css_tg(css)->parent\n\t\t\t? css_tg(css)->parent->uclamp : NULL;\n\n\t\tfor_each_clamp_id(clamp_id) {\n\t\t\t/* Assume effective clamps matches requested clamps */\n\t\t\teff[clamp_id] = css_tg(css)->uclamp_req[clamp_id].value;\n\t\t\t/* Cap effective clamps with parent's effective clamps */\n\t\t\tif (uc_parent &&\n\t\t\t    eff[clamp_id] > uc_parent[clamp_id].value) {\n\t\t\t\teff[clamp_id] = uc_parent[clamp_id].value;\n\t\t\t}\n\t\t}\n\t\t/* Ensure protection is always capped by limit */\n\t\teff[UCLAMP_MIN] = min(eff[UCLAMP_MIN], eff[UCLAMP_MAX]);\n\n\t\t/* Propagate most restrictive effective clamps */\n\t\tclamps = 0x0;\n\t\tuc_se = css_tg(css)->uclamp;\n\t\tfor_each_clamp_id(clamp_id) {\n\t\t\tif (eff[clamp_id] == uc_se[clamp_id].value)\n\t\t\t\tcontinue;\n\t\t\tuc_se[clamp_id].value = eff[clamp_id];\n\t\t\tuc_se[clamp_id].bucket_id = uclamp_bucket_id(eff[clamp_id]);\n\t\t\tclamps |= (0x1 << clamp_id);\n\t\t}\n\t\tif (!clamps) {\n\t\t\tcss = css_rightmost_descendant(css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Immediately update descendants RUNNABLE tasks */\n\t\tuclamp_update_active_tasks(css, clamps);\n\t}\n}\n\n/*\n * Integer 10^N with a given N exponent by casting to integer the literal \"1eN\"\n * C expression. Since there is no way to convert a macro argument (N) into a\n * character constant, use two levels of macros.\n */\n#define _POW10(exp) ((unsigned int)1e##exp)\n#define POW10(exp) _POW10(exp)\n\nstruct uclamp_request {\n#define UCLAMP_PERCENT_SHIFT\t2\n#define UCLAMP_PERCENT_SCALE\t(100 * POW10(UCLAMP_PERCENT_SHIFT))\n\ts64 percent;\n\tu64 util;\n\tint ret;\n};\n\nstatic inline struct uclamp_request\ncapacity_from_percent(char *buf)\n{\n\tstruct uclamp_request req = {\n\t\t.percent = UCLAMP_PERCENT_SCALE,\n\t\t.util = SCHED_CAPACITY_SCALE,\n\t\t.ret = 0,\n\t};\n\n\tbuf = strim(buf);\n\tif (strcmp(buf, \"max\")) {\n\t\treq.ret = cgroup_parse_float(buf, UCLAMP_PERCENT_SHIFT,\n\t\t\t\t\t     &req.percent);\n\t\tif (req.ret)\n\t\t\treturn req;\n\t\tif ((u64)req.percent > UCLAMP_PERCENT_SCALE) {\n\t\t\treq.ret = -ERANGE;\n\t\t\treturn req;\n\t\t}\n\n\t\treq.util = req.percent << SCHED_CAPACITY_SHIFT;\n\t\treq.util = DIV_ROUND_CLOSEST_ULL(req.util, UCLAMP_PERCENT_SCALE);\n\t}\n\n\treturn req;\n}\n\nstatic ssize_t cpu_uclamp_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\tsize_t nbytes, loff_t off,\n\t\t\t\tenum uclamp_id clamp_id)\n{\n\tstruct uclamp_request req;\n\tstruct task_group *tg;\n\n\treq = capacity_from_percent(buf);\n\tif (req.ret)\n\t\treturn req.ret;\n\n\tstatic_branch_enable(&sched_uclamp_used);\n\n\tmutex_lock(&uclamp_mutex);\n\trcu_read_lock();\n\n\ttg = css_tg(of_css(of));\n\tif (tg->uclamp_req[clamp_id].value != req.util)\n\t\tuclamp_se_set(&tg->uclamp_req[clamp_id], req.util, false);\n\n\t/*\n\t * Because of not recoverable conversion rounding we keep track of the\n\t * exact requested value\n\t */\n\ttg->uclamp_pct[clamp_id] = req.percent;\n\n\t/* Update effective clamps to track the most restrictive value */\n\tcpu_util_update_eff(of_css(of));\n\n\trcu_read_unlock();\n\tmutex_unlock(&uclamp_mutex);\n\n\treturn nbytes;\n}\n\nstatic ssize_t cpu_uclamp_min_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t    loff_t off)\n{\n\treturn cpu_uclamp_write(of, buf, nbytes, off, UCLAMP_MIN);\n}\n\nstatic ssize_t cpu_uclamp_max_write(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes,\n\t\t\t\t    loff_t off)\n{\n\treturn cpu_uclamp_write(of, buf, nbytes, off, UCLAMP_MAX);\n}\n\nstatic inline void cpu_uclamp_print(struct seq_file *sf,\n\t\t\t\t    enum uclamp_id clamp_id)\n{\n\tstruct task_group *tg;\n\tu64 util_clamp;\n\tu64 percent;\n\tu32 rem;\n\n\trcu_read_lock();\n\ttg = css_tg(seq_css(sf));\n\tutil_clamp = tg->uclamp_req[clamp_id].value;\n\trcu_read_unlock();\n\n\tif (util_clamp == SCHED_CAPACITY_SCALE) {\n\t\tseq_puts(sf, \"max\\n\");\n\t\treturn;\n\t}\n\n\tpercent = tg->uclamp_pct[clamp_id];\n\tpercent = div_u64_rem(percent, POW10(UCLAMP_PERCENT_SHIFT), &rem);\n\tseq_printf(sf, \"%llu.%0*u\\n\", percent, UCLAMP_PERCENT_SHIFT, rem);\n}\n\nstatic int cpu_uclamp_min_show(struct seq_file *sf, void *v)\n{\n\tcpu_uclamp_print(sf, UCLAMP_MIN);\n\treturn 0;\n}\n\nstatic int cpu_uclamp_max_show(struct seq_file *sf, void *v)\n{\n\tcpu_uclamp_print(sf, UCLAMP_MAX);\n\treturn 0;\n}\n#endif /* CONFIG_UCLAMP_TASK_GROUP */\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\nstatic int cpu_shares_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cftype, u64 shareval)\n{\n\tif (shareval > scale_load_down(ULONG_MAX))\n\t\tshareval = MAX_SHARES;\n\treturn sched_group_set_shares(css_tg(css), scale_load(shareval));\n}\n\nstatic u64 cpu_shares_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct task_group *tg = css_tg(css);\n\n\treturn (u64) scale_load_down(tg->shares);\n}\n\n#ifdef CONFIG_CFS_BANDWIDTH\nstatic DEFINE_MUTEX(cfs_constraints_mutex);\n\nconst u64 max_cfs_quota_period = 1 * NSEC_PER_SEC; /* 1s */\nstatic const u64 min_cfs_quota_period = 1 * NSEC_PER_MSEC; /* 1ms */\n/* More than 203 days if BW_SHIFT equals 20. */\nstatic const u64 max_cfs_runtime = MAX_BW * NSEC_PER_USEC;\n\nstatic int __cfs_schedulable(struct task_group *tg, u64 period, u64 runtime);\n\nstatic int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Ensure we have at some amount of bandwidth every period.  This is\n\t * to prevent reaching a state of large arrears when throttled via\n\t * entity_tick() resulting in prolonged exit starvation.\n\t */\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Likewise, bound things on the otherside by preventing insane quota\n\t * periods.  This also allows us to normalize in computing quota\n\t * feasibility.\n\t */\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Bound quota to defend quota against overflow during bandwidth shift.\n\t */\n\tif (quota != RUNTIME_INF && quota > max_cfs_runtime)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Prevent race between setting of cfs_rq->runtime_enabled and\n\t * unthrottle_offline_cfs_rqs().\n\t */\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\t/*\n\t * If we need to toggle cfs_bandwidth_used, off->on must occur\n\t * before making related changes, and on->off must occur afterwards\n\t */\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\t/* Restart the period timer (if active) to handle new period expiry: */\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\traw_spin_unlock_irq(&cfs_b->lock);\n\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irq(rq, &rf);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\n\treturn ret;\n}\n\nstatic int tg_set_cfs_quota(struct task_group *tg, long cfs_quota_us)\n{\n\tu64 quota, period;\n\n\tperiod = ktime_to_ns(tg->cfs_bandwidth.period);\n\tif (cfs_quota_us < 0)\n\t\tquota = RUNTIME_INF;\n\telse if ((u64)cfs_quota_us <= U64_MAX / NSEC_PER_USEC)\n\t\tquota = (u64)cfs_quota_us * NSEC_PER_USEC;\n\telse\n\t\treturn -EINVAL;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}\n\nstatic long tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->cfs_bandwidth.quota == RUNTIME_INF)\n\t\treturn -1;\n\n\tquota_us = tg->cfs_bandwidth.quota;\n\tdo_div(quota_us, NSEC_PER_USEC);\n\n\treturn quota_us;\n}\n\nstatic int tg_set_cfs_period(struct task_group *tg, long cfs_period_us)\n{\n\tu64 quota, period;\n\n\tif ((u64)cfs_period_us > U64_MAX / NSEC_PER_USEC)\n\t\treturn -EINVAL;\n\n\tperiod = (u64)cfs_period_us * NSEC_PER_USEC;\n\tquota = tg->cfs_bandwidth.quota;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}\n\nstatic long tg_get_cfs_period(struct task_group *tg)\n{\n\tu64 cfs_period_us;\n\n\tcfs_period_us = ktime_to_ns(tg->cfs_bandwidth.period);\n\tdo_div(cfs_period_us, NSEC_PER_USEC);\n\n\treturn cfs_period_us;\n}\n\nstatic s64 cpu_cfs_quota_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t  struct cftype *cft)\n{\n\treturn tg_get_cfs_quota(css_tg(css));\n}\n\nstatic int cpu_cfs_quota_write_s64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cftype, s64 cfs_quota_us)\n{\n\treturn tg_set_cfs_quota(css_tg(css), cfs_quota_us);\n}\n\nstatic u64 cpu_cfs_period_read_u64(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\treturn tg_get_cfs_period(css_tg(css));\n}\n\nstatic int cpu_cfs_period_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 cfs_period_us)\n{\n\treturn tg_set_cfs_period(css_tg(css), cfs_period_us);\n}\n\nstruct cfs_schedulable_data {\n\tstruct task_group *tg;\n\tu64 period, quota;\n};\n\n/*\n * normalize group quota/period to be quota/max_period\n * note: units are usecs\n */\nstatic u64 normalize_cfs_quota(struct task_group *tg,\n\t\t\t       struct cfs_schedulable_data *d)\n{\n\tu64 quota, period;\n\n\tif (tg == d->tg) {\n\t\tperiod = d->period;\n\t\tquota = d->quota;\n\t} else {\n\t\tperiod = tg_get_cfs_period(tg);\n\t\tquota = tg_get_cfs_quota(tg);\n\t}\n\n\t/* note: these should typically be equivalent */\n\tif (quota == RUNTIME_INF || quota == -1)\n\t\treturn RUNTIME_INF;\n\n\treturn to_ratio(period, quota);\n}\n\nstatic int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\n\t\t/*\n\t\t * Ensure max(child_quota) <= parent_quota.  On cgroup2,\n\t\t * always take the min.  On cgroup1, only inherit when no\n\t\t * limit is set:\n\t\t */\n\t\tif (cgroup_subsys_on_dfl(cpu_cgrp_subsys)) {\n\t\t\tquota = min(quota, parent_quota);\n\t\t} else {\n\t\t\tif (quota == RUNTIME_INF)\n\t\t\t\tquota = parent_quota;\n\t\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\n\treturn 0;\n}\n\nstatic int __cfs_schedulable(struct task_group *tg, u64 period, u64 quota)\n{\n\tint ret;\n\tstruct cfs_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.period = period,\n\t\t.quota = quota,\n\t};\n\n\tif (quota != RUNTIME_INF) {\n\t\tdo_div(data.period, NSEC_PER_USEC);\n\t\tdo_div(data.quota, NSEC_PER_USEC);\n\t}\n\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_cfs_schedulable_down, tg_nop, &data);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int cpu_cfs_stat_show(struct seq_file *sf, void *v)\n{\n\tstruct task_group *tg = css_tg(seq_css(sf));\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\n\tseq_printf(sf, \"nr_periods %d\\n\", cfs_b->nr_periods);\n\tseq_printf(sf, \"nr_throttled %d\\n\", cfs_b->nr_throttled);\n\tseq_printf(sf, \"throttled_time %llu\\n\", cfs_b->throttled_time);\n\n\tif (schedstat_enabled() && tg != &root_task_group) {\n\t\tu64 ws = 0;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i)\n\t\t\tws += schedstat_val(tg->se[i]->statistics.wait_sum);\n\n\t\tseq_printf(sf, \"wait_sum %llu\\n\", ws);\n\t}\n\n\treturn 0;\n}\n#endif /* CONFIG_CFS_BANDWIDTH */\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n#ifdef CONFIG_RT_GROUP_SCHED\nstatic int cpu_rt_runtime_write(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft, s64 val)\n{\n\treturn sched_group_set_rt_runtime(css_tg(css), val);\n}\n\nstatic s64 cpu_rt_runtime_read(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\treturn sched_group_rt_runtime(css_tg(css));\n}\n\nstatic int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 rt_period_us)\n{\n\treturn sched_group_set_rt_period(css_tg(css), rt_period_us);\n}\n\nstatic u64 cpu_rt_period_read_uint(struct cgroup_subsys_state *css,\n\t\t\t\t   struct cftype *cft)\n{\n\treturn sched_group_rt_period(css_tg(css));\n}\n#endif /* CONFIG_RT_GROUP_SCHED */\n\nstatic struct cftype cpu_legacy_files[] = {\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t{\n\t\t.name = \"shares\",\n\t\t.read_u64 = cpu_shares_read_u64,\n\t\t.write_u64 = cpu_shares_write_u64,\n\t},\n#endif\n#ifdef CONFIG_CFS_BANDWIDTH\n\t{\n\t\t.name = \"cfs_quota_us\",\n\t\t.read_s64 = cpu_cfs_quota_read_s64,\n\t\t.write_s64 = cpu_cfs_quota_write_s64,\n\t},\n\t{\n\t\t.name = \"cfs_period_us\",\n\t\t.read_u64 = cpu_cfs_period_read_u64,\n\t\t.write_u64 = cpu_cfs_period_write_u64,\n\t},\n\t{\n\t\t.name = \"stat\",\n\t\t.seq_show = cpu_cfs_stat_show,\n\t},\n#endif\n#ifdef CONFIG_RT_GROUP_SCHED\n\t{\n\t\t.name = \"rt_runtime_us\",\n\t\t.read_s64 = cpu_rt_runtime_read,\n\t\t.write_s64 = cpu_rt_runtime_write,\n\t},\n\t{\n\t\t.name = \"rt_period_us\",\n\t\t.read_u64 = cpu_rt_period_read_uint,\n\t\t.write_u64 = cpu_rt_period_write_uint,\n\t},\n#endif\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\t{\n\t\t.name = \"uclamp.min\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_uclamp_min_show,\n\t\t.write = cpu_uclamp_min_write,\n\t},\n\t{\n\t\t.name = \"uclamp.max\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_uclamp_max_show,\n\t\t.write = cpu_uclamp_max_write,\n\t},\n#endif\n\t{ }\t/* Terminate */\n};\n\nstatic int cpu_extra_stat_show(struct seq_file *sf,\n\t\t\t       struct cgroup_subsys_state *css)\n{\n#ifdef CONFIG_CFS_BANDWIDTH\n\t{\n\t\tstruct task_group *tg = css_tg(css);\n\t\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\t\tu64 throttled_usec;\n\n\t\tthrottled_usec = cfs_b->throttled_time;\n\t\tdo_div(throttled_usec, NSEC_PER_USEC);\n\n\t\tseq_printf(sf, \"nr_periods %d\\n\"\n\t\t\t   \"nr_throttled %d\\n\"\n\t\t\t   \"throttled_usec %llu\\n\",\n\t\t\t   cfs_b->nr_periods, cfs_b->nr_throttled,\n\t\t\t   throttled_usec);\n\t}\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\nstatic u64 cpu_weight_read_u64(struct cgroup_subsys_state *css,\n\t\t\t       struct cftype *cft)\n{\n\tstruct task_group *tg = css_tg(css);\n\tu64 weight = scale_load_down(tg->shares);\n\n\treturn DIV_ROUND_CLOSEST_ULL(weight * CGROUP_WEIGHT_DFL, 1024);\n}\n\nstatic int cpu_weight_write_u64(struct cgroup_subsys_state *css,\n\t\t\t\tstruct cftype *cft, u64 weight)\n{\n\t/*\n\t * cgroup weight knobs should use the common MIN, DFL and MAX\n\t * values which are 1, 100 and 10000 respectively.  While it loses\n\t * a bit of range on both ends, it maps pretty well onto the shares\n\t * value used by scheduler and the round-trip conversions preserve\n\t * the original value over the entire range.\n\t */\n\tif (weight < CGROUP_WEIGHT_MIN || weight > CGROUP_WEIGHT_MAX)\n\t\treturn -ERANGE;\n\n\tweight = DIV_ROUND_CLOSEST_ULL(weight * 1024, CGROUP_WEIGHT_DFL);\n\n\treturn sched_group_set_shares(css_tg(css), scale_load(weight));\n}\n\nstatic s64 cpu_weight_nice_read_s64(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cft)\n{\n\tunsigned long weight = scale_load_down(css_tg(css)->shares);\n\tint last_delta = INT_MAX;\n\tint prio, delta;\n\n\t/* find the closest nice value to the current weight */\n\tfor (prio = 0; prio < ARRAY_SIZE(sched_prio_to_weight); prio++) {\n\t\tdelta = abs(sched_prio_to_weight[prio] - weight);\n\t\tif (delta >= last_delta)\n\t\t\tbreak;\n\t\tlast_delta = delta;\n\t}\n\n\treturn PRIO_TO_NICE(prio - 1 + MAX_RT_PRIO);\n}\n\nstatic int cpu_weight_nice_write_s64(struct cgroup_subsys_state *css,\n\t\t\t\t     struct cftype *cft, s64 nice)\n{\n\tunsigned long weight;\n\tint idx;\n\n\tif (nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn -ERANGE;\n\n\tidx = NICE_TO_PRIO(nice) - MAX_RT_PRIO;\n\tidx = array_index_nospec(idx, 40);\n\tweight = sched_prio_to_weight[idx];\n\n\treturn sched_group_set_shares(css_tg(css), scale_load(weight));\n}\n#endif\n\nstatic void __maybe_unused cpu_period_quota_print(struct seq_file *sf,\n\t\t\t\t\t\t  long period, long quota)\n{\n\tif (quota < 0)\n\t\tseq_puts(sf, \"max\");\n\telse\n\t\tseq_printf(sf, \"%ld\", quota);\n\n\tseq_printf(sf, \" %ld\\n\", period);\n}\n\n/* caller should put the current value in *@periodp before calling */\nstatic int __maybe_unused cpu_period_quota_parse(char *buf,\n\t\t\t\t\t\t u64 *periodp, u64 *quotap)\n{\n\tchar tok[21];\t/* U64_MAX */\n\n\tif (sscanf(buf, \"%20s %llu\", tok, periodp) < 1)\n\t\treturn -EINVAL;\n\n\t*periodp *= NSEC_PER_USEC;\n\n\tif (sscanf(tok, \"%llu\", quotap))\n\t\t*quotap *= NSEC_PER_USEC;\n\telse if (!strcmp(tok, \"max\"))\n\t\t*quotap = RUNTIME_INF;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_CFS_BANDWIDTH\nstatic int cpu_max_show(struct seq_file *sf, void *v)\n{\n\tstruct task_group *tg = css_tg(seq_css(sf));\n\n\tcpu_period_quota_print(sf, tg_get_cfs_period(tg), tg_get_cfs_quota(tg));\n\treturn 0;\n}\n\nstatic ssize_t cpu_max_write(struct kernfs_open_file *of,\n\t\t\t     char *buf, size_t nbytes, loff_t off)\n{\n\tstruct task_group *tg = css_tg(of_css(of));\n\tu64 period = tg_get_cfs_period(tg);\n\tu64 quota;\n\tint ret;\n\n\tret = cpu_period_quota_parse(buf, &period, &quota);\n\tif (!ret)\n\t\tret = tg_set_cfs_bandwidth(tg, period, quota);\n\treturn ret ?: nbytes;\n}\n#endif\n\nstatic struct cftype cpu_files[] = {\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t{\n\t\t.name = \"weight\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.read_u64 = cpu_weight_read_u64,\n\t\t.write_u64 = cpu_weight_write_u64,\n\t},\n\t{\n\t\t.name = \"weight.nice\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.read_s64 = cpu_weight_nice_read_s64,\n\t\t.write_s64 = cpu_weight_nice_write_s64,\n\t},\n#endif\n#ifdef CONFIG_CFS_BANDWIDTH\n\t{\n\t\t.name = \"max\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_max_show,\n\t\t.write = cpu_max_write,\n\t},\n#endif\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\t{\n\t\t.name = \"uclamp.min\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_uclamp_min_show,\n\t\t.write = cpu_uclamp_min_write,\n\t},\n\t{\n\t\t.name = \"uclamp.max\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = cpu_uclamp_max_show,\n\t\t.write = cpu_uclamp_max_write,\n\t},\n#endif\n\t{ }\t/* terminate */\n};\n\nstruct cgroup_subsys cpu_cgrp_subsys = {\n\t.css_alloc\t= cpu_cgroup_css_alloc,\n\t.css_online\t= cpu_cgroup_css_online,\n\t.css_released\t= cpu_cgroup_css_released,\n\t.css_free\t= cpu_cgroup_css_free,\n\t.css_extra_stat_show = cpu_extra_stat_show,\n\t.fork\t\t= cpu_cgroup_fork,\n\t.can_attach\t= cpu_cgroup_can_attach,\n\t.attach\t\t= cpu_cgroup_attach,\n\t.legacy_cftypes\t= cpu_legacy_files,\n\t.dfl_cftypes\t= cpu_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\n#endif\t/* CONFIG_CGROUP_SCHED */\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}\n\n/*\n * Nice levels are multiplicative, with a gentle 10% change for every\n * nice level changed. I.e. when a CPU-bound task goes from nice 0 to\n * nice 1, it will get ~10% less CPU time than another CPU-bound task\n * that remained on nice 0.\n *\n * The \"10% effect\" is relative and cumulative: from _any_ nice level,\n * if you go up 1 level, it's -10% CPU usage, if you go down 1 level\n * it's +10% CPU usage. (to achieve that we use a multiplier of 1.25.\n * If a task goes up by ~10% and another task goes down by ~10% then\n * the relative distance between them is ~25%.)\n */\nconst int sched_prio_to_weight[40] = {\n /* -20 */     88761,     71755,     56483,     46273,     36291,\n /* -15 */     29154,     23254,     18705,     14949,     11916,\n /* -10 */      9548,      7620,      6100,      4904,      3906,\n /*  -5 */      3121,      2501,      1991,      1586,      1277,\n /*   0 */      1024,       820,       655,       526,       423,\n /*   5 */       335,       272,       215,       172,       137,\n /*  10 */       110,        87,        70,        56,        45,\n /*  15 */        36,        29,        23,        18,        15,\n};\n\n/*\n * Inverse (2^32/x) values of the sched_prio_to_weight[] array, precalculated.\n *\n * In cases where the weight does not change often, we can use the\n * precalculated inverse to speed up arithmetics by turning divisions\n * into multiplications:\n */\nconst u32 sched_prio_to_wmult[40] = {\n /* -20 */     48388,     59856,     76040,     92818,    118348,\n /* -15 */    147320,    184698,    229616,    287308,    360437,\n /* -10 */    449829,    563644,    704093,    875809,   1099582,\n /*  -5 */   1376151,   1717300,   2157191,   2708050,   3363326,\n /*   0 */   4194304,   5237765,   6557202,   8165337,  10153587,\n /*   5 */  12820798,  15790321,  19976592,  24970740,  31350126,\n /*  10 */  39045157,  49367440,  61356676,  76695844,  95443717,\n /*  15 */ 119304647, 148102320, 186737708, 238609294, 286331153,\n};\n\nvoid call_trace_sched_update_nr_running(struct rq *rq, int count)\n{\n        trace_sched_update_nr_running_tp(rq, count);\n}\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 861}, "message": "warn: potential spectre issue 'sched_prio_to_weight' [r]"}], "macros": [], "notes": [], "path": "/src/kernel/sched/core.c", "reportHash": "31c9276a65a7dce808e65c97de8712de", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 862}, "message": "warn: potential spectre issue 'sched_prio_to_wmult' [r]"}], "macros": [], "notes": [], "path": "/src/kernel/sched/core.c", "reportHash": "cc5fe596c9111d839e2cbe795835e56f", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 2389}, "message": "warn: inconsistent returns 'rf.flags'."}], "macros": [], "notes": [], "path": "/src/kernel/sched/core.c", "reportHash": "d38c3695b50435cd3443937b5158c395", "checkerName": "smatch.check_locking", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
