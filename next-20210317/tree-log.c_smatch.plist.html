<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/btrfs/tree-log.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2008 Oracle.  All rights reserved.\n */\n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/list_sort.h>\n#include <linux/iversion.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"tree-log.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"backref.h\"\n#include \"compression.h\"\n#include \"qgroup.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"zoned.h\"\n\n/* magic values for the inode_only field in btrfs_log_inode:\n *\n * LOG_INODE_ALL means to log everything\n * LOG_INODE_EXISTS means to log just enough to recreate the inode\n * during log replay\n */\nenum {\n\tLOG_INODE_ALL,\n\tLOG_INODE_EXISTS,\n\tLOG_OTHER_INODE,\n\tLOG_OTHER_INODE_ALL,\n};\n\n/*\n * directory trouble cases\n *\n * 1) on rename or unlink, if the inode being unlinked isn't in the fsync\n * log, we must force a full commit before doing an fsync of the directory\n * where the unlink was done.\n * ---> record transid of last unlink/rename per directory\n *\n * mkdir foo/some_dir\n * normal commit\n * rename foo/some_dir foo2/some_dir\n * mkdir foo/some_dir\n * fsync foo/some_dir/some_file\n *\n * The fsync above will unlink the original some_dir without recording\n * it in its new location (foo2).  After a crash, some_dir will be gone\n * unless the fsync of some_file forces a full commit\n *\n * 2) we must log any new names for any file or dir that is in the fsync\n * log. ---> check inode while renaming/linking.\n *\n * 2a) we must log any new names for any file or dir during rename\n * when the directory they are being removed from was logged.\n * ---> check inode and old parent dir during rename\n *\n *  2a is actually the more important variant.  With the extra logging\n *  a crash might unlink the old name without recreating the new one\n *\n * 3) after a crash, we must go through any directories with a link count\n * of zero and redo the rm -rf\n *\n * mkdir f1/foo\n * normal commit\n * rm -rf f1/foo\n * fsync(f1)\n *\n * The directory f1 was fully removed from the FS, but fsync was never\n * called on f1, only its parent dir.  After a crash the rm -rf must\n * be replayed.  This must be able to recurse down the entire\n * directory tree.  The inode link count fixup code takes care of the\n * ugly details.\n */\n\n/*\n * stages for the tree walking.  The first\n * stage (0) is to only pin down the blocks we find\n * the second stage (1) is to make sure that all the inodes\n * we find in the log are created in the subvolume.\n *\n * The last stage is to deal with directories and links and extents\n * and all the other fun semantics\n */\nenum {\n\tLOG_WALK_PIN_ONLY,\n\tLOG_WALK_REPLAY_INODES,\n\tLOG_WALK_REPLAY_DIR_INDEX,\n\tLOG_WALK_REPLAY_ALL,\n};\n\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct btrfs_inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   struct btrfs_log_ctx *ctx);\nstatic int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid);\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all);\nstatic void wait_log_commit(struct btrfs_root *root, int transid);\n\n/*\n * tree logging is a special write ahead log used to make sure that\n * fsyncs and O_SYNCs can happen without doing full tree commits.\n *\n * Full tree commits are expensive because they require commonly\n * modified blocks to be recowed, creating many dirty pages in the\n * extent tree an 4x-6x higher write load than ext3.\n *\n * Instead of doing a tree commit on every fsync, we use the\n * key ranges and transaction ids to find items for a given file or directory\n * that have changed in this transaction.  Those items are copied into\n * a special tree (one per subvolume root), that tree is written to disk\n * and then the fsync is considered complete.\n *\n * After a crash, items are copied out of the log-tree back into the\n * subvolume tree.  Any file data extents found are recorded in the extent\n * allocation tree, and the log-tree freed.\n *\n * The log tree is read three times, once to pin down all the extents it is\n * using in ram and once, once to create all the inodes logged in the tree\n * and once to do all the other items.\n */\n\n/*\n * start a sub transaction and setup the log tree\n * this increments the log tree writer count to make the people\n * syncing the tree wait for us to finish\n */\nstatic int start_log_trans(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tconst bool zoned = btrfs_is_zoned(fs_info);\n\tint ret = 0;\n\tbool created = false;\n\n\t/*\n\t * First check if the log root tree was already created. If not, create\n\t * it before locking the root's log_mutex, just to keep lockdep happy.\n\t */\n\tif (!test_bit(BTRFS_ROOT_HAS_LOG_TREE, &tree_root->state)) {\n\t\tmutex_lock(&tree_root->log_mutex);\n\t\tif (!fs_info->log_root_tree) {\n\t\t\tret = btrfs_init_log_root_tree(trans, fs_info);\n\t\t\tif (!ret) {\n\t\t\t\tset_bit(BTRFS_ROOT_HAS_LOG_TREE, &tree_root->state);\n\t\t\t\tcreated = true;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&tree_root->log_mutex);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\nagain:\n\tif (root->log_root) {\n\t\tint index = (root->log_transid + 1) % 2;\n\n\t\tif (btrfs_need_log_full_commit(trans)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (zoned && atomic_read(&root->log_commit[index])) {\n\t\t\twait_log_commit(root, root->log_transid - 1);\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (!root->log_start_pid) {\n\t\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t\troot->log_start_pid = current->pid;\n\t\t} else if (root->log_start_pid != current->pid) {\n\t\t\tset_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * This means fs_info->log_root_tree was already created\n\t\t * for some other FS trees. Do the full commit not to mix\n\t\t * nodes from multiple log transactions to do sequential\n\t\t * writing.\n\t\t */\n\t\tif (zoned && !created) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_add_log_tree(trans, root);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tset_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state);\n\t\tclear_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state);\n\t\troot->log_start_pid = current->pid;\n\t}\n\n\tatomic_inc(&root->log_writers);\n\tif (ctx && !ctx->logging_new_name) {\n\t\tint index = root->log_transid % 2;\n\t\tlist_add_tail(&ctx->list, &root->log_ctxs[index]);\n\t\tctx->log_transid = root->log_transid;\n\t}\n\nout:\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}\n\n/*\n * returns 0 if there was a log transaction running and we were able\n * to join, or returns -ENOENT if there were not transactions\n * in progress\n */\nstatic int join_running_log_trans(struct btrfs_root *root)\n{\n\tconst bool zoned = btrfs_is_zoned(root->fs_info);\n\tint ret = -ENOENT;\n\n\tif (!test_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state))\n\t\treturn ret;\n\n\tmutex_lock(&root->log_mutex);\nagain:\n\tif (root->log_root) {\n\t\tint index = (root->log_transid + 1) % 2;\n\n\t\tret = 0;\n\t\tif (zoned && atomic_read(&root->log_commit[index])) {\n\t\t\twait_log_commit(root, root->log_transid - 1);\n\t\t\tgoto again;\n\t\t}\n\t\tatomic_inc(&root->log_writers);\n\t}\n\tmutex_unlock(&root->log_mutex);\n\treturn ret;\n}\n\n/*\n * This either makes the current running log transaction wait\n * until you call btrfs_end_log_trans() or it makes any future\n * log transactions wait until you call btrfs_end_log_trans()\n */\nvoid btrfs_pin_log_trans(struct btrfs_root *root)\n{\n\tatomic_inc(&root->log_writers);\n}\n\n/*\n * indicate we're done making changes to the log tree\n * and wake up anyone waiting to do a sync\n */\nvoid btrfs_end_log_trans(struct btrfs_root *root)\n{\n\tif (atomic_dec_and_test(&root->log_writers)) {\n\t\t/* atomic_dec_and_test implies a barrier */\n\t\tcond_wake_up_nomb(&root->log_writer_wait);\n\t}\n}\n\nstatic int btrfs_write_tree_block(struct extent_buffer *buf)\n{\n\treturn filemap_fdatawrite_range(buf->pages[0]->mapping, buf->start,\n\t\t\t\t\tbuf->start + buf->len - 1);\n}\n\nstatic void btrfs_wait_tree_block_writeback(struct extent_buffer *buf)\n{\n\tfilemap_fdatawait_range(buf->pages[0]->mapping,\n\t\t\t        buf->start, buf->start + buf->len - 1);\n}\n\n/*\n * the walk control struct is used to pass state down the chain when\n * processing the log tree.  The stage field tells us which part\n * of the log tree processing we are currently doing.  The others\n * are state fields used for that specific part\n */\nstruct walk_control {\n\t/* should we free the extent on disk when done?  This is used\n\t * at transaction commit time while freeing a log tree\n\t */\n\tint free;\n\n\t/* should we write out the extent buffer?  This is used\n\t * while flushing the log tree to disk during a sync\n\t */\n\tint write;\n\n\t/* should we wait for the extent buffer io to finish?  Also used\n\t * while flushing the log tree to disk for a sync\n\t */\n\tint wait;\n\n\t/* pin only walk, we record which extents on disk belong to the\n\t * log trees\n\t */\n\tint pin;\n\n\t/* what stage of the replay code we're currently in */\n\tint stage;\n\n\t/*\n\t * Ignore any items from the inode currently being processed. Needs\n\t * to be set every time we find a BTRFS_INODE_ITEM_KEY and we are in\n\t * the LOG_WALK_REPLAY_INODES stage.\n\t */\n\tbool ignore_cur_inode;\n\n\t/* the root we are currently replaying */\n\tstruct btrfs_root *replay_dest;\n\n\t/* the trans handle for the current replay */\n\tstruct btrfs_trans_handle *trans;\n\n\t/* the function that gets used to process blocks we find in the\n\t * tree.  Note the extent_buffer might not be up to date when it is\n\t * passed in, and it must be checked or read if you need the data\n\t * inside it\n\t */\n\tint (*process_func)(struct btrfs_root *log, struct extent_buffer *eb,\n\t\t\t    struct walk_control *wc, u64 gen, int level);\n};\n\n/*\n * process_func used to pin down extents, write them or wait on them\n */\nstatic int process_one_buffer(struct btrfs_root *log,\n\t\t\t      struct extent_buffer *eb,\n\t\t\t      struct walk_control *wc, u64 gen, int level)\n{\n\tstruct btrfs_fs_info *fs_info = log->fs_info;\n\tint ret = 0;\n\n\t/*\n\t * If this fs is mixed then we need to be able to process the leaves to\n\t * pin down any logged extents, so we have to read the block.\n\t */\n\tif (btrfs_fs_incompat(fs_info, MIXED_GROUPS)) {\n\t\tret = btrfs_read_buffer(eb, gen, level, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wc->pin)\n\t\tret = btrfs_pin_extent_for_log_replay(wc->trans, eb->start,\n\t\t\t\t\t\t      eb->len);\n\n\tif (!ret && btrfs_buffer_uptodate(eb, gen, 0)) {\n\t\tif (wc->pin && btrfs_header_level(eb) == 0)\n\t\t\tret = btrfs_exclude_logged_extents(eb);\n\t\tif (wc->write)\n\t\t\tbtrfs_write_tree_block(eb);\n\t\tif (wc->wait)\n\t\t\tbtrfs_wait_tree_block_writeback(eb);\n\t}\n\treturn ret;\n}\n\n/*\n * Item overwrite used by replay and tree logging.  eb, slot and key all refer\n * to the src data we are copying out.\n *\n * root is the tree we are copying into, and path is a scratch\n * path for use in this function (it should be released on entry and\n * will be released on exit).\n *\n * If the key is already in the destination tree the existing item is\n * overwritten.  If the existing item isn't big enough, it is extended.\n * If it is too large, it is truncated.\n *\n * If the key isn't in the destination yet, a new item is inserted.\n */\nstatic noinline int overwrite_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct extent_buffer *eb, int slot,\n\t\t\t\t   struct btrfs_key *key)\n{\n\tint ret;\n\tu32 item_size;\n\tu64 saved_i_size = 0;\n\tint save_old_i_size = 0;\n\tunsigned long src_ptr;\n\tunsigned long dst_ptr;\n\tint overwrite_root = 0;\n\tbool inode_item = key->type == BTRFS_INODE_ITEM_KEY;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\toverwrite_root = 1;\n\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tsrc_ptr = btrfs_item_ptr_offset(eb, slot);\n\n\t/* look for the key in the destination tree */\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0) {\n\t\tchar *src_copy;\n\t\tchar *dst_copy;\n\t\tu32 dst_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t  path->slots[0]);\n\t\tif (dst_size != item_size)\n\t\t\tgoto insert;\n\n\t\tif (item_size == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\t\tdst_copy = kmalloc(item_size, GFP_NOFS);\n\t\tsrc_copy = kmalloc(item_size, GFP_NOFS);\n\t\tif (!dst_copy || !src_copy) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tkfree(dst_copy);\n\t\t\tkfree(src_copy);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tread_extent_buffer(eb, src_copy, src_ptr, item_size);\n\n\t\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tread_extent_buffer(path->nodes[0], dst_copy, dst_ptr,\n\t\t\t\t   item_size);\n\t\tret = memcmp(dst_copy, src_copy, item_size);\n\n\t\tkfree(dst_copy);\n\t\tkfree(src_copy);\n\t\t/*\n\t\t * they have the same contents, just return, this saves\n\t\t * us from cowing blocks in the destination tree and doing\n\t\t * extra writes that may not have been done by a previous\n\t\t * sync\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We need to load the old nbytes into the inode so when we\n\t\t * replay the extents we've logged we get the right nbytes.\n\t\t */\n\t\tif (inode_item) {\n\t\t\tstruct btrfs_inode_item *item;\n\t\t\tu64 nbytes;\n\t\t\tu32 mode;\n\n\t\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tnbytes = btrfs_inode_nbytes(path->nodes[0], item);\n\t\t\titem = btrfs_item_ptr(eb, slot,\n\t\t\t\t\t      struct btrfs_inode_item);\n\t\t\tbtrfs_set_inode_nbytes(eb, item, nbytes);\n\n\t\t\t/*\n\t\t\t * If this is a directory we need to reset the i_size to\n\t\t\t * 0 so that we can set it up properly when replaying\n\t\t\t * the rest of the items in this log.\n\t\t\t */\n\t\t\tmode = btrfs_inode_mode(eb, item);\n\t\t\tif (S_ISDIR(mode))\n\t\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t\t}\n\t} else if (inode_item) {\n\t\tstruct btrfs_inode_item *item;\n\t\tu32 mode;\n\n\t\t/*\n\t\t * New inode, set nbytes to 0 so that the nbytes comes out\n\t\t * properly when we replay the extents.\n\t\t */\n\t\titem = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\t\tbtrfs_set_inode_nbytes(eb, item, 0);\n\n\t\t/*\n\t\t * If this is a directory we need to reset the i_size to 0 so\n\t\t * that we can set it up properly when replaying the rest of\n\t\t * the items in this log.\n\t\t */\n\t\tmode = btrfs_inode_mode(eb, item);\n\t\tif (S_ISDIR(mode))\n\t\t\tbtrfs_set_inode_size(eb, item, 0);\n\t}\ninsert:\n\tbtrfs_release_path(path);\n\t/* try to insert the key into the destination tree */\n\tpath->skip_release_on_error = 1;\n\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\t      key, item_size);\n\tpath->skip_release_on_error = 0;\n\n\t/* make sure any existing item is the correct size */\n\tif (ret == -EEXIST || ret == -EOVERFLOW) {\n\t\tu32 found_size;\n\t\tfound_size = btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\tpath->slots[0]);\n\t\tif (found_size > item_size)\n\t\t\tbtrfs_truncate_item(path, item_size, 1);\n\t\telse if (found_size < item_size)\n\t\t\tbtrfs_extend_item(path, item_size - found_size);\n\t} else if (ret) {\n\t\treturn ret;\n\t}\n\tdst_ptr = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\tpath->slots[0]);\n\n\t/* don't overwrite an existing inode if the generation number\n\t * was logged as zero.  This is done when the tree logging code\n\t * is just logging an inode to make sure it exists after recovery.\n\t *\n\t * Also, don't overwrite i_size on directories during replay.\n\t * log replay inserts and removes directory items based on the\n\t * state of the tree found in the subvolume, and i_size is modified\n\t * as it goes\n\t */\n\tif (key->type == BTRFS_INODE_ITEM_KEY && ret == -EEXIST) {\n\t\tstruct btrfs_inode_item *src_item;\n\t\tstruct btrfs_inode_item *dst_item;\n\n\t\tsrc_item = (struct btrfs_inode_item *)src_ptr;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\n\t\tif (btrfs_inode_generation(eb, src_item) == 0) {\n\t\t\tstruct extent_buffer *dst_eb = path->nodes[0];\n\t\t\tconst u64 ino_size = btrfs_inode_size(eb, src_item);\n\n\t\t\t/*\n\t\t\t * For regular files an ino_size == 0 is used only when\n\t\t\t * logging that an inode exists, as part of a directory\n\t\t\t * fsync, and the inode wasn't fsynced before. In this\n\t\t\t * case don't set the size of the inode in the fs/subvol\n\t\t\t * tree, otherwise we would be throwing valid data away.\n\t\t\t */\n\t\t\tif (S_ISREG(btrfs_inode_mode(eb, src_item)) &&\n\t\t\t    S_ISREG(btrfs_inode_mode(dst_eb, dst_item)) &&\n\t\t\t    ino_size != 0)\n\t\t\t\tbtrfs_set_inode_size(dst_eb, dst_item, ino_size);\n\t\t\tgoto no_copy;\n\t\t}\n\n\t\tif (overwrite_root &&\n\t\t    S_ISDIR(btrfs_inode_mode(eb, src_item)) &&\n\t\t    S_ISDIR(btrfs_inode_mode(path->nodes[0], dst_item))) {\n\t\t\tsave_old_i_size = 1;\n\t\t\tsaved_i_size = btrfs_inode_size(path->nodes[0],\n\t\t\t\t\t\t\tdst_item);\n\t\t}\n\t}\n\n\tcopy_extent_buffer(path->nodes[0], eb, dst_ptr,\n\t\t\t   src_ptr, item_size);\n\n\tif (save_old_i_size) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tbtrfs_set_inode_size(path->nodes[0], dst_item, saved_i_size);\n\t}\n\n\t/* make sure the generation is filled in */\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tstruct btrfs_inode_item *dst_item;\n\t\tdst_item = (struct btrfs_inode_item *)dst_ptr;\n\t\tif (btrfs_inode_generation(path->nodes[0], dst_item) == 0) {\n\t\t\tbtrfs_set_inode_generation(path->nodes[0], dst_item,\n\t\t\t\t\t\t   trans->transid);\n\t\t}\n\t}\nno_copy:\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\n/*\n * simple helper to read an inode off the disk from a given root\n * This can only be called for subvolume roots and not for the log\n */\nstatic noinline struct inode *read_one_inode(struct btrfs_root *root,\n\t\t\t\t\t     u64 objectid)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget(root->fs_info->sb, objectid, root);\n\tif (IS_ERR(inode))\n\t\tinode = NULL;\n\treturn inode;\n}\n\n/* replays a single extent in 'eb' at 'slot' with 'key' into the\n * subvolume 'root'.  path is released on entry and should be released\n * on exit.\n *\n * extents in the log tree have not been allocated out of the extent\n * tree yet.  So, this completes the allocation, taking a reference\n * as required if the extent already exists or creating a new extent\n * if it isn't in the extent allocation tree yet.\n *\n * The extent is inserted into the file, dropping any existing extents\n * from the file that overlap the new one.\n */\nstatic noinline int replay_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct extent_buffer *eb, int slot,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint found_type;\n\tu64 extent_end;\n\tu64 start = key->offset;\n\tu64 nbytes = 0;\n\tstruct btrfs_file_extent_item *item;\n\tstruct inode *inode = NULL;\n\tunsigned long size;\n\tint ret = 0;\n\n\titem = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tfound_type = btrfs_file_extent_type(eb, item);\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tnbytes = btrfs_file_extent_num_bytes(eb, item);\n\t\textent_end = start + nbytes;\n\n\t\t/*\n\t\t * We don't add to the inodes nbytes if we are prealloc or a\n\t\t * hole.\n\t\t */\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0)\n\t\t\tnbytes = 0;\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tsize = btrfs_file_extent_ram_bytes(eb, item);\n\t\tnbytes = btrfs_file_extent_ram_bytes(eb, item);\n\t\textent_end = ALIGN(start + size,\n\t\t\t\t   fs_info->sectorsize);\n\t} else {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, key->objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * first check to see if we already have this extent in the\n\t * file.  This must be done before the btrfs_drop_extents run\n\t * so we don't try to drop this extent.\n\t */\n\tret = btrfs_lookup_file_extent(trans, root, path,\n\t\t\tbtrfs_ino(BTRFS_I(inode)), start, 0);\n\n\tif (ret == 0 &&\n\t    (found_type == BTRFS_FILE_EXTENT_REG ||\n\t     found_type == BTRFS_FILE_EXTENT_PREALLOC)) {\n\t\tstruct btrfs_file_extent_item cmp1;\n\t\tstruct btrfs_file_extent_item cmp2;\n\t\tstruct btrfs_file_extent_item *existing;\n\t\tstruct extent_buffer *leaf;\n\n\t\tleaf = path->nodes[0];\n\t\texisting = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_file_extent_item);\n\n\t\tread_extent_buffer(eb, &cmp1, (unsigned long)item,\n\t\t\t\t   sizeof(cmp1));\n\t\tread_extent_buffer(leaf, &cmp2, (unsigned long)existing,\n\t\t\t\t   sizeof(cmp2));\n\n\t\t/*\n\t\t * we already have a pointer to this exact extent,\n\t\t * we don't have to do anything\n\t\t */\n\t\tif (memcmp(&cmp1, &cmp2, sizeof(cmp1)) == 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/* drop any overlapping extents */\n\tdrop_args.start = start;\n\tdrop_args.end = extent_end;\n\tdrop_args.drop_cache = true;\n\tret = btrfs_drop_extents(trans, root, BTRFS_I(inode), &drop_args);\n\tif (ret)\n\t\tgoto out;\n\n\tif (found_type == BTRFS_FILE_EXTENT_REG ||\n\t    found_type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\tu64 offset;\n\t\tunsigned long dest_offset;\n\t\tstruct btrfs_key ins;\n\n\t\tif (btrfs_file_extent_disk_bytenr(eb, item) == 0 &&\n\t\t    btrfs_fs_incompat(fs_info, NO_HOLES))\n\t\t\tgoto update_inode;\n\n\t\tret = btrfs_insert_empty_item(trans, root, path, key,\n\t\t\t\t\t      sizeof(*item));\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdest_offset = btrfs_item_ptr_offset(path->nodes[0],\n\t\t\t\t\t\t    path->slots[0]);\n\t\tcopy_extent_buffer(path->nodes[0], eb, dest_offset,\n\t\t\t\t(unsigned long)item,  sizeof(*item));\n\n\t\tins.objectid = btrfs_file_extent_disk_bytenr(eb, item);\n\t\tins.offset = btrfs_file_extent_disk_num_bytes(eb, item);\n\t\tins.type = BTRFS_EXTENT_ITEM_KEY;\n\t\toffset = key->offset - btrfs_file_extent_offset(eb, item);\n\n\t\t/*\n\t\t * Manually record dirty extent, as here we did a shallow\n\t\t * file extent item copy and skip normal backref update,\n\t\t * but modifying extent tree all by ourselves.\n\t\t * So need to manually record dirty extent for qgroup,\n\t\t * as the owner of the file extent changed from log tree\n\t\t * (doesn't affect qgroup) to fs/file tree(affects qgroup)\n\t\t */\n\t\tret = btrfs_qgroup_trace_extent(trans,\n\t\t\t\tbtrfs_file_extent_disk_bytenr(eb, item),\n\t\t\t\tbtrfs_file_extent_disk_num_bytes(eb, item),\n\t\t\t\tGFP_NOFS);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ins.objectid > 0) {\n\t\t\tstruct btrfs_ref ref = { 0 };\n\t\t\tu64 csum_start;\n\t\t\tu64 csum_end;\n\t\t\tLIST_HEAD(ordered_sums);\n\n\t\t\t/*\n\t\t\t * is this extent already allocated in the extent\n\t\t\t * allocation tree?  If so, just add a reference\n\t\t\t */\n\t\t\tret = btrfs_lookup_data_extent(fs_info, ins.objectid,\n\t\t\t\t\t\tins.offset);\n\t\t\tif (ret == 0) {\n\t\t\t\tbtrfs_init_generic_ref(&ref,\n\t\t\t\t\t\tBTRFS_ADD_DELAYED_REF,\n\t\t\t\t\t\tins.objectid, ins.offset, 0);\n\t\t\t\tbtrfs_init_data_ref(&ref,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset);\n\t\t\t\tret = btrfs_inc_extent_ref(trans, &ref);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * insert the extent pointer in the extent\n\t\t\t\t * allocation tree\n\t\t\t\t */\n\t\t\t\tret = btrfs_alloc_logged_file_extent(trans,\n\t\t\t\t\t\troot->root_key.objectid,\n\t\t\t\t\t\tkey->objectid, offset, &ins);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_release_path(path);\n\n\t\t\tif (btrfs_file_extent_compression(eb, item)) {\n\t\t\t\tcsum_start = ins.objectid;\n\t\t\t\tcsum_end = csum_start + ins.offset;\n\t\t\t} else {\n\t\t\t\tcsum_start = ins.objectid +\n\t\t\t\t\tbtrfs_file_extent_offset(eb, item);\n\t\t\t\tcsum_end = csum_start +\n\t\t\t\t\tbtrfs_file_extent_num_bytes(eb, item);\n\t\t\t}\n\n\t\t\tret = btrfs_lookup_csums_range(root->log_root,\n\t\t\t\t\t\tcsum_start, csum_end - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Now delete all existing cums in the csum root that\n\t\t\t * cover our range. We do this because we can have an\n\t\t\t * extent that is completely referenced by one file\n\t\t\t * extent item and partially referenced by another\n\t\t\t * file extent item (like after using the clone or\n\t\t\t * extent_same ioctls). In this case if we end up doing\n\t\t\t * the replay of the one that partially references the\n\t\t\t * extent first, and we do not do the csum deletion\n\t\t\t * below, we can get 2 csum items in the csum tree that\n\t\t\t * overlap each other. For example, imagine our log has\n\t\t\t * the two following file extent items:\n\t\t\t *\n\t\t\t * key (257 EXTENT_DATA 409600)\n\t\t\t *     extent data disk byte 12845056 nr 102400\n\t\t\t *     extent data offset 20480 nr 20480 ram 102400\n\t\t\t *\n\t\t\t * key (257 EXTENT_DATA 819200)\n\t\t\t *     extent data disk byte 12845056 nr 102400\n\t\t\t *     extent data offset 0 nr 102400 ram 102400\n\t\t\t *\n\t\t\t * Where the second one fully references the 100K extent\n\t\t\t * that starts at disk byte 12845056, and the log tree\n\t\t\t * has a single csum item that covers the entire range\n\t\t\t * of the extent:\n\t\t\t *\n\t\t\t * key (EXTENT_CSUM EXTENT_CSUM 12845056) itemsize 100\n\t\t\t *\n\t\t\t * After the first file extent item is replayed, the\n\t\t\t * csum tree gets the following csum item:\n\t\t\t *\n\t\t\t * key (EXTENT_CSUM EXTENT_CSUM 12865536) itemsize 20\n\t\t\t *\n\t\t\t * Which covers the 20K sub-range starting at offset 20K\n\t\t\t * of our extent. Now when we replay the second file\n\t\t\t * extent item, if we do not delete existing csum items\n\t\t\t * that cover any of its blocks, we end up getting two\n\t\t\t * csum items in our csum tree that overlap each other:\n\t\t\t *\n\t\t\t * key (EXTENT_CSUM EXTENT_CSUM 12845056) itemsize 100\n\t\t\t * key (EXTENT_CSUM EXTENT_CSUM 12865536) itemsize 20\n\t\t\t *\n\t\t\t * Which is a problem, because after this anyone trying\n\t\t\t * to lookup up for the checksum of any block of our\n\t\t\t * extent starting at an offset of 40K or higher, will\n\t\t\t * end up looking at the second csum item only, which\n\t\t\t * does not contain the checksum for any block starting\n\t\t\t * at offset 40K or higher of our extent.\n\t\t\t */\n\t\t\twhile (!list_empty(&ordered_sums)) {\n\t\t\t\tstruct btrfs_ordered_sum *sums;\n\t\t\t\tsums = list_entry(ordered_sums.next,\n\t\t\t\t\t\tstruct btrfs_ordered_sum,\n\t\t\t\t\t\tlist);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_del_csums(trans,\n\t\t\t\t\t\t\t      fs_info->csum_root,\n\t\t\t\t\t\t\t      sums->bytenr,\n\t\t\t\t\t\t\t      sums->len);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = btrfs_csum_file_blocks(trans,\n\t\t\t\t\t\tfs_info->csum_root, sums);\n\t\t\t\tlist_del(&sums->list);\n\t\t\t\tkfree(sums);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t/* inline extents are easy, we just overwrite them */\n\t\tret = overwrite_item(trans, root, path, eb, slot, key);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = btrfs_inode_set_file_extent_range(BTRFS_I(inode), start,\n\t\t\t\t\t\textent_end - start);\n\tif (ret)\n\t\tgoto out;\n\nupdate_inode:\n\tbtrfs_update_inode_bytes(BTRFS_I(inode), nbytes, drop_args.bytes_found);\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\nout:\n\tif (inode)\n\t\tiput(inode);\n\treturn ret;\n}\n\n/*\n * when cleaning up conflicts between the directory names in the\n * subvolume, directory names in the log and directory names in the\n * inode back references, we may have to unlink inodes from directories.\n *\n * This is a helper function to do the unlink of a specific directory\n * item\n */\nstatic noinline int drop_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_inode *dir,\n\t\t\t\t      struct btrfs_dir_item *di)\n{\n\tstruct inode *inode;\n\tchar *name;\n\tint name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key location;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\n\tbtrfs_dir_item_key_to_cpu(leaf, di, &location);\n\tname_len = btrfs_dir_name_len(leaf, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, name, (unsigned long)(di + 1), name_len);\n\tbtrfs_release_path(path);\n\n\tinode = read_one_inode(root, location.objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = link_to_fixup_dir(trans, root, path, location.objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_unlink_inode(trans, root, dir, BTRFS_I(inode), name,\n\t\t\tname_len);\n\tif (ret)\n\t\tgoto out;\n\telse\n\t\tret = btrfs_run_delayed_items(trans);\nout:\n\tkfree(name);\n\tiput(inode);\n\treturn ret;\n}\n\n/*\n * helper function to see if a given name and sequence number found\n * in an inode back reference are already in a directory and correctly\n * point to this inode\n */\nstatic noinline int inode_in_dir(struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t u64 dirid, u64 objectid, u64 index,\n\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key location;\n\tint match = 0;\n\n\tdi = btrfs_lookup_dir_index_item(NULL, root, path, dirid,\n\t\t\t\t\t index, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dirid, name, name_len, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\t\tif (location.objectid != objectid)\n\t\t\tgoto out;\n\t} else\n\t\tgoto out;\n\tmatch = 1;\nout:\n\tbtrfs_release_path(path);\n\treturn match;\n}\n\n/*\n * helper function to check a log tree for a named back reference in\n * an inode.  This is used to decide if a back reference that is\n * found in the subvolume conflicts with what we find in the log.\n *\n * inode backreferences may have multiple refs in a single item,\n * during replay we process one reference at a time, and we don't\n * want to delete valid links to a file from the subvolume if that\n * link is also in the log.\n */\nstatic noinline int backref_in_log(struct btrfs_root *log,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   u64 ref_objectid,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, log, key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret == 1) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = !!btrfs_find_name_in_ext_backref(path->nodes[0],\n\t\t\t\t\t\t       path->slots[0],\n\t\t\t\t\t\t       ref_objectid,\n\t\t\t\t\t\t       name, namelen);\n\telse\n\t\tret = !!btrfs_find_name_in_backref(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0],\n\t\t\t\t\t\t   name, namelen);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_root *log_root,\n\t\t\t\t  struct btrfs_inode *dir,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n\t\t\t\t  u64 ref_index, char *name, int namelen,\n\t\t\t\t  int *search_done)\n{\n\tint ret;\n\tchar *victim_name;\n\tint victim_name_len;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key search_key;\n\tstruct btrfs_inode_extref *extref;\n\nagain:\n\t/* Search old style refs */\n\tsearch_key.objectid = inode_objectid;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = parent_objectid;\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret == 0) {\n\t\tstruct btrfs_inode_ref *victim_ref;\n\t\tunsigned long ptr;\n\t\tunsigned long ptr_end;\n\n\t\tleaf = path->nodes[0];\n\n\t\t/* are we trying to overwrite a back ref for the root directory\n\t\t * if so, just jump out, we're done\n\t\t */\n\t\tif (search_key.objectid == search_key.offset)\n\t\t\treturn 1;\n\n\t\t/* check all the names in this back reference to see\n\t\t * if they are in the log.  if so, we allow them to stay\n\t\t * otherwise they must be unlinked as a conflict\n\t\t */\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(leaf, path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tvictim_ref = (struct btrfs_inode_ref *)ptr;\n\t\t\tvictim_name_len = btrfs_inode_ref_name_len(leaf,\n\t\t\t\t\t\t\t\t   victim_ref);\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tread_extent_buffer(leaf, victim_name,\n\t\t\t\t\t   (unsigned long)(victim_ref + 1),\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tret = backref_in_log(log_root, &search_key,\n\t\t\t\t\t     parent_objectid, victim_name,\n\t\t\t\t\t     victim_name_len);\n\t\t\tif (ret < 0) {\n\t\t\t\tkfree(victim_name);\n\t\t\t\treturn ret;\n\t\t\t} else if (!ret) {\n\t\t\t\tinc_nlink(&inode->vfs_inode);\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tret = btrfs_unlink_inode(trans, root, dir, inode,\n\t\t\t\t\t\tvictim_name, victim_name_len);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = btrfs_run_delayed_items(trans);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\n\n\t\t\tptr = (unsigned long)(victim_ref + 1) + victim_name_len;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: we have searched root tree and checked the\n\t\t * corresponding ref, it does not need to check again.\n\t\t */\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* Same search but for extended refs */\n\textref = btrfs_lookup_inode_extref(NULL, root, path, name, namelen,\n\t\t\t\t\t   inode_objectid, parent_objectid, 0,\n\t\t\t\t\t   0);\n\tif (!IS_ERR_OR_NULL(extref)) {\n\t\tu32 item_size;\n\t\tu32 cur_offset = 0;\n\t\tunsigned long base;\n\t\tstruct inode *victim_parent;\n\n\t\tleaf = path->nodes[0];\n\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tbase = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *)(base + cur_offset);\n\n\t\t\tvictim_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tif (btrfs_inode_extref_parent(leaf, extref) != parent_objectid)\n\t\t\t\tgoto next;\n\n\t\t\tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t\t\tif (!victim_name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tread_extent_buffer(leaf, victim_name, (unsigned long)&extref->name,\n\t\t\t\t\t   victim_name_len);\n\n\t\t\tsearch_key.objectid = inode_objectid;\n\t\t\tsearch_key.type = BTRFS_INODE_EXTREF_KEY;\n\t\t\tsearch_key.offset = btrfs_extref_hash(parent_objectid,\n\t\t\t\t\t\t\t      victim_name,\n\t\t\t\t\t\t\t      victim_name_len);\n\t\t\tret = backref_in_log(log_root, &search_key,\n\t\t\t\t\t     parent_objectid, victim_name,\n\t\t\t\t\t     victim_name_len);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn ret;\n\t\t\t} else if (!ret) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tvictim_parent = read_one_inode(root,\n\t\t\t\t\t\tparent_objectid);\n\t\t\t\tif (victim_parent) {\n\t\t\t\t\tinc_nlink(&inode->vfs_inode);\n\t\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\t\tret = btrfs_unlink_inode(trans, root,\n\t\t\t\t\t\t\tBTRFS_I(victim_parent),\n\t\t\t\t\t\t\tinode,\n\t\t\t\t\t\t\tvictim_name,\n\t\t\t\t\t\t\tvictim_name_len);\n\t\t\t\t\tif (!ret)\n\t\t\t\t\t\tret = btrfs_run_delayed_items(\n\t\t\t\t\t\t\t\t  trans);\n\t\t\t\t}\n\t\t\t\tiput(victim_parent);\n\t\t\t\tkfree(victim_name);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*search_done = 1;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(victim_name);\nnext:\n\t\t\tcur_offset += victim_name_len + sizeof(*extref);\n\t\t}\n\t\t*search_done = 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicting sequence number */\n\tdi = btrfs_lookup_dir_index_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t\t ref_index, name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* look for a conflicting name */\n\tdi = btrfs_lookup_dir_item(trans, root, path, btrfs_ino(dir),\n\t\t\t\t   name, namelen, 0);\n\tif (di && !IS_ERR(di)) {\n\t\tret = drop_one_dir_item(trans, root, path, dir, di);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbtrfs_release_path(path);\n\n\treturn 0;\n}\n\nstatic int extref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t     u32 *namelen, char **name, u64 *index,\n\t\t\t     u64 *parent_objectid)\n{\n\tstruct btrfs_inode_extref *extref;\n\n\textref = (struct btrfs_inode_extref *)ref_ptr;\n\n\t*namelen = btrfs_inode_extref_name_len(eb, extref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)&extref->name,\n\t\t\t   *namelen);\n\n\tif (index)\n\t\t*index = btrfs_inode_extref_index(eb, extref);\n\tif (parent_objectid)\n\t\t*parent_objectid = btrfs_inode_extref_parent(eb, extref);\n\n\treturn 0;\n}\n\nstatic int ref_get_fields(struct extent_buffer *eb, unsigned long ref_ptr,\n\t\t\t  u32 *namelen, char **name, u64 *index)\n{\n\tstruct btrfs_inode_ref *ref;\n\n\tref = (struct btrfs_inode_ref *)ref_ptr;\n\n\t*namelen = btrfs_inode_ref_name_len(eb, ref);\n\t*name = kmalloc(*namelen, GFP_NOFS);\n\tif (*name == NULL)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(eb, *name, (unsigned long)(ref + 1), *namelen);\n\n\tif (index)\n\t\t*index = btrfs_inode_ref_index(eb, ref);\n\n\treturn 0;\n}\n\n/*\n * Take an inode reference item from the log tree and iterate all names from the\n * inode reference item in the subvolume tree with the same key (if it exists).\n * For any name that is not in the inode reference item from the log tree, do a\n * proper unlink of that name (that is, remove its entry from the inode\n * reference item and both dir index keys).\n */\nstatic int unlink_old_inode_refs(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct extent_buffer *log_eb,\n\t\t\t\t int log_slot,\n\t\t\t\t struct btrfs_key *key)\n{\n\tint ret;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tstruct extent_buffer *eb;\n\nagain:\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tref_ptr = btrfs_item_ptr_offset(eb, path->slots[0]);\n\tref_end = ref_ptr + btrfs_item_size_nr(eb, path->slots[0]);\n\twhile (ref_ptr < ref_end) {\n\t\tchar *name = NULL;\n\t\tint namelen;\n\t\tu64 parent_id;\n\n\t\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t\tNULL, &parent_id);\n\t\t} else {\n\t\t\tparent_id = key->offset;\n\t\t\tret = ref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t     NULL);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (key->type == BTRFS_INODE_EXTREF_KEY)\n\t\t\tret = !!btrfs_find_name_in_ext_backref(log_eb, log_slot,\n\t\t\t\t\t\t\t       parent_id, name,\n\t\t\t\t\t\t\t       namelen);\n\t\telse\n\t\t\tret = !!btrfs_find_name_in_backref(log_eb, log_slot,\n\t\t\t\t\t\t\t   name, namelen);\n\n\t\tif (!ret) {\n\t\t\tstruct inode *dir;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tdir = read_one_inode(root, parent_id);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tkfree(name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_unlink_inode(trans, root, BTRFS_I(dir),\n\t\t\t\t\t\t inode, name, namelen);\n\t\t\tkfree(name);\n\t\t\tiput(dir);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tgoto again;\n\t\t}\n\n\t\tkfree(name);\n\t\tref_ptr += namelen;\n\t\tif (key->type == BTRFS_INODE_EXTREF_KEY)\n\t\t\tref_ptr += sizeof(struct btrfs_inode_extref);\n\t\telse\n\t\t\tref_ptr += sizeof(struct btrfs_inode_ref);\n\t}\n\tret = 0;\n out:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\nstatic int btrfs_inode_ref_exists(struct inode *inode, struct inode *dir,\n\t\t\t\t  const u8 ref_type, const char *name,\n\t\t\t\t  const int namelen)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tconst u64 parent_id = btrfs_ino(BTRFS_I(dir));\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = btrfs_ino(BTRFS_I(inode));\n\tkey.type = ref_type;\n\tif (key.type == BTRFS_INODE_REF_KEY)\n\t\tkey.offset = parent_id;\n\telse\n\t\tkey.offset = btrfs_extref_hash(parent_id, name, namelen);\n\n\tret = btrfs_search_slot(NULL, BTRFS_I(inode)->root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tif (key.type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = !!btrfs_find_name_in_ext_backref(path->nodes[0],\n\t\t\t\tpath->slots[0], parent_id, name, namelen);\n\telse\n\t\tret = !!btrfs_find_name_in_backref(path->nodes[0], path->slots[0],\n\t\t\t\t\t\t   name, namelen);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int add_link(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct inode *dir, struct inode *inode, const char *name,\n\t\t    int namelen, u64 ref_index)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct inode *other_inode = NULL;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdir_item = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\t\t\t btrfs_ino(BTRFS_I(dir)),\n\t\t\t\t\t name, namelen, 0);\n\tif (!dir_item) {\n\t\tbtrfs_release_path(path);\n\t\tgoto add_link;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Our inode's dentry collides with the dentry of another inode which is\n\t * in the log but not yet processed since it has a higher inode number.\n\t * So delete that other dentry.\n\t */\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dir_item, &key);\n\tbtrfs_release_path(path);\n\tother_inode = read_one_inode(root, key.objectid);\n\tif (!other_inode) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = btrfs_unlink_inode(trans, root, BTRFS_I(dir), BTRFS_I(other_inode),\n\t\t\t\t name, namelen);\n\tif (ret)\n\t\tgoto out;\n\t/*\n\t * If we dropped the link count to 0, bump it so that later the iput()\n\t * on the inode will not free it. We will fixup the link count later.\n\t */\n\tif (other_inode->i_nlink == 0)\n\t\tinc_nlink(other_inode);\n\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto out;\nadd_link:\n\tret = btrfs_add_link(trans, BTRFS_I(dir), BTRFS_I(inode),\n\t\t\t     name, namelen, 0, ref_index);\nout:\n\tiput(other_inode);\n\tbtrfs_free_path(path);\n\n\treturn ret;\n}\n\n/*\n * replay one inode back reference item found in the log tree.\n * eb, slot and key refer to the buffer and key found in the log tree.\n * root is the destination we are replaying into, and path is for temp\n * use by this function.  (it should be released on return).\n */\nstatic noinline int add_inode_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct extent_buffer *eb, int slot,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct inode *dir = NULL;\n\tstruct inode *inode = NULL;\n\tunsigned long ref_ptr;\n\tunsigned long ref_end;\n\tchar *name = NULL;\n\tint namelen;\n\tint ret;\n\tint search_done = 0;\n\tint log_ref_ver = 0;\n\tu64 parent_objectid;\n\tu64 inode_objectid;\n\tu64 ref_index = 0;\n\tint ref_struct_size;\n\n\tref_ptr = btrfs_item_ptr_offset(eb, slot);\n\tref_end = ref_ptr + btrfs_item_size_nr(eb, slot);\n\n\tif (key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\tstruct btrfs_inode_extref *r;\n\n\t\tref_struct_size = sizeof(struct btrfs_inode_extref);\n\t\tlog_ref_ver = 1;\n\t\tr = (struct btrfs_inode_extref *)ref_ptr;\n\t\tparent_objectid = btrfs_inode_extref_parent(eb, r);\n\t} else {\n\t\tref_struct_size = sizeof(struct btrfs_inode_ref);\n\t\tparent_objectid = key->offset;\n\t}\n\tinode_objectid = key->objectid;\n\n\t/*\n\t * it is possible that we didn't log all the parent directories\n\t * for a given inode.  If we don't find the dir, just don't\n\t * copy the back ref in.  The link count fixup code will take\n\t * care of the rest\n\t */\n\tdir = read_one_inode(root, parent_objectid);\n\tif (!dir) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tinode = read_one_inode(root, inode_objectid);\n\tif (!inode) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (ref_ptr < ref_end) {\n\t\tif (log_ref_ver) {\n\t\t\tret = extref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t\t&ref_index, &parent_objectid);\n\t\t\t/*\n\t\t\t * parent object can change from one array\n\t\t\t * item to another.\n\t\t\t */\n\t\t\tif (!dir)\n\t\t\t\tdir = read_one_inode(root, parent_objectid);\n\t\t\tif (!dir) {\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ref_get_fields(eb, ref_ptr, &namelen, &name,\n\t\t\t\t\t     &ref_index);\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/* if we already have a perfect match, we're done */\n\t\tif (!inode_in_dir(root, path, btrfs_ino(BTRFS_I(dir)),\n\t\t\t\t\tbtrfs_ino(BTRFS_I(inode)), ref_index,\n\t\t\t\t\tname, namelen)) {\n\t\t\t/*\n\t\t\t * look for a conflicting back reference in the\n\t\t\t * metadata. if we find one we have to unlink that name\n\t\t\t * of the file before we add our new link.  Later on, we\n\t\t\t * overwrite any existing back reference, and we don't\n\t\t\t * want to create dangling pointers in the directory.\n\t\t\t */\n\n\t\t\tif (!search_done) {\n\t\t\t\tret = __add_inode_ref(trans, root, path, log,\n\t\t\t\t\t\t      BTRFS_I(dir),\n\t\t\t\t\t\t      BTRFS_I(inode),\n\t\t\t\t\t\t      inode_objectid,\n\t\t\t\t\t\t      parent_objectid,\n\t\t\t\t\t\t      ref_index, name, namelen,\n\t\t\t\t\t\t      &search_done);\n\t\t\t\tif (ret) {\n\t\t\t\t\tif (ret == 1)\n\t\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If a reference item already exists for this inode\n\t\t\t * with the same parent and name, but different index,\n\t\t\t * drop it and the corresponding directory index entries\n\t\t\t * from the parent before adding the new reference item\n\t\t\t * and dir index entries, otherwise we would fail with\n\t\t\t * -EEXIST returned from btrfs_add_link() below.\n\t\t\t */\n\t\t\tret = btrfs_inode_ref_exists(inode, dir, key->type,\n\t\t\t\t\t\t     name, namelen);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = btrfs_unlink_inode(trans, root,\n\t\t\t\t\t\t\t BTRFS_I(dir),\n\t\t\t\t\t\t\t BTRFS_I(inode),\n\t\t\t\t\t\t\t name, namelen);\n\t\t\t\t/*\n\t\t\t\t * If we dropped the link count to 0, bump it so\n\t\t\t\t * that later the iput() on the inode will not\n\t\t\t\t * free it. We will fixup the link count later.\n\t\t\t\t */\n\t\t\t\tif (!ret && inode->i_nlink == 0)\n\t\t\t\t\tinc_nlink(inode);\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* insert our name */\n\t\t\tret = add_link(trans, root, dir, inode, name, namelen,\n\t\t\t\t       ref_index);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tbtrfs_update_inode(trans, root, BTRFS_I(inode));\n\t\t}\n\n\t\tref_ptr = (unsigned long)(ref_ptr + ref_struct_size) + namelen;\n\t\tkfree(name);\n\t\tname = NULL;\n\t\tif (log_ref_ver) {\n\t\t\tiput(dir);\n\t\t\tdir = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Before we overwrite the inode reference item in the subvolume tree\n\t * with the item from the log tree, we must unlink all names from the\n\t * parent directory that are in the subvolume's tree inode reference\n\t * item, otherwise we end up with an inconsistent subvolume tree where\n\t * dir index entries exist for a name but there is no inode reference\n\t * item with the same name.\n\t */\n\tret = unlink_old_inode_refs(trans, root, path, BTRFS_I(inode), eb, slot,\n\t\t\t\t    key);\n\tif (ret)\n\t\tgoto out;\n\n\t/* finally write the back reference in the inode */\n\tret = overwrite_item(trans, root, path, eb, slot, key);\nout:\n\tbtrfs_release_path(path);\n\tkfree(name);\n\tiput(dir);\n\tiput(inode);\n\treturn ret;\n}\n\nstatic int count_inode_extrefs(struct btrfs_root *root,\n\t\tstruct btrfs_inode *inode, struct btrfs_path *path)\n{\n\tint ret = 0;\n\tint name_len;\n\tunsigned int nlink = 0;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tu64 inode_objectid = btrfs_ino(inode);\n\tu64 offset = 0;\n\tunsigned long ptr;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(root, inode_objectid, offset, path,\n\t\t\t\t\t    &extref, &offset);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\textref = (struct btrfs_inode_extref *) (ptr + cur_offset);\n\t\t\tname_len = btrfs_inode_extref_name_len(leaf, extref);\n\n\t\t\tnlink++;\n\n\t\t\tcur_offset += name_len + sizeof(*extref);\n\t\t}\n\n\t\toffset++;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\tif (ret < 0 && ret != -ENOENT)\n\t\treturn ret;\n\treturn nlink;\n}\n\nstatic int count_inode_refs(struct btrfs_root *root,\n\t\t\tstruct btrfs_inode *inode, struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tunsigned int nlink = 0;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tint name_len;\n\tu64 ino = btrfs_ino(inode);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\nprocess_slot:\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t      path->slots[0]);\n\t\tif (key.objectid != ino ||\n\t\t    key.type != BTRFS_INODE_REF_KEY)\n\t\t\tbreak;\n\t\tptr = btrfs_item_ptr_offset(path->nodes[0], path->slots[0]);\n\t\tptr_end = ptr + btrfs_item_size_nr(path->nodes[0],\n\t\t\t\t\t\t   path->slots[0]);\n\t\twhile (ptr < ptr_end) {\n\t\t\tstruct btrfs_inode_ref *ref;\n\n\t\t\tref = (struct btrfs_inode_ref *)ptr;\n\t\t\tname_len = btrfs_inode_ref_name_len(path->nodes[0],\n\t\t\t\t\t\t\t    ref);\n\t\t\tptr = (unsigned long)(ref + 1) + name_len;\n\t\t\tnlink++;\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\t\tif (path->slots[0] > 0) {\n\t\t\tpath->slots[0]--;\n\t\t\tgoto process_slot;\n\t\t}\n\t\tkey.offset--;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\n\treturn nlink;\n}\n\n/*\n * There are a few corners where the link count of the file can't\n * be properly maintained during replay.  So, instead of adding\n * lots of complexity to the log code, we just scan the backrefs\n * for any file that has been through replay.\n *\n * The scan will update the link count on the inode to reflect the\n * number of back refs found.  If it goes down to zero, the iput\n * will free the inode.\n */\nstatic noinline int fixup_inode_link_count(struct btrfs_trans_handle *trans,\n\t\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tu64 nlink = 0;\n\tu64 ino = btrfs_ino(BTRFS_I(inode));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = count_inode_refs(root, BTRFS_I(inode), path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink = ret;\n\n\tret = count_inode_extrefs(root, BTRFS_I(inode), path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnlink += ret;\n\n\tret = 0;\n\n\tif (nlink != inode->i_nlink) {\n\t\tset_nlink(inode, nlink);\n\t\tbtrfs_update_inode(trans, root, BTRFS_I(inode));\n\t}\n\tBTRFS_I(inode)->index_cnt = (u64)-1;\n\n\tif (inode->i_nlink == 0) {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tret = replay_dir_deletes(trans, root, NULL, path,\n\t\t\t\t\t\t ino, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = btrfs_insert_orphan_item(trans, root, ino);\n\t\tif (ret == -EEXIST)\n\t\t\tret = 0;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic noinline int fixup_inode_link_counts(struct btrfs_trans_handle *trans,\n\t\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t\t    struct btrfs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct inode *inode;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (ret == 1) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_TREE_LOG_FIXUP_OBJECTID ||\n\t\t    key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t\tinode = read_one_inode(root, key.offset);\n\t\tif (!inode)\n\t\t\treturn -EIO;\n\n\t\tret = fixup_inode_link_count(trans, root, inode);\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * fixup on a directory may create new entries,\n\t\t * make sure we always look for the highset possible\n\t\t * offset\n\t\t */\n\t\tkey.offset = (u64)-1;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n\n/*\n * record a given inode in the fixup dir so we can check its link\n * count when replay is done.  The link count is incremented here\n * so the inode won't go away until we check it\n */\nstatic noinline int link_to_fixup_dir(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tstruct inode *inode;\n\n\tinode = read_one_inode(root, objectid);\n\tif (!inode)\n\t\treturn -EIO;\n\n\tkey.objectid = BTRFS_TREE_LOG_FIXUP_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = objectid;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key, 0);\n\n\tbtrfs_release_path(path);\n\tif (ret == 0) {\n\t\tif (!inode->i_nlink)\n\t\t\tset_nlink(inode, 1);\n\t\telse\n\t\t\tinc_nlink(inode);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\t} else if (ret == -EEXIST) {\n\t\tret = 0;\n\t} else {\n\t\tBUG(); /* Logic Error */\n\t}\n\tiput(inode);\n\n\treturn ret;\n}\n\n/*\n * when replaying the log for a directory, we only insert names\n * for inodes that actually exist.  This means an fsync on a directory\n * does not implicitly fsync all the new files in it\n */\nstatic noinline int insert_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    u64 dirid, u64 index,\n\t\t\t\t    char *name, int name_len,\n\t\t\t\t    struct btrfs_key *location)\n{\n\tstruct inode *inode;\n\tstruct inode *dir;\n\tint ret;\n\n\tinode = read_one_inode(root, location->objectid);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tdir = read_one_inode(root, dirid);\n\tif (!dir) {\n\t\tiput(inode);\n\t\treturn -EIO;\n\t}\n\n\tret = btrfs_add_link(trans, BTRFS_I(dir), BTRFS_I(inode), name,\n\t\t\tname_len, 1, index);\n\n\t/* FIXME, put inode into FIXUP list */\n\n\tiput(inode);\n\tiput(dir);\n\treturn ret;\n}\n\n/*\n * take a single entry in a log directory item and replay it into\n * the subvolume.\n *\n * if a conflicting item exists in the subdirectory already,\n * the inode it points to is unlinked and put into the link count\n * fix up tree.\n *\n * If a name from the log points to a file or directory that does\n * not exist in the FS, it is skipped.  fsyncs on directories\n * do not force down inodes inside that directory, just changes to the\n * names or unlinks in a directory.\n *\n * Returns < 0 on error, 0 if the name wasn't replayed (dentry points to a\n * non-existing inode) and 1 if the name was replayed.\n */\nstatic noinline int replay_one_name(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *eb,\n\t\t\t\t    struct btrfs_dir_item *di,\n\t\t\t\t    struct btrfs_key *key)\n{\n\tchar *name;\n\tint name_len;\n\tstruct btrfs_dir_item *dst_di;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key log_key;\n\tstruct inode *dir;\n\tu8 log_type;\n\tint exists;\n\tint ret = 0;\n\tbool update_size = (key->type == BTRFS_DIR_INDEX_KEY);\n\tbool name_added = false;\n\n\tdir = read_one_inode(root, key->objectid);\n\tif (!dir)\n\t\treturn -EIO;\n\n\tname_len = btrfs_dir_name_len(eb, di);\n\tname = kmalloc(name_len, GFP_NOFS);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlog_type = btrfs_dir_type(eb, di);\n\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t   name_len);\n\n\tbtrfs_dir_item_key_to_cpu(eb, di, &log_key);\n\texists = btrfs_lookup_inode(trans, root, path, &log_key, 0);\n\tif (exists == 0)\n\t\texists = 1;\n\telse\n\t\texists = 0;\n\tbtrfs_release_path(path);\n\n\tif (key->type == BTRFS_DIR_ITEM_KEY) {\n\t\tdst_di = btrfs_lookup_dir_item(trans, root, path, key->objectid,\n\t\t\t\t       name, name_len, 1);\n\t} else if (key->type == BTRFS_DIR_INDEX_KEY) {\n\t\tdst_di = btrfs_lookup_dir_index_item(trans, root, path,\n\t\t\t\t\t\t     key->objectid,\n\t\t\t\t\t\t     key->offset, name,\n\t\t\t\t\t\t     name_len, 1);\n\t} else {\n\t\t/* Corruption */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (IS_ERR_OR_NULL(dst_di)) {\n\t\t/* we need a sequence number to insert, so we only\n\t\t * do inserts for the BTRFS_DIR_INDEX_KEY types\n\t\t */\n\t\tif (key->type != BTRFS_DIR_INDEX_KEY)\n\t\t\tgoto out;\n\t\tgoto insert;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], dst_di, &found_key);\n\t/* the existing item matches the logged item */\n\tif (found_key.objectid == log_key.objectid &&\n\t    found_key.type == log_key.type &&\n\t    found_key.offset == log_key.offset &&\n\t    btrfs_dir_type(path->nodes[0], dst_di) == log_type) {\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * don't drop the conflicting directory entry if the inode\n\t * for the new entry doesn't exist\n\t */\n\tif (!exists)\n\t\tgoto out;\n\n\tret = drop_one_dir_item(trans, root, path, BTRFS_I(dir), dst_di);\n\tif (ret)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_DIR_INDEX_KEY)\n\t\tgoto insert;\nout:\n\tbtrfs_release_path(path);\n\tif (!ret && update_size) {\n\t\tbtrfs_i_size_write(BTRFS_I(dir), dir->i_size + name_len * 2);\n\t\tret = btrfs_update_inode(trans, root, BTRFS_I(dir));\n\t}\n\tkfree(name);\n\tiput(dir);\n\tif (!ret && name_added)\n\t\tret = 1;\n\treturn ret;\n\ninsert:\n\t/*\n\t * Check if the inode reference exists in the log for the given name,\n\t * inode and parent inode\n\t */\n\tfound_key.objectid = log_key.objectid;\n\tfound_key.type = BTRFS_INODE_REF_KEY;\n\tfound_key.offset = key->objectid;\n\tret = backref_in_log(root->log_root, &found_key, 0, name, name_len);\n\tif (ret < 0) {\n\t        goto out;\n\t} else if (ret) {\n\t        /* The dentry will be added later. */\n\t        ret = 0;\n\t        update_size = false;\n\t        goto out;\n\t}\n\n\tfound_key.objectid = log_key.objectid;\n\tfound_key.type = BTRFS_INODE_EXTREF_KEY;\n\tfound_key.offset = key->objectid;\n\tret = backref_in_log(root->log_root, &found_key, key->objectid, name,\n\t\t\t     name_len);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\t/* The dentry will be added later. */\n\t\tret = 0;\n\t\tupdate_size = false;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(path);\n\tret = insert_one_name(trans, root, key->objectid, key->offset,\n\t\t\t      name, name_len, &log_key);\n\tif (ret && ret != -ENOENT && ret != -EEXIST)\n\t\tgoto out;\n\tif (!ret)\n\t\tname_added = true;\n\tupdate_size = false;\n\tret = 0;\n\tgoto out;\n}\n\n/*\n * find all the names in a directory item and reconcile them into\n * the subvolume.  Only BTRFS_DIR_ITEM_KEY types will have more than\n * one name in a directory item, but the same code gets used for\n * both directory index types\n */\nstatic noinline int replay_one_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_path *path,\n\t\t\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\t\t\tstruct btrfs_key *key)\n{\n\tint ret = 0;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tstruct btrfs_dir_item *di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tstruct btrfs_path *fixup_path = NULL;\n\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tret = replay_one_name(trans, root, path, eb, di, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\n\t\t/*\n\t\t * If this entry refers to a non-directory (directories can not\n\t\t * have a link count > 1) and it was added in the transaction\n\t\t * that was not committed, make sure we fixup the link count of\n\t\t * the inode it the entry points to. Otherwise something like\n\t\t * the following would result in a directory pointing to an\n\t\t * inode with a wrong link that does not account for this dir\n\t\t * entry:\n\t\t *\n\t\t * mkdir testdir\n\t\t * touch testdir/foo\n\t\t * touch testdir/bar\n\t\t * sync\n\t\t *\n\t\t * ln testdir/bar testdir/bar_link\n\t\t * ln testdir/foo testdir/foo_link\n\t\t * xfs_io -c \"fsync\" testdir/bar\n\t\t *\n\t\t * <power failure>\n\t\t *\n\t\t * mount fs, log replay happens\n\t\t *\n\t\t * File foo would remain with a link count of 1 when it has two\n\t\t * entries pointing to it in the directory testdir. This would\n\t\t * make it impossible to ever delete the parent directory has\n\t\t * it would result in stale dentries that can never be deleted.\n\t\t */\n\t\tif (ret == 1 && btrfs_dir_type(eb, di) != BTRFS_FT_DIR) {\n\t\t\tstruct btrfs_key di_key;\n\n\t\t\tif (!fixup_path) {\n\t\t\t\tfixup_path = btrfs_alloc_path();\n\t\t\t\tif (!fixup_path) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\t\t\tret = link_to_fixup_dir(trans, root, fixup_path,\n\t\t\t\t\t\tdi_key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t}\n\tbtrfs_free_path(fixup_path);\n\treturn ret;\n}\n\n/*\n * directory replay has two parts.  There are the standard directory\n * items in the log copied from the subvolume, and range items\n * created in the log while the subvolume was logged.\n *\n * The range items tell us which parts of the key space the log\n * is authoritative for.  During replay, if a key in the subvolume\n * directory is in a logged range item, but not actually in the log\n * that means it was deleted from the directory before the fsync\n * and should be removed.\n */\nstatic noinline int find_dir_range(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   u64 dirid, int key_type,\n\t\t\t\t   u64 *start_ret, u64 *end_ret)\n{\n\tstruct btrfs_key key;\n\tu64 found_end;\n\tstruct btrfs_dir_log_item *item;\n\tint ret;\n\tint nritems;\n\n\tif (*start_ret == (u64)-1)\n\t\treturn 1;\n\n\tkey.objectid = dirid;\n\tkey.type = key_type;\n\tkey.offset = *start_ret;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tif (path->slots[0] == 0)\n\t\t\tgoto out;\n\t\tpath->slots[0]--;\n\t}\n\tif (ret != 0)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto next;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\n\tif (*start_ret >= key.offset && *start_ret <= found_end) {\n\t\tret = 0;\n\t\t*start_ret = key.offset;\n\t\t*end_ret = found_end;\n\t\tgoto out;\n\t}\n\tret = 1;\nnext:\n\t/* check the next slot in the tree to see if it is a valid item */\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tpath->slots[0]++;\n\tif (path->slots[0] >= nritems) {\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\n\tif (key.type != key_type || key.objectid != dirid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tfound_end = btrfs_dir_log_end(path->nodes[0], item);\n\t*start_ret = key.offset;\n\t*end_ret = found_end;\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n/*\n * this looks for a given directory item in the log.  If the directory\n * item is not in the log, the item is removed and the inode it points\n * to is unlinked\n */\nstatic noinline int check_item_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_root *log,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      struct btrfs_path *log_path,\n\t\t\t\t      struct inode *dir,\n\t\t\t\t      struct btrfs_key *dir_key)\n{\n\tint ret;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tu32 item_size;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_dir_item *log_di;\n\tint name_len;\n\tunsigned long ptr;\n\tunsigned long ptr_end;\n\tchar *name;\n\tstruct inode *inode;\n\tstruct btrfs_key location;\n\nagain:\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem_size = btrfs_item_size_nr(eb, slot);\n\tptr = btrfs_item_ptr_offset(eb, slot);\n\tptr_end = ptr + item_size;\n\twhile (ptr < ptr_end) {\n\t\tdi = (struct btrfs_dir_item *)ptr;\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tread_extent_buffer(eb, name, (unsigned long)(di + 1),\n\t\t\t\t  name_len);\n\t\tlog_di = NULL;\n\t\tif (log && dir_key->type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_item(trans, log, log_path,\n\t\t\t\t\t\t       dir_key->objectid,\n\t\t\t\t\t\t       name, name_len, 0);\n\t\t} else if (log && dir_key->type == BTRFS_DIR_INDEX_KEY) {\n\t\t\tlog_di = btrfs_lookup_dir_index_item(trans, log,\n\t\t\t\t\t\t     log_path,\n\t\t\t\t\t\t     dir_key->objectid,\n\t\t\t\t\t\t     dir_key->offset,\n\t\t\t\t\t\t     name, name_len, 0);\n\t\t}\n\t\tif (!log_di || log_di == ERR_PTR(-ENOENT)) {\n\t\t\tbtrfs_dir_item_key_to_cpu(eb, di, &location);\n\t\t\tbtrfs_release_path(path);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tinode = read_one_inode(root, location.objectid);\n\t\t\tif (!inode) {\n\t\t\t\tkfree(name);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(trans, root,\n\t\t\t\t\t\tpath, location.objectid);\n\t\t\tif (ret) {\n\t\t\t\tkfree(name);\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinc_nlink(inode);\n\t\t\tret = btrfs_unlink_inode(trans, root, BTRFS_I(dir),\n\t\t\t\t\tBTRFS_I(inode), name, name_len);\n\t\t\tif (!ret)\n\t\t\t\tret = btrfs_run_delayed_items(trans);\n\t\t\tkfree(name);\n\t\t\tiput(inode);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\t/* there might still be more names under this key\n\t\t\t * check and repeat if required\n\t\t\t */\n\t\t\tret = btrfs_search_slot(NULL, root, dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(log_di)) {\n\t\t\tkfree(name);\n\t\t\treturn PTR_ERR(log_di);\n\t\t}\n\t\tbtrfs_release_path(log_path);\n\t\tkfree(name);\n\n\t\tptr = (unsigned long)(di + 1);\n\t\tptr += name_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(log_path);\n\treturn ret;\n}\n\nstatic int replay_xattr_deletes(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct btrfs_root *log,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const u64 ino)\n{\n\tstruct btrfs_key search_key;\n\tstruct btrfs_path *log_path;\n\tint i;\n\tint nritems;\n\tint ret;\n\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_XATTR_ITEM_KEY;\n\tsearch_key.offset = 0;\nagain:\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\nprocess_leaf:\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_dir_item *di;\n\t\tstruct btrfs_dir_item *log_di;\n\t\tu32 total_size;\n\t\tu32 cur;\n\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, i);\n\t\tif (key.objectid != ino || key.type != BTRFS_XATTR_ITEM_KEY) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], i, struct btrfs_dir_item);\n\t\ttotal_size = btrfs_item_size_nr(path->nodes[0], i);\n\t\tcur = 0;\n\t\twhile (cur < total_size) {\n\t\t\tu16 name_len = btrfs_dir_name_len(path->nodes[0], di);\n\t\t\tu16 data_len = btrfs_dir_data_len(path->nodes[0], di);\n\t\t\tu32 this_len = sizeof(*di) + name_len + data_len;\n\t\t\tchar *name;\n\n\t\t\tname = kmalloc(name_len, GFP_NOFS);\n\t\t\tif (!name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tread_extent_buffer(path->nodes[0], name,\n\t\t\t\t\t   (unsigned long)(di + 1), name_len);\n\n\t\t\tlog_di = btrfs_lookup_xattr(NULL, log, log_path, ino,\n\t\t\t\t\t\t    name, name_len, 0);\n\t\t\tbtrfs_release_path(log_path);\n\t\t\tif (!log_di) {\n\t\t\t\t/* Doesn't exist in log tree, so delete it. */\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tdi = btrfs_lookup_xattr(trans, root, path, ino,\n\t\t\t\t\t\t\tname, name_len, -1);\n\t\t\t\tkfree(name);\n\t\t\t\tif (IS_ERR(di)) {\n\t\t\t\t\tret = PTR_ERR(di);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tASSERT(di);\n\t\t\t\tret = btrfs_delete_one_dir_name(trans, root,\n\t\t\t\t\t\t\t\tpath, di);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tsearch_key = key;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tkfree(name);\n\t\t\tif (IS_ERR(log_di)) {\n\t\t\t\tret = PTR_ERR(log_di);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcur += this_len;\n\t\t\tdi = (struct btrfs_dir_item *)((char *)di + this_len);\n\t\t}\n\t}\n\tret = btrfs_next_leaf(root, path);\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (ret == 0)\n\t\tgoto process_leaf;\nout:\n\tbtrfs_free_path(log_path);\n\tbtrfs_release_path(path);\n\treturn ret;\n}\n\n\n/*\n * deletion replay happens before we copy any new directory items\n * out of the log or out of backreferences from inodes.  It\n * scans the log to find ranges of keys that log is authoritative for,\n * and then scans the directory to find items in those ranges that are\n * not present in the log.\n *\n * Anything we don't find in the log is unlinked and removed from the\n * directory.\n */\nstatic noinline int replay_dir_deletes(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       u64 dirid, int del_all)\n{\n\tu64 range_start;\n\tu64 range_end;\n\tint key_type = BTRFS_DIR_LOG_ITEM_KEY;\n\tint ret = 0;\n\tstruct btrfs_key dir_key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *log_path;\n\tstruct inode *dir;\n\n\tdir_key.objectid = dirid;\n\tdir_key.type = BTRFS_DIR_ITEM_KEY;\n\tlog_path = btrfs_alloc_path();\n\tif (!log_path)\n\t\treturn -ENOMEM;\n\n\tdir = read_one_inode(root, dirid);\n\t/* it isn't an error if the inode isn't there, that can happen\n\t * because we replay the deletes before we copy in the inode item\n\t * from the log\n\t */\n\tif (!dir) {\n\t\tbtrfs_free_path(log_path);\n\t\treturn 0;\n\t}\nagain:\n\trange_start = 0;\n\trange_end = 0;\n\twhile (1) {\n\t\tif (del_all)\n\t\t\trange_end = (u64)-1;\n\t\telse {\n\t\t\tret = find_dir_range(log, path, dirid, key_type,\n\t\t\t\t\t     &range_start, &range_end);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdir_key.offset = range_start;\n\t\twhile (1) {\n\t\t\tint nritems;\n\t\t\tret = btrfs_search_slot(NULL, root, &dir_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t\t\tif (path->slots[0] >= nritems) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret == 1)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (found_key.objectid != dirid ||\n\t\t\t    found_key.type != dir_key.type)\n\t\t\t\tgoto next_type;\n\n\t\t\tif (found_key.offset > range_end)\n\t\t\t\tbreak;\n\n\t\t\tret = check_item_in_log(trans, root, log, path,\n\t\t\t\t\t\tlog_path, dir,\n\t\t\t\t\t\t&found_key);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tif (found_key.offset == (u64)-1)\n\t\t\t\tbreak;\n\t\t\tdir_key.offset = found_key.offset + 1;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tif (range_end == (u64)-1)\n\t\t\tbreak;\n\t\trange_start = range_end + 1;\n\t}\n\nnext_type:\n\tret = 0;\n\tif (key_type == BTRFS_DIR_LOG_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_LOG_INDEX_KEY;\n\t\tdir_key.type = BTRFS_DIR_INDEX_KEY;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(log_path);\n\tiput(dir);\n\treturn ret;\n}\n\n/*\n * the process_func used to replay items from the log tree.  This\n * gets called in two different stages.  The first stage just looks\n * for inodes and makes sure they are all copied into the subvolume.\n *\n * The second stage copies all the other item types from the log into\n * the subvolume.  The two stage approach is slower, but gets rid of\n * lots of complexity around inodes referencing other inodes that exist\n * only in the log (references come from either directory items or inode\n * back refs).\n */\nstatic int replay_one_buffer(struct btrfs_root *log, struct extent_buffer *eb,\n\t\t\t     struct walk_control *wc, u64 gen, int level)\n{\n\tint nritems;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = wc->replay_dest;\n\tstruct btrfs_key key;\n\tint i;\n\tint ret;\n\n\tret = btrfs_read_buffer(eb, gen, level, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel = btrfs_header_level(eb);\n\n\tif (level != 0)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tnritems = btrfs_header_nritems(eb);\n\tfor (i = 0; i < nritems; i++) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, i);\n\n\t\t/* inode keys are done during the first stage */\n\t\tif (key.type == BTRFS_INODE_ITEM_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_INODES) {\n\t\t\tstruct btrfs_inode_item *inode_item;\n\t\t\tu32 mode;\n\n\t\t\tinode_item = btrfs_item_ptr(eb, i,\n\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\t/*\n\t\t\t * If we have a tmpfile (O_TMPFILE) that got fsync'ed\n\t\t\t * and never got linked before the fsync, skip it, as\n\t\t\t * replaying it is pointless since it would be deleted\n\t\t\t * later. We skip logging tmpfiles, but it's always\n\t\t\t * possible we are replaying a log created with a kernel\n\t\t\t * that used to log tmpfiles.\n\t\t\t */\n\t\t\tif (btrfs_inode_nlink(eb, inode_item) == 0) {\n\t\t\t\twc->ignore_cur_inode = true;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\twc->ignore_cur_inode = false;\n\t\t\t}\n\t\t\tret = replay_xattr_deletes(wc->trans, root, log,\n\t\t\t\t\t\t   path, key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tmode = btrfs_inode_mode(eb, inode_item);\n\t\t\tif (S_ISDIR(mode)) {\n\t\t\t\tret = replay_dir_deletes(wc->trans,\n\t\t\t\t\t root, log, path, key.objectid, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Before replaying extents, truncate the inode to its\n\t\t\t * size. We need to do it now and not after log replay\n\t\t\t * because before an fsync we can have prealloc extents\n\t\t\t * added beyond the inode's i_size. If we did it after,\n\t\t\t * through orphan cleanup for example, we would drop\n\t\t\t * those prealloc extents just after replaying them.\n\t\t\t */\n\t\t\tif (S_ISREG(mode)) {\n\t\t\t\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\t\t\t\tstruct inode *inode;\n\t\t\t\tu64 from;\n\n\t\t\t\tinode = read_one_inode(root, key.objectid);\n\t\t\t\tif (!inode) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfrom = ALIGN(i_size_read(inode),\n\t\t\t\t\t     root->fs_info->sectorsize);\n\t\t\t\tdrop_args.start = from;\n\t\t\t\tdrop_args.end = (u64)-1;\n\t\t\t\tdrop_args.drop_cache = true;\n\t\t\t\tret = btrfs_drop_extents(wc->trans, root,\n\t\t\t\t\t\t\t BTRFS_I(inode),\n\t\t\t\t\t\t\t &drop_args);\n\t\t\t\tif (!ret) {\n\t\t\t\t\tinode_sub_bytes(inode,\n\t\t\t\t\t\t\tdrop_args.bytes_found);\n\t\t\t\t\t/* Update the inode's nbytes. */\n\t\t\t\t\tret = btrfs_update_inode(wc->trans,\n\t\t\t\t\t\t\troot, BTRFS_I(inode));\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = link_to_fixup_dir(wc->trans, root,\n\t\t\t\t\t\tpath, key.objectid);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->ignore_cur_inode)\n\t\t\tcontinue;\n\n\t\tif (key.type == BTRFS_DIR_INDEX_KEY &&\n\t\t    wc->stage == LOG_WALK_REPLAY_DIR_INDEX) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage < LOG_WALK_REPLAY_ALL)\n\t\t\tcontinue;\n\n\t\t/* these keys are simply copied */\n\t\tif (key.type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tret = overwrite_item(wc->trans, root, path,\n\t\t\t\t\t     eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_INODE_REF_KEY ||\n\t\t\t   key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = add_inode_ref(wc->trans, root, log, path,\n\t\t\t\t\t    eb, i, &key);\n\t\t\tif (ret && ret != -ENOENT)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t} else if (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tret = replay_one_extent(wc->trans, root, path,\n\t\t\t\t\t\teb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else if (key.type == BTRFS_DIR_ITEM_KEY) {\n\t\t\tret = replay_one_dir_item(wc->trans, root, path,\n\t\t\t\t\t\t  eb, i, &key);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * Correctly adjust the reserved bytes occupied by a log tree extent buffer\n */\nstatic void unaccount_log_buffer(struct btrfs_fs_info *fs_info, u64 start)\n{\n\tstruct btrfs_block_group *cache;\n\n\tcache = btrfs_lookup_block_group(fs_info, start);\n\tif (!cache) {\n\t\tbtrfs_err(fs_info, \"unable to find block group for %llu\", start);\n\t\treturn;\n\t}\n\n\tspin_lock(&cache->space_info->lock);\n\tspin_lock(&cache->lock);\n\tcache->reserved -= fs_info->nodesize;\n\tcache->space_info->bytes_reserved -= fs_info->nodesize;\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&cache->space_info->lock);\n\n\tbtrfs_put_block_group(cache);\n}\n\nstatic noinline int walk_down_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_path *path, int *level,\n\t\t\t\t   struct walk_control *wc)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 bytenr;\n\tu64 ptr_gen;\n\tstruct extent_buffer *next;\n\tstruct extent_buffer *cur;\n\tu32 blocksize;\n\tint ret = 0;\n\n\twhile (*level > 0) {\n\t\tstruct btrfs_key first_key;\n\n\t\tcur = path->nodes[*level];\n\n\t\tWARN_ON(btrfs_header_level(cur) != *level);\n\n\t\tif (path->slots[*level] >=\n\t\t    btrfs_header_nritems(cur))\n\t\t\tbreak;\n\n\t\tbytenr = btrfs_node_blockptr(cur, path->slots[*level]);\n\t\tptr_gen = btrfs_node_ptr_generation(cur, path->slots[*level]);\n\t\tbtrfs_node_key_to_cpu(cur, &first_key, path->slots[*level]);\n\t\tblocksize = fs_info->nodesize;\n\n\t\tnext = btrfs_find_create_tree_block(fs_info, bytenr,\n\t\t\t\t\t\t    btrfs_header_owner(cur),\n\t\t\t\t\t\t    *level - 1);\n\t\tif (IS_ERR(next))\n\t\t\treturn PTR_ERR(next);\n\n\t\tif (*level == 1) {\n\t\t\tret = wc->process_func(root, next, wc, ptr_gen,\n\t\t\t\t\t       *level - 1);\n\t\t\tif (ret) {\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpath->slots[*level]++;\n\t\t\tif (wc->free) {\n\t\t\t\tret = btrfs_read_buffer(next, ptr_gen,\n\t\t\t\t\t\t\t*level - 1, &first_key);\n\t\t\t\tif (ret) {\n\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_clean_tree_block(next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t\tret = btrfs_pin_reserved_extent(trans,\n\t\t\t\t\t\t\tbytenr, blocksize);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tfree_extent_buffer(next);\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t\tbtrfs_redirty_list_add(\n\t\t\t\t\t\ttrans->transaction, next);\n\t\t\t\t} else {\n\t\t\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &next->bflags))\n\t\t\t\t\t\tclear_extent_buffer_dirty(next);\n\t\t\t\t\tunaccount_log_buffer(fs_info, bytenr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(next);\n\t\t\tcontinue;\n\t\t}\n\t\tret = btrfs_read_buffer(next, ptr_gen, *level - 1, &first_key);\n\t\tif (ret) {\n\t\t\tfree_extent_buffer(next);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (path->nodes[*level-1])\n\t\t\tfree_extent_buffer(path->nodes[*level-1]);\n\t\tpath->nodes[*level-1] = next;\n\t\t*level = btrfs_header_level(next);\n\t\tpath->slots[*level] = 0;\n\t\tcond_resched();\n\t}\n\tpath->slots[*level] = btrfs_header_nritems(path->nodes[*level]);\n\n\tcond_resched();\n\treturn 0;\n}\n\nstatic noinline int walk_up_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path, int *level,\n\t\t\t\t struct walk_control *wc)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tint slot;\n\tint ret;\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL - 1 && path->nodes[i]; i++) {\n\t\tslot = path->slots[i];\n\t\tif (slot + 1 < btrfs_header_nritems(path->nodes[i])) {\n\t\t\tpath->slots[i]++;\n\t\t\t*level = i;\n\t\t\tWARN_ON(*level == 0);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tret = wc->process_func(root, path->nodes[*level], wc,\n\t\t\t\t btrfs_header_generation(path->nodes[*level]),\n\t\t\t\t *level);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (wc->free) {\n\t\t\t\tstruct extent_buffer *next;\n\n\t\t\t\tnext = path->nodes[*level];\n\n\t\t\t\tif (trans) {\n\t\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\t\tbtrfs_clean_tree_block(next);\n\t\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\t\tret = btrfs_pin_reserved_extent(trans,\n\t\t\t\t\t\t     path->nodes[*level]->start,\n\t\t\t\t\t\t     path->nodes[*level]->len);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t} else {\n\t\t\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &next->bflags))\n\t\t\t\t\t\tclear_extent_buffer_dirty(next);\n\n\t\t\t\t\tunaccount_log_buffer(fs_info,\n\t\t\t\t\t\tpath->nodes[*level]->start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree_extent_buffer(path->nodes[*level]);\n\t\t\tpath->nodes[*level] = NULL;\n\t\t\t*level = i + 1;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/*\n * drop the reference count on the tree rooted at 'snap'.  This traverses\n * the tree freeing any blocks that have a ref count of zero after being\n * decremented.\n */\nstatic int walk_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *log, struct walk_control *wc)\n{\n\tstruct btrfs_fs_info *fs_info = log->fs_info;\n\tint ret = 0;\n\tint wret;\n\tint level;\n\tstruct btrfs_path *path;\n\tint orig_level;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlevel = btrfs_header_level(log->node);\n\torig_level = level;\n\tpath->nodes[level] = log->node;\n\tatomic_inc(&log->node->refs);\n\tpath->slots[level] = 0;\n\n\twhile (1) {\n\t\twret = walk_down_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\n\t\twret = walk_up_log_tree(trans, log, path, &level, wc);\n\t\tif (wret > 0)\n\t\t\tbreak;\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* was the root node processed? if not, catch it here */\n\tif (path->nodes[orig_level]) {\n\t\tret = wc->process_func(log, path->nodes[orig_level], wc,\n\t\t\t btrfs_header_generation(path->nodes[orig_level]),\n\t\t\t orig_level);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tif (wc->free) {\n\t\t\tstruct extent_buffer *next;\n\n\t\t\tnext = path->nodes[orig_level];\n\n\t\t\tif (trans) {\n\t\t\t\tbtrfs_tree_lock(next);\n\t\t\t\tbtrfs_clean_tree_block(next);\n\t\t\t\tbtrfs_wait_tree_block_writeback(next);\n\t\t\t\tbtrfs_tree_unlock(next);\n\t\t\t\tret = btrfs_pin_reserved_extent(trans,\n\t\t\t\t\t\tnext->start, next->len);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &next->bflags))\n\t\t\t\t\tclear_extent_buffer_dirty(next);\n\t\t\t\tunaccount_log_buffer(fs_info, next->start);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * helper function to update the item for a given subvolumes log root\n * in the tree of log roots\n */\nstatic int update_log_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *log,\n\t\t\t   struct btrfs_root_item *root_item)\n{\n\tstruct btrfs_fs_info *fs_info = log->fs_info;\n\tint ret;\n\n\tif (log->log_transid == 1) {\n\t\t/* insert root item on the first sync */\n\t\tret = btrfs_insert_root(trans, fs_info->log_root_tree,\n\t\t\t\t&log->root_key, root_item);\n\t} else {\n\t\tret = btrfs_update_root(trans, fs_info->log_root_tree,\n\t\t\t\t&log->root_key, root_item);\n\t}\n\treturn ret;\n}\n\nstatic void wait_log_commit(struct btrfs_root *root, int transid)\n{\n\tDEFINE_WAIT(wait);\n\tint index = transid % 2;\n\n\t/*\n\t * we only allow two pending log transactions at a time,\n\t * so we know that if ours is more than 2 older than the\n\t * current transaction, we're done\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(&root->log_commit_wait[index],\n\t\t\t\t&wait, TASK_UNINTERRUPTIBLE);\n\n\t\tif (!(root->log_transid_committed < transid &&\n\t\t      atomic_read(&root->log_commit[index])))\n\t\t\tbreak;\n\n\t\tmutex_unlock(&root->log_mutex);\n\t\tschedule();\n\t\tmutex_lock(&root->log_mutex);\n\t}\n\tfinish_wait(&root->log_commit_wait[index], &wait);\n}\n\nstatic void wait_for_writer(struct btrfs_root *root)\n{\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&root->log_writer_wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&root->log_writers))\n\t\t\tbreak;\n\n\t\tmutex_unlock(&root->log_mutex);\n\t\tschedule();\n\t\tmutex_lock(&root->log_mutex);\n\t}\n\tfinish_wait(&root->log_writer_wait, &wait);\n}\n\nstatic inline void btrfs_remove_log_ctx(struct btrfs_root *root,\n\t\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tmutex_lock(&root->log_mutex);\n\tlist_del_init(&ctx->list);\n\tmutex_unlock(&root->log_mutex);\n}\n\n/* \n * Invoked in log mutex context, or be sure there is no other task which\n * can access the list.\n */\nstatic inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,\n\t\t\t\t\t     int index, int error)\n{\n\tstruct btrfs_log_ctx *ctx;\n\tstruct btrfs_log_ctx *safe;\n\n\tlist_for_each_entry_safe(ctx, safe, &root->log_ctxs[index], list) {\n\t\tlist_del_init(&ctx->list);\n\t\tctx->log_ret = error;\n\t}\n\n\tINIT_LIST_HEAD(&root->log_ctxs[index]);\n}\n\n/*\n * btrfs_sync_log does sends a given tree log down to the disk and\n * updates the super blocks to record it.  When this call is done,\n * you know that any inodes previously logged are safely on disk only\n * if it returns 0.\n *\n * Any other return value means you need to call btrfs_commit_transaction.\n * Some of the edge cases for fsyncing directories that have had unlinks\n * or renames done in the past mean that sometimes the only safe\n * fsync is to commit the whole FS.  When btrfs_sync_log returns -EAGAIN,\n * that has happened.\n */\nint btrfs_sync_log(struct btrfs_trans_handle *trans,\n\t\t   struct btrfs_root *root, struct btrfs_log_ctx *ctx)\n{\n\tint index1;\n\tint index2;\n\tint mark;\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_root *log_root_tree = fs_info->log_root_tree;\n\tstruct btrfs_root_item new_root_item;\n\tint log_transid = 0;\n\tstruct btrfs_log_ctx root_log_ctx;\n\tstruct blk_plug plug;\n\tu64 log_root_start;\n\tu64 log_root_level;\n\n\tmutex_lock(&root->log_mutex);\n\tlog_transid = ctx->log_transid;\n\tif (root->log_transid_committed >= log_transid) {\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\n\tindex1 = log_transid % 2;\n\tif (atomic_read(&root->log_commit[index1])) {\n\t\twait_log_commit(root, log_transid);\n\t\tmutex_unlock(&root->log_mutex);\n\t\treturn ctx->log_ret;\n\t}\n\tASSERT(log_transid == root->log_transid);\n\tatomic_set(&root->log_commit[index1], 1);\n\n\t/* wait for previous tree log sync to complete */\n\tif (atomic_read(&root->log_commit[(index1 + 1) % 2]))\n\t\twait_log_commit(root, log_transid - 1);\n\n\twhile (1) {\n\t\tint batch = atomic_read(&root->log_batch);\n\t\t/* when we're on an ssd, just kick the log commit out */\n\t\tif (!btrfs_test_opt(fs_info, SSD) &&\n\t\t    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {\n\t\t\tmutex_unlock(&root->log_mutex);\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tmutex_lock(&root->log_mutex);\n\t\t}\n\t\twait_for_writer(root);\n\t\tif (batch == atomic_read(&root->log_batch))\n\t\t\tbreak;\n\t}\n\n\t/* bail out if we need to do a full commit */\n\tif (btrfs_need_log_full_commit(trans)) {\n\t\tret = -EAGAIN;\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\tif (log_transid % 2 == 0)\n\t\tmark = EXTENT_DIRTY;\n\telse\n\t\tmark = EXTENT_NEW;\n\n\t/* we start IO on  all the marked extents here, but we don't actually\n\t * wait for them until later.\n\t */\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(fs_info, &log->dirty_log_pages, mark);\n\t/*\n\t * -EAGAIN happens when someone, e.g., a concurrent transaction\n\t *  commit, writes a dirty extent in this tree-log commit. This\n\t *  concurrent write will create a hole writing out the extents,\n\t *  and we cannot proceed on a zoned filesystem, requiring\n\t *  sequential writing. While we can bail out to a full commit\n\t *  here, but we can continue hoping the concurrent writing fills\n\t *  the hole.\n\t */\n\tif (ret == -EAGAIN && btrfs_is_zoned(fs_info))\n\t\tret = 0;\n\tif (ret) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tmutex_unlock(&root->log_mutex);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We _must_ update under the root->log_mutex in order to make sure we\n\t * have a consistent view of the log root we are trying to commit at\n\t * this moment.\n\t *\n\t * We _must_ copy this into a local copy, because we are not holding the\n\t * log_root_tree->log_mutex yet.  This is important because when we\n\t * commit the log_root_tree we must have a consistent view of the\n\t * log_root_tree when we update the super block to point at the\n\t * log_root_tree bytenr.  If we update the log_root_tree here we'll race\n\t * with the commit and possibly point at the new block which we may not\n\t * have written out.\n\t */\n\tbtrfs_set_root_node(&log->root_item, log->node);\n\tmemcpy(&new_root_item, &log->root_item, sizeof(new_root_item));\n\n\troot->log_transid++;\n\tlog->log_transid = root->log_transid;\n\troot->log_start_pid = 0;\n\t/*\n\t * IO has been started, blocks of the log tree have WRITTEN flag set\n\t * in their headers. new modifications of the log will be written to\n\t * new positions. so it's safe to allow log writers to go in.\n\t */\n\tmutex_unlock(&root->log_mutex);\n\n\tbtrfs_init_log_ctx(&root_log_ctx, NULL);\n\n\tmutex_lock(&log_root_tree->log_mutex);\n\n\tif (btrfs_is_zoned(fs_info)) {\n\t\tif (!log_root_tree->node) {\n\t\t\tret = btrfs_alloc_log_tree_node(trans, log_root_tree);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tindex2 = log_root_tree->log_transid % 2;\n\tlist_add_tail(&root_log_ctx.list, &log_root_tree->log_ctxs[index2]);\n\troot_log_ctx.log_transid = log_root_tree->log_transid;\n\n\t/*\n\t * Now we are safe to update the log_root_tree because we're under the\n\t * log_mutex, and we're a current writer so we're holding the commit\n\t * open until we drop the log_mutex.\n\t */\n\tret = update_log_root(trans, log, &new_root_item);\n\tif (ret) {\n\t\tif (!list_empty(&root_log_ctx.list))\n\t\t\tlist_del_init(&root_log_ctx.list);\n\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_set_log_full_commit(trans);\n\n\t\tif (ret != -ENOSPC) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (log_root_tree->log_transid_committed >= root_log_ctx.log_transid) {\n\t\tblk_finish_plug(&plug);\n\t\tlist_del_init(&root_log_ctx.list);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\n\tindex2 = root_log_ctx.log_transid % 2;\n\tif (atomic_read(&log_root_tree->log_commit[index2])) {\n\t\tblk_finish_plug(&plug);\n\t\tret = btrfs_wait_tree_log_extents(log, mark);\n\t\twait_log_commit(log_root_tree,\n\t\t\t\troot_log_ctx.log_transid);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tif (!ret)\n\t\t\tret = root_log_ctx.log_ret;\n\t\tgoto out;\n\t}\n\tASSERT(root_log_ctx.log_transid == log_root_tree->log_transid);\n\tatomic_set(&log_root_tree->log_commit[index2], 1);\n\n\tif (atomic_read(&log_root_tree->log_commit[(index2 + 1) % 2])) {\n\t\twait_log_commit(log_root_tree,\n\t\t\t\troot_log_ctx.log_transid - 1);\n\t}\n\n\t/*\n\t * now that we've moved on to the tree of log tree roots,\n\t * check the full commit flag again\n\t */\n\tif (btrfs_need_log_full_commit(trans)) {\n\t\tblk_finish_plug(&plug);\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tret = -EAGAIN;\n\t\tgoto out_wake_log_root;\n\t}\n\n\tret = btrfs_write_marked_extents(fs_info,\n\t\t\t\t\t &log_root_tree->dirty_log_pages,\n\t\t\t\t\t EXTENT_DIRTY | EXTENT_NEW);\n\tblk_finish_plug(&plug);\n\t/*\n\t * As described above, -EAGAIN indicates a hole in the extents. We\n\t * cannot wait for these write outs since the waiting cause a\n\t * deadlock. Bail out to the full commit instead.\n\t */\n\tif (ret == -EAGAIN && btrfs_is_zoned(fs_info)) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tbtrfs_wait_tree_log_extents(log, mark);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t} else if (ret) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\tret = btrfs_wait_tree_log_extents(log, mark);\n\tif (!ret)\n\t\tret = btrfs_wait_tree_log_extents(log_root_tree,\n\t\t\t\t\t\t  EXTENT_NEW | EXTENT_DIRTY);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tmutex_unlock(&log_root_tree->log_mutex);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tlog_root_start = log_root_tree->node->start;\n\tlog_root_level = btrfs_header_level(log_root_tree->node);\n\tlog_root_tree->log_transid++;\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * Here we are guaranteed that nobody is going to write the superblock\n\t * for the current transaction before us and that neither we do write\n\t * our superblock before the previous transaction finishes its commit\n\t * and writes its superblock, because:\n\t *\n\t * 1) We are holding a handle on the current transaction, so no body\n\t *    can commit it until we release the handle;\n\t *\n\t * 2) Before writing our superblock we acquire the tree_log_mutex, so\n\t *    if the previous transaction is still committing, and hasn't yet\n\t *    written its superblock, we wait for it to do it, because a\n\t *    transaction commit acquires the tree_log_mutex when the commit\n\t *    begins and releases it only after writing its superblock.\n\t */\n\tmutex_lock(&fs_info->tree_log_mutex);\n\tbtrfs_set_super_log_root(fs_info->super_for_commit, log_root_start);\n\tbtrfs_set_super_log_root_level(fs_info->super_for_commit, log_root_level);\n\tret = write_all_supers(fs_info, 1);\n\tmutex_unlock(&fs_info->tree_log_mutex);\n\tif (ret) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_wake_log_root;\n\t}\n\n\tmutex_lock(&root->log_mutex);\n\tif (root->last_log_commit < log_transid)\n\t\troot->last_log_commit = log_transid;\n\tmutex_unlock(&root->log_mutex);\n\nout_wake_log_root:\n\tmutex_lock(&log_root_tree->log_mutex);\n\tbtrfs_remove_all_log_ctxs(log_root_tree, index2, ret);\n\n\tlog_root_tree->log_transid_committed++;\n\tatomic_set(&log_root_tree->log_commit[index2], 0);\n\tmutex_unlock(&log_root_tree->log_mutex);\n\n\t/*\n\t * The barrier before waitqueue_active (in cond_wake_up) is needed so\n\t * all the updates above are seen by the woken threads. It might not be\n\t * necessary, but proving that seems to be hard.\n\t */\n\tcond_wake_up(&log_root_tree->log_commit_wait[index2]);\nout:\n\tmutex_lock(&root->log_mutex);\n\tbtrfs_remove_all_log_ctxs(root, index1, ret);\n\troot->log_transid_committed++;\n\tatomic_set(&root->log_commit[index1], 0);\n\tmutex_unlock(&root->log_mutex);\n\n\t/*\n\t * The barrier before waitqueue_active (in cond_wake_up) is needed so\n\t * all the updates above are seen by the woken threads. It might not be\n\t * necessary, but proving that seems to be hard.\n\t */\n\tcond_wake_up(&root->log_commit_wait[index1]);\n\treturn ret;\n}\n\nstatic void free_log_tree(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log)\n{\n\tint ret;\n\tstruct walk_control wc = {\n\t\t.free = 1,\n\t\t.process_func = process_one_buffer\n\t};\n\n\tif (log->node) {\n\t\tret = walk_log_tree(trans, log, &wc);\n\t\tif (ret) {\n\t\t\tif (trans)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\telse\n\t\t\t\tbtrfs_handle_fs_error(log->fs_info, ret, NULL);\n\t\t}\n\t}\n\n\tclear_extent_bits(&log->dirty_log_pages, 0, (u64)-1,\n\t\t\t  EXTENT_DIRTY | EXTENT_NEW | EXTENT_NEED_WAIT);\n\textent_io_tree_release(&log->log_csum_range);\n\n\tif (trans && log->node)\n\t\tbtrfs_redirty_list_add(trans->transaction, log->node);\n\tbtrfs_put_root(log);\n}\n\n/*\n * free all the extents used by the tree log.  This should be called\n * at commit time of the full transaction\n */\nint btrfs_free_log(struct btrfs_trans_handle *trans, struct btrfs_root *root)\n{\n\tif (root->log_root) {\n\t\tfree_log_tree(trans, root->log_root);\n\t\troot->log_root = NULL;\n\t\tclear_bit(BTRFS_ROOT_HAS_LOG_TREE, &root->state);\n\t}\n\treturn 0;\n}\n\nint btrfs_free_log_root_tree(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->log_root_tree) {\n\t\tfree_log_tree(trans, fs_info->log_root_tree);\n\t\tfs_info->log_root_tree = NULL;\n\t\tclear_bit(BTRFS_ROOT_HAS_LOG_TREE, &fs_info->tree_root->state);\n\t}\n\treturn 0;\n}\n\n/*\n * Check if an inode was logged in the current transaction. We can't always rely\n * on an inode's logged_trans value, because it's an in-memory only field and\n * therefore not persisted. This means that its value is lost if the inode gets\n * evicted and loaded again from disk (in which case it has a value of 0, and\n * certainly it is smaller then any possible transaction ID), when that happens\n * the full_sync flag is set in the inode's runtime flags, so on that case we\n * assume eviction happened and ignore the logged_trans value, assuming the\n * worst case, that the inode was logged before in the current transaction.\n */\nstatic bool inode_logged(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_inode *inode)\n{\n\tif (inode->logged_trans == trans->transid)\n\t\treturn true;\n\n\tif (inode->last_trans == trans->transid &&\n\t    test_bit(BTRFS_INODE_NEEDS_FULL_SYNC, &inode->runtime_flags) &&\n\t    !test_bit(BTRFS_FS_LOG_RECOVERING, &trans->fs_info->flags))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * If both a file and directory are logged, and unlinks or renames are\n * mixed in, we have a few interesting corners:\n *\n * create file X in dir Y\n * link file X to X.link in dir Y\n * fsync file X\n * unlink file X but leave X.link\n * fsync dir Y\n *\n * After a crash we would expect only X.link to exist.  But file X\n * didn't get fsync'd again so the log has back refs for X and X.link.\n *\n * We solve this by removing directory entries and inode backrefs from the\n * log when a file that was logged in the current transaction is\n * unlinked.  Any later fsync will include the updated log entries, and\n * we'll be able to reconstruct the proper directory items from backrefs.\n *\n * This optimizations allows us to avoid relogging the entire inode\n * or the entire directory.\n */\nint btrfs_del_dir_entries_in_log(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t const char *name, int name_len,\n\t\t\t\t struct btrfs_inode *dir, u64 index)\n{\n\tstruct btrfs_root *log;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint err = 0;\n\tu64 dir_ino = btrfs_ino(dir);\n\n\tif (!inode_logged(trans, dir))\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\n\tmutex_lock(&dir->log_mutex);\n\n\tlog = root->log_root;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tdi = btrfs_lookup_dir_item(trans, log, path, dir_ino,\n\t\t\t\t   name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tdi = btrfs_lookup_dir_index_item(trans, log, path, dir_ino,\n\t\t\t\t\t index, name, name_len, -1);\n\tif (IS_ERR(di)) {\n\t\terr = PTR_ERR(di);\n\t\tgoto fail;\n\t}\n\tif (di) {\n\t\tret = btrfs_delete_one_dir_name(trans, log, path, di);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * We do not need to update the size field of the directory's inode item\n\t * because on log replay we update the field to reflect all existing\n\t * entries in the directory (see overwrite_item()).\n\t */\nfail:\n\tbtrfs_free_path(path);\nout_unlock:\n\tmutex_unlock(&dir->log_mutex);\n\tif (err == -ENOSPC) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\terr = 0;\n\t} else if (err < 0 && err != -ENOENT) {\n\t\t/* ENOENT can be returned if the entry hasn't been fsynced yet */\n\t\tbtrfs_abort_transaction(trans, err);\n\t}\n\n\tbtrfs_end_log_trans(root);\n\n\treturn err;\n}\n\n/* see comments for btrfs_del_dir_entries_in_log */\nint btrfs_del_inode_ref_in_log(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       const char *name, int name_len,\n\t\t\t       struct btrfs_inode *inode, u64 dirid)\n{\n\tstruct btrfs_root *log;\n\tu64 index;\n\tint ret;\n\n\tif (!inode_logged(trans, inode))\n\t\treturn 0;\n\n\tret = join_running_log_trans(root);\n\tif (ret)\n\t\treturn 0;\n\tlog = root->log_root;\n\tmutex_lock(&inode->log_mutex);\n\n\tret = btrfs_del_inode_ref(trans, log, name, name_len, btrfs_ino(inode),\n\t\t\t\t  dirid, &index);\n\tmutex_unlock(&inode->log_mutex);\n\tif (ret == -ENOSPC) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tret = 0;\n\t} else if (ret < 0 && ret != -ENOENT)\n\t\tbtrfs_abort_transaction(trans, ret);\n\tbtrfs_end_log_trans(root);\n\n\treturn ret;\n}\n\n/*\n * creates a range item in the log for 'dirid'.  first_offset and\n * last_offset tell us which parts of the key space the log should\n * be considered authoritative for.\n */\nstatic noinline int insert_dir_log_key(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *log,\n\t\t\t\t       struct btrfs_path *path,\n\t\t\t\t       int key_type, u64 dirid,\n\t\t\t\t       u64 first_offset, u64 last_offset)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_log_item *item;\n\n\tkey.objectid = dirid;\n\tkey.offset = first_offset;\n\tif (key_type == BTRFS_DIR_ITEM_KEY)\n\t\tkey.type = BTRFS_DIR_LOG_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_DIR_LOG_INDEX_KEY;\n\tret = btrfs_insert_empty_item(trans, log, path, &key, sizeof(*item));\n\tif (ret)\n\t\treturn ret;\n\n\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t      struct btrfs_dir_log_item);\n\tbtrfs_set_dir_log_end(path->nodes[0], item, last_offset);\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\n/*\n * log all the items included in the current transaction for a given\n * directory.  This also creates the range items in the log tree required\n * to replay anything deleted before the fsync\n */\nstatic noinline int log_dir_items(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct btrfs_inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path, int key_type,\n\t\t\t  struct btrfs_log_ctx *ctx,\n\t\t\t  u64 min_offset, u64 *last_offset_ret)\n{\n\tstruct btrfs_key min_key;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct extent_buffer *src;\n\tint err = 0;\n\tint ret;\n\tint i;\n\tint nritems;\n\tu64 first_offset = min_offset;\n\tu64 last_offset = (u64)-1;\n\tu64 ino = btrfs_ino(inode);\n\n\tlog = root->log_root;\n\n\tmin_key.objectid = ino;\n\tmin_key.type = key_type;\n\tmin_key.offset = min_offset;\n\n\tret = btrfs_search_forward(root, &min_key, path, trans->transid);\n\n\t/*\n\t * we didn't find anything from this transaction, see if there\n\t * is anything at all\n\t */\n\tif (ret != 0 || min_key.objectid != ino || min_key.type != key_type) {\n\t\tmin_key.objectid = ino;\n\t\tmin_key.type = key_type;\n\t\tmin_key.offset = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\treturn ret;\n\t\t}\n\t\tret = btrfs_previous_item(root, path, ino, key_type);\n\n\t\t/* if ret == 0 there are items for this type,\n\t\t * create a range to tell us the last key of this type.\n\t\t * otherwise, there are no items in this directory after\n\t\t * *min_offset, and we create a range to indicate that.\n\t\t */\n\t\tif (ret == 0) {\n\t\t\tstruct btrfs_key tmp;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key_type == tmp.type)\n\t\t\t\tfirst_offset = max(min_offset, tmp.offset) + 1;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* go backward to find any previous key */\n\tret = btrfs_previous_item(root, path, ino, key_type);\n\tif (ret == 0) {\n\t\tstruct btrfs_key tmp;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (key_type == tmp.type) {\n\t\t\tfirst_offset = tmp.offset;\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * Find the first key from this transaction again.  See the note for\n\t * log_new_dir_dentries, if we're logging a directory recursively we\n\t * won't be holding its i_mutex, which means we can modify the directory\n\t * while we're logging it.  If we remove an entry between our first\n\t * search and this search we'll not find the key again and can just\n\t * bail.\n\t */\nsearch:\n\tret = btrfs_search_slot(NULL, root, &min_key, path, 0, 0);\n\tif (ret != 0)\n\t\tgoto done;\n\n\t/*\n\t * we have a block from this transaction, log every item in it\n\t * from our directory\n\t */\n\twhile (1) {\n\t\tstruct btrfs_key tmp;\n\t\tsrc = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(src);\n\t\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\t\tstruct btrfs_dir_item *di;\n\n\t\t\tbtrfs_item_key_to_cpu(src, &min_key, i);\n\n\t\t\tif (min_key.objectid != ino || min_key.type != key_type)\n\t\t\t\tgoto done;\n\n\t\t\tif (need_resched()) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto search;\n\t\t\t}\n\n\t\t\tret = overwrite_item(trans, log, dst_path, src, i,\n\t\t\t\t\t     &min_key);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We must make sure that when we log a directory entry,\n\t\t\t * the corresponding inode, after log replay, has a\n\t\t\t * matching link count. For example:\n\t\t\t *\n\t\t\t * touch foo\n\t\t\t * mkdir mydir\n\t\t\t * sync\n\t\t\t * ln foo mydir/bar\n\t\t\t * xfs_io -c \"fsync\" mydir\n\t\t\t * <crash>\n\t\t\t * <mount fs and log replay>\n\t\t\t *\n\t\t\t * Would result in a fsync log that when replayed, our\n\t\t\t * file inode would have a link count of 1, but we get\n\t\t\t * two directory entries pointing to the same inode.\n\t\t\t * After removing one of the names, it would not be\n\t\t\t * possible to remove the other name, which resulted\n\t\t\t * always in stale file handle errors, and would not\n\t\t\t * be possible to rmdir the parent directory, since\n\t\t\t * its i_size could never decrement to the value\n\t\t\t * BTRFS_EMPTY_DIR_SIZE, resulting in -ENOTEMPTY errors.\n\t\t\t */\n\t\t\tdi = btrfs_item_ptr(src, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(src, di, &tmp);\n\t\t\tif (ctx &&\n\t\t\t    (btrfs_dir_transid(src, di) == trans->transid ||\n\t\t\t     btrfs_dir_type(src, di) == BTRFS_FT_DIR) &&\n\t\t\t    tmp.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\t\tctx->log_new_dentries = true;\n\t\t}\n\t\tpath->slots[0] = nritems;\n\n\t\t/*\n\t\t * look ahead to the next item and see if it is also\n\t\t * from this directory and from this transaction\n\t\t */\n\t\tret = btrfs_next_leaf(root, path);\n\t\tif (ret) {\n\t\t\tif (ret == 1)\n\t\t\t\tlast_offset = (u64)-1;\n\t\t\telse\n\t\t\t\terr = ret;\n\t\t\tgoto done;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &tmp, path->slots[0]);\n\t\tif (tmp.objectid != ino || tmp.type != key_type) {\n\t\t\tlast_offset = (u64)-1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (btrfs_header_generation(path->nodes[0]) != trans->transid) {\n\t\t\tret = overwrite_item(trans, log, dst_path,\n\t\t\t\t\t     path->nodes[0], path->slots[0],\n\t\t\t\t\t     &tmp);\n\t\t\tif (ret)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tlast_offset = tmp.offset;\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\n\tif (err == 0) {\n\t\t*last_offset_ret = last_offset;\n\t\t/*\n\t\t * insert the log range keys to indicate where the log\n\t\t * is valid\n\t\t */\n\t\tret = insert_dir_log_key(trans, log, path, key_type,\n\t\t\t\t\t ino, first_offset, last_offset);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}\n\n/*\n * logging directories is very similar to logging inodes, We find all the items\n * from the current transaction and write them to the log.\n *\n * The recovery code scans the directory in the subvolume, and if it finds a\n * key in the range logged that is not present in the log tree, then it means\n * that dir entry was unlinked during the transaction.\n *\n * In order for that scan to work, we must include one key smaller than\n * the smallest logged by this transaction and one key larger than the largest\n * key logged by this transaction.\n */\nstatic noinline int log_directory_changes(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct btrfs_inode *inode,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_path *dst_path,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tu64 min_key;\n\tu64 max_key;\n\tint ret;\n\tint key_type = BTRFS_DIR_ITEM_KEY;\n\nagain:\n\tmin_key = 0;\n\tmax_key = 0;\n\twhile (1) {\n\t\tret = log_dir_items(trans, root, inode, path, dst_path, key_type,\n\t\t\t\tctx, min_key, &max_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (max_key == (u64)-1)\n\t\t\tbreak;\n\t\tmin_key = max_key + 1;\n\t}\n\n\tif (key_type == BTRFS_DIR_ITEM_KEY) {\n\t\tkey_type = BTRFS_DIR_INDEX_KEY;\n\t\tgoto again;\n\t}\n\treturn 0;\n}\n\n/*\n * a helper function to drop items from the log before we relog an\n * inode.  max_key_type indicates the highest item type to remove.\n * This cannot be run for file data extents because it does not\n * free the extents they point to.\n */\nstatic int drop_objectid_items(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *log,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  u64 objectid, int max_key_type)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tint start_slot;\n\n\tkey.objectid = objectid;\n\tkey.type = max_key_type;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, log, &key, path, -1, 1);\n\t\tBUG_ON(ret == 0); /* Logic error */\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (path->slots[0] == 0)\n\t\t\tbreak;\n\n\t\tpath->slots[0]--;\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\n\t\tif (found_key.objectid != objectid)\n\t\t\tbreak;\n\n\t\tfound_key.offset = 0;\n\t\tfound_key.type = 0;\n\t\tret = btrfs_bin_search(path->nodes[0], &found_key, &start_slot);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = btrfs_del_items(trans, log, path, start_slot,\n\t\t\t\t      path->slots[0] - start_slot + 1);\n\t\t/*\n\t\t * If start slot isn't 0 then we don't need to re-search, we've\n\t\t * found the last guy with the objectid in this tree.\n\t\t */\n\t\tif (ret || start_slot != 0)\n\t\t\tbreak;\n\t\tbtrfs_release_path(path);\n\t}\n\tbtrfs_release_path(path);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token, leaf);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(&token, item, 0);\n\t\tbtrfs_set_token_inode_size(&token, item, logged_isize);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(&token, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation);\n\t\tbtrfs_set_token_inode_size(&token, item, inode->i_size);\n\t}\n\n\tbtrfs_set_token_inode_uid(&token, item, i_uid_read(inode));\n\tbtrfs_set_token_inode_gid(&token, item, i_gid_read(inode));\n\tbtrfs_set_token_inode_mode(&token, item, inode->i_mode);\n\tbtrfs_set_token_inode_nlink(&token, item, inode->i_nlink);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec);\n\n\tbtrfs_set_token_timespec_sec(&token, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec);\n\tbtrfs_set_token_timespec_nsec(&token, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec);\n\n\t/*\n\t * We do not need to set the nbytes field, in fact during a fast fsync\n\t * its value may not even be correct, since a fast fsync does not wait\n\t * for ordered extent completion, which is where we update nbytes, it\n\t * only waits for writeback to complete. During log replay as we find\n\t * file extent items and replay them, we adjust the nbytes field of the\n\t * inode item in subvolume tree as needed (see overwrite_item()).\n\t */\n\n\tbtrfs_set_token_inode_sequence(&token, item, inode_peek_iversion(inode));\n\tbtrfs_set_token_inode_transid(&token, item, trans->transid);\n\tbtrfs_set_token_inode_rdev(&token, item, inode->i_rdev);\n\tbtrfs_set_token_inode_flags(&token, item, BTRFS_I(inode)->flags);\n\tbtrfs_set_token_inode_block_group(&token, item, 0);\n}\n\nstatic int log_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *log, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode *inode)\n{\n\tstruct btrfs_inode_item *inode_item;\n\tint ret;\n\n\tret = btrfs_insert_empty_item(trans, log, path,\n\t\t\t\t      &inode->location, sizeof(*inode_item));\n\tif (ret && ret != -EEXIST)\n\t\treturn ret;\n\tinode_item = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_inode_item);\n\tfill_inode_item(trans, path->nodes[0], inode_item, &inode->vfs_inode,\n\t\t\t0, 0);\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\nstatic int log_csums(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_inode *inode,\n\t\t     struct btrfs_root *log_root,\n\t\t     struct btrfs_ordered_sum *sums)\n{\n\tconst u64 lock_end = sums->bytenr + sums->len - 1;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\n\t/*\n\t * If this inode was not used for reflink operations in the current\n\t * transaction with new extents, then do the fast path, no need to\n\t * worry about logging checksum items with overlapping ranges.\n\t */\n\tif (inode->last_reflink_trans < trans->transid)\n\t\treturn btrfs_csum_file_blocks(trans, log_root, sums);\n\n\t/*\n\t * Serialize logging for checksums. This is to avoid racing with the\n\t * same checksum being logged by another task that is logging another\n\t * file which happens to refer to the same extent as well. Such races\n\t * can leave checksum items in the log with overlapping ranges.\n\t */\n\tret = lock_extent_bits(&log_root->log_csum_range, sums->bytenr,\n\t\t\t       lock_end, &cached_state);\n\tif (ret)\n\t\treturn ret;\n\t/*\n\t * Due to extent cloning, we might have logged a csum item that covers a\n\t * subrange of a cloned extent, and later we can end up logging a csum\n\t * item for a larger subrange of the same extent or the entire range.\n\t * This would leave csum items in the log tree that cover the same range\n\t * and break the searches for checksums in the log tree, resulting in\n\t * some checksums missing in the fs/subvolume tree. So just delete (or\n\t * trim and adjust) any existing csum items in the log for this range.\n\t */\n\tret = btrfs_del_csums(trans, log_root, sums->bytenr, sums->len);\n\tif (!ret)\n\t\tret = btrfs_csum_file_blocks(trans, log_root, sums);\n\n\tunlock_extent_cached(&log_root->log_csum_range, sums->bytenr, lock_end,\n\t\t\t     &cached_state);\n\n\treturn ret;\n}\n\nstatic noinline int copy_items(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_inode *inode,\n\t\t\t       struct btrfs_path *dst_path,\n\t\t\t       struct btrfs_path *src_path,\n\t\t\t       int start_slot, int nr, int inode_only,\n\t\t\t       u64 logged_isize)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tunsigned long src_offset;\n\tunsigned long dst_offset;\n\tstruct btrfs_root *log = inode->root->log_root;\n\tstruct btrfs_file_extent_item *extent;\n\tstruct btrfs_inode_item *inode_item;\n\tstruct extent_buffer *src = src_path->nodes[0];\n\tint ret;\n\tstruct btrfs_key *ins_keys;\n\tu32 *ins_sizes;\n\tchar *ins_data;\n\tint i;\n\tstruct list_head ordered_sums;\n\tint skip_csum = inode->flags & BTRFS_INODE_NODATASUM;\n\n\tINIT_LIST_HEAD(&ordered_sums);\n\n\tins_data = kmalloc(nr * sizeof(struct btrfs_key) +\n\t\t\t   nr * sizeof(u32), GFP_NOFS);\n\tif (!ins_data)\n\t\treturn -ENOMEM;\n\n\tins_sizes = (u32 *)ins_data;\n\tins_keys = (struct btrfs_key *)(ins_data + nr * sizeof(u32));\n\n\tfor (i = 0; i < nr; i++) {\n\t\tins_sizes[i] = btrfs_item_size_nr(src, i + start_slot);\n\t\tbtrfs_item_key_to_cpu(src, ins_keys + i, i + start_slot);\n\t}\n\tret = btrfs_insert_empty_items(trans, log, dst_path,\n\t\t\t\t       ins_keys, ins_sizes, nr);\n\tif (ret) {\n\t\tkfree(ins_data);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < nr; i++, dst_path->slots[0]++) {\n\t\tdst_offset = btrfs_item_ptr_offset(dst_path->nodes[0],\n\t\t\t\t\t\t   dst_path->slots[0]);\n\n\t\tsrc_offset = btrfs_item_ptr_offset(src, start_slot + i);\n\n\t\tif (ins_keys[i].type == BTRFS_INODE_ITEM_KEY) {\n\t\t\tinode_item = btrfs_item_ptr(dst_path->nodes[0],\n\t\t\t\t\t\t    dst_path->slots[0],\n\t\t\t\t\t\t    struct btrfs_inode_item);\n\t\t\tfill_inode_item(trans, dst_path->nodes[0], inode_item,\n\t\t\t\t\t&inode->vfs_inode,\n\t\t\t\t\tinode_only == LOG_INODE_EXISTS,\n\t\t\t\t\tlogged_isize);\n\t\t} else {\n\t\t\tcopy_extent_buffer(dst_path->nodes[0], src, dst_offset,\n\t\t\t\t\t   src_offset, ins_sizes[i]);\n\t\t}\n\n\t\t/* take a reference on file data extents so that truncates\n\t\t * or deletes of this inode don't have to relog the inode\n\t\t * again\n\t\t */\n\t\tif (ins_keys[i].type == BTRFS_EXTENT_DATA_KEY &&\n\t\t    !skip_csum) {\n\t\t\tint found_type;\n\t\t\textent = btrfs_item_ptr(src, start_slot + i,\n\t\t\t\t\t\tstruct btrfs_file_extent_item);\n\n\t\t\tif (btrfs_file_extent_generation(src, extent) < trans->transid)\n\t\t\t\tcontinue;\n\n\t\t\tfound_type = btrfs_file_extent_type(src, extent);\n\t\t\tif (found_type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t\tu64 ds, dl, cs, cl;\n\t\t\t\tds = btrfs_file_extent_disk_bytenr(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\t/* ds == 0 is a hole */\n\t\t\t\tif (ds == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdl = btrfs_file_extent_disk_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tcs = btrfs_file_extent_offset(src, extent);\n\t\t\t\tcl = btrfs_file_extent_num_bytes(src,\n\t\t\t\t\t\t\t\textent);\n\t\t\t\tif (btrfs_file_extent_compression(src,\n\t\t\t\t\t\t\t\t  extent)) {\n\t\t\t\t\tcs = 0;\n\t\t\t\t\tcl = dl;\n\t\t\t\t}\n\n\t\t\t\tret = btrfs_lookup_csums_range(\n\t\t\t\t\t\tfs_info->csum_root,\n\t\t\t\t\t\tds + cs, ds + cs + cl - 1,\n\t\t\t\t\t\t&ordered_sums, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbtrfs_mark_buffer_dirty(dst_path->nodes[0]);\n\tbtrfs_release_path(dst_path);\n\tkfree(ins_data);\n\n\t/*\n\t * we have to do this after the loop above to avoid changing the\n\t * log tree while trying to change the log tree.\n\t */\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = log_csums(trans, inode, log, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}\n\nstatic int extent_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct extent_map *em1, *em2;\n\n\tem1 = list_entry(a, struct extent_map, list);\n\tem2 = list_entry(b, struct extent_map, list);\n\n\tif (em1->start < em2->start)\n\t\treturn -1;\n\telse if (em1->start > em2->start)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int log_extent_csums(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_inode *inode,\n\t\t\t    struct btrfs_root *log_root,\n\t\t\t    const struct extent_map *em,\n\t\t\t    struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 csum_offset;\n\tu64 csum_len;\n\tu64 mod_start = em->mod_start;\n\tu64 mod_len = em->mod_len;\n\tLIST_HEAD(ordered_sums);\n\tint ret = 0;\n\n\tif (inode->flags & BTRFS_INODE_NODATASUM ||\n\t    test_bit(EXTENT_FLAG_PREALLOC, &em->flags) ||\n\t    em->block_start == EXTENT_MAP_HOLE)\n\t\treturn 0;\n\n\tlist_for_each_entry(ordered, &ctx->ordered_extents, log_list) {\n\t\tconst u64 ordered_end = ordered->file_offset + ordered->num_bytes;\n\t\tconst u64 mod_end = mod_start + mod_len;\n\t\tstruct btrfs_ordered_sum *sums;\n\n\t\tif (mod_len == 0)\n\t\t\tbreak;\n\n\t\tif (ordered_end <= mod_start)\n\t\t\tcontinue;\n\t\tif (mod_end <= ordered->file_offset)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We are going to copy all the csums on this ordered extent, so\n\t\t * go ahead and adjust mod_start and mod_len in case this ordered\n\t\t * extent has already been logged.\n\t\t */\n\t\tif (ordered->file_offset > mod_start) {\n\t\t\tif (ordered_end >= mod_end)\n\t\t\t\tmod_len = ordered->file_offset - mod_start;\n\t\t\t/*\n\t\t\t * If we have this case\n\t\t\t *\n\t\t\t * |--------- logged extent ---------|\n\t\t\t *       |----- ordered extent ----|\n\t\t\t *\n\t\t\t * Just don't mess with mod_start and mod_len, we'll\n\t\t\t * just end up logging more csums than we need and it\n\t\t\t * will be ok.\n\t\t\t */\n\t\t} else {\n\t\t\tif (ordered_end < mod_end) {\n\t\t\t\tmod_len = mod_end - ordered_end;\n\t\t\t\tmod_start = ordered_end;\n\t\t\t} else {\n\t\t\t\tmod_len = 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * To keep us from looping for the above case of an ordered\n\t\t * extent that falls inside of the logged extent.\n\t\t */\n\t\tif (test_and_set_bit(BTRFS_ORDERED_LOGGED_CSUM, &ordered->flags))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(sums, &ordered->list, list) {\n\t\t\tret = log_csums(trans, inode, log_root, sums);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* We're done, found all csums in the ordered extents. */\n\tif (mod_len == 0)\n\t\treturn 0;\n\n\t/* If we're compressed we have to save the entire range of csums. */\n\tif (em->compress_type) {\n\t\tcsum_offset = 0;\n\t\tcsum_len = max(em->block_len, em->orig_block_len);\n\t} else {\n\t\tcsum_offset = mod_start - em->start;\n\t\tcsum_len = mod_len;\n\t}\n\n\t/* block start is already adjusted for the file extent offset. */\n\tret = btrfs_lookup_csums_range(trans->fs_info->csum_root,\n\t\t\t\t       em->block_start + csum_offset,\n\t\t\t\t       em->block_start + csum_offset +\n\t\t\t\t       csum_len - 1, &ordered_sums, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(&ordered_sums)) {\n\t\tstruct btrfs_ordered_sum *sums = list_entry(ordered_sums.next,\n\t\t\t\t\t\t   struct btrfs_ordered_sum,\n\t\t\t\t\t\t   list);\n\t\tif (!ret)\n\t\t\tret = log_csums(trans, inode, log_root, sums);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\n\treturn ret;\n}\n\nstatic int log_one_extent(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_inode *inode, struct btrfs_root *root,\n\t\t\t  const struct extent_map *em,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_drop_extents_args drop_args = { 0 };\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_map_token token;\n\tstruct btrfs_key key;\n\tu64 extent_offset = em->start - em->orig_start;\n\tu64 block_len;\n\tint ret;\n\n\tret = log_extent_csums(trans, inode, log, em, ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tdrop_args.path = path;\n\tdrop_args.start = em->start;\n\tdrop_args.end = em->start + em->len;\n\tdrop_args.replace_extent = true;\n\tdrop_args.extent_item_size = sizeof(*fi);\n\tret = btrfs_drop_extents(trans, log, inode, &drop_args);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!drop_args.extent_inserted) {\n\t\tkey.objectid = btrfs_ino(inode);\n\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\tkey.offset = em->start;\n\n\t\tret = btrfs_insert_empty_item(trans, log, path, &key,\n\t\t\t\t\t      sizeof(*fi));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tleaf = path->nodes[0];\n\tbtrfs_init_map_token(&token, leaf);\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tbtrfs_set_token_file_extent_generation(&token, fi, trans->transid);\n\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\tbtrfs_set_token_file_extent_type(&token, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_PREALLOC);\n\telse\n\t\tbtrfs_set_token_file_extent_type(&token, fi,\n\t\t\t\t\t\t BTRFS_FILE_EXTENT_REG);\n\n\tblock_len = max(em->block_len, em->orig_block_len);\n\tif (em->compress_type != BTRFS_COMPRESS_NONE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(&token, fi,\n\t\t\t\t\t\t\tem->block_start);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(&token, fi, block_len);\n\t} else if (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(&token, fi,\n\t\t\t\t\t\t\tem->block_start -\n\t\t\t\t\t\t\textent_offset);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(&token, fi, block_len);\n\t} else {\n\t\tbtrfs_set_token_file_extent_disk_bytenr(&token, fi, 0);\n\t\tbtrfs_set_token_file_extent_disk_num_bytes(&token, fi, 0);\n\t}\n\n\tbtrfs_set_token_file_extent_offset(&token, fi, extent_offset);\n\tbtrfs_set_token_file_extent_num_bytes(&token, fi, em->len);\n\tbtrfs_set_token_file_extent_ram_bytes(&token, fi, em->ram_bytes);\n\tbtrfs_set_token_file_extent_compression(&token, fi, em->compress_type);\n\tbtrfs_set_token_file_extent_encryption(&token, fi, 0);\n\tbtrfs_set_token_file_extent_other_encoding(&token, fi, 0);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}\n\n/*\n * Log all prealloc extents beyond the inode's i_size to make sure we do not\n * lose them after doing a fast fsync and replaying the log. We scan the\n * subvolume's root instead of iterating the inode's extent map tree because\n * otherwise we can log incorrect extent items based on extent map conversion.\n * That can happen due to the fact that extent maps are merged when they\n * are not in the extent map tree's list of modified extents.\n */\nstatic int btrfs_log_prealloc_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_inode *inode,\n\t\t\t\t      struct btrfs_path *path)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_key key;\n\tconst u64 i_size = i_size_read(&inode->vfs_inode);\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_path *dst_path = NULL;\n\tbool dropped_extents = false;\n\tu64 truncate_offset = i_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tint ins_nr = 0;\n\tint start_slot;\n\tint ret;\n\n\tif (!(inode->flags & BTRFS_INODE_PREALLOC))\n\t\treturn 0;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = i_size;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We must check if there is a prealloc extent that starts before the\n\t * i_size and crosses the i_size boundary. This is to ensure later we\n\t * truncate down to the end of that extent and not to the i_size, as\n\t * otherwise we end up losing part of the prealloc extent after a log\n\t * replay and with an implicit hole if there is another prealloc extent\n\t * that starts at an offset beyond i_size.\n\t */\n\tret = btrfs_previous_item(root, path, ino, BTRFS_EXTENT_DATA_KEY);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == 0) {\n\t\tstruct btrfs_file_extent_item *ei;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tei = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\t\tif (btrfs_file_extent_type(leaf, ei) ==\n\t\t    BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\tu64 extent_end;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\t\textent_end = key.offset +\n\t\t\t\tbtrfs_file_extent_num_bytes(leaf, ei);\n\n\t\t\tif (extent_end > i_size)\n\t\t\t\ttruncate_offset = extent_end;\n\t\t}\n\t} else {\n\t\tret = 0;\n\t}\n\n\twhile (true) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tif (ins_nr > 0) {\n\t\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t\t start_slot, ins_nr, 1, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tins_nr = 0;\n\t\t\t}\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid > ino)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(key.objectid < ino) ||\n\t\t    key.type < BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.offset < i_size) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dropped_extents) {\n\t\t\t/*\n\t\t\t * Avoid logging extent items logged in past fsync calls\n\t\t\t * and leading to duplicate keys in the log tree.\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tret = btrfs_truncate_inode_items(trans,\n\t\t\t\t\t\t\t root->log_root,\n\t\t\t\t\t\t\t inode, truncate_offset,\n\t\t\t\t\t\t\t BTRFS_EXTENT_DATA_KEY);\n\t\t\t} while (ret == -EAGAIN);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tdropped_extents = true;\n\t\t}\n\t\tif (ins_nr == 0)\n\t\t\tstart_slot = slot;\n\t\tins_nr++;\n\t\tpath->slots[0]++;\n\t\tif (!dst_path) {\n\t\t\tdst_path = btrfs_alloc_path();\n\t\t\tif (!dst_path) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tif (ins_nr > 0)\n\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t start_slot, ins_nr, 1, 0);\nout:\n\tbtrfs_release_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn ret;\n}\n\nstatic int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_inode *inode,\n\t\t\t\t     struct btrfs_path *path,\n\t\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_ordered_extent *tmp;\n\tstruct extent_map *em, *n;\n\tstruct list_head extents;\n\tstruct extent_map_tree *tree = &inode->extent_tree;\n\tint ret = 0;\n\tint num = 0;\n\n\tINIT_LIST_HEAD(&extents);\n\n\twrite_lock(&tree->lock);\n\n\tlist_for_each_entry_safe(em, n, &tree->modified_extents, list) {\n\t\tlist_del_init(&em->list);\n\t\t/*\n\t\t * Just an arbitrary number, this can be really CPU intensive\n\t\t * once we start getting a lot of extents, and really once we\n\t\t * have a bunch of extents we just want to commit since it will\n\t\t * be faster.\n\t\t */\n\t\tif (++num > 32768) {\n\t\t\tlist_del_init(&tree->modified_extents);\n\t\t\tret = -EFBIG;\n\t\t\tgoto process;\n\t\t}\n\n\t\tif (em->generation < trans->transid)\n\t\t\tcontinue;\n\n\t\t/* We log prealloc extents beyond eof later. */\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags) &&\n\t\t    em->start >= i_size_read(&inode->vfs_inode))\n\t\t\tcontinue;\n\n\t\t/* Need a ref to keep it from getting evicted from cache */\n\t\trefcount_inc(&em->refs);\n\t\tset_bit(EXTENT_FLAG_LOGGING, &em->flags);\n\t\tlist_add_tail(&em->list, &extents);\n\t\tnum++;\n\t}\n\n\tlist_sort(NULL, &extents, extent_cmp);\nprocess:\n\twhile (!list_empty(&extents)) {\n\t\tem = list_entry(extents.next, struct extent_map, list);\n\n\t\tlist_del_init(&em->list);\n\n\t\t/*\n\t\t * If we had an error we just need to delete everybody from our\n\t\t * private list.\n\t\t */\n\t\tif (ret) {\n\t\t\tclear_em_logging(tree, em);\n\t\t\tfree_extent_map(em);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite_unlock(&tree->lock);\n\n\t\tret = log_one_extent(trans, inode, root, em, path, ctx);\n\t\twrite_lock(&tree->lock);\n\t\tclear_em_logging(tree, em);\n\t\tfree_extent_map(em);\n\t}\n\tWARN_ON(!list_empty(&extents));\n\twrite_unlock(&tree->lock);\n\n\tbtrfs_release_path(path);\n\tif (!ret)\n\t\tret = btrfs_log_prealloc_extents(trans, inode, path);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * We have logged all extents successfully, now make sure the commit of\n\t * the current transaction waits for the ordered extents to complete\n\t * before it commits and wipes out the log trees, otherwise we would\n\t * lose data if an ordered extents completes after the transaction\n\t * commits and a power failure happens after the transaction commit.\n\t */\n\tlist_for_each_entry_safe(ordered, tmp, &ctx->ordered_extents, log_list) {\n\t\tlist_del_init(&ordered->log_list);\n\t\tset_bit(BTRFS_ORDERED_LOGGED, &ordered->flags);\n\n\t\tif (!test_bit(BTRFS_ORDERED_COMPLETE, &ordered->flags)) {\n\t\t\tspin_lock_irq(&inode->ordered_tree.lock);\n\t\t\tif (!test_bit(BTRFS_ORDERED_COMPLETE, &ordered->flags)) {\n\t\t\t\tset_bit(BTRFS_ORDERED_PENDING, &ordered->flags);\n\t\t\t\tatomic_inc(&trans->transaction->pending_ordered);\n\t\t\t}\n\t\t\tspin_unlock_irq(&inode->ordered_tree.lock);\n\t\t}\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\treturn 0;\n}\n\nstatic int logged_inode_size(struct btrfs_root *log, struct btrfs_inode *inode,\n\t\t\t     struct btrfs_path *path, u64 *size_ret)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, log, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*size_ret = 0;\n\t} else {\n\t\tstruct btrfs_inode_item *item;\n\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_item);\n\t\t*size_ret = btrfs_inode_size(path->nodes[0], item);\n\t\t/*\n\t\t * If the in-memory inode's i_size is smaller then the inode\n\t\t * size stored in the btree, return the inode's i_size, so\n\t\t * that we get a correct inode size after replaying the log\n\t\t * when before a power failure we had a shrinking truncate\n\t\t * followed by addition of a new name (rename / new hard link).\n\t\t * Otherwise return the inode size from the btree, to avoid\n\t\t * data loss when replaying a log due to previously doing a\n\t\t * write that expands the inode's size and logging a new name\n\t\t * immediately after.\n\t\t */\n\t\tif (*size_ret > inode->vfs_inode.i_size)\n\t\t\t*size_ret = inode->vfs_inode.i_size;\n\t}\n\n\tbtrfs_release_path(path);\n\treturn 0;\n}\n\n/*\n * At the moment we always log all xattrs. This is to figure out at log replay\n * time which xattrs must have their deletion replayed. If a xattr is missing\n * in the log tree and exists in the fs/subvol tree, we delete it. This is\n * because if a xattr is deleted, the inode is fsynced and a power failure\n * happens, causing the log to be replayed the next time the fs is mounted,\n * we want the xattr to not exist anymore (same behaviour as other filesystems\n * with a journal, ext3/4, xfs, f2fs, etc).\n */\nstatic int btrfs_log_all_xattrs(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_inode *inode,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\tstruct btrfs_path *dst_path)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tconst u64 ino = btrfs_ino(inode);\n\tint ins_nr = 0;\n\tint start_slot = 0;\n\tbool found_xattrs = false;\n\n\tif (test_bit(BTRFS_INODE_NO_XATTRS, &inode->runtime_flags))\n\t\treturn 0;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (true) {\n\t\tint slot = path->slots[0];\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint nritems = btrfs_header_nritems(leaf);\n\n\t\tif (slot >= nritems) {\n\t\t\tif (ins_nr > 0) {\n\t\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t\t start_slot, ins_nr, 1, 0);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tins_nr = 0;\n\t\t\t}\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != ino || key.type != BTRFS_XATTR_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tif (ins_nr == 0)\n\t\t\tstart_slot = slot;\n\t\tins_nr++;\n\t\tpath->slots[0]++;\n\t\tfound_xattrs = true;\n\t\tcond_resched();\n\t}\n\tif (ins_nr > 0) {\n\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t start_slot, ins_nr, 1, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!found_xattrs)\n\t\tset_bit(BTRFS_INODE_NO_XATTRS, &inode->runtime_flags);\n\n\treturn 0;\n}\n\n/*\n * When using the NO_HOLES feature if we punched a hole that causes the\n * deletion of entire leafs or all the extent items of the first leaf (the one\n * that contains the inode item and references) we may end up not processing\n * any extents, because there are no leafs with a generation matching the\n * current transaction that have extent items for our inode. So we need to find\n * if any holes exist and then log them. We also need to log holes after any\n * truncate operation that changes the inode's size.\n */\nstatic int btrfs_log_holes(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_inode *inode,\n\t\t\t   struct btrfs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_key key;\n\tconst u64 ino = btrfs_ino(inode);\n\tconst u64 i_size = i_size_read(&inode->vfs_inode);\n\tu64 prev_extent_end = 0;\n\tint ret;\n\n\tif (!btrfs_fs_incompat(fs_info, NO_HOLES) || i_size == 0)\n\t\treturn 0;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\t/* We have a hole, log it. */\n\t\tif (prev_extent_end < key.offset) {\n\t\t\tconst u64 hole_len = key.offset - prev_extent_end;\n\n\t\t\t/*\n\t\t\t * Release the path to avoid deadlocks with other code\n\t\t\t * paths that search the root while holding locks on\n\t\t\t * leafs from the log root.\n\t\t\t */\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = btrfs_insert_file_extent(trans, root->log_root,\n\t\t\t\t\t\t       ino, prev_extent_end, 0,\n\t\t\t\t\t\t       0, hole_len, 0, hole_len,\n\t\t\t\t\t\t       0, 0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t/*\n\t\t\t * Search for the same key again in the root. Since it's\n\t\t\t * an extent item and we are holding the inode lock, the\n\t\t\t * key must still exist. If it doesn't just emit warning\n\t\t\t * and return an error to fall back to a transaction\n\t\t\t * commit.\n\t\t\t */\n\t\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (WARN_ON(ret > 0))\n\t\t\t\treturn -ENOENT;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tprev_extent_end = btrfs_file_extent_end(path);\n\t\tpath->slots[0]++;\n\t\tcond_resched();\n\t}\n\n\tif (prev_extent_end < i_size) {\n\t\tu64 hole_len;\n\n\t\tbtrfs_release_path(path);\n\t\thole_len = ALIGN(i_size - prev_extent_end, fs_info->sectorsize);\n\t\tret = btrfs_insert_file_extent(trans, root->log_root,\n\t\t\t\t\t       ino, prev_extent_end, 0, 0,\n\t\t\t\t\t       hole_len, 0, hole_len,\n\t\t\t\t\t       0, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/*\n * When we are logging a new inode X, check if it doesn't have a reference that\n * matches the reference from some other inode Y created in a past transaction\n * and that was renamed in the current transaction. If we don't do this, then at\n * log replay time we can lose inode Y (and all its files if it's a directory):\n *\n * mkdir /mnt/x\n * echo \"hello world\" > /mnt/x/foobar\n * sync\n * mv /mnt/x /mnt/y\n * mkdir /mnt/x                 # or touch /mnt/x\n * xfs_io -c fsync /mnt/x\n * <power fail>\n * mount fs, trigger log replay\n *\n * After the log replay procedure, we would lose the first directory and all its\n * files (file foobar).\n * For the case where inode Y is not a directory we simply end up losing it:\n *\n * echo \"123\" > /mnt/foo\n * sync\n * mv /mnt/foo /mnt/bar\n * echo \"abc\" > /mnt/foo\n * xfs_io -c fsync /mnt/foo\n * <power fail>\n *\n * We also need this for cases where a snapshot entry is replaced by some other\n * entry (file or directory) otherwise we end up with an unreplayable log due to\n * attempts to delete the snapshot entry (entry of type BTRFS_ROOT_ITEM_KEY) as\n * if it were a regular entry:\n *\n * mkdir /mnt/x\n * btrfs subvolume snapshot /mnt /mnt/x/snap\n * btrfs subvolume delete /mnt/x/snap\n * rmdir /mnt/x\n * mkdir /mnt/x\n * fsync /mnt/x or fsync some new file inside it\n * <power fail>\n *\n * The snapshot delete, rmdir of x, mkdir of a new x and the fsync all happen in\n * the same transaction.\n */\nstatic int btrfs_check_ref_name_override(struct extent_buffer *eb,\n\t\t\t\t\t const int slot,\n\t\t\t\t\t const struct btrfs_key *key,\n\t\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t\t u64 *other_ino, u64 *other_parent)\n{\n\tint ret;\n\tstruct btrfs_path *search_path;\n\tchar *name = NULL;\n\tu32 name_len = 0;\n\tu32 item_size = btrfs_item_size_nr(eb, slot);\n\tu32 cur_offset = 0;\n\tunsigned long ptr = btrfs_item_ptr_offset(eb, slot);\n\n\tsearch_path = btrfs_alloc_path();\n\tif (!search_path)\n\t\treturn -ENOMEM;\n\tsearch_path->search_commit_root = 1;\n\tsearch_path->skip_locking = 1;\n\n\twhile (cur_offset < item_size) {\n\t\tu64 parent;\n\t\tu32 this_name_len;\n\t\tu32 this_len;\n\t\tunsigned long name_ptr;\n\t\tstruct btrfs_dir_item *di;\n\n\t\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tstruct btrfs_inode_ref *iref;\n\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur_offset);\n\t\t\tparent = key->offset;\n\t\t\tthis_name_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_ptr = (unsigned long)(iref + 1);\n\t\t\tthis_len = sizeof(*iref) + this_name_len;\n\t\t} else {\n\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t\t       cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tthis_name_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_ptr = (unsigned long)&extref->name;\n\t\t\tthis_len = sizeof(*extref) + this_name_len;\n\t\t}\n\n\t\tif (this_name_len > name_len) {\n\t\t\tchar *new_name;\n\n\t\t\tnew_name = krealloc(name, this_name_len, GFP_NOFS);\n\t\t\tif (!new_name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tname_len = this_name_len;\n\t\t\tname = new_name;\n\t\t}\n\n\t\tread_extent_buffer(eb, name, name_ptr, this_name_len);\n\t\tdi = btrfs_lookup_dir_item(NULL, inode->root, search_path,\n\t\t\t\tparent, name, this_name_len, 0);\n\t\tif (di && !IS_ERR(di)) {\n\t\t\tstruct btrfs_key di_key;\n\n\t\t\tbtrfs_dir_item_key_to_cpu(search_path->nodes[0],\n\t\t\t\t\t\t  di, &di_key);\n\t\t\tif (di_key.type == BTRFS_INODE_ITEM_KEY) {\n\t\t\t\tif (di_key.objectid != key->objectid) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\t*other_ino = di_key.objectid;\n\t\t\t\t\t*other_parent = parent;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(search_path);\n\n\t\tcur_offset += this_len;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(search_path);\n\tkfree(name);\n\treturn ret;\n}\n\nstruct btrfs_ino_list {\n\tu64 ino;\n\tu64 parent;\n\tstruct list_head list;\n};\n\nstatic int log_conflicting_inodes(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_log_ctx *ctx,\n\t\t\t\t  u64 ino, u64 parent)\n{\n\tstruct btrfs_ino_list *ino_elem;\n\tLIST_HEAD(inode_list);\n\tint ret = 0;\n\n\tino_elem = kmalloc(sizeof(*ino_elem), GFP_NOFS);\n\tif (!ino_elem)\n\t\treturn -ENOMEM;\n\tino_elem->ino = ino;\n\tino_elem->parent = parent;\n\tlist_add_tail(&ino_elem->list, &inode_list);\n\n\twhile (!list_empty(&inode_list)) {\n\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\tstruct btrfs_key key;\n\t\tstruct inode *inode;\n\n\t\tino_elem = list_first_entry(&inode_list, struct btrfs_ino_list,\n\t\t\t\t\t    list);\n\t\tino = ino_elem->ino;\n\t\tparent = ino_elem->parent;\n\t\tlist_del(&ino_elem->list);\n\t\tkfree(ino_elem);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tbtrfs_release_path(path);\n\n\t\tinode = btrfs_iget(fs_info->sb, ino, root);\n\t\t/*\n\t\t * If the other inode that had a conflicting dir entry was\n\t\t * deleted in the current transaction, we need to log its parent\n\t\t * directory.\n\t\t */\n\t\tif (IS_ERR(inode)) {\n\t\t\tret = PTR_ERR(inode);\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tinode = btrfs_iget(fs_info->sb, parent, root);\n\t\t\t\tif (IS_ERR(inode)) {\n\t\t\t\t\tret = PTR_ERR(inode);\n\t\t\t\t} else {\n\t\t\t\t\tret = btrfs_log_inode(trans, root,\n\t\t\t\t\t\t      BTRFS_I(inode),\n\t\t\t\t\t\t      LOG_OTHER_INODE_ALL,\n\t\t\t\t\t\t      ctx);\n\t\t\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * If the inode was already logged skip it - otherwise we can\n\t\t * hit an infinite loop. Example:\n\t\t *\n\t\t * From the commit root (previous transaction) we have the\n\t\t * following inodes:\n\t\t *\n\t\t * inode 257 a directory\n\t\t * inode 258 with references \"zz\" and \"zz_link\" on inode 257\n\t\t * inode 259 with reference \"a\" on inode 257\n\t\t *\n\t\t * And in the current (uncommitted) transaction we have:\n\t\t *\n\t\t * inode 257 a directory, unchanged\n\t\t * inode 258 with references \"a\" and \"a2\" on inode 257\n\t\t * inode 259 with reference \"zz_link\" on inode 257\n\t\t * inode 261 with reference \"zz\" on inode 257\n\t\t *\n\t\t * When logging inode 261 the following infinite loop could\n\t\t * happen if we don't skip already logged inodes:\n\t\t *\n\t\t * - we detect inode 258 as a conflicting inode, with inode 261\n\t\t *   on reference \"zz\", and log it;\n\t\t *\n\t\t * - we detect inode 259 as a conflicting inode, with inode 258\n\t\t *   on reference \"a\", and log it;\n\t\t *\n\t\t * - we detect inode 258 as a conflicting inode, with inode 259\n\t\t *   on reference \"zz_link\", and log it - again! After this we\n\t\t *   repeat the above steps forever.\n\t\t */\n\t\tspin_lock(&BTRFS_I(inode)->lock);\n\t\t/*\n\t\t * Check the inode's logged_trans only instead of\n\t\t * btrfs_inode_in_log(). This is because the last_log_commit of\n\t\t * the inode is not updated when we only log that it exists and\n\t\t * it has the full sync bit set (see btrfs_log_inode()).\n\t\t */\n\t\tif (BTRFS_I(inode)->logged_trans == trans->transid) {\n\t\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&BTRFS_I(inode)->lock);\n\t\t/*\n\t\t * We are safe logging the other inode without acquiring its\n\t\t * lock as long as we log with the LOG_INODE_EXISTS mode. We\n\t\t * are safe against concurrent renames of the other inode as\n\t\t * well because during a rename we pin the log and update the\n\t\t * log with the new name before we unpin it.\n\t\t */\n\t\tret = btrfs_log_inode(trans, root, BTRFS_I(inode),\n\t\t\t\t      LOG_OTHER_INODE, ctx);\n\t\tif (ret) {\n\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey.objectid = ino;\n\t\tkey.type = BTRFS_INODE_REF_KEY;\n\t\tkey.offset = 0;\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\t\tint slot = path->slots[0];\n\t\t\tu64 other_ino = 0;\n\t\t\tu64 other_parent = 0;\n\n\t\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ret > 0) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\t\tif (key.objectid != ino ||\n\t\t\t    (key.type != BTRFS_INODE_REF_KEY &&\n\t\t\t     key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = btrfs_check_ref_name_override(leaf, slot, &key,\n\t\t\t\t\tBTRFS_I(inode), &other_ino,\n\t\t\t\t\t&other_parent);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0) {\n\t\t\t\tino_elem = kmalloc(sizeof(*ino_elem), GFP_NOFS);\n\t\t\t\tif (!ino_elem) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tino_elem->ino = other_ino;\n\t\t\t\tino_elem->parent = other_parent;\n\t\t\t\tlist_add_tail(&ino_elem->list, &inode_list);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tpath->slots[0]++;\n\t\t}\n\t\tbtrfs_add_delayed_iput(inode);\n\t}\n\n\treturn ret;\n}\n\nstatic int copy_inode_items_to_log(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_inode *inode,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   const struct btrfs_key *max_key,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_path *dst_path,\n\t\t\t\t   const u64 logged_isize,\n\t\t\t\t   const bool recursive_logging,\n\t\t\t\t   const int inode_only,\n\t\t\t\t   struct btrfs_log_ctx *ctx,\n\t\t\t\t   bool *need_log_inode_item)\n{\n\tstruct btrfs_root *root = inode->root;\n\tint ins_start_slot = 0;\n\tint ins_nr = 0;\n\tint ret;\n\n\twhile (1) {\n\t\tret = btrfs_search_forward(root, min_key, path, trans->transid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\nagain:\n\t\t/* Note, ins_nr might be > 0 here, cleanup outside the loop */\n\t\tif (min_key->objectid != max_key->objectid)\n\t\t\tbreak;\n\t\tif (min_key->type > max_key->type)\n\t\t\tbreak;\n\n\t\tif (min_key->type == BTRFS_INODE_ITEM_KEY)\n\t\t\t*need_log_inode_item = false;\n\n\t\tif ((min_key->type == BTRFS_INODE_REF_KEY ||\n\t\t     min_key->type == BTRFS_INODE_EXTREF_KEY) &&\n\t\t    inode->generation == trans->transid &&\n\t\t    !recursive_logging) {\n\t\t\tu64 other_ino = 0;\n\t\t\tu64 other_parent = 0;\n\n\t\t\tret = btrfs_check_ref_name_override(path->nodes[0],\n\t\t\t\t\tpath->slots[0], min_key, inode,\n\t\t\t\t\t&other_ino, &other_parent);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn ret;\n\t\t\t} else if (ret > 0 && ctx &&\n\t\t\t\t   other_ino != btrfs_ino(BTRFS_I(ctx->inode))) {\n\t\t\t\tif (ins_nr > 0) {\n\t\t\t\t\tins_nr++;\n\t\t\t\t} else {\n\t\t\t\t\tins_nr = 1;\n\t\t\t\t\tins_start_slot = path->slots[0];\n\t\t\t\t}\n\t\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t\t ins_start_slot, ins_nr,\n\t\t\t\t\t\t inode_only, logged_isize);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tins_nr = 0;\n\n\t\t\t\tret = log_conflicting_inodes(trans, root, path,\n\t\t\t\t\t\tctx, other_ino, other_parent);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto next_key;\n\t\t\t}\n\t\t}\n\n\t\t/* Skip xattrs, we log them later with btrfs_log_all_xattrs() */\n\t\tif (min_key->type == BTRFS_XATTR_ITEM_KEY) {\n\t\t\tif (ins_nr == 0)\n\t\t\t\tgoto next_slot;\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t ins_start_slot,\n\t\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tins_nr = 0;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tif (ins_nr && ins_start_slot + ins_nr == path->slots[0]) {\n\t\t\tins_nr++;\n\t\t\tgoto next_slot;\n\t\t} else if (!ins_nr) {\n\t\t\tins_start_slot = path->slots[0];\n\t\t\tins_nr = 1;\n\t\t\tgoto next_slot;\n\t\t}\n\n\t\tret = copy_items(trans, inode, dst_path, path, ins_start_slot,\n\t\t\t\t ins_nr, inode_only, logged_isize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tins_nr = 1;\n\t\tins_start_slot = path->slots[0];\nnext_slot:\n\t\tpath->slots[0]++;\n\t\tif (path->slots[0] < btrfs_header_nritems(path->nodes[0])) {\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], min_key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tgoto again;\n\t\t}\n\t\tif (ins_nr) {\n\t\t\tret = copy_items(trans, inode, dst_path, path,\n\t\t\t\t\t ins_start_slot, ins_nr, inode_only,\n\t\t\t\t\t logged_isize);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tins_nr = 0;\n\t\t}\n\t\tbtrfs_release_path(path);\nnext_key:\n\t\tif (min_key->offset < (u64)-1) {\n\t\t\tmin_key->offset++;\n\t\t} else if (min_key->type < max_key->type) {\n\t\t\tmin_key->type++;\n\t\t\tmin_key->offset = 0;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ins_nr)\n\t\tret = copy_items(trans, inode, dst_path, path, ins_start_slot,\n\t\t\t\t ins_nr, inode_only, logged_isize);\n\n\treturn ret;\n}\n\n/* log a single inode in the tree log.\n * At least one parent directory for this inode must exist in the tree\n * or be logged already.\n *\n * Any items from this inode changed by the current transaction are copied\n * to the log tree.  An extra reference is taken on any extents in this\n * file, allowing us to avoid a whole pile of corner cases around logging\n * blocks that have been removed from the tree.\n *\n * See LOG_INODE_ALL and related defines for a description of what inode_only\n * does.\n *\n * This handles both files and directories.\n */\nstatic int btrfs_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root, struct btrfs_inode *inode,\n\t\t\t   int inode_only,\n\t\t\t   struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_path *dst_path;\n\tstruct btrfs_key min_key;\n\tstruct btrfs_key max_key;\n\tstruct btrfs_root *log = root->log_root;\n\tint err = 0;\n\tint ret = 0;\n\tbool fast_search = false;\n\tu64 ino = btrfs_ino(inode);\n\tstruct extent_map_tree *em_tree = &inode->extent_tree;\n\tu64 logged_isize = 0;\n\tbool need_log_inode_item = true;\n\tbool xattrs_logged = false;\n\tbool recursive_logging = false;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tdst_path = btrfs_alloc_path();\n\tif (!dst_path) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tmin_key.objectid = ino;\n\tmin_key.type = BTRFS_INODE_ITEM_KEY;\n\tmin_key.offset = 0;\n\n\tmax_key.objectid = ino;\n\n\n\t/* today the code can only do partial logging of directories */\n\tif (S_ISDIR(inode->vfs_inode.i_mode) ||\n\t    (!test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t       &inode->runtime_flags) &&\n\t     inode_only >= LOG_INODE_EXISTS))\n\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\telse\n\t\tmax_key.type = (u8)-1;\n\tmax_key.offset = (u64)-1;\n\n\t/*\n\t * Only run delayed items if we are a directory. We want to make sure\n\t * all directory indexes hit the fs/subvolume tree so we can find them\n\t * and figure out which index ranges have to be logged.\n\t *\n\t * Otherwise commit the delayed inode only if the full sync flag is set,\n\t * as we want to make sure an up to date version is in the subvolume\n\t * tree so copy_inode_items_to_log() / copy_items() can find it and copy\n\t * it to the log tree. For a non full sync, we always log the inode item\n\t * based on the in-memory struct btrfs_inode which is always up to date.\n\t */\n\tif (S_ISDIR(inode->vfs_inode.i_mode))\n\t\tret = btrfs_commit_inode_delayed_items(trans, inode);\n\telse if (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC, &inode->runtime_flags))\n\t\tret = btrfs_commit_inode_delayed_inode(inode);\n\n\tif (ret) {\n\t\tbtrfs_free_path(path);\n\t\tbtrfs_free_path(dst_path);\n\t\treturn ret;\n\t}\n\n\tif (inode_only == LOG_OTHER_INODE || inode_only == LOG_OTHER_INODE_ALL) {\n\t\trecursive_logging = true;\n\t\tif (inode_only == LOG_OTHER_INODE)\n\t\t\tinode_only = LOG_INODE_EXISTS;\n\t\telse\n\t\t\tinode_only = LOG_INODE_ALL;\n\t\tmutex_lock_nested(&inode->log_mutex, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tmutex_lock(&inode->log_mutex);\n\t}\n\n\t/*\n\t * This is for cases where logging a directory could result in losing a\n\t * a file after replaying the log. For example, if we move a file from a\n\t * directory A to a directory B, then fsync directory A, we have no way\n\t * to known the file was moved from A to B, so logging just A would\n\t * result in losing the file after a log replay.\n\t */\n\tif (S_ISDIR(inode->vfs_inode.i_mode) &&\n\t    inode_only == LOG_INODE_ALL &&\n\t    inode->last_unlink_trans >= trans->transid) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\terr = 1;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * a brute force approach to making sure we get the most uptodate\n\t * copies of everything.\n\t */\n\tif (S_ISDIR(inode->vfs_inode.i_mode)) {\n\t\tint max_key_type = BTRFS_DIR_LOG_INDEX_KEY;\n\n\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING, &inode->runtime_flags);\n\t\tif (inode_only == LOG_INODE_EXISTS)\n\t\t\tmax_key_type = BTRFS_XATTR_ITEM_KEY;\n\t\tret = drop_objectid_items(trans, log, path, ino, max_key_type);\n\t} else {\n\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t/*\n\t\t\t * Make sure the new inode item we write to the log has\n\t\t\t * the same isize as the current one (if it exists).\n\t\t\t * This is necessary to prevent data loss after log\n\t\t\t * replay, and also to prevent doing a wrong expanding\n\t\t\t * truncate - for e.g. create file, write 4K into offset\n\t\t\t * 0, fsync, write 4K into offset 4096, add hard link,\n\t\t\t * fsync some other file (to sync log), power fail - if\n\t\t\t * we use the inode's current i_size, after log replay\n\t\t\t * we get a 8Kb file, with the last 4Kb extent as a hole\n\t\t\t * (zeroes), as if an expanding truncate happened,\n\t\t\t * instead of getting a file of 4Kb only.\n\t\t\t */\n\t\t\terr = logged_inode_size(log, inode, path, &logged_isize);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (test_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t     &inode->runtime_flags)) {\n\t\t\tif (inode_only == LOG_INODE_EXISTS) {\n\t\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t\t  max_key.type);\n\t\t\t} else {\n\t\t\t\tclear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t\t  &inode->runtime_flags);\n\t\t\t\tclear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t  &inode->runtime_flags);\n\t\t\t\twhile(1) {\n\t\t\t\t\tret = btrfs_truncate_inode_items(trans,\n\t\t\t\t\t\tlog, inode, 0, 0);\n\t\t\t\t\tif (ret != -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (test_and_clear_bit(BTRFS_INODE_COPY_EVERYTHING,\n\t\t\t\t\t      &inode->runtime_flags) ||\n\t\t\t   inode_only == LOG_INODE_EXISTS) {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tmax_key.type = BTRFS_XATTR_ITEM_KEY;\n\t\t\tret = drop_objectid_items(trans, log, path, ino,\n\t\t\t\t\t\t  max_key.type);\n\t\t} else {\n\t\t\tif (inode_only == LOG_INODE_ALL)\n\t\t\t\tfast_search = true;\n\t\t\tgoto log_extents;\n\t\t}\n\n\t}\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_unlock;\n\t}\n\n\terr = copy_inode_items_to_log(trans, inode, &min_key, &max_key,\n\t\t\t\t      path, dst_path, logged_isize,\n\t\t\t\t      recursive_logging, inode_only, ctx,\n\t\t\t\t      &need_log_inode_item);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\terr = btrfs_log_all_xattrs(trans, root, inode, path, dst_path);\n\tif (err)\n\t\tgoto out_unlock;\n\txattrs_logged = true;\n\tif (max_key.type >= BTRFS_EXTENT_DATA_KEY && !fast_search) {\n\t\tbtrfs_release_path(path);\n\t\tbtrfs_release_path(dst_path);\n\t\terr = btrfs_log_holes(trans, root, inode, path);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\nlog_extents:\n\tbtrfs_release_path(path);\n\tbtrfs_release_path(dst_path);\n\tif (need_log_inode_item) {\n\t\terr = log_inode_item(trans, log, dst_path, inode);\n\t\tif (!err && !xattrs_logged) {\n\t\t\terr = btrfs_log_all_xattrs(trans, root, inode, path,\n\t\t\t\t\t\t   dst_path);\n\t\t\tbtrfs_release_path(path);\n\t\t}\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\tif (fast_search) {\n\t\tret = btrfs_log_changed_extents(trans, root, inode, dst_path,\n\t\t\t\t\t\tctx);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else if (inode_only == LOG_INODE_ALL) {\n\t\tstruct extent_map *em, *n;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tlist_for_each_entry_safe(em, n, &em_tree->modified_extents, list)\n\t\t\tlist_del_init(&em->list);\n\t\twrite_unlock(&em_tree->lock);\n\t}\n\n\tif (inode_only == LOG_INODE_ALL && S_ISDIR(inode->vfs_inode.i_mode)) {\n\t\tret = log_directory_changes(trans, root, inode, path, dst_path,\n\t\t\t\t\tctx);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/*\n\t * If we are logging that an ancestor inode exists as part of logging a\n\t * new name from a link or rename operation, don't mark the inode as\n\t * logged - otherwise if an explicit fsync is made against an ancestor,\n\t * the fsync considers the inode in the log and doesn't sync the log,\n\t * resulting in the ancestor missing after a power failure unless the\n\t * log was synced as part of an fsync against any other unrelated inode.\n\t * So keep it simple for this case and just don't flag the ancestors as\n\t * logged.\n\t */\n\tif (!ctx ||\n\t    !(S_ISDIR(inode->vfs_inode.i_mode) && ctx->logging_new_name &&\n\t      &inode->vfs_inode != ctx->inode)) {\n\t\tspin_lock(&inode->lock);\n\t\tinode->logged_trans = trans->transid;\n\t\t/*\n\t\t * Don't update last_log_commit if we logged that an inode exists\n\t\t * after it was loaded to memory (full_sync bit set).\n\t\t * This is to prevent data loss when we do a write to the inode,\n\t\t * then the inode gets evicted after all delalloc was flushed,\n\t\t * then we log it exists (due to a rename for example) and then\n\t\t * fsync it. This last fsync would do nothing (not logging the\n\t\t * extents previously written).\n\t\t */\n\t\tif (inode_only != LOG_INODE_EXISTS ||\n\t\t    !test_bit(BTRFS_INODE_NEEDS_FULL_SYNC, &inode->runtime_flags))\n\t\t\tinode->last_log_commit = inode->last_sub_trans;\n\t\tspin_unlock(&inode->lock);\n\t}\nout_unlock:\n\tmutex_unlock(&inode->log_mutex);\n\n\tbtrfs_free_path(path);\n\tbtrfs_free_path(dst_path);\n\treturn err;\n}\n\n/*\n * Check if we need to log an inode. This is used in contexts where while\n * logging an inode we need to log another inode (either that it exists or in\n * full mode). This is used instead of btrfs_inode_in_log() because the later\n * requires the inode to be in the log and have the log transaction committed,\n * while here we do not care if the log transaction was already committed - our\n * caller will commit the log later - and we want to avoid logging an inode\n * multiple times when multiple tasks have joined the same log transaction.\n */\nstatic bool need_log_inode(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_inode *inode)\n{\n\t/*\n\t * If this inode does not have new/updated/deleted xattrs since the last\n\t * time it was logged and is flagged as logged in the current transaction,\n\t * we can skip logging it. As for new/deleted names, those are updated in\n\t * the log by link/unlink/rename operations.\n\t * In case the inode was logged and then evicted and reloaded, its\n\t * logged_trans will be 0, in which case we have to fully log it since\n\t * logged_trans is a transient field, not persisted.\n\t */\n\tif (inode->logged_trans == trans->transid &&\n\t    !test_bit(BTRFS_INODE_COPY_EVERYTHING, &inode->runtime_flags))\n\t\treturn false;\n\n\treturn true;\n}\n\nstruct btrfs_dir_list {\n\tu64 ino;\n\tstruct list_head list;\n};\n\n/*\n * Log the inodes of the new dentries of a directory. See log_dir_items() for\n * details about the why it is needed.\n * This is a recursive operation - if an existing dentry corresponds to a\n * directory, that directory's new entries are logged too (same behaviour as\n * ext3/4, xfs, f2fs, reiserfs, nilfs2). Note that when logging the inodes\n * the dentries point to we do not lock their i_mutex, otherwise lockdep\n * complains about the following circular lock dependency / possible deadlock:\n *\n *        CPU0                                        CPU1\n *        ----                                        ----\n * lock(&type->i_mutex_dir_key#3/2);\n *                                            lock(sb_internal#2);\n *                                            lock(&type->i_mutex_dir_key#3/2);\n * lock(&sb->s_type->i_mutex_key#14);\n *\n * Where sb_internal is the lock (a counter that works as a lock) acquired by\n * sb_start_intwrite() in btrfs_start_transaction().\n * Not locking i_mutex of the inodes is still safe because:\n *\n * 1) For regular files we log with a mode of LOG_INODE_EXISTS. It's possible\n *    that while logging the inode new references (names) are added or removed\n *    from the inode, leaving the logged inode item with a link count that does\n *    not match the number of logged inode reference items. This is fine because\n *    at log replay time we compute the real number of links and correct the\n *    link count in the inode item (see replay_one_buffer() and\n *    link_to_fixup_dir());\n *\n * 2) For directories we log with a mode of LOG_INODE_ALL. It's possible that\n *    while logging the inode's items new items with keys BTRFS_DIR_ITEM_KEY and\n *    BTRFS_DIR_INDEX_KEY are added to fs/subvol tree and the logged inode item\n *    has a size that doesn't match the sum of the lengths of all the logged\n *    names. This does not result in a problem because if a dir_item key is\n *    logged but its matching dir_index key is not logged, at log replay time we\n *    don't use it to replay the respective name (see replay_one_name()). On the\n *    other hand if only the dir_index key ends up being logged, the respective\n *    name is added to the fs/subvol tree with both the dir_item and dir_index\n *    keys created (see replay_one_name()).\n *    The directory's inode item with a wrong i_size is not a problem as well,\n *    since we don't use it at log replay time to set the i_size in the inode\n *    item of the fs/subvol tree (see overwrite_item()).\n */\nstatic int log_new_dir_dentries(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_inode *start_inode,\n\t\t\t\tstruct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *log = root->log_root;\n\tstruct btrfs_path *path;\n\tLIST_HEAD(dir_list);\n\tstruct btrfs_dir_list *dir_elem;\n\tint ret = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdir_elem = kmalloc(sizeof(*dir_elem), GFP_NOFS);\n\tif (!dir_elem) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\tdir_elem->ino = btrfs_ino(start_inode);\n\tlist_add_tail(&dir_elem->list, &dir_list);\n\n\twhile (!list_empty(&dir_list)) {\n\t\tstruct extent_buffer *leaf;\n\t\tstruct btrfs_key min_key;\n\t\tint nritems;\n\t\tint i;\n\n\t\tdir_elem = list_first_entry(&dir_list, struct btrfs_dir_list,\n\t\t\t\t\t    list);\n\t\tif (ret)\n\t\t\tgoto next_dir_inode;\n\n\t\tmin_key.objectid = dir_elem->ino;\n\t\tmin_key.type = BTRFS_DIR_ITEM_KEY;\n\t\tmin_key.offset = 0;\nagain:\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_forward(log, &min_key, path, trans->transid);\n\t\tif (ret < 0) {\n\t\t\tgoto next_dir_inode;\n\t\t} else if (ret > 0) {\n\t\t\tret = 0;\n\t\t\tgoto next_dir_inode;\n\t\t}\n\nprocess_leaf:\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tfor (i = path->slots[0]; i < nritems; i++) {\n\t\t\tstruct btrfs_dir_item *di;\n\t\t\tstruct btrfs_key di_key;\n\t\t\tstruct inode *di_inode;\n\t\t\tstruct btrfs_dir_list *new_dir_elem;\n\t\t\tint log_mode = LOG_INODE_EXISTS;\n\t\t\tint type;\n\n\t\t\tbtrfs_item_key_to_cpu(leaf, &min_key, i);\n\t\t\tif (min_key.objectid != dir_elem->ino ||\n\t\t\t    min_key.type != BTRFS_DIR_ITEM_KEY)\n\t\t\t\tgoto next_dir_inode;\n\n\t\t\tdi = btrfs_item_ptr(leaf, i, struct btrfs_dir_item);\n\t\t\ttype = btrfs_dir_type(leaf, di);\n\t\t\tif (btrfs_dir_transid(leaf, di) < trans->transid &&\n\t\t\t    type != BTRFS_FT_DIR)\n\t\t\t\tcontinue;\n\t\t\tbtrfs_dir_item_key_to_cpu(leaf, di, &di_key);\n\t\t\tif (di_key.type == BTRFS_ROOT_ITEM_KEY)\n\t\t\t\tcontinue;\n\n\t\t\tbtrfs_release_path(path);\n\t\t\tdi_inode = btrfs_iget(fs_info->sb, di_key.objectid, root);\n\t\t\tif (IS_ERR(di_inode)) {\n\t\t\t\tret = PTR_ERR(di_inode);\n\t\t\t\tgoto next_dir_inode;\n\t\t\t}\n\n\t\t\tif (!need_log_inode(trans, BTRFS_I(di_inode))) {\n\t\t\t\tbtrfs_add_delayed_iput(di_inode);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx->log_new_dentries = false;\n\t\t\tif (type == BTRFS_FT_DIR || type == BTRFS_FT_SYMLINK)\n\t\t\t\tlog_mode = LOG_INODE_ALL;\n\t\t\tret = btrfs_log_inode(trans, root, BTRFS_I(di_inode),\n\t\t\t\t\t      log_mode, ctx);\n\t\t\tbtrfs_add_delayed_iput(di_inode);\n\t\t\tif (ret)\n\t\t\t\tgoto next_dir_inode;\n\t\t\tif (ctx->log_new_dentries) {\n\t\t\t\tnew_dir_elem = kmalloc(sizeof(*new_dir_elem),\n\t\t\t\t\t\t       GFP_NOFS);\n\t\t\t\tif (!new_dir_elem) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto next_dir_inode;\n\t\t\t\t}\n\t\t\t\tnew_dir_elem->ino = di_key.objectid;\n\t\t\t\tlist_add_tail(&new_dir_elem->list, &dir_list);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (i == nritems) {\n\t\t\tret = btrfs_next_leaf(log, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto next_dir_inode;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto next_dir_inode;\n\t\t\t}\n\t\t\tgoto process_leaf;\n\t\t}\n\t\tif (min_key.offset < (u64)-1) {\n\t\t\tmin_key.offset++;\n\t\t\tgoto again;\n\t\t}\nnext_dir_inode:\n\t\tlist_del(&dir_elem->list);\n\t\tkfree(dir_elem);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int btrfs_log_all_parents(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = inode->root;\n\tconst u64 ino = btrfs_ino(inode);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tu32 cur_offset = 0;\n\t\tu32 item_size;\n\t\tunsigned long ptr;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\t/* BTRFS_INODE_EXTREF_KEY is BTRFS_INODE_REF_KEY + 1 */\n\t\tif (key.objectid != ino || key.type > BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\twhile (cur_offset < item_size) {\n\t\t\tstruct btrfs_key inode_key;\n\t\t\tstruct inode *dir_inode;\n\n\t\t\tinode_key.type = BTRFS_INODE_ITEM_KEY;\n\t\t\tinode_key.offset = 0;\n\n\t\t\tif (key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\t\textref = (struct btrfs_inode_extref *)\n\t\t\t\t\t(ptr + cur_offset);\n\t\t\t\tinode_key.objectid = btrfs_inode_extref_parent(\n\t\t\t\t\tleaf, extref);\n\t\t\t\tcur_offset += sizeof(*extref);\n\t\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf,\n\t\t\t\t\textref);\n\t\t\t} else {\n\t\t\t\tinode_key.objectid = key.offset;\n\t\t\t\tcur_offset = item_size;\n\t\t\t}\n\n\t\t\tdir_inode = btrfs_iget(fs_info->sb, inode_key.objectid,\n\t\t\t\t\t       root);\n\t\t\t/*\n\t\t\t * If the parent inode was deleted, return an error to\n\t\t\t * fallback to a transaction commit. This is to prevent\n\t\t\t * getting an inode that was moved from one parent A to\n\t\t\t * a parent B, got its former parent A deleted and then\n\t\t\t * it got fsync'ed, from existing at both parents after\n\t\t\t * a log replay (and the old parent still existing).\n\t\t\t * Example:\n\t\t\t *\n\t\t\t * mkdir /mnt/A\n\t\t\t * mkdir /mnt/B\n\t\t\t * touch /mnt/B/bar\n\t\t\t * sync\n\t\t\t * mv /mnt/B/bar /mnt/A/bar\n\t\t\t * mv -T /mnt/A /mnt/B\n\t\t\t * fsync /mnt/B/bar\n\t\t\t * <power fail>\n\t\t\t *\n\t\t\t * If we ignore the old parent B which got deleted,\n\t\t\t * after a log replay we would have file bar linked\n\t\t\t * at both parents and the old parent B would still\n\t\t\t * exist.\n\t\t\t */\n\t\t\tif (IS_ERR(dir_inode)) {\n\t\t\t\tret = PTR_ERR(dir_inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!need_log_inode(trans, BTRFS_I(dir_inode))) {\n\t\t\t\tbtrfs_add_delayed_iput(dir_inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ctx)\n\t\t\t\tctx->log_new_dentries = false;\n\t\t\tret = btrfs_log_inode(trans, root, BTRFS_I(dir_inode),\n\t\t\t\t\t      LOG_INODE_ALL, ctx);\n\t\t\tif (!ret && ctx && ctx->log_new_dentries)\n\t\t\t\tret = log_new_dir_dentries(trans, root,\n\t\t\t\t\t\t   BTRFS_I(dir_inode), ctx);\n\t\t\tbtrfs_add_delayed_iput(dir_inode);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int log_new_ancestors(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_key found_key;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, path->slots[0]);\n\n\twhile (true) {\n\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_key search_key;\n\t\tstruct inode *inode;\n\t\tu64 ino;\n\t\tint ret = 0;\n\n\t\tbtrfs_release_path(path);\n\n\t\tino = found_key.offset;\n\n\t\tsearch_key.objectid = found_key.offset;\n\t\tsearch_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tsearch_key.offset = 0;\n\t\tinode = btrfs_iget(fs_info->sb, ino, root);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\n\t\tif (BTRFS_I(inode)->generation >= trans->transid &&\n\t\t    need_log_inode(trans, BTRFS_I(inode)))\n\t\t\tret = btrfs_log_inode(trans, root, BTRFS_I(inode),\n\t\t\t\t\t      LOG_INODE_EXISTS, ctx);\n\t\tbtrfs_add_delayed_iput(inode);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (search_key.objectid == BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tbreak;\n\n\t\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\t\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret > 0)\n\t\t\t\treturn -ENOENT;\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid != search_key.objectid ||\n\t\t    found_key.type != BTRFS_INODE_REF_KEY)\n\t\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}\n\nstatic int log_new_ancestors_fast(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct dentry *old_parent = NULL;\n\tstruct super_block *sb = inode->vfs_inode.i_sb;\n\tint ret = 0;\n\n\twhile (true) {\n\t\tif (!parent || d_really_is_negative(parent) ||\n\t\t    sb != parent->d_sb)\n\t\t\tbreak;\n\n\t\tinode = BTRFS_I(d_inode(parent));\n\t\tif (root != inode->root)\n\t\t\tbreak;\n\n\t\tif (inode->generation >= trans->transid &&\n\t\t    need_log_inode(trans, inode)) {\n\t\t\tret = btrfs_log_inode(trans, root, inode,\n\t\t\t\t\t      LOG_INODE_EXISTS, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (IS_ROOT(parent))\n\t\t\tbreak;\n\n\t\tparent = dget_parent(parent);\n\t\tdput(old_parent);\n\t\told_parent = parent;\n\t}\n\tdput(old_parent);\n\n\treturn ret;\n}\n\nstatic int log_all_new_ancestors(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_inode *inode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = inode->root;\n\tconst u64 ino = btrfs_ino(inode);\n\tstruct btrfs_path *path;\n\tstruct btrfs_key search_key;\n\tint ret;\n\n\t/*\n\t * For a single hard link case, go through a fast path that does not\n\t * need to iterate the fs/subvolume tree.\n\t */\n\tif (inode->vfs_inode.i_nlink < 2)\n\t\treturn log_new_ancestors_fast(trans, inode, parent, ctx);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsearch_key.objectid = ino;\n\tsearch_key.type = BTRFS_INODE_REF_KEY;\n\tsearch_key.offset = 0;\nagain:\n\tret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret == 0)\n\t\tpath->slots[0]++;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_key found_key;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\t\tif (found_key.objectid != ino ||\n\t\t    found_key.type > BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't deal with extended references because they are rare\n\t\t * cases and too complex to deal with (we would need to keep\n\t\t * track of which subitem we are processing for each item in\n\t\t * this loop, etc). So just return some error to fallback to\n\t\t * a transaction commit.\n\t\t */\n\t\tif (found_key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = -EMLINK;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Logging ancestors needs to do more searches on the fs/subvol\n\t\t * tree, so it releases the path as needed to avoid deadlocks.\n\t\t * Keep track of the last inode ref key and resume from that key\n\t\t * after logging all new ancestors for the current hard link.\n\t\t */\n\t\tmemcpy(&search_key, &found_key, sizeof(search_key));\n\n\t\tret = log_new_ancestors(trans, root, path, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbtrfs_release_path(path);\n\t\tgoto again;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * helper function around btrfs_log_inode to make sure newly created\n * parent directories also end up in the log.  A minimal inode and backref\n * only logging is done of any parent directories that are older than\n * the last committed transaction\n */\nstatic int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_inode *inode,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  int inode_only,\n\t\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct btrfs_root *root = inode->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\tbool log_dentries = false;\n\n\tif (btrfs_test_opt(fs_info, NOTREELOG)) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\tif (btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = 1;\n\t\tgoto end_no_trans;\n\t}\n\n\t/*\n\t * Skip already logged inodes or inodes corresponding to tmpfiles\n\t * (since logging them is pointless, a link count of 0 means they\n\t * will never be accessible).\n\t */\n\tif (btrfs_inode_in_log(inode, trans->transid) ||\n\t    inode->vfs_inode.i_nlink == 0) {\n\t\tret = BTRFS_NO_LOG_SYNC;\n\t\tgoto end_no_trans;\n\t}\n\n\tret = start_log_trans(trans, root, ctx);\n\tif (ret)\n\t\tgoto end_no_trans;\n\n\tret = btrfs_log_inode(trans, root, inode, inode_only, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\t/*\n\t * for regular files, if its inode is already on disk, we don't\n\t * have to worry about the parents at all.  This is because\n\t * we can use the last_unlink_trans field to record renames\n\t * and other fun in this file.\n\t */\n\tif (S_ISREG(inode->vfs_inode.i_mode) &&\n\t    inode->generation < trans->transid &&\n\t    inode->last_unlink_trans < trans->transid) {\n\t\tret = 0;\n\t\tgoto end_trans;\n\t}\n\n\tif (S_ISDIR(inode->vfs_inode.i_mode) && ctx && ctx->log_new_dentries)\n\t\tlog_dentries = true;\n\n\t/*\n\t * On unlink we must make sure all our current and old parent directory\n\t * inodes are fully logged. This is to prevent leaving dangling\n\t * directory index entries in directories that were our parents but are\n\t * not anymore. Not doing this results in old parent directory being\n\t * impossible to delete after log replay (rmdir will always fail with\n\t * error -ENOTEMPTY).\n\t *\n\t * Example 1:\n\t *\n\t * mkdir testdir\n\t * touch testdir/foo\n\t * ln testdir/foo testdir/bar\n\t * sync\n\t * unlink testdir/bar\n\t * xfs_io -c fsync testdir/foo\n\t * <power failure>\n\t * mount fs, triggers log replay\n\t *\n\t * If we don't log the parent directory (testdir), after log replay the\n\t * directory still has an entry pointing to the file inode using the bar\n\t * name, but a matching BTRFS_INODE_[REF|EXTREF]_KEY does not exist and\n\t * the file inode has a link count of 1.\n\t *\n\t * Example 2:\n\t *\n\t * mkdir testdir\n\t * touch foo\n\t * ln foo testdir/foo2\n\t * ln foo testdir/foo3\n\t * sync\n\t * unlink testdir/foo3\n\t * xfs_io -c fsync foo\n\t * <power failure>\n\t * mount fs, triggers log replay\n\t *\n\t * Similar as the first example, after log replay the parent directory\n\t * testdir still has an entry pointing to the inode file with name foo3\n\t * but the file inode does not have a matching BTRFS_INODE_REF_KEY item\n\t * and has a link count of 2.\n\t */\n\tif (inode->last_unlink_trans >= trans->transid) {\n\t\tret = btrfs_log_all_parents(trans, inode, ctx);\n\t\tif (ret)\n\t\t\tgoto end_trans;\n\t}\n\n\tret = log_all_new_ancestors(trans, inode, parent, ctx);\n\tif (ret)\n\t\tgoto end_trans;\n\n\tif (log_dentries)\n\t\tret = log_new_dir_dentries(trans, root, inode, ctx);\n\telse\n\t\tret = 0;\nend_trans:\n\tif (ret < 0) {\n\t\tbtrfs_set_log_full_commit(trans);\n\t\tret = 1;\n\t}\n\n\tif (ret)\n\t\tbtrfs_remove_log_ctx(root, ctx);\n\tbtrfs_end_log_trans(root);\nend_no_trans:\n\treturn ret;\n}\n\n/*\n * it is not safe to log dentry if the chunk root has added new\n * chunks.  This returns 0 if the dentry was logged, and 1 otherwise.\n * If this returns 1, you must commit the transaction to safely get your\n * data on disk.\n */\nint btrfs_log_dentry_safe(struct btrfs_trans_handle *trans,\n\t\t\t  struct dentry *dentry,\n\t\t\t  struct btrfs_log_ctx *ctx)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tint ret;\n\n\tret = btrfs_log_inode_parent(trans, BTRFS_I(d_inode(dentry)), parent,\n\t\t\t\t     LOG_INODE_ALL, ctx);\n\tdput(parent);\n\n\treturn ret;\n}\n\n/*\n * should be called during mount to recover any replay any log trees\n * from the FS\n */\nint btrfs_recover_log_trees(struct btrfs_root *log_root_tree)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *log;\n\tstruct btrfs_fs_info *fs_info = log_root_tree->fs_info;\n\tstruct walk_control wc = {\n\t\t.process_func = process_one_buffer,\n\t\t.stage = LOG_WALK_PIN_ONLY,\n\t};\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tset_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags);\n\n\ttrans = btrfs_start_transaction(fs_info->tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto error;\n\t}\n\n\twc.trans = trans;\n\twc.pin = 1;\n\n\tret = walk_log_tree(trans, log_root_tree, &wc);\n\tif (ret) {\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\"Failed to pin buffers while recovering log root tree.\");\n\t\tgoto error;\n\t}\n\nagain:\n\tkey.objectid = BTRFS_TREE_LOG_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, log_root_tree, &key, path, 0, 0);\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't find tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tbtrfs_release_path(path);\n\t\tif (found_key.objectid != BTRFS_TREE_LOG_OBJECTID)\n\t\t\tbreak;\n\n\t\tlog = btrfs_read_tree_root(log_root_tree, &found_key);\n\t\tif (IS_ERR(log)) {\n\t\t\tret = PTR_ERR(log);\n\t\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t    \"Couldn't read tree log root.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest = btrfs_get_fs_root(fs_info, found_key.offset,\n\t\t\t\t\t\t   true);\n\t\tif (IS_ERR(wc.replay_dest)) {\n\t\t\tret = PTR_ERR(wc.replay_dest);\n\n\t\t\t/*\n\t\t\t * We didn't find the subvol, likely because it was\n\t\t\t * deleted.  This is ok, simply skip this log and go to\n\t\t\t * the next one.\n\t\t\t *\n\t\t\t * We need to exclude the root because we can't have\n\t\t\t * other log replays overwriting this log as we'll read\n\t\t\t * it back in a few more times.  This will keep our\n\t\t\t * block from being modified, and we'll just bail for\n\t\t\t * each subsequent pass.\n\t\t\t */\n\t\t\tif (ret == -ENOENT)\n\t\t\t\tret = btrfs_pin_extent_for_log_replay(trans,\n\t\t\t\t\t\t\tlog->node->start,\n\t\t\t\t\t\t\tlog->node->len);\n\t\t\tbtrfs_put_root(log);\n\n\t\t\tif (!ret)\n\t\t\t\tgoto next;\n\t\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t\"Couldn't read target root for tree log recovery.\");\n\t\t\tgoto error;\n\t\t}\n\n\t\twc.replay_dest->log_root = log;\n\t\tret = btrfs_record_root_in_trans(trans, wc.replay_dest);\n\t\tif (ret)\n\t\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t\"Couldn't record the root in the transaction.\");\n\t\telse\n\t\t\tret = walk_log_tree(trans, log, &wc);\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tret = fixup_inode_link_counts(trans, wc.replay_dest,\n\t\t\t\t\t\t      path);\n\t\t}\n\n\t\tif (!ret && wc.stage == LOG_WALK_REPLAY_ALL) {\n\t\t\tstruct btrfs_root *root = wc.replay_dest;\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t/*\n\t\t\t * We have just replayed everything, and the highest\n\t\t\t * objectid of fs roots probably has changed in case\n\t\t\t * some inode_item's got replayed.\n\t\t\t *\n\t\t\t * root->objectid_mutex is not acquired as log replay\n\t\t\t * could only happen during mount.\n\t\t\t */\n\t\t\tret = btrfs_init_root_free_objectid(root);\n\t\t}\n\n\t\twc.replay_dest->log_root = NULL;\n\t\tbtrfs_put_root(wc.replay_dest);\n\t\tbtrfs_put_root(log);\n\n\t\tif (ret)\n\t\t\tgoto error;\nnext:\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/* step one is to pin it all, step two is to replay just inodes */\n\tif (wc.pin) {\n\t\twc.pin = 0;\n\t\twc.process_func = replay_one_buffer;\n\t\twc.stage = LOG_WALK_REPLAY_INODES;\n\t\tgoto again;\n\t}\n\t/* step three is to replay everything */\n\tif (wc.stage < LOG_WALK_REPLAY_ALL) {\n\t\twc.stage++;\n\t\tgoto again;\n\t}\n\n\tbtrfs_free_path(path);\n\n\t/* step 4: commit the transaction, which also unpins the blocks */\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tlog_root_tree->log_root = NULL;\n\tclear_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags);\n\tbtrfs_put_root(log_root_tree);\n\n\treturn 0;\nerror:\n\tif (wc.trans)\n\t\tbtrfs_end_transaction(wc.trans);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * there are some corner cases where we want to force a full\n * commit instead of allowing a directory to be logged.\n *\n * They revolve around files there were unlinked from the directory, and\n * this function updates the parent directory so that a full commit is\n * properly done if it is fsync'd later after the unlinks are done.\n *\n * Must be called before the unlink operations (updates to the subvolume tree,\n * inodes, etc) are done.\n */\nvoid btrfs_record_unlink_dir(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_inode *dir, struct btrfs_inode *inode,\n\t\t\t     int for_rename)\n{\n\t/*\n\t * when we're logging a file, if it hasn't been renamed\n\t * or unlinked, and its inode is fully committed on disk,\n\t * we don't have to worry about walking up the directory chain\n\t * to log its parents.\n\t *\n\t * So, we use the last_unlink_trans field to put this transid\n\t * into the file.  When the file is logged we check it and\n\t * don't log the parents if the file is fully on disk.\n\t */\n\tmutex_lock(&inode->log_mutex);\n\tinode->last_unlink_trans = trans->transid;\n\tmutex_unlock(&inode->log_mutex);\n\n\t/*\n\t * if this directory was already logged any new\n\t * names for this file/dir will get recorded\n\t */\n\tif (dir->logged_trans == trans->transid)\n\t\treturn;\n\n\t/*\n\t * if the inode we're about to unlink was logged,\n\t * the log will be properly updated for any new names\n\t */\n\tif (inode->logged_trans == trans->transid)\n\t\treturn;\n\n\t/*\n\t * when renaming files across directories, if the directory\n\t * there we're unlinking from gets fsync'd later on, there's\n\t * no way to find the destination directory later and fsync it\n\t * properly.  So, we have to be conservative and force commits\n\t * so the new name gets discovered.\n\t */\n\tif (for_rename)\n\t\tgoto record;\n\n\t/* we can safely do the unlink without any special recording */\n\treturn;\n\nrecord:\n\tmutex_lock(&dir->log_mutex);\n\tdir->last_unlink_trans = trans->transid;\n\tmutex_unlock(&dir->log_mutex);\n}\n\n/*\n * Make sure that if someone attempts to fsync the parent directory of a deleted\n * snapshot, it ends up triggering a transaction commit. This is to guarantee\n * that after replaying the log tree of the parent directory's root we will not\n * see the snapshot anymore and at log replay time we will not see any log tree\n * corresponding to the deleted snapshot's root, which could lead to replaying\n * it after replaying the log tree of the parent directory (which would replay\n * the snapshot delete operation).\n *\n * Must be called before the actual snapshot destroy operation (updates to the\n * parent root and tree of tree roots trees, etc) are done.\n */\nvoid btrfs_record_snapshot_destroy(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_inode *dir)\n{\n\tmutex_lock(&dir->log_mutex);\n\tdir->last_unlink_trans = trans->transid;\n\tmutex_unlock(&dir->log_mutex);\n}\n\n/*\n * Call this after adding a new name for a file and it will properly\n * update the log to reflect the new name.\n */\nvoid btrfs_log_new_name(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_inode *inode, struct btrfs_inode *old_dir,\n\t\t\tstruct dentry *parent)\n{\n\tstruct btrfs_log_ctx ctx;\n\n\t/*\n\t * this will force the logging code to walk the dentry chain\n\t * up for the file\n\t */\n\tif (!S_ISDIR(inode->vfs_inode.i_mode))\n\t\tinode->last_unlink_trans = trans->transid;\n\n\t/*\n\t * if this inode hasn't been logged and directory we're renaming it\n\t * from hasn't been logged, we don't need to log it\n\t */\n\tif (inode->logged_trans < trans->transid &&\n\t    (!old_dir || old_dir->logged_trans < trans->transid))\n\t\treturn;\n\n\tbtrfs_init_log_ctx(&ctx, &inode->vfs_inode);\n\tctx.logging_new_name = true;\n\t/*\n\t * We don't care about the return value. If we fail to log the new name\n\t * then we know the next attempt to sync the log will fallback to a full\n\t * transaction commit (due to a call to btrfs_set_log_full_commit()), so\n\t * we don't need to worry about getting a log committed that has an\n\t * inconsistent state after a rename operation.\n\t */\n\tbtrfs_log_inode_parent(trans, inode, parent, LOG_INODE_EXISTS, &ctx);\n}\n\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 3279}, "message": "error: we previously assumed 'log_root_tree->node' could be null (see line 3177)"}], "macros": [], "notes": [], "path": "/src/fs/btrfs/tree-log.c", "reportHash": "58aa9c4cbe436f3ba75a4f4b552efb53", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
