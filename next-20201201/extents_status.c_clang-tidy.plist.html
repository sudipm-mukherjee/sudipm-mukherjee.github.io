<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/ext4/extents_status.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  fs/ext4/extents_status.c\n *\n * Written by Yongqiang Yang <xiaoqiangnk@gmail.com>\n * Modified by\n *\tAllison Henderson <achender@linux.vnet.ibm.com>\n *\tHugh Dickins <hughd@google.com>\n *\tZheng Liu <wenqing.lz@taobao.com>\n *\n * Ext4 extents status tree core functions.\n */\n#include <linux/list_sort.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include \"ext4.h\"\n\n#include <trace/events/ext4.h>\n\n/*\n * According to previous discussion in Ext4 Developer Workshop, we\n * will introduce a new structure called io tree to track all extent\n * status in order to solve some problems that we have met\n * (e.g. Reservation space warning), and provide extent-level locking.\n * Delay extent tree is the first step to achieve this goal.  It is\n * original built by Yongqiang Yang.  At that time it is called delay\n * extent tree, whose goal is only track delayed extents in memory to\n * simplify the implementation of fiemap and bigalloc, and introduce\n * lseek SEEK_DATA/SEEK_HOLE support.  That is why it is still called\n * delay extent tree at the first commit.  But for better understand\n * what it does, it has been rename to extent status tree.\n *\n * Step1:\n * Currently the first step has been done.  All delayed extents are\n * tracked in the tree.  It maintains the delayed extent when a delayed\n * allocation is issued, and the delayed extent is written out or\n * invalidated.  Therefore the implementation of fiemap and bigalloc\n * are simplified, and SEEK_DATA/SEEK_HOLE are introduced.\n *\n * The following comment describes the implemenmtation of extent\n * status tree and future works.\n *\n * Step2:\n * In this step all extent status are tracked by extent status tree.\n * Thus, we can first try to lookup a block mapping in this tree before\n * finding it in extent tree.  Hence, single extent cache can be removed\n * because extent status tree can do a better job.  Extents in status\n * tree are loaded on-demand.  Therefore, the extent status tree may not\n * contain all of the extents in a file.  Meanwhile we define a shrinker\n * to reclaim memory from extent status tree because fragmented extent\n * tree will make status tree cost too much memory.  written/unwritten/-\n * hole extents in the tree will be reclaimed by this shrinker when we\n * are under high memory pressure.  Delayed extents will not be\n * reclimed because fiemap, bigalloc, and seek_data/hole need it.\n */\n\n/*\n * Extent status tree implementation for ext4.\n *\n *\n * ==========================================================================\n * Extent status tree tracks all extent status.\n *\n * 1. Why we need to implement extent status tree?\n *\n * Without extent status tree, ext4 identifies a delayed extent by looking\n * up page cache, this has several deficiencies - complicated, buggy,\n * and inefficient code.\n *\n * FIEMAP, SEEK_HOLE/DATA, bigalloc, and writeout all need to know if a\n * block or a range of blocks are belonged to a delayed extent.\n *\n * Let us have a look at how they do without extent status tree.\n *   --\tFIEMAP\n *\tFIEMAP looks up page cache to identify delayed allocations from holes.\n *\n *   --\tSEEK_HOLE/DATA\n *\tSEEK_HOLE/DATA has the same problem as FIEMAP.\n *\n *   --\tbigalloc\n *\tbigalloc looks up page cache to figure out if a block is\n *\talready under delayed allocation or not to determine whether\n *\tquota reserving is needed for the cluster.\n *\n *   --\twriteout\n *\tWriteout looks up whole page cache to see if a buffer is\n *\tmapped, If there are not very many delayed buffers, then it is\n *\ttime consuming.\n *\n * With extent status tree implementation, FIEMAP, SEEK_HOLE/DATA,\n * bigalloc and writeout can figure out if a block or a range of\n * blocks is under delayed allocation(belonged to a delayed extent) or\n * not by searching the extent tree.\n *\n *\n * ==========================================================================\n * 2. Ext4 extent status tree impelmentation\n *\n *   --\textent\n *\tA extent is a range of blocks which are contiguous logically and\n *\tphysically.  Unlike extent in extent tree, this extent in ext4 is\n *\ta in-memory struct, there is no corresponding on-disk data.  There\n *\tis no limit on length of extent, so an extent can contain as many\n *\tblocks as they are contiguous logically and physically.\n *\n *   --\textent status tree\n *\tEvery inode has an extent status tree and all allocation blocks\n *\tare added to the tree with different status.  The extent in the\n *\ttree are ordered by logical block no.\n *\n *   --\toperations on a extent status tree\n *\tThere are three important operations on a delayed extent tree: find\n *\tnext extent, adding a extent(a range of blocks) and removing a extent.\n *\n *   --\trace on a extent status tree\n *\tExtent status tree is protected by inode->i_es_lock.\n *\n *   --\tmemory consumption\n *      Fragmented extent tree will make extent status tree cost too much\n *      memory.  Hence, we will reclaim written/unwritten/hole extents from\n *      the tree under a heavy memory pressure.\n *\n *\n * ==========================================================================\n * 3. Performance analysis\n *\n *   --\toverhead\n *\t1. There is a cache extent for write access, so if writes are\n *\tnot very random, adding space operaions are in O(1) time.\n *\n *   --\tgain\n *\t2. Code is much simpler, more readable, more maintainable and\n *\tmore efficient.\n *\n *\n * ==========================================================================\n * 4. TODO list\n *\n *   -- Refactor delayed space reservation\n *\n *   -- Extent-level locking\n */\n\nstatic struct kmem_cache *ext4_es_cachep;\nstatic struct kmem_cache *ext4_pending_cachep;\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end, int *reserved);\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan);\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei);\nstatic void __revise_pending(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t     ext4_lblk_t len);\n\nint __init ext4_init_es(void)\n{\n\text4_es_cachep = kmem_cache_create(\"ext4_extent_status\",\n\t\t\t\t\t   sizeof(struct extent_status),\n\t\t\t\t\t   0, (SLAB_RECLAIM_ACCOUNT), NULL);\n\tif (ext4_es_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid ext4_exit_es(void)\n{\n\tkmem_cache_destroy(ext4_es_cachep);\n}\n\nvoid ext4_es_init_tree(struct ext4_es_tree *tree)\n{\n\ttree->root = RB_ROOT;\n\ttree->cache_es = NULL;\n}\n\n#ifdef ES_DEBUG__\nstatic void ext4_es_print_tree(struct inode *inode)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\tprintk(KERN_DEBUG \"status extents for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tstruct extent_status *es;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tprintk(KERN_DEBUG \" [%u/%u) %llu %x\",\n\t\t       es->es_lblk, es->es_len,\n\t\t       ext4_es_pblock(es), ext4_es_status(es));\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}\n#else\n#define ext4_es_print_tree(inode)\n#endif\n\nstatic inline ext4_lblk_t ext4_es_end(struct extent_status *es)\n{\n\tBUG_ON(es->es_lblk + es->es_len < es->es_lblk);\n\treturn es->es_lblk + es->es_len - 1;\n}\n\n/*\n * search through the tree for an delayed extent with a given offset.  If\n * it can't be found, try to find next extent.\n */\nstatic struct extent_status *__es_tree_search(struct rb_root *root,\n\t\t\t\t\t      ext4_lblk_t lblk)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct extent_status *es = NULL;\n\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn es;\n\t}\n\n\tif (es && lblk < es->es_lblk)\n\t\treturn es;\n\n\tif (es && lblk > ext4_es_end(es)) {\n\t\tnode = rb_next(&es->rb_node);\n\t\treturn node ? rb_entry(node, struct extent_status, rb_node) :\n\t\t\t      NULL;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * ext4_es_find_extent_range - find extent with specified status within block\n *                             range or next extent following block range in\n *                             extents status tree\n *\n * @inode - file containing the range\n * @matching_fn - pointer to function that matches extents with desired status\n * @lblk - logical block defining start of range\n * @end - logical block defining end of range\n * @es - extent found, if any\n *\n * Find the first extent within the block range specified by @lblk and @end\n * in the extents status tree that satisfies @matching_fn.  If a match\n * is found, it's returned in @es.  If not, and a matching extent is found\n * beyond the block range, it's returned in @es.  If no match is found, an\n * extent is returned in @es whose es_lblk, es_len, and es_pblk components\n * are 0.\n */\nstatic void __es_find_extent_range(struct inode *inode,\n\t\t\t\t   int (*matching_fn)(struct extent_status *es),\n\t\t\t\t   ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t   struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = NULL;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\n\tWARN_ON(es == NULL);\n\tWARN_ON(end < lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\n\t/* see if the extent has been cached */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u) %llu %x\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len,\n\t\t\t\t ext4_es_pblock(es1), ext4_es_status(es1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tes1 = __es_tree_search(&tree->root, lblk);\n\nout:\n\tif (es1 && !matching_fn(es1)) {\n\t\twhile ((node = rb_next(&es1->rb_node)) != NULL) {\n\t\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\t\tif (es1->es_lblk > end) {\n\t\t\t\tes1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (matching_fn(es1))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (es1 && matching_fn(es1)) {\n\t\ttree->cache_es = es1;\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t}\n\n}\n\n/*\n * Locking for __es_find_extent_range() for external use\n */\nvoid ext4_es_find_extent_range(struct inode *inode,\n\t\t\t       int (*matching_fn)(struct extent_status *es),\n\t\t\t       ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t       struct extent_status *es)\n{\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\ttrace_ext4_es_find_extent_range_enter(inode, lblk);\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\t__es_find_extent_range(inode, matching_fn, lblk, end, es);\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_find_extent_range_exit(inode, es);\n}\n\n/*\n * __es_scan_range - search block range for block with specified status\n *                   in extents status tree\n *\n * @inode - file containing the range\n * @matching_fn - pointer to function that matches extents with desired status\n * @lblk - logical block defining start of range\n * @end - logical block defining end of range\n *\n * Returns true if at least one block in the specified block range satisfies\n * the criterion specified by @matching_fn, and false if not.  If at least\n * one extent has the specified status, then there is at least one block\n * in the cluster with that status.  Should only be called by code that has\n * taken i_es_lock.\n */\nstatic bool __es_scan_range(struct inode *inode,\n\t\t\t    int (*matching_fn)(struct extent_status *es),\n\t\t\t    ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct extent_status es;\n\n\t__es_find_extent_range(inode, matching_fn, start, end, &es);\n\tif (es.es_len == 0)\n\t\treturn false;   /* no matching extent in the tree */\n\telse if (es.es_lblk <= start &&\n\t\t start < es.es_lblk + es.es_len)\n\t\treturn true;\n\telse if (start <= es.es_lblk && es.es_lblk <= end)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n/*\n * Locking for __es_scan_range() for external use\n */\nbool ext4_es_scan_range(struct inode *inode,\n\t\t\tint (*matching_fn)(struct extent_status *es),\n\t\t\text4_lblk_t lblk, ext4_lblk_t end)\n{\n\tbool ret;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn false;\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\tret = __es_scan_range(inode, matching_fn, lblk, end);\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\treturn ret;\n}\n\n/*\n * __es_scan_clu - search cluster for block with specified status in\n *                 extents status tree\n *\n * @inode - file containing the cluster\n * @matching_fn - pointer to function that matches extents with desired status\n * @lblk - logical block in cluster to be searched\n *\n * Returns true if at least one extent in the cluster containing @lblk\n * satisfies the criterion specified by @matching_fn, and false if not.  If at\n * least one extent has the specified status, then there is at least one block\n * in the cluster with that status.  Should only be called by code that has\n * taken i_es_lock.\n */\nstatic bool __es_scan_clu(struct inode *inode,\n\t\t\t  int (*matching_fn)(struct extent_status *es),\n\t\t\t  ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t lblk_start, lblk_end;\n\n\tlblk_start = EXT4_LBLK_CMASK(sbi, lblk);\n\tlblk_end = lblk_start + sbi->s_cluster_ratio - 1;\n\n\treturn __es_scan_range(inode, matching_fn, lblk_start, lblk_end);\n}\n\n/*\n * Locking for __es_scan_clu() for external use\n */\nbool ext4_es_scan_clu(struct inode *inode,\n\t\t      int (*matching_fn)(struct extent_status *es),\n\t\t      ext4_lblk_t lblk)\n{\n\tbool ret;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn false;\n\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\tret = __es_scan_clu(inode, matching_fn, lblk);\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\treturn ret;\n}\n\nstatic void ext4_es_list_add(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tif (!list_empty(&ei->i_es_list))\n\t\treturn;\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (list_empty(&ei->i_es_list)) {\n\t\tlist_add_tail(&ei->i_es_list, &sbi->s_es_list);\n\t\tsbi->s_es_nr_inode++;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}\n\nstatic struct extent_status *\next4_es_alloc_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len,\n\t\t     ext4_fsblk_t pblk)\n{\n\tstruct extent_status *es;\n\tes = kmem_cache_alloc(ext4_es_cachep, GFP_ATOMIC);\n\tif (es == NULL)\n\t\treturn NULL;\n\tes->es_lblk = lblk;\n\tes->es_len = len;\n\tes->es_pblk = pblk;\n\n\t/*\n\t * We don't count delayed extent because we never try to reclaim them\n\t */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tif (!EXT4_I(inode)->i_es_shk_nr++)\n\t\t\text4_es_list_add(inode);\n\t\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tEXT4_I(inode)->i_es_all_nr++;\n\tpercpu_counter_inc(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\treturn es;\n}\n\nstatic void ext4_es_free_extent(struct inode *inode, struct extent_status *es)\n{\n\tEXT4_I(inode)->i_es_all_nr--;\n\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->s_es_stats.es_stats_all_cnt);\n\n\t/* Decrease the shrink counter when this es is not delayed */\n\tif (!ext4_es_is_delayed(es)) {\n\t\tBUG_ON(EXT4_I(inode)->i_es_shk_nr == 0);\n\t\tif (!--EXT4_I(inode)->i_es_shk_nr)\n\t\t\text4_es_list_del(inode);\n\t\tpercpu_counter_dec(&EXT4_SB(inode->i_sb)->\n\t\t\t\t\ts_es_stats.es_stats_shk_cnt);\n\t}\n\n\tkmem_cache_free(ext4_es_cachep, es);\n}\n\n/*\n * Check whether or not two extents can be merged\n * Condition:\n *  - logical block number is contiguous\n *  - physical block number is contiguous\n *  - status is equal\n */\nstatic int ext4_es_can_be_merged(struct extent_status *es1,\n\t\t\t\t struct extent_status *es2)\n{\n\tif (ext4_es_type(es1) != ext4_es_type(es2))\n\t\treturn 0;\n\n\tif (((__u64) es1->es_len) + es2->es_len > EXT_MAX_BLOCKS) {\n\t\tpr_warn(\"ES assertion failed when merging extents. \"\n\t\t\t\"The sum of lengths of es1 (%d) and es2 (%d) \"\n\t\t\t\"is bigger than allowed file size (%d)\\n\",\n\t\t\tes1->es_len, es2->es_len, EXT_MAX_BLOCKS);\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (((__u64) es1->es_lblk) + es1->es_len != es2->es_lblk)\n\t\treturn 0;\n\n\tif ((ext4_es_is_written(es1) || ext4_es_is_unwritten(es1)) &&\n\t    (ext4_es_pblock(es1) + es1->es_len == ext4_es_pblock(es2)))\n\t\treturn 1;\n\n\tif (ext4_es_is_hole(es1))\n\t\treturn 1;\n\n\t/* we need to check delayed extent is without unwritten status */\n\tif (ext4_es_is_delayed(es1) && !ext4_es_is_unwritten(es1))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct extent_status *\next4_es_try_to_merge_left(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_prev(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es1, es)) {\n\t\tes1->es_len += es->es_len;\n\t\tif (ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es1);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tes = es1;\n\t}\n\n\treturn es;\n}\n\nstatic struct extent_status *\next4_es_try_to_merge_right(struct inode *inode, struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es1;\n\tstruct rb_node *node;\n\n\tnode = rb_next(&es->rb_node);\n\tif (!node)\n\t\treturn es;\n\n\tes1 = rb_entry(node, struct extent_status, rb_node);\n\tif (ext4_es_can_be_merged(es, es1)) {\n\t\tes->es_len += es1->es_len;\n\t\tif (ext4_es_is_referenced(es1))\n\t\t\text4_es_set_referenced(es);\n\t\trb_erase(node, &tree->root);\n\t\text4_es_free_extent(inode, es1);\n\t}\n\n\treturn es;\n}\n\n#ifdef ES_AGGRESSIVE_TEST\n#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n\nstatic void ext4_es_insert_extent_ext_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent *ex;\n\text4_lblk_t ee_block;\n\text4_fsblk_t ee_start;\n\tunsigned short ee_len;\n\tint depth, ee_status, es_status;\n\n\tpath = ext4_find_extent(inode, es->es_lblk, NULL, EXT4_EX_NOCACHE);\n\tif (IS_ERR(path))\n\t\treturn;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\tif (ex) {\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tee_start = ext4_ext_pblock(ex);\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\tee_status = ext4_ext_is_unwritten(ex) ? 1 : 0;\n\t\tes_status = ext4_es_is_unwritten(es) ? 1 : 0;\n\n\t\t/*\n\t\t * Make sure ex and es are not overlap when we try to insert\n\t\t * a delayed/hole extent.\n\t\t */\n\t\tif (!ext4_es_is_written(es) && !ext4_es_is_unwritten(es)) {\n\t\t\tif (in_range(es->es_lblk, ee_block, ee_len)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu we can find an extent \"\n\t\t\t\t\t\"at block [%d/%d/%llu/%c], but we \"\n\t\t\t\t\t\"want to add a delayed/hole extent \"\n\t\t\t\t\t\"[%d/%d/%llu/%x]\\n\",\n\t\t\t\t\tinode->i_ino, ee_block, ee_len,\n\t\t\t\t\tee_start, ee_status ? 'u' : 'w',\n\t\t\t\t\tes->es_lblk, es->es_len,\n\t\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't check ee_block == es->es_lblk, etc. because es\n\t\t * might be a part of whole extent, vice versa.\n\t\t */\n\t\tif (es->es_lblk < ee_block ||\n\t\t    ext4_es_pblock(es) != ee_start + es->es_lblk - ee_block) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ee_status ^ es_status) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"ex_status [%d/%d/%llu/%c] != \"\n\t\t\t\t\"es_status [%d/%d/%llu/%c]\\n\", inode->i_ino,\n\t\t\t\tee_block, ee_len, ee_start,\n\t\t\t\tee_status ? 'u' : 'w', es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), es_status ? 'u' : 'w');\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We can't find an extent on disk.  So we need to make sure\n\t\t * that we don't want to add an written/unwritten extent.\n\t\t */\n\t\tif (!ext4_es_is_delayed(es) && !ext4_es_is_hole(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"can't find an extent at block %d but we want \"\n\t\t\t\t\"to add a written/unwritten extent \"\n\t\t\t\t\"[%d/%d/%llu/%x]\\n\", inode->i_ino,\n\t\t\t\tes->es_lblk, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n}\n\nstatic void ext4_es_insert_extent_ind_check(struct inode *inode,\n\t\t\t\t\t    struct extent_status *es)\n{\n\tstruct ext4_map_blocks map;\n\tint retval;\n\n\t/*\n\t * Here we call ext4_ind_map_blocks to lookup a block mapping because\n\t * 'Indirect' structure is defined in indirect.c.  So we couldn't\n\t * access direct/indirect tree from outside.  It is too dirty to define\n\t * this function in indirect.c file.\n\t */\n\n\tmap.m_lblk = es->es_lblk;\n\tmap.m_len = es->es_len;\n\n\tretval = ext4_ind_map_blocks(NULL, inode, &map, 0);\n\tif (retval > 0) {\n\t\tif (ext4_es_is_delayed(es) || ext4_es_is_hole(es)) {\n\t\t\t/*\n\t\t\t * We want to add a delayed/hole extent but this\n\t\t\t * block has been allocated.\n\t\t\t */\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can find blocks but we want to add a \"\n\t\t\t\t\"delayed/hole extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t} else if (ext4_es_is_written(es)) {\n\t\t\tif (retval != es->es_len) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu retval %d != es_len %d\\n\",\n\t\t\t\t\tinode->i_ino, retval, es->es_len);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (map.m_pblk != ext4_es_pblock(es)) {\n\t\t\t\tpr_warn(\"ES insert assertion failed for \"\n\t\t\t\t\t\"inode: %lu m_pblk %llu != \"\n\t\t\t\t\t\"es_pblk %llu\\n\",\n\t\t\t\t\tinode->i_ino, map.m_pblk,\n\t\t\t\t\text4_es_pblock(es));\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't need to check unwritten extent because\n\t\t\t * indirect-based file doesn't have it.\n\t\t\t */\n\t\t\tBUG();\n\t\t}\n\t} else if (retval == 0) {\n\t\tif (ext4_es_is_written(es)) {\n\t\t\tpr_warn(\"ES insert assertion failed for inode: %lu \"\n\t\t\t\t\"We can't find the block but we want to add \"\n\t\t\t\t\"a written extent [%d/%d/%llu/%x]\\n\",\n\t\t\t\tinode->i_ino, es->es_lblk, es->es_len,\n\t\t\t\text4_es_pblock(es), ext4_es_status(es));\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n\t/*\n\t * We don't need to worry about the race condition because\n\t * caller takes i_data_sem locking.\n\t */\n\tBUG_ON(!rwsem_is_locked(&EXT4_I(inode)->i_data_sem));\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_es_insert_extent_ext_check(inode, es);\n\telse\n\t\text4_es_insert_extent_ind_check(inode, es);\n}\n#else\nstatic inline void ext4_es_insert_extent_check(struct inode *inode,\n\t\t\t\t\t       struct extent_status *es)\n{\n}\n#endif\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct extent_status *es;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tes = rb_entry(parent, struct extent_status, rb_node);\n\n\t\tif (newes->es_lblk < es->es_lblk) {\n\t\t\tif (ext4_es_can_be_merged(newes, es)) {\n\t\t\t\t/*\n\t\t\t\t * Here we can modify es_lblk directly\n\t\t\t\t * because it isn't overlapped.\n\t\t\t\t */\n\t\t\t\tes->es_lblk = newes->es_lblk;\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t\t    ext4_es_is_unwritten(es))\n\t\t\t\t\text4_es_store_pblock(es,\n\t\t\t\t\t\t\t     newes->es_pblk);\n\t\t\t\tes = ext4_es_try_to_merge_left(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (newes->es_lblk > ext4_es_end(es)) {\n\t\t\tif (ext4_es_can_be_merged(es, newes)) {\n\t\t\t\tes->es_len += newes->es_len;\n\t\t\t\tes = ext4_es_try_to_merge_right(inode, es);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tBUG();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes = ext4_es_alloc_extent(inode, newes->es_lblk, newes->es_len,\n\t\t\t\t  newes->es_pblk);\n\tif (!es)\n\t\treturn -ENOMEM;\n\trb_link_node(&es->rb_node, parent, p);\n\trb_insert_color(&es->rb_node, &tree->root);\n\nout:\n\ttree->cache_es = es;\n\treturn 0;\n}\n\n/*\n * ext4_es_insert_extent() adds information to an inode's extent\n * status tree.\n *\n * Return 0 on success, error code on failure.\n */\nint ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tif ((status & EXTENT_STATUS_DELAYED) &&\n\t    (status & EXTENT_STATUS_WRITTEN)) {\n\t\text4_warning(inode->i_sb, \"Inserting extent [%u/%u] as \"\n\t\t\t\t\" delayed and written which can potentially \"\n\t\t\t\t\" cause data loss.\", lblk, len);\n\t\tWARN_ON(1);\n\t}\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, NULL);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\n\tif (sbi->s_cluster_ratio > 1 && test_opt(inode->i_sb, DELALLOC) &&\n\t    (status & EXTENT_STATUS_WRITTEN ||\n\t     status & EXTENT_STATUS_UNWRITTEN))\n\t\t__revise_pending(inode, lblk, len);\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}\n\n/*\n * ext4_es_cache_extent() inserts information into the extent status\n * tree if and only if there isn't information about the range in\n * question already.\n */\nvoid ext4_es_cache_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status *es;\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_cache_extent(inode, &newes);\n\n\tif (!len)\n\t\treturn;\n\n\tBUG_ON(end < lblk);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\tes = __es_tree_search(&EXT4_I(inode)->i_es_tree.root, lblk);\n\tif (!es || es->es_lblk > end)\n\t\t__es_insert_extent(inode, &newes);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n}\n\n/*\n * ext4_es_lookup_extent() looks up an extent in extent status tree.\n *\n * ext4_es_lookup_extent is called by ext4_map_blocks/ext4_da_map_blocks.\n *\n * Return: 1 on found, 0 on not\n */\nint ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t *next_lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es1))\n\t\t\text4_es_set_referenced(es1);\n\t\tpercpu_counter_inc(&stats->es_stats_cache_hits);\n\t\tif (next_lblk) {\n\t\t\tnode = rb_next(&es1->rb_node);\n\t\t\tif (node) {\n\t\t\t\tes1 = rb_entry(node, struct extent_status,\n\t\t\t\t\t       rb_node);\n\t\t\t\t*next_lblk = es1->es_lblk;\n\t\t\t} else\n\t\t\t\t*next_lblk = 0;\n\t\t}\n\t} else {\n\t\tpercpu_counter_inc(&stats->es_stats_cache_misses);\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}\n\nstruct rsvd_count {\n\tint ndelonly;\n\tbool first_do_lblk_found;\n\text4_lblk_t first_do_lblk;\n\text4_lblk_t last_do_lblk;\n\tstruct extent_status *left_es;\n\tbool partial;\n\text4_lblk_t lclu;\n};\n\n/*\n * init_rsvd - initialize reserved count data before removing block range\n *\t       in file from extent status tree\n *\n * @inode - file containing range\n * @lblk - first block in range\n * @es - pointer to first extent in range\n * @rc - pointer to reserved count data\n *\n * Assumes es is not NULL\n */\nstatic void init_rsvd(struct inode *inode, ext4_lblk_t lblk,\n\t\t      struct extent_status *es, struct rsvd_count *rc)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct rb_node *node;\n\n\trc->ndelonly = 0;\n\n\t/*\n\t * for bigalloc, note the first delonly block in the range has not\n\t * been found, record the extent containing the block to the left of\n\t * the region to be removed, if any, and note that there's no partial\n\t * cluster to track\n\t */\n\tif (sbi->s_cluster_ratio > 1) {\n\t\trc->first_do_lblk_found = false;\n\t\tif (lblk > es->es_lblk) {\n\t\t\trc->left_es = es;\n\t\t} else {\n\t\t\tnode = rb_prev(&es->rb_node);\n\t\t\trc->left_es = node ? rb_entry(node,\n\t\t\t\t\t\t      struct extent_status,\n\t\t\t\t\t\t      rb_node) : NULL;\n\t\t}\n\t\trc->partial = false;\n\t}\n}\n\n/*\n * count_rsvd - count the clusters containing delayed and not unwritten\n *\t\t(delonly) blocks in a range within an extent and add to\n *\t        the running tally in rsvd_count\n *\n * @inode - file containing extent\n * @lblk - first block in range\n * @len - length of range in blocks\n * @es - pointer to extent containing clusters to be counted\n * @rc - pointer to reserved count data\n *\n * Tracks partial clusters found at the beginning and end of extents so\n * they aren't overcounted when they span adjacent extents\n */\nstatic void count_rsvd(struct inode *inode, ext4_lblk_t lblk, long len,\n\t\t       struct extent_status *es, struct rsvd_count *rc)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t i, end, nclu;\n\n\tif (!ext4_es_is_delonly(es))\n\t\treturn;\n\n\tWARN_ON(len <= 0);\n\n\tif (sbi->s_cluster_ratio == 1) {\n\t\trc->ndelonly += (int) len;\n\t\treturn;\n\t}\n\n\t/* bigalloc */\n\n\ti = (lblk < es->es_lblk) ? es->es_lblk : lblk;\n\tend = lblk + (ext4_lblk_t) len - 1;\n\tend = (end > ext4_es_end(es)) ? ext4_es_end(es) : end;\n\n\t/* record the first block of the first delonly extent seen */\n\tif (!rc->first_do_lblk_found) {\n\t\trc->first_do_lblk = i;\n\t\trc->first_do_lblk_found = true;\n\t}\n\n\t/* update the last lblk in the region seen so far */\n\trc->last_do_lblk = end;\n\n\t/*\n\t * if we're tracking a partial cluster and the current extent\n\t * doesn't start with it, count it and stop tracking\n\t */\n\tif (rc->partial && (rc->lclu != EXT4_B2C(sbi, i))) {\n\t\trc->ndelonly++;\n\t\trc->partial = false;\n\t}\n\n\t/*\n\t * if the first cluster doesn't start on a cluster boundary but\n\t * ends on one, count it\n\t */\n\tif (EXT4_LBLK_COFF(sbi, i) != 0) {\n\t\tif (end >= EXT4_LBLK_CFILL(sbi, i)) {\n\t\t\trc->ndelonly++;\n\t\t\trc->partial = false;\n\t\t\ti = EXT4_LBLK_CFILL(sbi, i) + 1;\n\t\t}\n\t}\n\n\t/*\n\t * if the current cluster starts on a cluster boundary, count the\n\t * number of whole delonly clusters in the extent\n\t */\n\tif ((i + sbi->s_cluster_ratio - 1) <= end) {\n\t\tnclu = (end - i + 1) >> sbi->s_cluster_bits;\n\t\trc->ndelonly += nclu;\n\t\ti += nclu << sbi->s_cluster_bits;\n\t}\n\n\t/*\n\t * start tracking a partial cluster if there's a partial at the end\n\t * of the current extent and we're not already tracking one\n\t */\n\tif (!rc->partial && i <= end) {\n\t\trc->partial = true;\n\t\trc->lclu = EXT4_B2C(sbi, i);\n\t}\n}\n\n/*\n * __pr_tree_search - search for a pending cluster reservation\n *\n * @root - root of pending reservation tree\n * @lclu - logical cluster to search for\n *\n * Returns the pending reservation for the cluster identified by @lclu\n * if found.  If not, returns a reservation for the next cluster if any,\n * and if not, returns NULL.\n */\nstatic struct pending_reservation *__pr_tree_search(struct rb_root *root,\n\t\t\t\t\t\t    ext4_lblk_t lclu)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct pending_reservation *pr = NULL;\n\n\twhile (node) {\n\t\tpr = rb_entry(node, struct pending_reservation, rb_node);\n\t\tif (lclu < pr->lclu)\n\t\t\tnode = node->rb_left;\n\t\telse if (lclu > pr->lclu)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn pr;\n\t}\n\tif (pr && lclu < pr->lclu)\n\t\treturn pr;\n\tif (pr && lclu > pr->lclu) {\n\t\tnode = rb_next(&pr->rb_node);\n\t\treturn node ? rb_entry(node, struct pending_reservation,\n\t\t\t\t       rb_node) : NULL;\n\t}\n\treturn NULL;\n}\n\n/*\n * get_rsvd - calculates and returns the number of cluster reservations to be\n *\t      released when removing a block range from the extent status tree\n *\t      and releases any pending reservations within the range\n *\n * @inode - file containing block range\n * @end - last block in range\n * @right_es - pointer to extent containing next block beyond end or NULL\n * @rc - pointer to reserved count data\n *\n * The number of reservations to be released is equal to the number of\n * clusters containing delayed and not unwritten (delonly) blocks within\n * the range, minus the number of clusters still containing delonly blocks\n * at the ends of the range, and minus the number of pending reservations\n * within the range.\n */\nstatic unsigned int get_rsvd(struct inode *inode, ext4_lblk_t end,\n\t\t\t     struct extent_status *right_es,\n\t\t\t     struct rsvd_count *rc)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct pending_reservation *pr;\n\tstruct ext4_pending_tree *tree = &EXT4_I(inode)->i_pending_tree;\n\tstruct rb_node *node;\n\text4_lblk_t first_lclu, last_lclu;\n\tbool left_delonly, right_delonly, count_pending;\n\tstruct extent_status *es;\n\n\tif (sbi->s_cluster_ratio > 1) {\n\t\t/* count any remaining partial cluster */\n\t\tif (rc->partial)\n\t\t\trc->ndelonly++;\n\n\t\tif (rc->ndelonly == 0)\n\t\t\treturn 0;\n\n\t\tfirst_lclu = EXT4_B2C(sbi, rc->first_do_lblk);\n\t\tlast_lclu = EXT4_B2C(sbi, rc->last_do_lblk);\n\n\t\t/*\n\t\t * decrease the delonly count by the number of clusters at the\n\t\t * ends of the range that still contain delonly blocks -\n\t\t * these clusters still need to be reserved\n\t\t */\n\t\tleft_delonly = right_delonly = false;\n\n\t\tes = rc->left_es;\n\t\twhile (es && ext4_es_end(es) >=\n\t\t       EXT4_LBLK_CMASK(sbi, rc->first_do_lblk)) {\n\t\t\tif (ext4_es_is_delonly(es)) {\n\t\t\t\trc->ndelonly--;\n\t\t\t\tleft_delonly = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = rb_prev(&es->rb_node);\n\t\t\tif (!node)\n\t\t\t\tbreak;\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\t}\n\t\tif (right_es && (!left_delonly || first_lclu != last_lclu)) {\n\t\t\tif (end < ext4_es_end(right_es)) {\n\t\t\t\tes = right_es;\n\t\t\t} else {\n\t\t\t\tnode = rb_next(&right_es->rb_node);\n\t\t\t\tes = node ? rb_entry(node, struct extent_status,\n\t\t\t\t\t\t     rb_node) : NULL;\n\t\t\t}\n\t\t\twhile (es && es->es_lblk <=\n\t\t\t       EXT4_LBLK_CFILL(sbi, rc->last_do_lblk)) {\n\t\t\t\tif (ext4_es_is_delonly(es)) {\n\t\t\t\t\trc->ndelonly--;\n\t\t\t\t\tright_delonly = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnode = rb_next(&es->rb_node);\n\t\t\t\tif (!node)\n\t\t\t\t\tbreak;\n\t\t\t\tes = rb_entry(node, struct extent_status,\n\t\t\t\t\t      rb_node);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Determine the block range that should be searched for\n\t\t * pending reservations, if any.  Clusters on the ends of the\n\t\t * original removed range containing delonly blocks are\n\t\t * excluded.  They've already been accounted for and it's not\n\t\t * possible to determine if an associated pending reservation\n\t\t * should be released with the information available in the\n\t\t * extents status tree.\n\t\t */\n\t\tif (first_lclu == last_lclu) {\n\t\t\tif (left_delonly | right_delonly)\n\t\t\t\tcount_pending = false;\n\t\t\telse\n\t\t\t\tcount_pending = true;\n\t\t} else {\n\t\t\tif (left_delonly)\n\t\t\t\tfirst_lclu++;\n\t\t\tif (right_delonly)\n\t\t\t\tlast_lclu--;\n\t\t\tif (first_lclu <= last_lclu)\n\t\t\t\tcount_pending = true;\n\t\t\telse\n\t\t\t\tcount_pending = false;\n\t\t}\n\n\t\t/*\n\t\t * a pending reservation found between first_lclu and last_lclu\n\t\t * represents an allocated cluster that contained at least one\n\t\t * delonly block, so the delonly total must be reduced by one\n\t\t * for each pending reservation found and released\n\t\t */\n\t\tif (count_pending) {\n\t\t\tpr = __pr_tree_search(&tree->root, first_lclu);\n\t\t\twhile (pr && pr->lclu <= last_lclu) {\n\t\t\t\trc->ndelonly--;\n\t\t\t\tnode = rb_next(&pr->rb_node);\n\t\t\t\trb_erase(&pr->rb_node, &tree->root);\n\t\t\t\tkmem_cache_free(ext4_pending_cachep, pr);\n\t\t\t\tif (!node)\n\t\t\t\t\tbreak;\n\t\t\t\tpr = rb_entry(node, struct pending_reservation,\n\t\t\t\t\t      rb_node);\n\t\t\t}\n\t\t}\n\t}\n\treturn rc->ndelonly;\n}\n\n\n/*\n * __es_remove_extent - removes block range from extent status tree\n *\n * @inode - file containing range\n * @lblk - first block in range\n * @end - last block in range\n * @reserved - number of cluster reservations released\n *\n * If @reserved is not NULL and delayed allocation is enabled, counts\n * block/cluster reservations freed by removing range and if bigalloc\n * enabled cancels pending reservations as needed. Returns 0 on success,\n * error code on failure.\n */\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end, int *reserved)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct rb_node *node;\n\tstruct extent_status *es;\n\tstruct extent_status orig_es;\n\text4_lblk_t len1, len2;\n\text4_fsblk_t block;\n\tint err;\n\tbool count_reserved = true;\n\tstruct rsvd_count rc;\n\n\tif (reserved == NULL || !test_opt(inode->i_sb, DELALLOC))\n\t\tcount_reserved = false;\nretry:\n\terr = 0;\n\n\tes = __es_tree_search(&tree->root, lblk);\n\tif (!es)\n\t\tgoto out;\n\tif (es->es_lblk > end)\n\t\tgoto out;\n\n\t/* Simply invalidate cache_es. */\n\ttree->cache_es = NULL;\n\tif (count_reserved)\n\t\tinit_rsvd(inode, lblk, es, &rc);\n\n\torig_es.es_lblk = es->es_lblk;\n\torig_es.es_len = es->es_len;\n\torig_es.es_pblk = es->es_pblk;\n\n\tlen1 = lblk > es->es_lblk ? lblk - es->es_lblk : 0;\n\tlen2 = ext4_es_end(es) > end ? ext4_es_end(es) - end : 0;\n\tif (len1 > 0)\n\t\tes->es_len = len1;\n\tif (len2 > 0) {\n\t\tif (len1 > 0) {\n\t\t\tstruct extent_status newes;\n\n\t\t\tnewes.es_lblk = end + 1;\n\t\t\tnewes.es_len = len2;\n\t\t\tblock = 0x7FDEADBEEFULL;\n\t\t\tif (ext4_es_is_written(&orig_es) ||\n\t\t\t    ext4_es_is_unwritten(&orig_es))\n\t\t\t\tblock = ext4_es_pblock(&orig_es) +\n\t\t\t\t\torig_es.es_len - len2;\n\t\t\text4_es_store_pblock_status(&newes, block,\n\t\t\t\t\t\t    ext4_es_status(&orig_es));\n\t\t\terr = __es_insert_extent(inode, &newes);\n\t\t\tif (err) {\n\t\t\t\tes->es_lblk = orig_es.es_lblk;\n\t\t\t\tes->es_len = orig_es.es_len;\n\t\t\t\tif ((err == -ENOMEM) &&\n\t\t\t\t    __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t\t128, EXT4_I(inode)))\n\t\t\t\t\tgoto retry;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tes->es_lblk = end + 1;\n\t\t\tes->es_len = len2;\n\t\t\tif (ext4_es_is_written(es) ||\n\t\t\t    ext4_es_is_unwritten(es)) {\n\t\t\t\tblock = orig_es.es_pblk + orig_es.es_len - len2;\n\t\t\t\text4_es_store_pblock(es, block);\n\t\t\t}\n\t\t}\n\t\tif (count_reserved)\n\t\t\tcount_rsvd(inode, lblk, orig_es.es_len - len1 - len2,\n\t\t\t\t   &orig_es, &rc);\n\t\tgoto out;\n\t}\n\n\tif (len1 > 0) {\n\t\tif (count_reserved)\n\t\t\tcount_rsvd(inode, lblk, orig_es.es_len - len1,\n\t\t\t\t   &orig_es, &rc);\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (node)\n\t\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\telse\n\t\t\tes = NULL;\n\t}\n\n\twhile (es && ext4_es_end(es) <= end) {\n\t\tif (count_reserved)\n\t\t\tcount_rsvd(inode, es->es_lblk, es->es_len, es, &rc);\n\t\tnode = rb_next(&es->rb_node);\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\tif (!node) {\n\t\t\tes = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\tif (es && es->es_lblk < end + 1) {\n\t\text4_lblk_t orig_len = es->es_len;\n\n\t\tlen1 = ext4_es_end(es) - end;\n\t\tif (count_reserved)\n\t\t\tcount_rsvd(inode, es->es_lblk, orig_len - len1,\n\t\t\t\t   es, &rc);\n\t\tes->es_lblk = end + 1;\n\t\tes->es_len = len1;\n\t\tif (ext4_es_is_written(es) || ext4_es_is_unwritten(es)) {\n\t\t\tblock = es->es_pblk + orig_len - len1;\n\t\t\text4_es_store_pblock(es, block);\n\t\t}\n\t}\n\n\tif (count_reserved)\n\t\t*reserved = get_rsvd(inode, end, es, &rc);\nout:\n\treturn err;\n}\n\n/*\n * ext4_es_remove_extent - removes block range from extent status tree\n *\n * @inode - file containing range\n * @lblk - first block in range\n * @len - number of blocks to remove\n *\n * Reduces block/cluster reservation count and for bigalloc cancels pending\n * reservations as needed. Returns 0 on success, error code on failure.\n */\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\tint reserved = 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn err;\n}\n\nstatic int __es_shrink(struct ext4_sb_info *sbi, int nr_to_scan,\n\t\t       struct ext4_inode_info *locked_ei)\n{\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_es_stats *es_stats;\n\tktime_t start_time;\n\tu64 scan_time;\n\tint nr_to_walk;\n\tint nr_shrunk = 0;\n\tint retried = 0, nr_skipped = 0;\n\n\tes_stats = &sbi->s_es_stats;\n\tstart_time = ktime_get();\n\nretry:\n\tspin_lock(&sbi->s_es_lock);\n\tnr_to_walk = sbi->s_es_nr_inode;\n\twhile (nr_to_walk-- > 0) {\n\t\tif (list_empty(&sbi->s_es_list)) {\n\t\t\tspin_unlock(&sbi->s_es_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tei = list_first_entry(&sbi->s_es_list, struct ext4_inode_info,\n\t\t\t\t      i_es_list);\n\t\t/* Move the inode to the tail */\n\t\tlist_move_tail(&ei->i_es_list, &sbi->s_es_list);\n\n\t\t/*\n\t\t * Normally we try hard to avoid shrinking precached inodes,\n\t\t * but we will as a last resort.\n\t\t */\n\t\tif (!retried && ext4_test_inode_state(&ei->vfs_inode,\n\t\t\t\t\t\tEXT4_STATE_EXT_PRECACHED)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ei == locked_ei || !write_trylock(&ei->i_es_lock)) {\n\t\t\tnr_skipped++;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Now we hold i_es_lock which protects us from inode reclaim\n\t\t * freeing inode under us\n\t\t */\n\t\tspin_unlock(&sbi->s_es_lock);\n\n\t\tnr_shrunk += es_reclaim_extents(ei, &nr_to_scan);\n\t\twrite_unlock(&ei->i_es_lock);\n\n\t\tif (nr_to_scan <= 0)\n\t\t\tgoto out;\n\t\tspin_lock(&sbi->s_es_lock);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\t/*\n\t * If we skipped any inodes, and we weren't able to make any\n\t * forward progress, try again to scan precached inodes.\n\t */\n\tif ((nr_shrunk == 0) && nr_skipped && !retried) {\n\t\tretried++;\n\t\tgoto retry;\n\t}\n\n\tif (locked_ei && nr_shrunk == 0)\n\t\tnr_shrunk = es_reclaim_extents(locked_ei, &nr_to_scan);\n\nout:\n\tscan_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\tif (likely(es_stats->es_stats_scan_time))\n\t\tes_stats->es_stats_scan_time = (scan_time +\n\t\t\t\tes_stats->es_stats_scan_time*3) / 4;\n\telse\n\t\tes_stats->es_stats_scan_time = scan_time;\n\tif (scan_time > es_stats->es_stats_max_scan_time)\n\t\tes_stats->es_stats_max_scan_time = scan_time;\n\tif (likely(es_stats->es_stats_shrunk))\n\t\tes_stats->es_stats_shrunk = (nr_shrunk +\n\t\t\t\tes_stats->es_stats_shrunk*3) / 4;\n\telse\n\t\tes_stats->es_stats_shrunk = nr_shrunk;\n\n\ttrace_ext4_es_shrink(sbi->s_sb, nr_shrunk, scan_time,\n\t\t\t     nr_skipped, retried);\n\treturn nr_shrunk;\n}\n\nstatic unsigned long ext4_es_count(struct shrinker *shrink,\n\t\t\t\t   struct shrink_control *sc)\n{\n\tunsigned long nr;\n\tstruct ext4_sb_info *sbi;\n\n\tsbi = container_of(shrink, struct ext4_sb_info, s_es_shrinker);\n\tnr = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\n\ttrace_ext4_es_shrink_count(sbi->s_sb, sc->nr_to_scan, nr);\n\treturn nr;\n}\n\nstatic unsigned long ext4_es_scan(struct shrinker *shrink,\n\t\t\t\t  struct shrink_control *sc)\n{\n\tstruct ext4_sb_info *sbi = container_of(shrink,\n\t\t\t\t\tstruct ext4_sb_info, s_es_shrinker);\n\tint nr_to_scan = sc->nr_to_scan;\n\tint ret, nr_shrunk;\n\n\tret = percpu_counter_read_positive(&sbi->s_es_stats.es_stats_shk_cnt);\n\ttrace_ext4_es_shrink_scan_enter(sbi->s_sb, nr_to_scan, ret);\n\n\tif (!nr_to_scan)\n\t\treturn ret;\n\n\tnr_shrunk = __es_shrink(sbi, nr_to_scan, NULL);\n\n\ttrace_ext4_es_shrink_scan_exit(sbi->s_sb, nr_shrunk, ret);\n\treturn nr_shrunk;\n}\n\nint ext4_seq_es_shrinker_info_show(struct seq_file *seq, void *v)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB((struct super_block *) seq->private);\n\tstruct ext4_es_stats *es_stats = &sbi->s_es_stats;\n\tstruct ext4_inode_info *ei, *max = NULL;\n\tunsigned int inode_cnt = 0;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\n\t/* here we just find an inode that has the max nr. of objects */\n\tspin_lock(&sbi->s_es_lock);\n\tlist_for_each_entry(ei, &sbi->s_es_list, i_es_list) {\n\t\tinode_cnt++;\n\t\tif (max && max->i_es_all_nr < ei->i_es_all_nr)\n\t\t\tmax = ei;\n\t\telse if (!max)\n\t\t\tmax = ei;\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n\n\tseq_printf(seq, \"stats:\\n  %lld objects\\n  %lld reclaimable objects\\n\",\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_all_cnt),\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_shk_cnt));\n\tseq_printf(seq, \"  %lld/%lld cache hits/misses\\n\",\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_cache_hits),\n\t\t   percpu_counter_sum_positive(&es_stats->es_stats_cache_misses));\n\tif (inode_cnt)\n\t\tseq_printf(seq, \"  %d inodes on list\\n\", inode_cnt);\n\n\tseq_printf(seq, \"average:\\n  %llu us scan time\\n\",\n\t    div_u64(es_stats->es_stats_scan_time, 1000));\n\tseq_printf(seq, \"  %lu shrunk objects\\n\", es_stats->es_stats_shrunk);\n\tif (inode_cnt)\n\t\tseq_printf(seq,\n\t\t    \"maximum:\\n  %lu inode (%u objects, %u reclaimable)\\n\"\n\t\t    \"  %llu us max scan time\\n\",\n\t\t    max->vfs_inode.i_ino, max->i_es_all_nr, max->i_es_shk_nr,\n\t\t    div_u64(es_stats->es_stats_max_scan_time, 1000));\n\n\treturn 0;\n}\n\nint ext4_es_register_shrinker(struct ext4_sb_info *sbi)\n{\n\tint err;\n\n\t/* Make sure we have enough bits for physical block number */\n\tBUILD_BUG_ON(ES_SHIFT < 48);\n\tINIT_LIST_HEAD(&sbi->s_es_list);\n\tsbi->s_es_nr_inode = 0;\n\tspin_lock_init(&sbi->s_es_lock);\n\tsbi->s_es_stats.es_stats_shrunk = 0;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_cache_hits, 0,\n\t\t\t\t  GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_cache_misses, 0,\n\t\t\t\t  GFP_KERNEL);\n\tif (err)\n\t\tgoto err1;\n\tsbi->s_es_stats.es_stats_scan_time = 0;\n\tsbi->s_es_stats.es_stats_max_scan_time = 0;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_all_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err2;\n\terr = percpu_counter_init(&sbi->s_es_stats.es_stats_shk_cnt, 0, GFP_KERNEL);\n\tif (err)\n\t\tgoto err3;\n\n\tsbi->s_es_shrinker.scan_objects = ext4_es_scan;\n\tsbi->s_es_shrinker.count_objects = ext4_es_count;\n\tsbi->s_es_shrinker.seeks = DEFAULT_SEEKS;\n\terr = register_shrinker(&sbi->s_es_shrinker);\n\tif (err)\n\t\tgoto err4;\n\n\treturn 0;\nerr4:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\nerr3:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\nerr2:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_cache_misses);\nerr1:\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_cache_hits);\n\treturn err;\n}\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_cache_hits);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_cache_misses);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}\n\n/*\n * Shrink extents in given inode from ei->i_es_shrink_lblk till end. Scan at\n * most *nr_to_scan extents, update *nr_to_scan accordingly.\n *\n * Return 0 if we hit end of tree / interval, 1 if we exhausted nr_to_scan.\n * Increment *nr_shrunk by the number of reclaimed extents. Also update\n * ei->i_es_shrink_lblk to where we should continue scanning.\n */\nstatic int es_do_reclaim_extents(struct ext4_inode_info *ei, ext4_lblk_t end,\n\t\t\t\t int *nr_to_scan, int *nr_shrunk)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tstruct ext4_es_tree *tree = &ei->i_es_tree;\n\tstruct extent_status *es;\n\tstruct rb_node *node;\n\n\tes = __es_tree_search(&tree->root, ei->i_es_shrink_lblk);\n\tif (!es)\n\t\tgoto out_wrap;\n\n\twhile (*nr_to_scan > 0) {\n\t\tif (es->es_lblk > end) {\n\t\t\tei->i_es_shrink_lblk = end + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\t(*nr_to_scan)--;\n\t\tnode = rb_next(&es->rb_node);\n\t\t/*\n\t\t * We can't reclaim delayed extent from status tree because\n\t\t * fiemap, bigallic, and seek_data/hole need to use it.\n\t\t */\n\t\tif (ext4_es_is_delayed(es))\n\t\t\tgoto next;\n\t\tif (ext4_es_is_referenced(es)) {\n\t\t\text4_es_clear_referenced(es);\n\t\t\tgoto next;\n\t\t}\n\n\t\trb_erase(&es->rb_node, &tree->root);\n\t\text4_es_free_extent(inode, es);\n\t\t(*nr_shrunk)++;\nnext:\n\t\tif (!node)\n\t\t\tgoto out_wrap;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\tei->i_es_shrink_lblk = es->es_lblk;\n\treturn 1;\nout_wrap:\n\tei->i_es_shrink_lblk = 0;\n\treturn 0;\n}\n\nstatic int es_reclaim_extents(struct ext4_inode_info *ei, int *nr_to_scan)\n{\n\tstruct inode *inode = &ei->vfs_inode;\n\tint nr_shrunk = 0;\n\text4_lblk_t start = ei->i_es_shrink_lblk;\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\n\tif (ei->i_es_shk_nr == 0)\n\t\treturn 0;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_EXT_PRECACHED) &&\n\t    __ratelimit(&_rs))\n\t\text4_warning(inode->i_sb, \"forced shrink of precached extents\");\n\n\tif (!es_do_reclaim_extents(ei, EXT_MAX_BLOCKS, nr_to_scan, &nr_shrunk) &&\n\t    start != 0)\n\t\tes_do_reclaim_extents(ei, start - 1, nr_to_scan, &nr_shrunk);\n\n\tei->i_es_tree.cache_es = NULL;\n\treturn nr_shrunk;\n}\n\n/*\n * Called to support EXT4_IOC_CLEAR_ES_CACHE.  We can only remove\n * discretionary entries from the extent status cache.  (Some entries\n * must be present for proper operations.)\n */\nvoid ext4_clear_inode_es(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct extent_status *es;\n\tstruct ext4_es_tree *tree;\n\tstruct rb_node *node;\n\n\twrite_lock(&ei->i_es_lock);\n\ttree = &EXT4_I(inode)->i_es_tree;\n\ttree->cache_es = NULL;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t\tnode = rb_next(node);\n\t\tif (!ext4_es_is_delayed(es)) {\n\t\t\trb_erase(&es->rb_node, &tree->root);\n\t\t\text4_es_free_extent(inode, es);\n\t\t}\n\t}\n\text4_clear_inode_state(inode, EXT4_STATE_EXT_PRECACHED);\n\twrite_unlock(&ei->i_es_lock);\n}\n\n#ifdef ES_DEBUG__\nstatic void ext4_print_pending_tree(struct inode *inode)\n{\n\tstruct ext4_pending_tree *tree;\n\tstruct rb_node *node;\n\tstruct pending_reservation *pr;\n\n\tprintk(KERN_DEBUG \"pending reservations for inode %lu:\", inode->i_ino);\n\ttree = &EXT4_I(inode)->i_pending_tree;\n\tnode = rb_first(&tree->root);\n\twhile (node) {\n\t\tpr = rb_entry(node, struct pending_reservation, rb_node);\n\t\tprintk(KERN_DEBUG \" %u\", pr->lclu);\n\t\tnode = rb_next(node);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n}\n#else\n#define ext4_print_pending_tree(inode)\n#endif\n\nint __init ext4_init_pending(void)\n{\n\text4_pending_cachep = kmem_cache_create(\"ext4_pending_reservation\",\n\t\t\t\t\t   sizeof(struct pending_reservation),\n\t\t\t\t\t   0, (SLAB_RECLAIM_ACCOUNT), NULL);\n\tif (ext4_pending_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid ext4_exit_pending(void)\n{\n\tkmem_cache_destroy(ext4_pending_cachep);\n}\n\nvoid ext4_init_pending_tree(struct ext4_pending_tree *tree)\n{\n\ttree->root = RB_ROOT;\n}\n\n/*\n * __get_pending - retrieve a pointer to a pending reservation\n *\n * @inode - file containing the pending cluster reservation\n * @lclu - logical cluster of interest\n *\n * Returns a pointer to a pending reservation if it's a member of\n * the set, and NULL if not.  Must be called holding i_es_lock.\n */\nstatic struct pending_reservation *__get_pending(struct inode *inode,\n\t\t\t\t\t\t ext4_lblk_t lclu)\n{\n\tstruct ext4_pending_tree *tree;\n\tstruct rb_node *node;\n\tstruct pending_reservation *pr = NULL;\n\n\ttree = &EXT4_I(inode)->i_pending_tree;\n\tnode = (&tree->root)->rb_node;\n\n\twhile (node) {\n\t\tpr = rb_entry(node, struct pending_reservation, rb_node);\n\t\tif (lclu < pr->lclu)\n\t\t\tnode = node->rb_left;\n\t\telse if (lclu > pr->lclu)\n\t\t\tnode = node->rb_right;\n\t\telse if (lclu == pr->lclu)\n\t\t\treturn pr;\n\t}\n\treturn NULL;\n}\n\n/*\n * __insert_pending - adds a pending cluster reservation to the set of\n *                    pending reservations\n *\n * @inode - file containing the cluster\n * @lblk - logical block in the cluster to be added\n *\n * Returns 0 on successful insertion and -ENOMEM on failure.  If the\n * pending reservation is already in the set, returns successfully.\n */\nstatic int __insert_pending(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_pending_tree *tree = &EXT4_I(inode)->i_pending_tree;\n\tstruct rb_node **p = &tree->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_reservation *pr;\n\text4_lblk_t lclu;\n\tint ret = 0;\n\n\tlclu = EXT4_B2C(sbi, lblk);\n\t/* search to find parent for insertion */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tpr = rb_entry(parent, struct pending_reservation, rb_node);\n\n\t\tif (lclu < pr->lclu) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (lclu > pr->lclu) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\t/* pending reservation already inserted */\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpr = kmem_cache_alloc(ext4_pending_cachep, GFP_ATOMIC);\n\tif (pr == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpr->lclu = lclu;\n\n\trb_link_node(&pr->rb_node, parent, p);\n\trb_insert_color(&pr->rb_node, &tree->root);\n\nout:\n\treturn ret;\n}\n\n/*\n * __remove_pending - removes a pending cluster reservation from the set\n *                    of pending reservations\n *\n * @inode - file containing the cluster\n * @lblk - logical block in the pending cluster reservation to be removed\n *\n * Returns successfully if pending reservation is not a member of the set.\n */\nstatic void __remove_pending(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct pending_reservation *pr;\n\tstruct ext4_pending_tree *tree;\n\n\tpr = __get_pending(inode, EXT4_B2C(sbi, lblk));\n\tif (pr != NULL) {\n\t\ttree = &EXT4_I(inode)->i_pending_tree;\n\t\trb_erase(&pr->rb_node, &tree->root);\n\t\tkmem_cache_free(ext4_pending_cachep, pr);\n\t}\n}\n\n/*\n * ext4_remove_pending - removes a pending cluster reservation from the set\n *                       of pending reservations\n *\n * @inode - file containing the cluster\n * @lblk - logical block in the pending cluster reservation to be removed\n *\n * Locking for external use of __remove_pending.\n */\nvoid ext4_remove_pending(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\twrite_lock(&ei->i_es_lock);\n\t__remove_pending(inode, lblk);\n\twrite_unlock(&ei->i_es_lock);\n}\n\n/*\n * ext4_is_pending - determine whether a cluster has a pending reservation\n *                   on it\n *\n * @inode - file containing the cluster\n * @lblk - logical block in the cluster\n *\n * Returns true if there's a pending reservation for the cluster in the\n * set of pending reservations, and false if not.\n */\nbool ext4_is_pending(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tbool ret;\n\n\tread_lock(&ei->i_es_lock);\n\tret = (bool)(__get_pending(inode, EXT4_B2C(sbi, lblk)) != NULL);\n\tread_unlock(&ei->i_es_lock);\n\n\treturn ret;\n}\n\n/*\n * ext4_es_insert_delayed_block - adds a delayed block to the extents status\n *                                tree, adding a pending reservation where\n *                                needed\n *\n * @inode - file containing the newly added block\n * @lblk - logical block to be added\n * @allocated - indicates whether a physical cluster has been allocated for\n *              the logical cluster that contains the block\n *\n * Returns 0 on success, negative error code on failure.\n */\nint ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t bool allocated)\n{\n\tstruct extent_status newes;\n\tint err = 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn 0;\n\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\n\terr = __es_remove_extent(inode, lblk, lblk, NULL);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err != 0)\n\t\tgoto error;\n\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\n\treturn err;\n}\n\n/*\n * __es_delayed_clu - count number of clusters containing blocks that\n *                    are delayed only\n *\n * @inode - file containing block range\n * @start - logical block defining start of range\n * @end - logical block defining end of range\n *\n * Returns the number of clusters containing only delayed (not delayed\n * and unwritten) blocks in the range specified by @start and @end.  Any\n * cluster or part of a cluster within the range and containing a delayed\n * and not unwritten block within the range is counted as a whole cluster.\n */\nstatic unsigned int __es_delayed_clu(struct inode *inode, ext4_lblk_t start,\n\t\t\t\t     ext4_lblk_t end)\n{\n\tstruct ext4_es_tree *tree = &EXT4_I(inode)->i_es_tree;\n\tstruct extent_status *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct rb_node *node;\n\text4_lblk_t first_lclu, last_lclu;\n\tunsigned long long last_counted_lclu;\n\tunsigned int n = 0;\n\n\t/* guaranteed to be unequal to any ext4_lblk_t value */\n\tlast_counted_lclu = ~0ULL;\n\n\tes = __es_tree_search(&tree->root, start);\n\n\twhile (es && (es->es_lblk <= end)) {\n\t\tif (ext4_es_is_delonly(es)) {\n\t\t\tif (es->es_lblk <= start)\n\t\t\t\tfirst_lclu = EXT4_B2C(sbi, start);\n\t\t\telse\n\t\t\t\tfirst_lclu = EXT4_B2C(sbi, es->es_lblk);\n\n\t\t\tif (ext4_es_end(es) >= end)\n\t\t\t\tlast_lclu = EXT4_B2C(sbi, end);\n\t\t\telse\n\t\t\t\tlast_lclu = EXT4_B2C(sbi, ext4_es_end(es));\n\n\t\t\tif (first_lclu == last_counted_lclu)\n\t\t\t\tn += last_lclu - first_lclu;\n\t\t\telse\n\t\t\t\tn += last_lclu - first_lclu + 1;\n\t\t\tlast_counted_lclu = last_lclu;\n\t\t}\n\t\tnode = rb_next(&es->rb_node);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tes = rb_entry(node, struct extent_status, rb_node);\n\t}\n\n\treturn n;\n}\n\n/*\n * ext4_es_delayed_clu - count number of clusters containing blocks that\n *                       are both delayed and unwritten\n *\n * @inode - file containing block range\n * @lblk - logical block defining start of range\n * @len - number of blocks in range\n *\n * Locking for external use of __es_delayed_clu().\n */\nunsigned int ext4_es_delayed_clu(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t ext4_lblk_t len)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_lblk_t end;\n\tunsigned int n;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tend = lblk + len - 1;\n\tWARN_ON(end < lblk);\n\n\tread_lock(&ei->i_es_lock);\n\n\tn = __es_delayed_clu(inode, lblk, end);\n\n\tread_unlock(&ei->i_es_lock);\n\n\treturn n;\n}\n\n/*\n * __revise_pending - makes, cancels, or leaves unchanged pending cluster\n *                    reservations for a specified block range depending\n *                    upon the presence or absence of delayed blocks\n *                    outside the range within clusters at the ends of the\n *                    range\n *\n * @inode - file containing the range\n * @lblk - logical block defining the start of range\n * @len  - length of range in blocks\n *\n * Used after a newly allocated extent is added to the extents status tree.\n * Requires that the extents in the range have either written or unwritten\n * status.  Must be called while holding i_es_lock.\n */\nstatic void __revise_pending(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t     ext4_lblk_t len)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t end = lblk + len - 1;\n\text4_lblk_t first, last;\n\tbool f_del = false, l_del = false;\n\n\tif (len == 0)\n\t\treturn;\n\n\t/*\n\t * Two cases - block range within single cluster and block range\n\t * spanning two or more clusters.  Note that a cluster belonging\n\t * to a range starting and/or ending on a cluster boundary is treated\n\t * as if it does not contain a delayed extent.  The new range may\n\t * have allocated space for previously delayed blocks out to the\n\t * cluster boundary, requiring that any pre-existing pending\n\t * reservation be canceled.  Because this code only looks at blocks\n\t * outside the range, it should revise pending reservations\n\t * correctly even if the extent represented by the range can't be\n\t * inserted in the extents status tree due to ENOSPC.\n\t */\n\n\tif (EXT4_B2C(sbi, lblk) == EXT4_B2C(sbi, end)) {\n\t\tfirst = EXT4_LBLK_CMASK(sbi, lblk);\n\t\tif (first != lblk)\n\t\t\tf_del = __es_scan_range(inode, &ext4_es_is_delonly,\n\t\t\t\t\t\tfirst, lblk - 1);\n\t\tif (f_del) {\n\t\t\t__insert_pending(inode, first);\n\t\t} else {\n\t\t\tlast = EXT4_LBLK_CMASK(sbi, end) +\n\t\t\t       sbi->s_cluster_ratio - 1;\n\t\t\tif (last != end)\n\t\t\t\tl_del = __es_scan_range(inode,\n\t\t\t\t\t\t\t&ext4_es_is_delonly,\n\t\t\t\t\t\t\tend + 1, last);\n\t\t\tif (l_del)\n\t\t\t\t__insert_pending(inode, last);\n\t\t\telse\n\t\t\t\t__remove_pending(inode, last);\n\t\t}\n\t} else {\n\t\tfirst = EXT4_LBLK_CMASK(sbi, lblk);\n\t\tif (first != lblk)\n\t\t\tf_del = __es_scan_range(inode, &ext4_es_is_delonly,\n\t\t\t\t\t\tfirst, lblk - 1);\n\t\tif (f_del)\n\t\t\t__insert_pending(inode, first);\n\t\telse\n\t\t\t__remove_pending(inode, first);\n\n\t\tlast = EXT4_LBLK_CMASK(sbi, end) + sbi->s_cluster_ratio - 1;\n\t\tif (last != end)\n\t\t\tl_del = __es_scan_range(inode, &ext4_es_is_delonly,\n\t\t\t\t\t\tend + 1, last);\n\t\tif (l_del)\n\t\t\t__insert_pending(inode, last);\n\t\telse\n\t\t\t__remove_pending(inode, last);\n\t}\n}\n"}, "1": {"id": 1, "path": "/src/include/trace/events/ext4.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM ext4\n\n#if !defined(_TRACE_EXT4_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_EXT4_H\n\n#include <linux/writeback.h>\n#include <linux/tracepoint.h>\n\nstruct ext4_allocation_context;\nstruct ext4_allocation_request;\nstruct ext4_extent;\nstruct ext4_prealloc_space;\nstruct ext4_inode_info;\nstruct mpage_da_data;\nstruct ext4_map_blocks;\nstruct extent_status;\nstruct ext4_fsmap;\nstruct partial_cluster;\n\n#define EXT4_I(inode) (container_of(inode, struct ext4_inode_info, vfs_inode))\n\n#define show_mballoc_flags(flags) __print_flags(flags, \"|\",\t\\\n\t{ EXT4_MB_HINT_MERGE,\t\t\"HINT_MERGE\" },\t\t\\\n\t{ EXT4_MB_HINT_RESERVED,\t\"HINT_RESV\" },\t\t\\\n\t{ EXT4_MB_HINT_METADATA,\t\"HINT_MDATA\" },\t\t\\\n\t{ EXT4_MB_HINT_FIRST,\t\t\"HINT_FIRST\" },\t\t\\\n\t{ EXT4_MB_HINT_BEST,\t\t\"HINT_BEST\" },\t\t\\\n\t{ EXT4_MB_HINT_DATA,\t\t\"HINT_DATA\" },\t\t\\\n\t{ EXT4_MB_HINT_NOPREALLOC,\t\"HINT_NOPREALLOC\" },\t\\\n\t{ EXT4_MB_HINT_GROUP_ALLOC,\t\"HINT_GRP_ALLOC\" },\t\\\n\t{ EXT4_MB_HINT_GOAL_ONLY,\t\"HINT_GOAL_ONLY\" },\t\\\n\t{ EXT4_MB_HINT_TRY_GOAL,\t\"HINT_TRY_GOAL\" },\t\\\n\t{ EXT4_MB_DELALLOC_RESERVED,\t\"DELALLOC_RESV\" },\t\\\n\t{ EXT4_MB_STREAM_ALLOC,\t\t\"STREAM_ALLOC\" },\t\\\n\t{ EXT4_MB_USE_ROOT_BLOCKS,\t\"USE_ROOT_BLKS\" },\t\\\n\t{ EXT4_MB_USE_RESERVED,\t\t\"USE_RESV\" },\t\t\\\n\t{ EXT4_MB_STRICT_CHECK,\t\t\"STRICT_CHECK\" })\n\n#define show_map_flags(flags) __print_flags(flags, \"|\",\t\t\t\\\n\t{ EXT4_GET_BLOCKS_CREATE,\t\t\"CREATE\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_UNWRIT_EXT,\t\t\"UNWRIT\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_DELALLOC_RESERVE,\t\"DELALLOC\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_PRE_IO,\t\t\"PRE_IO\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_CONVERT,\t\t\"CONVERT\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_METADATA_NOFAIL,\t\"METADATA_NOFAIL\" },\t\\\n\t{ EXT4_GET_BLOCKS_NO_NORMALIZE,\t\t\"NO_NORMALIZE\" },\t\\\n\t{ EXT4_GET_BLOCKS_CONVERT_UNWRITTEN,\t\"CONVERT_UNWRITTEN\" },  \\\n\t{ EXT4_GET_BLOCKS_ZERO,\t\t\t\"ZERO\" },\t\t\\\n\t{ EXT4_GET_BLOCKS_IO_SUBMIT,\t\t\"IO_SUBMIT\" },\t\t\\\n\t{ EXT4_EX_NOCACHE,\t\t\t\"EX_NOCACHE\" })\n\n/*\n * __print_flags() requires that all enum values be wrapped in the\n * TRACE_DEFINE_ENUM macro so that the enum value can be encoded in the ftrace\n * ring buffer.\n */\nTRACE_DEFINE_ENUM(BH_New);\nTRACE_DEFINE_ENUM(BH_Mapped);\nTRACE_DEFINE_ENUM(BH_Unwritten);\nTRACE_DEFINE_ENUM(BH_Boundary);\n\n#define show_mflags(flags) __print_flags(flags, \"\",\t\\\n\t{ EXT4_MAP_NEW,\t\t\"N\" },\t\t\t\\\n\t{ EXT4_MAP_MAPPED,\t\"M\" },\t\t\t\\\n\t{ EXT4_MAP_UNWRITTEN,\t\"U\" },\t\t\t\\\n\t{ EXT4_MAP_BOUNDARY,\t\"B\" })\n\n#define show_free_flags(flags) __print_flags(flags, \"|\",\t\\\n\t{ EXT4_FREE_BLOCKS_METADATA,\t\t\"METADATA\" },\t\\\n\t{ EXT4_FREE_BLOCKS_FORGET,\t\t\"FORGET\" },\t\\\n\t{ EXT4_FREE_BLOCKS_VALIDATED,\t\t\"VALIDATED\" },\t\\\n\t{ EXT4_FREE_BLOCKS_NO_QUOT_UPDATE,\t\"NO_QUOTA\" },\t\\\n\t{ EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER,\"1ST_CLUSTER\" },\\\n\t{ EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER,\t\"LAST_CLUSTER\" })\n\nTRACE_DEFINE_ENUM(ES_WRITTEN_B);\nTRACE_DEFINE_ENUM(ES_UNWRITTEN_B);\nTRACE_DEFINE_ENUM(ES_DELAYED_B);\nTRACE_DEFINE_ENUM(ES_HOLE_B);\nTRACE_DEFINE_ENUM(ES_REFERENCED_B);\n\n#define show_extent_status(status) __print_flags(status, \"\",\t\\\n\t{ EXTENT_STATUS_WRITTEN,\t\"W\" },\t\t\t\\\n\t{ EXTENT_STATUS_UNWRITTEN,\t\"U\" },\t\t\t\\\n\t{ EXTENT_STATUS_DELAYED,\t\"D\" },\t\t\t\\\n\t{ EXTENT_STATUS_HOLE,\t\t\"H\" },\t\t\t\\\n\t{ EXTENT_STATUS_REFERENCED,\t\"R\" })\n\n#define show_falloc_mode(mode) __print_flags(mode, \"|\",\t\t\\\n\t{ FALLOC_FL_KEEP_SIZE,\t\t\"KEEP_SIZE\"},\t\t\\\n\t{ FALLOC_FL_PUNCH_HOLE,\t\t\"PUNCH_HOLE\"},\t\t\\\n\t{ FALLOC_FL_NO_HIDE_STALE,\t\"NO_HIDE_STALE\"},\t\\\n\t{ FALLOC_FL_COLLAPSE_RANGE,\t\"COLLAPSE_RANGE\"},\t\\\n\t{ FALLOC_FL_ZERO_RANGE,\t\t\"ZERO_RANGE\"})\n\n#define show_fc_reason(reason)\t\t\t\t\t\t\\\n\t__print_symbolic(reason,\t\t\t\t\t\\\n\t\t{ EXT4_FC_REASON_XATTR,\t\t\"XATTR\"},\t\t\\\n\t\t{ EXT4_FC_REASON_CROSS_RENAME,\t\"CROSS_RENAME\"},\t\\\n\t\t{ EXT4_FC_REASON_JOURNAL_FLAG_CHANGE, \"JOURNAL_FLAG_CHANGE\"}, \\\n\t\t{ EXT4_FC_REASON_NOMEM,\t\"NO_MEM\"},\t\t\t\\\n\t\t{ EXT4_FC_REASON_SWAP_BOOT,\t\"SWAP_BOOT\"},\t\t\\\n\t\t{ EXT4_FC_REASON_RESIZE,\t\"RESIZE\"},\t\t\\\n\t\t{ EXT4_FC_REASON_RENAME_DIR,\t\"RENAME_DIR\"},\t\t\\\n\t\t{ EXT4_FC_REASON_FALLOC_RANGE,\t\"FALLOC_RANGE\"},\t\\\n\t\t{ EXT4_FC_REASON_INODE_JOURNAL_DATA,\t\"INODE_JOURNAL_DATA\"})\n\nTRACE_EVENT(ext4_other_inode_update_time,\n\tTP_PROTO(struct inode *inode, ino_t orig_ino),\n\n\tTP_ARGS(inode, orig_ino),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\torig_ino\t\t)\n\t\t__field(\tuid_t,\tuid\t\t\t)\n\t\t__field(\tgid_t,\tgid\t\t\t)\n\t\t__field(\t__u16, mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->orig_ino = orig_ino;\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->uid\t= i_uid_read(inode);\n\t\t__entry->gid\t= i_gid_read(inode);\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d orig_ino %lu ino %lu mode 0%o uid %u gid %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->orig_ino,\n\t\t  (unsigned long) __entry->ino, __entry->mode,\n\t\t  __entry->uid, __entry->gid)\n);\n\nTRACE_EVENT(ext4_free_inode,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tuid_t,\tuid\t\t\t)\n\t\t__field(\tgid_t,\tgid\t\t\t)\n\t\t__field(\t__u64, blocks\t\t\t)\n\t\t__field(\t__u16, mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->uid\t= i_uid_read(inode);\n\t\t__entry->gid\t= i_gid_read(inode);\n\t\t__entry->blocks\t= inode->i_blocks;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o uid %u gid %u blocks %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->mode,\n\t\t  __entry->uid, __entry->gid, __entry->blocks)\n);\n\nTRACE_EVENT(ext4_request_inode,\n\tTP_PROTO(struct inode *dir, int mode),\n\n\tTP_ARGS(dir, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tdir\t\t\t)\n\t\t__field(\t__u16, mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= dir->i_sb->s_dev;\n\t\t__entry->dir\t= dir->i_ino;\n\t\t__entry->mode\t= mode;\n\t),\n\n\tTP_printk(\"dev %d,%d dir %lu mode 0%o\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->dir, __entry->mode)\n);\n\nTRACE_EVENT(ext4_allocate_inode,\n\tTP_PROTO(struct inode *inode, struct inode *dir, int mode),\n\n\tTP_ARGS(inode, dir, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\tdir\t\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->dir\t= dir->i_ino;\n\t\t__entry->mode\t= mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu dir %lu mode 0%o\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->dir, __entry->mode)\n);\n\nTRACE_EVENT(ext4_evict_inode,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tnlink\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->nlink\t= inode->i_nlink;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu nlink %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->nlink)\n);\n\nTRACE_EVENT(ext4_drop_inode,\n\tTP_PROTO(struct inode *inode, int drop),\n\n\tTP_ARGS(inode, drop),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tdrop\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->drop\t= drop;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu drop %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->drop)\n);\n\nTRACE_EVENT(ext4_nfs_commit_metadata,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino)\n);\n\nTRACE_EVENT(ext4_mark_inode_dirty,\n\tTP_PROTO(struct inode *inode, unsigned long IP),\n\n\tTP_ARGS(inode, IP),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(unsigned long,\tip\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->ip\t= IP;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu caller %pS\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, (void *)__entry->ip)\n);\n\nTRACE_EVENT(ext4_begin_ordered_truncate,\n\tTP_PROTO(struct inode *inode, loff_t new_size),\n\n\tTP_ARGS(inode, new_size),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tnew_size\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->new_size\t= new_size;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu new_size %lld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->new_size)\n);\n\nDECLARE_EVENT_CLASS(ext4__write_begin,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int flags),\n\n\tTP_ARGS(inode, pos, len, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\tunsigned int, flags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= pos;\n\t\t__entry->len\t= len;\n\t\t__entry->flags\t= flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %u flags %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len, __entry->flags)\n);\n\nDEFINE_EVENT(ext4__write_begin, ext4_write_begin,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int flags),\n\n\tTP_ARGS(inode, pos, len, flags)\n);\n\nDEFINE_EVENT(ext4__write_begin, ext4_da_write_begin,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int flags),\n\n\tTP_ARGS(inode, pos, len, flags)\n);\n\nDECLARE_EVENT_CLASS(ext4__write_end,\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t\tunsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\tunsigned int, copied\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= pos;\n\t\t__entry->len\t= len;\n\t\t__entry->copied\t= copied;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %u copied %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len, __entry->copied)\n);\n\nDEFINE_EVENT(ext4__write_end, ext4_write_end,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied)\n);\n\nDEFINE_EVENT(ext4__write_end, ext4_journalled_write_end,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied)\n);\n\nDEFINE_EVENT(ext4__write_end, ext4_da_write_end,\n\n\tTP_PROTO(struct inode *inode, loff_t pos, unsigned int len,\n\t\t unsigned int copied),\n\n\tTP_ARGS(inode, pos, len, copied)\n);\n\nTRACE_EVENT(ext4_writepages,\n\tTP_PROTO(struct inode *inode, struct writeback_control *wbc),\n\n\tTP_ARGS(inode, wbc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tlong,\tnr_to_write\t\t)\n\t\t__field(\tlong,\tpages_skipped\t\t)\n\t\t__field(\tloff_t,\trange_start\t\t)\n\t\t__field(\tloff_t,\trange_end\t\t)\n\t\t__field(       pgoff_t,\twriteback_index\t\t)\n\t\t__field(\tint,\tsync_mode\t\t)\n\t\t__field(\tchar,\tfor_kupdate\t\t)\n\t\t__field(\tchar,\trange_cyclic\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->nr_to_write\t= wbc->nr_to_write;\n\t\t__entry->pages_skipped\t= wbc->pages_skipped;\n\t\t__entry->range_start\t= wbc->range_start;\n\t\t__entry->range_end\t= wbc->range_end;\n\t\t__entry->writeback_index = inode->i_mapping->writeback_index;\n\t\t__entry->sync_mode\t= wbc->sync_mode;\n\t\t__entry->for_kupdate\t= wbc->for_kupdate;\n\t\t__entry->range_cyclic\t= wbc->range_cyclic;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld \"\n\t\t  \"range_start %lld range_end %lld sync_mode %d \"\n\t\t  \"for_kupdate %d range_cyclic %d writeback_index %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->nr_to_write,\n\t\t  __entry->pages_skipped, __entry->range_start,\n\t\t  __entry->range_end, __entry->sync_mode,\n\t\t  __entry->for_kupdate, __entry->range_cyclic,\n\t\t  (unsigned long) __entry->writeback_index)\n);\n\nTRACE_EVENT(ext4_da_write_pages,\n\tTP_PROTO(struct inode *inode, pgoff_t first_page,\n\t\t struct writeback_control *wbc),\n\n\tTP_ARGS(inode, first_page, wbc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(      pgoff_t,\tfirst_page\t\t)\n\t\t__field(\t long,\tnr_to_write\t\t)\n\t\t__field(\t  int,\tsync_mode\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->first_page\t= first_page;\n\t\t__entry->nr_to_write\t= wbc->nr_to_write;\n\t\t__entry->sync_mode\t= wbc->sync_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu first_page %lu nr_to_write %ld \"\n\t\t  \"sync_mode %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->first_page,\n\t\t  __entry->nr_to_write, __entry->sync_mode)\n);\n\nTRACE_EVENT(ext4_da_write_pages_extent,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map),\n\n\tTP_ARGS(inode, map),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tlblk\t\t\t)\n\t\t__field(\t__u32,\tlen\t\t\t)\n\t\t__field(\t__u32,\tflags\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->lblk\t\t= map->m_lblk;\n\t\t__entry->len\t\t= map->m_len;\n\t\t__entry->flags\t\t= map->m_flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %llu len %u flags %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->lblk, __entry->len,\n\t\t  show_mflags(__entry->flags))\n);\n\nTRACE_EVENT(ext4_writepages_result,\n\tTP_PROTO(struct inode *inode, struct writeback_control *wbc,\n\t\t\tint ret, int pages_written),\n\n\tTP_ARGS(inode, wbc, ret, pages_written),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t\t__field(\tint,\tpages_written\t\t)\n\t\t__field(\tlong,\tpages_skipped\t\t)\n\t\t__field(       pgoff_t,\twriteback_index\t\t)\n\t\t__field(\tint,\tsync_mode\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->ret\t\t= ret;\n\t\t__entry->pages_written\t= pages_written;\n\t\t__entry->pages_skipped\t= wbc->pages_skipped;\n\t\t__entry->writeback_index = inode->i_mapping->writeback_index;\n\t\t__entry->sync_mode\t= wbc->sync_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu ret %d pages_written %d pages_skipped %ld \"\n\t\t  \"sync_mode %d writeback_index %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->ret,\n\t\t  __entry->pages_written, __entry->pages_skipped,\n\t\t  __entry->sync_mode,\n\t\t  (unsigned long) __entry->writeback_index)\n);\n\nDECLARE_EVENT_CLASS(ext4__page_op,\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tpgoff_t, index\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= page->mapping->host->i_sb->s_dev;\n\t\t__entry->ino\t= page->mapping->host->i_ino;\n\t\t__entry->index\t= page->index;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu page_index %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->index)\n);\n\nDEFINE_EVENT(ext4__page_op, ext4_writepage,\n\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page)\n);\n\nDEFINE_EVENT(ext4__page_op, ext4_readpage,\n\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page)\n);\n\nDEFINE_EVENT(ext4__page_op, ext4_releasepage,\n\n\tTP_PROTO(struct page *page),\n\n\tTP_ARGS(page)\n);\n\nDECLARE_EVENT_CLASS(ext4_invalidatepage_op,\n\tTP_PROTO(struct page *page, unsigned int offset, unsigned int length),\n\n\tTP_ARGS(page, offset, length),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tpgoff_t, index\t\t\t)\n\t\t__field(\tunsigned int, offset\t\t)\n\t\t__field(\tunsigned int, length\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= page->mapping->host->i_sb->s_dev;\n\t\t__entry->ino\t= page->mapping->host->i_ino;\n\t\t__entry->index\t= page->index;\n\t\t__entry->offset\t= offset;\n\t\t__entry->length\t= length;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu page_index %lu offset %u length %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->index,\n\t\t  __entry->offset, __entry->length)\n);\n\nDEFINE_EVENT(ext4_invalidatepage_op, ext4_invalidatepage,\n\tTP_PROTO(struct page *page, unsigned int offset, unsigned int length),\n\n\tTP_ARGS(page, offset, length)\n);\n\nDEFINE_EVENT(ext4_invalidatepage_op, ext4_journalled_invalidatepage,\n\tTP_PROTO(struct page *page, unsigned int offset, unsigned int length),\n\n\tTP_ARGS(page, offset, length)\n);\n\nTRACE_EVENT(ext4_discard_blocks,\n\tTP_PROTO(struct super_block *sb, unsigned long long blk,\n\t\t\tunsigned long long count),\n\n\tTP_ARGS(sb, blk, count),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u64,\tblk\t\t\t)\n\t\t__field(\t__u64,\tcount\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->blk\t= blk;\n\t\t__entry->count\t= count;\n\t),\n\n\tTP_printk(\"dev %d,%d blk %llu count %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->blk, __entry->count)\n);\n\nDECLARE_EVENT_CLASS(ext4__mb_new_pa,\n\tTP_PROTO(struct ext4_allocation_context *ac,\n\t\t struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(ac, pa),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tpa_pstart\t\t)\n\t\t__field(\t__u64,\tpa_lstart\t\t)\n\t\t__field(\t__u32,\tpa_len\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= ac->ac_sb->s_dev;\n\t\t__entry->ino\t\t= ac->ac_inode->i_ino;\n\t\t__entry->pa_pstart\t= pa->pa_pstart;\n\t\t__entry->pa_lstart\t= pa->pa_lstart;\n\t\t__entry->pa_len\t\t= pa->pa_len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pstart %llu len %u lstart %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pa_pstart, __entry->pa_len, __entry->pa_lstart)\n);\n\nDEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_inode_pa,\n\n\tTP_PROTO(struct ext4_allocation_context *ac,\n\t\t struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(ac, pa)\n);\n\nDEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_group_pa,\n\n\tTP_PROTO(struct ext4_allocation_context *ac,\n\t\t struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(ac, pa)\n);\n\nTRACE_EVENT(ext4_mb_release_inode_pa,\n\tTP_PROTO(struct ext4_prealloc_space *pa,\n\t\t unsigned long long block, unsigned int count),\n\n\tTP_ARGS(pa, block, count),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\t__u32,\tcount\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= pa->pa_inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= pa->pa_inode->i_ino;\n\t\t__entry->block\t\t= block;\n\t\t__entry->count\t\t= count;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu block %llu count %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->block, __entry->count)\n);\n\nTRACE_EVENT(ext4_mb_release_group_pa,\n\tTP_PROTO(struct super_block *sb, struct ext4_prealloc_space *pa),\n\n\tTP_ARGS(sb, pa),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u64,\tpa_pstart\t\t)\n\t\t__field(\t__u32,\tpa_len\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->pa_pstart\t= pa->pa_pstart;\n\t\t__entry->pa_len\t\t= pa->pa_len;\n\t),\n\n\tTP_printk(\"dev %d,%d pstart %llu len %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->pa_pstart, __entry->pa_len)\n);\n\nTRACE_EVENT(ext4_discard_preallocations,\n\tTP_PROTO(struct inode *inode, unsigned int len, unsigned int needed),\n\n\tTP_ARGS(inode, len, needed),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tneeded\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->len\t= len;\n\t\t__entry->needed\t= needed;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu len: %u needed %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->len,\n\t\t  __entry->needed)\n);\n\nTRACE_EVENT(ext4_mb_discard_preallocations,\n\tTP_PROTO(struct super_block *sb, int needed),\n\n\tTP_ARGS(sb, needed),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\tneeded\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->needed\t= needed;\n\t),\n\n\tTP_printk(\"dev %d,%d needed %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->needed)\n);\n\nTRACE_EVENT(ext4_request_blocks,\n\tTP_PROTO(struct ext4_allocation_request *ar),\n\n\tTP_ARGS(ar),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\t__u32,  logical\t\t\t)\n\t\t__field(\t__u32,\tlleft\t\t\t)\n\t\t__field(\t__u32,\tlright\t\t\t)\n\t\t__field(\t__u64,\tgoal\t\t\t)\n\t\t__field(\t__u64,\tpleft\t\t\t)\n\t\t__field(\t__u64,\tpright\t\t\t)\n\t\t__field(\tunsigned int, flags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= ar->inode->i_sb->s_dev;\n\t\t__entry->ino\t= ar->inode->i_ino;\n\t\t__entry->len\t= ar->len;\n\t\t__entry->logical = ar->logical;\n\t\t__entry->goal\t= ar->goal;\n\t\t__entry->lleft\t= ar->lleft;\n\t\t__entry->lright\t= ar->lright;\n\t\t__entry->pleft\t= ar->pleft;\n\t\t__entry->pright\t= ar->pright;\n\t\t__entry->flags\t= ar->flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu flags %s len %u lblk %u goal %llu \"\n\t\t  \"lleft %u lright %u pleft %llu pright %llu \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, show_mballoc_flags(__entry->flags),\n\t\t  __entry->len, __entry->logical, __entry->goal,\n\t\t  __entry->lleft, __entry->lright, __entry->pleft,\n\t\t  __entry->pright)\n);\n\nTRACE_EVENT(ext4_allocate_blocks,\n\tTP_PROTO(struct ext4_allocation_request *ar, unsigned long long block),\n\n\tTP_ARGS(ar, block),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\tunsigned int, len\t\t)\n\t\t__field(\t__u32,  logical\t\t\t)\n\t\t__field(\t__u32,\tlleft\t\t\t)\n\t\t__field(\t__u32,\tlright\t\t\t)\n\t\t__field(\t__u64,\tgoal\t\t\t)\n\t\t__field(\t__u64,\tpleft\t\t\t)\n\t\t__field(\t__u64,\tpright\t\t\t)\n\t\t__field(\tunsigned int, flags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= ar->inode->i_sb->s_dev;\n\t\t__entry->ino\t= ar->inode->i_ino;\n\t\t__entry->block\t= block;\n\t\t__entry->len\t= ar->len;\n\t\t__entry->logical = ar->logical;\n\t\t__entry->goal\t= ar->goal;\n\t\t__entry->lleft\t= ar->lleft;\n\t\t__entry->lright\t= ar->lright;\n\t\t__entry->pleft\t= ar->pleft;\n\t\t__entry->pright\t= ar->pright;\n\t\t__entry->flags\t= ar->flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu flags %s len %u block %llu lblk %u \"\n\t\t  \"goal %llu lleft %u lright %u pleft %llu pright %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, show_mballoc_flags(__entry->flags),\n\t\t  __entry->len, __entry->block, __entry->logical,\n\t\t  __entry->goal,  __entry->lleft, __entry->lright,\n\t\t  __entry->pleft, __entry->pright)\n);\n\nTRACE_EVENT(ext4_free_blocks,\n\tTP_PROTO(struct inode *inode, __u64 block, unsigned long count,\n\t\t int flags),\n\n\tTP_ARGS(inode, block, count, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\tunsigned long,\tcount\t\t)\n\t\t__field(\tint,\tflags\t\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->block\t\t= block;\n\t\t__entry->count\t\t= count;\n\t\t__entry->flags\t\t= flags;\n\t\t__entry->mode\t\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o block %llu count %lu flags %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->block, __entry->count,\n\t\t  show_free_flags(__entry->flags))\n);\n\nTRACE_EVENT(ext4_sync_file_enter,\n\tTP_PROTO(struct file *file, int datasync),\n\n\tTP_ARGS(file, datasync),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\tparent\t\t\t)\n\t\t__field(\tint,\tdatasync\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\tstruct dentry *dentry = file->f_path.dentry;\n\n\t\t__entry->dev\t\t= dentry->d_sb->s_dev;\n\t\t__entry->ino\t\t= d_inode(dentry)->i_ino;\n\t\t__entry->datasync\t= datasync;\n\t\t__entry->parent\t\t= d_inode(dentry->d_parent)->i_ino;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu parent %lu datasync %d \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long) __entry->parent, __entry->datasync)\n);\n\nTRACE_EVENT(ext4_sync_file_exit,\n\tTP_PROTO(struct inode *inode, int ret),\n\n\tTP_ARGS(inode, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->ret\t\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->ret)\n);\n\nTRACE_EVENT(ext4_sync_fs,\n\tTP_PROTO(struct super_block *sb, int wait),\n\n\tTP_ARGS(sb, wait),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\twait\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->wait\t= wait;\n\t),\n\n\tTP_printk(\"dev %d,%d wait %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->wait)\n);\n\nTRACE_EVENT(ext4_alloc_da_blocks,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field( unsigned int,\tdata_blocks\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->data_blocks = EXT4_I(inode)->i_reserved_data_blocks;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu reserved_data_blocks %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->data_blocks)\n);\n\nTRACE_EVENT(ext4_mballoc_alloc,\n\tTP_PROTO(struct ext4_allocation_context *ac),\n\n\tTP_ARGS(ac),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u32, \torig_logical\t\t)\n\t\t__field(\t  int,\torig_start\t\t)\n\t\t__field(\t__u32, \torig_group\t\t)\n\t\t__field(\t  int,\torig_len\t\t)\n\t\t__field(\t__u32, \tgoal_logical\t\t)\n\t\t__field(\t  int,\tgoal_start\t\t)\n\t\t__field(\t__u32, \tgoal_group\t\t)\n\t\t__field(\t  int,\tgoal_len\t\t)\n\t\t__field(\t__u32, \tresult_logical\t\t)\n\t\t__field(\t  int,\tresult_start\t\t)\n\t\t__field(\t__u32, \tresult_group\t\t)\n\t\t__field(\t  int,\tresult_len\t\t)\n\t\t__field(\t__u16,\tfound\t\t\t)\n\t\t__field(\t__u16,\tgroups\t\t\t)\n\t\t__field(\t__u16,\tbuddy\t\t\t)\n\t\t__field(\t__u16,\tflags\t\t\t)\n\t\t__field(\t__u16,\ttail\t\t\t)\n\t\t__field(\t__u8,\tcr\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= ac->ac_inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= ac->ac_inode->i_ino;\n\t\t__entry->orig_logical\t= ac->ac_o_ex.fe_logical;\n\t\t__entry->orig_start\t= ac->ac_o_ex.fe_start;\n\t\t__entry->orig_group\t= ac->ac_o_ex.fe_group;\n\t\t__entry->orig_len\t= ac->ac_o_ex.fe_len;\n\t\t__entry->goal_logical\t= ac->ac_g_ex.fe_logical;\n\t\t__entry->goal_start\t= ac->ac_g_ex.fe_start;\n\t\t__entry->goal_group\t= ac->ac_g_ex.fe_group;\n\t\t__entry->goal_len\t= ac->ac_g_ex.fe_len;\n\t\t__entry->result_logical\t= ac->ac_f_ex.fe_logical;\n\t\t__entry->result_start\t= ac->ac_f_ex.fe_start;\n\t\t__entry->result_group\t= ac->ac_f_ex.fe_group;\n\t\t__entry->result_len\t= ac->ac_f_ex.fe_len;\n\t\t__entry->found\t\t= ac->ac_found;\n\t\t__entry->flags\t\t= ac->ac_flags;\n\t\t__entry->groups\t\t= ac->ac_groups_scanned;\n\t\t__entry->buddy\t\t= ac->ac_buddy;\n\t\t__entry->tail\t\t= ac->ac_tail;\n\t\t__entry->cr\t\t= ac->ac_criteria;\n\t),\n\n\tTP_printk(\"dev %d,%d inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u \"\n\t\t  \"result %u/%d/%u@%u blks %u grps %u cr %u flags %s \"\n\t\t  \"tail %u broken %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->orig_group, __entry->orig_start,\n\t\t  __entry->orig_len, __entry->orig_logical,\n\t\t  __entry->goal_group, __entry->goal_start,\n\t\t  __entry->goal_len, __entry->goal_logical,\n\t\t  __entry->result_group, __entry->result_start,\n\t\t  __entry->result_len, __entry->result_logical,\n\t\t  __entry->found, __entry->groups, __entry->cr,\n\t\t  show_mballoc_flags(__entry->flags), __entry->tail,\n\t\t  __entry->buddy ? 1 << __entry->buddy : 0)\n);\n\nTRACE_EVENT(ext4_mballoc_prealloc,\n\tTP_PROTO(struct ext4_allocation_context *ac),\n\n\tTP_ARGS(ac),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u32, \torig_logical\t\t)\n\t\t__field(\t  int,\torig_start\t\t)\n\t\t__field(\t__u32, \torig_group\t\t)\n\t\t__field(\t  int,\torig_len\t\t)\n\t\t__field(\t__u32, \tresult_logical\t\t)\n\t\t__field(\t  int,\tresult_start\t\t)\n\t\t__field(\t__u32, \tresult_group\t\t)\n\t\t__field(\t  int,\tresult_len\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= ac->ac_inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= ac->ac_inode->i_ino;\n\t\t__entry->orig_logical\t= ac->ac_o_ex.fe_logical;\n\t\t__entry->orig_start\t= ac->ac_o_ex.fe_start;\n\t\t__entry->orig_group\t= ac->ac_o_ex.fe_group;\n\t\t__entry->orig_len\t= ac->ac_o_ex.fe_len;\n\t\t__entry->result_logical\t= ac->ac_b_ex.fe_logical;\n\t\t__entry->result_start\t= ac->ac_b_ex.fe_start;\n\t\t__entry->result_group\t= ac->ac_b_ex.fe_group;\n\t\t__entry->result_len\t= ac->ac_b_ex.fe_len;\n\t),\n\n\tTP_printk(\"dev %d,%d inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->orig_group, __entry->orig_start,\n\t\t  __entry->orig_len, __entry->orig_logical,\n\t\t  __entry->result_group, __entry->result_start,\n\t\t  __entry->result_len, __entry->result_logical)\n);\n\nDECLARE_EVENT_CLASS(ext4__mballoc,\n\tTP_PROTO(struct super_block *sb,\n\t\t struct inode *inode,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, inode, group, start, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t  int,\tresult_start\t\t)\n\t\t__field(\t__u32, \tresult_group\t\t)\n\t\t__field(\t  int,\tresult_len\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->ino\t\t= inode ? inode->i_ino : 0;\n\t\t__entry->result_start\t= start;\n\t\t__entry->result_group\t= group;\n\t\t__entry->result_len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d inode %lu extent %u/%d/%d \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->result_group, __entry->result_start,\n\t\t  __entry->result_len)\n);\n\nDEFINE_EVENT(ext4__mballoc, ext4_mballoc_discard,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t struct inode *inode,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, inode, group, start, len)\n);\n\nDEFINE_EVENT(ext4__mballoc, ext4_mballoc_free,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t struct inode *inode,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, inode, group, start, len)\n);\n\nTRACE_EVENT(ext4_forget,\n\tTP_PROTO(struct inode *inode, int is_metadata, __u64 block),\n\n\tTP_ARGS(inode, is_metadata, block),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\tblock\t\t\t)\n\t\t__field(\tint,\tis_metadata\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->block\t= block;\n\t\t__entry->is_metadata = is_metadata;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o is_metadata %d block %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->is_metadata, __entry->block)\n);\n\nTRACE_EVENT(ext4_da_update_reserve_space,\n\tTP_PROTO(struct inode *inode, int used_blocks, int quota_claim),\n\n\tTP_ARGS(inode, used_blocks, quota_claim),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\ti_blocks\t\t)\n\t\t__field(\tint,\tused_blocks\t\t)\n\t\t__field(\tint,\treserved_data_blocks\t)\n\t\t__field(\tint,\tquota_claim\t\t)\n\t\t__field(\t__u16,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->i_blocks = inode->i_blocks;\n\t\t__entry->used_blocks = used_blocks;\n\t\t__entry->reserved_data_blocks =\n\t\t\t\tEXT4_I(inode)->i_reserved_data_blocks;\n\t\t__entry->quota_claim = quota_claim;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o i_blocks %llu used_blocks %d \"\n\t\t  \"reserved_data_blocks %d quota_claim %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->i_blocks,\n\t\t  __entry->used_blocks, __entry->reserved_data_blocks,\n\t\t  __entry->quota_claim)\n);\n\nTRACE_EVENT(ext4_da_reserve_space,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\ti_blocks\t\t)\n\t\t__field(\tint,\treserved_data_blocks\t)\n\t\t__field(\t__u16,  mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->i_blocks = inode->i_blocks;\n\t\t__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o i_blocks %llu \"\n\t\t  \"reserved_data_blocks %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->i_blocks,\n\t\t  __entry->reserved_data_blocks)\n);\n\nTRACE_EVENT(ext4_da_release_space,\n\tTP_PROTO(struct inode *inode, int freed_blocks),\n\n\tTP_ARGS(inode, freed_blocks),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\t__u64,\ti_blocks\t\t)\n\t\t__field(\tint,\tfreed_blocks\t\t)\n\t\t__field(\tint,\treserved_data_blocks\t)\n\t\t__field(\t__u16,  mode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->i_blocks = inode->i_blocks;\n\t\t__entry->freed_blocks = freed_blocks;\n\t\t__entry->reserved_data_blocks = EXT4_I(inode)->i_reserved_data_blocks;\n\t\t__entry->mode\t= inode->i_mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu mode 0%o i_blocks %llu freed_blocks %d \"\n\t\t  \"reserved_data_blocks %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->mode, __entry->i_blocks,\n\t\t  __entry->freed_blocks, __entry->reserved_data_blocks)\n);\n\nDECLARE_EVENT_CLASS(ext4__bitmap_load,\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->group)\n);\n\nDEFINE_EVENT(ext4__bitmap_load, ext4_mb_bitmap_load,\n\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group)\n);\n\nDEFINE_EVENT(ext4__bitmap_load, ext4_mb_buddy_bitmap_load,\n\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group)\n);\n\nDEFINE_EVENT(ext4__bitmap_load, ext4_load_inode_bitmap,\n\n\tTP_PROTO(struct super_block *sb, unsigned long group),\n\n\tTP_ARGS(sb, group)\n);\n\nTRACE_EVENT(ext4_read_block_bitmap_load,\n\tTP_PROTO(struct super_block *sb, unsigned long group, bool prefetch),\n\n\tTP_ARGS(sb, group, prefetch),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\t\t__field(\tbool,\tprefetch\t\t)\n\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t\t__entry->prefetch = prefetch;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u prefetch %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->group, __entry->prefetch)\n);\n\nTRACE_EVENT(ext4_direct_IO_enter,\n\tTP_PROTO(struct inode *inode, loff_t offset, unsigned long len, int rw),\n\n\tTP_ARGS(inode, offset, len, rw),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned long,\tlen\t\t)\n\t\t__field(\tint,\trw\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= offset;\n\t\t__entry->len\t= len;\n\t\t__entry->rw\t= rw;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %lu rw %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len, __entry->rw)\n);\n\nTRACE_EVENT(ext4_direct_IO_exit,\n\tTP_PROTO(struct inode *inode, loff_t offset, unsigned long len,\n\t\t int rw, int ret),\n\n\tTP_ARGS(inode, offset, len, rw, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned long,\tlen\t\t)\n\t\t__field(\tint,\trw\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= offset;\n\t\t__entry->len\t= len;\n\t\t__entry->rw\t= rw;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld len %lu rw %d ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->len,\n\t\t  __entry->rw, __entry->ret)\n);\n\nDECLARE_EVENT_CLASS(ext4__fallocate_mode,\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\toffset\t\t\t)\n\t\t__field(\tloff_t, len\t\t\t)\n\t\t__field(\tint,\tmode\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->offset\t= offset;\n\t\t__entry->len\t= len;\n\t\t__entry->mode\t= mode;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu offset %lld len %lld mode %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->offset, __entry->len,\n\t\t  show_falloc_mode(__entry->mode))\n);\n\nDEFINE_EVENT(ext4__fallocate_mode, ext4_fallocate_enter,\n\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode)\n);\n\nDEFINE_EVENT(ext4__fallocate_mode, ext4_punch_hole,\n\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode)\n);\n\nDEFINE_EVENT(ext4__fallocate_mode, ext4_zero_range,\n\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len, int mode),\n\n\tTP_ARGS(inode, offset, len, mode)\n);\n\nTRACE_EVENT(ext4_fallocate_exit,\n\tTP_PROTO(struct inode *inode, loff_t offset,\n\t\t unsigned int max_blocks, int ret),\n\n\tTP_ARGS(inode, offset, max_blocks, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tpos\t\t\t)\n\t\t__field(\tunsigned int,\tblocks\t\t)\n\t\t__field(\tint, \tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pos\t= offset;\n\t\t__entry->blocks\t= max_blocks;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu pos %lld blocks %u ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->pos, __entry->blocks,\n\t\t  __entry->ret)\n);\n\nTRACE_EVENT(ext4_unlink_enter,\n\tTP_PROTO(struct inode *parent, struct dentry *dentry),\n\n\tTP_ARGS(parent, dentry),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tino_t,\tparent\t\t\t)\n\t\t__field(\tloff_t,\tsize\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= dentry->d_sb->s_dev;\n\t\t__entry->ino\t\t= d_inode(dentry)->i_ino;\n\t\t__entry->parent\t\t= parent->i_ino;\n\t\t__entry->size\t\t= d_inode(dentry)->i_size;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu size %lld parent %lu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->size,\n\t\t  (unsigned long) __entry->parent)\n);\n\nTRACE_EVENT(ext4_unlink_exit,\n\tTP_PROTO(struct dentry *dentry, int ret),\n\n\tTP_ARGS(dentry, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tint,\tret\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= dentry->d_sb->s_dev;\n\t\t__entry->ino\t\t= d_inode(dentry)->i_ino;\n\t\t__entry->ret\t\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->ret)\n);\n\nDECLARE_EVENT_CLASS(ext4__truncate,\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\t__u64,\t\tblocks\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->blocks\t= inode->i_blocks;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu blocks %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->blocks)\n);\n\nDEFINE_EVENT(ext4__truncate, ext4_truncate_enter,\n\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode)\n);\n\nDEFINE_EVENT(ext4__truncate, ext4_truncate_exit,\n\n\tTP_PROTO(struct inode *inode),\n\n\tTP_ARGS(inode)\n);\n\n/* 'ux' is the unwritten extent. */\nTRACE_EVENT(ext4_ext_convert_to_initialized_enter,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map,\n\t\t struct ext4_extent *ux),\n\n\tTP_ARGS(inode, map, ux),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tm_lblk\t)\n\t\t__field(\tunsigned,\tm_len\t)\n\t\t__field(\text4_lblk_t,\tu_lblk\t)\n\t\t__field(\tunsigned,\tu_len\t)\n\t\t__field(\text4_fsblk_t,\tu_pblk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->m_lblk\t\t= map->m_lblk;\n\t\t__entry->m_len\t\t= map->m_len;\n\t\t__entry->u_lblk\t\t= le32_to_cpu(ux->ee_block);\n\t\t__entry->u_len\t\t= ext4_ext_get_actual_len(ux);\n\t\t__entry->u_pblk\t\t= ext4_ext_pblock(ux);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu m_lblk %u m_len %u u_lblk %u u_len %u \"\n\t\t  \"u_pblk %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->m_lblk, __entry->m_len,\n\t\t  __entry->u_lblk, __entry->u_len, __entry->u_pblk)\n);\n\n/*\n * 'ux' is the unwritten extent.\n * 'ix' is the initialized extent to which blocks are transferred.\n */\nTRACE_EVENT(ext4_ext_convert_to_initialized_fastpath,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map,\n\t\t struct ext4_extent *ux, struct ext4_extent *ix),\n\n\tTP_ARGS(inode, map, ux, ix),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tm_lblk\t)\n\t\t__field(\tunsigned,\tm_len\t)\n\t\t__field(\text4_lblk_t,\tu_lblk\t)\n\t\t__field(\tunsigned,\tu_len\t)\n\t\t__field(\text4_fsblk_t,\tu_pblk\t)\n\t\t__field(\text4_lblk_t,\ti_lblk\t)\n\t\t__field(\tunsigned,\ti_len\t)\n\t\t__field(\text4_fsblk_t,\ti_pblk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->m_lblk\t\t= map->m_lblk;\n\t\t__entry->m_len\t\t= map->m_len;\n\t\t__entry->u_lblk\t\t= le32_to_cpu(ux->ee_block);\n\t\t__entry->u_len\t\t= ext4_ext_get_actual_len(ux);\n\t\t__entry->u_pblk\t\t= ext4_ext_pblock(ux);\n\t\t__entry->i_lblk\t\t= le32_to_cpu(ix->ee_block);\n\t\t__entry->i_len\t\t= ext4_ext_get_actual_len(ix);\n\t\t__entry->i_pblk\t\t= ext4_ext_pblock(ix);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu m_lblk %u m_len %u \"\n\t\t  \"u_lblk %u u_len %u u_pblk %llu \"\n\t\t  \"i_lblk %u i_len %u i_pblk %llu \",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->m_lblk, __entry->m_len,\n\t\t  __entry->u_lblk, __entry->u_len, __entry->u_pblk,\n\t\t  __entry->i_lblk, __entry->i_len, __entry->i_pblk)\n);\n\nDECLARE_EVENT_CLASS(ext4__map_blocks_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk,\n\t\t unsigned int len, unsigned int flags),\n\n\tTP_ARGS(inode, lblk, len, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tflags\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t\t__entry->flags\t= flags;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u len %u flags %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len, show_map_flags(__entry->flags))\n);\n\nDEFINE_EVENT(ext4__map_blocks_enter, ext4_ext_map_blocks_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk,\n\t\t unsigned len, unsigned flags),\n\n\tTP_ARGS(inode, lblk, len, flags)\n);\n\nDEFINE_EVENT(ext4__map_blocks_enter, ext4_ind_map_blocks_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk,\n\t\t unsigned len, unsigned flags),\n\n\tTP_ARGS(inode, lblk, len, flags)\n);\n\nDECLARE_EVENT_CLASS(ext4__map_blocks_exit,\n\tTP_PROTO(struct inode *inode, unsigned flags, struct ext4_map_blocks *map,\n\t\t int ret),\n\n\tTP_ARGS(inode, flags, map, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\tunsigned int,\tflags\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tmflags\t\t)\n\t\t__field(\tint,\t\tret\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->flags\t= flags;\n\t\t__entry->pblk\t= map->m_pblk;\n\t\t__entry->lblk\t= map->m_lblk;\n\t\t__entry->len\t= map->m_len;\n\t\t__entry->mflags\t= map->m_flags;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu flags %s lblk %u pblk %llu len %u \"\n\t\t  \"mflags %s ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  show_map_flags(__entry->flags), __entry->lblk, __entry->pblk,\n\t\t  __entry->len, show_mflags(__entry->mflags), __entry->ret)\n);\n\nDEFINE_EVENT(ext4__map_blocks_exit, ext4_ext_map_blocks_exit,\n\tTP_PROTO(struct inode *inode, unsigned flags,\n\t\t struct ext4_map_blocks *map, int ret),\n\n\tTP_ARGS(inode, flags, map, ret)\n);\n\nDEFINE_EVENT(ext4__map_blocks_exit, ext4_ind_map_blocks_exit,\n\tTP_PROTO(struct inode *inode, unsigned flags,\n\t\t struct ext4_map_blocks *map, int ret),\n\n\tTP_ARGS(inode, flags, map, ret)\n);\n\nTRACE_EVENT(ext4_ext_load_extent,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk),\n\n\tTP_ARGS(inode, lblk, pblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev    = inode->i_sb->s_dev;\n\t\t__entry->ino    = inode->i_ino;\n\t\t__entry->pblk\t= pblk;\n\t\t__entry->lblk\t= lblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u pblk %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->pblk)\n);\n\nTRACE_EVENT(ext4_load_inode,\n\tTP_PROTO(struct super_block *sb, unsigned long ino),\n\n\tTP_ARGS(sb, ino),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t)\n\t\t__field(\tino_t,\tino\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->ino\t\t= ino;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %ld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino)\n);\n\nTRACE_EVENT(ext4_journal_start,\n\tTP_PROTO(struct super_block *sb, int blocks, int rsv_blocks,\n\t\t int revoke_creds, unsigned long IP),\n\n\tTP_ARGS(sb, blocks, rsv_blocks, revoke_creds, IP),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(unsigned long,\tip\t\t\t)\n\t\t__field(\t  int,\tblocks\t\t\t)\n\t\t__field(\t  int,\trsv_blocks\t\t)\n\t\t__field(\t  int,\trevoke_creds\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t = sb->s_dev;\n\t\t__entry->ip\t\t = IP;\n\t\t__entry->blocks\t\t = blocks;\n\t\t__entry->rsv_blocks\t = rsv_blocks;\n\t\t__entry->revoke_creds\t = revoke_creds;\n\t),\n\n\tTP_printk(\"dev %d,%d blocks %d, rsv_blocks %d, revoke_creds %d, \"\n\t\t  \"caller %pS\", MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->blocks, __entry->rsv_blocks, __entry->revoke_creds,\n\t\t  (void *)__entry->ip)\n);\n\nTRACE_EVENT(ext4_journal_start_reserved,\n\tTP_PROTO(struct super_block *sb, int blocks, unsigned long IP),\n\n\tTP_ARGS(sb, blocks, IP),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(unsigned long,\tip\t\t\t)\n\t\t__field(\t  int,\tblocks\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t = sb->s_dev;\n\t\t__entry->ip\t\t = IP;\n\t\t__entry->blocks\t\t = blocks;\n\t),\n\n\tTP_printk(\"dev %d,%d blocks, %d caller %pS\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->blocks, (void *)__entry->ip)\n);\n\nDECLARE_EVENT_CLASS(ext4__trim,\n\tTP_PROTO(struct super_block *sb,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, group, start, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tint,\tdev_major\t\t)\n\t\t__field(\tint,\tdev_minor\t\t)\n\t\t__field(\t__u32, \tgroup\t\t\t)\n\t\t__field(\tint,\tstart\t\t\t)\n\t\t__field(\tint,\tlen\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev_major\t= MAJOR(sb->s_dev);\n\t\t__entry->dev_minor\t= MINOR(sb->s_dev);\n\t\t__entry->group\t\t= group;\n\t\t__entry->start\t\t= start;\n\t\t__entry->len\t\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u, start %d, len %d\",\n\t\t  __entry->dev_major, __entry->dev_minor,\n\t\t  __entry->group, __entry->start, __entry->len)\n);\n\nDEFINE_EVENT(ext4__trim, ext4_trim_extent,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, group, start, len)\n);\n\nDEFINE_EVENT(ext4__trim, ext4_trim_all_free,\n\n\tTP_PROTO(struct super_block *sb,\n\t\t ext4_group_t group,\n\t\t ext4_grpblk_t start,\n\t\t ext4_grpblk_t len),\n\n\tTP_ARGS(sb, group, start, len)\n);\n\nTRACE_EVENT(ext4_ext_handle_unwritten_extents,\n\tTP_PROTO(struct inode *inode, struct ext4_map_blocks *map, int flags,\n\t\t unsigned int allocated, ext4_fsblk_t newblock),\n\n\tTP_ARGS(inode, map, flags, allocated, newblock),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\tint,\t\tflags\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tunsigned int,\tlen\t\t)\n\t\t__field(\tunsigned int,\tallocated\t)\n\t\t__field(\text4_fsblk_t,\tnewblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->flags\t\t= flags;\n\t\t__entry->lblk\t\t= map->m_lblk;\n\t\t__entry->pblk\t\t= map->m_pblk;\n\t\t__entry->len\t\t= map->m_len;\n\t\t__entry->allocated\t= allocated;\n\t\t__entry->newblk\t\t= newblock;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu m_lblk %u m_pblk %llu m_len %u flags %s \"\n\t\t  \"allocated %d newblock %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk, (unsigned long long) __entry->pblk,\n\t\t  __entry->len, show_map_flags(__entry->flags),\n\t\t  (unsigned int) __entry->allocated,\n\t\t  (unsigned long long) __entry->newblk)\n);\n\nTRACE_EVENT(ext4_get_implied_cluster_alloc_exit,\n\tTP_PROTO(struct super_block *sb, struct ext4_map_blocks *map, int ret),\n\n\tTP_ARGS(sb, map, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tunsigned int,\tflags\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t)\n\t\t__field(\tunsigned int,\tlen\t)\n\t\t__field(\tint,\t\tret\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->flags\t= map->m_flags;\n\t\t__entry->lblk\t= map->m_lblk;\n\t\t__entry->pblk\t= map->m_pblk;\n\t\t__entry->len\t= map->m_len;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d m_lblk %u m_pblk %llu m_len %u m_flags %s ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->lblk, (unsigned long long) __entry->pblk,\n\t\t  __entry->len, show_mflags(__entry->flags), __entry->ret)\n);\n\nTRACE_EVENT(ext4_ext_put_in_cache,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len,\n\t\t ext4_fsblk_t start),\n\n\tTP_ARGS(inode, lblk, len, start),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tunsigned int,\tlen\t)\n\t\t__field(\text4_fsblk_t,\tstart\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t\t__entry->start\t= start;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u len %u start %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  __entry->len,\n\t\t  (unsigned long long) __entry->start)\n);\n\nTRACE_EVENT(ext4_ext_in_cache,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, int ret),\n\n\tTP_ARGS(inode, lblk, ret),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tint,\t\tret\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->ret\t= ret;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u ret %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  __entry->ret)\n\n);\n\nTRACE_EVENT(ext4_find_delalloc_range,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t from, ext4_lblk_t to,\n\t\tint reverse, int found, ext4_lblk_t found_blk),\n\n\tTP_ARGS(inode, from, to, reverse, found, found_blk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tfrom\t\t)\n\t\t__field(\text4_lblk_t,\tto\t\t)\n\t\t__field(\tint,\t\treverse\t\t)\n\t\t__field(\tint,\t\tfound\t\t)\n\t\t__field(\text4_lblk_t,\tfound_blk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->from\t\t= from;\n\t\t__entry->to\t\t= to;\n\t\t__entry->reverse\t= reverse;\n\t\t__entry->found\t\t= found;\n\t\t__entry->found_blk\t= found_blk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu from %u to %u reverse %d found %d \"\n\t\t  \"(blk = %u)\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->from, (unsigned) __entry->to,\n\t\t  __entry->reverse, __entry->found,\n\t\t  (unsigned) __entry->found_blk)\n);\n\nTRACE_EVENT(ext4_get_reserved_cluster_alloc,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, unsigned int len),\n\n\tTP_ARGS(inode, lblk, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tunsigned int,\tlen\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u len %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  __entry->len)\n);\n\nTRACE_EVENT(ext4_ext_show_extent,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,\n\t\t unsigned short len),\n\n\tTP_ARGS(inode, lblk, pblk, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t)\n\t\t__field(\text4_lblk_t,\tlblk\t)\n\t\t__field(\tunsigned short,\tlen\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pblk\t= pblk;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u pblk %llu len %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->lblk,\n\t\t  (unsigned long long) __entry->pblk,\n\t\t  (unsigned short) __entry->len)\n);\n\nTRACE_EVENT(ext4_remove_blocks,\n\tTP_PROTO(struct inode *inode, struct ext4_extent *ex,\n\t\t ext4_lblk_t from, ext4_fsblk_t to,\n\t\t struct partial_cluster *pc),\n\n\tTP_ARGS(inode, ex, from, to, pc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tfrom\t)\n\t\t__field(\text4_lblk_t,\tto\t)\n\t\t__field(\text4_fsblk_t,\tee_pblk\t)\n\t\t__field(\text4_lblk_t,\tee_lblk\t)\n\t\t__field(\tunsigned short,\tee_len\t)\n\t\t__field(\text4_fsblk_t,\tpc_pclu\t)\n\t\t__field(\text4_lblk_t,\tpc_lblk\t)\n\t\t__field(\tint,\t\tpc_state)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->from\t\t= from;\n\t\t__entry->to\t\t= to;\n\t\t__entry->ee_pblk\t= ext4_ext_pblock(ex);\n\t\t__entry->ee_lblk\t= le32_to_cpu(ex->ee_block);\n\t\t__entry->ee_len\t\t= ext4_ext_get_actual_len(ex);\n\t\t__entry->pc_pclu\t= pc->pclu;\n\t\t__entry->pc_lblk\t= pc->lblk;\n\t\t__entry->pc_state\t= pc->state;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu extent [%u(%llu), %u]\"\n\t\t  \"from %u to %u partial [pclu %lld lblk %u state %d]\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->ee_lblk,\n\t\t  (unsigned long long) __entry->ee_pblk,\n\t\t  (unsigned short) __entry->ee_len,\n\t\t  (unsigned) __entry->from,\n\t\t  (unsigned) __entry->to,\n\t\t  (long long) __entry->pc_pclu,\n\t\t  (unsigned int) __entry->pc_lblk,\n\t\t  (int) __entry->pc_state)\n);\n\nTRACE_EVENT(ext4_ext_rm_leaf,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t start,\n\t\t struct ext4_extent *ex,\n\t\t struct partial_cluster *pc),\n\n\tTP_ARGS(inode, start, ex, pc),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tstart\t)\n\t\t__field(\text4_lblk_t,\tee_lblk\t)\n\t\t__field(\text4_fsblk_t,\tee_pblk\t)\n\t\t__field(\tshort,\t\tee_len\t)\n\t\t__field(\text4_fsblk_t,\tpc_pclu\t)\n\t\t__field(\text4_lblk_t,\tpc_lblk\t)\n\t\t__field(\tint,\t\tpc_state)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->start\t\t= start;\n\t\t__entry->ee_lblk\t= le32_to_cpu(ex->ee_block);\n\t\t__entry->ee_pblk\t= ext4_ext_pblock(ex);\n\t\t__entry->ee_len\t\t= ext4_ext_get_actual_len(ex);\n\t\t__entry->pc_pclu\t= pc->pclu;\n\t\t__entry->pc_lblk\t= pc->lblk;\n\t\t__entry->pc_state\t= pc->state;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu start_lblk %u last_extent [%u(%llu), %u]\"\n\t\t  \"partial [pclu %lld lblk %u state %d]\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->start,\n\t\t  (unsigned) __entry->ee_lblk,\n\t\t  (unsigned long long) __entry->ee_pblk,\n\t\t  (unsigned short) __entry->ee_len,\n\t\t  (long long) __entry->pc_pclu,\n\t\t  (unsigned int) __entry->pc_lblk,\n\t\t  (int) __entry->pc_state)\n);\n\nTRACE_EVENT(ext4_ext_rm_idx,\n\tTP_PROTO(struct inode *inode, ext4_fsblk_t pblk),\n\n\tTP_ARGS(inode, pblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->pblk\t= pblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu index_pblk %llu\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned long long) __entry->pblk)\n);\n\nTRACE_EVENT(ext4_ext_remove_space,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t start,\n\t\t ext4_lblk_t end, int depth),\n\n\tTP_ARGS(inode, start, end, depth),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t)\n\t\t__field(\tino_t,\t\tino\t)\n\t\t__field(\text4_lblk_t,\tstart\t)\n\t\t__field(\text4_lblk_t,\tend\t)\n\t\t__field(\tint,\t\tdepth\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->start\t= start;\n\t\t__entry->end\t= end;\n\t\t__entry->depth\t= depth;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu since %u end %u depth %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->start,\n\t\t  (unsigned) __entry->end,\n\t\t  __entry->depth)\n);\n\nTRACE_EVENT(ext4_ext_remove_space_done,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t start, ext4_lblk_t end,\n\t\t int depth, struct partial_cluster *pc, __le16 eh_entries),\n\n\tTP_ARGS(inode, start, end, depth, pc, eh_entries),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tstart\t\t)\n\t\t__field(\text4_lblk_t,\tend\t\t)\n\t\t__field(\tint,\t\tdepth\t\t)\n\t\t__field(\text4_fsblk_t,\tpc_pclu\t\t)\n\t\t__field(\text4_lblk_t,\tpc_lblk\t\t)\n\t\t__field(\tint,\t\tpc_state\t)\n\t\t__field(\tunsigned short,\teh_entries\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->start\t\t= start;\n\t\t__entry->end\t\t= end;\n\t\t__entry->depth\t\t= depth;\n\t\t__entry->pc_pclu\t= pc->pclu;\n\t\t__entry->pc_lblk\t= pc->lblk;\n\t\t__entry->pc_state\t= pc->state;\n\t\t__entry->eh_entries\t= le16_to_cpu(eh_entries);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu since %u end %u depth %d \"\n\t\t  \"partial [pclu %lld lblk %u state %d] \"\n\t\t  \"remaining_entries %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  (unsigned) __entry->start,\n\t\t  (unsigned) __entry->end,\n\t\t  __entry->depth,\n\t\t  (long long) __entry->pc_pclu,\n\t\t  (unsigned int) __entry->pc_lblk,\n\t\t  (int) __entry->pc_state,\n\t\t  (unsigned short) __entry->eh_entries)\n);\n\nDECLARE_EVENT_CLASS(ext4__es_extent,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar, status\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= es->es_lblk;\n\t\t__entry->len\t= es->es_len;\n\t\t__entry->pblk\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t= ext4_es_status(es);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%u/%u) mapped %llu status %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->pblk, show_extent_status(__entry->status))\n);\n\nDEFINE_EVENT(ext4__es_extent, ext4_es_insert_extent,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es)\n);\n\nDEFINE_EVENT(ext4__es_extent, ext4_es_cache_extent,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es)\n);\n\nTRACE_EVENT(ext4_es_remove_extent,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len),\n\n\tTP_ARGS(inode, lblk, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tino_t,\tino\t\t\t)\n\t\t__field(\tloff_t,\tlblk\t\t\t)\n\t\t__field(\tloff_t,\tlen\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%lld/%lld)\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len)\n);\n\nTRACE_EVENT(ext4_es_find_extent_range_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk),\n\n\tTP_ARGS(inode, lblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->lblk)\n);\n\nTRACE_EVENT(ext4_es_find_extent_range_exit,\n\tTP_PROTO(struct inode *inode, struct extent_status *es),\n\n\tTP_ARGS(inode, es),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar, status\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= es->es_lblk;\n\t\t__entry->len\t= es->es_len;\n\t\t__entry->pblk\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t= ext4_es_status(es);\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%u/%u) mapped %llu status %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->pblk, show_extent_status(__entry->status))\n);\n\nTRACE_EVENT(ext4_es_lookup_extent_enter,\n\tTP_PROTO(struct inode *inode, ext4_lblk_t lblk),\n\n\tTP_ARGS(inode, lblk),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= lblk;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu lblk %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->lblk)\n);\n\nTRACE_EVENT(ext4_es_lookup_extent_exit,\n\tTP_PROTO(struct inode *inode, struct extent_status *es,\n\t\t int found),\n\n\tTP_ARGS(inode, es, found),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar,\t\tstatus\t\t)\n\t\t__field(\tint,\t\tfound\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->lblk\t= es->es_lblk;\n\t\t__entry->len\t= es->es_len;\n\t\t__entry->pblk\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t= ext4_es_status(es);\n\t\t__entry->found\t= found;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu found %d [%u/%u) %llu %s\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino, __entry->found,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->found ? __entry->pblk : 0,\n\t\t  show_extent_status(__entry->found ? __entry->status : 0))\n);\n\nDECLARE_EVENT_CLASS(ext4__es_shrink_enter,\n\tTP_PROTO(struct super_block *sb, int nr_to_scan, int cache_cnt),\n\n\tTP_ARGS(sb, nr_to_scan, cache_cnt),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\tnr_to_scan\t\t)\n\t\t__field(\tint,\tcache_cnt\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->nr_to_scan\t= nr_to_scan;\n\t\t__entry->cache_cnt\t= cache_cnt;\n\t),\n\n\tTP_printk(\"dev %d,%d nr_to_scan %d cache_cnt %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->nr_to_scan, __entry->cache_cnt)\n);\n\nDEFINE_EVENT(ext4__es_shrink_enter, ext4_es_shrink_count,\n\tTP_PROTO(struct super_block *sb, int nr_to_scan, int cache_cnt),\n\n\tTP_ARGS(sb, nr_to_scan, cache_cnt)\n);\n\nDEFINE_EVENT(ext4__es_shrink_enter, ext4_es_shrink_scan_enter,\n\tTP_PROTO(struct super_block *sb, int nr_to_scan, int cache_cnt),\n\n\tTP_ARGS(sb, nr_to_scan, cache_cnt)\n);\n\nTRACE_EVENT(ext4_es_shrink_scan_exit,\n\tTP_PROTO(struct super_block *sb, int nr_shrunk, int cache_cnt),\n\n\tTP_ARGS(sb, nr_shrunk, cache_cnt),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\tint,\tnr_shrunk\t\t)\n\t\t__field(\tint,\tcache_cnt\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->nr_shrunk\t= nr_shrunk;\n\t\t__entry->cache_cnt\t= cache_cnt;\n\t),\n\n\tTP_printk(\"dev %d,%d nr_shrunk %d cache_cnt %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->nr_shrunk, __entry->cache_cnt)\n);\n\nTRACE_EVENT(ext4_collapse_range,\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len),\n\n\tTP_ARGS(inode, offset, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t,\tdev)\n\t\t__field(ino_t,\tino)\n\t\t__field(loff_t,\toffset)\n\t\t__field(loff_t, len)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->offset\t= offset;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu offset %lld len %lld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->offset, __entry->len)\n);\n\nTRACE_EVENT(ext4_insert_range,\n\tTP_PROTO(struct inode *inode, loff_t offset, loff_t len),\n\n\tTP_ARGS(inode, offset, len),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t,\tdev)\n\t\t__field(ino_t,\tino)\n\t\t__field(loff_t,\toffset)\n\t\t__field(loff_t, len)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t= inode->i_ino;\n\t\t__entry->offset\t= offset;\n\t\t__entry->len\t= len;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu offset %lld len %lld\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->offset, __entry->len)\n);\n\nTRACE_EVENT(ext4_es_shrink,\n\tTP_PROTO(struct super_block *sb, int nr_shrunk, u64 scan_time,\n\t\t int nr_skipped, int retried),\n\n\tTP_ARGS(sb, nr_shrunk, scan_time, nr_skipped, retried),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tint,\t\tnr_shrunk\t)\n\t\t__field(\tunsigned long long, scan_time\t)\n\t\t__field(\tint,\t\tnr_skipped\t)\n\t\t__field(\tint,\t\tretried\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= sb->s_dev;\n\t\t__entry->nr_shrunk\t= nr_shrunk;\n\t\t__entry->scan_time\t= div_u64(scan_time, 1000);\n\t\t__entry->nr_skipped\t= nr_skipped;\n\t\t__entry->retried\t= retried;\n\t),\n\n\tTP_printk(\"dev %d,%d nr_shrunk %d, scan_time %llu \"\n\t\t  \"nr_skipped %d retried %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev), __entry->nr_shrunk,\n\t\t  __entry->scan_time, __entry->nr_skipped, __entry->retried)\n);\n\nTRACE_EVENT(ext4_es_insert_delayed_block,\n\tTP_PROTO(struct inode *inode, struct extent_status *es,\n\t\t bool allocated),\n\n\tTP_ARGS(inode, es, allocated),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\t\tdev\t\t)\n\t\t__field(\tino_t,\t\tino\t\t)\n\t\t__field(\text4_lblk_t,\tlblk\t\t)\n\t\t__field(\text4_lblk_t,\tlen\t\t)\n\t\t__field(\text4_fsblk_t,\tpblk\t\t)\n\t\t__field(\tchar,\t\tstatus\t\t)\n\t\t__field(\tbool,\t\tallocated\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t\t= inode->i_sb->s_dev;\n\t\t__entry->ino\t\t= inode->i_ino;\n\t\t__entry->lblk\t\t= es->es_lblk;\n\t\t__entry->len\t\t= es->es_len;\n\t\t__entry->pblk\t\t= ext4_es_show_pblock(es);\n\t\t__entry->status\t\t= ext4_es_status(es);\n\t\t__entry->allocated\t= allocated;\n\t),\n\n\tTP_printk(\"dev %d,%d ino %lu es [%u/%u) mapped %llu status %s \"\n\t\t  \"allocated %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  (unsigned long) __entry->ino,\n\t\t  __entry->lblk, __entry->len,\n\t\t  __entry->pblk, show_extent_status(__entry->status),\n\t\t  __entry->allocated)\n);\n\n/* fsmap traces */\nDECLARE_EVENT_CLASS(ext4_fsmap_class,\n\tTP_PROTO(struct super_block *sb, u32 keydev, u32 agno, u64 bno, u64 len,\n\t\t u64 owner),\n\tTP_ARGS(sb, keydev, agno, bno, len, owner),\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(dev_t, keydev)\n\t\t__field(u32, agno)\n\t\t__field(u64, bno)\n\t\t__field(u64, len)\n\t\t__field(u64, owner)\n\t),\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_bdev->bd_dev;\n\t\t__entry->keydev = new_decode_dev(keydev);\n\t\t__entry->agno = agno;\n\t\t__entry->bno = bno;\n\t\t__entry->len = len;\n\t\t__entry->owner = owner;\n\t),\n\tTP_printk(\"dev %d:%d keydev %d:%d agno %u bno %llu len %llu owner %lld\\n\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  MAJOR(__entry->keydev), MINOR(__entry->keydev),\n\t\t  __entry->agno,\n\t\t  __entry->bno,\n\t\t  __entry->len,\n\t\t  __entry->owner)\n)\n#define DEFINE_FSMAP_EVENT(name) \\\nDEFINE_EVENT(ext4_fsmap_class, name, \\\n\tTP_PROTO(struct super_block *sb, u32 keydev, u32 agno, u64 bno, u64 len, \\\n\t\t u64 owner), \\\n\tTP_ARGS(sb, keydev, agno, bno, len, owner))\nDEFINE_FSMAP_EVENT(ext4_fsmap_low_key);\nDEFINE_FSMAP_EVENT(ext4_fsmap_high_key);\nDEFINE_FSMAP_EVENT(ext4_fsmap_mapping);\n\nDECLARE_EVENT_CLASS(ext4_getfsmap_class,\n\tTP_PROTO(struct super_block *sb, struct ext4_fsmap *fsmap),\n\tTP_ARGS(sb, fsmap),\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(dev_t, keydev)\n\t\t__field(u64, block)\n\t\t__field(u64, len)\n\t\t__field(u64, owner)\n\t\t__field(u64, flags)\n\t),\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_bdev->bd_dev;\n\t\t__entry->keydev = new_decode_dev(fsmap->fmr_device);\n\t\t__entry->block = fsmap->fmr_physical;\n\t\t__entry->len = fsmap->fmr_length;\n\t\t__entry->owner = fsmap->fmr_owner;\n\t\t__entry->flags = fsmap->fmr_flags;\n\t),\n\tTP_printk(\"dev %d:%d keydev %d:%d block %llu len %llu owner %lld flags 0x%llx\\n\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  MAJOR(__entry->keydev), MINOR(__entry->keydev),\n\t\t  __entry->block,\n\t\t  __entry->len,\n\t\t  __entry->owner,\n\t\t  __entry->flags)\n)\n#define DEFINE_GETFSMAP_EVENT(name) \\\nDEFINE_EVENT(ext4_getfsmap_class, name, \\\n\tTP_PROTO(struct super_block *sb, struct ext4_fsmap *fsmap), \\\n\tTP_ARGS(sb, fsmap))\nDEFINE_GETFSMAP_EVENT(ext4_getfsmap_low_key);\nDEFINE_GETFSMAP_EVENT(ext4_getfsmap_high_key);\nDEFINE_GETFSMAP_EVENT(ext4_getfsmap_mapping);\n\nTRACE_EVENT(ext4_shutdown,\n\tTP_PROTO(struct super_block *sb, unsigned long flags),\n\n\tTP_ARGS(sb, flags),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(     unsigned,\tflags\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->flags\t= flags;\n\t),\n\n\tTP_printk(\"dev %d,%d flags %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->flags)\n);\n\nTRACE_EVENT(ext4_error,\n\tTP_PROTO(struct super_block *sb, const char *function,\n\t\t unsigned int line),\n\n\tTP_ARGS(sb, function, line),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field( const char *,\tfunction\t\t)\n\t\t__field(     unsigned,\tline\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->function = function;\n\t\t__entry->line\t= line;\n\t),\n\n\tTP_printk(\"dev %d,%d function %s line %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->function, __entry->line)\n);\n\nTRACE_EVENT(ext4_prefetch_bitmaps,\n\t    TP_PROTO(struct super_block *sb, ext4_group_t group,\n\t\t     ext4_group_t next, unsigned int prefetch_ios),\n\n\tTP_ARGS(sb, group, next, prefetch_ios),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\t\t__field(\t__u32,\tnext\t\t\t)\n\t\t__field(\t__u32,\tios\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t\t__entry->next\t= next;\n\t\t__entry->ios\t= prefetch_ios;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u next %u ios %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->group, __entry->next, __entry->ios)\n);\n\nTRACE_EVENT(ext4_lazy_itable_init,\n\t    TP_PROTO(struct super_block *sb, ext4_group_t group),\n\n\tTP_ARGS(sb, group),\n\n\tTP_STRUCT__entry(\n\t\t__field(\tdev_t,\tdev\t\t\t)\n\t\t__field(\t__u32,\tgroup\t\t\t)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev\t= sb->s_dev;\n\t\t__entry->group\t= group;\n\t),\n\n\tTP_printk(\"dev %d,%d group %u\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev), __entry->group)\n);\n\nTRACE_EVENT(ext4_fc_replay_scan,\n\tTP_PROTO(struct super_block *sb, int error, int off),\n\n\tTP_ARGS(sb, error, off),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(int, error)\n\t\t__field(int, off)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t\t__entry->error = error;\n\t\t__entry->off = off;\n\t),\n\n\tTP_printk(\"FC scan pass on dev %d,%d: error %d, off %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->error, __entry->off)\n);\n\nTRACE_EVENT(ext4_fc_replay,\n\tTP_PROTO(struct super_block *sb, int tag, int ino, int priv1, int priv2),\n\n\tTP_ARGS(sb, tag, ino, priv1, priv2),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(int, tag)\n\t\t__field(int, ino)\n\t\t__field(int, priv1)\n\t\t__field(int, priv2)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t\t__entry->tag = tag;\n\t\t__entry->ino = ino;\n\t\t__entry->priv1 = priv1;\n\t\t__entry->priv2 = priv2;\n\t),\n\n\tTP_printk(\"FC Replay %d,%d: tag %d, ino %d, data1 %d, data2 %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->tag, __entry->ino, __entry->priv1, __entry->priv2)\n);\n\nTRACE_EVENT(ext4_fc_commit_start,\n\tTP_PROTO(struct super_block *sb),\n\n\tTP_ARGS(sb),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t),\n\n\tTP_printk(\"fast_commit started on dev %d,%d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev))\n);\n\nTRACE_EVENT(ext4_fc_commit_stop,\n\t    TP_PROTO(struct super_block *sb, int nblks, int reason),\n\n\tTP_ARGS(sb, nblks, reason),\n\n\tTP_STRUCT__entry(\n\t\t__field(dev_t, dev)\n\t\t__field(int, nblks)\n\t\t__field(int, reason)\n\t\t__field(int, num_fc)\n\t\t__field(int, num_fc_ineligible)\n\t\t__field(int, nblks_agg)\n\t),\n\n\tTP_fast_assign(\n\t\t__entry->dev = sb->s_dev;\n\t\t__entry->nblks = nblks;\n\t\t__entry->reason = reason;\n\t\t__entry->num_fc = EXT4_SB(sb)->s_fc_stats.fc_num_commits;\n\t\t__entry->num_fc_ineligible =\n\t\t\tEXT4_SB(sb)->s_fc_stats.fc_ineligible_commits;\n\t\t__entry->nblks_agg = EXT4_SB(sb)->s_fc_stats.fc_numblks;\n\t),\n\n\tTP_printk(\"fc on [%d,%d] nblks %d, reason %d, fc = %d, ineligible = %d, agg_nblks %d\",\n\t\t  MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t  __entry->nblks, __entry->reason, __entry->num_fc,\n\t\t  __entry->num_fc_ineligible, __entry->nblks_agg)\n);\n\n#define FC_REASON_NAME_STAT(reason)\t\t\t\t\t\\\n\tshow_fc_reason(reason),\t\t\t\t\t\t\\\n\t__entry->sbi->s_fc_stats.fc_ineligible_reason_count[reason]\n\nTRACE_EVENT(ext4_fc_stats,\n\t    TP_PROTO(struct super_block *sb),\n\n\t    TP_ARGS(sb),\n\n\t    TP_STRUCT__entry(\n\t\t    __field(dev_t, dev)\n\t\t    __field(struct ext4_sb_info *, sbi)\n\t\t    __field(int, count)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->dev = sb->s_dev;\n\t\t    __entry->sbi = EXT4_SB(sb);\n\t\t    ),\n\n\t    TP_printk(\"dev %d:%d fc ineligible reasons:\\n\"\n\t\t      \"%s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s:%d, %s:%d; \"\n\t\t      \"num_commits:%ld, ineligible: %ld, numblks: %ld\",\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_XATTR),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_CROSS_RENAME),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_JOURNAL_FLAG_CHANGE),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_NOMEM),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_SWAP_BOOT),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_RESIZE),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_RENAME_DIR),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_FALLOC_RANGE),\n\t\t      FC_REASON_NAME_STAT(EXT4_FC_REASON_INODE_JOURNAL_DATA),\n\t\t      __entry->sbi->s_fc_stats.fc_num_commits,\n\t\t      __entry->sbi->s_fc_stats.fc_ineligible_commits,\n\t\t      __entry->sbi->s_fc_stats.fc_numblks)\n\n);\n\n#define DEFINE_TRACE_DENTRY_EVENT(__type)\t\t\t\t\\\n\tTRACE_EVENT(ext4_fc_track_##__type,\t\t\t\t\\\n\t    TP_PROTO(struct inode *inode, struct dentry *dentry, int ret), \\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_ARGS(inode, dentry, ret),\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_STRUCT__entry(\t\t\t\t\t\t\\\n\t\t    __field(dev_t, dev)\t\t\t\t\t\\\n\t\t    __field(int, ino)\t\t\t\t\t\\\n\t\t    __field(int, error)\t\t\t\t\t\\\n\t\t    ),\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_fast_assign(\t\t\t\t\t\t\\\n\t\t    __entry->dev = inode->i_sb->s_dev;\t\t\t\\\n\t\t    __entry->ino = inode->i_ino;\t\t\t\\\n\t\t    __entry->error = ret;\t\t\t\t\\\n\t\t    ),\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t    TP_printk(\"dev %d:%d, inode %d, error %d, fc_%s\",\t\t\\\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\t\t\\\n\t\t      __entry->ino, __entry->error,\t\t\t\\\n\t\t      #__type)\t\t\t\t\t\t\\\n\t)\n\nDEFINE_TRACE_DENTRY_EVENT(create);\nDEFINE_TRACE_DENTRY_EVENT(link);\nDEFINE_TRACE_DENTRY_EVENT(unlink);\n\nTRACE_EVENT(ext4_fc_track_inode,\n\t    TP_PROTO(struct inode *inode, int ret),\n\n\t    TP_ARGS(inode, ret),\n\n\t    TP_STRUCT__entry(\n\t\t    __field(dev_t, dev)\n\t\t    __field(int, ino)\n\t\t    __field(int, error)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->dev = inode->i_sb->s_dev;\n\t\t    __entry->ino = inode->i_ino;\n\t\t    __entry->error = ret;\n\t\t    ),\n\n\t    TP_printk(\"dev %d:%d, inode %d, error %d\",\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t      __entry->ino, __entry->error)\n\t);\n\nTRACE_EVENT(ext4_fc_track_range,\n\t    TP_PROTO(struct inode *inode, long start, long end, int ret),\n\n\t    TP_ARGS(inode, start, end, ret),\n\n\t    TP_STRUCT__entry(\n\t\t    __field(dev_t, dev)\n\t\t    __field(int, ino)\n\t\t    __field(long, start)\n\t\t    __field(long, end)\n\t\t    __field(int, error)\n\t\t    ),\n\n\t    TP_fast_assign(\n\t\t    __entry->dev = inode->i_sb->s_dev;\n\t\t    __entry->ino = inode->i_ino;\n\t\t    __entry->start = start;\n\t\t    __entry->end = end;\n\t\t    __entry->error = ret;\n\t\t    ),\n\n\t    TP_printk(\"dev %d:%d, inode %d, error %d, start %ld, end %ld\",\n\t\t      MAJOR(__entry->dev), MINOR(__entry->dev),\n\t\t      __entry->ino, __entry->error, __entry->start,\n\t\t      __entry->end)\n\t);\n\n#endif /* _TRACE_EXT4_H */\n\n/* This part must be outside protection */\n#include <trace/define_trace.h>\n"}, "2": {"id": 2, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n\n#include <asm/byteorder.h>\n\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\nextern int _cond_resched(void);\n# define might_resched() _cond_resched()\n#else\n# define might_resched() do { } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_migrate(const char *file, int line);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n\n/**\n * cant_migrate - annotation for functions that cannot migrate\n *\n * Will print a stack trace if executed in code which is migratable\n */\n# define cant_migrate()\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (IS_ENABLED(CONFIG_SMP))\t\t\t\t\\\n\t\t\t__cant_migrate(__FILE__, __LINE__);\t\t\\\n\t} while (0)\n\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define cant_migrate()\t\tdo { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_max_rcu_stall_to_panic;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}, "3": {"id": 3, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Builtins */\n\n/*\n * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.\n * In the meantime, to support gcc < 10, we implement __has_builtin\n * by hand.\n */\n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#define __must_check\t\t__attribute__((__warn_unused_result__))\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}, "5": {"id": 5, "path": "/src/fs/ext4/extents_status.h", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n *  fs/ext4/extents_status.h\n *\n * Written by Yongqiang Yang <xiaoqiangnk@gmail.com>\n * Modified by\n *\tAllison Henderson <achender@linux.vnet.ibm.com>\n *\tZheng Liu <wenqing.lz@taobao.com>\n *\n */\n\n#ifndef _EXT4_EXTENTS_STATUS_H\n#define _EXT4_EXTENTS_STATUS_H\n\n/*\n * Turn on ES_DEBUG__ to get lots of info about extent status operations.\n */\n#ifdef ES_DEBUG__\n#define es_debug(fmt, ...)\tprintk(fmt, ##__VA_ARGS__)\n#else\n#define es_debug(fmt, ...)\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n/*\n * With ES_AGGRESSIVE_TEST defined, the result of es caching will be\n * checked with old map_block's result.\n */\n#define ES_AGGRESSIVE_TEST__\n\n/*\n * These flags live in the high bits of extent_status.es_pblk\n */\nenum {\n\tES_WRITTEN_B,\n\tES_UNWRITTEN_B,\n\tES_DELAYED_B,\n\tES_HOLE_B,\n\tES_REFERENCED_B,\n\tES_FLAGS\n};\n\n#define ES_SHIFT (sizeof(ext4_fsblk_t)*8 - ES_FLAGS)\n#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\n#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)\n#define EXTENT_STATUS_REFERENCED\t(1 << ES_REFERENCED_B)\n\n#define ES_TYPE_MASK\t((ext4_fsblk_t)(EXTENT_STATUS_WRITTEN | \\\n\t\t\t  EXTENT_STATUS_UNWRITTEN | \\\n\t\t\t  EXTENT_STATUS_DELAYED | \\\n\t\t\t  EXTENT_STATUS_HOLE) << ES_SHIFT)\n\nstruct ext4_sb_info;\nstruct ext4_extent;\n\nstruct extent_status {\n\tstruct rb_node rb_node;\n\text4_lblk_t es_lblk;\t/* first logical block extent covers */\n\text4_lblk_t es_len;\t/* length of extent in block */\n\text4_fsblk_t es_pblk;\t/* first physical block */\n};\n\nstruct ext4_es_tree {\n\tstruct rb_root root;\n\tstruct extent_status *cache_es;\t/* recently accessed extent */\n};\n\nstruct ext4_es_stats {\n\tunsigned long es_stats_shrunk;\n\tstruct percpu_counter es_stats_cache_hits;\n\tstruct percpu_counter es_stats_cache_misses;\n\tu64 es_stats_scan_time;\n\tu64 es_stats_max_scan_time;\n\tstruct percpu_counter es_stats_all_cnt;\n\tstruct percpu_counter es_stats_shk_cnt;\n};\n\n/*\n * Pending cluster reservations for bigalloc file systems\n *\n * A cluster with a pending reservation is a logical cluster shared by at\n * least one extent in the extents status tree with delayed and unwritten\n * status and at least one other written or unwritten extent.  The\n * reservation is said to be pending because a cluster reservation would\n * have to be taken in the event all blocks in the cluster shared with\n * written or unwritten extents were deleted while the delayed and\n * unwritten blocks remained.\n *\n * The set of pending cluster reservations is an auxiliary data structure\n * used with the extents status tree to implement reserved cluster/block\n * accounting for bigalloc file systems.  The set is kept in memory and\n * records all pending cluster reservations.\n *\n * Its primary function is to avoid the need to read extents from the\n * disk when invalidating pages as a result of a truncate, punch hole, or\n * collapse range operation.  Page invalidation requires a decrease in the\n * reserved cluster count if it results in the removal of all delayed\n * and unwritten extents (blocks) from a cluster that is not shared with a\n * written or unwritten extent, and no decrease otherwise.  Determining\n * whether the cluster is shared can be done by searching for a pending\n * reservation on it.\n *\n * Secondarily, it provides a potentially faster method for determining\n * whether the reserved cluster count should be increased when a physical\n * cluster is deallocated as a result of a truncate, punch hole, or\n * collapse range operation.  The necessary information is also present\n * in the extents status tree, but might be more rapidly accessed in\n * the pending reservation set in many cases due to smaller size.\n *\n * The pending cluster reservation set is implemented as a red-black tree\n * with the goal of minimizing per page search time overhead.\n */\n\nstruct pending_reservation {\n\tstruct rb_node rb_node;\n\text4_lblk_t lclu;\n};\n\nstruct ext4_pending_tree {\n\tstruct rb_root root;\n};\n\nextern int __init ext4_init_es(void);\nextern void ext4_exit_es(void);\nextern void ext4_es_init_tree(struct ext4_es_tree *tree);\n\nextern int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t\t unsigned int status);\nextern void ext4_es_cache_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t\t unsigned int status);\nextern int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t ext4_lblk_t len);\nextern void ext4_es_find_extent_range(struct inode *inode,\n\t\t\t\t      int (*match_fn)(struct extent_status *es),\n\t\t\t\t      ext4_lblk_t lblk, ext4_lblk_t end,\n\t\t\t\t      struct extent_status *es);\nextern int ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t ext4_lblk_t *next_lblk,\n\t\t\t\t struct extent_status *es);\nextern bool ext4_es_scan_range(struct inode *inode,\n\t\t\t       int (*matching_fn)(struct extent_status *es),\n\t\t\t       ext4_lblk_t lblk, ext4_lblk_t end);\nextern bool ext4_es_scan_clu(struct inode *inode,\n\t\t\t     int (*matching_fn)(struct extent_status *es),\n\t\t\t     ext4_lblk_t lblk);\n\nstatic inline unsigned int ext4_es_status(struct extent_status *es)\n{\n\treturn es->es_pblk >> ES_SHIFT;\n}\n\nstatic inline unsigned int ext4_es_type(struct extent_status *es)\n{\n\treturn (es->es_pblk & ES_TYPE_MASK) >> ES_SHIFT;\n}\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}\n\nstatic inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}\n\nstatic inline int ext4_es_is_mapped(struct extent_status *es)\n{\n\treturn (ext4_es_is_written(es) || ext4_es_is_unwritten(es));\n}\n\nstatic inline int ext4_es_is_delonly(struct extent_status *es)\n{\n\treturn (ext4_es_is_delayed(es) && !ext4_es_is_unwritten(es));\n}\n\nstatic inline void ext4_es_set_referenced(struct extent_status *es)\n{\n\tes->es_pblk |= ((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT;\n}\n\nstatic inline void ext4_es_clear_referenced(struct extent_status *es)\n{\n\tes->es_pblk &= ~(((ext4_fsblk_t)EXTENT_STATUS_REFERENCED) << ES_SHIFT);\n}\n\nstatic inline int ext4_es_is_referenced(struct extent_status *es)\n{\n\treturn (ext4_es_status(es) & EXTENT_STATUS_REFERENCED) != 0;\n}\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}\n\nstatic inline ext4_fsblk_t ext4_es_show_pblock(struct extent_status *es)\n{\n\text4_fsblk_t pblock = ext4_es_pblock(es);\n\treturn pblock == ~ES_MASK ? 0 : pblock;\n}\n\nstatic inline void ext4_es_store_pblock(struct extent_status *es,\n\t\t\t\t\text4_fsblk_t pb)\n{\n\text4_fsblk_t block;\n\n\tblock = (pb & ~ES_MASK) | (es->es_pblk & ES_MASK);\n\tes->es_pblk = block;\n}\n\nstatic inline void ext4_es_store_status(struct extent_status *es,\n\t\t\t\t\tunsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (es->es_pblk & ~ES_MASK);\n}\n\nstatic inline void ext4_es_store_pblock_status(struct extent_status *es,\n\t\t\t\t\t       ext4_fsblk_t pb,\n\t\t\t\t\t       unsigned int status)\n{\n\tes->es_pblk = (((ext4_fsblk_t)status << ES_SHIFT) & ES_MASK) |\n\t\t      (pb & ~ES_MASK);\n}\n\nextern int ext4_es_register_shrinker(struct ext4_sb_info *sbi);\nextern void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi);\n\nextern int ext4_seq_es_shrinker_info_show(struct seq_file *seq, void *v);\n\nextern int __init ext4_init_pending(void);\nextern void ext4_exit_pending(void);\nextern void ext4_init_pending_tree(struct ext4_pending_tree *tree);\nextern void ext4_remove_pending(struct inode *inode, ext4_lblk_t lblk);\nextern bool ext4_is_pending(struct inode *inode, ext4_lblk_t lblk);\nextern int ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t\tbool allocated);\nextern unsigned int ext4_es_delayed_clu(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t\text4_lblk_t len);\nextern void ext4_clear_inode_es(struct inode *inode);\n\n#endif /* _EXT4_EXTENTS_STATUS_H */\n"}, "6": {"id": 6, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 31, "file": 0, "line": 1306}, "message": "Left side of '&&' is false"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 61, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 31, "file": 0, "line": 1306}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 322}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 310}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 4, "line": 302}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 31, "file": 0, "line": 1306}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 322}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 310}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 300}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 0, "line": 1316}, "message": "Assuming 'reserved' is not equal to NULL"}, {"location": {"col": 6, "file": 0, "line": 1316}, "message": "Left side of '||' is false"}, {"location": {"col": 26, "file": 0, "line": 1316}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1316}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1322}, "message": "Assuming 'es' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1322}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1324}, "message": "Assuming 'end' is >= field 'es_lblk'"}, {"location": {"col": 2, "file": 0, "line": 1324}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1329}, "message": "'count_reserved' is true"}, {"location": {"col": 2, "file": 0, "line": 1329}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1330}, "message": "Calling 'init_rsvd'"}, {"location": {"col": 6, "file": 0, "line": 1024}, "message": "Assuming field 's_cluster_ratio' is <= 1"}, {"location": {"col": 2, "file": 0, "line": 1024}, "message": "Taking false branch"}, {"location": {"col": 1, "file": 0, "line": 1036}, "message": "Returning without writing to 'rc->first_do_lblk_found'"}, {"location": {"col": 3, "file": 0, "line": 1330}, "message": "Returning from 'init_rsvd'"}, {"location": {"col": 9, "file": 0, "line": 1336}, "message": "Assuming 'lblk' is <= field 'es_lblk'"}, {"location": {"col": 9, "file": 0, "line": 1336}, "message": "'?' condition is false"}, {"location": {"col": 9, "file": 0, "line": 1337}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 1337}, "message": "'?' condition is false"}, {"location": {"col": 6, "file": 0, "line": 1338}, "message": "'len1' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1338}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1340}, "message": "'len2' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1340}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1378}, "message": "'len1' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1378}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 1389}, "message": "'es' is non-null"}, {"location": {"col": 9, "file": 0, "line": 1389}, "message": "Left side of '&&' is true"}, {"location": {"col": 15, "file": 0, "line": 1389}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1389}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 1390}, "message": "'count_reserved' is true"}, {"location": {"col": 3, "file": 0, "line": 1390}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1391}, "message": "Calling 'count_rsvd'"}, {"location": {"col": 7, "file": 0, "line": 1058}, "message": "Calling 'ext4_es_is_delonly'"}, {"location": {"col": 10, "file": 5, "line": 189}, "message": "Left side of '&&' is true"}, {"location": {"col": 2, "file": 5, "line": 189}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 1058}, "message": "Returning from 'ext4_es_is_delonly'"}, {"location": {"col": 2, "file": 0, "line": 1058}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 1061}, "message": "Assuming 'len' is > 0"}, {"location": {"col": 25, "file": 6, "line": 119}, "message": "expanded from macro 'WARN_ON'"}, {"location": {"col": 2, "file": 0, "line": 1061}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 6, "line": 120}, "message": "expanded from macro 'WARN_ON'"}, {"location": {"col": 6, "file": 0, "line": 1063}, "message": "Assuming field 's_cluster_ratio' is not equal to 1"}, {"location": {"col": 2, "file": 0, "line": 1063}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 1070}, "message": "'lblk' is >= field 'es_lblk'"}, {"location": {"col": 6, "file": 0, "line": 1070}, "message": "'?' condition is false"}, {"location": {"col": 9, "file": 0, "line": 1072}, "message": "Assuming the condition is false"}, {"location": {"col": 8, "file": 0, "line": 1072}, "message": "'?' condition is false"}, {"location": {"col": 6, "file": 0, "line": 1075}, "message": "Branch condition evaluates to a garbage value"}, {"location": {"col": 6, "file": 0, "line": 1075}, "message": "Branch condition evaluates to a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/ext4/extents_status.c", "reportHash": "2b6b3e52e6ec84fafcfa2139d5be6b4f", "checkerName": "clang-analyzer-core.uninitialized.Branch", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 31, "file": 0, "line": 1306}, "message": "Left side of '&&' is false"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 61, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 31, "file": 0, "line": 1306}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 322}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 310}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 4, "line": 302}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 31, "file": 0, "line": 1306}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 322}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 310}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 300}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 0, "line": 1316}, "message": "Assuming 'reserved' is not equal to NULL"}, {"location": {"col": 6, "file": 0, "line": 1316}, "message": "Left side of '||' is false"}, {"location": {"col": 26, "file": 0, "line": 1316}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1316}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1322}, "message": "Assuming 'es' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1322}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1324}, "message": "Assuming 'end' is >= field 'es_lblk'"}, {"location": {"col": 2, "file": 0, "line": 1324}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1329}, "message": "'count_reserved' is true"}, {"location": {"col": 2, "file": 0, "line": 1329}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1330}, "message": "Calling 'init_rsvd'"}, {"location": {"col": 6, "file": 0, "line": 1024}, "message": "Assuming field 's_cluster_ratio' is <= 1"}, {"location": {"col": 2, "file": 0, "line": 1024}, "message": "Taking false branch"}, {"location": {"col": 1, "file": 0, "line": 1036}, "message": "Returning without writing to 'rc->partial'"}, {"location": {"col": 3, "file": 0, "line": 1330}, "message": "Returning from 'init_rsvd'"}, {"location": {"col": 9, "file": 0, "line": 1336}, "message": "Assuming 'lblk' is <= field 'es_lblk'"}, {"location": {"col": 9, "file": 0, "line": 1336}, "message": "'?' condition is false"}, {"location": {"col": 9, "file": 0, "line": 1337}, "message": "Assuming the condition is false"}, {"location": {"col": 9, "file": 0, "line": 1337}, "message": "'?' condition is false"}, {"location": {"col": 6, "file": 0, "line": 1338}, "message": "'len1' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1338}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1340}, "message": "'len2' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1340}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1378}, "message": "'len1' is <= 0"}, {"location": {"col": 2, "file": 0, "line": 1378}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 1389}, "message": "'es' is non-null"}, {"location": {"col": 9, "file": 0, "line": 1389}, "message": "Left side of '&&' is true"}, {"location": {"col": 15, "file": 0, "line": 1389}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 1389}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 1390}, "message": "'count_reserved' is true"}, {"location": {"col": 3, "file": 0, "line": 1390}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1391}, "message": "Calling 'count_rsvd'"}, {"location": {"col": 2, "file": 0, "line": 1058}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 1059}, "message": "Returning without writing to 'rc->partial'"}, {"location": {"col": 4, "file": 0, "line": 1391}, "message": "Returning from 'count_rsvd'"}, {"location": {"col": 7, "file": 0, "line": 1395}, "message": "Assuming 'node' is null"}, {"location": {"col": 3, "file": 0, "line": 1395}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1397}, "message": "Execution continues on line 1402"}, {"location": {"col": 6, "file": 0, "line": 1402}, "message": "'es' is null"}, {"location": {"col": 9, "file": 0, "line": 1402}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 1417}, "message": "'count_reserved' is true"}, {"location": {"col": 2, "file": 0, "line": 1417}, "message": "Taking true branch"}, {"location": {"col": 15, "file": 0, "line": 1418}, "message": "Calling 'get_rsvd'"}, {"location": {"col": 36, "file": 0, "line": 1181}, "message": "Left side of '&&' is false"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 61, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 36, "file": 0, "line": 1181}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 322}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 310}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 4, "line": 302}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 36, "file": 0, "line": 1181}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 24, "file": 1, "line": 22}, "message": "expanded from macro 'EXT4_I'"}, {"location": {"col": 2, "file": 2, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 322}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 310}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 300}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 6, "file": 0, "line": 1187}, "message": "Assuming field 's_cluster_ratio' is > 1"}, {"location": {"col": 2, "file": 0, "line": 1187}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1189}, "message": "Branch condition evaluates to a garbage value"}, {"location": {"col": 7, "file": 0, "line": 1189}, "message": "Branch condition evaluates to a garbage value"}], "macros": [], "notes": [], "path": "/src/fs/ext4/extents_status.c", "reportHash": "6ab390f2f36886e3c33eee84f5202d64", "checkerName": "clang-analyzer-core.uninitialized.Branch", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
