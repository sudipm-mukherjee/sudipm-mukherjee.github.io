<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Driver for Marvell PPv2 network controller for Armada 375 SoC.\n *\n * Copyright (C) 2014 Marvell\n *\n * Marcin Wojtas <mw@semihalf.com>\n */\n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_device.h>\n#include <linux/skbuff.h>\n#include <linux/inetdevice.h>\n#include <linux/mbus.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/interrupt.h>\n#include <linux/cpumask.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/phy.h>\n#include <linux/phylink.h>\n#include <linux/phy/phy.h>\n#include <linux/ptp_classify.h>\n#include <linux/clk.h>\n#include <linux/hrtimer.h>\n#include <linux/ktime.h>\n#include <linux/regmap.h>\n#include <uapi/linux/ppp_defs.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/tso.h>\n#include <linux/bpf_trace.h>\n\n#include \"mvpp2.h\"\n#include \"mvpp2_prs.h\"\n#include \"mvpp2_cls.h\"\n\nenum mvpp2_bm_pool_log_num {\n\tMVPP2_BM_SHORT,\n\tMVPP2_BM_LONG,\n\tMVPP2_BM_JUMBO,\n\tMVPP2_BM_POOLS_NUM\n};\n\nstatic struct {\n\tint pkt_size;\n\tint buf_num;\n} mvpp2_pools[MVPP2_BM_POOLS_NUM];\n\n/* The prototype is added here to be used in start_dev when using ACPI. This\n * will be removed once phylink is used for all modes (dt+ACPI).\n */\nstatic void mvpp2_acpi_start(struct mvpp2_port *port);\n\n/* Queue modes */\n#define MVPP2_QDIST_SINGLE_MODE\t0\n#define MVPP2_QDIST_MULTI_MODE\t1\n\nstatic int queue_mode = MVPP2_QDIST_MULTI_MODE;\n\nmodule_param(queue_mode, int, 0444);\nMODULE_PARM_DESC(queue_mode, \"Set queue_mode (single=0, multi=1)\");\n\n/* Utility/helper methods */\n\nvoid mvpp2_write(struct mvpp2 *priv, u32 offset, u32 data)\n{\n\twritel(data, priv->swth_base[0] + offset);\n}\n\nu32 mvpp2_read(struct mvpp2 *priv, u32 offset)\n{\n\treturn readl(priv->swth_base[0] + offset);\n}\n\nstatic u32 mvpp2_read_relaxed(struct mvpp2 *priv, u32 offset)\n{\n\treturn readl_relaxed(priv->swth_base[0] + offset);\n}\n\nstatic inline u32 mvpp2_cpu_to_thread(struct mvpp2 *priv, int cpu)\n{\n\treturn cpu % priv->nthreads;\n}\n\nstatic struct page_pool *\nmvpp2_create_page_pool(struct device *dev, int num, int len,\n\t\t       enum dma_data_direction dma_dir)\n{\n\tstruct page_pool_params pp_params = {\n\t\t/* internal DMA mapping in page_pool */\n\t\t.flags = PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV,\n\t\t.pool_size = num,\n\t\t.nid = NUMA_NO_NODE,\n\t\t.dev = dev,\n\t\t.dma_dir = dma_dir,\n\t\t.offset = MVPP2_SKB_HEADROOM,\n\t\t.max_len = len,\n\t};\n\n\treturn page_pool_create(&pp_params);\n}\n\n/* These accessors should be used to access:\n *\n * - per-thread registers, where each thread has its own copy of the\n *   register.\n *\n *   MVPP2_BM_VIRT_ALLOC_REG\n *   MVPP2_BM_ADDR_HIGH_ALLOC\n *   MVPP22_BM_ADDR_HIGH_RLS_REG\n *   MVPP2_BM_VIRT_RLS_REG\n *   MVPP2_ISR_RX_TX_CAUSE_REG\n *   MVPP2_ISR_RX_TX_MASK_REG\n *   MVPP2_TXQ_NUM_REG\n *   MVPP2_AGGR_TXQ_UPDATE_REG\n *   MVPP2_TXQ_RSVD_REQ_REG\n *   MVPP2_TXQ_RSVD_RSLT_REG\n *   MVPP2_TXQ_SENT_REG\n *   MVPP2_RXQ_NUM_REG\n *\n * - global registers that must be accessed through a specific thread\n *   window, because they are related to an access to a per-thread\n *   register\n *\n *   MVPP2_BM_PHY_ALLOC_REG    (related to MVPP2_BM_VIRT_ALLOC_REG)\n *   MVPP2_BM_PHY_RLS_REG      (related to MVPP2_BM_VIRT_RLS_REG)\n *   MVPP2_RXQ_THRESH_REG      (related to MVPP2_RXQ_NUM_REG)\n *   MVPP2_RXQ_DESC_ADDR_REG   (related to MVPP2_RXQ_NUM_REG)\n *   MVPP2_RXQ_DESC_SIZE_REG   (related to MVPP2_RXQ_NUM_REG)\n *   MVPP2_RXQ_INDEX_REG       (related to MVPP2_RXQ_NUM_REG)\n *   MVPP2_TXQ_PENDING_REG     (related to MVPP2_TXQ_NUM_REG)\n *   MVPP2_TXQ_DESC_ADDR_REG   (related to MVPP2_TXQ_NUM_REG)\n *   MVPP2_TXQ_DESC_SIZE_REG   (related to MVPP2_TXQ_NUM_REG)\n *   MVPP2_TXQ_INDEX_REG       (related to MVPP2_TXQ_NUM_REG)\n *   MVPP2_TXQ_PENDING_REG     (related to MVPP2_TXQ_NUM_REG)\n *   MVPP2_TXQ_PREF_BUF_REG    (related to MVPP2_TXQ_NUM_REG)\n *   MVPP2_TXQ_PREF_BUF_REG    (related to MVPP2_TXQ_NUM_REG)\n */\nstatic void mvpp2_thread_write(struct mvpp2 *priv, unsigned int thread,\n\t\t\t       u32 offset, u32 data)\n{\n\twritel(data, priv->swth_base[thread] + offset);\n}\n\nstatic u32 mvpp2_thread_read(struct mvpp2 *priv, unsigned int thread,\n\t\t\t     u32 offset)\n{\n\treturn readl(priv->swth_base[thread] + offset);\n}\n\nstatic void mvpp2_thread_write_relaxed(struct mvpp2 *priv, unsigned int thread,\n\t\t\t\t       u32 offset, u32 data)\n{\n\twritel_relaxed(data, priv->swth_base[thread] + offset);\n}\n\nstatic u32 mvpp2_thread_read_relaxed(struct mvpp2 *priv, unsigned int thread,\n\t\t\t\t     u32 offset)\n{\n\treturn readl_relaxed(priv->swth_base[thread] + offset);\n}\n\nstatic dma_addr_t mvpp2_txdesc_dma_addr_get(struct mvpp2_port *port,\n\t\t\t\t\t    struct mvpp2_tx_desc *tx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn le32_to_cpu(tx_desc->pp21.buf_dma_addr);\n\telse\n\t\treturn le64_to_cpu(tx_desc->pp22.buf_dma_addr_ptp) &\n\t\t       MVPP2_DESC_DMA_MASK;\n}\n\nstatic void mvpp2_txdesc_dma_addr_set(struct mvpp2_port *port,\n\t\t\t\t      struct mvpp2_tx_desc *tx_desc,\n\t\t\t\t      dma_addr_t dma_addr)\n{\n\tdma_addr_t addr, offset;\n\n\taddr = dma_addr & ~MVPP2_TX_DESC_ALIGN;\n\toffset = dma_addr & MVPP2_TX_DESC_ALIGN;\n\n\tif (port->priv->hw_version == MVPP21) {\n\t\ttx_desc->pp21.buf_dma_addr = cpu_to_le32(addr);\n\t\ttx_desc->pp21.packet_offset = offset;\n\t} else {\n\t\t__le64 val = cpu_to_le64(addr);\n\n\t\ttx_desc->pp22.buf_dma_addr_ptp &= ~cpu_to_le64(MVPP2_DESC_DMA_MASK);\n\t\ttx_desc->pp22.buf_dma_addr_ptp |= val;\n\t\ttx_desc->pp22.packet_offset = offset;\n\t}\n}\n\nstatic size_t mvpp2_txdesc_size_get(struct mvpp2_port *port,\n\t\t\t\t    struct mvpp2_tx_desc *tx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn le16_to_cpu(tx_desc->pp21.data_size);\n\telse\n\t\treturn le16_to_cpu(tx_desc->pp22.data_size);\n}\n\nstatic void mvpp2_txdesc_size_set(struct mvpp2_port *port,\n\t\t\t\t  struct mvpp2_tx_desc *tx_desc,\n\t\t\t\t  size_t size)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\ttx_desc->pp21.data_size = cpu_to_le16(size);\n\telse\n\t\ttx_desc->pp22.data_size = cpu_to_le16(size);\n}\n\nstatic void mvpp2_txdesc_txq_set(struct mvpp2_port *port,\n\t\t\t\t struct mvpp2_tx_desc *tx_desc,\n\t\t\t\t unsigned int txq)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\ttx_desc->pp21.phys_txq = txq;\n\telse\n\t\ttx_desc->pp22.phys_txq = txq;\n}\n\nstatic void mvpp2_txdesc_cmd_set(struct mvpp2_port *port,\n\t\t\t\t struct mvpp2_tx_desc *tx_desc,\n\t\t\t\t unsigned int command)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\ttx_desc->pp21.command = cpu_to_le32(command);\n\telse\n\t\ttx_desc->pp22.command = cpu_to_le32(command);\n}\n\nstatic unsigned int mvpp2_txdesc_offset_get(struct mvpp2_port *port,\n\t\t\t\t\t    struct mvpp2_tx_desc *tx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn tx_desc->pp21.packet_offset;\n\telse\n\t\treturn tx_desc->pp22.packet_offset;\n}\n\nstatic dma_addr_t mvpp2_rxdesc_dma_addr_get(struct mvpp2_port *port,\n\t\t\t\t\t    struct mvpp2_rx_desc *rx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn le32_to_cpu(rx_desc->pp21.buf_dma_addr);\n\telse\n\t\treturn le64_to_cpu(rx_desc->pp22.buf_dma_addr_key_hash) &\n\t\t       MVPP2_DESC_DMA_MASK;\n}\n\nstatic unsigned long mvpp2_rxdesc_cookie_get(struct mvpp2_port *port,\n\t\t\t\t\t     struct mvpp2_rx_desc *rx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn le32_to_cpu(rx_desc->pp21.buf_cookie);\n\telse\n\t\treturn le64_to_cpu(rx_desc->pp22.buf_cookie_misc) &\n\t\t       MVPP2_DESC_DMA_MASK;\n}\n\nstatic size_t mvpp2_rxdesc_size_get(struct mvpp2_port *port,\n\t\t\t\t    struct mvpp2_rx_desc *rx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn le16_to_cpu(rx_desc->pp21.data_size);\n\telse\n\t\treturn le16_to_cpu(rx_desc->pp22.data_size);\n}\n\nstatic u32 mvpp2_rxdesc_status_get(struct mvpp2_port *port,\n\t\t\t\t   struct mvpp2_rx_desc *rx_desc)\n{\n\tif (port->priv->hw_version == MVPP21)\n\t\treturn le32_to_cpu(rx_desc->pp21.status);\n\telse\n\t\treturn le32_to_cpu(rx_desc->pp22.status);\n}\n\nstatic void mvpp2_txq_inc_get(struct mvpp2_txq_pcpu *txq_pcpu)\n{\n\ttxq_pcpu->txq_get_index++;\n\tif (txq_pcpu->txq_get_index == txq_pcpu->size)\n\t\ttxq_pcpu->txq_get_index = 0;\n}\n\nstatic void mvpp2_txq_inc_put(struct mvpp2_port *port,\n\t\t\t      struct mvpp2_txq_pcpu *txq_pcpu,\n\t\t\t      void *data,\n\t\t\t      struct mvpp2_tx_desc *tx_desc,\n\t\t\t      enum mvpp2_tx_buf_type buf_type)\n{\n\tstruct mvpp2_txq_pcpu_buf *tx_buf =\n\t\ttxq_pcpu->buffs + txq_pcpu->txq_put_index;\n\ttx_buf->type = buf_type;\n\tif (buf_type == MVPP2_TYPE_SKB)\n\t\ttx_buf->skb = data;\n\telse\n\t\ttx_buf->xdpf = data;\n\ttx_buf->size = mvpp2_txdesc_size_get(port, tx_desc);\n\ttx_buf->dma = mvpp2_txdesc_dma_addr_get(port, tx_desc) +\n\t\tmvpp2_txdesc_offset_get(port, tx_desc);\n\ttxq_pcpu->txq_put_index++;\n\tif (txq_pcpu->txq_put_index == txq_pcpu->size)\n\t\ttxq_pcpu->txq_put_index = 0;\n}\n\n/* Get number of maximum RXQ */\nstatic int mvpp2_get_nrxqs(struct mvpp2 *priv)\n{\n\tunsigned int nrxqs;\n\n\tif (priv->hw_version == MVPP22 && queue_mode == MVPP2_QDIST_SINGLE_MODE)\n\t\treturn 1;\n\n\t/* According to the PPv2.2 datasheet and our experiments on\n\t * PPv2.1, RX queues have an allocation granularity of 4 (when\n\t * more than a single one on PPv2.2).\n\t * Round up to nearest multiple of 4.\n\t */\n\tnrxqs = (num_possible_cpus() + 3) & ~0x3;\n\tif (nrxqs > MVPP2_PORT_MAX_RXQ)\n\t\tnrxqs = MVPP2_PORT_MAX_RXQ;\n\n\treturn nrxqs;\n}\n\n/* Get number of physical egress port */\nstatic inline int mvpp2_egress_port(struct mvpp2_port *port)\n{\n\treturn MVPP2_MAX_TCONT + port->id;\n}\n\n/* Get number of physical TXQ */\nstatic inline int mvpp2_txq_phys(int port, int txq)\n{\n\treturn (MVPP2_MAX_TCONT + port) * MVPP2_MAX_TXQ + txq;\n}\n\n/* Returns a struct page if page_pool is set, otherwise a buffer */\nstatic void *mvpp2_frag_alloc(const struct mvpp2_bm_pool *pool,\n\t\t\t      struct page_pool *page_pool)\n{\n\tif (page_pool)\n\t\treturn page_pool_dev_alloc_pages(page_pool);\n\n\tif (likely(pool->frag_size <= PAGE_SIZE))\n\t\treturn netdev_alloc_frag(pool->frag_size);\n\n\treturn kmalloc(pool->frag_size, GFP_ATOMIC);\n}\n\nstatic void mvpp2_frag_free(const struct mvpp2_bm_pool *pool,\n\t\t\t    struct page_pool *page_pool, void *data)\n{\n\tif (page_pool)\n\t\tpage_pool_put_full_page(page_pool, virt_to_head_page(data), false);\n\telse if (likely(pool->frag_size <= PAGE_SIZE))\n\t\tskb_free_frag(data);\n\telse\n\t\tkfree(data);\n}\n\n/* Buffer Manager configuration routines */\n\n/* Create pool */\nstatic int mvpp2_bm_pool_create(struct device *dev, struct mvpp2 *priv,\n\t\t\t\tstruct mvpp2_bm_pool *bm_pool, int size)\n{\n\tu32 val;\n\n\t/* Number of buffer pointers must be a multiple of 16, as per\n\t * hardware constraints\n\t */\n\tif (!IS_ALIGNED(size, 16))\n\t\treturn -EINVAL;\n\n\t/* PPv2.1 needs 8 bytes per buffer pointer, PPv2.2 needs 16\n\t * bytes per buffer pointer\n\t */\n\tif (priv->hw_version == MVPP21)\n\t\tbm_pool->size_bytes = 2 * sizeof(u32) * size;\n\telse\n\t\tbm_pool->size_bytes = 2 * sizeof(u64) * size;\n\n\tbm_pool->virt_addr = dma_alloc_coherent(dev, bm_pool->size_bytes,\n\t\t\t\t\t\t&bm_pool->dma_addr,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!bm_pool->virt_addr)\n\t\treturn -ENOMEM;\n\n\tif (!IS_ALIGNED((unsigned long)bm_pool->virt_addr,\n\t\t\tMVPP2_BM_POOL_PTR_ALIGN)) {\n\t\tdma_free_coherent(dev, bm_pool->size_bytes,\n\t\t\t\t  bm_pool->virt_addr, bm_pool->dma_addr);\n\t\tdev_err(dev, \"BM pool %d is not %d bytes aligned\\n\",\n\t\t\tbm_pool->id, MVPP2_BM_POOL_PTR_ALIGN);\n\t\treturn -ENOMEM;\n\t}\n\n\tmvpp2_write(priv, MVPP2_BM_POOL_BASE_REG(bm_pool->id),\n\t\t    lower_32_bits(bm_pool->dma_addr));\n\tmvpp2_write(priv, MVPP2_BM_POOL_SIZE_REG(bm_pool->id), size);\n\n\tval = mvpp2_read(priv, MVPP2_BM_POOL_CTRL_REG(bm_pool->id));\n\tval |= MVPP2_BM_START_MASK;\n\tmvpp2_write(priv, MVPP2_BM_POOL_CTRL_REG(bm_pool->id), val);\n\n\tbm_pool->size = size;\n\tbm_pool->pkt_size = 0;\n\tbm_pool->buf_num = 0;\n\n\treturn 0;\n}\n\n/* Set pool buffer size */\nstatic void mvpp2_bm_pool_bufsize_set(struct mvpp2 *priv,\n\t\t\t\t      struct mvpp2_bm_pool *bm_pool,\n\t\t\t\t      int buf_size)\n{\n\tu32 val;\n\n\tbm_pool->buf_size = buf_size;\n\n\tval = ALIGN(buf_size, 1 << MVPP2_POOL_BUF_SIZE_OFFSET);\n\tmvpp2_write(priv, MVPP2_POOL_BUF_SIZE_REG(bm_pool->id), val);\n}\n\nstatic void mvpp2_bm_bufs_get_addrs(struct device *dev, struct mvpp2 *priv,\n\t\t\t\t    struct mvpp2_bm_pool *bm_pool,\n\t\t\t\t    dma_addr_t *dma_addr,\n\t\t\t\t    phys_addr_t *phys_addr)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(priv, get_cpu());\n\n\t*dma_addr = mvpp2_thread_read(priv, thread,\n\t\t\t\t      MVPP2_BM_PHY_ALLOC_REG(bm_pool->id));\n\t*phys_addr = mvpp2_thread_read(priv, thread, MVPP2_BM_VIRT_ALLOC_REG);\n\n\tif (priv->hw_version == MVPP22) {\n\t\tu32 val;\n\t\tu32 dma_addr_highbits, phys_addr_highbits;\n\n\t\tval = mvpp2_thread_read(priv, thread, MVPP22_BM_ADDR_HIGH_ALLOC);\n\t\tdma_addr_highbits = (val & MVPP22_BM_ADDR_HIGH_PHYS_MASK);\n\t\tphys_addr_highbits = (val & MVPP22_BM_ADDR_HIGH_VIRT_MASK) >>\n\t\t\tMVPP22_BM_ADDR_HIGH_VIRT_SHIFT;\n\n\t\tif (sizeof(dma_addr_t) == 8)\n\t\t\t*dma_addr |= (u64)dma_addr_highbits << 32;\n\n\t\tif (sizeof(phys_addr_t) == 8)\n\t\t\t*phys_addr |= (u64)phys_addr_highbits << 32;\n\t}\n\n\tput_cpu();\n}\n\n/* Free all buffers from the pool */\nstatic void mvpp2_bm_bufs_free(struct device *dev, struct mvpp2 *priv,\n\t\t\t       struct mvpp2_bm_pool *bm_pool, int buf_num)\n{\n\tstruct page_pool *pp = NULL;\n\tint i;\n\n\tif (buf_num > bm_pool->buf_num) {\n\t\tWARN(1, \"Pool does not have so many bufs pool(%d) bufs(%d)\\n\",\n\t\t     bm_pool->id, buf_num);\n\t\tbuf_num = bm_pool->buf_num;\n\t}\n\n\tif (priv->percpu_pools)\n\t\tpp = priv->page_pool[bm_pool->id];\n\n\tfor (i = 0; i < buf_num; i++) {\n\t\tdma_addr_t buf_dma_addr;\n\t\tphys_addr_t buf_phys_addr;\n\t\tvoid *data;\n\n\t\tmvpp2_bm_bufs_get_addrs(dev, priv, bm_pool,\n\t\t\t\t\t&buf_dma_addr, &buf_phys_addr);\n\n\t\tif (!pp)\n\t\t\tdma_unmap_single(dev, buf_dma_addr,\n\t\t\t\t\t bm_pool->buf_size, DMA_FROM_DEVICE);\n\n\t\tdata = (void *)phys_to_virt(buf_phys_addr);\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\tmvpp2_frag_free(bm_pool, pp, data);\n\t}\n\n\t/* Update BM driver with number of buffers removed from pool */\n\tbm_pool->buf_num -= i;\n}\n\n/* Check number of buffers in BM pool */\nstatic int mvpp2_check_hw_buf_num(struct mvpp2 *priv, struct mvpp2_bm_pool *bm_pool)\n{\n\tint buf_num = 0;\n\n\tbuf_num += mvpp2_read(priv, MVPP2_BM_POOL_PTRS_NUM_REG(bm_pool->id)) &\n\t\t\t\t    MVPP22_BM_POOL_PTRS_NUM_MASK;\n\tbuf_num += mvpp2_read(priv, MVPP2_BM_BPPI_PTRS_NUM_REG(bm_pool->id)) &\n\t\t\t\t    MVPP2_BM_BPPI_PTR_NUM_MASK;\n\n\t/* HW has one buffer ready which is not reflected in the counters */\n\tif (buf_num)\n\t\tbuf_num += 1;\n\n\treturn buf_num;\n}\n\n/* Cleanup pool */\nstatic int mvpp2_bm_pool_destroy(struct device *dev, struct mvpp2 *priv,\n\t\t\t\t struct mvpp2_bm_pool *bm_pool)\n{\n\tint buf_num;\n\tu32 val;\n\n\tbuf_num = mvpp2_check_hw_buf_num(priv, bm_pool);\n\tmvpp2_bm_bufs_free(dev, priv, bm_pool, buf_num);\n\n\t/* Check buffer counters after free */\n\tbuf_num = mvpp2_check_hw_buf_num(priv, bm_pool);\n\tif (buf_num) {\n\t\tWARN(1, \"cannot free all buffers in pool %d, buf_num left %d\\n\",\n\t\t     bm_pool->id, bm_pool->buf_num);\n\t\treturn 0;\n\t}\n\n\tval = mvpp2_read(priv, MVPP2_BM_POOL_CTRL_REG(bm_pool->id));\n\tval |= MVPP2_BM_STOP_MASK;\n\tmvpp2_write(priv, MVPP2_BM_POOL_CTRL_REG(bm_pool->id), val);\n\n\tif (priv->percpu_pools) {\n\t\tpage_pool_destroy(priv->page_pool[bm_pool->id]);\n\t\tpriv->page_pool[bm_pool->id] = NULL;\n\t}\n\n\tdma_free_coherent(dev, bm_pool->size_bytes,\n\t\t\t  bm_pool->virt_addr,\n\t\t\t  bm_pool->dma_addr);\n\treturn 0;\n}\n\nstatic int mvpp2_bm_pools_init(struct device *dev, struct mvpp2 *priv)\n{\n\tint i, err, size, poolnum = MVPP2_BM_POOLS_NUM;\n\tstruct mvpp2_bm_pool *bm_pool;\n\n\tif (priv->percpu_pools)\n\t\tpoolnum = mvpp2_get_nrxqs(priv) * 2;\n\n\t/* Create all pools with maximum size */\n\tsize = MVPP2_BM_POOL_SIZE_MAX;\n\tfor (i = 0; i < poolnum; i++) {\n\t\tbm_pool = &priv->bm_pools[i];\n\t\tbm_pool->id = i;\n\t\terr = mvpp2_bm_pool_create(dev, priv, bm_pool, size);\n\t\tif (err)\n\t\t\tgoto err_unroll_pools;\n\t\tmvpp2_bm_pool_bufsize_set(priv, bm_pool, 0);\n\t}\n\treturn 0;\n\nerr_unroll_pools:\n\tdev_err(dev, \"failed to create BM pool %d, size %d\\n\", i, size);\n\tfor (i = i - 1; i >= 0; i--)\n\t\tmvpp2_bm_pool_destroy(dev, priv, &priv->bm_pools[i]);\n\treturn err;\n}\n\nstatic int mvpp2_bm_init(struct device *dev, struct mvpp2 *priv)\n{\n\tenum dma_data_direction dma_dir = DMA_FROM_DEVICE;\n\tint i, err, poolnum = MVPP2_BM_POOLS_NUM;\n\tstruct mvpp2_port *port;\n\n\tif (priv->percpu_pools) {\n\t\tfor (i = 0; i < priv->port_count; i++) {\n\t\t\tport = priv->port_list[i];\n\t\t\tif (port->xdp_prog) {\n\t\t\t\tdma_dir = DMA_BIDIRECTIONAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpoolnum = mvpp2_get_nrxqs(priv) * 2;\n\t\tfor (i = 0; i < poolnum; i++) {\n\t\t\t/* the pool in use */\n\t\t\tint pn = i / (poolnum / 2);\n\n\t\t\tpriv->page_pool[i] =\n\t\t\t\tmvpp2_create_page_pool(dev,\n\t\t\t\t\t\t       mvpp2_pools[pn].buf_num,\n\t\t\t\t\t\t       mvpp2_pools[pn].pkt_size,\n\t\t\t\t\t\t       dma_dir);\n\t\t\tif (IS_ERR(priv->page_pool[i])) {\n\t\t\t\tint j;\n\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tpage_pool_destroy(priv->page_pool[j]);\n\t\t\t\t\tpriv->page_pool[j] = NULL;\n\t\t\t\t}\n\t\t\t\treturn PTR_ERR(priv->page_pool[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_info(dev, \"using %d %s buffers\\n\", poolnum,\n\t\t priv->percpu_pools ? \"per-cpu\" : \"shared\");\n\n\tfor (i = 0; i < poolnum; i++) {\n\t\t/* Mask BM all interrupts */\n\t\tmvpp2_write(priv, MVPP2_BM_INTR_MASK_REG(i), 0);\n\t\t/* Clear BM cause register */\n\t\tmvpp2_write(priv, MVPP2_BM_INTR_CAUSE_REG(i), 0);\n\t}\n\n\t/* Allocate and initialize BM pools */\n\tpriv->bm_pools = devm_kcalloc(dev, poolnum,\n\t\t\t\t      sizeof(*priv->bm_pools), GFP_KERNEL);\n\tif (!priv->bm_pools)\n\t\treturn -ENOMEM;\n\n\terr = mvpp2_bm_pools_init(dev, priv);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void mvpp2_setup_bm_pool(void)\n{\n\t/* Short pool */\n\tmvpp2_pools[MVPP2_BM_SHORT].buf_num  = MVPP2_BM_SHORT_BUF_NUM;\n\tmvpp2_pools[MVPP2_BM_SHORT].pkt_size = MVPP2_BM_SHORT_PKT_SIZE;\n\n\t/* Long pool */\n\tmvpp2_pools[MVPP2_BM_LONG].buf_num  = MVPP2_BM_LONG_BUF_NUM;\n\tmvpp2_pools[MVPP2_BM_LONG].pkt_size = MVPP2_BM_LONG_PKT_SIZE;\n\n\t/* Jumbo pool */\n\tmvpp2_pools[MVPP2_BM_JUMBO].buf_num  = MVPP2_BM_JUMBO_BUF_NUM;\n\tmvpp2_pools[MVPP2_BM_JUMBO].pkt_size = MVPP2_BM_JUMBO_PKT_SIZE;\n}\n\n/* Attach long pool to rxq */\nstatic void mvpp2_rxq_long_pool_set(struct mvpp2_port *port,\n\t\t\t\t    int lrxq, int long_pool)\n{\n\tu32 val, mask;\n\tint prxq;\n\n\t/* Get queue physical ID */\n\tprxq = port->rxqs[lrxq]->id;\n\n\tif (port->priv->hw_version == MVPP21)\n\t\tmask = MVPP21_RXQ_POOL_LONG_MASK;\n\telse\n\t\tmask = MVPP22_RXQ_POOL_LONG_MASK;\n\n\tval = mvpp2_read(port->priv, MVPP2_RXQ_CONFIG_REG(prxq));\n\tval &= ~mask;\n\tval |= (long_pool << MVPP2_RXQ_POOL_LONG_OFFS) & mask;\n\tmvpp2_write(port->priv, MVPP2_RXQ_CONFIG_REG(prxq), val);\n}\n\n/* Attach short pool to rxq */\nstatic void mvpp2_rxq_short_pool_set(struct mvpp2_port *port,\n\t\t\t\t     int lrxq, int short_pool)\n{\n\tu32 val, mask;\n\tint prxq;\n\n\t/* Get queue physical ID */\n\tprxq = port->rxqs[lrxq]->id;\n\n\tif (port->priv->hw_version == MVPP21)\n\t\tmask = MVPP21_RXQ_POOL_SHORT_MASK;\n\telse\n\t\tmask = MVPP22_RXQ_POOL_SHORT_MASK;\n\n\tval = mvpp2_read(port->priv, MVPP2_RXQ_CONFIG_REG(prxq));\n\tval &= ~mask;\n\tval |= (short_pool << MVPP2_RXQ_POOL_SHORT_OFFS) & mask;\n\tmvpp2_write(port->priv, MVPP2_RXQ_CONFIG_REG(prxq), val);\n}\n\nstatic void *mvpp2_buf_alloc(struct mvpp2_port *port,\n\t\t\t     struct mvpp2_bm_pool *bm_pool,\n\t\t\t     struct page_pool *page_pool,\n\t\t\t     dma_addr_t *buf_dma_addr,\n\t\t\t     phys_addr_t *buf_phys_addr,\n\t\t\t     gfp_t gfp_mask)\n{\n\tdma_addr_t dma_addr;\n\tstruct page *page;\n\tvoid *data;\n\n\tdata = mvpp2_frag_alloc(bm_pool, page_pool);\n\tif (!data)\n\t\treturn NULL;\n\n\tif (page_pool) {\n\t\tpage = (struct page *)data;\n\t\tdma_addr = page_pool_get_dma_addr(page);\n\t\tdata = page_to_virt(page);\n\t} else {\n\t\tdma_addr = dma_map_single(port->dev->dev.parent, data,\n\t\t\t\t\t  MVPP2_RX_BUF_SIZE(bm_pool->pkt_size),\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(port->dev->dev.parent, dma_addr))) {\n\t\t\tmvpp2_frag_free(bm_pool, NULL, data);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t*buf_dma_addr = dma_addr;\n\t*buf_phys_addr = virt_to_phys(data);\n\n\treturn data;\n}\n\n/* Release buffer to BM */\nstatic inline void mvpp2_bm_pool_put(struct mvpp2_port *port, int pool,\n\t\t\t\t     dma_addr_t buf_dma_addr,\n\t\t\t\t     phys_addr_t buf_phys_addr)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tunsigned long flags = 0;\n\n\tif (test_bit(thread, &port->priv->lock_map))\n\t\tspin_lock_irqsave(&port->bm_lock[thread], flags);\n\n\tif (port->priv->hw_version == MVPP22) {\n\t\tu32 val = 0;\n\n\t\tif (sizeof(dma_addr_t) == 8)\n\t\t\tval |= upper_32_bits(buf_dma_addr) &\n\t\t\t\tMVPP22_BM_ADDR_HIGH_PHYS_RLS_MASK;\n\n\t\tif (sizeof(phys_addr_t) == 8)\n\t\t\tval |= (upper_32_bits(buf_phys_addr)\n\t\t\t\t<< MVPP22_BM_ADDR_HIGH_VIRT_RLS_SHIFT) &\n\t\t\t\tMVPP22_BM_ADDR_HIGH_VIRT_RLS_MASK;\n\n\t\tmvpp2_thread_write_relaxed(port->priv, thread,\n\t\t\t\t\t   MVPP22_BM_ADDR_HIGH_RLS_REG, val);\n\t}\n\n\t/* MVPP2_BM_VIRT_RLS_REG is not interpreted by HW, and simply\n\t * returned in the \"cookie\" field of the RX\n\t * descriptor. Instead of storing the virtual address, we\n\t * store the physical address\n\t */\n\tmvpp2_thread_write_relaxed(port->priv, thread,\n\t\t\t\t   MVPP2_BM_VIRT_RLS_REG, buf_phys_addr);\n\tmvpp2_thread_write_relaxed(port->priv, thread,\n\t\t\t\t   MVPP2_BM_PHY_RLS_REG(pool), buf_dma_addr);\n\n\tif (test_bit(thread, &port->priv->lock_map))\n\t\tspin_unlock_irqrestore(&port->bm_lock[thread], flags);\n\n\tput_cpu();\n}\n\n/* Allocate buffers for the pool */\nstatic int mvpp2_bm_bufs_add(struct mvpp2_port *port,\n\t\t\t     struct mvpp2_bm_pool *bm_pool, int buf_num)\n{\n\tint i, buf_size, total_size;\n\tdma_addr_t dma_addr;\n\tphys_addr_t phys_addr;\n\tstruct page_pool *pp = NULL;\n\tvoid *buf;\n\n\tif (port->priv->percpu_pools &&\n\t    bm_pool->pkt_size > MVPP2_BM_LONG_PKT_SIZE) {\n\t\tnetdev_err(port->dev,\n\t\t\t   \"attempted to use jumbo frames with per-cpu pools\");\n\t\treturn 0;\n\t}\n\n\tbuf_size = MVPP2_RX_BUF_SIZE(bm_pool->pkt_size);\n\ttotal_size = MVPP2_RX_TOTAL_SIZE(buf_size);\n\n\tif (buf_num < 0 ||\n\t    (buf_num + bm_pool->buf_num > bm_pool->size)) {\n\t\tnetdev_err(port->dev,\n\t\t\t   \"cannot allocate %d buffers for pool %d\\n\",\n\t\t\t   buf_num, bm_pool->id);\n\t\treturn 0;\n\t}\n\n\tif (port->priv->percpu_pools)\n\t\tpp = port->priv->page_pool[bm_pool->id];\n\tfor (i = 0; i < buf_num; i++) {\n\t\tbuf = mvpp2_buf_alloc(port, bm_pool, pp, &dma_addr,\n\t\t\t\t      &phys_addr, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tbreak;\n\n\t\tmvpp2_bm_pool_put(port, bm_pool->id, dma_addr,\n\t\t\t\t  phys_addr);\n\t}\n\n\t/* Update BM driver with number of buffers added to pool */\n\tbm_pool->buf_num += i;\n\n\tnetdev_dbg(port->dev,\n\t\t   \"pool %d: pkt_size=%4d, buf_size=%4d, total_size=%4d\\n\",\n\t\t   bm_pool->id, bm_pool->pkt_size, buf_size, total_size);\n\n\tnetdev_dbg(port->dev,\n\t\t   \"pool %d: %d of %d buffers added\\n\",\n\t\t   bm_pool->id, i, buf_num);\n\treturn i;\n}\n\n/* Notify the driver that BM pool is being used as specific type and return the\n * pool pointer on success\n */\nstatic struct mvpp2_bm_pool *\nmvpp2_bm_pool_use(struct mvpp2_port *port, unsigned pool, int pkt_size)\n{\n\tstruct mvpp2_bm_pool *new_pool = &port->priv->bm_pools[pool];\n\tint num;\n\n\tif ((port->priv->percpu_pools && pool > mvpp2_get_nrxqs(port->priv) * 2) ||\n\t    (!port->priv->percpu_pools && pool >= MVPP2_BM_POOLS_NUM)) {\n\t\tnetdev_err(port->dev, \"Invalid pool %d\\n\", pool);\n\t\treturn NULL;\n\t}\n\n\t/* Allocate buffers in case BM pool is used as long pool, but packet\n\t * size doesn't match MTU or BM pool hasn't being used yet\n\t */\n\tif (new_pool->pkt_size == 0) {\n\t\tint pkts_num;\n\n\t\t/* Set default buffer number or free all the buffers in case\n\t\t * the pool is not empty\n\t\t */\n\t\tpkts_num = new_pool->buf_num;\n\t\tif (pkts_num == 0) {\n\t\t\tif (port->priv->percpu_pools) {\n\t\t\t\tif (pool < port->nrxqs)\n\t\t\t\t\tpkts_num = mvpp2_pools[MVPP2_BM_SHORT].buf_num;\n\t\t\t\telse\n\t\t\t\t\tpkts_num = mvpp2_pools[MVPP2_BM_LONG].buf_num;\n\t\t\t} else {\n\t\t\t\tpkts_num = mvpp2_pools[pool].buf_num;\n\t\t\t}\n\t\t} else {\n\t\t\tmvpp2_bm_bufs_free(port->dev->dev.parent,\n\t\t\t\t\t   port->priv, new_pool, pkts_num);\n\t\t}\n\n\t\tnew_pool->pkt_size = pkt_size;\n\t\tnew_pool->frag_size =\n\t\t\tSKB_DATA_ALIGN(MVPP2_RX_BUF_SIZE(pkt_size)) +\n\t\t\tMVPP2_SKB_SHINFO_SIZE;\n\n\t\t/* Allocate buffers for this pool */\n\t\tnum = mvpp2_bm_bufs_add(port, new_pool, pkts_num);\n\t\tif (num != pkts_num) {\n\t\t\tWARN(1, \"pool %d: %d of %d allocated\\n\",\n\t\t\t     new_pool->id, num, pkts_num);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmvpp2_bm_pool_bufsize_set(port->priv, new_pool,\n\t\t\t\t  MVPP2_RX_BUF_SIZE(new_pool->pkt_size));\n\n\treturn new_pool;\n}\n\nstatic struct mvpp2_bm_pool *\nmvpp2_bm_pool_use_percpu(struct mvpp2_port *port, int type,\n\t\t\t unsigned int pool, int pkt_size)\n{\n\tstruct mvpp2_bm_pool *new_pool = &port->priv->bm_pools[pool];\n\tint num;\n\n\tif (pool > port->nrxqs * 2) {\n\t\tnetdev_err(port->dev, \"Invalid pool %d\\n\", pool);\n\t\treturn NULL;\n\t}\n\n\t/* Allocate buffers in case BM pool is used as long pool, but packet\n\t * size doesn't match MTU or BM pool hasn't being used yet\n\t */\n\tif (new_pool->pkt_size == 0) {\n\t\tint pkts_num;\n\n\t\t/* Set default buffer number or free all the buffers in case\n\t\t * the pool is not empty\n\t\t */\n\t\tpkts_num = new_pool->buf_num;\n\t\tif (pkts_num == 0)\n\t\t\tpkts_num = mvpp2_pools[type].buf_num;\n\t\telse\n\t\t\tmvpp2_bm_bufs_free(port->dev->dev.parent,\n\t\t\t\t\t   port->priv, new_pool, pkts_num);\n\n\t\tnew_pool->pkt_size = pkt_size;\n\t\tnew_pool->frag_size =\n\t\t\tSKB_DATA_ALIGN(MVPP2_RX_BUF_SIZE(pkt_size)) +\n\t\t\tMVPP2_SKB_SHINFO_SIZE;\n\n\t\t/* Allocate buffers for this pool */\n\t\tnum = mvpp2_bm_bufs_add(port, new_pool, pkts_num);\n\t\tif (num != pkts_num) {\n\t\t\tWARN(1, \"pool %d: %d of %d allocated\\n\",\n\t\t\t     new_pool->id, num, pkts_num);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmvpp2_bm_pool_bufsize_set(port->priv, new_pool,\n\t\t\t\t  MVPP2_RX_BUF_SIZE(new_pool->pkt_size));\n\n\treturn new_pool;\n}\n\n/* Initialize pools for swf, shared buffers variant */\nstatic int mvpp2_swf_bm_pool_init_shared(struct mvpp2_port *port)\n{\n\tenum mvpp2_bm_pool_log_num long_log_pool, short_log_pool;\n\tint rxq;\n\n\t/* If port pkt_size is higher than 1518B:\n\t * HW Long pool - SW Jumbo pool, HW Short pool - SW Long pool\n\t * else: HW Long pool - SW Long pool, HW Short pool - SW Short pool\n\t */\n\tif (port->pkt_size > MVPP2_BM_LONG_PKT_SIZE) {\n\t\tlong_log_pool = MVPP2_BM_JUMBO;\n\t\tshort_log_pool = MVPP2_BM_LONG;\n\t} else {\n\t\tlong_log_pool = MVPP2_BM_LONG;\n\t\tshort_log_pool = MVPP2_BM_SHORT;\n\t}\n\n\tif (!port->pool_long) {\n\t\tport->pool_long =\n\t\t\tmvpp2_bm_pool_use(port, long_log_pool,\n\t\t\t\t\t  mvpp2_pools[long_log_pool].pkt_size);\n\t\tif (!port->pool_long)\n\t\t\treturn -ENOMEM;\n\n\t\tport->pool_long->port_map |= BIT(port->id);\n\n\t\tfor (rxq = 0; rxq < port->nrxqs; rxq++)\n\t\t\tmvpp2_rxq_long_pool_set(port, rxq, port->pool_long->id);\n\t}\n\n\tif (!port->pool_short) {\n\t\tport->pool_short =\n\t\t\tmvpp2_bm_pool_use(port, short_log_pool,\n\t\t\t\t\t  mvpp2_pools[short_log_pool].pkt_size);\n\t\tif (!port->pool_short)\n\t\t\treturn -ENOMEM;\n\n\t\tport->pool_short->port_map |= BIT(port->id);\n\n\t\tfor (rxq = 0; rxq < port->nrxqs; rxq++)\n\t\t\tmvpp2_rxq_short_pool_set(port, rxq,\n\t\t\t\t\t\t port->pool_short->id);\n\t}\n\n\treturn 0;\n}\n\n/* Initialize pools for swf, percpu buffers variant */\nstatic int mvpp2_swf_bm_pool_init_percpu(struct mvpp2_port *port)\n{\n\tstruct mvpp2_bm_pool *bm_pool;\n\tint i;\n\n\tfor (i = 0; i < port->nrxqs; i++) {\n\t\tbm_pool = mvpp2_bm_pool_use_percpu(port, MVPP2_BM_SHORT, i,\n\t\t\t\t\t\t   mvpp2_pools[MVPP2_BM_SHORT].pkt_size);\n\t\tif (!bm_pool)\n\t\t\treturn -ENOMEM;\n\n\t\tbm_pool->port_map |= BIT(port->id);\n\t\tmvpp2_rxq_short_pool_set(port, i, bm_pool->id);\n\t}\n\n\tfor (i = 0; i < port->nrxqs; i++) {\n\t\tbm_pool = mvpp2_bm_pool_use_percpu(port, MVPP2_BM_LONG, i + port->nrxqs,\n\t\t\t\t\t\t   mvpp2_pools[MVPP2_BM_LONG].pkt_size);\n\t\tif (!bm_pool)\n\t\t\treturn -ENOMEM;\n\n\t\tbm_pool->port_map |= BIT(port->id);\n\t\tmvpp2_rxq_long_pool_set(port, i, bm_pool->id);\n\t}\n\n\tport->pool_long = NULL;\n\tport->pool_short = NULL;\n\n\treturn 0;\n}\n\nstatic int mvpp2_swf_bm_pool_init(struct mvpp2_port *port)\n{\n\tif (port->priv->percpu_pools)\n\t\treturn mvpp2_swf_bm_pool_init_percpu(port);\n\telse\n\t\treturn mvpp2_swf_bm_pool_init_shared(port);\n}\n\nstatic void mvpp2_set_hw_csum(struct mvpp2_port *port,\n\t\t\t      enum mvpp2_bm_pool_log_num new_long_pool)\n{\n\tconst netdev_features_t csums = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\n\t/* Update L4 checksum when jumbo enable/disable on port.\n\t * Only port 0 supports hardware checksum offload due to\n\t * the Tx FIFO size limitation.\n\t * Also, don't set NETIF_F_HW_CSUM because L3_offset in TX descriptor\n\t * has 7 bits, so the maximum L3 offset is 128.\n\t */\n\tif (new_long_pool == MVPP2_BM_JUMBO && port->id != 0) {\n\t\tport->dev->features &= ~csums;\n\t\tport->dev->hw_features &= ~csums;\n\t} else {\n\t\tport->dev->features |= csums;\n\t\tport->dev->hw_features |= csums;\n\t}\n}\n\nstatic int mvpp2_bm_update_mtu(struct net_device *dev, int mtu)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tenum mvpp2_bm_pool_log_num new_long_pool;\n\tint pkt_size = MVPP2_RX_PKT_SIZE(mtu);\n\n\tif (port->priv->percpu_pools)\n\t\tgoto out_set;\n\n\t/* If port MTU is higher than 1518B:\n\t * HW Long pool - SW Jumbo pool, HW Short pool - SW Long pool\n\t * else: HW Long pool - SW Long pool, HW Short pool - SW Short pool\n\t */\n\tif (pkt_size > MVPP2_BM_LONG_PKT_SIZE)\n\t\tnew_long_pool = MVPP2_BM_JUMBO;\n\telse\n\t\tnew_long_pool = MVPP2_BM_LONG;\n\n\tif (new_long_pool != port->pool_long->id) {\n\t\t/* Remove port from old short & long pool */\n\t\tport->pool_long = mvpp2_bm_pool_use(port, port->pool_long->id,\n\t\t\t\t\t\t    port->pool_long->pkt_size);\n\t\tport->pool_long->port_map &= ~BIT(port->id);\n\t\tport->pool_long = NULL;\n\n\t\tport->pool_short = mvpp2_bm_pool_use(port, port->pool_short->id,\n\t\t\t\t\t\t     port->pool_short->pkt_size);\n\t\tport->pool_short->port_map &= ~BIT(port->id);\n\t\tport->pool_short = NULL;\n\n\t\tport->pkt_size =  pkt_size;\n\n\t\t/* Add port to new short & long pool */\n\t\tmvpp2_swf_bm_pool_init(port);\n\n\t\tmvpp2_set_hw_csum(port, new_long_pool);\n\t}\n\nout_set:\n\tdev->mtu = mtu;\n\tdev->wanted_features = dev->features;\n\n\tnetdev_update_features(dev);\n\treturn 0;\n}\n\nstatic inline void mvpp2_interrupts_enable(struct mvpp2_port *port)\n{\n\tint i, sw_thread_mask = 0;\n\n\tfor (i = 0; i < port->nqvecs; i++)\n\t\tsw_thread_mask |= port->qvecs[i].sw_thread_mask;\n\n\tmvpp2_write(port->priv, MVPP2_ISR_ENABLE_REG(port->id),\n\t\t    MVPP2_ISR_ENABLE_INTERRUPT(sw_thread_mask));\n}\n\nstatic inline void mvpp2_interrupts_disable(struct mvpp2_port *port)\n{\n\tint i, sw_thread_mask = 0;\n\n\tfor (i = 0; i < port->nqvecs; i++)\n\t\tsw_thread_mask |= port->qvecs[i].sw_thread_mask;\n\n\tmvpp2_write(port->priv, MVPP2_ISR_ENABLE_REG(port->id),\n\t\t    MVPP2_ISR_DISABLE_INTERRUPT(sw_thread_mask));\n}\n\nstatic inline void mvpp2_qvec_interrupt_enable(struct mvpp2_queue_vector *qvec)\n{\n\tstruct mvpp2_port *port = qvec->port;\n\n\tmvpp2_write(port->priv, MVPP2_ISR_ENABLE_REG(port->id),\n\t\t    MVPP2_ISR_ENABLE_INTERRUPT(qvec->sw_thread_mask));\n}\n\nstatic inline void mvpp2_qvec_interrupt_disable(struct mvpp2_queue_vector *qvec)\n{\n\tstruct mvpp2_port *port = qvec->port;\n\n\tmvpp2_write(port->priv, MVPP2_ISR_ENABLE_REG(port->id),\n\t\t    MVPP2_ISR_DISABLE_INTERRUPT(qvec->sw_thread_mask));\n}\n\n/* Mask the current thread's Rx/Tx interrupts\n * Called by on_each_cpu(), guaranteed to run with migration disabled,\n * using smp_processor_id() is OK.\n */\nstatic void mvpp2_interrupts_mask(void *arg)\n{\n\tstruct mvpp2_port *port = arg;\n\n\t/* If the thread isn't used, don't do anything */\n\tif (smp_processor_id() > port->priv->nthreads)\n\t\treturn;\n\n\tmvpp2_thread_write(port->priv,\n\t\t\t   mvpp2_cpu_to_thread(port->priv, smp_processor_id()),\n\t\t\t   MVPP2_ISR_RX_TX_MASK_REG(port->id), 0);\n}\n\n/* Unmask the current thread's Rx/Tx interrupts.\n * Called by on_each_cpu(), guaranteed to run with migration disabled,\n * using smp_processor_id() is OK.\n */\nstatic void mvpp2_interrupts_unmask(void *arg)\n{\n\tstruct mvpp2_port *port = arg;\n\tu32 val;\n\n\t/* If the thread isn't used, don't do anything */\n\tif (smp_processor_id() > port->priv->nthreads)\n\t\treturn;\n\n\tval = MVPP2_CAUSE_MISC_SUM_MASK |\n\t\tMVPP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK(port->priv->hw_version);\n\tif (port->has_tx_irqs)\n\t\tval |= MVPP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK;\n\n\tmvpp2_thread_write(port->priv,\n\t\t\t   mvpp2_cpu_to_thread(port->priv, smp_processor_id()),\n\t\t\t   MVPP2_ISR_RX_TX_MASK_REG(port->id), val);\n}\n\nstatic void\nmvpp2_shared_interrupt_mask_unmask(struct mvpp2_port *port, bool mask)\n{\n\tu32 val;\n\tint i;\n\n\tif (port->priv->hw_version != MVPP22)\n\t\treturn;\n\n\tif (mask)\n\t\tval = 0;\n\telse\n\t\tval = MVPP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK(MVPP22);\n\n\tfor (i = 0; i < port->nqvecs; i++) {\n\t\tstruct mvpp2_queue_vector *v = port->qvecs + i;\n\n\t\tif (v->type != MVPP2_QUEUE_VECTOR_SHARED)\n\t\t\tcontinue;\n\n\t\tmvpp2_thread_write(port->priv, v->sw_thread_id,\n\t\t\t\t   MVPP2_ISR_RX_TX_MASK_REG(port->id), val);\n\t}\n}\n\n/* Only GOP port 0 has an XLG MAC */\nstatic bool mvpp2_port_supports_xlg(struct mvpp2_port *port)\n{\n\treturn port->gop_id == 0;\n}\n\nstatic bool mvpp2_port_supports_rgmii(struct mvpp2_port *port)\n{\n\treturn !(port->priv->hw_version == MVPP22 && port->gop_id == 0);\n}\n\n/* Port configuration routines */\nstatic bool mvpp2_is_xlg(phy_interface_t interface)\n{\n\treturn interface == PHY_INTERFACE_MODE_10GBASER ||\n\t       interface == PHY_INTERFACE_MODE_XAUI;\n}\n\nstatic void mvpp2_modify(void __iomem *ptr, u32 mask, u32 set)\n{\n\tu32 old, val;\n\n\told = val = readl(ptr);\n\tval &= ~mask;\n\tval |= set;\n\tif (old != val)\n\t\twritel(val, ptr);\n}\n\nstatic void mvpp22_gop_init_rgmii(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tu32 val;\n\n\tregmap_read(priv->sysctrl_base, GENCONF_PORT_CTRL0, &val);\n\tval |= GENCONF_PORT_CTRL0_BUS_WIDTH_SELECT;\n\tregmap_write(priv->sysctrl_base, GENCONF_PORT_CTRL0, val);\n\n\tregmap_read(priv->sysctrl_base, GENCONF_CTRL0, &val);\n\tif (port->gop_id == 2)\n\t\tval |= GENCONF_CTRL0_PORT0_RGMII | GENCONF_CTRL0_PORT1_RGMII;\n\telse if (port->gop_id == 3)\n\t\tval |= GENCONF_CTRL0_PORT1_RGMII_MII;\n\tregmap_write(priv->sysctrl_base, GENCONF_CTRL0, val);\n}\n\nstatic void mvpp22_gop_init_sgmii(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tu32 val;\n\n\tregmap_read(priv->sysctrl_base, GENCONF_PORT_CTRL0, &val);\n\tval |= GENCONF_PORT_CTRL0_BUS_WIDTH_SELECT |\n\t       GENCONF_PORT_CTRL0_RX_DATA_SAMPLE;\n\tregmap_write(priv->sysctrl_base, GENCONF_PORT_CTRL0, val);\n\n\tif (port->gop_id > 1) {\n\t\tregmap_read(priv->sysctrl_base, GENCONF_CTRL0, &val);\n\t\tif (port->gop_id == 2)\n\t\t\tval &= ~GENCONF_CTRL0_PORT0_RGMII;\n\t\telse if (port->gop_id == 3)\n\t\t\tval &= ~GENCONF_CTRL0_PORT1_RGMII_MII;\n\t\tregmap_write(priv->sysctrl_base, GENCONF_CTRL0, val);\n\t}\n}\n\nstatic void mvpp22_gop_init_10gkr(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tvoid __iomem *mpcs = priv->iface_base + MVPP22_MPCS_BASE(port->gop_id);\n\tvoid __iomem *xpcs = priv->iface_base + MVPP22_XPCS_BASE(port->gop_id);\n\tu32 val;\n\n\tval = readl(xpcs + MVPP22_XPCS_CFG0);\n\tval &= ~(MVPP22_XPCS_CFG0_PCS_MODE(0x3) |\n\t\t MVPP22_XPCS_CFG0_ACTIVE_LANE(0x3));\n\tval |= MVPP22_XPCS_CFG0_ACTIVE_LANE(2);\n\twritel(val, xpcs + MVPP22_XPCS_CFG0);\n\n\tval = readl(mpcs + MVPP22_MPCS_CTRL);\n\tval &= ~MVPP22_MPCS_CTRL_FWD_ERR_CONN;\n\twritel(val, mpcs + MVPP22_MPCS_CTRL);\n\n\tval = readl(mpcs + MVPP22_MPCS_CLK_RESET);\n\tval &= ~MVPP22_MPCS_CLK_RESET_DIV_RATIO(0x7);\n\tval |= MVPP22_MPCS_CLK_RESET_DIV_RATIO(1);\n\twritel(val, mpcs + MVPP22_MPCS_CLK_RESET);\n}\n\nstatic int mvpp22_gop_init(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tu32 val;\n\n\tif (!priv->sysctrl_base)\n\t\treturn 0;\n\n\tswitch (port->phy_interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tif (!mvpp2_port_supports_rgmii(port))\n\t\t\tgoto invalid_conf;\n\t\tmvpp22_gop_init_rgmii(port);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tmvpp22_gop_init_sgmii(port);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tif (!mvpp2_port_supports_xlg(port))\n\t\t\tgoto invalid_conf;\n\t\tmvpp22_gop_init_10gkr(port);\n\t\tbreak;\n\tdefault:\n\t\tgoto unsupported_conf;\n\t}\n\n\tregmap_read(priv->sysctrl_base, GENCONF_PORT_CTRL1, &val);\n\tval |= GENCONF_PORT_CTRL1_RESET(port->gop_id) |\n\t       GENCONF_PORT_CTRL1_EN(port->gop_id);\n\tregmap_write(priv->sysctrl_base, GENCONF_PORT_CTRL1, val);\n\n\tregmap_read(priv->sysctrl_base, GENCONF_PORT_CTRL0, &val);\n\tval |= GENCONF_PORT_CTRL0_CLK_DIV_PHASE_CLR;\n\tregmap_write(priv->sysctrl_base, GENCONF_PORT_CTRL0, val);\n\n\tregmap_read(priv->sysctrl_base, GENCONF_SOFT_RESET1, &val);\n\tval |= GENCONF_SOFT_RESET1_GOP;\n\tregmap_write(priv->sysctrl_base, GENCONF_SOFT_RESET1, val);\n\nunsupported_conf:\n\treturn 0;\n\ninvalid_conf:\n\tnetdev_err(port->dev, \"Invalid port configuration\\n\");\n\treturn -EINVAL;\n}\n\nstatic void mvpp22_gop_unmask_irq(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tif (phy_interface_mode_is_rgmii(port->phy_interface) ||\n\t    phy_interface_mode_is_8023z(port->phy_interface) ||\n\t    port->phy_interface == PHY_INTERFACE_MODE_SGMII) {\n\t\t/* Enable the GMAC link status irq for this port */\n\t\tval = readl(port->base + MVPP22_GMAC_INT_SUM_MASK);\n\t\tval |= MVPP22_GMAC_INT_SUM_MASK_LINK_STAT;\n\t\twritel(val, port->base + MVPP22_GMAC_INT_SUM_MASK);\n\t}\n\n\tif (mvpp2_port_supports_xlg(port)) {\n\t\t/* Enable the XLG/GIG irqs for this port */\n\t\tval = readl(port->base + MVPP22_XLG_EXT_INT_MASK);\n\t\tif (mvpp2_is_xlg(port->phy_interface))\n\t\t\tval |= MVPP22_XLG_EXT_INT_MASK_XLG;\n\t\telse\n\t\t\tval |= MVPP22_XLG_EXT_INT_MASK_GIG;\n\t\twritel(val, port->base + MVPP22_XLG_EXT_INT_MASK);\n\t}\n}\n\nstatic void mvpp22_gop_mask_irq(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tif (mvpp2_port_supports_xlg(port)) {\n\t\tval = readl(port->base + MVPP22_XLG_EXT_INT_MASK);\n\t\tval &= ~(MVPP22_XLG_EXT_INT_MASK_XLG |\n\t\t\t MVPP22_XLG_EXT_INT_MASK_GIG);\n\t\twritel(val, port->base + MVPP22_XLG_EXT_INT_MASK);\n\t}\n\n\tif (phy_interface_mode_is_rgmii(port->phy_interface) ||\n\t    phy_interface_mode_is_8023z(port->phy_interface) ||\n\t    port->phy_interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval = readl(port->base + MVPP22_GMAC_INT_SUM_MASK);\n\t\tval &= ~MVPP22_GMAC_INT_SUM_MASK_LINK_STAT;\n\t\twritel(val, port->base + MVPP22_GMAC_INT_SUM_MASK);\n\t}\n}\n\nstatic void mvpp22_gop_setup_irq(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tmvpp2_modify(port->base + MVPP22_GMAC_INT_SUM_MASK,\n\t\t     MVPP22_GMAC_INT_SUM_MASK_PTP,\n\t\t     MVPP22_GMAC_INT_SUM_MASK_PTP);\n\n\tif (port->phylink ||\n\t    phy_interface_mode_is_rgmii(port->phy_interface) ||\n\t    phy_interface_mode_is_8023z(port->phy_interface) ||\n\t    port->phy_interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval = readl(port->base + MVPP22_GMAC_INT_MASK);\n\t\tval |= MVPP22_GMAC_INT_MASK_LINK_STAT;\n\t\twritel(val, port->base + MVPP22_GMAC_INT_MASK);\n\t}\n\n\tif (mvpp2_port_supports_xlg(port)) {\n\t\tval = readl(port->base + MVPP22_XLG_INT_MASK);\n\t\tval |= MVPP22_XLG_INT_MASK_LINK;\n\t\twritel(val, port->base + MVPP22_XLG_INT_MASK);\n\n\t\tmvpp2_modify(port->base + MVPP22_XLG_EXT_INT_MASK,\n\t\t\t     MVPP22_XLG_EXT_INT_MASK_PTP,\n\t\t\t     MVPP22_XLG_EXT_INT_MASK_PTP);\n\t}\n\n\tmvpp22_gop_unmask_irq(port);\n}\n\n/* Sets the PHY mode of the COMPHY (which configures the serdes lanes).\n *\n * The PHY mode used by the PPv2 driver comes from the network subsystem, while\n * the one given to the COMPHY comes from the generic PHY subsystem. Hence they\n * differ.\n *\n * The COMPHY configures the serdes lanes regardless of the actual use of the\n * lanes by the physical layer. This is why configurations like\n * \"PPv2 (2500BaseX) - COMPHY (2500SGMII)\" are valid.\n */\nstatic int mvpp22_comphy_init(struct mvpp2_port *port)\n{\n\tint ret;\n\n\tif (!port->comphy)\n\t\treturn 0;\n\n\tret = phy_set_mode_ext(port->comphy, PHY_MODE_ETHERNET,\n\t\t\t       port->phy_interface);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_power_on(port->comphy);\n}\n\nstatic void mvpp2_port_enable(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tif (mvpp2_port_supports_xlg(port) &&\n\t    mvpp2_is_xlg(port->phy_interface)) {\n\t\tval = readl(port->base + MVPP22_XLG_CTRL0_REG);\n\t\tval |= MVPP22_XLG_CTRL0_PORT_EN;\n\t\tval &= ~MVPP22_XLG_CTRL0_MIB_CNT_DIS;\n\t\twritel(val, port->base + MVPP22_XLG_CTRL0_REG);\n\t} else {\n\t\tval = readl(port->base + MVPP2_GMAC_CTRL_0_REG);\n\t\tval |= MVPP2_GMAC_PORT_EN_MASK;\n\t\tval |= MVPP2_GMAC_MIB_CNTR_EN_MASK;\n\t\twritel(val, port->base + MVPP2_GMAC_CTRL_0_REG);\n\t}\n}\n\nstatic void mvpp2_port_disable(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tif (mvpp2_port_supports_xlg(port) &&\n\t    mvpp2_is_xlg(port->phy_interface)) {\n\t\tval = readl(port->base + MVPP22_XLG_CTRL0_REG);\n\t\tval &= ~MVPP22_XLG_CTRL0_PORT_EN;\n\t\twritel(val, port->base + MVPP22_XLG_CTRL0_REG);\n\t}\n\n\tval = readl(port->base + MVPP2_GMAC_CTRL_0_REG);\n\tval &= ~(MVPP2_GMAC_PORT_EN_MASK);\n\twritel(val, port->base + MVPP2_GMAC_CTRL_0_REG);\n}\n\n/* Set IEEE 802.3x Flow Control Xon Packet Transmission Mode */\nstatic void mvpp2_port_periodic_xon_disable(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->base + MVPP2_GMAC_CTRL_1_REG) &\n\t\t    ~MVPP2_GMAC_PERIODIC_XON_EN_MASK;\n\twritel(val, port->base + MVPP2_GMAC_CTRL_1_REG);\n}\n\n/* Configure loopback port */\nstatic void mvpp2_port_loopback_set(struct mvpp2_port *port,\n\t\t\t\t    const struct phylink_link_state *state)\n{\n\tu32 val;\n\n\tval = readl(port->base + MVPP2_GMAC_CTRL_1_REG);\n\n\tif (state->speed == 1000)\n\t\tval |= MVPP2_GMAC_GMII_LB_EN_MASK;\n\telse\n\t\tval &= ~MVPP2_GMAC_GMII_LB_EN_MASK;\n\n\tif (phy_interface_mode_is_8023z(state->interface) ||\n\t    state->interface == PHY_INTERFACE_MODE_SGMII)\n\t\tval |= MVPP2_GMAC_PCS_LB_EN_MASK;\n\telse\n\t\tval &= ~MVPP2_GMAC_PCS_LB_EN_MASK;\n\n\twritel(val, port->base + MVPP2_GMAC_CTRL_1_REG);\n}\n\nenum {\n\tETHTOOL_XDP_REDIRECT,\n\tETHTOOL_XDP_PASS,\n\tETHTOOL_XDP_DROP,\n\tETHTOOL_XDP_TX,\n\tETHTOOL_XDP_TX_ERR,\n\tETHTOOL_XDP_XMIT,\n\tETHTOOL_XDP_XMIT_ERR,\n};\n\nstruct mvpp2_ethtool_counter {\n\tunsigned int offset;\n\tconst char string[ETH_GSTRING_LEN];\n\tbool reg_is_64b;\n};\n\nstatic u64 mvpp2_read_count(struct mvpp2_port *port,\n\t\t\t    const struct mvpp2_ethtool_counter *counter)\n{\n\tu64 val;\n\n\tval = readl(port->stats_base + counter->offset);\n\tif (counter->reg_is_64b)\n\t\tval += (u64)readl(port->stats_base + counter->offset + 4) << 32;\n\n\treturn val;\n}\n\n/* Some counters are accessed indirectly by first writing an index to\n * MVPP2_CTRS_IDX. The index can represent various resources depending on the\n * register we access, it can be a hit counter for some classification tables,\n * a counter specific to a rxq, a txq or a buffer pool.\n */\nstatic u32 mvpp2_read_index(struct mvpp2 *priv, u32 index, u32 reg)\n{\n\tmvpp2_write(priv, MVPP2_CTRS_IDX, index);\n\treturn mvpp2_read(priv, reg);\n}\n\n/* Due to the fact that software statistics and hardware statistics are, by\n * design, incremented at different moments in the chain of packet processing,\n * it is very likely that incoming packets could have been dropped after being\n * counted by hardware but before reaching software statistics (most probably\n * multicast packets), and in the oppposite way, during transmission, FCS bytes\n * are added in between as well as TSO skb will be split and header bytes added.\n * Hence, statistics gathered from userspace with ifconfig (software) and\n * ethtool (hardware) cannot be compared.\n */\nstatic const struct mvpp2_ethtool_counter mvpp2_ethtool_mib_regs[] = {\n\t{ MVPP2_MIB_GOOD_OCTETS_RCVD, \"good_octets_received\", true },\n\t{ MVPP2_MIB_BAD_OCTETS_RCVD, \"bad_octets_received\" },\n\t{ MVPP2_MIB_CRC_ERRORS_SENT, \"crc_errors_sent\" },\n\t{ MVPP2_MIB_UNICAST_FRAMES_RCVD, \"unicast_frames_received\" },\n\t{ MVPP2_MIB_BROADCAST_FRAMES_RCVD, \"broadcast_frames_received\" },\n\t{ MVPP2_MIB_MULTICAST_FRAMES_RCVD, \"multicast_frames_received\" },\n\t{ MVPP2_MIB_FRAMES_64_OCTETS, \"frames_64_octets\" },\n\t{ MVPP2_MIB_FRAMES_65_TO_127_OCTETS, \"frames_65_to_127_octet\" },\n\t{ MVPP2_MIB_FRAMES_128_TO_255_OCTETS, \"frames_128_to_255_octet\" },\n\t{ MVPP2_MIB_FRAMES_256_TO_511_OCTETS, \"frames_256_to_511_octet\" },\n\t{ MVPP2_MIB_FRAMES_512_TO_1023_OCTETS, \"frames_512_to_1023_octet\" },\n\t{ MVPP2_MIB_FRAMES_1024_TO_MAX_OCTETS, \"frames_1024_to_max_octet\" },\n\t{ MVPP2_MIB_GOOD_OCTETS_SENT, \"good_octets_sent\", true },\n\t{ MVPP2_MIB_UNICAST_FRAMES_SENT, \"unicast_frames_sent\" },\n\t{ MVPP2_MIB_MULTICAST_FRAMES_SENT, \"multicast_frames_sent\" },\n\t{ MVPP2_MIB_BROADCAST_FRAMES_SENT, \"broadcast_frames_sent\" },\n\t{ MVPP2_MIB_FC_SENT, \"fc_sent\" },\n\t{ MVPP2_MIB_FC_RCVD, \"fc_received\" },\n\t{ MVPP2_MIB_RX_FIFO_OVERRUN, \"rx_fifo_overrun\" },\n\t{ MVPP2_MIB_UNDERSIZE_RCVD, \"undersize_received\" },\n\t{ MVPP2_MIB_FRAGMENTS_RCVD, \"fragments_received\" },\n\t{ MVPP2_MIB_OVERSIZE_RCVD, \"oversize_received\" },\n\t{ MVPP2_MIB_JABBER_RCVD, \"jabber_received\" },\n\t{ MVPP2_MIB_MAC_RCV_ERROR, \"mac_receive_error\" },\n\t{ MVPP2_MIB_BAD_CRC_EVENT, \"bad_crc_event\" },\n\t{ MVPP2_MIB_COLLISION, \"collision\" },\n\t{ MVPP2_MIB_LATE_COLLISION, \"late_collision\" },\n};\n\nstatic const struct mvpp2_ethtool_counter mvpp2_ethtool_port_regs[] = {\n\t{ MVPP2_OVERRUN_ETH_DROP, \"rx_fifo_or_parser_overrun_drops\" },\n\t{ MVPP2_CLS_ETH_DROP, \"rx_classifier_drops\" },\n};\n\nstatic const struct mvpp2_ethtool_counter mvpp2_ethtool_txq_regs[] = {\n\t{ MVPP2_TX_DESC_ENQ_CTR, \"txq_%d_desc_enqueue\" },\n\t{ MVPP2_TX_DESC_ENQ_TO_DDR_CTR, \"txq_%d_desc_enqueue_to_ddr\" },\n\t{ MVPP2_TX_BUFF_ENQ_TO_DDR_CTR, \"txq_%d_buff_euqueue_to_ddr\" },\n\t{ MVPP2_TX_DESC_ENQ_HW_FWD_CTR, \"txq_%d_desc_hardware_forwarded\" },\n\t{ MVPP2_TX_PKTS_DEQ_CTR, \"txq_%d_packets_dequeued\" },\n\t{ MVPP2_TX_PKTS_FULL_QUEUE_DROP_CTR, \"txq_%d_queue_full_drops\" },\n\t{ MVPP2_TX_PKTS_EARLY_DROP_CTR, \"txq_%d_packets_early_drops\" },\n\t{ MVPP2_TX_PKTS_BM_DROP_CTR, \"txq_%d_packets_bm_drops\" },\n\t{ MVPP2_TX_PKTS_BM_MC_DROP_CTR, \"txq_%d_packets_rep_bm_drops\" },\n};\n\nstatic const struct mvpp2_ethtool_counter mvpp2_ethtool_rxq_regs[] = {\n\t{ MVPP2_RX_DESC_ENQ_CTR, \"rxq_%d_desc_enqueue\" },\n\t{ MVPP2_RX_PKTS_FULL_QUEUE_DROP_CTR, \"rxq_%d_queue_full_drops\" },\n\t{ MVPP2_RX_PKTS_EARLY_DROP_CTR, \"rxq_%d_packets_early_drops\" },\n\t{ MVPP2_RX_PKTS_BM_DROP_CTR, \"rxq_%d_packets_bm_drops\" },\n};\n\nstatic const struct mvpp2_ethtool_counter mvpp2_ethtool_xdp[] = {\n\t{ ETHTOOL_XDP_REDIRECT, \"rx_xdp_redirect\", },\n\t{ ETHTOOL_XDP_PASS, \"rx_xdp_pass\", },\n\t{ ETHTOOL_XDP_DROP, \"rx_xdp_drop\", },\n\t{ ETHTOOL_XDP_TX, \"rx_xdp_tx\", },\n\t{ ETHTOOL_XDP_TX_ERR, \"rx_xdp_tx_errors\", },\n\t{ ETHTOOL_XDP_XMIT, \"tx_xdp_xmit\", },\n\t{ ETHTOOL_XDP_XMIT_ERR, \"tx_xdp_xmit_errors\", },\n};\n\n#define MVPP2_N_ETHTOOL_STATS(ntxqs, nrxqs)\t(ARRAY_SIZE(mvpp2_ethtool_mib_regs) + \\\n\t\t\t\t\t\t ARRAY_SIZE(mvpp2_ethtool_port_regs) + \\\n\t\t\t\t\t\t (ARRAY_SIZE(mvpp2_ethtool_txq_regs) * (ntxqs)) + \\\n\t\t\t\t\t\t (ARRAY_SIZE(mvpp2_ethtool_rxq_regs) * (nrxqs)) + \\\n\t\t\t\t\t\t ARRAY_SIZE(mvpp2_ethtool_xdp))\n\nstatic void mvpp2_ethtool_get_strings(struct net_device *netdev, u32 sset,\n\t\t\t\t      u8 *data)\n{\n\tstruct mvpp2_port *port = netdev_priv(netdev);\n\tint i, q;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_mib_regs); i++) {\n\t\tstrscpy(data, mvpp2_ethtool_mib_regs[i].string,\n\t\t\tETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_port_regs); i++) {\n\t\tstrscpy(data, mvpp2_ethtool_port_regs[i].string,\n\t\t\tETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n\n\tfor (q = 0; q < port->ntxqs; q++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_txq_regs); i++) {\n\t\t\tsnprintf(data, ETH_GSTRING_LEN,\n\t\t\t\t mvpp2_ethtool_txq_regs[i].string, q);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\n\tfor (q = 0; q < port->nrxqs; q++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_rxq_regs); i++) {\n\t\t\tsnprintf(data, ETH_GSTRING_LEN,\n\t\t\t\t mvpp2_ethtool_rxq_regs[i].string,\n\t\t\t\t q);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_xdp); i++) {\n\t\tstrscpy(data, mvpp2_ethtool_xdp[i].string,\n\t\t\tETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic void\nmvpp2_get_xdp_stats(struct mvpp2_port *port, struct mvpp2_pcpu_stats *xdp_stats)\n{\n\tunsigned int start;\n\tunsigned int cpu;\n\n\t/* Gather XDP Statistics */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct mvpp2_pcpu_stats *cpu_stats;\n\t\tu64\txdp_redirect;\n\t\tu64\txdp_pass;\n\t\tu64\txdp_drop;\n\t\tu64\txdp_xmit;\n\t\tu64\txdp_xmit_err;\n\t\tu64\txdp_tx;\n\t\tu64\txdp_tx_err;\n\n\t\tcpu_stats = per_cpu_ptr(port->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\n\t\t\txdp_redirect = cpu_stats->xdp_redirect;\n\t\t\txdp_pass   = cpu_stats->xdp_pass;\n\t\t\txdp_drop = cpu_stats->xdp_drop;\n\t\t\txdp_xmit   = cpu_stats->xdp_xmit;\n\t\t\txdp_xmit_err   = cpu_stats->xdp_xmit_err;\n\t\t\txdp_tx   = cpu_stats->xdp_tx;\n\t\t\txdp_tx_err   = cpu_stats->xdp_tx_err;\n\t\t} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));\n\n\t\txdp_stats->xdp_redirect += xdp_redirect;\n\t\txdp_stats->xdp_pass   += xdp_pass;\n\t\txdp_stats->xdp_drop += xdp_drop;\n\t\txdp_stats->xdp_xmit   += xdp_xmit;\n\t\txdp_stats->xdp_xmit_err   += xdp_xmit_err;\n\t\txdp_stats->xdp_tx   += xdp_tx;\n\t\txdp_stats->xdp_tx_err   += xdp_tx_err;\n\t}\n}\n\nstatic void mvpp2_read_stats(struct mvpp2_port *port)\n{\n\tstruct mvpp2_pcpu_stats xdp_stats = {};\n\tconst struct mvpp2_ethtool_counter *s;\n\tu64 *pstats;\n\tint i, q;\n\n\tpstats = port->ethtool_stats;\n\n\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_mib_regs); i++)\n\t\t*pstats++ += mvpp2_read_count(port, &mvpp2_ethtool_mib_regs[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_port_regs); i++)\n\t\t*pstats++ += mvpp2_read(port->priv,\n\t\t\t\t\tmvpp2_ethtool_port_regs[i].offset +\n\t\t\t\t\t4 * port->id);\n\n\tfor (q = 0; q < port->ntxqs; q++)\n\t\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_txq_regs); i++)\n\t\t\t*pstats++ += mvpp2_read_index(port->priv,\n\t\t\t\t\t\t      MVPP22_CTRS_TX_CTR(port->id, q),\n\t\t\t\t\t\t      mvpp2_ethtool_txq_regs[i].offset);\n\n\t/* Rxqs are numbered from 0 from the user standpoint, but not from the\n\t * driver's. We need to add the  port->first_rxq offset.\n\t */\n\tfor (q = 0; q < port->nrxqs; q++)\n\t\tfor (i = 0; i < ARRAY_SIZE(mvpp2_ethtool_rxq_regs); i++)\n\t\t\t*pstats++ += mvpp2_read_index(port->priv,\n\t\t\t\t\t\t      port->first_rxq + q,\n\t\t\t\t\t\t      mvpp2_ethtool_rxq_regs[i].offset);\n\n\t/* Gather XDP Statistics */\n\tmvpp2_get_xdp_stats(port, &xdp_stats);\n\n\tfor (i = 0, s = mvpp2_ethtool_xdp;\n\t\t s < mvpp2_ethtool_xdp + ARRAY_SIZE(mvpp2_ethtool_xdp);\n\t     s++, i++) {\n\t\tswitch (s->offset) {\n\t\tcase ETHTOOL_XDP_REDIRECT:\n\t\t\t*pstats++ = xdp_stats.xdp_redirect;\n\t\t\tbreak;\n\t\tcase ETHTOOL_XDP_PASS:\n\t\t\t*pstats++ = xdp_stats.xdp_pass;\n\t\t\tbreak;\n\t\tcase ETHTOOL_XDP_DROP:\n\t\t\t*pstats++ = xdp_stats.xdp_drop;\n\t\t\tbreak;\n\t\tcase ETHTOOL_XDP_TX:\n\t\t\t*pstats++ = xdp_stats.xdp_tx;\n\t\t\tbreak;\n\t\tcase ETHTOOL_XDP_TX_ERR:\n\t\t\t*pstats++ = xdp_stats.xdp_tx_err;\n\t\t\tbreak;\n\t\tcase ETHTOOL_XDP_XMIT:\n\t\t\t*pstats++ = xdp_stats.xdp_xmit;\n\t\t\tbreak;\n\t\tcase ETHTOOL_XDP_XMIT_ERR:\n\t\t\t*pstats++ = xdp_stats.xdp_xmit_err;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void mvpp2_gather_hw_statistics(struct work_struct *work)\n{\n\tstruct delayed_work *del_work = to_delayed_work(work);\n\tstruct mvpp2_port *port = container_of(del_work, struct mvpp2_port,\n\t\t\t\t\t       stats_work);\n\n\tmutex_lock(&port->gather_stats_lock);\n\n\tmvpp2_read_stats(port);\n\n\t/* No need to read again the counters right after this function if it\n\t * was called asynchronously by the user (ie. use of ethtool).\n\t */\n\tcancel_delayed_work(&port->stats_work);\n\tqueue_delayed_work(port->priv->stats_queue, &port->stats_work,\n\t\t\t   MVPP2_MIB_COUNTERS_STATS_DELAY);\n\n\tmutex_unlock(&port->gather_stats_lock);\n}\n\nstatic void mvpp2_ethtool_get_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\t/* Update statistics for the given port, then take the lock to avoid\n\t * concurrent accesses on the ethtool_stats structure during its copy.\n\t */\n\tmvpp2_gather_hw_statistics(&port->stats_work.work);\n\n\tmutex_lock(&port->gather_stats_lock);\n\tmemcpy(data, port->ethtool_stats,\n\t       sizeof(u64) * MVPP2_N_ETHTOOL_STATS(port->ntxqs, port->nrxqs));\n\tmutex_unlock(&port->gather_stats_lock);\n}\n\nstatic int mvpp2_ethtool_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (sset == ETH_SS_STATS)\n\t\treturn MVPP2_N_ETHTOOL_STATS(port->ntxqs, port->nrxqs);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void mvpp2_mac_reset_assert(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->base + MVPP2_GMAC_CTRL_2_REG) |\n\t      MVPP2_GMAC_PORT_RESET_MASK;\n\twritel(val, port->base + MVPP2_GMAC_CTRL_2_REG);\n\n\tif (port->priv->hw_version == MVPP22 && port->gop_id == 0) {\n\t\tval = readl(port->base + MVPP22_XLG_CTRL0_REG) &\n\t\t      ~MVPP22_XLG_CTRL0_MAC_RESET_DIS;\n\t\twritel(val, port->base + MVPP22_XLG_CTRL0_REG);\n\t}\n}\n\nstatic void mvpp22_pcs_reset_assert(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tvoid __iomem *mpcs, *xpcs;\n\tu32 val;\n\n\tif (port->priv->hw_version != MVPP22 || port->gop_id != 0)\n\t\treturn;\n\n\tmpcs = priv->iface_base + MVPP22_MPCS_BASE(port->gop_id);\n\txpcs = priv->iface_base + MVPP22_XPCS_BASE(port->gop_id);\n\n\tval = readl(mpcs + MVPP22_MPCS_CLK_RESET);\n\tval &= ~(MAC_CLK_RESET_MAC | MAC_CLK_RESET_SD_RX | MAC_CLK_RESET_SD_TX);\n\tval |= MVPP22_MPCS_CLK_RESET_DIV_SET;\n\twritel(val, mpcs + MVPP22_MPCS_CLK_RESET);\n\n\tval = readl(xpcs + MVPP22_XPCS_CFG0);\n\twritel(val & ~MVPP22_XPCS_CFG0_RESET_DIS, xpcs + MVPP22_XPCS_CFG0);\n}\n\nstatic void mvpp22_pcs_reset_deassert(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tvoid __iomem *mpcs, *xpcs;\n\tu32 val;\n\n\tif (port->priv->hw_version != MVPP22 || port->gop_id != 0)\n\t\treturn;\n\n\tmpcs = priv->iface_base + MVPP22_MPCS_BASE(port->gop_id);\n\txpcs = priv->iface_base + MVPP22_XPCS_BASE(port->gop_id);\n\n\tswitch (port->phy_interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tval = readl(mpcs + MVPP22_MPCS_CLK_RESET);\n\t\tval |= MAC_CLK_RESET_MAC | MAC_CLK_RESET_SD_RX |\n\t\t       MAC_CLK_RESET_SD_TX;\n\t\tval &= ~MVPP22_MPCS_CLK_RESET_DIV_SET;\n\t\twritel(val, mpcs + MVPP22_MPCS_CLK_RESET);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\t\tval = readl(xpcs + MVPP22_XPCS_CFG0);\n\t\twritel(val | MVPP22_XPCS_CFG0_RESET_DIS, xpcs + MVPP22_XPCS_CFG0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/* Change maximum receive size of the port */\nstatic inline void mvpp2_gmac_max_rx_size_set(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tval = readl(port->base + MVPP2_GMAC_CTRL_0_REG);\n\tval &= ~MVPP2_GMAC_MAX_RX_SIZE_MASK;\n\tval |= (((port->pkt_size - MVPP2_MH_SIZE) / 2) <<\n\t\t    MVPP2_GMAC_MAX_RX_SIZE_OFFS);\n\twritel(val, port->base + MVPP2_GMAC_CTRL_0_REG);\n}\n\n/* Change maximum receive size of the port */\nstatic inline void mvpp2_xlg_max_rx_size_set(struct mvpp2_port *port)\n{\n\tu32 val;\n\n\tval =  readl(port->base + MVPP22_XLG_CTRL1_REG);\n\tval &= ~MVPP22_XLG_CTRL1_FRAMESIZELIMIT_MASK;\n\tval |= ((port->pkt_size - MVPP2_MH_SIZE) / 2) <<\n\t       MVPP22_XLG_CTRL1_FRAMESIZELIMIT_OFFS;\n\twritel(val, port->base + MVPP22_XLG_CTRL1_REG);\n}\n\n/* Set defaults to the MVPP2 port */\nstatic void mvpp2_defaults_set(struct mvpp2_port *port)\n{\n\tint tx_port_num, val, queue, lrxq;\n\n\tif (port->priv->hw_version == MVPP21) {\n\t\t/* Update TX FIFO MIN Threshold */\n\t\tval = readl(port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);\n\t\tval &= ~MVPP2_GMAC_TX_FIFO_MIN_TH_ALL_MASK;\n\t\t/* Min. TX threshold must be less than minimal packet length */\n\t\tval |= MVPP2_GMAC_TX_FIFO_MIN_TH_MASK(64 - 4 - 2);\n\t\twritel(val, port->base + MVPP2_GMAC_PORT_FIFO_CFG_1_REG);\n\t}\n\n\t/* Disable Legacy WRR, Disable EJP, Release from reset */\n\ttx_port_num = mvpp2_egress_port(port);\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_PORT_INDEX_REG,\n\t\t    tx_port_num);\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_CMD_1_REG, 0);\n\n\t/* Set TXQ scheduling to Round-Robin */\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_FIXED_PRIO_REG, 0);\n\n\t/* Close bandwidth for all queues */\n\tfor (queue = 0; queue < MVPP2_MAX_TXQ; queue++)\n\t\tmvpp2_write(port->priv,\n\t\t\t    MVPP2_TXQ_SCHED_TOKEN_CNTR_REG(queue), 0);\n\n\t/* Set refill period to 1 usec, refill tokens\n\t * and bucket size to maximum\n\t */\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_PERIOD_REG,\n\t\t    port->priv->tclk / USEC_PER_SEC);\n\tval = mvpp2_read(port->priv, MVPP2_TXP_SCHED_REFILL_REG);\n\tval &= ~MVPP2_TXP_REFILL_PERIOD_ALL_MASK;\n\tval |= MVPP2_TXP_REFILL_PERIOD_MASK(1);\n\tval |= MVPP2_TXP_REFILL_TOKENS_ALL_MASK;\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_REFILL_REG, val);\n\tval = MVPP2_TXP_TOKEN_SIZE_MAX;\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_TOKEN_SIZE_REG, val);\n\n\t/* Set MaximumLowLatencyPacketSize value to 256 */\n\tmvpp2_write(port->priv, MVPP2_RX_CTRL_REG(port->id),\n\t\t    MVPP2_RX_USE_PSEUDO_FOR_CSUM_MASK |\n\t\t    MVPP2_RX_LOW_LATENCY_PKT_SIZE(256));\n\n\t/* Enable Rx cache snoop */\n\tfor (lrxq = 0; lrxq < port->nrxqs; lrxq++) {\n\t\tqueue = port->rxqs[lrxq]->id;\n\t\tval = mvpp2_read(port->priv, MVPP2_RXQ_CONFIG_REG(queue));\n\t\tval |= MVPP2_SNOOP_PKT_SIZE_MASK |\n\t\t\t   MVPP2_SNOOP_BUF_HDR_MASK;\n\t\tmvpp2_write(port->priv, MVPP2_RXQ_CONFIG_REG(queue), val);\n\t}\n\n\t/* At default, mask all interrupts to all present cpus */\n\tmvpp2_interrupts_disable(port);\n}\n\n/* Enable/disable receiving packets */\nstatic void mvpp2_ingress_enable(struct mvpp2_port *port)\n{\n\tu32 val;\n\tint lrxq, queue;\n\n\tfor (lrxq = 0; lrxq < port->nrxqs; lrxq++) {\n\t\tqueue = port->rxqs[lrxq]->id;\n\t\tval = mvpp2_read(port->priv, MVPP2_RXQ_CONFIG_REG(queue));\n\t\tval &= ~MVPP2_RXQ_DISABLE_MASK;\n\t\tmvpp2_write(port->priv, MVPP2_RXQ_CONFIG_REG(queue), val);\n\t}\n}\n\nstatic void mvpp2_ingress_disable(struct mvpp2_port *port)\n{\n\tu32 val;\n\tint lrxq, queue;\n\n\tfor (lrxq = 0; lrxq < port->nrxqs; lrxq++) {\n\t\tqueue = port->rxqs[lrxq]->id;\n\t\tval = mvpp2_read(port->priv, MVPP2_RXQ_CONFIG_REG(queue));\n\t\tval |= MVPP2_RXQ_DISABLE_MASK;\n\t\tmvpp2_write(port->priv, MVPP2_RXQ_CONFIG_REG(queue), val);\n\t}\n}\n\n/* Enable transmit via physical egress queue\n * - HW starts take descriptors from DRAM\n */\nstatic void mvpp2_egress_enable(struct mvpp2_port *port)\n{\n\tu32 qmap;\n\tint queue;\n\tint tx_port_num = mvpp2_egress_port(port);\n\n\t/* Enable all initialized TXs. */\n\tqmap = 0;\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\tstruct mvpp2_tx_queue *txq = port->txqs[queue];\n\n\t\tif (txq->descs)\n\t\t\tqmap |= (1 << queue);\n\t}\n\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_PORT_INDEX_REG, tx_port_num);\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_Q_CMD_REG, qmap);\n}\n\n/* Disable transmit via physical egress queue\n * - HW doesn't take descriptors from DRAM\n */\nstatic void mvpp2_egress_disable(struct mvpp2_port *port)\n{\n\tu32 reg_data;\n\tint delay;\n\tint tx_port_num = mvpp2_egress_port(port);\n\n\t/* Issue stop command for active channels only */\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_PORT_INDEX_REG, tx_port_num);\n\treg_data = (mvpp2_read(port->priv, MVPP2_TXP_SCHED_Q_CMD_REG)) &\n\t\t    MVPP2_TXP_SCHED_ENQ_MASK;\n\tif (reg_data != 0)\n\t\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_Q_CMD_REG,\n\t\t\t    (reg_data << MVPP2_TXP_SCHED_DISQ_OFFSET));\n\n\t/* Wait for all Tx activity to terminate. */\n\tdelay = 0;\n\tdo {\n\t\tif (delay >= MVPP2_TX_DISABLE_TIMEOUT_MSEC) {\n\t\t\tnetdev_warn(port->dev,\n\t\t\t\t    \"Tx stop timed out, status=0x%08x\\n\",\n\t\t\t\t    reg_data);\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t\tdelay++;\n\n\t\t/* Check port TX Command register that all\n\t\t * Tx queues are stopped\n\t\t */\n\t\treg_data = mvpp2_read(port->priv, MVPP2_TXP_SCHED_Q_CMD_REG);\n\t} while (reg_data & MVPP2_TXP_SCHED_ENQ_MASK);\n}\n\n/* Rx descriptors helper methods */\n\n/* Get number of Rx descriptors occupied by received packets */\nstatic inline int\nmvpp2_rxq_received(struct mvpp2_port *port, int rxq_id)\n{\n\tu32 val = mvpp2_read(port->priv, MVPP2_RXQ_STATUS_REG(rxq_id));\n\n\treturn val & MVPP2_RXQ_OCCUPIED_MASK;\n}\n\n/* Update Rx queue status with the number of occupied and available\n * Rx descriptor slots.\n */\nstatic inline void\nmvpp2_rxq_status_update(struct mvpp2_port *port, int rxq_id,\n\t\t\tint used_count, int free_count)\n{\n\t/* Decrement the number of used descriptors and increment count\n\t * increment the number of free descriptors.\n\t */\n\tu32 val = used_count | (free_count << MVPP2_RXQ_NUM_NEW_OFFSET);\n\n\tmvpp2_write(port->priv, MVPP2_RXQ_STATUS_UPDATE_REG(rxq_id), val);\n}\n\n/* Get pointer to next RX descriptor to be processed by SW */\nstatic inline struct mvpp2_rx_desc *\nmvpp2_rxq_next_desc_get(struct mvpp2_rx_queue *rxq)\n{\n\tint rx_desc = rxq->next_desc_to_proc;\n\n\trxq->next_desc_to_proc = MVPP2_QUEUE_NEXT_DESC(rxq, rx_desc);\n\tprefetch(rxq->descs + rxq->next_desc_to_proc);\n\treturn rxq->descs + rx_desc;\n}\n\n/* Set rx queue offset */\nstatic void mvpp2_rxq_offset_set(struct mvpp2_port *port,\n\t\t\t\t int prxq, int offset)\n{\n\tu32 val;\n\n\t/* Convert offset from bytes to units of 32 bytes */\n\toffset = offset >> 5;\n\n\tval = mvpp2_read(port->priv, MVPP2_RXQ_CONFIG_REG(prxq));\n\tval &= ~MVPP2_RXQ_PACKET_OFFSET_MASK;\n\n\t/* Offset is in */\n\tval |= ((offset << MVPP2_RXQ_PACKET_OFFSET_OFFS) &\n\t\t    MVPP2_RXQ_PACKET_OFFSET_MASK);\n\n\tmvpp2_write(port->priv, MVPP2_RXQ_CONFIG_REG(prxq), val);\n}\n\n/* Tx descriptors helper methods */\n\n/* Get pointer to next Tx descriptor to be processed (send) by HW */\nstatic struct mvpp2_tx_desc *\nmvpp2_txq_next_desc_get(struct mvpp2_tx_queue *txq)\n{\n\tint tx_desc = txq->next_desc_to_proc;\n\n\ttxq->next_desc_to_proc = MVPP2_QUEUE_NEXT_DESC(txq, tx_desc);\n\treturn txq->descs + tx_desc;\n}\n\n/* Update HW with number of aggregated Tx descriptors to be sent\n *\n * Called only from mvpp2_tx(), so migration is disabled, using\n * smp_processor_id() is OK.\n */\nstatic void mvpp2_aggr_txq_pend_desc_add(struct mvpp2_port *port, int pending)\n{\n\t/* aggregated access - relevant TXQ number is written in TX desc */\n\tmvpp2_thread_write(port->priv,\n\t\t\t   mvpp2_cpu_to_thread(port->priv, smp_processor_id()),\n\t\t\t   MVPP2_AGGR_TXQ_UPDATE_REG, pending);\n}\n\n/* Check if there are enough free descriptors in aggregated txq.\n * If not, update the number of occupied descriptors and repeat the check.\n *\n * Called only from mvpp2_tx(), so migration is disabled, using\n * smp_processor_id() is OK.\n */\nstatic int mvpp2_aggr_desc_num_check(struct mvpp2_port *port,\n\t\t\t\t     struct mvpp2_tx_queue *aggr_txq, int num)\n{\n\tif ((aggr_txq->count + num) > MVPP2_AGGR_TXQ_SIZE) {\n\t\t/* Update number of occupied aggregated Tx descriptors */\n\t\tunsigned int thread =\n\t\t\tmvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\t\tu32 val = mvpp2_read_relaxed(port->priv,\n\t\t\t\t\t     MVPP2_AGGR_TXQ_STATUS_REG(thread));\n\n\t\taggr_txq->count = val & MVPP2_AGGR_TXQ_PENDING_MASK;\n\n\t\tif ((aggr_txq->count + num) > MVPP2_AGGR_TXQ_SIZE)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n/* Reserved Tx descriptors allocation request\n *\n * Called only from mvpp2_txq_reserved_desc_num_proc(), itself called\n * only by mvpp2_tx(), so migration is disabled, using\n * smp_processor_id() is OK.\n */\nstatic int mvpp2_txq_alloc_reserved_desc(struct mvpp2_port *port,\n\t\t\t\t\t struct mvpp2_tx_queue *txq, int num)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\tstruct mvpp2 *priv = port->priv;\n\tu32 val;\n\n\tval = (txq->id << MVPP2_TXQ_RSVD_REQ_Q_OFFSET) | num;\n\tmvpp2_thread_write_relaxed(priv, thread, MVPP2_TXQ_RSVD_REQ_REG, val);\n\n\tval = mvpp2_thread_read_relaxed(priv, thread, MVPP2_TXQ_RSVD_RSLT_REG);\n\n\treturn val & MVPP2_TXQ_RSVD_RSLT_MASK;\n}\n\n/* Check if there are enough reserved descriptors for transmission.\n * If not, request chunk of reserved descriptors and check again.\n */\nstatic int mvpp2_txq_reserved_desc_num_proc(struct mvpp2_port *port,\n\t\t\t\t\t    struct mvpp2_tx_queue *txq,\n\t\t\t\t\t    struct mvpp2_txq_pcpu *txq_pcpu,\n\t\t\t\t\t    int num)\n{\n\tint req, desc_count;\n\tunsigned int thread;\n\n\tif (txq_pcpu->reserved_num >= num)\n\t\treturn 0;\n\n\t/* Not enough descriptors reserved! Update the reserved descriptor\n\t * count and check again.\n\t */\n\n\tdesc_count = 0;\n\t/* Compute total of used descriptors */\n\tfor (thread = 0; thread < port->priv->nthreads; thread++) {\n\t\tstruct mvpp2_txq_pcpu *txq_pcpu_aux;\n\n\t\ttxq_pcpu_aux = per_cpu_ptr(txq->pcpu, thread);\n\t\tdesc_count += txq_pcpu_aux->count;\n\t\tdesc_count += txq_pcpu_aux->reserved_num;\n\t}\n\n\treq = max(MVPP2_CPU_DESC_CHUNK, num - txq_pcpu->reserved_num);\n\tdesc_count += req;\n\n\tif (desc_count >\n\t   (txq->size - (MVPP2_MAX_THREADS * MVPP2_CPU_DESC_CHUNK)))\n\t\treturn -ENOMEM;\n\n\ttxq_pcpu->reserved_num += mvpp2_txq_alloc_reserved_desc(port, txq, req);\n\n\t/* OK, the descriptor could have been updated: check again. */\n\tif (txq_pcpu->reserved_num < num)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n/* Release the last allocated Tx descriptor. Useful to handle DMA\n * mapping failures in the Tx path.\n */\nstatic void mvpp2_txq_desc_put(struct mvpp2_tx_queue *txq)\n{\n\tif (txq->next_desc_to_proc == 0)\n\t\ttxq->next_desc_to_proc = txq->last_desc - 1;\n\telse\n\t\ttxq->next_desc_to_proc--;\n}\n\n/* Set Tx descriptors fields relevant for CSUM calculation */\nstatic u32 mvpp2_txq_desc_csum(int l3_offs, __be16 l3_proto,\n\t\t\t       int ip_hdr_len, int l4_proto)\n{\n\tu32 command;\n\n\t/* fields: L3_offset, IP_hdrlen, L3_type, G_IPv4_chk,\n\t * G_L4_chk, L4_type required only for checksum calculation\n\t */\n\tcommand = (l3_offs << MVPP2_TXD_L3_OFF_SHIFT);\n\tcommand |= (ip_hdr_len << MVPP2_TXD_IP_HLEN_SHIFT);\n\tcommand |= MVPP2_TXD_IP_CSUM_DISABLE;\n\n\tif (l3_proto == htons(ETH_P_IP)) {\n\t\tcommand &= ~MVPP2_TXD_IP_CSUM_DISABLE;\t/* enable IPv4 csum */\n\t\tcommand &= ~MVPP2_TXD_L3_IP6;\t\t/* enable IPv4 */\n\t} else {\n\t\tcommand |= MVPP2_TXD_L3_IP6;\t\t/* enable IPv6 */\n\t}\n\n\tif (l4_proto == IPPROTO_TCP) {\n\t\tcommand &= ~MVPP2_TXD_L4_UDP;\t\t/* enable TCP */\n\t\tcommand &= ~MVPP2_TXD_L4_CSUM_FRAG;\t/* generate L4 csum */\n\t} else if (l4_proto == IPPROTO_UDP) {\n\t\tcommand |= MVPP2_TXD_L4_UDP;\t\t/* enable UDP */\n\t\tcommand &= ~MVPP2_TXD_L4_CSUM_FRAG;\t/* generate L4 csum */\n\t} else {\n\t\tcommand |= MVPP2_TXD_L4_CSUM_NOT;\n\t}\n\n\treturn command;\n}\n\n/* Get number of sent descriptors and decrement counter.\n * The number of sent descriptors is returned.\n * Per-thread access\n *\n * Called only from mvpp2_txq_done(), called from mvpp2_tx()\n * (migration disabled) and from the TX completion tasklet (migration\n * disabled) so using smp_processor_id() is OK.\n */\nstatic inline int mvpp2_txq_sent_desc_proc(struct mvpp2_port *port,\n\t\t\t\t\t   struct mvpp2_tx_queue *txq)\n{\n\tu32 val;\n\n\t/* Reading status reg resets transmitted descriptor counter */\n\tval = mvpp2_thread_read_relaxed(port->priv,\n\t\t\t\t\tmvpp2_cpu_to_thread(port->priv, smp_processor_id()),\n\t\t\t\t\tMVPP2_TXQ_SENT_REG(txq->id));\n\n\treturn (val & MVPP2_TRANSMITTED_COUNT_MASK) >>\n\t\tMVPP2_TRANSMITTED_COUNT_OFFSET;\n}\n\n/* Called through on_each_cpu(), so runs on all CPUs, with migration\n * disabled, therefore using smp_processor_id() is OK.\n */\nstatic void mvpp2_txq_sent_counter_clear(void *arg)\n{\n\tstruct mvpp2_port *port = arg;\n\tint queue;\n\n\t/* If the thread isn't used, don't do anything */\n\tif (smp_processor_id() > port->priv->nthreads)\n\t\treturn;\n\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\tint id = port->txqs[queue]->id;\n\n\t\tmvpp2_thread_read(port->priv,\n\t\t\t\t  mvpp2_cpu_to_thread(port->priv, smp_processor_id()),\n\t\t\t\t  MVPP2_TXQ_SENT_REG(id));\n\t}\n}\n\n/* Set max sizes for Tx queues */\nstatic void mvpp2_txp_max_tx_size_set(struct mvpp2_port *port)\n{\n\tu32\tval, size, mtu;\n\tint\ttxq, tx_port_num;\n\n\tmtu = port->pkt_size * 8;\n\tif (mtu > MVPP2_TXP_MTU_MAX)\n\t\tmtu = MVPP2_TXP_MTU_MAX;\n\n\t/* WA for wrong Token bucket update: Set MTU value = 3*real MTU value */\n\tmtu = 3 * mtu;\n\n\t/* Indirect access to registers */\n\ttx_port_num = mvpp2_egress_port(port);\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_PORT_INDEX_REG, tx_port_num);\n\n\t/* Set MTU */\n\tval = mvpp2_read(port->priv, MVPP2_TXP_SCHED_MTU_REG);\n\tval &= ~MVPP2_TXP_MTU_MAX;\n\tval |= mtu;\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_MTU_REG, val);\n\n\t/* TXP token size and all TXQs token size must be larger that MTU */\n\tval = mvpp2_read(port->priv, MVPP2_TXP_SCHED_TOKEN_SIZE_REG);\n\tsize = val & MVPP2_TXP_TOKEN_SIZE_MAX;\n\tif (size < mtu) {\n\t\tsize = mtu;\n\t\tval &= ~MVPP2_TXP_TOKEN_SIZE_MAX;\n\t\tval |= size;\n\t\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_TOKEN_SIZE_REG, val);\n\t}\n\n\tfor (txq = 0; txq < port->ntxqs; txq++) {\n\t\tval = mvpp2_read(port->priv,\n\t\t\t\t MVPP2_TXQ_SCHED_TOKEN_SIZE_REG(txq));\n\t\tsize = val & MVPP2_TXQ_TOKEN_SIZE_MAX;\n\n\t\tif (size < mtu) {\n\t\t\tsize = mtu;\n\t\t\tval &= ~MVPP2_TXQ_TOKEN_SIZE_MAX;\n\t\t\tval |= size;\n\t\t\tmvpp2_write(port->priv,\n\t\t\t\t    MVPP2_TXQ_SCHED_TOKEN_SIZE_REG(txq),\n\t\t\t\t    val);\n\t\t}\n\t}\n}\n\n/* Set the number of packets that will be received before Rx interrupt\n * will be generated by HW.\n */\nstatic void mvpp2_rx_pkts_coal_set(struct mvpp2_port *port,\n\t\t\t\t   struct mvpp2_rx_queue *rxq)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\n\tif (rxq->pkts_coal > MVPP2_OCCUPIED_THRESH_MASK)\n\t\trxq->pkts_coal = MVPP2_OCCUPIED_THRESH_MASK;\n\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_NUM_REG, rxq->id);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_THRESH_REG,\n\t\t\t   rxq->pkts_coal);\n\n\tput_cpu();\n}\n\n/* For some reason in the LSP this is done on each CPU. Why ? */\nstatic void mvpp2_tx_pkts_coal_set(struct mvpp2_port *port,\n\t\t\t\t   struct mvpp2_tx_queue *txq)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tu32 val;\n\n\tif (txq->done_pkts_coal > MVPP2_TXQ_THRESH_MASK)\n\t\ttxq->done_pkts_coal = MVPP2_TXQ_THRESH_MASK;\n\n\tval = (txq->done_pkts_coal << MVPP2_TXQ_THRESH_OFFSET);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_NUM_REG, txq->id);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_THRESH_REG, val);\n\n\tput_cpu();\n}\n\nstatic u32 mvpp2_usec_to_cycles(u32 usec, unsigned long clk_hz)\n{\n\tu64 tmp = (u64)clk_hz * usec;\n\n\tdo_div(tmp, USEC_PER_SEC);\n\n\treturn tmp > U32_MAX ? U32_MAX : tmp;\n}\n\nstatic u32 mvpp2_cycles_to_usec(u32 cycles, unsigned long clk_hz)\n{\n\tu64 tmp = (u64)cycles * USEC_PER_SEC;\n\n\tdo_div(tmp, clk_hz);\n\n\treturn tmp > U32_MAX ? U32_MAX : tmp;\n}\n\n/* Set the time delay in usec before Rx interrupt */\nstatic void mvpp2_rx_time_coal_set(struct mvpp2_port *port,\n\t\t\t\t   struct mvpp2_rx_queue *rxq)\n{\n\tunsigned long freq = port->priv->tclk;\n\tu32 val = mvpp2_usec_to_cycles(rxq->time_coal, freq);\n\n\tif (val > MVPP2_MAX_ISR_RX_THRESHOLD) {\n\t\trxq->time_coal =\n\t\t\tmvpp2_cycles_to_usec(MVPP2_MAX_ISR_RX_THRESHOLD, freq);\n\n\t\t/* re-evaluate to get actual register value */\n\t\tval = mvpp2_usec_to_cycles(rxq->time_coal, freq);\n\t}\n\n\tmvpp2_write(port->priv, MVPP2_ISR_RX_THRESHOLD_REG(rxq->id), val);\n}\n\nstatic void mvpp2_tx_time_coal_set(struct mvpp2_port *port)\n{\n\tunsigned long freq = port->priv->tclk;\n\tu32 val = mvpp2_usec_to_cycles(port->tx_time_coal, freq);\n\n\tif (val > MVPP2_MAX_ISR_TX_THRESHOLD) {\n\t\tport->tx_time_coal =\n\t\t\tmvpp2_cycles_to_usec(MVPP2_MAX_ISR_TX_THRESHOLD, freq);\n\n\t\t/* re-evaluate to get actual register value */\n\t\tval = mvpp2_usec_to_cycles(port->tx_time_coal, freq);\n\t}\n\n\tmvpp2_write(port->priv, MVPP2_ISR_TX_THRESHOLD_REG(port->id), val);\n}\n\n/* Free Tx queue skbuffs */\nstatic void mvpp2_txq_bufs_free(struct mvpp2_port *port,\n\t\t\t\tstruct mvpp2_tx_queue *txq,\n\t\t\t\tstruct mvpp2_txq_pcpu *txq_pcpu, int num)\n{\n\tstruct xdp_frame_bulk bq;\n\tint i;\n\n\txdp_frame_bulk_init(&bq);\n\n\trcu_read_lock(); /* need for xdp_return_frame_bulk */\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct mvpp2_txq_pcpu_buf *tx_buf =\n\t\t\ttxq_pcpu->buffs + txq_pcpu->txq_get_index;\n\n\t\tif (!IS_TSO_HEADER(txq_pcpu, tx_buf->dma) &&\n\t\t    tx_buf->type != MVPP2_TYPE_XDP_TX)\n\t\t\tdma_unmap_single(port->dev->dev.parent, tx_buf->dma,\n\t\t\t\t\t tx_buf->size, DMA_TO_DEVICE);\n\t\tif (tx_buf->type == MVPP2_TYPE_SKB && tx_buf->skb)\n\t\t\tdev_kfree_skb_any(tx_buf->skb);\n\t\telse if (tx_buf->type == MVPP2_TYPE_XDP_TX ||\n\t\t\t tx_buf->type == MVPP2_TYPE_XDP_NDO)\n\t\t\txdp_return_frame_bulk(tx_buf->xdpf, &bq);\n\n\t\tmvpp2_txq_inc_get(txq_pcpu);\n\t}\n\txdp_flush_frame_bulk(&bq);\n\n\trcu_read_unlock();\n}\n\nstatic inline struct mvpp2_rx_queue *mvpp2_get_rx_queue(struct mvpp2_port *port,\n\t\t\t\t\t\t\tu32 cause)\n{\n\tint queue = fls(cause) - 1;\n\n\treturn port->rxqs[queue];\n}\n\nstatic inline struct mvpp2_tx_queue *mvpp2_get_tx_queue(struct mvpp2_port *port,\n\t\t\t\t\t\t\tu32 cause)\n{\n\tint queue = fls(cause) - 1;\n\n\treturn port->txqs[queue];\n}\n\n/* Handle end of transmission */\nstatic void mvpp2_txq_done(struct mvpp2_port *port, struct mvpp2_tx_queue *txq,\n\t\t\t   struct mvpp2_txq_pcpu *txq_pcpu)\n{\n\tstruct netdev_queue *nq = netdev_get_tx_queue(port->dev, txq->log_id);\n\tint tx_done;\n\n\tif (txq_pcpu->thread != mvpp2_cpu_to_thread(port->priv, smp_processor_id()))\n\t\tnetdev_err(port->dev, \"wrong cpu on the end of Tx processing\\n\");\n\n\ttx_done = mvpp2_txq_sent_desc_proc(port, txq);\n\tif (!tx_done)\n\t\treturn;\n\tmvpp2_txq_bufs_free(port, txq, txq_pcpu, tx_done);\n\n\ttxq_pcpu->count -= tx_done;\n\n\tif (netif_tx_queue_stopped(nq))\n\t\tif (txq_pcpu->count <= txq_pcpu->wake_threshold)\n\t\t\tnetif_tx_wake_queue(nq);\n}\n\nstatic unsigned int mvpp2_tx_done(struct mvpp2_port *port, u32 cause,\n\t\t\t\t  unsigned int thread)\n{\n\tstruct mvpp2_tx_queue *txq;\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tunsigned int tx_todo = 0;\n\n\twhile (cause) {\n\t\ttxq = mvpp2_get_tx_queue(port, cause);\n\t\tif (!txq)\n\t\t\tbreak;\n\n\t\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\n\t\tif (txq_pcpu->count) {\n\t\t\tmvpp2_txq_done(port, txq, txq_pcpu);\n\t\t\ttx_todo += txq_pcpu->count;\n\t\t}\n\n\t\tcause &= ~(1 << txq->log_id);\n\t}\n\treturn tx_todo;\n}\n\n/* Rx/Tx queue initialization/cleanup methods */\n\n/* Allocate and initialize descriptors for aggr TXQ */\nstatic int mvpp2_aggr_txq_init(struct platform_device *pdev,\n\t\t\t       struct mvpp2_tx_queue *aggr_txq,\n\t\t\t       unsigned int thread, struct mvpp2 *priv)\n{\n\tu32 txq_dma;\n\n\t/* Allocate memory for TX descriptors */\n\taggr_txq->descs = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t     MVPP2_AGGR_TXQ_SIZE * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t\t\t     &aggr_txq->descs_dma, GFP_KERNEL);\n\tif (!aggr_txq->descs)\n\t\treturn -ENOMEM;\n\n\taggr_txq->last_desc = MVPP2_AGGR_TXQ_SIZE - 1;\n\n\t/* Aggr TXQ no reset WA */\n\taggr_txq->next_desc_to_proc = mvpp2_read(priv,\n\t\t\t\t\t\t MVPP2_AGGR_TXQ_INDEX_REG(thread));\n\n\t/* Set Tx descriptors queue starting address indirect\n\t * access\n\t */\n\tif (priv->hw_version == MVPP21)\n\t\ttxq_dma = aggr_txq->descs_dma;\n\telse\n\t\ttxq_dma = aggr_txq->descs_dma >>\n\t\t\tMVPP22_AGGR_TXQ_DESC_ADDR_OFFS;\n\n\tmvpp2_write(priv, MVPP2_AGGR_TXQ_DESC_ADDR_REG(thread), txq_dma);\n\tmvpp2_write(priv, MVPP2_AGGR_TXQ_DESC_SIZE_REG(thread),\n\t\t    MVPP2_AGGR_TXQ_SIZE);\n\n\treturn 0;\n}\n\n/* Create a specified Rx queue */\nstatic int mvpp2_rxq_init(struct mvpp2_port *port,\n\t\t\t  struct mvpp2_rx_queue *rxq)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tunsigned int thread;\n\tu32 rxq_dma;\n\tint err;\n\n\trxq->size = port->rx_ring_size;\n\n\t/* Allocate memory for RX descriptors */\n\trxq->descs = dma_alloc_coherent(port->dev->dev.parent,\n\t\t\t\t\trxq->size * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t\t\t&rxq->descs_dma, GFP_KERNEL);\n\tif (!rxq->descs)\n\t\treturn -ENOMEM;\n\n\trxq->last_desc = rxq->size - 1;\n\n\t/* Zero occupied and non-occupied counters - direct access */\n\tmvpp2_write(port->priv, MVPP2_RXQ_STATUS_REG(rxq->id), 0);\n\n\t/* Set Rx descriptors queue starting address - indirect access */\n\tthread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_NUM_REG, rxq->id);\n\tif (port->priv->hw_version == MVPP21)\n\t\trxq_dma = rxq->descs_dma;\n\telse\n\t\trxq_dma = rxq->descs_dma >> MVPP22_DESC_ADDR_OFFS;\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_DESC_ADDR_REG, rxq_dma);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_DESC_SIZE_REG, rxq->size);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_INDEX_REG, 0);\n\tput_cpu();\n\n\t/* Set Offset */\n\tmvpp2_rxq_offset_set(port, rxq->id, MVPP2_SKB_HEADROOM);\n\n\t/* Set coalescing pkts and time */\n\tmvpp2_rx_pkts_coal_set(port, rxq);\n\tmvpp2_rx_time_coal_set(port, rxq);\n\n\t/* Add number of descriptors ready for receiving packets */\n\tmvpp2_rxq_status_update(port, rxq->id, 0, rxq->size);\n\n\tif (priv->percpu_pools) {\n\t\terr = xdp_rxq_info_reg(&rxq->xdp_rxq_short, port->dev, rxq->id, 0);\n\t\tif (err < 0)\n\t\t\tgoto err_free_dma;\n\n\t\terr = xdp_rxq_info_reg(&rxq->xdp_rxq_long, port->dev, rxq->id, 0);\n\t\tif (err < 0)\n\t\t\tgoto err_unregister_rxq_short;\n\n\t\t/* Every RXQ has a pool for short and another for long packets */\n\t\terr = xdp_rxq_info_reg_mem_model(&rxq->xdp_rxq_short,\n\t\t\t\t\t\t MEM_TYPE_PAGE_POOL,\n\t\t\t\t\t\t priv->page_pool[rxq->logic_rxq]);\n\t\tif (err < 0)\n\t\t\tgoto err_unregister_rxq_long;\n\n\t\terr = xdp_rxq_info_reg_mem_model(&rxq->xdp_rxq_long,\n\t\t\t\t\t\t MEM_TYPE_PAGE_POOL,\n\t\t\t\t\t\t priv->page_pool[rxq->logic_rxq +\n\t\t\t\t\t\t\t\t port->nrxqs]);\n\t\tif (err < 0)\n\t\t\tgoto err_unregister_mem_rxq_short;\n\t}\n\n\treturn 0;\n\nerr_unregister_mem_rxq_short:\n\txdp_rxq_info_unreg_mem_model(&rxq->xdp_rxq_short);\nerr_unregister_rxq_long:\n\txdp_rxq_info_unreg(&rxq->xdp_rxq_long);\nerr_unregister_rxq_short:\n\txdp_rxq_info_unreg(&rxq->xdp_rxq_short);\nerr_free_dma:\n\tdma_free_coherent(port->dev->dev.parent,\n\t\t\t  rxq->size * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t  rxq->descs, rxq->descs_dma);\n\treturn err;\n}\n\n/* Push packets received by the RXQ to BM pool */\nstatic void mvpp2_rxq_drop_pkts(struct mvpp2_port *port,\n\t\t\t\tstruct mvpp2_rx_queue *rxq)\n{\n\tint rx_received, i;\n\n\trx_received = mvpp2_rxq_received(port, rxq->id);\n\tif (!rx_received)\n\t\treturn;\n\n\tfor (i = 0; i < rx_received; i++) {\n\t\tstruct mvpp2_rx_desc *rx_desc = mvpp2_rxq_next_desc_get(rxq);\n\t\tu32 status = mvpp2_rxdesc_status_get(port, rx_desc);\n\t\tint pool;\n\n\t\tpool = (status & MVPP2_RXD_BM_POOL_ID_MASK) >>\n\t\t\tMVPP2_RXD_BM_POOL_ID_OFFS;\n\n\t\tmvpp2_bm_pool_put(port, pool,\n\t\t\t\t  mvpp2_rxdesc_dma_addr_get(port, rx_desc),\n\t\t\t\t  mvpp2_rxdesc_cookie_get(port, rx_desc));\n\t}\n\tmvpp2_rxq_status_update(port, rxq->id, rx_received, rx_received);\n}\n\n/* Cleanup Rx queue */\nstatic void mvpp2_rxq_deinit(struct mvpp2_port *port,\n\t\t\t     struct mvpp2_rx_queue *rxq)\n{\n\tunsigned int thread;\n\n\tif (xdp_rxq_info_is_reg(&rxq->xdp_rxq_short))\n\t\txdp_rxq_info_unreg(&rxq->xdp_rxq_short);\n\n\tif (xdp_rxq_info_is_reg(&rxq->xdp_rxq_long))\n\t\txdp_rxq_info_unreg(&rxq->xdp_rxq_long);\n\n\tmvpp2_rxq_drop_pkts(port, rxq);\n\n\tif (rxq->descs)\n\t\tdma_free_coherent(port->dev->dev.parent,\n\t\t\t\t  rxq->size * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t\t  rxq->descs,\n\t\t\t\t  rxq->descs_dma);\n\n\trxq->descs             = NULL;\n\trxq->last_desc         = 0;\n\trxq->next_desc_to_proc = 0;\n\trxq->descs_dma         = 0;\n\n\t/* Clear Rx descriptors queue starting address and size;\n\t * free descriptor number\n\t */\n\tmvpp2_write(port->priv, MVPP2_RXQ_STATUS_REG(rxq->id), 0);\n\tthread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_NUM_REG, rxq->id);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_DESC_ADDR_REG, 0);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_RXQ_DESC_SIZE_REG, 0);\n\tput_cpu();\n}\n\n/* Create and initialize a Tx queue */\nstatic int mvpp2_txq_init(struct mvpp2_port *port,\n\t\t\t  struct mvpp2_tx_queue *txq)\n{\n\tu32 val;\n\tunsigned int thread;\n\tint desc, desc_per_txq, tx_port_num;\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\n\ttxq->size = port->tx_ring_size;\n\n\t/* Allocate memory for Tx descriptors */\n\ttxq->descs = dma_alloc_coherent(port->dev->dev.parent,\n\t\t\t\ttxq->size * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t\t&txq->descs_dma, GFP_KERNEL);\n\tif (!txq->descs)\n\t\treturn -ENOMEM;\n\n\ttxq->last_desc = txq->size - 1;\n\n\t/* Set Tx descriptors queue starting address - indirect access */\n\tthread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_NUM_REG, txq->id);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_DESC_ADDR_REG,\n\t\t\t   txq->descs_dma);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_DESC_SIZE_REG,\n\t\t\t   txq->size & MVPP2_TXQ_DESC_SIZE_MASK);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_INDEX_REG, 0);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_RSVD_CLR_REG,\n\t\t\t   txq->id << MVPP2_TXQ_RSVD_CLR_OFFSET);\n\tval = mvpp2_thread_read(port->priv, thread, MVPP2_TXQ_PENDING_REG);\n\tval &= ~MVPP2_TXQ_PENDING_MASK;\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_PENDING_REG, val);\n\n\t/* Calculate base address in prefetch buffer. We reserve 16 descriptors\n\t * for each existing TXQ.\n\t * TCONTS for PON port must be continuous from 0 to MVPP2_MAX_TCONT\n\t * GBE ports assumed to be continuous from 0 to MVPP2_MAX_PORTS\n\t */\n\tdesc_per_txq = 16;\n\tdesc = (port->id * MVPP2_MAX_TXQ * desc_per_txq) +\n\t       (txq->log_id * desc_per_txq);\n\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_PREF_BUF_REG,\n\t\t\t   MVPP2_PREF_BUF_PTR(desc) | MVPP2_PREF_BUF_SIZE_16 |\n\t\t\t   MVPP2_PREF_BUF_THRESH(desc_per_txq / 2));\n\tput_cpu();\n\n\t/* WRR / EJP configuration - indirect access */\n\ttx_port_num = mvpp2_egress_port(port);\n\tmvpp2_write(port->priv, MVPP2_TXP_SCHED_PORT_INDEX_REG, tx_port_num);\n\n\tval = mvpp2_read(port->priv, MVPP2_TXQ_SCHED_REFILL_REG(txq->log_id));\n\tval &= ~MVPP2_TXQ_REFILL_PERIOD_ALL_MASK;\n\tval |= MVPP2_TXQ_REFILL_PERIOD_MASK(1);\n\tval |= MVPP2_TXQ_REFILL_TOKENS_ALL_MASK;\n\tmvpp2_write(port->priv, MVPP2_TXQ_SCHED_REFILL_REG(txq->log_id), val);\n\n\tval = MVPP2_TXQ_TOKEN_SIZE_MAX;\n\tmvpp2_write(port->priv, MVPP2_TXQ_SCHED_TOKEN_SIZE_REG(txq->log_id),\n\t\t    val);\n\n\tfor (thread = 0; thread < port->priv->nthreads; thread++) {\n\t\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\t\ttxq_pcpu->size = txq->size;\n\t\ttxq_pcpu->buffs = kmalloc_array(txq_pcpu->size,\n\t\t\t\t\t\tsizeof(*txq_pcpu->buffs),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!txq_pcpu->buffs)\n\t\t\treturn -ENOMEM;\n\n\t\ttxq_pcpu->count = 0;\n\t\ttxq_pcpu->reserved_num = 0;\n\t\ttxq_pcpu->txq_put_index = 0;\n\t\ttxq_pcpu->txq_get_index = 0;\n\t\ttxq_pcpu->tso_headers = NULL;\n\n\t\ttxq_pcpu->stop_threshold = txq->size - MVPP2_MAX_SKB_DESCS;\n\t\ttxq_pcpu->wake_threshold = txq_pcpu->stop_threshold / 2;\n\n\t\ttxq_pcpu->tso_headers =\n\t\t\tdma_alloc_coherent(port->dev->dev.parent,\n\t\t\t\t\t   txq_pcpu->size * TSO_HEADER_SIZE,\n\t\t\t\t\t   &txq_pcpu->tso_headers_dma,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!txq_pcpu->tso_headers)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/* Free allocated TXQ resources */\nstatic void mvpp2_txq_deinit(struct mvpp2_port *port,\n\t\t\t     struct mvpp2_tx_queue *txq)\n{\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tunsigned int thread;\n\n\tfor (thread = 0; thread < port->priv->nthreads; thread++) {\n\t\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\t\tkfree(txq_pcpu->buffs);\n\n\t\tif (txq_pcpu->tso_headers)\n\t\t\tdma_free_coherent(port->dev->dev.parent,\n\t\t\t\t\t  txq_pcpu->size * TSO_HEADER_SIZE,\n\t\t\t\t\t  txq_pcpu->tso_headers,\n\t\t\t\t\t  txq_pcpu->tso_headers_dma);\n\n\t\ttxq_pcpu->tso_headers = NULL;\n\t}\n\n\tif (txq->descs)\n\t\tdma_free_coherent(port->dev->dev.parent,\n\t\t\t\t  txq->size * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t\t  txq->descs, txq->descs_dma);\n\n\ttxq->descs             = NULL;\n\ttxq->last_desc         = 0;\n\ttxq->next_desc_to_proc = 0;\n\ttxq->descs_dma         = 0;\n\n\t/* Set minimum bandwidth for disabled TXQs */\n\tmvpp2_write(port->priv, MVPP2_TXQ_SCHED_TOKEN_CNTR_REG(txq->log_id), 0);\n\n\t/* Set Tx descriptors queue starting address and size */\n\tthread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_NUM_REG, txq->id);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_DESC_ADDR_REG, 0);\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_DESC_SIZE_REG, 0);\n\tput_cpu();\n}\n\n/* Cleanup Tx ports */\nstatic void mvpp2_txq_clean(struct mvpp2_port *port, struct mvpp2_tx_queue *txq)\n{\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tint delay, pending;\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, get_cpu());\n\tu32 val;\n\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_NUM_REG, txq->id);\n\tval = mvpp2_thread_read(port->priv, thread, MVPP2_TXQ_PREF_BUF_REG);\n\tval |= MVPP2_TXQ_DRAIN_EN_MASK;\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_PREF_BUF_REG, val);\n\n\t/* The napi queue has been stopped so wait for all packets\n\t * to be transmitted.\n\t */\n\tdelay = 0;\n\tdo {\n\t\tif (delay >= MVPP2_TX_PENDING_TIMEOUT_MSEC) {\n\t\t\tnetdev_warn(port->dev,\n\t\t\t\t    \"port %d: cleaning queue %d timed out\\n\",\n\t\t\t\t    port->id, txq->log_id);\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t\tdelay++;\n\n\t\tpending = mvpp2_thread_read(port->priv, thread,\n\t\t\t\t\t    MVPP2_TXQ_PENDING_REG);\n\t\tpending &= MVPP2_TXQ_PENDING_MASK;\n\t} while (pending);\n\n\tval &= ~MVPP2_TXQ_DRAIN_EN_MASK;\n\tmvpp2_thread_write(port->priv, thread, MVPP2_TXQ_PREF_BUF_REG, val);\n\tput_cpu();\n\n\tfor (thread = 0; thread < port->priv->nthreads; thread++) {\n\t\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\n\t\t/* Release all packets */\n\t\tmvpp2_txq_bufs_free(port, txq, txq_pcpu, txq_pcpu->count);\n\n\t\t/* Reset queue */\n\t\ttxq_pcpu->count = 0;\n\t\ttxq_pcpu->txq_put_index = 0;\n\t\ttxq_pcpu->txq_get_index = 0;\n\t}\n}\n\n/* Cleanup all Tx queues */\nstatic void mvpp2_cleanup_txqs(struct mvpp2_port *port)\n{\n\tstruct mvpp2_tx_queue *txq;\n\tint queue;\n\tu32 val;\n\n\tval = mvpp2_read(port->priv, MVPP2_TX_PORT_FLUSH_REG);\n\n\t/* Reset Tx ports and delete Tx queues */\n\tval |= MVPP2_TX_PORT_FLUSH_MASK(port->id);\n\tmvpp2_write(port->priv, MVPP2_TX_PORT_FLUSH_REG, val);\n\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\ttxq = port->txqs[queue];\n\t\tmvpp2_txq_clean(port, txq);\n\t\tmvpp2_txq_deinit(port, txq);\n\t}\n\n\ton_each_cpu(mvpp2_txq_sent_counter_clear, port, 1);\n\n\tval &= ~MVPP2_TX_PORT_FLUSH_MASK(port->id);\n\tmvpp2_write(port->priv, MVPP2_TX_PORT_FLUSH_REG, val);\n}\n\n/* Cleanup all Rx queues */\nstatic void mvpp2_cleanup_rxqs(struct mvpp2_port *port)\n{\n\tint queue;\n\n\tfor (queue = 0; queue < port->nrxqs; queue++)\n\t\tmvpp2_rxq_deinit(port, port->rxqs[queue]);\n}\n\n/* Init all Rx queues for port */\nstatic int mvpp2_setup_rxqs(struct mvpp2_port *port)\n{\n\tint queue, err;\n\n\tfor (queue = 0; queue < port->nrxqs; queue++) {\n\t\terr = mvpp2_rxq_init(port, port->rxqs[queue]);\n\t\tif (err)\n\t\t\tgoto err_cleanup;\n\t}\n\treturn 0;\n\nerr_cleanup:\n\tmvpp2_cleanup_rxqs(port);\n\treturn err;\n}\n\n/* Init all tx queues for port */\nstatic int mvpp2_setup_txqs(struct mvpp2_port *port)\n{\n\tstruct mvpp2_tx_queue *txq;\n\tint queue, err;\n\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\ttxq = port->txqs[queue];\n\t\terr = mvpp2_txq_init(port, txq);\n\t\tif (err)\n\t\t\tgoto err_cleanup;\n\n\t\t/* Assign this queue to a CPU */\n\t\tif (queue < num_possible_cpus())\n\t\t\tnetif_set_xps_queue(port->dev, cpumask_of(queue), queue);\n\t}\n\n\tif (port->has_tx_irqs) {\n\t\tmvpp2_tx_time_coal_set(port);\n\t\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\t\ttxq = port->txqs[queue];\n\t\t\tmvpp2_tx_pkts_coal_set(port, txq);\n\t\t}\n\t}\n\n\ton_each_cpu(mvpp2_txq_sent_counter_clear, port, 1);\n\treturn 0;\n\nerr_cleanup:\n\tmvpp2_cleanup_txqs(port);\n\treturn err;\n}\n\n/* The callback for per-port interrupt */\nstatic irqreturn_t mvpp2_isr(int irq, void *dev_id)\n{\n\tstruct mvpp2_queue_vector *qv = dev_id;\n\n\tmvpp2_qvec_interrupt_disable(qv);\n\n\tnapi_schedule(&qv->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mvpp2_isr_handle_ptp_queue(struct mvpp2_port *port, int nq)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct mvpp2_hwtstamp_queue *queue;\n\tstruct sk_buff *skb;\n\tvoid __iomem *ptp_q;\n\tunsigned int id;\n\tu32 r0, r1, r2;\n\n\tptp_q = port->priv->iface_base + MVPP22_PTP_BASE(port->gop_id);\n\tif (nq)\n\t\tptp_q += MVPP22_PTP_TX_Q1_R0 - MVPP22_PTP_TX_Q0_R0;\n\n\tqueue = &port->tx_hwtstamp_queue[nq];\n\n\twhile (1) {\n\t\tr0 = readl_relaxed(ptp_q + MVPP22_PTP_TX_Q0_R0) & 0xffff;\n\t\tif (!r0)\n\t\t\tbreak;\n\n\t\tr1 = readl_relaxed(ptp_q + MVPP22_PTP_TX_Q0_R1) & 0xffff;\n\t\tr2 = readl_relaxed(ptp_q + MVPP22_PTP_TX_Q0_R2) & 0xffff;\n\n\t\tid = (r0 >> 1) & 31;\n\n\t\tskb = queue->skb[id];\n\t\tqueue->skb[id] = NULL;\n\t\tif (skb) {\n\t\t\tu32 ts = r2 << 19 | r1 << 3 | r0 >> 13;\n\n\t\t\tmvpp22_tai_tstamp(port->priv->tai, ts, &shhwtstamps);\n\t\t\tskb_tstamp_tx(skb, &shhwtstamps);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t}\n}\n\nstatic void mvpp2_isr_handle_ptp(struct mvpp2_port *port)\n{\n\tvoid __iomem *ptp;\n\tu32 val;\n\n\tptp = port->priv->iface_base + MVPP22_PTP_BASE(port->gop_id);\n\tval = readl(ptp + MVPP22_PTP_INT_CAUSE);\n\tif (val & MVPP22_PTP_INT_CAUSE_QUEUE0)\n\t\tmvpp2_isr_handle_ptp_queue(port, 0);\n\tif (val & MVPP22_PTP_INT_CAUSE_QUEUE1)\n\t\tmvpp2_isr_handle_ptp_queue(port, 1);\n}\n\nstatic void mvpp2_isr_handle_link(struct mvpp2_port *port, bool link)\n{\n\tstruct net_device *dev = port->dev;\n\n\tif (port->phylink) {\n\t\tphylink_mac_change(port->phylink, link);\n\t\treturn;\n\t}\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\tif (link) {\n\t\tmvpp2_interrupts_enable(port);\n\n\t\tmvpp2_egress_enable(port);\n\t\tmvpp2_ingress_enable(port);\n\t\tnetif_carrier_on(dev);\n\t\tnetif_tx_wake_all_queues(dev);\n\t} else {\n\t\tnetif_tx_stop_all_queues(dev);\n\t\tnetif_carrier_off(dev);\n\t\tmvpp2_ingress_disable(port);\n\t\tmvpp2_egress_disable(port);\n\n\t\tmvpp2_interrupts_disable(port);\n\t}\n}\n\nstatic void mvpp2_isr_handle_xlg(struct mvpp2_port *port)\n{\n\tbool link;\n\tu32 val;\n\n\tval = readl(port->base + MVPP22_XLG_INT_STAT);\n\tif (val & MVPP22_XLG_INT_STAT_LINK) {\n\t\tval = readl(port->base + MVPP22_XLG_STATUS);\n\t\tlink = (val & MVPP22_XLG_STATUS_LINK_UP);\n\t\tmvpp2_isr_handle_link(port, link);\n\t}\n}\n\nstatic void mvpp2_isr_handle_gmac_internal(struct mvpp2_port *port)\n{\n\tbool link;\n\tu32 val;\n\n\tif (phy_interface_mode_is_rgmii(port->phy_interface) ||\n\t    phy_interface_mode_is_8023z(port->phy_interface) ||\n\t    port->phy_interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval = readl(port->base + MVPP22_GMAC_INT_STAT);\n\t\tif (val & MVPP22_GMAC_INT_STAT_LINK) {\n\t\t\tval = readl(port->base + MVPP2_GMAC_STATUS0);\n\t\t\tlink = (val & MVPP2_GMAC_STATUS0_LINK_UP);\n\t\t\tmvpp2_isr_handle_link(port, link);\n\t\t}\n\t}\n}\n\n/* Per-port interrupt for link status changes */\nstatic irqreturn_t mvpp2_port_isr(int irq, void *dev_id)\n{\n\tstruct mvpp2_port *port = (struct mvpp2_port *)dev_id;\n\tu32 val;\n\n\tmvpp22_gop_mask_irq(port);\n\n\tif (mvpp2_port_supports_xlg(port) &&\n\t    mvpp2_is_xlg(port->phy_interface)) {\n\t\t/* Check the external status register */\n\t\tval = readl(port->base + MVPP22_XLG_EXT_INT_STAT);\n\t\tif (val & MVPP22_XLG_EXT_INT_STAT_XLG)\n\t\t\tmvpp2_isr_handle_xlg(port);\n\t\tif (val & MVPP22_XLG_EXT_INT_STAT_PTP)\n\t\t\tmvpp2_isr_handle_ptp(port);\n\t} else {\n\t\t/* If it's not the XLG, we must be using the GMAC.\n\t\t * Check the summary status.\n\t\t */\n\t\tval = readl(port->base + MVPP22_GMAC_INT_SUM_STAT);\n\t\tif (val & MVPP22_GMAC_INT_SUM_STAT_INTERNAL)\n\t\t\tmvpp2_isr_handle_gmac_internal(port);\n\t\tif (val & MVPP22_GMAC_INT_SUM_STAT_PTP)\n\t\t\tmvpp2_isr_handle_ptp(port);\n\t}\n\n\tmvpp22_gop_unmask_irq(port);\n\treturn IRQ_HANDLED;\n}\n\nstatic enum hrtimer_restart mvpp2_hr_timer_cb(struct hrtimer *timer)\n{\n\tstruct net_device *dev;\n\tstruct mvpp2_port *port;\n\tstruct mvpp2_port_pcpu *port_pcpu;\n\tunsigned int tx_todo, cause;\n\n\tport_pcpu = container_of(timer, struct mvpp2_port_pcpu, tx_done_timer);\n\tdev = port_pcpu->dev;\n\n\tif (!netif_running(dev))\n\t\treturn HRTIMER_NORESTART;\n\n\tport_pcpu->timer_scheduled = false;\n\tport = netdev_priv(dev);\n\n\t/* Process all the Tx queues */\n\tcause = (1 << port->ntxqs) - 1;\n\ttx_todo = mvpp2_tx_done(port, cause,\n\t\t\t\tmvpp2_cpu_to_thread(port->priv, smp_processor_id()));\n\n\t/* Set the timer in case not all the packets were processed */\n\tif (tx_todo && !port_pcpu->timer_scheduled) {\n\t\tport_pcpu->timer_scheduled = true;\n\t\thrtimer_forward_now(&port_pcpu->tx_done_timer,\n\t\t\t\t    MVPP2_TXDONE_HRTIMER_PERIOD_NS);\n\n\t\treturn HRTIMER_RESTART;\n\t}\n\treturn HRTIMER_NORESTART;\n}\n\n/* Main RX/TX processing routines */\n\n/* Display more error info */\nstatic void mvpp2_rx_error(struct mvpp2_port *port,\n\t\t\t   struct mvpp2_rx_desc *rx_desc)\n{\n\tu32 status = mvpp2_rxdesc_status_get(port, rx_desc);\n\tsize_t sz = mvpp2_rxdesc_size_get(port, rx_desc);\n\tchar *err_str = NULL;\n\n\tswitch (status & MVPP2_RXD_ERR_CODE_MASK) {\n\tcase MVPP2_RXD_ERR_CRC:\n\t\terr_str = \"crc\";\n\t\tbreak;\n\tcase MVPP2_RXD_ERR_OVERRUN:\n\t\terr_str = \"overrun\";\n\t\tbreak;\n\tcase MVPP2_RXD_ERR_RESOURCE:\n\t\terr_str = \"resource\";\n\t\tbreak;\n\t}\n\tif (err_str && net_ratelimit())\n\t\tnetdev_err(port->dev,\n\t\t\t   \"bad rx status %08x (%s error), size=%zu\\n\",\n\t\t\t   status, err_str, sz);\n}\n\n/* Handle RX checksum offload */\nstatic void mvpp2_rx_csum(struct mvpp2_port *port, u32 status,\n\t\t\t  struct sk_buff *skb)\n{\n\tif (((status & MVPP2_RXD_L3_IP4) &&\n\t     !(status & MVPP2_RXD_IP4_HEADER_ERR)) ||\n\t    (status & MVPP2_RXD_L3_IP6))\n\t\tif (((status & MVPP2_RXD_L4_UDP) ||\n\t\t     (status & MVPP2_RXD_L4_TCP)) &&\n\t\t     (status & MVPP2_RXD_L4_CSUM_OK)) {\n\t\t\tskb->csum = 0;\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\treturn;\n\t\t}\n\n\tskb->ip_summed = CHECKSUM_NONE;\n}\n\n/* Allocate a new skb and add it to BM pool */\nstatic int mvpp2_rx_refill(struct mvpp2_port *port,\n\t\t\t   struct mvpp2_bm_pool *bm_pool,\n\t\t\t   struct page_pool *page_pool, int pool)\n{\n\tdma_addr_t dma_addr;\n\tphys_addr_t phys_addr;\n\tvoid *buf;\n\n\tbuf = mvpp2_buf_alloc(port, bm_pool, page_pool,\n\t\t\t      &dma_addr, &phys_addr, GFP_ATOMIC);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmvpp2_bm_pool_put(port, pool, dma_addr, phys_addr);\n\n\treturn 0;\n}\n\n/* Handle tx checksum */\nstatic u32 mvpp2_skb_tx_csum(struct mvpp2_port *port, struct sk_buff *skb)\n{\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tint ip_hdr_len = 0;\n\t\tu8 l4_proto;\n\t\t__be16 l3_proto = vlan_get_protocol(skb);\n\n\t\tif (l3_proto == htons(ETH_P_IP)) {\n\t\t\tstruct iphdr *ip4h = ip_hdr(skb);\n\n\t\t\t/* Calculate IPv4 checksum and L4 checksum */\n\t\t\tip_hdr_len = ip4h->ihl;\n\t\t\tl4_proto = ip4h->protocol;\n\t\t} else if (l3_proto == htons(ETH_P_IPV6)) {\n\t\t\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\n\t\t\t/* Read l4_protocol from one of IPv6 extra headers */\n\t\t\tif (skb_network_header_len(skb) > 0)\n\t\t\t\tip_hdr_len = (skb_network_header_len(skb) >> 2);\n\t\t\tl4_proto = ip6h->nexthdr;\n\t\t} else {\n\t\t\treturn MVPP2_TXD_L4_CSUM_NOT;\n\t\t}\n\n\t\treturn mvpp2_txq_desc_csum(skb_network_offset(skb),\n\t\t\t\t\t   l3_proto, ip_hdr_len, l4_proto);\n\t}\n\n\treturn MVPP2_TXD_L4_CSUM_NOT | MVPP2_TXD_IP_CSUM_DISABLE;\n}\n\nstatic void mvpp2_xdp_finish_tx(struct mvpp2_port *port, u16 txq_id, int nxmit, int nxmit_byte)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\tstruct mvpp2_tx_queue *aggr_txq;\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tstruct mvpp2_tx_queue *txq;\n\tstruct netdev_queue *nq;\n\n\ttxq = port->txqs[txq_id];\n\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\tnq = netdev_get_tx_queue(port->dev, txq_id);\n\taggr_txq = &port->priv->aggr_txqs[thread];\n\n\ttxq_pcpu->reserved_num -= nxmit;\n\ttxq_pcpu->count += nxmit;\n\taggr_txq->count += nxmit;\n\n\t/* Enable transmit */\n\twmb();\n\tmvpp2_aggr_txq_pend_desc_add(port, nxmit);\n\n\tif (txq_pcpu->count >= txq_pcpu->stop_threshold)\n\t\tnetif_tx_stop_queue(nq);\n\n\t/* Finalize TX processing */\n\tif (!port->has_tx_irqs && txq_pcpu->count >= txq->done_pkts_coal)\n\t\tmvpp2_txq_done(port, txq, txq_pcpu);\n}\n\nstatic int\nmvpp2_xdp_submit_frame(struct mvpp2_port *port, u16 txq_id,\n\t\t       struct xdp_frame *xdpf, bool dma_map)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\tu32 tx_cmd = MVPP2_TXD_L4_CSUM_NOT | MVPP2_TXD_IP_CSUM_DISABLE |\n\t\t     MVPP2_TXD_F_DESC | MVPP2_TXD_L_DESC;\n\tenum mvpp2_tx_buf_type buf_type;\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tstruct mvpp2_tx_queue *aggr_txq;\n\tstruct mvpp2_tx_desc *tx_desc;\n\tstruct mvpp2_tx_queue *txq;\n\tint ret = MVPP2_XDP_TX;\n\tdma_addr_t dma_addr;\n\n\ttxq = port->txqs[txq_id];\n\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\taggr_txq = &port->priv->aggr_txqs[thread];\n\n\t/* Check number of available descriptors */\n\tif (mvpp2_aggr_desc_num_check(port, aggr_txq, 1) ||\n\t    mvpp2_txq_reserved_desc_num_proc(port, txq, txq_pcpu, 1)) {\n\t\tret = MVPP2_XDP_DROPPED;\n\t\tgoto out;\n\t}\n\n\t/* Get a descriptor for the first part of the packet */\n\ttx_desc = mvpp2_txq_next_desc_get(aggr_txq);\n\tmvpp2_txdesc_txq_set(port, tx_desc, txq->id);\n\tmvpp2_txdesc_size_set(port, tx_desc, xdpf->len);\n\n\tif (dma_map) {\n\t\t/* XDP_REDIRECT or AF_XDP */\n\t\tdma_addr = dma_map_single(port->dev->dev.parent, xdpf->data,\n\t\t\t\t\t  xdpf->len, DMA_TO_DEVICE);\n\n\t\tif (unlikely(dma_mapping_error(port->dev->dev.parent, dma_addr))) {\n\t\t\tmvpp2_txq_desc_put(txq);\n\t\t\tret = MVPP2_XDP_DROPPED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf_type = MVPP2_TYPE_XDP_NDO;\n\t} else {\n\t\t/* XDP_TX */\n\t\tstruct page *page = virt_to_page(xdpf->data);\n\n\t\tdma_addr = page_pool_get_dma_addr(page) +\n\t\t\t   sizeof(*xdpf) + xdpf->headroom;\n\t\tdma_sync_single_for_device(port->dev->dev.parent, dma_addr,\n\t\t\t\t\t   xdpf->len, DMA_BIDIRECTIONAL);\n\n\t\tbuf_type = MVPP2_TYPE_XDP_TX;\n\t}\n\n\tmvpp2_txdesc_dma_addr_set(port, tx_desc, dma_addr);\n\n\tmvpp2_txdesc_cmd_set(port, tx_desc, tx_cmd);\n\tmvpp2_txq_inc_put(port, txq_pcpu, xdpf, tx_desc, buf_type);\n\nout:\n\treturn ret;\n}\n\nstatic int\nmvpp2_xdp_xmit_back(struct mvpp2_port *port, struct xdp_buff *xdp)\n{\n\tstruct mvpp2_pcpu_stats *stats = this_cpu_ptr(port->stats);\n\tstruct xdp_frame *xdpf;\n\tu16 txq_id;\n\tint ret;\n\n\txdpf = xdp_convert_buff_to_frame(xdp);\n\tif (unlikely(!xdpf))\n\t\treturn MVPP2_XDP_DROPPED;\n\n\t/* The first of the TX queues are used for XPS,\n\t * the second half for XDP_TX\n\t */\n\ttxq_id = mvpp2_cpu_to_thread(port->priv, smp_processor_id()) + (port->ntxqs / 2);\n\n\tret = mvpp2_xdp_submit_frame(port, txq_id, xdpf, false);\n\tif (ret == MVPP2_XDP_TX) {\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->tx_bytes += xdpf->len;\n\t\tstats->tx_packets++;\n\t\tstats->xdp_tx++;\n\t\tu64_stats_update_end(&stats->syncp);\n\n\t\tmvpp2_xdp_finish_tx(port, txq_id, 1, xdpf->len);\n\t} else {\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->xdp_tx_err++;\n\t\tu64_stats_update_end(&stats->syncp);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmvpp2_xdp_xmit(struct net_device *dev, int num_frame,\n\t       struct xdp_frame **frames, u32 flags)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint i, nxmit_byte = 0, nxmit = num_frame;\n\tstruct mvpp2_pcpu_stats *stats;\n\tu16 txq_id;\n\tu32 ret;\n\n\tif (unlikely(test_bit(0, &port->state)))\n\t\treturn -ENETDOWN;\n\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\n\t/* The first of the TX queues are used for XPS,\n\t * the second half for XDP_TX\n\t */\n\ttxq_id = mvpp2_cpu_to_thread(port->priv, smp_processor_id()) + (port->ntxqs / 2);\n\n\tfor (i = 0; i < num_frame; i++) {\n\t\tret = mvpp2_xdp_submit_frame(port, txq_id, frames[i], true);\n\t\tif (ret == MVPP2_XDP_TX) {\n\t\t\tnxmit_byte += frames[i]->len;\n\t\t} else {\n\t\t\txdp_return_frame_rx_napi(frames[i]);\n\t\t\tnxmit--;\n\t\t}\n\t}\n\n\tif (likely(nxmit > 0))\n\t\tmvpp2_xdp_finish_tx(port, txq_id, nxmit, nxmit_byte);\n\n\tstats = this_cpu_ptr(port->stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->tx_bytes += nxmit_byte;\n\tstats->tx_packets += nxmit;\n\tstats->xdp_xmit += nxmit;\n\tstats->xdp_xmit_err += num_frame - nxmit;\n\tu64_stats_update_end(&stats->syncp);\n\n\treturn nxmit;\n}\n\nstatic int\nmvpp2_run_xdp(struct mvpp2_port *port, struct mvpp2_rx_queue *rxq,\n\t      struct bpf_prog *prog, struct xdp_buff *xdp,\n\t      struct page_pool *pp, struct mvpp2_pcpu_stats *stats)\n{\n\tunsigned int len, sync, err;\n\tstruct page *page;\n\tu32 ret, act;\n\n\tlen = xdp->data_end - xdp->data_hard_start - MVPP2_SKB_HEADROOM;\n\tact = bpf_prog_run_xdp(prog, xdp);\n\n\t/* Due xdp_adjust_tail: DMA sync for_device cover max len CPU touch */\n\tsync = xdp->data_end - xdp->data_hard_start - MVPP2_SKB_HEADROOM;\n\tsync = max(sync, len);\n\n\tswitch (act) {\n\tcase XDP_PASS:\n\t\tstats->xdp_pass++;\n\t\tret = MVPP2_XDP_PASS;\n\t\tbreak;\n\tcase XDP_REDIRECT:\n\t\terr = xdp_do_redirect(port->dev, xdp, prog);\n\t\tif (unlikely(err)) {\n\t\t\tret = MVPP2_XDP_DROPPED;\n\t\t\tpage = virt_to_head_page(xdp->data);\n\t\t\tpage_pool_put_page(pp, page, sync, true);\n\t\t} else {\n\t\t\tret = MVPP2_XDP_REDIR;\n\t\t\tstats->xdp_redirect++;\n\t\t}\n\t\tbreak;\n\tcase XDP_TX:\n\t\tret = mvpp2_xdp_xmit_back(port, xdp);\n\t\tif (ret != MVPP2_XDP_TX) {\n\t\t\tpage = virt_to_head_page(xdp->data);\n\t\t\tpage_pool_put_page(pp, page, sync, true);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbpf_warn_invalid_xdp_action(act);\n\t\tfallthrough;\n\tcase XDP_ABORTED:\n\t\ttrace_xdp_exception(port->dev, prog, act);\n\t\tfallthrough;\n\tcase XDP_DROP:\n\t\tpage = virt_to_head_page(xdp->data);\n\t\tpage_pool_put_page(pp, page, sync, true);\n\t\tret = MVPP2_XDP_DROPPED;\n\t\tstats->xdp_drop++;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/* Main rx processing */\nstatic int mvpp2_rx(struct mvpp2_port *port, struct napi_struct *napi,\n\t\t    int rx_todo, struct mvpp2_rx_queue *rxq)\n{\n\tstruct net_device *dev = port->dev;\n\tstruct mvpp2_pcpu_stats ps = {};\n\tenum dma_data_direction dma_dir;\n\tstruct bpf_prog *xdp_prog;\n\tstruct xdp_buff xdp;\n\tint rx_received;\n\tint rx_done = 0;\n\tu32 xdp_ret = 0;\n\n\trcu_read_lock();\n\n\txdp_prog = READ_ONCE(port->xdp_prog);\n\n\t/* Get number of received packets and clamp the to-do */\n\trx_received = mvpp2_rxq_received(port, rxq->id);\n\tif (rx_todo > rx_received)\n\t\trx_todo = rx_received;\n\n\twhile (rx_done < rx_todo) {\n\t\tstruct mvpp2_rx_desc *rx_desc = mvpp2_rxq_next_desc_get(rxq);\n\t\tstruct mvpp2_bm_pool *bm_pool;\n\t\tstruct page_pool *pp = NULL;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int frag_size;\n\t\tdma_addr_t dma_addr;\n\t\tphys_addr_t phys_addr;\n\t\tu32 rx_status, timestamp;\n\t\tint pool, rx_bytes, err, ret;\n\t\tvoid *data;\n\n\t\trx_done++;\n\t\trx_status = mvpp2_rxdesc_status_get(port, rx_desc);\n\t\trx_bytes = mvpp2_rxdesc_size_get(port, rx_desc);\n\t\trx_bytes -= MVPP2_MH_SIZE;\n\t\tdma_addr = mvpp2_rxdesc_dma_addr_get(port, rx_desc);\n\t\tphys_addr = mvpp2_rxdesc_cookie_get(port, rx_desc);\n\t\tdata = (void *)phys_to_virt(phys_addr);\n\n\t\tpool = (rx_status & MVPP2_RXD_BM_POOL_ID_MASK) >>\n\t\t\tMVPP2_RXD_BM_POOL_ID_OFFS;\n\t\tbm_pool = &port->priv->bm_pools[pool];\n\n\t\t/* In case of an error, release the requested buffer pointer\n\t\t * to the Buffer Manager. This request process is controlled\n\t\t * by the hardware, and the information about the buffer is\n\t\t * comprised by the RX descriptor.\n\t\t */\n\t\tif (rx_status & MVPP2_RXD_ERR_SUMMARY)\n\t\t\tgoto err_drop_frame;\n\n\t\tif (port->priv->percpu_pools) {\n\t\t\tpp = port->priv->page_pool[pool];\n\t\t\tdma_dir = page_pool_get_dma_dir(pp);\n\t\t} else {\n\t\t\tdma_dir = DMA_FROM_DEVICE;\n\t\t}\n\n\t\tdma_sync_single_for_cpu(dev->dev.parent, dma_addr,\n\t\t\t\t\trx_bytes + MVPP2_MH_SIZE,\n\t\t\t\t\tdma_dir);\n\n\t\t/* Prefetch header */\n\t\tprefetch(data);\n\n\t\tif (bm_pool->frag_size > PAGE_SIZE)\n\t\t\tfrag_size = 0;\n\t\telse\n\t\t\tfrag_size = bm_pool->frag_size;\n\n\t\tif (xdp_prog) {\n\t\t\txdp.data_hard_start = data;\n\t\t\txdp.data = data + MVPP2_MH_SIZE + MVPP2_SKB_HEADROOM;\n\t\t\txdp.data_end = xdp.data + rx_bytes;\n\t\t\txdp.frame_sz = PAGE_SIZE;\n\n\t\t\tif (bm_pool->pkt_size == MVPP2_BM_SHORT_PKT_SIZE)\n\t\t\t\txdp.rxq = &rxq->xdp_rxq_short;\n\t\t\telse\n\t\t\t\txdp.rxq = &rxq->xdp_rxq_long;\n\n\t\t\txdp_set_data_meta_invalid(&xdp);\n\n\t\t\tret = mvpp2_run_xdp(port, rxq, xdp_prog, &xdp, pp, &ps);\n\n\t\t\tif (ret) {\n\t\t\t\txdp_ret |= ret;\n\t\t\t\terr = mvpp2_rx_refill(port, bm_pool, pp, pool);\n\t\t\t\tif (err) {\n\t\t\t\t\tnetdev_err(port->dev, \"failed to refill BM pools\\n\");\n\t\t\t\t\tgoto err_drop_frame;\n\t\t\t\t}\n\n\t\t\t\tps.rx_packets++;\n\t\t\t\tps.rx_bytes += rx_bytes;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tskb = build_skb(data, frag_size);\n\t\tif (!skb) {\n\t\t\tnetdev_warn(port->dev, \"skb build failed\\n\");\n\t\t\tgoto err_drop_frame;\n\t\t}\n\n\t\t/* If we have RX hardware timestamping enabled, grab the\n\t\t * timestamp from the queue and convert.\n\t\t */\n\t\tif (mvpp22_rx_hwtstamping(port)) {\n\t\t\ttimestamp = le32_to_cpu(rx_desc->pp22.timestamp);\n\t\t\tmvpp22_tai_tstamp(port->priv->tai, timestamp,\n\t\t\t\t\t skb_hwtstamps(skb));\n\t\t}\n\n\t\terr = mvpp2_rx_refill(port, bm_pool, pp, pool);\n\t\tif (err) {\n\t\t\tnetdev_err(port->dev, \"failed to refill BM pools\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto err_drop_frame;\n\t\t}\n\n\t\tif (pp)\n\t\t\tpage_pool_release_page(pp, virt_to_page(data));\n\t\telse\n\t\t\tdma_unmap_single_attrs(dev->dev.parent, dma_addr,\n\t\t\t\t\t       bm_pool->buf_size, DMA_FROM_DEVICE,\n\t\t\t\t\t       DMA_ATTR_SKIP_CPU_SYNC);\n\n\t\tps.rx_packets++;\n\t\tps.rx_bytes += rx_bytes;\n\n\t\tskb_reserve(skb, MVPP2_MH_SIZE + MVPP2_SKB_HEADROOM);\n\t\tskb_put(skb, rx_bytes);\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmvpp2_rx_csum(port, rx_status, skb);\n\n\t\tnapi_gro_receive(napi, skb);\n\t\tcontinue;\n\nerr_drop_frame:\n\t\tdev->stats.rx_errors++;\n\t\tmvpp2_rx_error(port, rx_desc);\n\t\t/* Return the buffer to the pool */\n\t\tmvpp2_bm_pool_put(port, pool, dma_addr, phys_addr);\n\t}\n\n\trcu_read_unlock();\n\n\tif (xdp_ret & MVPP2_XDP_REDIR)\n\t\txdp_do_flush_map();\n\n\tif (ps.rx_packets) {\n\t\tstruct mvpp2_pcpu_stats *stats = this_cpu_ptr(port->stats);\n\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->rx_packets += ps.rx_packets;\n\t\tstats->rx_bytes   += ps.rx_bytes;\n\t\t/* xdp */\n\t\tstats->xdp_redirect += ps.xdp_redirect;\n\t\tstats->xdp_pass += ps.xdp_pass;\n\t\tstats->xdp_drop += ps.xdp_drop;\n\t\tu64_stats_update_end(&stats->syncp);\n\t}\n\n\t/* Update Rx queue management counters */\n\twmb();\n\tmvpp2_rxq_status_update(port, rxq->id, rx_done, rx_done);\n\n\treturn rx_todo;\n}\n\nstatic inline void\ntx_desc_unmap_put(struct mvpp2_port *port, struct mvpp2_tx_queue *txq,\n\t\t  struct mvpp2_tx_desc *desc)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\tstruct mvpp2_txq_pcpu *txq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\n\tdma_addr_t buf_dma_addr =\n\t\tmvpp2_txdesc_dma_addr_get(port, desc);\n\tsize_t buf_sz =\n\t\tmvpp2_txdesc_size_get(port, desc);\n\tif (!IS_TSO_HEADER(txq_pcpu, buf_dma_addr))\n\t\tdma_unmap_single(port->dev->dev.parent, buf_dma_addr,\n\t\t\t\t buf_sz, DMA_TO_DEVICE);\n\tmvpp2_txq_desc_put(txq);\n}\n\nstatic void mvpp2_txdesc_clear_ptp(struct mvpp2_port *port,\n\t\t\t\t   struct mvpp2_tx_desc *desc)\n{\n\t/* We only need to clear the low bits */\n\tif (port->priv->hw_version != MVPP21)\n\t\tdesc->pp22.ptp_descriptor &=\n\t\t\tcpu_to_le32(~MVPP22_PTP_DESC_MASK_LOW);\n}\n\nstatic bool mvpp2_tx_hw_tstamp(struct mvpp2_port *port,\n\t\t\t       struct mvpp2_tx_desc *tx_desc,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct mvpp2_hwtstamp_queue *queue;\n\tunsigned int mtype, type, i;\n\tstruct ptp_header *hdr;\n\tu64 ptpdesc;\n\n\tif (port->priv->hw_version == MVPP21 ||\n\t    port->tx_hwtstamp_type == HWTSTAMP_TX_OFF)\n\t\treturn false;\n\n\ttype = ptp_classify_raw(skb);\n\tif (!type)\n\t\treturn false;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn false;\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tptpdesc = MVPP22_PTP_MACTIMESTAMPINGEN |\n\t\t  MVPP22_PTP_ACTION_CAPTURE;\n\tqueue = &port->tx_hwtstamp_queue[0];\n\n\tswitch (type & PTP_CLASS_VMASK) {\n\tcase PTP_CLASS_V1:\n\t\tptpdesc |= MVPP22_PTP_PACKETFORMAT(MVPP22_PTP_PKT_FMT_PTPV1);\n\t\tbreak;\n\n\tcase PTP_CLASS_V2:\n\t\tptpdesc |= MVPP22_PTP_PACKETFORMAT(MVPP22_PTP_PKT_FMT_PTPV2);\n\t\tmtype = hdr->tsmt & 15;\n\t\t/* Direct PTP Sync messages to queue 1 */\n\t\tif (mtype == 0) {\n\t\t\tptpdesc |= MVPP22_PTP_TIMESTAMPQUEUESELECT;\n\t\t\tqueue = &port->tx_hwtstamp_queue[1];\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Take a reference on the skb and insert into our queue */\n\ti = queue->next;\n\tqueue->next = (i + 1) & 31;\n\tif (queue->skb[i])\n\t\tdev_kfree_skb_any(queue->skb[i]);\n\tqueue->skb[i] = skb_get(skb);\n\n\tptpdesc |= MVPP22_PTP_TIMESTAMPENTRYID(i);\n\n\t/*\n\t * 3:0\t\t- PTPAction\n\t * 6:4\t\t- PTPPacketFormat\n\t * 7\t\t- PTP_CF_WraparoundCheckEn\n\t * 9:8\t\t- IngressTimestampSeconds[1:0]\n\t * 10\t\t- Reserved\n\t * 11\t\t- MACTimestampingEn\n\t * 17:12\t- PTP_TimestampQueueEntryID[5:0]\n\t * 18\t\t- PTPTimestampQueueSelect\n\t * 19\t\t- UDPChecksumUpdateEn\n\t * 27:20\t- TimestampOffset\n\t *\t\t\tPTP, NTPTransmit, OWAMP/TWAMP - L3 to PTP header\n\t *\t\t\tNTPTs, Y.1731 - L3 to timestamp entry\n\t * 35:28\t- UDP Checksum Offset\n\t *\n\t * stored in tx descriptor bits 75:64 (11:0) and 191:168 (35:12)\n\t */\n\ttx_desc->pp22.ptp_descriptor &=\n\t\tcpu_to_le32(~MVPP22_PTP_DESC_MASK_LOW);\n\ttx_desc->pp22.ptp_descriptor |=\n\t\tcpu_to_le32(ptpdesc & MVPP22_PTP_DESC_MASK_LOW);\n\ttx_desc->pp22.buf_dma_addr_ptp &= cpu_to_le64(~0xffffff0000000000ULL);\n\ttx_desc->pp22.buf_dma_addr_ptp |= cpu_to_le64((ptpdesc >> 12) << 40);\n\n\treturn true;\n}\n\n/* Handle tx fragmentation processing */\nstatic int mvpp2_tx_frag_process(struct mvpp2_port *port, struct sk_buff *skb,\n\t\t\t\t struct mvpp2_tx_queue *aggr_txq,\n\t\t\t\t struct mvpp2_tx_queue *txq)\n{\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\tstruct mvpp2_txq_pcpu *txq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\tstruct mvpp2_tx_desc *tx_desc;\n\tint i;\n\tdma_addr_t buf_dma_addr;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tvoid *addr = skb_frag_address(frag);\n\n\t\ttx_desc = mvpp2_txq_next_desc_get(aggr_txq);\n\t\tmvpp2_txdesc_clear_ptp(port, tx_desc);\n\t\tmvpp2_txdesc_txq_set(port, tx_desc, txq->id);\n\t\tmvpp2_txdesc_size_set(port, tx_desc, skb_frag_size(frag));\n\n\t\tbuf_dma_addr = dma_map_single(port->dev->dev.parent, addr,\n\t\t\t\t\t      skb_frag_size(frag),\n\t\t\t\t\t      DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(port->dev->dev.parent, buf_dma_addr)) {\n\t\t\tmvpp2_txq_desc_put(txq);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tmvpp2_txdesc_dma_addr_set(port, tx_desc, buf_dma_addr);\n\n\t\tif (i == (skb_shinfo(skb)->nr_frags - 1)) {\n\t\t\t/* Last descriptor */\n\t\t\tmvpp2_txdesc_cmd_set(port, tx_desc,\n\t\t\t\t\t     MVPP2_TXD_L_DESC);\n\t\t\tmvpp2_txq_inc_put(port, txq_pcpu, skb, tx_desc, MVPP2_TYPE_SKB);\n\t\t} else {\n\t\t\t/* Descriptor in the middle: Not First, Not Last */\n\t\t\tmvpp2_txdesc_cmd_set(port, tx_desc, 0);\n\t\t\tmvpp2_txq_inc_put(port, txq_pcpu, NULL, tx_desc, MVPP2_TYPE_SKB);\n\t\t}\n\t}\n\n\treturn 0;\ncleanup:\n\t/* Release all descriptors that were used to map fragments of\n\t * this packet, as well as the corresponding DMA mappings\n\t */\n\tfor (i = i - 1; i >= 0; i--) {\n\t\ttx_desc = txq->descs + i;\n\t\ttx_desc_unmap_put(port, txq, tx_desc);\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic inline void mvpp2_tso_put_hdr(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     struct mvpp2_tx_queue *txq,\n\t\t\t\t     struct mvpp2_tx_queue *aggr_txq,\n\t\t\t\t     struct mvpp2_txq_pcpu *txq_pcpu,\n\t\t\t\t     int hdr_sz)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tstruct mvpp2_tx_desc *tx_desc = mvpp2_txq_next_desc_get(aggr_txq);\n\tdma_addr_t addr;\n\n\tmvpp2_txdesc_clear_ptp(port, tx_desc);\n\tmvpp2_txdesc_txq_set(port, tx_desc, txq->id);\n\tmvpp2_txdesc_size_set(port, tx_desc, hdr_sz);\n\n\taddr = txq_pcpu->tso_headers_dma +\n\t       txq_pcpu->txq_put_index * TSO_HEADER_SIZE;\n\tmvpp2_txdesc_dma_addr_set(port, tx_desc, addr);\n\n\tmvpp2_txdesc_cmd_set(port, tx_desc, mvpp2_skb_tx_csum(port, skb) |\n\t\t\t\t\t    MVPP2_TXD_F_DESC |\n\t\t\t\t\t    MVPP2_TXD_PADDING_DISABLE);\n\tmvpp2_txq_inc_put(port, txq_pcpu, NULL, tx_desc, MVPP2_TYPE_SKB);\n}\n\nstatic inline int mvpp2_tso_put_data(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev, struct tso_t *tso,\n\t\t\t\t     struct mvpp2_tx_queue *txq,\n\t\t\t\t     struct mvpp2_tx_queue *aggr_txq,\n\t\t\t\t     struct mvpp2_txq_pcpu *txq_pcpu,\n\t\t\t\t     int sz, bool left, bool last)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tstruct mvpp2_tx_desc *tx_desc = mvpp2_txq_next_desc_get(aggr_txq);\n\tdma_addr_t buf_dma_addr;\n\n\tmvpp2_txdesc_clear_ptp(port, tx_desc);\n\tmvpp2_txdesc_txq_set(port, tx_desc, txq->id);\n\tmvpp2_txdesc_size_set(port, tx_desc, sz);\n\n\tbuf_dma_addr = dma_map_single(dev->dev.parent, tso->data, sz,\n\t\t\t\t      DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev->dev.parent, buf_dma_addr))) {\n\t\tmvpp2_txq_desc_put(txq);\n\t\treturn -ENOMEM;\n\t}\n\n\tmvpp2_txdesc_dma_addr_set(port, tx_desc, buf_dma_addr);\n\n\tif (!left) {\n\t\tmvpp2_txdesc_cmd_set(port, tx_desc, MVPP2_TXD_L_DESC);\n\t\tif (last) {\n\t\t\tmvpp2_txq_inc_put(port, txq_pcpu, skb, tx_desc, MVPP2_TYPE_SKB);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tmvpp2_txdesc_cmd_set(port, tx_desc, 0);\n\t}\n\n\tmvpp2_txq_inc_put(port, txq_pcpu, NULL, tx_desc, MVPP2_TYPE_SKB);\n\treturn 0;\n}\n\nstatic int mvpp2_tx_tso(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct mvpp2_tx_queue *txq,\n\t\t\tstruct mvpp2_tx_queue *aggr_txq,\n\t\t\tstruct mvpp2_txq_pcpu *txq_pcpu)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint hdr_sz, i, len, descs = 0;\n\tstruct tso_t tso;\n\n\t/* Check number of available descriptors */\n\tif (mvpp2_aggr_desc_num_check(port, aggr_txq, tso_count_descs(skb)) ||\n\t    mvpp2_txq_reserved_desc_num_proc(port, txq, txq_pcpu,\n\t\t\t\t\t     tso_count_descs(skb)))\n\t\treturn 0;\n\n\thdr_sz = tso_start(skb, &tso);\n\n\tlen = skb->len - hdr_sz;\n\twhile (len > 0) {\n\t\tint left = min_t(int, skb_shinfo(skb)->gso_size, len);\n\t\tchar *hdr = txq_pcpu->tso_headers +\n\t\t\t    txq_pcpu->txq_put_index * TSO_HEADER_SIZE;\n\n\t\tlen -= left;\n\t\tdescs++;\n\n\t\ttso_build_hdr(skb, hdr, &tso, left, len == 0);\n\t\tmvpp2_tso_put_hdr(skb, dev, txq, aggr_txq, txq_pcpu, hdr_sz);\n\n\t\twhile (left > 0) {\n\t\t\tint sz = min_t(int, tso.size, left);\n\t\t\tleft -= sz;\n\t\t\tdescs++;\n\n\t\t\tif (mvpp2_tso_put_data(skb, dev, &tso, txq, aggr_txq,\n\t\t\t\t\t       txq_pcpu, sz, left, len == 0))\n\t\t\t\tgoto release;\n\t\t\ttso_build_data(skb, &tso, sz);\n\t\t}\n\t}\n\n\treturn descs;\n\nrelease:\n\tfor (i = descs - 1; i >= 0; i--) {\n\t\tstruct mvpp2_tx_desc *tx_desc = txq->descs + i;\n\t\ttx_desc_unmap_put(port, txq, tx_desc);\n\t}\n\treturn 0;\n}\n\n/* Main tx processing */\nstatic netdev_tx_t mvpp2_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tstruct mvpp2_tx_queue *txq, *aggr_txq;\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tstruct mvpp2_tx_desc *tx_desc;\n\tdma_addr_t buf_dma_addr;\n\tunsigned long flags = 0;\n\tunsigned int thread;\n\tint frags = 0;\n\tu16 txq_id;\n\tu32 tx_cmd;\n\n\tthread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\n\ttxq_id = skb_get_queue_mapping(skb);\n\ttxq = port->txqs[txq_id];\n\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\taggr_txq = &port->priv->aggr_txqs[thread];\n\n\tif (test_bit(thread, &port->priv->lock_map))\n\t\tspin_lock_irqsave(&port->tx_lock[thread], flags);\n\n\tif (skb_is_gso(skb)) {\n\t\tfrags = mvpp2_tx_tso(skb, dev, txq, aggr_txq, txq_pcpu);\n\t\tgoto out;\n\t}\n\tfrags = skb_shinfo(skb)->nr_frags + 1;\n\n\t/* Check number of available descriptors */\n\tif (mvpp2_aggr_desc_num_check(port, aggr_txq, frags) ||\n\t    mvpp2_txq_reserved_desc_num_proc(port, txq, txq_pcpu, frags)) {\n\t\tfrags = 0;\n\t\tgoto out;\n\t}\n\n\t/* Get a descriptor for the first part of the packet */\n\ttx_desc = mvpp2_txq_next_desc_get(aggr_txq);\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) ||\n\t    !mvpp2_tx_hw_tstamp(port, tx_desc, skb))\n\t\tmvpp2_txdesc_clear_ptp(port, tx_desc);\n\tmvpp2_txdesc_txq_set(port, tx_desc, txq->id);\n\tmvpp2_txdesc_size_set(port, tx_desc, skb_headlen(skb));\n\n\tbuf_dma_addr = dma_map_single(dev->dev.parent, skb->data,\n\t\t\t\t      skb_headlen(skb), DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(dev->dev.parent, buf_dma_addr))) {\n\t\tmvpp2_txq_desc_put(txq);\n\t\tfrags = 0;\n\t\tgoto out;\n\t}\n\n\tmvpp2_txdesc_dma_addr_set(port, tx_desc, buf_dma_addr);\n\n\ttx_cmd = mvpp2_skb_tx_csum(port, skb);\n\n\tif (frags == 1) {\n\t\t/* First and Last descriptor */\n\t\ttx_cmd |= MVPP2_TXD_F_DESC | MVPP2_TXD_L_DESC;\n\t\tmvpp2_txdesc_cmd_set(port, tx_desc, tx_cmd);\n\t\tmvpp2_txq_inc_put(port, txq_pcpu, skb, tx_desc, MVPP2_TYPE_SKB);\n\t} else {\n\t\t/* First but not Last */\n\t\ttx_cmd |= MVPP2_TXD_F_DESC | MVPP2_TXD_PADDING_DISABLE;\n\t\tmvpp2_txdesc_cmd_set(port, tx_desc, tx_cmd);\n\t\tmvpp2_txq_inc_put(port, txq_pcpu, NULL, tx_desc, MVPP2_TYPE_SKB);\n\n\t\t/* Continue with other skb fragments */\n\t\tif (mvpp2_tx_frag_process(port, skb, aggr_txq, txq)) {\n\t\t\ttx_desc_unmap_put(port, txq, tx_desc);\n\t\t\tfrags = 0;\n\t\t}\n\t}\n\nout:\n\tif (frags > 0) {\n\t\tstruct mvpp2_pcpu_stats *stats = per_cpu_ptr(port->stats, thread);\n\t\tstruct netdev_queue *nq = netdev_get_tx_queue(dev, txq_id);\n\n\t\ttxq_pcpu->reserved_num -= frags;\n\t\ttxq_pcpu->count += frags;\n\t\taggr_txq->count += frags;\n\n\t\t/* Enable transmit */\n\t\twmb();\n\t\tmvpp2_aggr_txq_pend_desc_add(port, frags);\n\n\t\tif (txq_pcpu->count >= txq_pcpu->stop_threshold)\n\t\t\tnetif_tx_stop_queue(nq);\n\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += skb->len;\n\t\tu64_stats_update_end(&stats->syncp);\n\t} else {\n\t\tdev->stats.tx_dropped++;\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\t/* Finalize TX processing */\n\tif (!port->has_tx_irqs && txq_pcpu->count >= txq->done_pkts_coal)\n\t\tmvpp2_txq_done(port, txq, txq_pcpu);\n\n\t/* Set the timer in case not all frags were processed */\n\tif (!port->has_tx_irqs && txq_pcpu->count <= frags &&\n\t    txq_pcpu->count > 0) {\n\t\tstruct mvpp2_port_pcpu *port_pcpu = per_cpu_ptr(port->pcpu, thread);\n\n\t\tif (!port_pcpu->timer_scheduled) {\n\t\t\tport_pcpu->timer_scheduled = true;\n\t\t\thrtimer_start(&port_pcpu->tx_done_timer,\n\t\t\t\t      MVPP2_TXDONE_HRTIMER_PERIOD_NS,\n\t\t\t\t      HRTIMER_MODE_REL_PINNED_SOFT);\n\t\t}\n\t}\n\n\tif (test_bit(thread, &port->priv->lock_map))\n\t\tspin_unlock_irqrestore(&port->tx_lock[thread], flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline void mvpp2_cause_error(struct net_device *dev, int cause)\n{\n\tif (cause & MVPP2_CAUSE_FCS_ERR_MASK)\n\t\tnetdev_err(dev, \"FCS error\\n\");\n\tif (cause & MVPP2_CAUSE_RX_FIFO_OVERRUN_MASK)\n\t\tnetdev_err(dev, \"rx fifo overrun error\\n\");\n\tif (cause & MVPP2_CAUSE_TX_FIFO_UNDERRUN_MASK)\n\t\tnetdev_err(dev, \"tx fifo underrun error\\n\");\n}\n\nstatic int mvpp2_poll(struct napi_struct *napi, int budget)\n{\n\tu32 cause_rx_tx, cause_rx, cause_tx, cause_misc;\n\tint rx_done = 0;\n\tstruct mvpp2_port *port = netdev_priv(napi->dev);\n\tstruct mvpp2_queue_vector *qv;\n\tunsigned int thread = mvpp2_cpu_to_thread(port->priv, smp_processor_id());\n\n\tqv = container_of(napi, struct mvpp2_queue_vector, napi);\n\n\t/* Rx/Tx cause register\n\t *\n\t * Bits 0-15: each bit indicates received packets on the Rx queue\n\t * (bit 0 is for Rx queue 0).\n\t *\n\t * Bits 16-23: each bit indicates transmitted packets on the Tx queue\n\t * (bit 16 is for Tx queue 0).\n\t *\n\t * Each CPU has its own Rx/Tx cause register\n\t */\n\tcause_rx_tx = mvpp2_thread_read_relaxed(port->priv, qv->sw_thread_id,\n\t\t\t\t\t\tMVPP2_ISR_RX_TX_CAUSE_REG(port->id));\n\n\tcause_misc = cause_rx_tx & MVPP2_CAUSE_MISC_SUM_MASK;\n\tif (cause_misc) {\n\t\tmvpp2_cause_error(port->dev, cause_misc);\n\n\t\t/* Clear the cause register */\n\t\tmvpp2_write(port->priv, MVPP2_ISR_MISC_CAUSE_REG, 0);\n\t\tmvpp2_thread_write(port->priv, thread,\n\t\t\t\t   MVPP2_ISR_RX_TX_CAUSE_REG(port->id),\n\t\t\t\t   cause_rx_tx & ~MVPP2_CAUSE_MISC_SUM_MASK);\n\t}\n\n\tif (port->has_tx_irqs) {\n\t\tcause_tx = cause_rx_tx & MVPP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK;\n\t\tif (cause_tx) {\n\t\t\tcause_tx >>= MVPP2_CAUSE_TXQ_OCCUP_DESC_ALL_OFFSET;\n\t\t\tmvpp2_tx_done(port, cause_tx, qv->sw_thread_id);\n\t\t}\n\t}\n\n\t/* Process RX packets */\n\tcause_rx = cause_rx_tx &\n\t\t   MVPP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK(port->priv->hw_version);\n\tcause_rx <<= qv->first_rxq;\n\tcause_rx |= qv->pending_cause_rx;\n\twhile (cause_rx && budget > 0) {\n\t\tint count;\n\t\tstruct mvpp2_rx_queue *rxq;\n\n\t\trxq = mvpp2_get_rx_queue(port, cause_rx);\n\t\tif (!rxq)\n\t\t\tbreak;\n\n\t\tcount = mvpp2_rx(port, napi, budget, rxq);\n\t\trx_done += count;\n\t\tbudget -= count;\n\t\tif (budget > 0) {\n\t\t\t/* Clear the bit associated to this Rx queue\n\t\t\t * so that next iteration will continue from\n\t\t\t * the next Rx queue.\n\t\t\t */\n\t\t\tcause_rx &= ~(1 << rxq->logic_rxq);\n\t\t}\n\t}\n\n\tif (budget > 0) {\n\t\tcause_rx = 0;\n\t\tnapi_complete_done(napi, rx_done);\n\n\t\tmvpp2_qvec_interrupt_enable(qv);\n\t}\n\tqv->pending_cause_rx = cause_rx;\n\treturn rx_done;\n}\n\nstatic void mvpp22_mode_reconfigure(struct mvpp2_port *port)\n{\n\tu32 ctrl3;\n\n\t/* Set the GMAC & XLG MAC in reset */\n\tmvpp2_mac_reset_assert(port);\n\n\t/* Set the MPCS and XPCS in reset */\n\tmvpp22_pcs_reset_assert(port);\n\n\t/* comphy reconfiguration */\n\tmvpp22_comphy_init(port);\n\n\t/* gop reconfiguration */\n\tmvpp22_gop_init(port);\n\n\tmvpp22_pcs_reset_deassert(port);\n\n\tif (mvpp2_port_supports_xlg(port)) {\n\t\tctrl3 = readl(port->base + MVPP22_XLG_CTRL3_REG);\n\t\tctrl3 &= ~MVPP22_XLG_CTRL3_MACMODESELECT_MASK;\n\n\t\tif (mvpp2_is_xlg(port->phy_interface))\n\t\t\tctrl3 |= MVPP22_XLG_CTRL3_MACMODESELECT_10G;\n\t\telse\n\t\t\tctrl3 |= MVPP22_XLG_CTRL3_MACMODESELECT_GMAC;\n\n\t\twritel(ctrl3, port->base + MVPP22_XLG_CTRL3_REG);\n\t}\n\n\tif (mvpp2_port_supports_xlg(port) && mvpp2_is_xlg(port->phy_interface))\n\t\tmvpp2_xlg_max_rx_size_set(port);\n\telse\n\t\tmvpp2_gmac_max_rx_size_set(port);\n}\n\n/* Set hw internals when starting port */\nstatic void mvpp2_start_dev(struct mvpp2_port *port)\n{\n\tint i;\n\n\tmvpp2_txp_max_tx_size_set(port);\n\n\tfor (i = 0; i < port->nqvecs; i++)\n\t\tnapi_enable(&port->qvecs[i].napi);\n\n\t/* Enable interrupts on all threads */\n\tmvpp2_interrupts_enable(port);\n\n\tif (port->priv->hw_version == MVPP22)\n\t\tmvpp22_mode_reconfigure(port);\n\n\tif (port->phylink) {\n\t\tphylink_start(port->phylink);\n\t} else {\n\t\tmvpp2_acpi_start(port);\n\t}\n\n\tnetif_tx_start_all_queues(port->dev);\n\n\tclear_bit(0, &port->state);\n}\n\n/* Set hw internals when stopping port */\nstatic void mvpp2_stop_dev(struct mvpp2_port *port)\n{\n\tint i;\n\n\tset_bit(0, &port->state);\n\n\t/* Disable interrupts on all threads */\n\tmvpp2_interrupts_disable(port);\n\n\tfor (i = 0; i < port->nqvecs; i++)\n\t\tnapi_disable(&port->qvecs[i].napi);\n\n\tif (port->phylink)\n\t\tphylink_stop(port->phylink);\n\tphy_power_off(port->comphy);\n}\n\nstatic int mvpp2_check_ringparam_valid(struct net_device *dev,\n\t\t\t\t       struct ethtool_ringparam *ring)\n{\n\tu16 new_rx_pending = ring->rx_pending;\n\tu16 new_tx_pending = ring->tx_pending;\n\n\tif (ring->rx_pending == 0 || ring->tx_pending == 0)\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending > MVPP2_MAX_RXD_MAX)\n\t\tnew_rx_pending = MVPP2_MAX_RXD_MAX;\n\telse if (!IS_ALIGNED(ring->rx_pending, 16))\n\t\tnew_rx_pending = ALIGN(ring->rx_pending, 16);\n\n\tif (ring->tx_pending > MVPP2_MAX_TXD_MAX)\n\t\tnew_tx_pending = MVPP2_MAX_TXD_MAX;\n\telse if (!IS_ALIGNED(ring->tx_pending, 32))\n\t\tnew_tx_pending = ALIGN(ring->tx_pending, 32);\n\n\t/* The Tx ring size cannot be smaller than the minimum number of\n\t * descriptors needed for TSO.\n\t */\n\tif (new_tx_pending < MVPP2_MAX_SKB_DESCS)\n\t\tnew_tx_pending = ALIGN(MVPP2_MAX_SKB_DESCS, 32);\n\n\tif (ring->rx_pending != new_rx_pending) {\n\t\tnetdev_info(dev, \"illegal Rx ring size value %d, round to %d\\n\",\n\t\t\t    ring->rx_pending, new_rx_pending);\n\t\tring->rx_pending = new_rx_pending;\n\t}\n\n\tif (ring->tx_pending != new_tx_pending) {\n\t\tnetdev_info(dev, \"illegal Tx ring size value %d, round to %d\\n\",\n\t\t\t    ring->tx_pending, new_tx_pending);\n\t\tring->tx_pending = new_tx_pending;\n\t}\n\n\treturn 0;\n}\n\nstatic void mvpp21_get_mac_address(struct mvpp2_port *port, unsigned char *addr)\n{\n\tu32 mac_addr_l, mac_addr_m, mac_addr_h;\n\n\tmac_addr_l = readl(port->base + MVPP2_GMAC_CTRL_1_REG);\n\tmac_addr_m = readl(port->priv->lms_base + MVPP2_SRC_ADDR_MIDDLE);\n\tmac_addr_h = readl(port->priv->lms_base + MVPP2_SRC_ADDR_HIGH);\n\taddr[0] = (mac_addr_h >> 24) & 0xFF;\n\taddr[1] = (mac_addr_h >> 16) & 0xFF;\n\taddr[2] = (mac_addr_h >> 8) & 0xFF;\n\taddr[3] = mac_addr_h & 0xFF;\n\taddr[4] = mac_addr_m & 0xFF;\n\taddr[5] = (mac_addr_l >> MVPP2_GMAC_SA_LOW_OFFS) & 0xFF;\n}\n\nstatic int mvpp2_irqs_init(struct mvpp2_port *port)\n{\n\tint err, i;\n\n\tfor (i = 0; i < port->nqvecs; i++) {\n\t\tstruct mvpp2_queue_vector *qv = port->qvecs + i;\n\n\t\tif (qv->type == MVPP2_QUEUE_VECTOR_PRIVATE) {\n\t\t\tqv->mask = kzalloc(cpumask_size(), GFP_KERNEL);\n\t\t\tif (!qv->mask) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tirq_set_status_flags(qv->irq, IRQ_NO_BALANCING);\n\t\t}\n\n\t\terr = request_irq(qv->irq, mvpp2_isr, 0, port->dev->name, qv);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (qv->type == MVPP2_QUEUE_VECTOR_PRIVATE) {\n\t\t\tunsigned int cpu;\n\n\t\t\tfor_each_present_cpu(cpu) {\n\t\t\t\tif (mvpp2_cpu_to_thread(port->priv, cpu) ==\n\t\t\t\t    qv->sw_thread_id)\n\t\t\t\t\tcpumask_set_cpu(cpu, qv->mask);\n\t\t\t}\n\n\t\t\tirq_set_affinity_hint(qv->irq, qv->mask);\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tfor (i = 0; i < port->nqvecs; i++) {\n\t\tstruct mvpp2_queue_vector *qv = port->qvecs + i;\n\n\t\tirq_set_affinity_hint(qv->irq, NULL);\n\t\tkfree(qv->mask);\n\t\tqv->mask = NULL;\n\t\tfree_irq(qv->irq, qv);\n\t}\n\n\treturn err;\n}\n\nstatic void mvpp2_irqs_deinit(struct mvpp2_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->nqvecs; i++) {\n\t\tstruct mvpp2_queue_vector *qv = port->qvecs + i;\n\n\t\tirq_set_affinity_hint(qv->irq, NULL);\n\t\tkfree(qv->mask);\n\t\tqv->mask = NULL;\n\t\tirq_clear_status_flags(qv->irq, IRQ_NO_BALANCING);\n\t\tfree_irq(qv->irq, qv);\n\t}\n}\n\nstatic bool mvpp22_rss_is_supported(void)\n{\n\treturn queue_mode == MVPP2_QDIST_MULTI_MODE;\n}\n\nstatic int mvpp2_open(struct net_device *dev)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tstruct mvpp2 *priv = port->priv;\n\tunsigned char mac_bcast[ETH_ALEN] = {\n\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tbool valid = false;\n\tint err;\n\n\terr = mvpp2_prs_mac_da_accept(port, mac_bcast, true);\n\tif (err) {\n\t\tnetdev_err(dev, \"mvpp2_prs_mac_da_accept BC failed\\n\");\n\t\treturn err;\n\t}\n\terr = mvpp2_prs_mac_da_accept(port, dev->dev_addr, true);\n\tif (err) {\n\t\tnetdev_err(dev, \"mvpp2_prs_mac_da_accept own addr failed\\n\");\n\t\treturn err;\n\t}\n\terr = mvpp2_prs_tag_mode_set(port->priv, port->id, MVPP2_TAG_TYPE_MH);\n\tif (err) {\n\t\tnetdev_err(dev, \"mvpp2_prs_tag_mode_set failed\\n\");\n\t\treturn err;\n\t}\n\terr = mvpp2_prs_def_flow(port);\n\tif (err) {\n\t\tnetdev_err(dev, \"mvpp2_prs_def_flow failed\\n\");\n\t\treturn err;\n\t}\n\n\t/* Allocate the Rx/Tx queues */\n\terr = mvpp2_setup_rxqs(port);\n\tif (err) {\n\t\tnetdev_err(port->dev, \"cannot allocate Rx queues\\n\");\n\t\treturn err;\n\t}\n\n\terr = mvpp2_setup_txqs(port);\n\tif (err) {\n\t\tnetdev_err(port->dev, \"cannot allocate Tx queues\\n\");\n\t\tgoto err_cleanup_rxqs;\n\t}\n\n\terr = mvpp2_irqs_init(port);\n\tif (err) {\n\t\tnetdev_err(port->dev, \"cannot init IRQs\\n\");\n\t\tgoto err_cleanup_txqs;\n\t}\n\n\t/* Phylink isn't supported yet in ACPI mode */\n\tif (port->of_node) {\n\t\terr = phylink_of_phy_connect(port->phylink, port->of_node, 0);\n\t\tif (err) {\n\t\t\tnetdev_err(port->dev, \"could not attach PHY (%d)\\n\",\n\t\t\t\t   err);\n\t\t\tgoto err_free_irq;\n\t\t}\n\n\t\tvalid = true;\n\t}\n\n\tif (priv->hw_version == MVPP22 && port->port_irq) {\n\t\terr = request_irq(port->port_irq, mvpp2_port_isr, 0,\n\t\t\t\t  dev->name, port);\n\t\tif (err) {\n\t\t\tnetdev_err(port->dev,\n\t\t\t\t   \"cannot request port link/ptp IRQ %d\\n\",\n\t\t\t\t   port->port_irq);\n\t\t\tgoto err_free_irq;\n\t\t}\n\n\t\tmvpp22_gop_setup_irq(port);\n\n\t\t/* In default link is down */\n\t\tnetif_carrier_off(port->dev);\n\n\t\tvalid = true;\n\t} else {\n\t\tport->port_irq = 0;\n\t}\n\n\tif (!valid) {\n\t\tnetdev_err(port->dev,\n\t\t\t   \"invalid configuration: no dt or link IRQ\");\n\t\tgoto err_free_irq;\n\t}\n\n\t/* Unmask interrupts on all CPUs */\n\ton_each_cpu(mvpp2_interrupts_unmask, port, 1);\n\tmvpp2_shared_interrupt_mask_unmask(port, false);\n\n\tmvpp2_start_dev(port);\n\n\t/* Start hardware statistics gathering */\n\tqueue_delayed_work(priv->stats_queue, &port->stats_work,\n\t\t\t   MVPP2_MIB_COUNTERS_STATS_DELAY);\n\n\treturn 0;\n\nerr_free_irq:\n\tmvpp2_irqs_deinit(port);\nerr_cleanup_txqs:\n\tmvpp2_cleanup_txqs(port);\nerr_cleanup_rxqs:\n\tmvpp2_cleanup_rxqs(port);\n\treturn err;\n}\n\nstatic int mvpp2_stop(struct net_device *dev)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tstruct mvpp2_port_pcpu *port_pcpu;\n\tunsigned int thread;\n\n\tmvpp2_stop_dev(port);\n\n\t/* Mask interrupts on all threads */\n\ton_each_cpu(mvpp2_interrupts_mask, port, 1);\n\tmvpp2_shared_interrupt_mask_unmask(port, true);\n\n\tif (port->phylink)\n\t\tphylink_disconnect_phy(port->phylink);\n\tif (port->port_irq)\n\t\tfree_irq(port->port_irq, port);\n\n\tmvpp2_irqs_deinit(port);\n\tif (!port->has_tx_irqs) {\n\t\tfor (thread = 0; thread < port->priv->nthreads; thread++) {\n\t\t\tport_pcpu = per_cpu_ptr(port->pcpu, thread);\n\n\t\t\thrtimer_cancel(&port_pcpu->tx_done_timer);\n\t\t\tport_pcpu->timer_scheduled = false;\n\t\t}\n\t}\n\tmvpp2_cleanup_rxqs(port);\n\tmvpp2_cleanup_txqs(port);\n\n\tcancel_delayed_work_sync(&port->stats_work);\n\n\tmvpp2_mac_reset_assert(port);\n\tmvpp22_pcs_reset_assert(port);\n\n\treturn 0;\n}\n\nstatic int mvpp2_prs_mac_da_accept_list(struct mvpp2_port *port,\n\t\t\t\t\tstruct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha;\n\tint ret;\n\n\tnetdev_hw_addr_list_for_each(ha, list) {\n\t\tret = mvpp2_prs_mac_da_accept(port, ha->addr, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mvpp2_set_rx_promisc(struct mvpp2_port *port, bool enable)\n{\n\tif (!enable && (port->dev->features & NETIF_F_HW_VLAN_CTAG_FILTER))\n\t\tmvpp2_prs_vid_enable_filtering(port);\n\telse\n\t\tmvpp2_prs_vid_disable_filtering(port);\n\n\tmvpp2_prs_mac_promisc_set(port->priv, port->id,\n\t\t\t\t  MVPP2_PRS_L2_UNI_CAST, enable);\n\n\tmvpp2_prs_mac_promisc_set(port->priv, port->id,\n\t\t\t\t  MVPP2_PRS_L2_MULTI_CAST, enable);\n}\n\nstatic void mvpp2_set_rx_mode(struct net_device *dev)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\t/* Clear the whole UC and MC list */\n\tmvpp2_prs_mac_del_all(port);\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tmvpp2_set_rx_promisc(port, true);\n\t\treturn;\n\t}\n\n\tmvpp2_set_rx_promisc(port, false);\n\n\tif (netdev_uc_count(dev) > MVPP2_PRS_MAC_UC_FILT_MAX ||\n\t    mvpp2_prs_mac_da_accept_list(port, &dev->uc))\n\t\tmvpp2_prs_mac_promisc_set(port->priv, port->id,\n\t\t\t\t\t  MVPP2_PRS_L2_UNI_CAST, true);\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\tmvpp2_prs_mac_promisc_set(port->priv, port->id,\n\t\t\t\t\t  MVPP2_PRS_L2_MULTI_CAST, true);\n\t\treturn;\n\t}\n\n\tif (netdev_mc_count(dev) > MVPP2_PRS_MAC_MC_FILT_MAX ||\n\t    mvpp2_prs_mac_da_accept_list(port, &dev->mc))\n\t\tmvpp2_prs_mac_promisc_set(port->priv, port->id,\n\t\t\t\t\t  MVPP2_PRS_L2_MULTI_CAST, true);\n}\n\nstatic int mvpp2_set_mac_address(struct net_device *dev, void *p)\n{\n\tconst struct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = mvpp2_prs_update_mac_da(dev, addr->sa_data);\n\tif (err) {\n\t\t/* Reconfigure parser accept the original MAC address */\n\t\tmvpp2_prs_update_mac_da(dev, dev->dev_addr);\n\t\tnetdev_err(dev, \"failed to change MAC address\\n\");\n\t}\n\treturn err;\n}\n\n/* Shut down all the ports, reconfigure the pools as percpu or shared,\n * then bring up again all ports.\n */\nstatic int mvpp2_bm_switch_buffers(struct mvpp2 *priv, bool percpu)\n{\n\tint numbufs = MVPP2_BM_POOLS_NUM, i;\n\tstruct mvpp2_port *port = NULL;\n\tbool status[MVPP2_MAX_PORTS];\n\n\tfor (i = 0; i < priv->port_count; i++) {\n\t\tport = priv->port_list[i];\n\t\tstatus[i] = netif_running(port->dev);\n\t\tif (status[i])\n\t\t\tmvpp2_stop(port->dev);\n\t}\n\n\t/* nrxqs is the same for all ports */\n\tif (priv->percpu_pools)\n\t\tnumbufs = port->nrxqs * 2;\n\n\tfor (i = 0; i < numbufs; i++)\n\t\tmvpp2_bm_pool_destroy(port->dev->dev.parent, priv, &priv->bm_pools[i]);\n\n\tdevm_kfree(port->dev->dev.parent, priv->bm_pools);\n\tpriv->percpu_pools = percpu;\n\tmvpp2_bm_init(port->dev->dev.parent, priv);\n\n\tfor (i = 0; i < priv->port_count; i++) {\n\t\tport = priv->port_list[i];\n\t\tmvpp2_swf_bm_pool_init(port);\n\t\tif (status[i])\n\t\t\tmvpp2_open(port->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvpp2_change_mtu(struct net_device *dev, int mtu)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tbool running = netif_running(dev);\n\tstruct mvpp2 *priv = port->priv;\n\tint err;\n\n\tif (!IS_ALIGNED(MVPP2_RX_PKT_SIZE(mtu), 8)) {\n\t\tnetdev_info(dev, \"illegal MTU value %d, round to %d\\n\", mtu,\n\t\t\t    ALIGN(MVPP2_RX_PKT_SIZE(mtu), 8));\n\t\tmtu = ALIGN(MVPP2_RX_PKT_SIZE(mtu), 8);\n\t}\n\n\tif (MVPP2_RX_PKT_SIZE(mtu) > MVPP2_BM_LONG_PKT_SIZE) {\n\t\tif (port->xdp_prog) {\n\t\t\tnetdev_err(dev, \"Jumbo frames are not supported with XDP\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (priv->percpu_pools) {\n\t\t\tnetdev_warn(dev, \"mtu %d too high, switching to shared buffers\", mtu);\n\t\t\tmvpp2_bm_switch_buffers(priv, false);\n\t\t}\n\t} else {\n\t\tbool jumbo = false;\n\t\tint i;\n\n\t\tfor (i = 0; i < priv->port_count; i++)\n\t\t\tif (priv->port_list[i] != port &&\n\t\t\t    MVPP2_RX_PKT_SIZE(priv->port_list[i]->dev->mtu) >\n\t\t\t    MVPP2_BM_LONG_PKT_SIZE) {\n\t\t\t\tjumbo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t/* No port is using jumbo frames */\n\t\tif (!jumbo) {\n\t\t\tdev_info(port->dev->dev.parent,\n\t\t\t\t \"all ports have a low MTU, switching to per-cpu buffers\");\n\t\t\tmvpp2_bm_switch_buffers(priv, true);\n\t\t}\n\t}\n\n\tif (running)\n\t\tmvpp2_stop_dev(port);\n\n\terr = mvpp2_bm_update_mtu(dev, mtu);\n\tif (err) {\n\t\tnetdev_err(dev, \"failed to change MTU\\n\");\n\t\t/* Reconfigure BM to the original MTU */\n\t\tmvpp2_bm_update_mtu(dev, dev->mtu);\n\t} else {\n\t\tport->pkt_size =  MVPP2_RX_PKT_SIZE(mtu);\n\t}\n\n\tif (running) {\n\t\tmvpp2_start_dev(port);\n\t\tmvpp2_egress_enable(port);\n\t\tmvpp2_ingress_enable(port);\n\t}\n\n\treturn err;\n}\n\nstatic int mvpp2_check_pagepool_dma(struct mvpp2_port *port)\n{\n\tenum dma_data_direction dma_dir = DMA_FROM_DEVICE;\n\tstruct mvpp2 *priv = port->priv;\n\tint err = -1, i;\n\n\tif (!priv->percpu_pools)\n\t\treturn err;\n\n\tif (!priv->page_pool[0])\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->port_count; i++) {\n\t\tport = priv->port_list[i];\n\t\tif (port->xdp_prog) {\n\t\t\tdma_dir = DMA_BIDIRECTIONAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* All pools are equal in terms of DMA direction */\n\tif (priv->page_pool[0]->p.dma_dir != dma_dir)\n\t\terr = mvpp2_bm_switch_buffers(priv, true);\n\n\treturn err;\n}\n\nstatic void\nmvpp2_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tunsigned int start;\n\tunsigned int cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct mvpp2_pcpu_stats *cpu_stats;\n\t\tu64 rx_packets;\n\t\tu64 rx_bytes;\n\t\tu64 tx_packets;\n\t\tu64 tx_bytes;\n\n\t\tcpu_stats = per_cpu_ptr(port->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\n\t\t\trx_packets = cpu_stats->rx_packets;\n\t\t\trx_bytes   = cpu_stats->rx_bytes;\n\t\t\ttx_packets = cpu_stats->tx_packets;\n\t\t\ttx_bytes   = cpu_stats->tx_bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));\n\n\t\tstats->rx_packets += rx_packets;\n\t\tstats->rx_bytes   += rx_bytes;\n\t\tstats->tx_packets += tx_packets;\n\t\tstats->tx_bytes   += tx_bytes;\n\t}\n\n\tstats->rx_errors\t= dev->stats.rx_errors;\n\tstats->rx_dropped\t= dev->stats.rx_dropped;\n\tstats->tx_dropped\t= dev->stats.tx_dropped;\n}\n\nstatic int mvpp2_set_ts_config(struct mvpp2_port *port, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\tvoid __iomem *ptp;\n\tu32 gcr, int_mask;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tif (config.flags)\n\t\treturn -EINVAL;\n\n\tif (config.tx_type != HWTSTAMP_TX_OFF &&\n\t    config.tx_type != HWTSTAMP_TX_ON)\n\t\treturn -ERANGE;\n\n\tptp = port->priv->iface_base + MVPP22_PTP_BASE(port->gop_id);\n\n\tint_mask = gcr = 0;\n\tif (config.tx_type != HWTSTAMP_TX_OFF) {\n\t\tgcr |= MVPP22_PTP_GCR_TSU_ENABLE | MVPP22_PTP_GCR_TX_RESET;\n\t\tint_mask |= MVPP22_PTP_INT_MASK_QUEUE1 |\n\t\t\t    MVPP22_PTP_INT_MASK_QUEUE0;\n\t}\n\n\t/* It seems we must also release the TX reset when enabling the TSU */\n\tif (config.rx_filter != HWTSTAMP_FILTER_NONE)\n\t\tgcr |= MVPP22_PTP_GCR_TSU_ENABLE | MVPP22_PTP_GCR_RX_RESET |\n\t\t       MVPP22_PTP_GCR_TX_RESET;\n\n\tif (gcr & MVPP22_PTP_GCR_TSU_ENABLE)\n\t\tmvpp22_tai_start(port->priv->tai);\n\n\tif (config.rx_filter != HWTSTAMP_FILTER_NONE) {\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tmvpp2_modify(ptp + MVPP22_PTP_GCR,\n\t\t\t     MVPP22_PTP_GCR_RX_RESET |\n\t\t\t     MVPP22_PTP_GCR_TX_RESET |\n\t\t\t     MVPP22_PTP_GCR_TSU_ENABLE, gcr);\n\t\tport->rx_hwtstamp = true;\n\t} else {\n\t\tport->rx_hwtstamp = false;\n\t\tmvpp2_modify(ptp + MVPP22_PTP_GCR,\n\t\t\t     MVPP22_PTP_GCR_RX_RESET |\n\t\t\t     MVPP22_PTP_GCR_TX_RESET |\n\t\t\t     MVPP22_PTP_GCR_TSU_ENABLE, gcr);\n\t}\n\n\tmvpp2_modify(ptp + MVPP22_PTP_INT_MASK,\n\t\t     MVPP22_PTP_INT_MASK_QUEUE1 |\n\t\t     MVPP22_PTP_INT_MASK_QUEUE0, int_mask);\n\n\tif (!(gcr & MVPP22_PTP_GCR_TSU_ENABLE))\n\t\tmvpp22_tai_stop(port->priv->tai);\n\n\tport->tx_hwtstamp_type = config.tx_type;\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int mvpp2_get_ts_config(struct mvpp2_port *port, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\n\tmemset(&config, 0, sizeof(config));\n\n\tconfig.tx_type = port->tx_hwtstamp_type;\n\tconfig.rx_filter = port->rx_hwtstamp ?\n\t\tHWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE;\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int mvpp2_ethtool_get_ts_info(struct net_device *dev,\n\t\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (!port->hwtstamp)\n\t\treturn -EOPNOTSUPP;\n\n\tinfo->phc_index = mvpp22_tai_ptp_clock_index(port->priv->tai);\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) |\n\t\t\t BIT(HWTSTAMP_TX_ON);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t   BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic int mvpp2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\tif (port->hwtstamp)\n\t\t\treturn mvpp2_set_ts_config(port, ifr);\n\t\tbreak;\n\n\tcase SIOCGHWTSTAMP:\n\t\tif (port->hwtstamp)\n\t\t\treturn mvpp2_get_ts_config(port, ifr);\n\t\tbreak;\n\t}\n\n\tif (!port->phylink)\n\t\treturn -ENOTSUPP;\n\n\treturn phylink_mii_ioctl(port->phylink, ifr, cmd);\n}\n\nstatic int mvpp2_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret;\n\n\tret = mvpp2_prs_vid_entry_add(port, vid);\n\tif (ret)\n\t\tnetdev_err(dev, \"rx-vlan-filter offloading cannot accept more than %d VIDs per port\\n\",\n\t\t\t   MVPP2_PRS_VLAN_FILT_MAX - 1);\n\treturn ret;\n}\n\nstatic int mvpp2_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tmvpp2_prs_vid_entry_remove(port, vid);\n\treturn 0;\n}\n\nstatic int mvpp2_set_features(struct net_device *dev,\n\t\t\t      netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\tif (features & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\t\tmvpp2_prs_vid_enable_filtering(port);\n\t\t} else {\n\t\t\t/* Invalidate all registered VID filters for this\n\t\t\t * port\n\t\t\t */\n\t\t\tmvpp2_prs_vid_remove_all(port);\n\n\t\t\tmvpp2_prs_vid_disable_filtering(port);\n\t\t}\n\t}\n\n\tif (changed & NETIF_F_RXHASH) {\n\t\tif (features & NETIF_F_RXHASH)\n\t\t\tmvpp22_port_rss_enable(port);\n\t\telse\n\t\t\tmvpp22_port_rss_disable(port);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvpp2_xdp_setup(struct mvpp2_port *port, struct netdev_bpf *bpf)\n{\n\tstruct bpf_prog *prog = bpf->prog, *old_prog;\n\tbool running = netif_running(port->dev);\n\tbool reset = !prog != !port->xdp_prog;\n\n\tif (port->dev->mtu > ETH_DATA_LEN) {\n\t\tNL_SET_ERR_MSG_MOD(bpf->extack, \"XDP is not supported with jumbo frames enabled\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!port->priv->percpu_pools) {\n\t\tNL_SET_ERR_MSG_MOD(bpf->extack, \"Per CPU Pools required for XDP\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (port->ntxqs < num_possible_cpus() * 2) {\n\t\tNL_SET_ERR_MSG_MOD(bpf->extack, \"XDP_TX needs two TX queues per CPU\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* device is up and bpf is added/removed, must setup the RX queues */\n\tif (running && reset)\n\t\tmvpp2_stop(port->dev);\n\n\told_prog = xchg(&port->xdp_prog, prog);\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\t/* bpf is just replaced, RXQ and MTU are already setup */\n\tif (!reset)\n\t\treturn 0;\n\n\t/* device was up, restore the link */\n\tif (running)\n\t\tmvpp2_open(port->dev);\n\n\t/* Check Page Pool DMA Direction */\n\tmvpp2_check_pagepool_dma(port);\n\n\treturn 0;\n}\n\nstatic int mvpp2_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn mvpp2_xdp_setup(port, xdp);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* Ethtool methods */\n\nstatic int mvpp2_ethtool_nway_reset(struct net_device *dev)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (!port->phylink)\n\t\treturn -ENOTSUPP;\n\n\treturn phylink_ethtool_nway_reset(port->phylink);\n}\n\n/* Set interrupt coalescing for ethtools */\nstatic int mvpp2_ethtool_set_coalesce(struct net_device *dev,\n\t\t\t\t      struct ethtool_coalesce *c)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint queue;\n\n\tfor (queue = 0; queue < port->nrxqs; queue++) {\n\t\tstruct mvpp2_rx_queue *rxq = port->rxqs[queue];\n\n\t\trxq->time_coal = c->rx_coalesce_usecs;\n\t\trxq->pkts_coal = c->rx_max_coalesced_frames;\n\t\tmvpp2_rx_pkts_coal_set(port, rxq);\n\t\tmvpp2_rx_time_coal_set(port, rxq);\n\t}\n\n\tif (port->has_tx_irqs) {\n\t\tport->tx_time_coal = c->tx_coalesce_usecs;\n\t\tmvpp2_tx_time_coal_set(port);\n\t}\n\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\tstruct mvpp2_tx_queue *txq = port->txqs[queue];\n\n\t\ttxq->done_pkts_coal = c->tx_max_coalesced_frames;\n\n\t\tif (port->has_tx_irqs)\n\t\t\tmvpp2_tx_pkts_coal_set(port, txq);\n\t}\n\n\treturn 0;\n}\n\n/* get coalescing for ethtools */\nstatic int mvpp2_ethtool_get_coalesce(struct net_device *dev,\n\t\t\t\t      struct ethtool_coalesce *c)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tc->rx_coalesce_usecs       = port->rxqs[0]->time_coal;\n\tc->rx_max_coalesced_frames = port->rxqs[0]->pkts_coal;\n\tc->tx_max_coalesced_frames = port->txqs[0]->done_pkts_coal;\n\tc->tx_coalesce_usecs       = port->tx_time_coal;\n\treturn 0;\n}\n\nstatic void mvpp2_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstrlcpy(drvinfo->driver, MVPP2_DRIVER_NAME,\n\t\tsizeof(drvinfo->driver));\n\tstrlcpy(drvinfo->version, MVPP2_DRIVER_VERSION,\n\t\tsizeof(drvinfo->version));\n\tstrlcpy(drvinfo->bus_info, dev_name(&dev->dev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void mvpp2_ethtool_get_ringparam(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_ringparam *ring)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tring->rx_max_pending = MVPP2_MAX_RXD_MAX;\n\tring->tx_max_pending = MVPP2_MAX_TXD_MAX;\n\tring->rx_pending = port->rx_ring_size;\n\tring->tx_pending = port->tx_ring_size;\n}\n\nstatic int mvpp2_ethtool_set_ringparam(struct net_device *dev,\n\t\t\t\t       struct ethtool_ringparam *ring)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tu16 prev_rx_ring_size = port->rx_ring_size;\n\tu16 prev_tx_ring_size = port->tx_ring_size;\n\tint err;\n\n\terr = mvpp2_check_ringparam_valid(dev, ring);\n\tif (err)\n\t\treturn err;\n\n\tif (!netif_running(dev)) {\n\t\tport->rx_ring_size = ring->rx_pending;\n\t\tport->tx_ring_size = ring->tx_pending;\n\t\treturn 0;\n\t}\n\n\t/* The interface is running, so we have to force a\n\t * reallocation of the queues\n\t */\n\tmvpp2_stop_dev(port);\n\tmvpp2_cleanup_rxqs(port);\n\tmvpp2_cleanup_txqs(port);\n\n\tport->rx_ring_size = ring->rx_pending;\n\tport->tx_ring_size = ring->tx_pending;\n\n\terr = mvpp2_setup_rxqs(port);\n\tif (err) {\n\t\t/* Reallocate Rx queues with the original ring size */\n\t\tport->rx_ring_size = prev_rx_ring_size;\n\t\tring->rx_pending = prev_rx_ring_size;\n\t\terr = mvpp2_setup_rxqs(port);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\terr = mvpp2_setup_txqs(port);\n\tif (err) {\n\t\t/* Reallocate Tx queues with the original ring size */\n\t\tport->tx_ring_size = prev_tx_ring_size;\n\t\tring->tx_pending = prev_tx_ring_size;\n\t\terr = mvpp2_setup_txqs(port);\n\t\tif (err)\n\t\t\tgoto err_clean_rxqs;\n\t}\n\n\tmvpp2_start_dev(port);\n\tmvpp2_egress_enable(port);\n\tmvpp2_ingress_enable(port);\n\n\treturn 0;\n\nerr_clean_rxqs:\n\tmvpp2_cleanup_rxqs(port);\nerr_out:\n\tnetdev_err(dev, \"failed to change ring parameters\");\n\treturn err;\n}\n\nstatic void mvpp2_ethtool_get_pause_param(struct net_device *dev,\n\t\t\t\t\t  struct ethtool_pauseparam *pause)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (!port->phylink)\n\t\treturn;\n\n\tphylink_ethtool_get_pauseparam(port->phylink, pause);\n}\n\nstatic int mvpp2_ethtool_set_pause_param(struct net_device *dev,\n\t\t\t\t\t struct ethtool_pauseparam *pause)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (!port->phylink)\n\t\treturn -ENOTSUPP;\n\n\treturn phylink_ethtool_set_pauseparam(port->phylink, pause);\n}\n\nstatic int mvpp2_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (!port->phylink)\n\t\treturn -ENOTSUPP;\n\n\treturn phylink_ethtool_ksettings_get(port->phylink, cmd);\n}\n\nstatic int mvpp2_ethtool_set_link_ksettings(struct net_device *dev,\n\t\t\t\t\t    const struct ethtool_link_ksettings *cmd)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\n\tif (!port->phylink)\n\t\treturn -ENOTSUPP;\n\n\treturn phylink_ethtool_ksettings_set(port->phylink, cmd);\n}\n\nstatic int mvpp2_ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t   struct ethtool_rxnfc *info, u32 *rules)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret = 0, i, loc = 0;\n\n\tif (!mvpp22_rss_is_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\tret = mvpp2_ethtool_rxfh_get(port, info);\n\t\tbreak;\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = port->nrxqs;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tinfo->rule_cnt = port->n_rfs_rules;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tret = mvpp2_ethtool_cls_rule_get(port, info);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tfor (i = 0; i < MVPP2_N_RFS_ENTRIES_PER_FLOW; i++) {\n\t\t\tif (port->rfs_rules[i])\n\t\t\t\trules[loc++] = i;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int mvpp2_ethtool_set_rxnfc(struct net_device *dev,\n\t\t\t\t   struct ethtool_rxnfc *info)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!mvpp22_rss_is_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tret = mvpp2_ethtool_rxfh_set(port, info);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tret = mvpp2_ethtool_cls_rule_ins(port, info);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\tret = mvpp2_ethtool_cls_rule_del(port, info);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\nstatic u32 mvpp2_ethtool_get_rxfh_indir_size(struct net_device *dev)\n{\n\treturn mvpp22_rss_is_supported() ? MVPP22_RSS_TABLE_ENTRIES : 0;\n}\n\nstatic int mvpp2_ethtool_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,\n\t\t\t\t  u8 *hfunc)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!mvpp22_rss_is_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir)\n\t\tret = mvpp22_port_rss_ctx_indir_get(port, 0, indir);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_CRC32;\n\n\treturn ret;\n}\n\nstatic int mvpp2_ethtool_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t\t  const u8 *key, const u8 hfunc)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!mvpp22_rss_is_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_CRC32)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir)\n\t\tret = mvpp22_port_rss_ctx_indir_set(port, 0, indir);\n\n\treturn ret;\n}\n\nstatic int mvpp2_ethtool_get_rxfh_context(struct net_device *dev, u32 *indir,\n\t\t\t\t\t  u8 *key, u8 *hfunc, u32 rss_context)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!mvpp22_rss_is_supported())\n\t\treturn -EOPNOTSUPP;\n\tif (rss_context >= MVPP22_N_RSS_TABLES)\n\t\treturn -EINVAL;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_CRC32;\n\n\tif (indir)\n\t\tret = mvpp22_port_rss_ctx_indir_get(port, rss_context, indir);\n\n\treturn ret;\n}\n\nstatic int mvpp2_ethtool_set_rxfh_context(struct net_device *dev,\n\t\t\t\t\t  const u32 *indir, const u8 *key,\n\t\t\t\t\t  const u8 hfunc, u32 *rss_context,\n\t\t\t\t\t  bool delete)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tint ret;\n\n\tif (!mvpp22_rss_is_supported())\n\t\treturn -EOPNOTSUPP;\n\n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_CRC32)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (delete)\n\t\treturn mvpp22_port_rss_ctx_delete(port, *rss_context);\n\n\tif (*rss_context == ETH_RXFH_CONTEXT_ALLOC) {\n\t\tret = mvpp22_port_rss_ctx_create(port, rss_context);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn mvpp22_port_rss_ctx_indir_set(port, *rss_context, indir);\n}\n/* Device ops */\n\nstatic const struct net_device_ops mvpp2_netdev_ops = {\n\t.ndo_open\t\t= mvpp2_open,\n\t.ndo_stop\t\t= mvpp2_stop,\n\t.ndo_start_xmit\t\t= mvpp2_tx,\n\t.ndo_set_rx_mode\t= mvpp2_set_rx_mode,\n\t.ndo_set_mac_address\t= mvpp2_set_mac_address,\n\t.ndo_change_mtu\t\t= mvpp2_change_mtu,\n\t.ndo_get_stats64\t= mvpp2_get_stats64,\n\t.ndo_do_ioctl\t\t= mvpp2_ioctl,\n\t.ndo_vlan_rx_add_vid\t= mvpp2_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= mvpp2_vlan_rx_kill_vid,\n\t.ndo_set_features\t= mvpp2_set_features,\n\t.ndo_bpf\t\t= mvpp2_xdp,\n\t.ndo_xdp_xmit\t\t= mvpp2_xdp_xmit,\n};\n\nstatic const struct ethtool_ops mvpp2_eth_tool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.nway_reset\t\t= mvpp2_ethtool_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t= mvpp2_ethtool_get_ts_info,\n\t.set_coalesce\t\t= mvpp2_ethtool_set_coalesce,\n\t.get_coalesce\t\t= mvpp2_ethtool_get_coalesce,\n\t.get_drvinfo\t\t= mvpp2_ethtool_get_drvinfo,\n\t.get_ringparam\t\t= mvpp2_ethtool_get_ringparam,\n\t.set_ringparam\t\t= mvpp2_ethtool_set_ringparam,\n\t.get_strings\t\t= mvpp2_ethtool_get_strings,\n\t.get_ethtool_stats\t= mvpp2_ethtool_get_stats,\n\t.get_sset_count\t\t= mvpp2_ethtool_get_sset_count,\n\t.get_pauseparam\t\t= mvpp2_ethtool_get_pause_param,\n\t.set_pauseparam\t\t= mvpp2_ethtool_set_pause_param,\n\t.get_link_ksettings\t= mvpp2_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= mvpp2_ethtool_set_link_ksettings,\n\t.get_rxnfc\t\t= mvpp2_ethtool_get_rxnfc,\n\t.set_rxnfc\t\t= mvpp2_ethtool_set_rxnfc,\n\t.get_rxfh_indir_size\t= mvpp2_ethtool_get_rxfh_indir_size,\n\t.get_rxfh\t\t= mvpp2_ethtool_get_rxfh,\n\t.set_rxfh\t\t= mvpp2_ethtool_set_rxfh,\n\t.get_rxfh_context\t= mvpp2_ethtool_get_rxfh_context,\n\t.set_rxfh_context\t= mvpp2_ethtool_set_rxfh_context,\n};\n\n/* Used for PPv2.1, or PPv2.2 with the old Device Tree binding that\n * had a single IRQ defined per-port.\n */\nstatic int mvpp2_simple_queue_vectors_init(struct mvpp2_port *port,\n\t\t\t\t\t   struct device_node *port_node)\n{\n\tstruct mvpp2_queue_vector *v = &port->qvecs[0];\n\n\tv->first_rxq = 0;\n\tv->nrxqs = port->nrxqs;\n\tv->type = MVPP2_QUEUE_VECTOR_SHARED;\n\tv->sw_thread_id = 0;\n\tv->sw_thread_mask = *cpumask_bits(cpu_online_mask);\n\tv->port = port;\n\tv->irq = irq_of_parse_and_map(port_node, 0);\n\tif (v->irq <= 0)\n\t\treturn -EINVAL;\n\tnetif_napi_add(port->dev, &v->napi, mvpp2_poll,\n\t\t       NAPI_POLL_WEIGHT);\n\n\tport->nqvecs = 1;\n\n\treturn 0;\n}\n\nstatic int mvpp2_multi_queue_vectors_init(struct mvpp2_port *port,\n\t\t\t\t\t  struct device_node *port_node)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tstruct mvpp2_queue_vector *v;\n\tint i, ret;\n\n\tswitch (queue_mode) {\n\tcase MVPP2_QDIST_SINGLE_MODE:\n\t\tport->nqvecs = priv->nthreads + 1;\n\t\tbreak;\n\tcase MVPP2_QDIST_MULTI_MODE:\n\t\tport->nqvecs = priv->nthreads;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < port->nqvecs; i++) {\n\t\tchar irqname[16];\n\n\t\tv = port->qvecs + i;\n\n\t\tv->port = port;\n\t\tv->type = MVPP2_QUEUE_VECTOR_PRIVATE;\n\t\tv->sw_thread_id = i;\n\t\tv->sw_thread_mask = BIT(i);\n\n\t\tif (port->flags & MVPP2_F_DT_COMPAT)\n\t\t\tsnprintf(irqname, sizeof(irqname), \"tx-cpu%d\", i);\n\t\telse\n\t\t\tsnprintf(irqname, sizeof(irqname), \"hif%d\", i);\n\n\t\tif (queue_mode == MVPP2_QDIST_MULTI_MODE) {\n\t\t\tv->first_rxq = i;\n\t\t\tv->nrxqs = 1;\n\t\t} else if (queue_mode == MVPP2_QDIST_SINGLE_MODE &&\n\t\t\t   i == (port->nqvecs - 1)) {\n\t\t\tv->first_rxq = 0;\n\t\t\tv->nrxqs = port->nrxqs;\n\t\t\tv->type = MVPP2_QUEUE_VECTOR_SHARED;\n\n\t\t\tif (port->flags & MVPP2_F_DT_COMPAT)\n\t\t\t\tstrncpy(irqname, \"rx-shared\", sizeof(irqname));\n\t\t}\n\n\t\tif (port_node)\n\t\t\tv->irq = of_irq_get_byname(port_node, irqname);\n\t\telse\n\t\t\tv->irq = fwnode_irq_get(port->fwnode, i);\n\t\tif (v->irq <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tnetif_napi_add(port->dev, &v->napi, mvpp2_poll,\n\t\t\t       NAPI_POLL_WEIGHT);\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < port->nqvecs; i++)\n\t\tirq_dispose_mapping(port->qvecs[i].irq);\n\treturn ret;\n}\n\nstatic int mvpp2_queue_vectors_init(struct mvpp2_port *port,\n\t\t\t\t    struct device_node *port_node)\n{\n\tif (port->has_tx_irqs)\n\t\treturn mvpp2_multi_queue_vectors_init(port, port_node);\n\telse\n\t\treturn mvpp2_simple_queue_vectors_init(port, port_node);\n}\n\nstatic void mvpp2_queue_vectors_deinit(struct mvpp2_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->nqvecs; i++)\n\t\tirq_dispose_mapping(port->qvecs[i].irq);\n}\n\n/* Configure Rx queue group interrupt for this port */\nstatic void mvpp2_rx_irqs_setup(struct mvpp2_port *port)\n{\n\tstruct mvpp2 *priv = port->priv;\n\tu32 val;\n\tint i;\n\n\tif (priv->hw_version == MVPP21) {\n\t\tmvpp2_write(priv, MVPP21_ISR_RXQ_GROUP_REG(port->id),\n\t\t\t    port->nrxqs);\n\t\treturn;\n\t}\n\n\t/* Handle the more complicated PPv2.2 case */\n\tfor (i = 0; i < port->nqvecs; i++) {\n\t\tstruct mvpp2_queue_vector *qv = port->qvecs + i;\n\n\t\tif (!qv->nrxqs)\n\t\t\tcontinue;\n\n\t\tval = qv->sw_thread_id;\n\t\tval |= port->id << MVPP22_ISR_RXQ_GROUP_INDEX_GROUP_OFFSET;\n\t\tmvpp2_write(priv, MVPP22_ISR_RXQ_GROUP_INDEX_REG, val);\n\n\t\tval = qv->first_rxq;\n\t\tval |= qv->nrxqs << MVPP22_ISR_RXQ_SUB_GROUP_SIZE_OFFSET;\n\t\tmvpp2_write(priv, MVPP22_ISR_RXQ_SUB_GROUP_CONFIG_REG, val);\n\t}\n}\n\n/* Initialize port HW */\nstatic int mvpp2_port_init(struct mvpp2_port *port)\n{\n\tstruct device *dev = port->dev->dev.parent;\n\tstruct mvpp2 *priv = port->priv;\n\tstruct mvpp2_txq_pcpu *txq_pcpu;\n\tunsigned int thread;\n\tint queue, err;\n\n\t/* Checks for hardware constraints */\n\tif (port->first_rxq + port->nrxqs >\n\t    MVPP2_MAX_PORTS * priv->max_port_rxqs)\n\t\treturn -EINVAL;\n\n\tif (port->nrxqs > priv->max_port_rxqs || port->ntxqs > MVPP2_MAX_TXQ)\n\t\treturn -EINVAL;\n\n\t/* Disable port */\n\tmvpp2_egress_disable(port);\n\tmvpp2_port_disable(port);\n\n\tport->tx_time_coal = MVPP2_TXDONE_COAL_USEC;\n\n\tport->txqs = devm_kcalloc(dev, port->ntxqs, sizeof(*port->txqs),\n\t\t\t\t  GFP_KERNEL);\n\tif (!port->txqs)\n\t\treturn -ENOMEM;\n\n\t/* Associate physical Tx queues to this port and initialize.\n\t * The mapping is predefined.\n\t */\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\tint queue_phy_id = mvpp2_txq_phys(port->id, queue);\n\t\tstruct mvpp2_tx_queue *txq;\n\n\t\ttxq = devm_kzalloc(dev, sizeof(*txq), GFP_KERNEL);\n\t\tif (!txq) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_percpu;\n\t\t}\n\n\t\ttxq->pcpu = alloc_percpu(struct mvpp2_txq_pcpu);\n\t\tif (!txq->pcpu) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_percpu;\n\t\t}\n\n\t\ttxq->id = queue_phy_id;\n\t\ttxq->log_id = queue;\n\t\ttxq->done_pkts_coal = MVPP2_TXDONE_COAL_PKTS_THRESH;\n\t\tfor (thread = 0; thread < priv->nthreads; thread++) {\n\t\t\ttxq_pcpu = per_cpu_ptr(txq->pcpu, thread);\n\t\t\ttxq_pcpu->thread = thread;\n\t\t}\n\n\t\tport->txqs[queue] = txq;\n\t}\n\n\tport->rxqs = devm_kcalloc(dev, port->nrxqs, sizeof(*port->rxqs),\n\t\t\t\t  GFP_KERNEL);\n\tif (!port->rxqs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_percpu;\n\t}\n\n\t/* Allocate and initialize Rx queue for this port */\n\tfor (queue = 0; queue < port->nrxqs; queue++) {\n\t\tstruct mvpp2_rx_queue *rxq;\n\n\t\t/* Map physical Rx queue to port's logical Rx queue */\n\t\trxq = devm_kzalloc(dev, sizeof(*rxq), GFP_KERNEL);\n\t\tif (!rxq) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_percpu;\n\t\t}\n\t\t/* Map this Rx queue to a physical queue */\n\t\trxq->id = port->first_rxq + queue;\n\t\trxq->port = port->id;\n\t\trxq->logic_rxq = queue;\n\n\t\tport->rxqs[queue] = rxq;\n\t}\n\n\tmvpp2_rx_irqs_setup(port);\n\n\t/* Create Rx descriptor rings */\n\tfor (queue = 0; queue < port->nrxqs; queue++) {\n\t\tstruct mvpp2_rx_queue *rxq = port->rxqs[queue];\n\n\t\trxq->size = port->rx_ring_size;\n\t\trxq->pkts_coal = MVPP2_RX_COAL_PKTS;\n\t\trxq->time_coal = MVPP2_RX_COAL_USEC;\n\t}\n\n\tmvpp2_ingress_disable(port);\n\n\t/* Port default configuration */\n\tmvpp2_defaults_set(port);\n\n\t/* Port's classifier configuration */\n\tmvpp2_cls_oversize_rxq_set(port);\n\tmvpp2_cls_port_config(port);\n\n\tif (mvpp22_rss_is_supported())\n\t\tmvpp22_port_rss_init(port);\n\n\t/* Provide an initial Rx packet size */\n\tport->pkt_size = MVPP2_RX_PKT_SIZE(port->dev->mtu);\n\n\t/* Initialize pools for swf */\n\terr = mvpp2_swf_bm_pool_init(port);\n\tif (err)\n\t\tgoto err_free_percpu;\n\n\t/* Clear all port stats */\n\tmvpp2_read_stats(port);\n\tmemset(port->ethtool_stats, 0,\n\t       MVPP2_N_ETHTOOL_STATS(port->ntxqs, port->nrxqs) * sizeof(u64));\n\n\treturn 0;\n\nerr_free_percpu:\n\tfor (queue = 0; queue < port->ntxqs; queue++) {\n\t\tif (!port->txqs[queue])\n\t\t\tcontinue;\n\t\tfree_percpu(port->txqs[queue]->pcpu);\n\t}\n\treturn err;\n}\n\nstatic bool mvpp22_port_has_legacy_tx_irqs(struct device_node *port_node,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tchar *irqs[5] = { \"rx-shared\", \"tx-cpu0\", \"tx-cpu1\", \"tx-cpu2\",\n\t\t\t  \"tx-cpu3\" };\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\tif (of_property_match_string(port_node, \"interrupt-names\",\n\t\t\t\t\t     irqs[i]) < 0)\n\t\t\treturn false;\n\n\t*flags |= MVPP2_F_DT_COMPAT;\n\treturn true;\n}\n\n/* Checks if the port dt description has the required Tx interrupts:\n * - PPv2.1: there are no such interrupts.\n * - PPv2.2:\n *   - The old DTs have: \"rx-shared\", \"tx-cpuX\" with X in [0...3]\n *   - The new ones have: \"hifX\" with X in [0..8]\n *\n * All those variants are supported to keep the backward compatibility.\n */\nstatic bool mvpp2_port_has_irqs(struct mvpp2 *priv,\n\t\t\t\tstruct device_node *port_node,\n\t\t\t\tunsigned long *flags)\n{\n\tchar name[5];\n\tint i;\n\n\t/* ACPI */\n\tif (!port_node)\n\t\treturn true;\n\n\tif (priv->hw_version == MVPP21)\n\t\treturn false;\n\n\tif (mvpp22_port_has_legacy_tx_irqs(port_node, flags))\n\t\treturn true;\n\n\tfor (i = 0; i < MVPP2_MAX_THREADS; i++) {\n\t\tsnprintf(name, 5, \"hif%d\", i);\n\t\tif (of_property_match_string(port_node, \"interrupt-names\",\n\t\t\t\t\t     name) < 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void mvpp2_port_copy_mac_addr(struct net_device *dev, struct mvpp2 *priv,\n\t\t\t\t     struct fwnode_handle *fwnode,\n\t\t\t\t     char **mac_from)\n{\n\tstruct mvpp2_port *port = netdev_priv(dev);\n\tchar hw_mac_addr[ETH_ALEN] = {0};\n\tchar fw_mac_addr[ETH_ALEN];\n\n\tif (fwnode_get_mac_address(fwnode, fw_mac_addr, ETH_ALEN)) {\n\t\t*mac_from = \"firmware node\";\n\t\tether_addr_copy(dev->dev_addr, fw_mac_addr);\n\t\treturn;\n\t}\n\n\tif (priv->hw_version == MVPP21) {\n\t\tmvpp21_get_mac_address(port, hw_mac_addr);\n\t\tif (is_valid_ether_addr(hw_mac_addr)) {\n\t\t\t*mac_from = \"hardware\";\n\t\t\tether_addr_copy(dev->dev_addr, hw_mac_addr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t*mac_from = \"random\";\n\teth_hw_addr_random(dev);\n}\n\nstatic struct mvpp2_port *mvpp2_phylink_to_port(struct phylink_config *config)\n{\n\treturn container_of(config, struct mvpp2_port, phylink_config);\n}\n\nstatic struct mvpp2_port *mvpp2_pcs_to_port(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct mvpp2_port, phylink_pcs);\n}\n\nstatic void mvpp2_xlg_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t    struct phylink_link_state *state)\n{\n\tstruct mvpp2_port *port = mvpp2_pcs_to_port(pcs);\n\tu32 val;\n\n\tstate->speed = SPEED_10000;\n\tstate->duplex = 1;\n\tstate->an_complete = 1;\n\n\tval = readl(port->base + MVPP22_XLG_STATUS);\n\tstate->link = !!(val & MVPP22_XLG_STATUS_LINK_UP);\n\n\tstate->pause = 0;\n\tval = readl(port->base + MVPP22_XLG_CTRL0_REG);\n\tif (val & MVPP22_XLG_CTRL0_TX_FLOW_CTRL_EN)\n\t\tstate->pause |= MLO_PAUSE_TX;\n\tif (val & MVPP22_XLG_CTRL0_RX_FLOW_CTRL_EN)\n\t\tstate->pause |= MLO_PAUSE_RX;\n}\n\nstatic int mvpp2_xlg_pcs_config(struct phylink_pcs *pcs,\n\t\t\t\tunsigned int mode,\n\t\t\t\tphy_interface_t interface,\n\t\t\t\tconst unsigned long *advertising,\n\t\t\t\tbool permit_pause_to_mac)\n{\n\treturn 0;\n}\n\nstatic const struct phylink_pcs_ops mvpp2_phylink_xlg_pcs_ops = {\n\t.pcs_get_state = mvpp2_xlg_pcs_get_state,\n\t.pcs_config = mvpp2_xlg_pcs_config,\n};\n\nstatic void mvpp2_gmac_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t     struct phylink_link_state *state)\n{\n\tstruct mvpp2_port *port = mvpp2_pcs_to_port(pcs);\n\tu32 val;\n\n\tval = readl(port->base + MVPP2_GMAC_STATUS0);\n\n\tstate->an_complete = !!(val & MVPP2_GMAC_STATUS0_AN_COMPLETE);\n\tstate->link = !!(val & MVPP2_GMAC_STATUS0_LINK_UP);\n\tstate->duplex = !!(val & MVPP2_GMAC_STATUS0_FULL_DUPLEX);\n\n\tswitch (port->phy_interface) {\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tstate->speed = SPEED_2500;\n\t\tbreak;\n\tdefault:\n\t\tif (val & MVPP2_GMAC_STATUS0_GMII_SPEED)\n\t\t\tstate->speed = SPEED_1000;\n\t\telse if (val & MVPP2_GMAC_STATUS0_MII_SPEED)\n\t\t\tstate->speed = SPEED_100;\n\t\telse\n\t\t\tstate->speed = SPEED_10;\n\t}\n\n\tstate->pause = 0;\n\tif (val & MVPP2_GMAC_STATUS0_RX_PAUSE)\n\t\tstate->pause |= MLO_PAUSE_RX;\n\tif (val & MVPP2_GMAC_STATUS0_TX_PAUSE)\n\t\tstate->pause |= MLO_PAUSE_TX;\n}\n\nstatic int mvpp2_gmac_pcs_config(struct phylink_pcs *pcs, unsigned int mode,\n\t\t\t\t phy_interface_t interface,\n\t\t\t\t const unsigned long *advertising,\n\t\t\t\t bool permit_pause_to_mac)\n{\n\tstruct mvpp2_port *port = mvpp2_pcs_to_port(pcs);\n\tu32 mask, val, an, old_an, changed;\n\n\tmask = MVPP2_GMAC_IN_BAND_AUTONEG_BYPASS |\n\t       MVPP2_GMAC_IN_BAND_AUTONEG |\n\t       MVPP2_GMAC_AN_SPEED_EN |\n\t       MVPP2_GMAC_FLOW_CTRL_AUTONEG |\n\t       MVPP2_GMAC_AN_DUPLEX_EN;\n\n\tif (phylink_autoneg_inband(mode)) {\n\t\tmask |= MVPP2_GMAC_CONFIG_MII_SPEED |\n\t\t\tMVPP2_GMAC_CONFIG_GMII_SPEED |\n\t\t\tMVPP2_GMAC_CONFIG_FULL_DUPLEX;\n\t\tval = MVPP2_GMAC_IN_BAND_AUTONEG;\n\n\t\tif (interface == PHY_INTERFACE_MODE_SGMII) {\n\t\t\t/* SGMII mode receives the speed and duplex from PHY */\n\t\t\tval |= MVPP2_GMAC_AN_SPEED_EN |\n\t\t\t       MVPP2_GMAC_AN_DUPLEX_EN;\n\t\t} else {\n\t\t\t/* 802.3z mode has fixed speed and duplex */\n\t\t\tval |= MVPP2_GMAC_CONFIG_GMII_SPEED |\n\t\t\t       MVPP2_GMAC_CONFIG_FULL_DUPLEX;\n\n\t\t\t/* The FLOW_CTRL_AUTONEG bit selects either the hardware\n\t\t\t * automatically or the bits in MVPP22_GMAC_CTRL_4_REG\n\t\t\t * manually controls the GMAC pause modes.\n\t\t\t */\n\t\t\tif (permit_pause_to_mac)\n\t\t\t\tval |= MVPP2_GMAC_FLOW_CTRL_AUTONEG;\n\n\t\t\t/* Configure advertisement bits */\n\t\t\tmask |= MVPP2_GMAC_FC_ADV_EN | MVPP2_GMAC_FC_ADV_ASM_EN;\n\t\t\tif (phylink_test(advertising, Pause))\n\t\t\t\tval |= MVPP2_GMAC_FC_ADV_EN;\n\t\t\tif (phylink_test(advertising, Asym_Pause))\n\t\t\t\tval |= MVPP2_GMAC_FC_ADV_ASM_EN;\n\t\t}\n\t} else {\n\t\tval = 0;\n\t}\n\n\told_an = an = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n\tan = (an & ~mask) | val;\n\tchanged = an ^ old_an;\n\tif (changed)\n\t\twritel(an, port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n\n\t/* We are only interested in the advertisement bits changing */\n\treturn changed & (MVPP2_GMAC_FC_ADV_EN | MVPP2_GMAC_FC_ADV_ASM_EN);\n}\n\nstatic void mvpp2_gmac_pcs_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct mvpp2_port *port = mvpp2_pcs_to_port(pcs);\n\tu32 val = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n\n\twritel(val | MVPP2_GMAC_IN_BAND_RESTART_AN,\n\t       port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n\twritel(val & ~MVPP2_GMAC_IN_BAND_RESTART_AN,\n\t       port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n}\n\nstatic const struct phylink_pcs_ops mvpp2_phylink_gmac_pcs_ops = {\n\t.pcs_get_state = mvpp2_gmac_pcs_get_state,\n\t.pcs_config = mvpp2_gmac_pcs_config,\n\t.pcs_an_restart = mvpp2_gmac_pcs_an_restart,\n};\n\nstatic void mvpp2_phylink_validate(struct phylink_config *config,\n\t\t\t\t   unsigned long *supported,\n\t\t\t\t   struct phylink_link_state *state)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };\n\n\t/* Invalid combinations */\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\t\tif (!mvpp2_port_supports_xlg(port))\n\t\t\tgoto empty_set;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tif (!mvpp2_port_supports_rgmii(port))\n\t\t\tgoto empty_set;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tphylink_set(mask, Autoneg);\n\tphylink_set_port_modes(mask);\n\tphylink_set(mask, Pause);\n\tphylink_set(mask, Asym_Pause);\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_NA:\n\t\tif (mvpp2_port_supports_xlg(port)) {\n\t\t\tphylink_set(mask, 10000baseT_Full);\n\t\t\tphylink_set(mask, 10000baseCR_Full);\n\t\t\tphylink_set(mask, 10000baseSR_Full);\n\t\t\tphylink_set(mask, 10000baseLR_Full);\n\t\t\tphylink_set(mask, 10000baseLRM_Full);\n\t\t\tphylink_set(mask, 10000baseER_Full);\n\t\t\tphylink_set(mask, 10000baseKR_Full);\n\t\t}\n\t\tif (state->interface != PHY_INTERFACE_MODE_NA)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tphylink_set(mask, 10baseT_Half);\n\t\tphylink_set(mask, 10baseT_Full);\n\t\tphylink_set(mask, 100baseT_Half);\n\t\tphylink_set(mask, 100baseT_Full);\n\t\tphylink_set(mask, 1000baseT_Full);\n\t\tphylink_set(mask, 1000baseX_Full);\n\t\tif (state->interface != PHY_INTERFACE_MODE_NA)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tif (port->comphy ||\n\t\t    state->interface != PHY_INTERFACE_MODE_2500BASEX) {\n\t\t\tphylink_set(mask, 1000baseT_Full);\n\t\t\tphylink_set(mask, 1000baseX_Full);\n\t\t}\n\t\tif (port->comphy ||\n\t\t    state->interface == PHY_INTERFACE_MODE_2500BASEX) {\n\t\t\tphylink_set(mask, 2500baseT_Full);\n\t\t\tphylink_set(mask, 2500baseX_Full);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto empty_set;\n\t}\n\n\tbitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tbitmap_and(state->advertising, state->advertising, mask,\n\t\t   __ETHTOOL_LINK_MODE_MASK_NBITS);\n\n\tphylink_helper_basex_speed(state);\n\treturn;\n\nempty_set:\n\tbitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);\n}\n\nstatic void mvpp2_xlg_config(struct mvpp2_port *port, unsigned int mode,\n\t\t\t     const struct phylink_link_state *state)\n{\n\tu32 val;\n\n\tmvpp2_modify(port->base + MVPP22_XLG_CTRL0_REG,\n\t\t     MVPP22_XLG_CTRL0_MAC_RESET_DIS,\n\t\t     MVPP22_XLG_CTRL0_MAC_RESET_DIS);\n\tmvpp2_modify(port->base + MVPP22_XLG_CTRL4_REG,\n\t\t     MVPP22_XLG_CTRL4_MACMODSELECT_GMAC |\n\t\t     MVPP22_XLG_CTRL4_EN_IDLE_CHECK |\n\t\t     MVPP22_XLG_CTRL4_FWD_FC | MVPP22_XLG_CTRL4_FWD_PFC,\n\t\t     MVPP22_XLG_CTRL4_FWD_FC | MVPP22_XLG_CTRL4_FWD_PFC);\n\n\t/* Wait for reset to deassert */\n\tdo {\n\t\tval = readl(port->base + MVPP22_XLG_CTRL0_REG);\n\t} while (!(val & MVPP22_XLG_CTRL0_MAC_RESET_DIS));\n}\n\nstatic void mvpp2_gmac_config(struct mvpp2_port *port, unsigned int mode,\n\t\t\t      const struct phylink_link_state *state)\n{\n\tu32 old_ctrl0, ctrl0;\n\tu32 old_ctrl2, ctrl2;\n\tu32 old_ctrl4, ctrl4;\n\n\told_ctrl0 = ctrl0 = readl(port->base + MVPP2_GMAC_CTRL_0_REG);\n\told_ctrl2 = ctrl2 = readl(port->base + MVPP2_GMAC_CTRL_2_REG);\n\told_ctrl4 = ctrl4 = readl(port->base + MVPP22_GMAC_CTRL_4_REG);\n\n\tctrl0 &= ~MVPP2_GMAC_PORT_TYPE_MASK;\n\tctrl2 &= ~(MVPP2_GMAC_INBAND_AN_MASK | MVPP2_GMAC_PCS_ENABLE_MASK);\n\n\t/* Configure port type */\n\tif (phy_interface_mode_is_8023z(state->interface)) {\n\t\tctrl2 |= MVPP2_GMAC_PCS_ENABLE_MASK;\n\t\tctrl4 &= ~MVPP22_CTRL4_EXT_PIN_GMII_SEL;\n\t\tctrl4 |= MVPP22_CTRL4_SYNC_BYPASS_DIS |\n\t\t\t MVPP22_CTRL4_DP_CLK_SEL |\n\t\t\t MVPP22_CTRL4_QSGMII_BYPASS_ACTIVE;\n\t} else if (state->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tctrl2 |= MVPP2_GMAC_PCS_ENABLE_MASK | MVPP2_GMAC_INBAND_AN_MASK;\n\t\tctrl4 &= ~MVPP22_CTRL4_EXT_PIN_GMII_SEL;\n\t\tctrl4 |= MVPP22_CTRL4_SYNC_BYPASS_DIS |\n\t\t\t MVPP22_CTRL4_DP_CLK_SEL |\n\t\t\t MVPP22_CTRL4_QSGMII_BYPASS_ACTIVE;\n\t} else if (phy_interface_mode_is_rgmii(state->interface)) {\n\t\tctrl4 &= ~MVPP22_CTRL4_DP_CLK_SEL;\n\t\tctrl4 |= MVPP22_CTRL4_EXT_PIN_GMII_SEL |\n\t\t\t MVPP22_CTRL4_SYNC_BYPASS_DIS |\n\t\t\t MVPP22_CTRL4_QSGMII_BYPASS_ACTIVE;\n\t}\n\n\t/* Configure negotiation style */\n\tif (!phylink_autoneg_inband(mode)) {\n\t\t/* Phy or fixed speed - no in-band AN, nothing to do, leave the\n\t\t * configured speed, duplex and flow control as-is.\n\t\t */\n\t} else if (state->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\t/* SGMII in-band mode receives the speed and duplex from\n\t\t * the PHY. Flow control information is not received. */\n\t} else if (phy_interface_mode_is_8023z(state->interface)) {\n\t\t/* 1000BaseX and 2500BaseX ports cannot negotiate speed nor can\n\t\t * they negotiate duplex: they are always operating with a fixed\n\t\t * speed of 1000/2500Mbps in full duplex, so force 1000/2500\n\t\t * speed and full duplex here.\n\t\t */\n\t\tctrl0 |= MVPP2_GMAC_PORT_TYPE_MASK;\n\t}\n\n\tif (old_ctrl0 != ctrl0)\n\t\twritel(ctrl0, port->base + MVPP2_GMAC_CTRL_0_REG);\n\tif (old_ctrl2 != ctrl2)\n\t\twritel(ctrl2, port->base + MVPP2_GMAC_CTRL_2_REG);\n\tif (old_ctrl4 != ctrl4)\n\t\twritel(ctrl4, port->base + MVPP22_GMAC_CTRL_4_REG);\n}\n\nstatic int mvpp2__mac_prepare(struct phylink_config *config, unsigned int mode,\n\t\t\t      phy_interface_t interface)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\n\t/* Check for invalid configuration */\n\tif (mvpp2_is_xlg(interface) && port->gop_id != 0) {\n\t\tnetdev_err(port->dev, \"Invalid mode on %s\\n\", port->dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (port->phy_interface != interface ||\n\t    phylink_autoneg_inband(mode)) {\n\t\t/* Force the link down when changing the interface or if in\n\t\t * in-band mode to ensure we do not change the configuration\n\t\t * while the hardware is indicating link is up. We force both\n\t\t * XLG and GMAC down to ensure that they're both in a known\n\t\t * state.\n\t\t */\n\t\tmvpp2_modify(port->base + MVPP2_GMAC_AUTONEG_CONFIG,\n\t\t\t     MVPP2_GMAC_FORCE_LINK_PASS |\n\t\t\t     MVPP2_GMAC_FORCE_LINK_DOWN,\n\t\t\t     MVPP2_GMAC_FORCE_LINK_DOWN);\n\n\t\tif (mvpp2_port_supports_xlg(port))\n\t\t\tmvpp2_modify(port->base + MVPP22_XLG_CTRL0_REG,\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_PASS |\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_DOWN,\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_DOWN);\n\t}\n\n\t/* Make sure the port is disabled when reconfiguring the mode */\n\tmvpp2_port_disable(port);\n\n\tif (port->phy_interface != interface) {\n\t\t/* Place GMAC into reset */\n\t\tmvpp2_modify(port->base + MVPP2_GMAC_CTRL_2_REG,\n\t\t\t     MVPP2_GMAC_PORT_RESET_MASK,\n\t\t\t     MVPP2_GMAC_PORT_RESET_MASK);\n\n\t\tif (port->priv->hw_version == MVPP22) {\n\t\t\tmvpp22_gop_mask_irq(port);\n\n\t\t\tphy_power_off(port->comphy);\n\t\t}\n\t}\n\n\t/* Select the appropriate PCS operations depending on the\n\t * configured interface mode. We will only switch to a mode\n\t * that the validate() checks have already passed.\n\t */\n\tif (mvpp2_is_xlg(interface))\n\t\tport->phylink_pcs.ops = &mvpp2_phylink_xlg_pcs_ops;\n\telse\n\t\tport->phylink_pcs.ops = &mvpp2_phylink_gmac_pcs_ops;\n\n\treturn 0;\n}\n\nstatic int mvpp2_mac_prepare(struct phylink_config *config, unsigned int mode,\n\t\t\t     phy_interface_t interface)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\tint ret;\n\n\tret = mvpp2__mac_prepare(config, mode, interface);\n\tif (ret == 0)\n\t\tphylink_set_pcs(port->phylink, &port->phylink_pcs);\n\n\treturn ret;\n}\n\nstatic void mvpp2_mac_config(struct phylink_config *config, unsigned int mode,\n\t\t\t     const struct phylink_link_state *state)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\n\t/* mac (re)configuration */\n\tif (mvpp2_is_xlg(state->interface))\n\t\tmvpp2_xlg_config(port, mode, state);\n\telse if (phy_interface_mode_is_rgmii(state->interface) ||\n\t\t phy_interface_mode_is_8023z(state->interface) ||\n\t\t state->interface == PHY_INTERFACE_MODE_SGMII)\n\t\tmvpp2_gmac_config(port, mode, state);\n\n\tif (port->priv->hw_version == MVPP21 && port->flags & MVPP2_F_LOOPBACK)\n\t\tmvpp2_port_loopback_set(port, state);\n}\n\nstatic int mvpp2_mac_finish(struct phylink_config *config, unsigned int mode,\n\t\t\t    phy_interface_t interface)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\n\tif (port->priv->hw_version == MVPP22 &&\n\t    port->phy_interface != interface) {\n\t\tport->phy_interface = interface;\n\n\t\t/* Reconfigure the serdes lanes */\n\t\tmvpp22_mode_reconfigure(port);\n\n\t\t/* Unmask interrupts */\n\t\tmvpp22_gop_unmask_irq(port);\n\t}\n\n\tif (!mvpp2_is_xlg(interface)) {\n\t\t/* Release GMAC reset and wait */\n\t\tmvpp2_modify(port->base + MVPP2_GMAC_CTRL_2_REG,\n\t\t\t     MVPP2_GMAC_PORT_RESET_MASK, 0);\n\n\t\twhile (readl(port->base + MVPP2_GMAC_CTRL_2_REG) &\n\t\t       MVPP2_GMAC_PORT_RESET_MASK)\n\t\t\tcontinue;\n\t}\n\n\tmvpp2_port_enable(port);\n\n\t/* Allow the link to come up if in in-band mode, otherwise the\n\t * link is forced via mac_link_down()/mac_link_up()\n\t */\n\tif (phylink_autoneg_inband(mode)) {\n\t\tif (mvpp2_is_xlg(interface))\n\t\t\tmvpp2_modify(port->base + MVPP22_XLG_CTRL0_REG,\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_PASS |\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_DOWN, 0);\n\t\telse\n\t\t\tmvpp2_modify(port->base + MVPP2_GMAC_AUTONEG_CONFIG,\n\t\t\t\t     MVPP2_GMAC_FORCE_LINK_PASS |\n\t\t\t\t     MVPP2_GMAC_FORCE_LINK_DOWN, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void mvpp2_mac_link_up(struct phylink_config *config,\n\t\t\t      struct phy_device *phy,\n\t\t\t      unsigned int mode, phy_interface_t interface,\n\t\t\t      int speed, int duplex,\n\t\t\t      bool tx_pause, bool rx_pause)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\tu32 val;\n\n\tif (mvpp2_is_xlg(interface)) {\n\t\tif (!phylink_autoneg_inband(mode)) {\n\t\t\tval = MVPP22_XLG_CTRL0_FORCE_LINK_PASS;\n\t\t\tif (tx_pause)\n\t\t\t\tval |= MVPP22_XLG_CTRL0_TX_FLOW_CTRL_EN;\n\t\t\tif (rx_pause)\n\t\t\t\tval |= MVPP22_XLG_CTRL0_RX_FLOW_CTRL_EN;\n\n\t\t\tmvpp2_modify(port->base + MVPP22_XLG_CTRL0_REG,\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_DOWN |\n\t\t\t\t     MVPP22_XLG_CTRL0_FORCE_LINK_PASS |\n\t\t\t\t     MVPP22_XLG_CTRL0_TX_FLOW_CTRL_EN |\n\t\t\t\t     MVPP22_XLG_CTRL0_RX_FLOW_CTRL_EN, val);\n\t\t}\n\t} else {\n\t\tif (!phylink_autoneg_inband(mode)) {\n\t\t\tval = MVPP2_GMAC_FORCE_LINK_PASS;\n\n\t\t\tif (speed == SPEED_1000 || speed == SPEED_2500)\n\t\t\t\tval |= MVPP2_GMAC_CONFIG_GMII_SPEED;\n\t\t\telse if (speed == SPEED_100)\n\t\t\t\tval |= MVPP2_GMAC_CONFIG_MII_SPEED;\n\n\t\t\tif (duplex == DUPLEX_FULL)\n\t\t\t\tval |= MVPP2_GMAC_CONFIG_FULL_DUPLEX;\n\n\t\t\tmvpp2_modify(port->base + MVPP2_GMAC_AUTONEG_CONFIG,\n\t\t\t\t     MVPP2_GMAC_FORCE_LINK_DOWN |\n\t\t\t\t     MVPP2_GMAC_FORCE_LINK_PASS |\n\t\t\t\t     MVPP2_GMAC_CONFIG_MII_SPEED |\n\t\t\t\t     MVPP2_GMAC_CONFIG_GMII_SPEED |\n\t\t\t\t     MVPP2_GMAC_CONFIG_FULL_DUPLEX, val);\n\t\t}\n\n\t\t/* We can always update the flow control enable bits;\n\t\t * these will only be effective if flow control AN\n\t\t * (MVPP2_GMAC_FLOW_CTRL_AUTONEG) is disabled.\n\t\t */\n\t\tval = 0;\n\t\tif (tx_pause)\n\t\t\tval |= MVPP22_CTRL4_TX_FC_EN;\n\t\tif (rx_pause)\n\t\t\tval |= MVPP22_CTRL4_RX_FC_EN;\n\n\t\tmvpp2_modify(port->base + MVPP22_GMAC_CTRL_4_REG,\n\t\t\t     MVPP22_CTRL4_RX_FC_EN | MVPP22_CTRL4_TX_FC_EN,\n\t\t\t     val);\n\t}\n\n\tmvpp2_port_enable(port);\n\n\tmvpp2_egress_enable(port);\n\tmvpp2_ingress_enable(port);\n\tnetif_tx_wake_all_queues(port->dev);\n}\n\nstatic void mvpp2_mac_link_down(struct phylink_config *config,\n\t\t\t\tunsigned int mode, phy_interface_t interface)\n{\n\tstruct mvpp2_port *port = mvpp2_phylink_to_port(config);\n\tu32 val;\n\n\tif (!phylink_autoneg_inband(mode)) {\n\t\tif (mvpp2_is_xlg(interface)) {\n\t\t\tval = readl(port->base + MVPP22_XLG_CTRL0_REG);\n\t\t\tval &= ~MVPP22_XLG_CTRL0_FORCE_LINK_PASS;\n\t\t\tval |= MVPP22_XLG_CTRL0_FORCE_LINK_DOWN;\n\t\t\twritel(val, port->base + MVPP22_XLG_CTRL0_REG);\n\t\t} else {\n\t\t\tval = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n\t\t\tval &= ~MVPP2_GMAC_FORCE_LINK_PASS;\n\t\t\tval |= MVPP2_GMAC_FORCE_LINK_DOWN;\n\t\t\twritel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);\n\t\t}\n\t}\n\n\tnetif_tx_stop_all_queues(port->dev);\n\tmvpp2_egress_disable(port);\n\tmvpp2_ingress_disable(port);\n\n\tmvpp2_port_disable(port);\n}\n\nstatic const struct phylink_mac_ops mvpp2_phylink_ops = {\n\t.validate = mvpp2_phylink_validate,\n\t.mac_prepare = mvpp2_mac_prepare,\n\t.mac_config = mvpp2_mac_config,\n\t.mac_finish = mvpp2_mac_finish,\n\t.mac_link_up = mvpp2_mac_link_up,\n\t.mac_link_down = mvpp2_mac_link_down,\n};\n\n/* Work-around for ACPI */\nstatic void mvpp2_acpi_start(struct mvpp2_port *port)\n{\n\t/* Phylink isn't used as of now for ACPI, so the MAC has to be\n\t * configured manually when the interface is started. This will\n\t * be removed as soon as the phylink ACPI support lands in.\n\t */\n\tstruct phylink_link_state state = {\n\t\t.interface = port->phy_interface,\n\t};\n\tmvpp2__mac_prepare(&port->phylink_config, MLO_AN_INBAND,\n\t\t\t   port->phy_interface);\n\tmvpp2_mac_config(&port->phylink_config, MLO_AN_INBAND, &state);\n\tport->phylink_pcs.ops->pcs_config(&port->phylink_pcs, MLO_AN_INBAND,\n\t\t\t\t\t  port->phy_interface,\n\t\t\t\t\t  state.advertising, false);\n\tmvpp2_mac_finish(&port->phylink_config, MLO_AN_INBAND,\n\t\t\t port->phy_interface);\n\tmvpp2_mac_link_up(&port->phylink_config, NULL,\n\t\t\t  MLO_AN_INBAND, port->phy_interface,\n\t\t\t  SPEED_UNKNOWN, DUPLEX_UNKNOWN, false, false);\n}\n\n/* Ports initialization */\nstatic int mvpp2_port_probe(struct platform_device *pdev,\n\t\t\t    struct fwnode_handle *port_fwnode,\n\t\t\t    struct mvpp2 *priv)\n{\n\tstruct phy *comphy = NULL;\n\tstruct mvpp2_port *port;\n\tstruct mvpp2_port_pcpu *port_pcpu;\n\tstruct device_node *port_node = to_of_node(port_fwnode);\n\tnetdev_features_t features;\n\tstruct net_device *dev;\n\tstruct phylink *phylink;\n\tchar *mac_from = \"\";\n\tunsigned int ntxqs, nrxqs, thread;\n\tunsigned long flags = 0;\n\tbool has_tx_irqs;\n\tu32 id;\n\tint phy_mode;\n\tint err, i;\n\n\thas_tx_irqs = mvpp2_port_has_irqs(priv, port_node, &flags);\n\tif (!has_tx_irqs && queue_mode == MVPP2_QDIST_MULTI_MODE) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"not enough IRQs to support multi queue mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tntxqs = MVPP2_MAX_TXQ;\n\tnrxqs = mvpp2_get_nrxqs(priv);\n\n\tdev = alloc_etherdev_mqs(sizeof(*port), ntxqs, nrxqs);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tphy_mode = fwnode_get_phy_mode(port_fwnode);\n\tif (phy_mode < 0) {\n\t\tdev_err(&pdev->dev, \"incorrect phy mode\\n\");\n\t\terr = phy_mode;\n\t\tgoto err_free_netdev;\n\t}\n\n\t/*\n\t * Rewrite 10GBASE-KR to 10GBASE-R for compatibility with existing DT.\n\t * Existing usage of 10GBASE-KR is not correct; no backplane\n\t * negotiation is done, and this driver does not actually support\n\t * 10GBASE-KR.\n\t */\n\tif (phy_mode == PHY_INTERFACE_MODE_10GKR)\n\t\tphy_mode = PHY_INTERFACE_MODE_10GBASER;\n\n\tif (port_node) {\n\t\tcomphy = devm_of_phy_get(&pdev->dev, port_node, NULL);\n\t\tif (IS_ERR(comphy)) {\n\t\t\tif (PTR_ERR(comphy) == -EPROBE_DEFER) {\n\t\t\t\terr = -EPROBE_DEFER;\n\t\t\t\tgoto err_free_netdev;\n\t\t\t}\n\t\t\tcomphy = NULL;\n\t\t}\n\t}\n\n\tif (fwnode_property_read_u32(port_fwnode, \"port-id\", &id)) {\n\t\terr = -EINVAL;\n\t\tdev_err(&pdev->dev, \"missing port-id value\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\tdev->tx_queue_len = MVPP2_MAX_TXD_MAX;\n\tdev->watchdog_timeo = 5 * HZ;\n\tdev->netdev_ops = &mvpp2_netdev_ops;\n\tdev->ethtool_ops = &mvpp2_eth_tool_ops;\n\n\tport = netdev_priv(dev);\n\tport->dev = dev;\n\tport->fwnode = port_fwnode;\n\tport->has_phy = !!of_find_property(port_node, \"phy\", NULL);\n\tport->ntxqs = ntxqs;\n\tport->nrxqs = nrxqs;\n\tport->priv = priv;\n\tport->has_tx_irqs = has_tx_irqs;\n\tport->flags = flags;\n\n\terr = mvpp2_queue_vectors_init(port, port_node);\n\tif (err)\n\t\tgoto err_free_netdev;\n\n\tif (port_node)\n\t\tport->port_irq = of_irq_get_byname(port_node, \"link\");\n\telse\n\t\tport->port_irq = fwnode_irq_get(port_fwnode, port->nqvecs + 1);\n\tif (port->port_irq == -EPROBE_DEFER) {\n\t\terr = -EPROBE_DEFER;\n\t\tgoto err_deinit_qvecs;\n\t}\n\tif (port->port_irq <= 0)\n\t\t/* the link irq is optional */\n\t\tport->port_irq = 0;\n\n\tif (fwnode_property_read_bool(port_fwnode, \"marvell,loopback\"))\n\t\tport->flags |= MVPP2_F_LOOPBACK;\n\n\tport->id = id;\n\tif (priv->hw_version == MVPP21)\n\t\tport->first_rxq = port->id * port->nrxqs;\n\telse\n\t\tport->first_rxq = port->id * priv->max_port_rxqs;\n\n\tport->of_node = port_node;\n\tport->phy_interface = phy_mode;\n\tport->comphy = comphy;\n\n\tif (priv->hw_version == MVPP21) {\n\t\tport->base = devm_platform_ioremap_resource(pdev, 2 + id);\n\t\tif (IS_ERR(port->base)) {\n\t\t\terr = PTR_ERR(port->base);\n\t\t\tgoto err_free_irq;\n\t\t}\n\n\t\tport->stats_base = port->priv->lms_base +\n\t\t\t\t   MVPP21_MIB_COUNTERS_OFFSET +\n\t\t\t\t   port->gop_id * MVPP21_MIB_COUNTERS_PORT_SZ;\n\t} else {\n\t\tif (fwnode_property_read_u32(port_fwnode, \"gop-port-id\",\n\t\t\t\t\t     &port->gop_id)) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_err(&pdev->dev, \"missing gop-port-id value\\n\");\n\t\t\tgoto err_deinit_qvecs;\n\t\t}\n\n\t\tport->base = priv->iface_base + MVPP22_GMAC_BASE(port->gop_id);\n\t\tport->stats_base = port->priv->iface_base +\n\t\t\t\t   MVPP22_MIB_COUNTERS_OFFSET +\n\t\t\t\t   port->gop_id * MVPP22_MIB_COUNTERS_PORT_SZ;\n\n\t\t/* We may want a property to describe whether we should use\n\t\t * MAC hardware timestamping.\n\t\t */\n\t\tif (priv->tai)\n\t\t\tport->hwtstamp = true;\n\t}\n\n\t/* Alloc per-cpu and ethtool stats */\n\tport->stats = netdev_alloc_pcpu_stats(struct mvpp2_pcpu_stats);\n\tif (!port->stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tport->ethtool_stats = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t   MVPP2_N_ETHTOOL_STATS(ntxqs, nrxqs),\n\t\t\t\t\t   sizeof(u64), GFP_KERNEL);\n\tif (!port->ethtool_stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_stats;\n\t}\n\n\tmutex_init(&port->gather_stats_lock);\n\tINIT_DELAYED_WORK(&port->stats_work, mvpp2_gather_hw_statistics);\n\n\tmvpp2_port_copy_mac_addr(dev, priv, port_fwnode, &mac_from);\n\n\tport->tx_ring_size = MVPP2_MAX_TXD_DFLT;\n\tport->rx_ring_size = MVPP2_MAX_RXD_DFLT;\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = mvpp2_port_init(port);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to init port %d\\n\", id);\n\t\tgoto err_free_stats;\n\t}\n\n\tmvpp2_port_periodic_xon_disable(port);\n\n\tmvpp2_mac_reset_assert(port);\n\tmvpp22_pcs_reset_assert(port);\n\n\tport->pcpu = alloc_percpu(struct mvpp2_port_pcpu);\n\tif (!port->pcpu) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_txq_pcpu;\n\t}\n\n\tif (!port->has_tx_irqs) {\n\t\tfor (thread = 0; thread < priv->nthreads; thread++) {\n\t\t\tport_pcpu = per_cpu_ptr(port->pcpu, thread);\n\n\t\t\thrtimer_init(&port_pcpu->tx_done_timer, CLOCK_MONOTONIC,\n\t\t\t\t     HRTIMER_MODE_REL_PINNED_SOFT);\n\t\t\tport_pcpu->tx_done_timer.function = mvpp2_hr_timer_cb;\n\t\t\tport_pcpu->timer_scheduled = false;\n\t\t\tport_pcpu->dev = dev;\n\t\t}\n\t}\n\n\tfeatures = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |\n\t\t   NETIF_F_TSO;\n\tdev->features = features | NETIF_F_RXCSUM;\n\tdev->hw_features |= features | NETIF_F_RXCSUM | NETIF_F_GRO |\n\t\t\t    NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\tif (mvpp22_rss_is_supported()) {\n\t\tdev->hw_features |= NETIF_F_RXHASH;\n\t\tdev->features |= NETIF_F_NTUPLE;\n\t}\n\n\tif (!port->priv->percpu_pools)\n\t\tmvpp2_set_hw_csum(port, port->pool_long->id);\n\n\tdev->vlan_features |= features;\n\tdev->gso_max_segs = MVPP2_MAX_TSO_SEGS;\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t/* MTU range: 68 - 9704 */\n\tdev->min_mtu = ETH_MIN_MTU;\n\t/* 9704 == 9728 - 20 and rounding to 8 */\n\tdev->max_mtu = MVPP2_BM_JUMBO_PKT_SIZE;\n\tdev->dev.of_node = port_node;\n\n\t/* Phylink isn't used w/ ACPI as of now */\n\tif (port_node) {\n\t\tport->phylink_config.dev = &dev->dev;\n\t\tport->phylink_config.type = PHYLINK_NETDEV;\n\n\t\tphylink = phylink_create(&port->phylink_config, port_fwnode,\n\t\t\t\t\t phy_mode, &mvpp2_phylink_ops);\n\t\tif (IS_ERR(phylink)) {\n\t\t\terr = PTR_ERR(phylink);\n\t\t\tgoto err_free_port_pcpu;\n\t\t}\n\t\tport->phylink = phylink;\n\t} else {\n\t\tport->phylink = NULL;\n\t}\n\n\t/* Cycle the comphy to power it down, saving 270mW per port -\n\t * don't worry about an error powering it up. When the comphy\n\t * driver does this, we can remove this code.\n\t */\n\tif (port->comphy) {\n\t\terr = mvpp22_comphy_init(port);\n\t\tif (err == 0)\n\t\t\tphy_power_off(port->comphy);\n\t}\n\n\terr = register_netdev(dev);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register netdev\\n\");\n\t\tgoto err_phylink;\n\t}\n\tnetdev_info(dev, \"Using %s mac address %pM\\n\", mac_from, dev->dev_addr);\n\n\tpriv->port_list[priv->port_count++] = port;\n\n\treturn 0;\n\nerr_phylink:\n\tif (port->phylink)\n\t\tphylink_destroy(port->phylink);\nerr_free_port_pcpu:\n\tfree_percpu(port->pcpu);\nerr_free_txq_pcpu:\n\tfor (i = 0; i < port->ntxqs; i++)\n\t\tfree_percpu(port->txqs[i]->pcpu);\nerr_free_stats:\n\tfree_percpu(port->stats);\nerr_free_irq:\n\tif (port->port_irq)\n\t\tirq_dispose_mapping(port->port_irq);\nerr_deinit_qvecs:\n\tmvpp2_queue_vectors_deinit(port);\nerr_free_netdev:\n\tfree_netdev(dev);\n\treturn err;\n}\n\n/* Ports removal routine */\nstatic void mvpp2_port_remove(struct mvpp2_port *port)\n{\n\tint i;\n\n\tunregister_netdev(port->dev);\n\tif (port->phylink)\n\t\tphylink_destroy(port->phylink);\n\tfree_percpu(port->pcpu);\n\tfree_percpu(port->stats);\n\tfor (i = 0; i < port->ntxqs; i++)\n\t\tfree_percpu(port->txqs[i]->pcpu);\n\tmvpp2_queue_vectors_deinit(port);\n\tif (port->port_irq)\n\t\tirq_dispose_mapping(port->port_irq);\n\tfree_netdev(port->dev);\n}\n\n/* Initialize decoding windows */\nstatic void mvpp2_conf_mbus_windows(const struct mbus_dram_target_info *dram,\n\t\t\t\t    struct mvpp2 *priv)\n{\n\tu32 win_enable;\n\tint i;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tmvpp2_write(priv, MVPP2_WIN_BASE(i), 0);\n\t\tmvpp2_write(priv, MVPP2_WIN_SIZE(i), 0);\n\n\t\tif (i < 4)\n\t\t\tmvpp2_write(priv, MVPP2_WIN_REMAP(i), 0);\n\t}\n\n\twin_enable = 0;\n\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\tmvpp2_write(priv, MVPP2_WIN_BASE(i),\n\t\t\t    (cs->base & 0xffff0000) | (cs->mbus_attr << 8) |\n\t\t\t    dram->mbus_dram_target_id);\n\n\t\tmvpp2_write(priv, MVPP2_WIN_SIZE(i),\n\t\t\t    (cs->size - 1) & 0xffff0000);\n\n\t\twin_enable |= (1 << i);\n\t}\n\n\tmvpp2_write(priv, MVPP2_BASE_ADDR_ENABLE, win_enable);\n}\n\n/* Initialize Rx FIFO's */\nstatic void mvpp2_rx_fifo_init(struct mvpp2 *priv)\n{\n\tint port;\n\n\tfor (port = 0; port < MVPP2_MAX_PORTS; port++) {\n\t\tmvpp2_write(priv, MVPP2_RX_DATA_FIFO_SIZE_REG(port),\n\t\t\t    MVPP2_RX_FIFO_PORT_DATA_SIZE_4KB);\n\t\tmvpp2_write(priv, MVPP2_RX_ATTR_FIFO_SIZE_REG(port),\n\t\t\t    MVPP2_RX_FIFO_PORT_ATTR_SIZE_4KB);\n\t}\n\n\tmvpp2_write(priv, MVPP2_RX_MIN_PKT_SIZE_REG,\n\t\t    MVPP2_RX_FIFO_PORT_MIN_PKT);\n\tmvpp2_write(priv, MVPP2_RX_FIFO_INIT_REG, 0x1);\n}\n\nstatic void mvpp22_rx_fifo_set_hw(struct mvpp2 *priv, int port, int data_size)\n{\n\tint attr_size = MVPP2_RX_FIFO_PORT_ATTR_SIZE(data_size);\n\n\tmvpp2_write(priv, MVPP2_RX_DATA_FIFO_SIZE_REG(port), data_size);\n\tmvpp2_write(priv, MVPP2_RX_ATTR_FIFO_SIZE_REG(port), attr_size);\n}\n\n/* Initialize TX FIFO's: the total FIFO size is 48kB on PPv2.2.\n * 4kB fixed space must be assigned for the loopback port.\n * Redistribute remaining avialable 44kB space among all active ports.\n * Guarantee minimum 32kB for 10G port and 8kB for port 1, capable of 2.5G\n * SGMII link.\n */\nstatic void mvpp22_rx_fifo_init(struct mvpp2 *priv)\n{\n\tint remaining_ports_count;\n\tunsigned long port_map;\n\tint size_remainder;\n\tint port, size;\n\n\t/* The loopback requires fixed 4kB of the FIFO space assignment. */\n\tmvpp22_rx_fifo_set_hw(priv, MVPP2_LOOPBACK_PORT_INDEX,\n\t\t\t      MVPP2_RX_FIFO_PORT_DATA_SIZE_4KB);\n\tport_map = priv->port_map & ~BIT(MVPP2_LOOPBACK_PORT_INDEX);\n\n\t/* Set RX FIFO size to 0 for inactive ports. */\n\tfor_each_clear_bit(port, &port_map, MVPP2_LOOPBACK_PORT_INDEX)\n\t\tmvpp22_rx_fifo_set_hw(priv, port, 0);\n\n\t/* Assign remaining RX FIFO space among all active ports. */\n\tsize_remainder = MVPP2_RX_FIFO_PORT_DATA_SIZE_44KB;\n\tremaining_ports_count = hweight_long(port_map);\n\n\tfor_each_set_bit(port, &port_map, MVPP2_LOOPBACK_PORT_INDEX) {\n\t\tif (remaining_ports_count == 1)\n\t\t\tsize = size_remainder;\n\t\telse if (port == 0)\n\t\t\tsize = max(size_remainder / remaining_ports_count,\n\t\t\t\t   MVPP2_RX_FIFO_PORT_DATA_SIZE_32KB);\n\t\telse if (port == 1)\n\t\t\tsize = max(size_remainder / remaining_ports_count,\n\t\t\t\t   MVPP2_RX_FIFO_PORT_DATA_SIZE_8KB);\n\t\telse\n\t\t\tsize = size_remainder / remaining_ports_count;\n\n\t\tsize_remainder -= size;\n\t\tremaining_ports_count--;\n\n\t\tmvpp22_rx_fifo_set_hw(priv, port, size);\n\t}\n\n\tmvpp2_write(priv, MVPP2_RX_MIN_PKT_SIZE_REG,\n\t\t    MVPP2_RX_FIFO_PORT_MIN_PKT);\n\tmvpp2_write(priv, MVPP2_RX_FIFO_INIT_REG, 0x1);\n}\n\nstatic void mvpp22_tx_fifo_set_hw(struct mvpp2 *priv, int port, int size)\n{\n\tint threshold = MVPP2_TX_FIFO_THRESHOLD(size);\n\n\tmvpp2_write(priv, MVPP22_TX_FIFO_SIZE_REG(port), size);\n\tmvpp2_write(priv, MVPP22_TX_FIFO_THRESH_REG(port), threshold);\n}\n\n/* Initialize TX FIFO's: the total FIFO size is 19kB on PPv2.2.\n * 3kB fixed space must be assigned for the loopback port.\n * Redistribute remaining avialable 16kB space among all active ports.\n * The 10G interface should use 10kB (which is maximum possible size\n * per single port).\n */\nstatic void mvpp22_tx_fifo_init(struct mvpp2 *priv)\n{\n\tint remaining_ports_count;\n\tunsigned long port_map;\n\tint size_remainder;\n\tint port, size;\n\n\t/* The loopback requires fixed 3kB of the FIFO space assignment. */\n\tmvpp22_tx_fifo_set_hw(priv, MVPP2_LOOPBACK_PORT_INDEX,\n\t\t\t      MVPP22_TX_FIFO_DATA_SIZE_3KB);\n\tport_map = priv->port_map & ~BIT(MVPP2_LOOPBACK_PORT_INDEX);\n\n\t/* Set TX FIFO size to 0 for inactive ports. */\n\tfor_each_clear_bit(port, &port_map, MVPP2_LOOPBACK_PORT_INDEX)\n\t\tmvpp22_tx_fifo_set_hw(priv, port, 0);\n\n\t/* Assign remaining TX FIFO space among all active ports. */\n\tsize_remainder = MVPP22_TX_FIFO_DATA_SIZE_16KB;\n\tremaining_ports_count = hweight_long(port_map);\n\n\tfor_each_set_bit(port, &port_map, MVPP2_LOOPBACK_PORT_INDEX) {\n\t\tif (remaining_ports_count == 1)\n\t\t\tsize = min(size_remainder,\n\t\t\t\t   MVPP22_TX_FIFO_DATA_SIZE_10KB);\n\t\telse if (port == 0)\n\t\t\tsize = MVPP22_TX_FIFO_DATA_SIZE_10KB;\n\t\telse\n\t\t\tsize = size_remainder / remaining_ports_count;\n\n\t\tsize_remainder -= size;\n\t\tremaining_ports_count--;\n\n\t\tmvpp22_tx_fifo_set_hw(priv, port, size);\n\t}\n}\n\nstatic void mvpp2_axi_init(struct mvpp2 *priv)\n{\n\tu32 val, rdval, wrval;\n\n\tmvpp2_write(priv, MVPP22_BM_ADDR_HIGH_RLS_REG, 0x0);\n\n\t/* AXI Bridge Configuration */\n\n\trdval = MVPP22_AXI_CODE_CACHE_RD_CACHE\n\t\t<< MVPP22_AXI_ATTR_CACHE_OFFS;\n\trdval |= MVPP22_AXI_CODE_DOMAIN_OUTER_DOM\n\t\t<< MVPP22_AXI_ATTR_DOMAIN_OFFS;\n\n\twrval = MVPP22_AXI_CODE_CACHE_WR_CACHE\n\t\t<< MVPP22_AXI_ATTR_CACHE_OFFS;\n\twrval |= MVPP22_AXI_CODE_DOMAIN_OUTER_DOM\n\t\t<< MVPP22_AXI_ATTR_DOMAIN_OFFS;\n\n\t/* BM */\n\tmvpp2_write(priv, MVPP22_AXI_BM_WR_ATTR_REG, wrval);\n\tmvpp2_write(priv, MVPP22_AXI_BM_RD_ATTR_REG, rdval);\n\n\t/* Descriptors */\n\tmvpp2_write(priv, MVPP22_AXI_AGGRQ_DESCR_RD_ATTR_REG, rdval);\n\tmvpp2_write(priv, MVPP22_AXI_TXQ_DESCR_WR_ATTR_REG, wrval);\n\tmvpp2_write(priv, MVPP22_AXI_TXQ_DESCR_RD_ATTR_REG, rdval);\n\tmvpp2_write(priv, MVPP22_AXI_RXQ_DESCR_WR_ATTR_REG, wrval);\n\n\t/* Buffer Data */\n\tmvpp2_write(priv, MVPP22_AXI_TX_DATA_RD_ATTR_REG, rdval);\n\tmvpp2_write(priv, MVPP22_AXI_RX_DATA_WR_ATTR_REG, wrval);\n\n\tval = MVPP22_AXI_CODE_CACHE_NON_CACHE\n\t\t<< MVPP22_AXI_CODE_CACHE_OFFS;\n\tval |= MVPP22_AXI_CODE_DOMAIN_SYSTEM\n\t\t<< MVPP22_AXI_CODE_DOMAIN_OFFS;\n\tmvpp2_write(priv, MVPP22_AXI_RD_NORMAL_CODE_REG, val);\n\tmvpp2_write(priv, MVPP22_AXI_WR_NORMAL_CODE_REG, val);\n\n\tval = MVPP22_AXI_CODE_CACHE_RD_CACHE\n\t\t<< MVPP22_AXI_CODE_CACHE_OFFS;\n\tval |= MVPP22_AXI_CODE_DOMAIN_OUTER_DOM\n\t\t<< MVPP22_AXI_CODE_DOMAIN_OFFS;\n\n\tmvpp2_write(priv, MVPP22_AXI_RD_SNOOP_CODE_REG, val);\n\n\tval = MVPP22_AXI_CODE_CACHE_WR_CACHE\n\t\t<< MVPP22_AXI_CODE_CACHE_OFFS;\n\tval |= MVPP22_AXI_CODE_DOMAIN_OUTER_DOM\n\t\t<< MVPP22_AXI_CODE_DOMAIN_OFFS;\n\n\tmvpp2_write(priv, MVPP22_AXI_WR_SNOOP_CODE_REG, val);\n}\n\n/* Initialize network controller common part HW */\nstatic int mvpp2_init(struct platform_device *pdev, struct mvpp2 *priv)\n{\n\tconst struct mbus_dram_target_info *dram_target_info;\n\tint err, i;\n\tu32 val;\n\n\t/* MBUS windows configuration */\n\tdram_target_info = mv_mbus_dram_info();\n\tif (dram_target_info)\n\t\tmvpp2_conf_mbus_windows(dram_target_info, priv);\n\n\tif (priv->hw_version == MVPP22)\n\t\tmvpp2_axi_init(priv);\n\n\t/* Disable HW PHY polling */\n\tif (priv->hw_version == MVPP21) {\n\t\tval = readl(priv->lms_base + MVPP2_PHY_AN_CFG0_REG);\n\t\tval |= MVPP2_PHY_AN_STOP_SMI0_MASK;\n\t\twritel(val, priv->lms_base + MVPP2_PHY_AN_CFG0_REG);\n\t} else {\n\t\tval = readl(priv->iface_base + MVPP22_SMI_MISC_CFG_REG);\n\t\tval &= ~MVPP22_SMI_POLLING_EN;\n\t\twritel(val, priv->iface_base + MVPP22_SMI_MISC_CFG_REG);\n\t}\n\n\t/* Allocate and initialize aggregated TXQs */\n\tpriv->aggr_txqs = devm_kcalloc(&pdev->dev, MVPP2_MAX_THREADS,\n\t\t\t\t       sizeof(*priv->aggr_txqs),\n\t\t\t\t       GFP_KERNEL);\n\tif (!priv->aggr_txqs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MVPP2_MAX_THREADS; i++) {\n\t\tpriv->aggr_txqs[i].id = i;\n\t\tpriv->aggr_txqs[i].size = MVPP2_AGGR_TXQ_SIZE;\n\t\terr = mvpp2_aggr_txq_init(pdev, &priv->aggr_txqs[i], i, priv);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Fifo Init */\n\tif (priv->hw_version == MVPP21) {\n\t\tmvpp2_rx_fifo_init(priv);\n\t} else {\n\t\tmvpp22_rx_fifo_init(priv);\n\t\tmvpp22_tx_fifo_init(priv);\n\t}\n\n\tif (priv->hw_version == MVPP21)\n\t\twritel(MVPP2_EXT_GLOBAL_CTRL_DEFAULT,\n\t\t       priv->lms_base + MVPP2_MNG_EXTENDED_GLOBAL_CTRL_REG);\n\n\t/* Allow cache snoop when transmiting packets */\n\tmvpp2_write(priv, MVPP2_TX_SNOOP_REG, 0x1);\n\n\t/* Buffer Manager initialization */\n\terr = mvpp2_bm_init(&pdev->dev, priv);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Parser default initialization */\n\terr = mvpp2_prs_default_init(pdev, priv);\n\tif (err < 0)\n\t\treturn err;\n\n\t/* Classifier default initialization */\n\tmvpp2_cls_init(priv);\n\n\treturn 0;\n}\n\nstatic int mvpp2_probe(struct platform_device *pdev)\n{\n\tconst struct acpi_device_id *acpi_id;\n\tstruct fwnode_handle *fwnode = pdev->dev.fwnode;\n\tstruct fwnode_handle *port_fwnode;\n\tstruct mvpp2 *priv;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint i, shared;\n\tint err;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (has_acpi_companion(&pdev->dev)) {\n\t\tacpi_id = acpi_match_device(pdev->dev.driver->acpi_match_table,\n\t\t\t\t\t    &pdev->dev);\n\t\tif (!acpi_id)\n\t\t\treturn -EINVAL;\n\t\tpriv->hw_version = (unsigned long)acpi_id->driver_data;\n\t} else {\n\t\tpriv->hw_version =\n\t\t\t(unsigned long)of_device_get_match_data(&pdev->dev);\n\t}\n\n\t/* multi queue mode isn't supported on PPV2.1, fallback to single\n\t * mode\n\t */\n\tif (priv->hw_version == MVPP21)\n\t\tqueue_mode = MVPP2_QDIST_SINGLE_MODE;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (priv->hw_version == MVPP21) {\n\t\tpriv->lms_base = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(priv->lms_base))\n\t\t\treturn PTR_ERR(priv->lms_base);\n\t} else {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\t\tif (has_acpi_companion(&pdev->dev)) {\n\t\t\t/* In case the MDIO memory region is declared in\n\t\t\t * the ACPI, it can already appear as 'in-use'\n\t\t\t * in the OS. Because it is overlapped by second\n\t\t\t * region of the network controller, make\n\t\t\t * sure it is released, before requesting it again.\n\t\t\t * The care is taken by mvpp2 driver to avoid\n\t\t\t * concurrent access to this memory region.\n\t\t\t */\n\t\t\trelease_resource(res);\n\t\t}\n\t\tpriv->iface_base = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(priv->iface_base))\n\t\t\treturn PTR_ERR(priv->iface_base);\n\t}\n\n\tif (priv->hw_version == MVPP22 && dev_of_node(&pdev->dev)) {\n\t\tpriv->sysctrl_base =\n\t\t\tsyscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t\"marvell,system-controller\");\n\t\tif (IS_ERR(priv->sysctrl_base))\n\t\t\t/* The system controller regmap is optional for dt\n\t\t\t * compatibility reasons. When not provided, the\n\t\t\t * configuration of the GoP relies on the\n\t\t\t * firmware/bootloader.\n\t\t\t */\n\t\t\tpriv->sysctrl_base = NULL;\n\t}\n\n\tif (priv->hw_version == MVPP22 &&\n\t    mvpp2_get_nrxqs(priv) * 2 <= MVPP2_BM_MAX_POOLS)\n\t\tpriv->percpu_pools = 1;\n\n\tmvpp2_setup_bm_pool();\n\n\n\tpriv->nthreads = min_t(unsigned int, num_present_cpus(),\n\t\t\t       MVPP2_MAX_THREADS);\n\n\tshared = num_present_cpus() - priv->nthreads;\n\tif (shared > 0)\n\t\tbitmap_fill(&priv->lock_map,\n\t\t\t    min_t(int, shared, MVPP2_MAX_THREADS));\n\n\tfor (i = 0; i < MVPP2_MAX_THREADS; i++) {\n\t\tu32 addr_space_sz;\n\n\t\taddr_space_sz = (priv->hw_version == MVPP21 ?\n\t\t\t\t MVPP21_ADDR_SPACE_SZ : MVPP22_ADDR_SPACE_SZ);\n\t\tpriv->swth_base[i] = base + i * addr_space_sz;\n\t}\n\n\tif (priv->hw_version == MVPP21)\n\t\tpriv->max_port_rxqs = 8;\n\telse\n\t\tpriv->max_port_rxqs = 32;\n\n\tif (dev_of_node(&pdev->dev)) {\n\t\tpriv->pp_clk = devm_clk_get(&pdev->dev, \"pp_clk\");\n\t\tif (IS_ERR(priv->pp_clk))\n\t\t\treturn PTR_ERR(priv->pp_clk);\n\t\terr = clk_prepare_enable(priv->pp_clk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tpriv->gop_clk = devm_clk_get(&pdev->dev, \"gop_clk\");\n\t\tif (IS_ERR(priv->gop_clk)) {\n\t\t\terr = PTR_ERR(priv->gop_clk);\n\t\t\tgoto err_pp_clk;\n\t\t}\n\t\terr = clk_prepare_enable(priv->gop_clk);\n\t\tif (err < 0)\n\t\t\tgoto err_pp_clk;\n\n\t\tif (priv->hw_version == MVPP22) {\n\t\t\tpriv->mg_clk = devm_clk_get(&pdev->dev, \"mg_clk\");\n\t\t\tif (IS_ERR(priv->mg_clk)) {\n\t\t\t\terr = PTR_ERR(priv->mg_clk);\n\t\t\t\tgoto err_gop_clk;\n\t\t\t}\n\n\t\t\terr = clk_prepare_enable(priv->mg_clk);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_gop_clk;\n\n\t\t\tpriv->mg_core_clk = devm_clk_get(&pdev->dev, \"mg_core_clk\");\n\t\t\tif (IS_ERR(priv->mg_core_clk)) {\n\t\t\t\tpriv->mg_core_clk = NULL;\n\t\t\t} else {\n\t\t\t\terr = clk_prepare_enable(priv->mg_core_clk);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_mg_clk;\n\t\t\t}\n\t\t}\n\n\t\tpriv->axi_clk = devm_clk_get(&pdev->dev, \"axi_clk\");\n\t\tif (IS_ERR(priv->axi_clk)) {\n\t\t\terr = PTR_ERR(priv->axi_clk);\n\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\tgoto err_mg_core_clk;\n\t\t\tpriv->axi_clk = NULL;\n\t\t} else {\n\t\t\terr = clk_prepare_enable(priv->axi_clk);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_mg_core_clk;\n\t\t}\n\n\t\t/* Get system's tclk rate */\n\t\tpriv->tclk = clk_get_rate(priv->pp_clk);\n\t} else if (device_property_read_u32(&pdev->dev, \"clock-frequency\",\n\t\t\t\t\t    &priv->tclk)) {\n\t\tdev_err(&pdev->dev, \"missing clock-frequency value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->hw_version == MVPP22) {\n\t\terr = dma_set_mask(&pdev->dev, MVPP2_DESC_DMA_MASK);\n\t\tif (err)\n\t\t\tgoto err_axi_clk;\n\t\t/* Sadly, the BM pools all share the same register to\n\t\t * store the high 32 bits of their address. So they\n\t\t * must all have the same high 32 bits, which forces\n\t\t * us to restrict coherent memory to DMA_BIT_MASK(32).\n\t\t */\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err)\n\t\t\tgoto err_axi_clk;\n\t}\n\n\t/* Map DTS-active ports. Should be done before FIFO mvpp2_init */\n\tfwnode_for_each_available_child_node(fwnode, port_fwnode) {\n\t\tif (!fwnode_property_read_u32(port_fwnode, \"port-id\", &i))\n\t\t\tpriv->port_map |= BIT(i);\n\t}\n\n\t/* Initialize network controller */\n\terr = mvpp2_init(pdev, priv);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to initialize controller\\n\");\n\t\tgoto err_axi_clk;\n\t}\n\n\terr = mvpp22_tai_probe(&pdev->dev, priv);\n\tif (err < 0)\n\t\tgoto err_axi_clk;\n\n\t/* Initialize ports */\n\tfwnode_for_each_available_child_node(fwnode, port_fwnode) {\n\t\terr = mvpp2_port_probe(pdev, port_fwnode, priv);\n\t\tif (err < 0)\n\t\t\tgoto err_port_probe;\n\t}\n\n\tif (priv->port_count == 0) {\n\t\tdev_err(&pdev->dev, \"no ports enabled\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_axi_clk;\n\t}\n\n\t/* Statistics must be gathered regularly because some of them (like\n\t * packets counters) are 32-bit registers and could overflow quite\n\t * quickly. For instance, a 10Gb link used at full bandwidth with the\n\t * smallest packets (64B) will overflow a 32-bit counter in less than\n\t * 30 seconds. Then, use a workqueue to fill 64-bit counters.\n\t */\n\tsnprintf(priv->queue_name, sizeof(priv->queue_name),\n\t\t \"stats-wq-%s%s\", netdev_name(priv->port_list[0]->dev),\n\t\t priv->port_count > 1 ? \"+\" : \"\");\n\tpriv->stats_queue = create_singlethread_workqueue(priv->queue_name);\n\tif (!priv->stats_queue) {\n\t\terr = -ENOMEM;\n\t\tgoto err_port_probe;\n\t}\n\n\tmvpp2_dbgfs_init(priv, pdev->name);\n\n\tplatform_set_drvdata(pdev, priv);\n\treturn 0;\n\nerr_port_probe:\n\ti = 0;\n\tfwnode_for_each_available_child_node(fwnode, port_fwnode) {\n\t\tif (priv->port_list[i])\n\t\t\tmvpp2_port_remove(priv->port_list[i]);\n\t\ti++;\n\t}\nerr_axi_clk:\n\tclk_disable_unprepare(priv->axi_clk);\n\nerr_mg_core_clk:\n\tif (priv->hw_version == MVPP22)\n\t\tclk_disable_unprepare(priv->mg_core_clk);\nerr_mg_clk:\n\tif (priv->hw_version == MVPP22)\n\t\tclk_disable_unprepare(priv->mg_clk);\nerr_gop_clk:\n\tclk_disable_unprepare(priv->gop_clk);\nerr_pp_clk:\n\tclk_disable_unprepare(priv->pp_clk);\n\treturn err;\n}\n\nstatic int mvpp2_remove(struct platform_device *pdev)\n{\n\tstruct mvpp2 *priv = platform_get_drvdata(pdev);\n\tstruct fwnode_handle *fwnode = pdev->dev.fwnode;\n\tint i = 0, poolnum = MVPP2_BM_POOLS_NUM;\n\tstruct fwnode_handle *port_fwnode;\n\n\tmvpp2_dbgfs_cleanup(priv);\n\n\tfwnode_for_each_available_child_node(fwnode, port_fwnode) {\n\t\tif (priv->port_list[i]) {\n\t\t\tmutex_destroy(&priv->port_list[i]->gather_stats_lock);\n\t\t\tmvpp2_port_remove(priv->port_list[i]);\n\t\t}\n\t\ti++;\n\t}\n\n\tdestroy_workqueue(priv->stats_queue);\n\n\tif (priv->percpu_pools)\n\t\tpoolnum = mvpp2_get_nrxqs(priv) * 2;\n\n\tfor (i = 0; i < poolnum; i++) {\n\t\tstruct mvpp2_bm_pool *bm_pool = &priv->bm_pools[i];\n\n\t\tmvpp2_bm_pool_destroy(&pdev->dev, priv, bm_pool);\n\t}\n\n\tfor (i = 0; i < MVPP2_MAX_THREADS; i++) {\n\t\tstruct mvpp2_tx_queue *aggr_txq = &priv->aggr_txqs[i];\n\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  MVPP2_AGGR_TXQ_SIZE * MVPP2_DESC_ALIGNED_SIZE,\n\t\t\t\t  aggr_txq->descs,\n\t\t\t\t  aggr_txq->descs_dma);\n\t}\n\n\tif (is_acpi_node(port_fwnode))\n\t\treturn 0;\n\n\tclk_disable_unprepare(priv->axi_clk);\n\tclk_disable_unprepare(priv->mg_core_clk);\n\tclk_disable_unprepare(priv->mg_clk);\n\tclk_disable_unprepare(priv->pp_clk);\n\tclk_disable_unprepare(priv->gop_clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mvpp2_match[] = {\n\t{\n\t\t.compatible = \"marvell,armada-375-pp2\",\n\t\t.data = (void *)MVPP21,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-7k-pp22\",\n\t\t.data = (void *)MVPP22,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mvpp2_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id mvpp2_acpi_match[] = {\n\t{ \"MRVL0110\", MVPP22 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, mvpp2_acpi_match);\n#endif\n\nstatic struct platform_driver mvpp2_driver = {\n\t.probe = mvpp2_probe,\n\t.remove = mvpp2_remove,\n\t.driver = {\n\t\t.name = MVPP2_DRIVER_NAME,\n\t\t.of_match_table = mvpp2_match,\n\t\t.acpi_match_table = ACPI_PTR(mvpp2_acpi_match),\n\t},\n};\n\nmodule_platform_driver(mvpp2_driver);\n\nMODULE_DESCRIPTION(\"Marvell PPv2 Ethernet Driver - www.marvell.com\");\nMODULE_AUTHOR(\"Marcin Wojtas <mw@semihalf.com>\");\nMODULE_LICENSE(\"GPL v2\");\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 0, "line": 4059}, "message": "preceding lock on line 3961"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c", "reportHash": "d29ff93582856af6351c40238694a42d", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
