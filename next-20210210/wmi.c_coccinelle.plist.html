<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/wireless/ath/ath11k/wmi.c", "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n/*\n * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.\n */\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <net/mac80211.h>\n#include <net/cfg80211.h>\n#include <linux/completion.h>\n#include <linux/if_ether.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/uuid.h>\n#include <linux/time.h>\n#include <linux/of.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"mac.h\"\n#include \"hw.h\"\n#include \"peer.h\"\n\nstruct wmi_tlv_policy {\n\tsize_t min_len;\n};\n\nstruct wmi_tlv_svc_ready_parse {\n\tbool wmi_svc_bitmap_done;\n};\n\nstruct wmi_tlv_dma_ring_caps_parse {\n\tstruct wmi_dma_ring_capabilities *dma_ring_caps;\n\tu32 n_dma_ring_caps;\n};\n\nstruct wmi_tlv_svc_rdy_ext_parse {\n\tstruct ath11k_service_ext_param param;\n\tstruct wmi_soc_mac_phy_hw_mode_caps *hw_caps;\n\tstruct wmi_hw_mode_capabilities *hw_mode_caps;\n\tu32 n_hw_mode_caps;\n\tu32 tot_phy_id;\n\tstruct wmi_hw_mode_capabilities pref_hw_mode_caps;\n\tstruct wmi_mac_phy_capabilities *mac_phy_caps;\n\tu32 n_mac_phy_caps;\n\tstruct wmi_soc_hal_reg_capabilities *soc_hal_reg_caps;\n\tstruct wmi_hal_reg_capabilities_ext *ext_hal_reg_caps;\n\tu32 n_ext_hal_reg_caps;\n\tstruct wmi_tlv_dma_ring_caps_parse dma_caps_parse;\n\tbool hw_mode_done;\n\tbool mac_phy_done;\n\tbool ext_hal_reg_done;\n\tbool mac_phy_chainmask_combo_done;\n\tbool mac_phy_chainmask_cap_done;\n\tbool oem_dma_ring_cap_done;\n\tbool dma_ring_cap_done;\n};\n\nstruct wmi_tlv_svc_rdy_ext2_parse {\n\tstruct wmi_tlv_dma_ring_caps_parse dma_caps_parse;\n\tbool dma_ring_cap_done;\n};\n\nstruct wmi_tlv_rdy_parse {\n\tu32 num_extra_mac_addr;\n};\n\nstruct wmi_tlv_dma_buf_release_parse {\n\tstruct ath11k_wmi_dma_buf_release_fixed_param fixed;\n\tstruct wmi_dma_buf_release_entry *buf_entry;\n\tstruct wmi_dma_buf_release_meta_data *meta_data;\n\tu32 num_buf_entry;\n\tu32 num_meta;\n\tbool buf_entry_done;\n\tbool meta_data_done;\n};\n\nstatic const struct wmi_tlv_policy wmi_tlv_policies[] = {\n\t[WMI_TAG_ARRAY_BYTE]\n\t\t= { .min_len = 0 },\n\t[WMI_TAG_ARRAY_UINT32]\n\t\t= { .min_len = 0 },\n\t[WMI_TAG_SERVICE_READY_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_service_ready_event) },\n\t[WMI_TAG_SERVICE_READY_EXT_EVENT]\n\t\t= { .min_len =  sizeof(struct wmi_service_ready_ext_event) },\n\t[WMI_TAG_SOC_MAC_PHY_HW_MODE_CAPS]\n\t\t= { .min_len = sizeof(struct wmi_soc_mac_phy_hw_mode_caps) },\n\t[WMI_TAG_SOC_HAL_REG_CAPABILITIES]\n\t\t= { .min_len = sizeof(struct wmi_soc_hal_reg_capabilities) },\n\t[WMI_TAG_VDEV_START_RESPONSE_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_start_resp_event) },\n\t[WMI_TAG_PEER_DELETE_RESP_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_delete_resp_event) },\n\t[WMI_TAG_OFFLOAD_BCN_TX_STATUS_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_bcn_tx_status_event) },\n\t[WMI_TAG_VDEV_STOPPED_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_stopped_event) },\n\t[WMI_TAG_REG_CHAN_LIST_CC_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_reg_chan_list_cc_event) },\n\t[WMI_TAG_MGMT_RX_HDR]\n\t\t= { .min_len = sizeof(struct wmi_mgmt_rx_hdr) },\n\t[WMI_TAG_MGMT_TX_COMPL_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_mgmt_tx_compl_event) },\n\t[WMI_TAG_SCAN_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_scan_event) },\n\t[WMI_TAG_PEER_STA_KICKOUT_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_sta_kickout_event) },\n\t[WMI_TAG_ROAM_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_roam_event) },\n\t[WMI_TAG_CHAN_INFO_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_chan_info_event) },\n\t[WMI_TAG_PDEV_BSS_CHAN_INFO_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_pdev_bss_chan_info_event) },\n\t[WMI_TAG_VDEV_INSTALL_KEY_COMPLETE_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_install_key_compl_event) },\n\t[WMI_TAG_READY_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_ready_event_min) },\n\t[WMI_TAG_SERVICE_AVAILABLE_EVENT]\n\t\t= {.min_len = sizeof(struct wmi_service_available_event) },\n\t[WMI_TAG_PEER_ASSOC_CONF_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_assoc_conf_event) },\n\t[WMI_TAG_STATS_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_stats_event) },\n\t[WMI_TAG_PDEV_CTL_FAILSAFE_CHECK_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_pdev_ctl_failsafe_chk_event) },\n\t[WMI_TAG_HOST_SWFDA_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_fils_discovery_event) },\n\t[WMI_TAG_OFFLOAD_PRB_RSP_TX_STATUS_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_probe_resp_tx_status_event) },\n\t[WMI_TAG_VDEV_DELETE_RESP_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_vdev_delete_resp_event) },\n};\n\n#define PRIMAP(_hw_mode_) \\\n\t[_hw_mode_] = _hw_mode_##_PRI\n\nstatic const int ath11k_hw_mode_pri_map[] = {\n\tPRIMAP(WMI_HOST_HW_MODE_SINGLE),\n\tPRIMAP(WMI_HOST_HW_MODE_DBS),\n\tPRIMAP(WMI_HOST_HW_MODE_SBS_PASSIVE),\n\tPRIMAP(WMI_HOST_HW_MODE_SBS),\n\tPRIMAP(WMI_HOST_HW_MODE_DBS_SBS),\n\tPRIMAP(WMI_HOST_HW_MODE_DBS_OR_SBS),\n\t/* keep last */\n\tPRIMAP(WMI_HOST_HW_MODE_MAX),\n};\n\nstatic int\nath11k_wmi_tlv_iter(struct ath11k_base *ab, const void *ptr, size_t len,\n\t\t    int (*iter)(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\tconst void *ptr, void *data),\n\t\t    void *data)\n{\n\tconst void *begin = ptr;\n\tconst struct wmi_tlv *tlv;\n\tu16 tlv_tag, tlv_len;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tif (len < sizeof(*tlv)) {\n\t\t\tath11k_err(ab, \"wmi tlv parse failure at byte %zd (%zu bytes left, %zu expected)\\n\",\n\t\t\t\t   ptr - begin, len, sizeof(*tlv));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttlv = ptr;\n\t\ttlv_tag = FIELD_GET(WMI_TLV_TAG, tlv->header);\n\t\ttlv_len = FIELD_GET(WMI_TLV_LEN, tlv->header);\n\t\tptr += sizeof(*tlv);\n\t\tlen -= sizeof(*tlv);\n\n\t\tif (tlv_len > len) {\n\t\t\tath11k_err(ab, \"wmi tlv parse failure of tag %u at byte %zd (%zu bytes left, %u expected)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, len, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tlv_tag < ARRAY_SIZE(wmi_tlv_policies) &&\n\t\t    wmi_tlv_policies[tlv_tag].min_len &&\n\t\t    wmi_tlv_policies[tlv_tag].min_len > tlv_len) {\n\t\t\tath11k_err(ab, \"wmi tlv parse failure of tag %u at byte %zd (%u bytes is less than min length %zu)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, tlv_len,\n\t\t\t\t   wmi_tlv_policies[tlv_tag].min_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = iter(ab, tlv_tag, tlv_len, ptr, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptr += tlv_len;\n\t\tlen -= tlv_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_iter_parse(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\t     const void *ptr, void *data)\n{\n\tconst void **tb = data;\n\n\tif (tag < WMI_TAG_MAX)\n\t\ttb[tag] = ptr;\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_parse(struct ath11k_base *ar, const void **tb,\n\t\t\t\tconst void *ptr, size_t len)\n{\n\treturn ath11k_wmi_tlv_iter(ar, ptr, len, ath11k_wmi_tlv_iter_parse,\n\t\t\t\t   (void *)tb);\n}\n\nstatic const void **\nath11k_wmi_tlv_parse_alloc(struct ath11k_base *ab, const void *ptr,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tconst void **tb;\n\tint ret;\n\n\ttb = kcalloc(WMI_TAG_MAX, sizeof(*tb), gfp);\n\tif (!tb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ath11k_wmi_tlv_parse(ab, tb, ptr, len);\n\tif (ret) {\n\t\tkfree(tb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn tb;\n}\n\nstatic int ath11k_wmi_cmd_send_nowait(struct ath11k_pdev_wmi *wmi, struct sk_buff *skb,\n\t\t\t\t      u32 cmd_id)\n{\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB(skb);\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tint ret;\n\tu32 cmd = 0;\n\n\tif (skb_push(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd |= FIELD_PREP(WMI_CMD_HDR_CMD_ID, cmd_id);\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tcmd_hdr->cmd_id = cmd;\n\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\tret = ath11k_htc_send(&ab->htc, wmi->eid, skb);\n\n\tif (ret)\n\t\tgoto err_pull;\n\n\treturn 0;\n\nerr_pull:\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\treturn ret;\n}\n\nint ath11k_wmi_cmd_send(struct ath11k_pdev_wmi *wmi, struct sk_buff *skb,\n\t\t\tu32 cmd_id)\n{\n\tstruct ath11k_wmi_base *wmi_sc = wmi->wmi_ab;\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\twait_event_timeout(wmi_sc->tx_credits_wq, ({\n\t\tret = ath11k_wmi_cmd_send_nowait(wmi, skb, cmd_id);\n\n\t\tif (ret && test_bit(ATH11K_FLAG_CRASH_FLUSH, &wmi_sc->ab->dev_flags))\n\t\t\tret = -ESHUTDOWN;\n\n\t\t(ret != -EAGAIN);\n\t}), WMI_SEND_TIMEOUT_HZ);\n\n\tif (ret == -EAGAIN)\n\t\tath11k_warn(wmi_sc->ab, \"wmi command %d timeout\\n\", cmd_id);\n\n\treturn ret;\n}\n\nstatic int ath11k_pull_svc_ready_ext(struct ath11k_pdev_wmi *wmi_handle,\n\t\t\t\t     const void *ptr,\n\t\t\t\t     struct ath11k_service_ext_param *param)\n{\n\tconst struct wmi_service_ready_ext_event *ev = ptr;\n\n\tif (!ev)\n\t\treturn -EINVAL;\n\n\t/* Move this to host based bitmap */\n\tparam->default_conc_scan_config_bits = ev->default_conc_scan_config_bits;\n\tparam->default_fw_config_bits =\tev->default_fw_config_bits;\n\tparam->he_cap_info = ev->he_cap_info;\n\tparam->mpdu_density = ev->mpdu_density;\n\tparam->max_bssid_rx_filters = ev->max_bssid_rx_filters;\n\tmemcpy(&param->ppet, &ev->ppet, sizeof(param->ppet));\n\n\treturn 0;\n}\n\nstatic int\nath11k_pull_mac_phy_cap_svc_ready_ext(struct ath11k_pdev_wmi *wmi_handle,\n\t\t\t\t      struct wmi_soc_mac_phy_hw_mode_caps *hw_caps,\n\t\t\t\t      struct wmi_hw_mode_capabilities *wmi_hw_mode_caps,\n\t\t\t\t      struct wmi_soc_hal_reg_capabilities *hal_reg_caps,\n\t\t\t\t      struct wmi_mac_phy_capabilities *wmi_mac_phy_caps,\n\t\t\t\t      u8 hw_mode_id, u8 phy_id,\n\t\t\t\t      struct ath11k_pdev *pdev)\n{\n\tstruct wmi_mac_phy_capabilities *mac_phy_caps;\n\tstruct ath11k_band_cap *cap_band;\n\tstruct ath11k_pdev_cap *pdev_cap = &pdev->cap;\n\tu32 phy_map;\n\tu32 hw_idx, phy_idx = 0;\n\n\tif (!hw_caps || !wmi_hw_mode_caps || !hal_reg_caps)\n\t\treturn -EINVAL;\n\n\tfor (hw_idx = 0; hw_idx < hw_caps->num_hw_modes; hw_idx++) {\n\t\tif (hw_mode_id == wmi_hw_mode_caps[hw_idx].hw_mode_id)\n\t\t\tbreak;\n\n\t\tphy_map = wmi_hw_mode_caps[hw_idx].phy_id_map;\n\t\twhile (phy_map) {\n\t\t\tphy_map >>= 1;\n\t\t\tphy_idx++;\n\t\t}\n\t}\n\n\tif (hw_idx == hw_caps->num_hw_modes)\n\t\treturn -EINVAL;\n\n\tphy_idx += phy_id;\n\tif (phy_id >= hal_reg_caps->num_phy)\n\t\treturn -EINVAL;\n\n\tmac_phy_caps = wmi_mac_phy_caps + phy_idx;\n\n\tpdev->pdev_id = mac_phy_caps->pdev_id;\n\tpdev_cap->supported_bands |= mac_phy_caps->supported_bands;\n\tpdev_cap->ampdu_density = mac_phy_caps->ampdu_density;\n\n\t/* Take non-zero tx/rx chainmask. If tx/rx chainmask differs from\n\t * band to band for a single radio, need to see how this should be\n\t * handled.\n\t */\n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tpdev_cap->tx_chain_mask = mac_phy_caps->tx_chain_mask_2g;\n\t\tpdev_cap->rx_chain_mask = mac_phy_caps->rx_chain_mask_2g;\n\t} else if (mac_phy_caps->supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tpdev_cap->vht_cap = mac_phy_caps->vht_cap_info_5g;\n\t\tpdev_cap->vht_mcs = mac_phy_caps->vht_supp_mcs_5g;\n\t\tpdev_cap->he_mcs = mac_phy_caps->he_supp_mcs_5g;\n\t\tpdev_cap->tx_chain_mask = mac_phy_caps->tx_chain_mask_5g;\n\t\tpdev_cap->rx_chain_mask = mac_phy_caps->rx_chain_mask_5g;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t/* tx/rx chainmask reported from fw depends on the actual hw chains used,\n\t * For example, for 4x4 capable macphys, first 4 chains can be used for first\n\t * mac and the remaing 4 chains can be used for the second mac or vice-versa.\n\t * In this case, tx/rx chainmask 0xf will be advertised for first mac and 0xf0\n\t * will be advertised for second mac or vice-versa. Compute the shift value\n\t * for tx/rx chainmask which will be used to advertise supported ht/vht rates to\n\t * mac80211.\n\t */\n\tpdev_cap->tx_chain_mask_shift =\n\t\t\tfind_first_bit((unsigned long *)&pdev_cap->tx_chain_mask, 32);\n\tpdev_cap->rx_chain_mask_shift =\n\t\t\tfind_first_bit((unsigned long *)&pdev_cap->rx_chain_mask, 32);\n\n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tcap_band = &pdev_cap->band[NL80211_BAND_2GHZ];\n\t\tcap_band->phy_id = mac_phy_caps->phy_id;\n\t\tcap_band->max_bw_supported = mac_phy_caps->max_bw_supported_2g;\n\t\tcap_band->ht_cap_info = mac_phy_caps->ht_cap_info_2g;\n\t\tcap_band->he_cap_info[0] = mac_phy_caps->he_cap_info_2g;\n\t\tcap_band->he_cap_info[1] = mac_phy_caps->he_cap_info_2g_ext;\n\t\tcap_band->he_mcs = mac_phy_caps->he_supp_mcs_2g;\n\t\tmemcpy(cap_band->he_cap_phy_info, &mac_phy_caps->he_cap_phy_info_2g,\n\t\t       sizeof(u32) * PSOC_HOST_MAX_PHY_SIZE);\n\t\tmemcpy(&cap_band->he_ppet, &mac_phy_caps->he_ppet2g,\n\t\t       sizeof(struct ath11k_ppe_threshold));\n\t}\n\n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tcap_band = &pdev_cap->band[NL80211_BAND_5GHZ];\n\t\tcap_band->phy_id = mac_phy_caps->phy_id;\n\t\tcap_band->max_bw_supported = mac_phy_caps->max_bw_supported_5g;\n\t\tcap_band->ht_cap_info = mac_phy_caps->ht_cap_info_5g;\n\t\tcap_band->he_cap_info[0] = mac_phy_caps->he_cap_info_5g;\n\t\tcap_band->he_cap_info[1] = mac_phy_caps->he_cap_info_5g_ext;\n\t\tcap_band->he_mcs = mac_phy_caps->he_supp_mcs_5g;\n\t\tmemcpy(cap_band->he_cap_phy_info, &mac_phy_caps->he_cap_phy_info_5g,\n\t\t       sizeof(u32) * PSOC_HOST_MAX_PHY_SIZE);\n\t\tmemcpy(&cap_band->he_ppet, &mac_phy_caps->he_ppet5g,\n\t\t       sizeof(struct ath11k_ppe_threshold));\n\t}\n\n\tcap_band = &pdev_cap->band[NL80211_BAND_6GHZ];\n\tcap_band->max_bw_supported = mac_phy_caps->max_bw_supported_5g;\n\tcap_band->ht_cap_info = mac_phy_caps->ht_cap_info_5g;\n\tcap_band->he_cap_info[0] = mac_phy_caps->he_cap_info_5g;\n\tcap_band->he_cap_info[1] = mac_phy_caps->he_cap_info_5g_ext;\n\tcap_band->he_mcs = mac_phy_caps->he_supp_mcs_5g;\n\tmemcpy(cap_band->he_cap_phy_info, &mac_phy_caps->he_cap_phy_info_5g,\n\t       sizeof(u32) * PSOC_HOST_MAX_PHY_SIZE);\n\tmemcpy(&cap_band->he_ppet, &mac_phy_caps->he_ppet5g,\n\t       sizeof(struct ath11k_ppe_threshold));\n\n\treturn 0;\n}\n\nstatic int\nath11k_pull_reg_cap_svc_rdy_ext(struct ath11k_pdev_wmi *wmi_handle,\n\t\t\t\tstruct wmi_soc_hal_reg_capabilities *reg_caps,\n\t\t\t\tstruct wmi_hal_reg_capabilities_ext *wmi_ext_reg_cap,\n\t\t\t\tu8 phy_idx,\n\t\t\t\tstruct ath11k_hal_reg_capabilities_ext *param)\n{\n\tstruct wmi_hal_reg_capabilities_ext *ext_reg_cap;\n\n\tif (!reg_caps || !wmi_ext_reg_cap)\n\t\treturn -EINVAL;\n\n\tif (phy_idx >= reg_caps->num_phy)\n\t\treturn -EINVAL;\n\n\text_reg_cap = &wmi_ext_reg_cap[phy_idx];\n\n\tparam->phy_id = ext_reg_cap->phy_id;\n\tparam->eeprom_reg_domain = ext_reg_cap->eeprom_reg_domain;\n\tparam->eeprom_reg_domain_ext =\n\t\t\t      ext_reg_cap->eeprom_reg_domain_ext;\n\tparam->regcap1 = ext_reg_cap->regcap1;\n\tparam->regcap2 = ext_reg_cap->regcap2;\n\t/* check if param->wireless_mode is needed */\n\tparam->low_2ghz_chan = ext_reg_cap->low_2ghz_chan;\n\tparam->high_2ghz_chan = ext_reg_cap->high_2ghz_chan;\n\tparam->low_5ghz_chan = ext_reg_cap->low_5ghz_chan;\n\tparam->high_5ghz_chan = ext_reg_cap->high_5ghz_chan;\n\n\treturn 0;\n}\n\nstatic int ath11k_pull_service_ready_tlv(struct ath11k_base *ab,\n\t\t\t\t\t const void *evt_buf,\n\t\t\t\t\t struct ath11k_targ_cap *cap)\n{\n\tconst struct wmi_service_ready_event *ev = evt_buf;\n\n\tif (!ev) {\n\t\tath11k_err(ab, \"%s: failed by NULL param\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcap->phy_capability = ev->phy_capability;\n\tcap->max_frag_entry = ev->max_frag_entry;\n\tcap->num_rf_chains = ev->num_rf_chains;\n\tcap->ht_cap_info = ev->ht_cap_info;\n\tcap->vht_cap_info = ev->vht_cap_info;\n\tcap->vht_supp_mcs = ev->vht_supp_mcs;\n\tcap->hw_min_tx_power = ev->hw_min_tx_power;\n\tcap->hw_max_tx_power = ev->hw_max_tx_power;\n\tcap->sys_cap_info = ev->sys_cap_info;\n\tcap->min_pkt_size_enable = ev->min_pkt_size_enable;\n\tcap->max_bcn_ie_size = ev->max_bcn_ie_size;\n\tcap->max_num_scan_channels = ev->max_num_scan_channels;\n\tcap->max_supported_macs = ev->max_supported_macs;\n\tcap->wmi_fw_sub_feat_caps = ev->wmi_fw_sub_feat_caps;\n\tcap->txrx_chainmask = ev->txrx_chainmask;\n\tcap->default_dbs_hw_mode_index = ev->default_dbs_hw_mode_index;\n\tcap->num_msdu_desc = ev->num_msdu_desc;\n\n\treturn 0;\n}\n\n/* Save the wmi_service_bitmap into a linear bitmap. The wmi_services in\n * wmi_service ready event are advertised in b0-b3 (LSB 4-bits) of each\n * 4-byte word.\n */\nstatic void ath11k_wmi_service_bitmap_copy(struct ath11k_pdev_wmi *wmi,\n\t\t\t\t\t   const u32 *wmi_svc_bm)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < WMI_SERVICE_BM_SIZE && j < WMI_MAX_SERVICE; i++) {\n\t\tdo {\n\t\t\tif (wmi_svc_bm[i] & BIT(j % WMI_SERVICE_BITS_IN_SIZE32))\n\t\t\t\tset_bit(j, wmi->wmi_ab->svc_map);\n\t\t} while (++j % WMI_SERVICE_BITS_IN_SIZE32);\n\t}\n}\n\nstatic int ath11k_wmi_tlv_svc_rdy_parse(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_ready_parse *svc_ready = data;\n\tstruct ath11k_pdev_wmi *wmi_handle = &ab->wmi_ab.wmi[0];\n\tu16 expect_len;\n\n\tswitch (tag) {\n\tcase WMI_TAG_SERVICE_READY_EVENT:\n\t\tif (ath11k_pull_service_ready_tlv(ab, ptr, &ab->target_caps))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase WMI_TAG_ARRAY_UINT32:\n\t\tif (!svc_ready->wmi_svc_bitmap_done) {\n\t\t\texpect_len = WMI_SERVICE_BM_SIZE * sizeof(u32);\n\t\t\tif (len < expect_len) {\n\t\t\t\tath11k_warn(ab, \"invalid len %d for the tag 0x%x\\n\",\n\t\t\t\t\t    len, tag);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tath11k_wmi_service_bitmap_copy(wmi_handle, ptr);\n\n\t\t\tsvc_ready->wmi_svc_bitmap_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_service_ready_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_tlv_svc_ready_parse svc_ready = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_svc_rdy_parse,\n\t\t\t\t  &svc_ready);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct sk_buff *ath11k_wmi_alloc_skb(struct ath11k_wmi_base *wmi_sc, u32 len)\n{\n\tstruct sk_buff *skb;\n\tstruct ath11k_base *ab = wmi_sc->ab;\n\tu32 round_len = roundup(len, 4);\n\n\tskb = ath11k_htc_alloc_skb(ab, WMI_SKB_HEADROOM + round_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, WMI_SKB_HEADROOM);\n\tif (!IS_ALIGNED((unsigned long)skb->data, 4))\n\t\tath11k_warn(ab, \"unaligned WMI skb data\\n\");\n\n\tskb_put(skb, round_len);\n\tmemset(skb->data, 0, round_len);\n\n\treturn skb;\n}\n\nint ath11k_wmi_mgmt_send(struct ath11k *ar, u32 vdev_id, u32 buf_id,\n\t\t\t struct sk_buff *frame)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_mgmt_send_cmd *cmd;\n\tstruct wmi_tlv *frame_tlv;\n\tstruct sk_buff *skb;\n\tu32 buf_len;\n\tint ret, len;\n\n\tbuf_len = frame->len < WMI_MGMT_SEND_DOWNLD_LEN ?\n\t\t  frame->len : WMI_MGMT_SEND_DOWNLD_LEN;\n\n\tlen = sizeof(*cmd) + sizeof(*frame_tlv) + roundup(buf_len, 4);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_mgmt_send_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_MGMT_TX_SEND_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->desc_id = buf_id;\n\tcmd->chanfreq = 0;\n\tcmd->paddr_lo = lower_32_bits(ATH11K_SKB_CB(frame)->paddr);\n\tcmd->paddr_hi = upper_32_bits(ATH11K_SKB_CB(frame)->paddr);\n\tcmd->frame_len = frame->len;\n\tcmd->buf_len = buf_len;\n\tcmd->tx_params_valid = 0;\n\n\tframe_tlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));\n\tframe_tlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t\t    FIELD_PREP(WMI_TLV_LEN, buf_len);\n\n\tmemcpy(frame_tlv->value, frame->data, buf_len);\n\n\tath11k_ce_byte_swap(frame_tlv->value, buf_len);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_MGMT_TX_SEND_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to submit WMI_MGMT_TX_SEND_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_create(struct ath11k *ar, u8 *macaddr,\n\t\t\t   struct vdev_create_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_create_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_vdev_txrx_streams *txrx_streams;\n\tstruct wmi_tlv *tlv;\n\tint ret, len;\n\tvoid *ptr;\n\n\t/* It can be optimized my sending tx/rx chain configuration\n\t * only for supported bands instead of always sending it for\n\t * both the bands.\n\t */\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE +\n\t\t(WMI_NUM_SUPPORTED_BAND_MAX * sizeof(*txrx_streams));\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_create_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_CREATE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->if_id;\n\tcmd->vdev_type = param->type;\n\tcmd->vdev_subtype = param->subtype;\n\tcmd->num_cfg_txrx_streams = WMI_NUM_SUPPORTED_BAND_MAX;\n\tcmd->pdev_id = param->pdev_id;\n\tether_addr_copy(cmd->vdev_macaddr.addr, macaddr);\n\n\tptr = skb->data + sizeof(*cmd);\n\tlen = WMI_NUM_SUPPORTED_BAND_MAX * sizeof(*txrx_streams);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\tptr += TLV_HDR_SIZE;\n\ttxrx_streams = ptr;\n\tlen = sizeof(*txrx_streams);\n\ttxrx_streams->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_TXRX_STREAMS) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\ttxrx_streams->band = WMI_TPC_CHAINMASK_CONFIG_BAND_2G;\n\ttxrx_streams->supported_tx_streams =\n\t\t\t\t param->chains[NL80211_BAND_2GHZ].tx;\n\ttxrx_streams->supported_rx_streams =\n\t\t\t\t param->chains[NL80211_BAND_2GHZ].rx;\n\n\ttxrx_streams++;\n\ttxrx_streams->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_TXRX_STREAMS) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\ttxrx_streams->band = WMI_TPC_CHAINMASK_CONFIG_BAND_5G;\n\ttxrx_streams->supported_tx_streams =\n\t\t\t\t param->chains[NL80211_BAND_5GHZ].tx;\n\ttxrx_streams->supported_rx_streams =\n\t\t\t\t param->chains[NL80211_BAND_5GHZ].rx;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_CREATE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to submit WMI_VDEV_CREATE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev create: id %d type %d subtype %d macaddr %pM pdevid %d\\n\",\n\t\t   param->if_id, param->type, param->subtype,\n\t\t   macaddr, param->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_delete(struct ath11k *ar, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_delete_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_DELETE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_DELETE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_DELETE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"WMI vdev delete id %d\\n\", vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_stop(struct ath11k *ar, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_stop_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_stop_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_STOP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_STOP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_STOP cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"WMI vdev stop id 0x%x\\n\", vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_down(struct ath11k *ar, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_down_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_down_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_DOWN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_DOWN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_DOWN cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"WMI vdev down id 0x%x\\n\", vdev_id);\n\n\treturn ret;\n}\n\nstatic void ath11k_wmi_put_wmi_channel(struct wmi_channel *chan,\n\t\t\t\t       struct wmi_vdev_start_req_arg *arg)\n{\n\tmemset(chan, 0, sizeof(*chan));\n\n\tchan->mhz = arg->channel.freq;\n\tchan->band_center_freq1 = arg->channel.band_center_freq1;\n\tif (arg->channel.mode == MODE_11AC_VHT80_80)\n\t\tchan->band_center_freq2 = arg->channel.band_center_freq2;\n\telse\n\t\tchan->band_center_freq2 = 0;\n\n\tchan->info |= FIELD_PREP(WMI_CHAN_INFO_MODE, arg->channel.mode);\n\tif (arg->channel.passive)\n\t\tchan->info |= WMI_CHAN_INFO_PASSIVE;\n\tif (arg->channel.allow_ibss)\n\t\tchan->info |= WMI_CHAN_INFO_ADHOC_ALLOWED;\n\tif (arg->channel.allow_ht)\n\t\tchan->info |= WMI_CHAN_INFO_ALLOW_HT;\n\tif (arg->channel.allow_vht)\n\t\tchan->info |= WMI_CHAN_INFO_ALLOW_VHT;\n\tif (arg->channel.allow_he)\n\t\tchan->info |= WMI_CHAN_INFO_ALLOW_HE;\n\tif (arg->channel.ht40plus)\n\t\tchan->info |= WMI_CHAN_INFO_HT40_PLUS;\n\tif (arg->channel.chan_radar)\n\t\tchan->info |= WMI_CHAN_INFO_DFS;\n\tif (arg->channel.freq2_radar)\n\t\tchan->info |= WMI_CHAN_INFO_DFS_FREQ2;\n\n\tchan->reg_info_1 = FIELD_PREP(WMI_CHAN_REG_INFO1_MAX_PWR,\n\t\t\t\t      arg->channel.max_power) |\n\t\tFIELD_PREP(WMI_CHAN_REG_INFO1_MAX_REG_PWR,\n\t\t\t   arg->channel.max_reg_power);\n\n\tchan->reg_info_2 = FIELD_PREP(WMI_CHAN_REG_INFO2_ANT_MAX,\n\t\t\t\t      arg->channel.max_antenna_gain) |\n\t\tFIELD_PREP(WMI_CHAN_REG_INFO2_MAX_TX_PWR,\n\t\t\t   arg->channel.max_power);\n}\n\nint ath11k_wmi_vdev_start(struct ath11k *ar, struct wmi_vdev_start_req_arg *arg,\n\t\t\t  bool restart)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_start_request_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_channel *chan;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint ret, len;\n\n\tif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(*cmd) + sizeof(*chan) + TLV_HDR_SIZE;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_start_request_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_START_REQUEST_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = arg->vdev_id;\n\tcmd->beacon_interval = arg->bcn_intval;\n\tcmd->bcn_tx_rate = arg->bcn_tx_rate;\n\tcmd->dtim_period = arg->dtim_period;\n\tcmd->num_noa_descriptors = arg->num_noa_descriptors;\n\tcmd->preferred_rx_streams = arg->pref_rx_streams;\n\tcmd->preferred_tx_streams = arg->pref_tx_streams;\n\tcmd->cac_duration_ms = arg->cac_duration_ms;\n\tcmd->regdomain = arg->regdomain;\n\tcmd->he_ops = arg->he_ops;\n\n\tif (!restart) {\n\t\tif (arg->ssid) {\n\t\t\tcmd->ssid.ssid_len = arg->ssid_len;\n\t\t\tmemcpy(cmd->ssid.ssid, arg->ssid, arg->ssid_len);\n\t\t}\n\t\tif (arg->hidden_ssid)\n\t\t\tcmd->flags |= WMI_VDEV_START_HIDDEN_SSID;\n\t\tif (arg->pmf_enabled)\n\t\t\tcmd->flags |= WMI_VDEV_START_PMF_ENABLED;\n\t}\n\n\tcmd->flags |= WMI_VDEV_START_LDPC_RX_ENABLED;\n\n\tptr = skb->data + sizeof(*cmd);\n\tchan = ptr;\n\n\tath11k_wmi_put_wmi_channel(chan, arg);\n\n\tchan->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_CHANNEL) |\n\t\t\t   FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t      sizeof(*chan) - TLV_HDR_SIZE);\n\tptr += sizeof(*chan);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, 0);\n\n\t/* Note: This is a nested TLV containing:\n\t * [wmi_tlv][wmi_p2p_noa_descriptor][wmi_tlv]..\n\t */\n\n\tptr += sizeof(*tlv);\n\n\tif (restart)\n\t\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t\t  WMI_VDEV_RESTART_REQUEST_CMDID);\n\telse\n\t\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t\t  WMI_VDEV_START_REQUEST_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit vdev_%s cmd\\n\",\n\t\t\t    restart ? \"restart\" : \"start\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"vdev %s id 0x%x freq 0x%x mode 0x%x\\n\",\n\t\t   restart ? \"restart\" : \"start\", arg->vdev_id,\n\t\t   arg->channel.freq, arg->channel.mode);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_up(struct ath11k *ar, u32 vdev_id, u32 aid, const u8 *bssid)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_up_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_up_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_UP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->vdev_assoc_id = aid;\n\n\tether_addr_copy(cmd->vdev_bssid.addr, bssid);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_UP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_UP cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI mgmt vdev up id 0x%x assoc id %d bssid %pM\\n\",\n\t\t   vdev_id, aid, bssid);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_peer_create_cmd(struct ath11k *ar,\n\t\t\t\t    struct peer_create_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_create_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_create_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_CREATE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, param->peer_addr);\n\tcmd->peer_type = param->peer_type;\n\tcmd->vdev_id = param->vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_CREATE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_PEER_CREATE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI peer create vdev_id %d peer_addr %pM\\n\",\n\t\t   param->vdev_id, param->peer_addr);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_peer_delete_cmd(struct ath11k *ar,\n\t\t\t\t    const u8 *peer_addr, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_delete_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_DELETE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->vdev_id = vdev_id;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI peer delete vdev_id %d peer_addr %pM\\n\",\n\t\t   vdev_id,  peer_addr);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_DELETE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PEER_DELETE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_pdev_set_regdomain(struct ath11k *ar,\n\t\t\t\t       struct pdev_set_regdomain_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_regdomain_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_regdomain_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PDEV_SET_REGDOMAIN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->reg_domain = param->current_rd_in_use;\n\tcmd->reg_domain_2g = param->current_rd_2g;\n\tcmd->reg_domain_5g = param->current_rd_5g;\n\tcmd->conformance_test_limit_2g = param->ctl_2g;\n\tcmd->conformance_test_limit_5g = param->ctl_5g;\n\tcmd->dfs_domain = param->dfs_domain;\n\tcmd->pdev_id = param->pdev_id;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI pdev regd rd %d rd2g %d rd5g %d domain %d pdev id %d\\n\",\n\t\t   param->current_rd_in_use, param->current_rd_2g,\n\t\t   param->current_rd_5g, param->dfs_domain, param->pdev_id);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SET_REGDOMAIN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_REGDOMAIN cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_set_peer_param(struct ath11k *ar, const u8 *peer_addr,\n\t\t\t      u32 vdev_id, u32 param_id, u32 param_val)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_set_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_SET_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->vdev_id = vdev_id;\n\tcmd->param_id = param_id;\n\tcmd->param_value = param_val;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_SET_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PEER_SET_PARAM cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev %d peer 0x%pM set param %d value %d\\n\",\n\t\t   vdev_id, peer_addr, param_id, param_val);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_peer_flush_tids_cmd(struct ath11k *ar,\n\t\t\t\t\tu8 peer_addr[ETH_ALEN],\n\t\t\t\t\tstruct peer_flush_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_flush_tids_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_flush_tids_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_FLUSH_TIDS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->peer_tid_bitmap = param->peer_tid_bitmap;\n\tcmd->vdev_id = param->vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_FLUSH_TIDS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_FLUSH_TIDS cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI peer flush vdev_id %d peer_addr %pM tids %08x\\n\",\n\t\t   param->vdev_id, peer_addr, param->peer_tid_bitmap);\n\n\treturn ret;\n}\n\nint ath11k_wmi_peer_rx_reorder_queue_setup(struct ath11k *ar,\n\t\t\t\t\t   int vdev_id, const u8 *addr,\n\t\t\t\t\t   dma_addr_t paddr, u8 tid,\n\t\t\t\t\t   u8 ba_window_size_valid,\n\t\t\t\t\t   u32 ba_window_size)\n{\n\tstruct wmi_peer_reorder_queue_setup_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_reorder_queue_setup_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_REORDER_QUEUE_SETUP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, addr);\n\tcmd->vdev_id = vdev_id;\n\tcmd->tid = tid;\n\tcmd->queue_ptr_lo = lower_32_bits(paddr);\n\tcmd->queue_ptr_hi = upper_32_bits(paddr);\n\tcmd->queue_no = tid;\n\tcmd->ba_window_size_valid = ba_window_size_valid;\n\tcmd->ba_window_size = ba_window_size;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_PEER_REORDER_QUEUE_SETUP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_REORDER_QUEUE_SETUP\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi rx reorder queue setup addr %pM vdev_id %d tid %d\\n\",\n\t\t   addr, vdev_id, tid);\n\n\treturn ret;\n}\n\nint\nath11k_wmi_rx_reord_queue_remove(struct ath11k *ar,\n\t\t\t\t struct rx_reorder_queue_remove_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_reorder_queue_remove_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_reorder_queue_remove_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_REORDER_QUEUE_REMOVE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, param->peer_macaddr);\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->tid_mask = param->peer_tid_bitmap;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"%s: peer_macaddr %pM vdev_id %d, tid_map %d\", __func__,\n\t\t   param->peer_macaddr, param->vdev_id, param->peer_tid_bitmap);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PEER_REORDER_QUEUE_REMOVE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_REORDER_QUEUE_REMOVE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_set_param(struct ath11k *ar, u32 param_id,\n\t\t\t      u32 param_value, u8 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SET_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\tcmd->param_id = param_id;\n\tcmd->param_value = param_value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SET_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_SET_PARAM cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI pdev set param %d pdev id %d value %d\\n\",\n\t\t   param_id, pdev_id, param_value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_set_ps_mode(struct ath11k *ar, int vdev_id, u32 enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_ps_mode_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_ps_mode_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_STA_POWERSAVE_MODE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->sta_ps_mode = enable;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_STA_POWERSAVE_MODE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_SET_PARAM cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev set psmode %d vdev id %d\\n\",\n\t\t   enable, vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_suspend(struct ath11k *ar, u32 suspend_opt,\n\t\t\t    u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_suspend_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_suspend_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SUSPEND_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->suspend_opt = suspend_opt;\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SUSPEND_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_SUSPEND cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI pdev suspend pdev_id %d\\n\", pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_resume(struct ath11k *ar, u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_resume_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_resume_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_RESUME_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI pdev resume pdev id %d\\n\", pdev_id);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_RESUME_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_RESUME cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\n/* TODO FW Support for the cmd is not available yet.\n * Can be tested once the command and corresponding\n * event is implemented in FW\n */\nint ath11k_wmi_pdev_bss_chan_info_request(struct ath11k *ar,\n\t\t\t\t\t  enum wmi_bss_chan_info_req_type type)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_bss_chan_info_req_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_bss_chan_info_req_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PDEV_BSS_CHAN_INFO_REQUEST) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->req_type = type;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI bss chan info req type %d\\n\", type);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_BSS_CHAN_INFO_REQUEST_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PDEV_BSS_CHAN_INFO_REQUEST cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_set_ap_ps_param_cmd(struct ath11k *ar, u8 *peer_addr,\n\t\t\t\t\tstruct ap_ps_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_ap_ps_peer_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_ap_ps_peer_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_AP_PS_PEER_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->param = param->param;\n\tcmd->value = param->value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_AP_PS_PEER_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_AP_PS_PEER_PARAM_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI set ap ps vdev id %d peer %pM param %d value %d\\n\",\n\t\t   param->vdev_id, peer_addr, param->param, param->value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_set_sta_ps_param(struct ath11k *ar, u32 vdev_id,\n\t\t\t\tu32 param, u32 param_value)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_sta_powersave_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_sta_powersave_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_STA_POWERSAVE_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->param = param;\n\tcmd->value = param_value;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI set sta ps vdev_id %d param %d value %d\\n\",\n\t\t   vdev_id, param, param_value);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_STA_POWERSAVE_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_STA_POWERSAVE_PARAM_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_force_fw_hang_cmd(struct ath11k *ar, u32 type, u32 delay_time_ms)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_force_fw_hang_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_force_fw_hang_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_FORCE_FW_HANG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->type = type;\n\tcmd->delay_time_ms = delay_time_ms;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_FORCE_FW_HANG_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"Failed to send WMI_FORCE_FW_HANG_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_set_param_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t  u32 param_id, u32 param_value)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_set_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_SET_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->param_id = param_id;\n\tcmd->param_value = param_value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_SET_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_VDEV_SET_PARAM_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev id 0x%x set param %d value %d\\n\",\n\t\t   vdev_id, param_id, param_value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_stats_request_cmd(struct ath11k *ar,\n\t\t\t\t      struct stats_request_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_request_stats_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_request_stats_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_REQUEST_STATS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->stats_id = param->stats_id;\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->pdev_id = param->pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_REQUEST_STATS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_REQUEST_STATS cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI request stats 0x%x vdev id %d pdev id %d\\n\",\n\t\t   param->stats_id, param->vdev_id, param->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_pdev_temperature_cmd(struct ath11k *ar)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_get_pdev_temperature_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_get_pdev_temperature_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_GET_TEMPERATURE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_GET_TEMPERATURE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_GET_TEMPERATURE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI pdev get temperature for pdev_id %d\\n\", ar->pdev->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_bcn_offload_control_cmd(struct ath11k *ar,\n\t\t\t\t\t    u32 vdev_id, u32 bcn_ctrl_op)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_bcn_offload_ctrl_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bcn_offload_ctrl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_BCN_OFFLOAD_CTRL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->bcn_ctrl_op = bcn_ctrl_op;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI bcn ctrl offload vdev id %d ctrl_op %d\\n\",\n\t\t   vdev_id, bcn_ctrl_op);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_BCN_OFFLOAD_CTRL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_BCN_OFFLOAD_CTRL_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_bcn_tmpl(struct ath11k *ar, u32 vdev_id,\n\t\t\tstruct ieee80211_mutable_offsets *offs,\n\t\t\tstruct sk_buff *bcn)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_bcn_tmpl_cmd *cmd;\n\tstruct wmi_bcn_prb_info *bcn_prb_info;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tint ret, len;\n\tsize_t aligned_len = roundup(bcn->len, 4);\n\n\tlen = sizeof(*cmd) + sizeof(*bcn_prb_info) + TLV_HDR_SIZE + aligned_len;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bcn_tmpl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_BCN_TMPL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->tim_ie_offset = offs->tim_offset;\n\tcmd->csa_switch_count_offset = offs->cntdwn_counter_offs[0];\n\tcmd->ext_csa_switch_count_offset = offs->cntdwn_counter_offs[1];\n\tcmd->buf_len = bcn->len;\n\n\tptr = skb->data + sizeof(*cmd);\n\n\tbcn_prb_info = ptr;\n\tlen = sizeof(*bcn_prb_info);\n\tbcn_prb_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t      WMI_TAG_BCN_PRB_INFO) |\n\t\t\t\t   FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tbcn_prb_info->caps = 0;\n\tbcn_prb_info->erp = 0;\n\n\tptr += sizeof(*bcn_prb_info);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, aligned_len);\n\tmemcpy(tlv->value, bcn->data, bcn->len);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_BCN_TMPL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_BCN_TMPL_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_install_key(struct ath11k *ar,\n\t\t\t\tstruct wmi_vdev_install_key_arg *arg)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_install_key_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\tint key_len_aligned = roundup(arg->key_len, sizeof(uint32_t));\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + key_len_aligned;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_install_key_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_INSTALL_KEY_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = arg->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, arg->macaddr);\n\tcmd->key_idx = arg->key_idx;\n\tcmd->key_flags = arg->key_flags;\n\tcmd->key_cipher = arg->key_cipher;\n\tcmd->key_len = arg->key_len;\n\tcmd->key_txmic_len = arg->key_txmic_len;\n\tcmd->key_rxmic_len = arg->key_rxmic_len;\n\n\tif (arg->key_rsc_counter)\n\t\tmemcpy(&cmd->key_rsc_counter, &arg->key_rsc_counter,\n\t\t       sizeof(struct wmi_key_seq_counter));\n\n\ttlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, key_len_aligned);\n\tmemcpy(tlv->value, (u8 *)arg->key_data, key_len_aligned);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_INSTALL_KEY_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_VDEV_INSTALL_KEY cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev install key idx %d cipher %d len %d\\n\",\n\t\t   arg->key_idx, arg->key_cipher, arg->key_len);\n\n\treturn ret;\n}\n\nstatic inline void\nath11k_wmi_copy_peer_flags(struct wmi_peer_assoc_complete_cmd *cmd,\n\t\t\t   struct peer_assoc_params *param,\n\t\t\t   bool hw_crypto_disabled)\n{\n\tcmd->peer_flags = 0;\n\n\tif (param->is_wme_set) {\n\t\tif (param->qos_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_QOS;\n\t\tif (param->apsd_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_APSD;\n\t\tif (param->ht_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_HT;\n\t\tif (param->bw_40)\n\t\t\tcmd->peer_flags |= WMI_PEER_40MHZ;\n\t\tif (param->bw_80)\n\t\t\tcmd->peer_flags |= WMI_PEER_80MHZ;\n\t\tif (param->bw_160)\n\t\t\tcmd->peer_flags |= WMI_PEER_160MHZ;\n\n\t\t/* Typically if STBC is enabled for VHT it should be enabled\n\t\t * for HT as well\n\t\t **/\n\t\tif (param->stbc_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_STBC;\n\n\t\t/* Typically if LDPC is enabled for VHT it should be enabled\n\t\t * for HT as well\n\t\t **/\n\t\tif (param->ldpc_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_LDPC;\n\n\t\tif (param->static_mimops_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_STATIC_MIMOPS;\n\t\tif (param->dynamic_mimops_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_DYN_MIMOPS;\n\t\tif (param->spatial_mux_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_SPATIAL_MUX;\n\t\tif (param->vht_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_VHT;\n\t\tif (param->he_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_HE;\n\t\tif (param->twt_requester)\n\t\t\tcmd->peer_flags |= WMI_PEER_TWT_REQ;\n\t\tif (param->twt_responder)\n\t\t\tcmd->peer_flags |= WMI_PEER_TWT_RESP;\n\t}\n\n\t/* Suppress authorization for all AUTH modes that need 4-way handshake\n\t * (during re-association).\n\t * Authorization will be done for these modes on key installation.\n\t */\n\tif (param->auth_flag)\n\t\tcmd->peer_flags |= WMI_PEER_AUTH;\n\tif (param->need_ptk_4_way) {\n\t\tcmd->peer_flags |= WMI_PEER_NEED_PTK_4_WAY;\n\t\tif (!hw_crypto_disabled)\n\t\t\tcmd->peer_flags &= ~WMI_PEER_AUTH;\n\t}\n\tif (param->need_gtk_2_way)\n\t\tcmd->peer_flags |= WMI_PEER_NEED_GTK_2_WAY;\n\t/* safe mode bypass the 4-way handshake */\n\tif (param->safe_mode_enabled)\n\t\tcmd->peer_flags &= ~(WMI_PEER_NEED_PTK_4_WAY |\n\t\t\t\t     WMI_PEER_NEED_GTK_2_WAY);\n\n\tif (param->is_pmf_enabled)\n\t\tcmd->peer_flags |= WMI_PEER_PMF;\n\n\t/* Disable AMSDU for station transmit, if user configures it */\n\t/* Disable AMSDU for AP transmit to 11n Stations, if user configures\n\t * it\n\t * if (param->amsdu_disable) Add after FW support\n\t **/\n\n\t/* Target asserts if node is marked HT and all MCS is set to 0.\n\t * Mark the node as non-HT if all the mcs rates are disabled through\n\t * iwpriv\n\t **/\n\tif (param->peer_ht_rates.num_rates == 0)\n\t\tcmd->peer_flags &= ~WMI_PEER_HT;\n}\n\nint ath11k_wmi_send_peer_assoc_cmd(struct ath11k *ar,\n\t\t\t\t   struct peer_assoc_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_assoc_complete_cmd *cmd;\n\tstruct wmi_vht_rate_set *mcs;\n\tstruct wmi_he_rate_set *he_mcs;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tu32 peer_legacy_rates_align;\n\tu32 peer_ht_rates_align;\n\tint i, ret, len;\n\n\tpeer_legacy_rates_align = roundup(param->peer_legacy_rates.num_rates,\n\t\t\t\t\t  sizeof(u32));\n\tpeer_ht_rates_align = roundup(param->peer_ht_rates.num_rates,\n\t\t\t\t      sizeof(u32));\n\n\tlen = sizeof(*cmd) +\n\t      TLV_HDR_SIZE + (peer_legacy_rates_align * sizeof(u8)) +\n\t      TLV_HDR_SIZE + (peer_ht_rates_align * sizeof(u8)) +\n\t      sizeof(*mcs) + TLV_HDR_SIZE +\n\t      (sizeof(*he_mcs) * param->peer_he_mcs_count);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tptr = skb->data;\n\n\tcmd = ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PEER_ASSOC_COMPLETE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\n\tcmd->peer_new_assoc = param->peer_new_assoc;\n\tcmd->peer_associd = param->peer_associd;\n\n\tath11k_wmi_copy_peer_flags(cmd, param,\n\t\t\t\t   test_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED,\n\t\t\t\t\t    &ar->ab->dev_flags));\n\n\tether_addr_copy(cmd->peer_macaddr.addr, param->peer_mac);\n\n\tcmd->peer_rate_caps = param->peer_rate_caps;\n\tcmd->peer_caps = param->peer_caps;\n\tcmd->peer_listen_intval = param->peer_listen_intval;\n\tcmd->peer_ht_caps = param->peer_ht_caps;\n\tcmd->peer_max_mpdu = param->peer_max_mpdu;\n\tcmd->peer_mpdu_density = param->peer_mpdu_density;\n\tcmd->peer_vht_caps = param->peer_vht_caps;\n\tcmd->peer_phymode = param->peer_phymode;\n\n\t/* Update 11ax capabilities */\n\tcmd->peer_he_cap_info = param->peer_he_cap_macinfo[0];\n\tcmd->peer_he_cap_info_ext = param->peer_he_cap_macinfo[1];\n\tcmd->peer_he_cap_info_internal = param->peer_he_cap_macinfo_internal;\n\tcmd->peer_he_caps_6ghz = param->peer_he_caps_6ghz;\n\tcmd->peer_he_ops = param->peer_he_ops;\n\tmemcpy(&cmd->peer_he_cap_phy, &param->peer_he_cap_phyinfo,\n\t       sizeof(param->peer_he_cap_phyinfo));\n\tmemcpy(&cmd->peer_ppet, &param->peer_ppet,\n\t       sizeof(param->peer_ppet));\n\n\t/* Update peer legacy rate information */\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, peer_legacy_rates_align);\n\n\tptr += TLV_HDR_SIZE;\n\n\tcmd->num_peer_legacy_rates = param->peer_legacy_rates.num_rates;\n\tmemcpy(ptr, param->peer_legacy_rates.rates,\n\t       param->peer_legacy_rates.num_rates);\n\n\t/* Update peer HT rate information */\n\tptr += peer_legacy_rates_align;\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, peer_ht_rates_align);\n\tptr += TLV_HDR_SIZE;\n\tcmd->num_peer_ht_rates = param->peer_ht_rates.num_rates;\n\tmemcpy(ptr, param->peer_ht_rates.rates,\n\t       param->peer_ht_rates.num_rates);\n\n\t/* VHT Rates */\n\tptr += peer_ht_rates_align;\n\n\tmcs = ptr;\n\n\tmcs->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VHT_RATE_SET) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*mcs) - TLV_HDR_SIZE);\n\n\tcmd->peer_nss = param->peer_nss;\n\n\t/* Update bandwidth-NSS mapping */\n\tcmd->peer_bw_rxnss_override = 0;\n\tcmd->peer_bw_rxnss_override |= param->peer_bw_rxnss_override;\n\n\tif (param->vht_capable) {\n\t\tmcs->rx_max_rate = param->rx_max_rate;\n\t\tmcs->rx_mcs_set = param->rx_mcs_set;\n\t\tmcs->tx_max_rate = param->tx_max_rate;\n\t\tmcs->tx_mcs_set = param->tx_mcs_set;\n\t}\n\n\t/* HE Rates */\n\tcmd->peer_he_mcs = param->peer_he_mcs_count;\n\tcmd->min_data_rate = param->min_data_rate;\n\n\tptr += sizeof(*mcs);\n\n\tlen = param->peer_he_mcs_count * sizeof(*he_mcs);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE;\n\n\t/* Loop through the HE rate set */\n\tfor (i = 0; i < param->peer_he_mcs_count; i++) {\n\t\the_mcs = ptr;\n\t\the_mcs->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\tWMI_TAG_HE_RATE_SET) |\n\t\t\t\t     FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\tsizeof(*he_mcs) - TLV_HDR_SIZE);\n\n\t\the_mcs->rx_mcs_set = param->peer_he_rx_mcs_set[i];\n\t\the_mcs->tx_mcs_set = param->peer_he_tx_mcs_set[i];\n\t\tptr += sizeof(*he_mcs);\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_ASSOC_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_ASSOC_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi peer assoc vdev id %d assoc id %d peer mac %pM peer_flags %x rate_caps %x peer_caps %x listen_intval %d ht_caps %x max_mpdu %d nss %d phymode %d peer_mpdu_density %d vht_caps %x he cap_info %x he ops %x he cap_info_ext %x he phy %x %x %x peer_bw_rxnss_override %x\\n\",\n\t\t   cmd->vdev_id, cmd->peer_associd, param->peer_mac,\n\t\t   cmd->peer_flags, cmd->peer_rate_caps, cmd->peer_caps,\n\t\t   cmd->peer_listen_intval, cmd->peer_ht_caps,\n\t\t   cmd->peer_max_mpdu, cmd->peer_nss, cmd->peer_phymode,\n\t\t   cmd->peer_mpdu_density,\n\t\t   cmd->peer_vht_caps, cmd->peer_he_cap_info,\n\t\t   cmd->peer_he_ops, cmd->peer_he_cap_info_ext,\n\t\t   cmd->peer_he_cap_phy[0], cmd->peer_he_cap_phy[1],\n\t\t   cmd->peer_he_cap_phy[2],\n\t\t   cmd->peer_bw_rxnss_override);\n\n\treturn ret;\n}\n\nvoid ath11k_wmi_start_scan_init(struct ath11k *ar,\n\t\t\t\tstruct scan_req_params *arg)\n{\n\t/* setup commonly used values */\n\targ->scan_req_id = 1;\n\targ->scan_priority = WMI_SCAN_PRIORITY_LOW;\n\targ->dwell_time_active = 50;\n\targ->dwell_time_active_2g = 0;\n\targ->dwell_time_passive = 150;\n\targ->dwell_time_active_6g = 40;\n\targ->dwell_time_passive_6g = 30;\n\targ->min_rest_time = 50;\n\targ->max_rest_time = 500;\n\targ->repeat_probe_time = 0;\n\targ->probe_spacing_time = 0;\n\targ->idle_time = 0;\n\targ->max_scan_time = 20000;\n\targ->probe_delay = 5;\n\targ->notify_scan_events = WMI_SCAN_EVENT_STARTED |\n\t\t\t\t  WMI_SCAN_EVENT_COMPLETED |\n\t\t\t\t  WMI_SCAN_EVENT_BSS_CHANNEL |\n\t\t\t\t  WMI_SCAN_EVENT_FOREIGN_CHAN |\n\t\t\t\t  WMI_SCAN_EVENT_DEQUEUED;\n\targ->scan_flags |= WMI_SCAN_CHAN_STAT_EVENT;\n\targ->num_bssid = 1;\n\n\t/* fill bssid_list[0] with 0xff, otherwise bssid and RA will be\n\t * ZEROs in probe request\n\t */\n\teth_broadcast_addr(arg->bssid_list[0].addr);\n}\n\nstatic inline void\nath11k_wmi_copy_scan_event_cntrl_flags(struct wmi_start_scan_cmd *cmd,\n\t\t\t\t       struct scan_req_params *param)\n{\n\t/* Scan events subscription */\n\tif (param->scan_ev_started)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_STARTED;\n\tif (param->scan_ev_completed)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_COMPLETED;\n\tif (param->scan_ev_bss_chan)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_BSS_CHANNEL;\n\tif (param->scan_ev_foreign_chan)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_FOREIGN_CHAN;\n\tif (param->scan_ev_dequeued)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_DEQUEUED;\n\tif (param->scan_ev_preempted)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_PREEMPTED;\n\tif (param->scan_ev_start_failed)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_START_FAILED;\n\tif (param->scan_ev_restarted)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_RESTARTED;\n\tif (param->scan_ev_foreign_chn_exit)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_FOREIGN_CHAN_EXIT;\n\tif (param->scan_ev_suspended)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_SUSPENDED;\n\tif (param->scan_ev_resumed)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_RESUMED;\n\n\t/** Set scan control flags */\n\tcmd->scan_ctrl_flags = 0;\n\tif (param->scan_f_passive)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_PASSIVE;\n\tif (param->scan_f_strict_passive_pch)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_STRICT_PASSIVE_ON_PCHN;\n\tif (param->scan_f_promisc_mode)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FILTER_PROMISCUOS;\n\tif (param->scan_f_capture_phy_err)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_CAPTURE_PHY_ERROR;\n\tif (param->scan_f_half_rate)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_HALF_RATE_SUPPORT;\n\tif (param->scan_f_quarter_rate)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_QUARTER_RATE_SUPPORT;\n\tif (param->scan_f_cck_rates)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_CCK_RATES;\n\tif (param->scan_f_ofdm_rates)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_OFDM_RATES;\n\tif (param->scan_f_chan_stat_evnt)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_CHAN_STAT_EVENT;\n\tif (param->scan_f_filter_prb_req)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FILTER_PROBE_REQ;\n\tif (param->scan_f_bcast_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_BCAST_PROBE_REQ;\n\tif (param->scan_f_offchan_mgmt_tx)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_OFFCHAN_MGMT_TX;\n\tif (param->scan_f_offchan_data_tx)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_OFFCHAN_DATA_TX;\n\tif (param->scan_f_force_active_dfs_chn)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_FORCE_ACTIVE_ON_DFS;\n\tif (param->scan_f_add_tpc_ie_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_TPC_IE_IN_PROBE_REQ;\n\tif (param->scan_f_add_ds_ie_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_DS_IE_IN_PROBE_REQ;\n\tif (param->scan_f_add_spoofed_mac_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_SPOOF_MAC_IN_PROBE_REQ;\n\tif (param->scan_f_add_rand_seq_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_RANDOM_SEQ_NO_IN_PROBE_REQ;\n\tif (param->scan_f_en_ie_whitelist_in_probe)\n\t\tcmd->scan_ctrl_flags |=\n\t\t\t WMI_SCAN_ENABLE_IE_WHTELIST_IN_PROBE_REQ;\n\n\t/* for adaptive scan mode using 3 bits (21 - 23 bits) */\n\tWMI_SCAN_SET_DWELL_MODE(cmd->scan_ctrl_flags,\n\t\t\t\tparam->adaptive_dwell_time_mode);\n}\n\nint ath11k_wmi_send_scan_start_cmd(struct ath11k *ar,\n\t\t\t\t   struct scan_req_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_start_scan_cmd *cmd;\n\tstruct wmi_ssid *ssid = NULL;\n\tstruct wmi_mac_addr *bssid;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint i, ret, len;\n\tu32 *tmp_ptr;\n\tu8 extraie_len_with_pad = 0;\n\tstruct hint_short_ssid *s_ssid = NULL;\n\tstruct hint_bssid *hint_bssid = NULL;\n\n\tlen = sizeof(*cmd);\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->num_chan)\n\t\tlen += params->num_chan * sizeof(u32);\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->num_ssids)\n\t\tlen += params->num_ssids * sizeof(*ssid);\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->num_bssid)\n\t\tlen += sizeof(*bssid) * params->num_bssid;\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->extraie.len)\n\t\textraie_len_with_pad =\n\t\t\troundup(params->extraie.len, sizeof(u32));\n\tlen += extraie_len_with_pad;\n\n\tif (params->num_hint_bssid)\n\t\tlen += TLV_HDR_SIZE +\n\t\t       params->num_hint_bssid * sizeof(struct hint_bssid);\n\n\tif (params->num_hint_s_ssid)\n\t\tlen += TLV_HDR_SIZE +\n\t\t       params->num_hint_s_ssid * sizeof(struct hint_short_ssid);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tptr = skb->data;\n\n\tcmd = ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_START_SCAN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->scan_id = params->scan_id;\n\tcmd->scan_req_id = params->scan_req_id;\n\tcmd->vdev_id = params->vdev_id;\n\tcmd->scan_priority = params->scan_priority;\n\tcmd->notify_scan_events = params->notify_scan_events;\n\n\tath11k_wmi_copy_scan_event_cntrl_flags(cmd, params);\n\n\tcmd->dwell_time_active = params->dwell_time_active;\n\tcmd->dwell_time_active_2g = params->dwell_time_active_2g;\n\tcmd->dwell_time_passive = params->dwell_time_passive;\n\tcmd->dwell_time_active_6g = params->dwell_time_active_6g;\n\tcmd->dwell_time_passive_6g = params->dwell_time_passive_6g;\n\tcmd->min_rest_time = params->min_rest_time;\n\tcmd->max_rest_time = params->max_rest_time;\n\tcmd->repeat_probe_time = params->repeat_probe_time;\n\tcmd->probe_spacing_time = params->probe_spacing_time;\n\tcmd->idle_time = params->idle_time;\n\tcmd->max_scan_time = params->max_scan_time;\n\tcmd->probe_delay = params->probe_delay;\n\tcmd->burst_duration = params->burst_duration;\n\tcmd->num_chan = params->num_chan;\n\tcmd->num_bssid = params->num_bssid;\n\tcmd->num_ssids = params->num_ssids;\n\tcmd->ie_len = params->extraie.len;\n\tcmd->n_probes = params->n_probes;\n\n\tptr += sizeof(*cmd);\n\n\tlen = params->num_chan * sizeof(u32);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE;\n\ttmp_ptr = (u32 *)ptr;\n\n\tfor (i = 0; i < params->num_chan; ++i)\n\t\ttmp_ptr[i] = params->chan_list[i];\n\n\tptr += len;\n\n\tlen = params->num_ssids * sizeof(*ssid);\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\tptr += TLV_HDR_SIZE;\n\n\tif (params->num_ssids) {\n\t\tssid = ptr;\n\t\tfor (i = 0; i < params->num_ssids; ++i) {\n\t\t\tssid->ssid_len = params->ssid[i].length;\n\t\t\tmemcpy(ssid->ssid, params->ssid[i].ssid,\n\t\t\t       params->ssid[i].length);\n\t\t\tssid++;\n\t\t}\n\t}\n\n\tptr += (params->num_ssids * sizeof(*ssid));\n\tlen = params->num_bssid * sizeof(*bssid);\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\tptr += TLV_HDR_SIZE;\n\tbssid = ptr;\n\n\tif (params->num_bssid) {\n\t\tfor (i = 0; i < params->num_bssid; ++i) {\n\t\t\tether_addr_copy(bssid->addr,\n\t\t\t\t\tparams->bssid_list[i].addr);\n\t\t\tbssid++;\n\t\t}\n\t}\n\n\tptr += params->num_bssid * sizeof(*bssid);\n\n\tlen = extraie_len_with_pad;\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE;\n\n\tif (params->extraie.len)\n\t\tmemcpy(ptr, params->extraie.ptr,\n\t\t       params->extraie.len);\n\n\tptr += extraie_len_with_pad;\n\n\tif (params->num_hint_s_ssid) {\n\t\tlen = params->num_hint_s_ssid * sizeof(struct hint_short_ssid);\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\t\tptr += TLV_HDR_SIZE;\n\t\ts_ssid = ptr;\n\t\tfor (i = 0; i < params->num_hint_s_ssid; ++i) {\n\t\t\ts_ssid->freq_flags = params->hint_s_ssid[i].freq_flags;\n\t\t\ts_ssid->short_ssid = params->hint_s_ssid[i].short_ssid;\n\t\t\ts_ssid++;\n\t\t}\n\t\tptr += len;\n\t}\n\n\tif (params->num_hint_bssid) {\n\t\tlen = params->num_hint_bssid * sizeof(struct hint_bssid);\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\t\tptr += TLV_HDR_SIZE;\n\t\thint_bssid = ptr;\n\t\tfor (i = 0; i < params->num_hint_bssid; ++i) {\n\t\t\thint_bssid->freq_flags =\n\t\t\t\tparams->hint_bssid[i].freq_flags;\n\t\t\tether_addr_copy(&params->hint_bssid[i].bssid.addr[0],\n\t\t\t\t\t&hint_bssid->bssid.addr[0]);\n\t\t\thint_bssid++;\n\t\t}\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_START_SCAN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_START_SCAN_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_scan_stop_cmd(struct ath11k *ar,\n\t\t\t\t  struct scan_cancel_param *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_stop_scan_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_stop_scan_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_STOP_SCAN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->requestor = param->requester;\n\tcmd->scan_id = param->scan_id;\n\tcmd->pdev_id = param->pdev_id;\n\t/* stop the scan with the corresponding scan_id */\n\tif (param->req_type == WLAN_SCAN_CANCEL_PDEV_ALL) {\n\t\t/* Cancelling all scans */\n\t\tcmd->req_type =  WMI_SCAN_STOP_ALL;\n\t} else if (param->req_type == WLAN_SCAN_CANCEL_VDEV_ALL) {\n\t\t/* Cancelling VAP scans */\n\t\tcmd->req_type =  WMI_SCN_STOP_VAP_ALL;\n\t} else if (param->req_type == WLAN_SCAN_CANCEL_SINGLE) {\n\t\t/* Cancelling specific scan */\n\t\tcmd->req_type =  WMI_SCAN_STOP_ONE;\n\t} else {\n\t\tath11k_warn(ar->ab, \"invalid scan cancel param %d\",\n\t\t\t    param->req_type);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_STOP_SCAN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_STOP_SCAN_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_scan_chan_list_cmd(struct ath11k *ar,\n\t\t\t\t       struct scan_chan_list_params *chan_list)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_scan_chan_list_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_channel *chan_info;\n\tstruct channel_param *tchan_info;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint i, ret, len;\n\tu16 num_send_chans, num_sends = 0, max_chan_limit = 0;\n\tu32 *reg1, *reg2;\n\n\ttchan_info = &chan_list->ch_param[0];\n\twhile (chan_list->nallchans) {\n\t\tlen = sizeof(*cmd) + TLV_HDR_SIZE;\n\t\tmax_chan_limit = (wmi->wmi_ab->max_msg_len[ar->pdev_idx] - len) /\n\t\t\tsizeof(*chan_info);\n\n\t\tif (chan_list->nallchans > max_chan_limit)\n\t\t\tnum_send_chans = max_chan_limit;\n\t\telse\n\t\t\tnum_send_chans = chan_list->nallchans;\n\n\t\tchan_list->nallchans -= num_send_chans;\n\t\tlen += sizeof(*chan_info) * num_send_chans;\n\n\t\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tcmd = (struct wmi_scan_chan_list_cmd *)skb->data;\n\t\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_SCAN_CHAN_LIST_CMD) |\n\t\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\t\tcmd->pdev_id = chan_list->pdev_id;\n\t\tcmd->num_scan_chans = num_send_chans;\n\t\tif (num_sends)\n\t\t\tcmd->flags |= WMI_APPEND_TO_EXISTING_CHAN_LIST_FLAG;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t   \"WMI no.of chan = %d len = %d pdev_id = %d num_sends = %d\\n\",\n\t\t\t   num_send_chans, len, cmd->pdev_id, num_sends);\n\n\t\tptr = skb->data + sizeof(*cmd);\n\n\t\tlen = sizeof(*chan_info) * num_send_chans;\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\t\tptr += TLV_HDR_SIZE;\n\n\t\tfor (i = 0; i < num_send_chans; ++i) {\n\t\t\tchan_info = ptr;\n\t\t\tmemset(chan_info, 0, sizeof(*chan_info));\n\t\t\tlen = sizeof(*chan_info);\n\t\t\tchan_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\t\t   WMI_TAG_CHANNEL) |\n\t\t\t\t\t\tFIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\t\t   len - TLV_HDR_SIZE);\n\n\t\t\treg1 = &chan_info->reg_info_1;\n\t\t\treg2 = &chan_info->reg_info_2;\n\t\t\tchan_info->mhz = tchan_info->mhz;\n\t\t\tchan_info->band_center_freq1 = tchan_info->cfreq1;\n\t\t\tchan_info->band_center_freq2 = tchan_info->cfreq2;\n\n\t\t\tif (tchan_info->is_chan_passive)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_PASSIVE;\n\t\t\tif (tchan_info->allow_he)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_ALLOW_HE;\n\t\t\telse if (tchan_info->allow_vht)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_ALLOW_VHT;\n\t\t\telse if (tchan_info->allow_ht)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_ALLOW_HT;\n\t\t\tif (tchan_info->half_rate)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_HALF_RATE;\n\t\t\tif (tchan_info->quarter_rate)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_QUARTER_RATE;\n\t\t\tif (tchan_info->psc_channel)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_PSC;\n\n\t\t\tchan_info->info |= FIELD_PREP(WMI_CHAN_INFO_MODE,\n\t\t\t\t\t\t      tchan_info->phy_mode);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_MIN_PWR,\n\t\t\t\t\t    tchan_info->minpower);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_MAX_PWR,\n\t\t\t\t\t    tchan_info->maxpower);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_MAX_REG_PWR,\n\t\t\t\t\t    tchan_info->maxregpower);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_REG_CLS,\n\t\t\t\t\t    tchan_info->reg_class_id);\n\t\t\t*reg2 |= FIELD_PREP(WMI_CHAN_REG_INFO2_ANT_MAX,\n\t\t\t\t\t    tchan_info->antennamax);\n\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t\t   \"WMI chan scan list chan[%d] = %u, chan_info->info %8x\\n\",\n\t\t\t\t   i, chan_info->mhz, chan_info->info);\n\n\t\t\tptr += sizeof(*chan_info);\n\n\t\t\ttchan_info++;\n\t\t}\n\n\t\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_SCAN_CHAN_LIST_CMDID);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to send WMI_SCAN_CHAN_LIST cmd\\n\");\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnum_sends++;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_wmm_update_cmd_tlv(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t       struct wmi_wmm_params_all_arg *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_set_wmm_params_cmd *cmd;\n\tstruct wmi_wmm_params *wmm_param;\n\tstruct wmi_wmm_params_arg *wmi_wmm_arg;\n\tstruct sk_buff *skb;\n\tint ret, ac;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_set_wmm_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_SET_WMM_PARAMS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->wmm_param_type = 0;\n\n\tfor (ac = 0; ac < WME_NUM_AC; ac++) {\n\t\tswitch (ac) {\n\t\tcase WME_AC_BE:\n\t\t\twmi_wmm_arg = &param->ac_be;\n\t\t\tbreak;\n\t\tcase WME_AC_BK:\n\t\t\twmi_wmm_arg = &param->ac_bk;\n\t\t\tbreak;\n\t\tcase WME_AC_VI:\n\t\t\twmi_wmm_arg = &param->ac_vi;\n\t\t\tbreak;\n\t\tcase WME_AC_VO:\n\t\t\twmi_wmm_arg = &param->ac_vo;\n\t\t\tbreak;\n\t\t}\n\n\t\twmm_param = (struct wmi_wmm_params *)&cmd->wmm_params[ac];\n\t\twmm_param->tlv_header =\n\t\t\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t   WMI_TAG_VDEV_SET_WMM_PARAMS_CMD) |\n\t\t\t\tFIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t   sizeof(*wmm_param) - TLV_HDR_SIZE);\n\n\t\twmm_param->aifs = wmi_wmm_arg->aifs;\n\t\twmm_param->cwmin = wmi_wmm_arg->cwmin;\n\t\twmm_param->cwmax = wmi_wmm_arg->cwmax;\n\t\twmm_param->txoplimit = wmi_wmm_arg->txop;\n\t\twmm_param->acm = wmi_wmm_arg->acm;\n\t\twmm_param->no_ack = wmi_wmm_arg->no_ack;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t   \"wmi wmm set ac %d aifs %d cwmin %d cwmax %d txop %d acm %d no_ack %d\\n\",\n\t\t\t   ac, wmm_param->aifs, wmm_param->cwmin,\n\t\t\t   wmm_param->cwmax, wmm_param->txoplimit,\n\t\t\t   wmm_param->acm, wmm_param->no_ack);\n\t}\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_VDEV_SET_WMM_PARAMS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_VDEV_SET_WMM_PARAMS_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_dfs_phyerr_offload_enable_cmd(struct ath11k *ar,\n\t\t\t\t\t\t  u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_dfs_phyerr_offload_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_dfs_phyerr_offload_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_DFS_PHYERR_OFFLOAD_ENABLE_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = pdev_id;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI dfs phy err offload enable pdev id %d\\n\", pdev_id);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_DFS_PHYERR_OFFLOAD_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PDEV_DFS_PHYERR_OFFLOAD_ENABLE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_delba_send(struct ath11k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t  u32 tid, u32 initiator, u32 reason)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_delba_send_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delba_send_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_DELBA_SEND_CMD) |\n\t\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = tid;\n\tcmd->initiator = initiator;\n\tcmd->reasoncode = reason;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi delba send vdev_id 0x%X mac_addr %pM tid %u initiator %u reason %u\\n\",\n\t\t   vdev_id, mac, tid, initiator, reason);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_DELBA_SEND_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_DELBA_SEND_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_addba_set_resp(struct ath11k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t      u32 tid, u32 status)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_addba_setresponse_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_addba_setresponse_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_ADDBA_SETRESPONSE_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = tid;\n\tcmd->statuscode = status;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi addba set resp vdev_id 0x%X mac_addr %pM tid %u status %u\\n\",\n\t\t   vdev_id, mac, tid, status);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_ADDBA_SET_RESP_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_ADDBA_SET_RESP_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_addba_send(struct ath11k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t  u32 tid, u32 buf_size)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_addba_send_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_addba_send_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ADDBA_SEND_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = tid;\n\tcmd->buffersize = buf_size;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi addba send vdev_id 0x%X mac_addr %pM tid %u bufsize %u\\n\",\n\t\t   vdev_id, mac, tid, buf_size);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_ADDBA_SEND_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_ADDBA_SEND_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_addba_clear_resp(struct ath11k *ar, u32 vdev_id, const u8 *mac)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_addba_clear_resp_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_addba_clear_resp_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_ADDBA_CLEAR_RESP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi addba clear resp vdev_id 0x%X mac_addr %pM\\n\",\n\t\t   vdev_id, mac);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_ADDBA_CLEAR_RESP_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_ADDBA_CLEAR_RESP_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_peer_pktlog_filter(struct ath11k *ar, u8 *addr, u8 enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_pktlog_filter_cmd *cmd;\n\tstruct wmi_pdev_pktlog_filter_info *info;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint ret, len;\n\n\tlen = sizeof(*cmd) + sizeof(*info) + TLV_HDR_SIZE;\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_pktlog_filter_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PEER_PKTLOG_FILTER_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = DP_HW2SW_MACID(ar->pdev->pdev_id);\n\tcmd->num_mac = 1;\n\tcmd->enable = enable;\n\n\tptr = skb->data + sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, sizeof(*info));\n\n\tptr += TLV_HDR_SIZE;\n\tinfo = ptr;\n\n\tether_addr_copy(info->peer_macaddr.addr, addr);\n\tinfo->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PEER_PKTLOG_FILTER_INFO) |\n\t\t\t   FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t      sizeof(*info) - TLV_HDR_SIZE);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_PKTLOG_FILTER_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_PKTLOG_ENABLE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint\nath11k_wmi_send_init_country_cmd(struct ath11k *ar,\n\t\t\t\t struct wmi_init_country_params init_cc_params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_init_country_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_init_country_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_SET_INIT_COUNTRY_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\n\tswitch (init_cc_params.flags) {\n\tcase ALPHA_IS_SET:\n\t\tcmd->init_cc_type = WMI_COUNTRY_INFO_TYPE_ALPHA;\n\t\tmemcpy((u8 *)&cmd->cc_info.alpha2,\n\t\t       init_cc_params.cc_info.alpha2, 3);\n\t\tbreak;\n\tcase CC_IS_SET:\n\t\tcmd->init_cc_type = WMI_COUNTRY_INFO_TYPE_COUNTRY_CODE;\n\t\tcmd->cc_info.country_code = init_cc_params.cc_info.country_code;\n\t\tbreak;\n\tcase REGDMN_IS_SET:\n\t\tcmd->init_cc_type = WMI_COUNTRY_INFO_TYPE_REGDOMAIN;\n\t\tcmd->cc_info.regdom_id = init_cc_params.cc_info.regdom_id;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_SET_INIT_COUNTRY_CMDID);\n\nout:\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_SET_INIT_COUNTRY CMD :%d\\n\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint\nath11k_wmi_send_thermal_mitigation_param_cmd(struct ath11k *ar,\n\t\t\t\t\t     struct thermal_mitigation_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_therm_throt_config_request_cmd *cmd;\n\tstruct wmi_therm_throt_level_config_info *lvl_conf;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tint i, ret, len;\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE +\n\t      THERMAL_LEVELS * sizeof(struct wmi_therm_throt_level_config_info);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_therm_throt_config_request_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_THERM_THROT_CONFIG_REQUEST) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tcmd->enable = param->enable;\n\tcmd->dc = param->dc;\n\tcmd->dc_per_event = param->dc_per_event;\n\tcmd->therm_throt_levels = THERMAL_LEVELS;\n\n\ttlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t (THERMAL_LEVELS *\n\t\t\t\t  sizeof(struct wmi_therm_throt_level_config_info)));\n\n\tlvl_conf = (struct wmi_therm_throt_level_config_info *)(skb->data +\n\t\t\t\t\t\t\t\tsizeof(*cmd) +\n\t\t\t\t\t\t\t\tTLV_HDR_SIZE);\n\tfor (i = 0; i < THERMAL_LEVELS; i++) {\n\t\tlvl_conf->tlv_header =\n\t\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_THERM_THROT_LEVEL_CONFIG_INFO) |\n\t\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*lvl_conf) - TLV_HDR_SIZE);\n\n\t\tlvl_conf->temp_lwm = param->levelconf[i].tmplwm;\n\t\tlvl_conf->temp_hwm = param->levelconf[i].tmphwm;\n\t\tlvl_conf->dc_off_percent = param->levelconf[i].dcoffpercent;\n\t\tlvl_conf->prio = param->levelconf[i].priority;\n\t\tlvl_conf++;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_THERM_THROT_SET_CONF_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send THERM_THROT_SET_CONF cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev set thermal throt pdev_id %d enable %d dc %d dc_per_event %x levels %d\\n\",\n\t\t   ar->pdev->pdev_id, param->enable, param->dc,\n\t\t   param->dc_per_event, THERMAL_LEVELS);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_pktlog_enable(struct ath11k *ar, u32 pktlog_filter)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pktlog_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pktlog_enable_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PKTLOG_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = DP_HW2SW_MACID(ar->pdev->pdev_id);\n\tcmd->evlist = pktlog_filter;\n\tcmd->enable = ATH11K_WMI_PKTLOG_ENABLE_FORCE;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_PKTLOG_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_PKTLOG_ENABLE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_pktlog_disable(struct ath11k *ar)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pktlog_disable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pktlog_disable_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PKTLOG_DISABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = DP_HW2SW_MACID(ar->pdev->pdev_id);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_PKTLOG_DISABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_PKTLOG_ENABLE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint\nath11k_wmi_send_twt_enable_cmd(struct ath11k *ar, u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_enable_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_enable_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TWT_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\tcmd->sta_cong_timer_ms = ATH11K_TWT_DEF_STA_CONG_TIMER_MS;\n\tcmd->default_slot_size = ATH11K_TWT_DEF_DEFAULT_SLOT_SIZE;\n\tcmd->congestion_thresh_setup = ATH11K_TWT_DEF_CONGESTION_THRESH_SETUP;\n\tcmd->congestion_thresh_teardown =\n\t\tATH11K_TWT_DEF_CONGESTION_THRESH_TEARDOWN;\n\tcmd->congestion_thresh_critical =\n\t\tATH11K_TWT_DEF_CONGESTION_THRESH_CRITICAL;\n\tcmd->interference_thresh_teardown =\n\t\tATH11K_TWT_DEF_INTERFERENCE_THRESH_TEARDOWN;\n\tcmd->interference_thresh_setup =\n\t\tATH11K_TWT_DEF_INTERFERENCE_THRESH_SETUP;\n\tcmd->min_no_sta_setup = ATH11K_TWT_DEF_MIN_NO_STA_SETUP;\n\tcmd->min_no_sta_teardown = ATH11K_TWT_DEF_MIN_NO_STA_TEARDOWN;\n\tcmd->no_of_bcast_mcast_slots = ATH11K_TWT_DEF_NO_OF_BCAST_MCAST_SLOTS;\n\tcmd->min_no_twt_slots = ATH11K_TWT_DEF_MIN_NO_TWT_SLOTS;\n\tcmd->max_no_sta_twt = ATH11K_TWT_DEF_MAX_NO_STA_TWT;\n\tcmd->mode_check_interval = ATH11K_TWT_DEF_MODE_CHECK_INTERVAL;\n\tcmd->add_sta_slot_interval = ATH11K_TWT_DEF_ADD_STA_SLOT_INTERVAL;\n\tcmd->remove_sta_slot_interval =\n\t\tATH11K_TWT_DEF_REMOVE_STA_SLOT_INTERVAL;\n\t/* TODO add MBSSID support */\n\tcmd->mbss_support = 0;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_TWT_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_TWT_ENABLE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint\nath11k_wmi_send_twt_disable_cmd(struct ath11k *ar, u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_disable_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_disable_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TWT_DISABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_TWT_DISABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_TWT_DISABLE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint\nath11k_wmi_send_obss_spr_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t     struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_obss_spatial_reuse_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_obss_spatial_reuse_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_OBSS_SPATIAL_REUSE_SET_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->enable = he_obss_pd->enable;\n\tcmd->obss_min = he_obss_pd->min_offset;\n\tcmd->obss_max = he_obss_pd->max_offset;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_OBSS_PD_SPATIAL_REUSE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"Failed to send WMI_PDEV_OBSS_PD_SPATIAL_REUSE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint\nath11k_wmi_send_obss_color_collision_cfg_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t\t     u8 bss_color, u32 period,\n\t\t\t\t\t     bool enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_obss_color_collision_cfg_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_obss_color_collision_cfg_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_OBSS_COLOR_COLLISION_DET_CONFIG) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->evt_type = enable ? ATH11K_OBSS_COLOR_COLLISION_DETECTION :\n\t\t\t\t ATH11K_OBSS_COLOR_COLLISION_DETECTION_DISABLE;\n\tcmd->current_bss_color = bss_color;\n\tcmd->detection_period_ms = period;\n\tcmd->scan_period_ms = ATH11K_BSS_COLOR_COLLISION_SCAN_PERIOD_MS;\n\tcmd->free_slot_expiry_time_ms = 0;\n\tcmd->flags = 0;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi_send_obss_color_collision_cfg id %d type %d bss_color %d detect_period %d scan_period %d\\n\",\n\t\t   cmd->vdev_id, cmd->evt_type, cmd->current_bss_color,\n\t\t   cmd->detection_period_ms, cmd->scan_period_ms);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_OBSS_COLOR_COLLISION_DET_CONFIG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_OBSS_COLOR_COLLISION_DET_CONFIG_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint ath11k_wmi_send_bss_color_change_enable_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t\t\tbool enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_bss_color_change_enable_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bss_color_change_enable_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_BSS_COLOR_CHANGE_ENABLE) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->enable = enable ? 1 : 0;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"wmi_send_bss_color_change_enable id %d enable %d\\n\",\n\t\t   cmd->vdev_id, cmd->enable);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_BSS_COLOR_CHANGE_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_BSS_COLOR_CHANGE_ENABLE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint ath11k_wmi_fils_discovery_tmpl(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t   struct sk_buff *tmpl)\n{\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tint ret, len;\n\tsize_t aligned_len;\n\tstruct wmi_fils_discovery_tmpl_cmd *cmd;\n\n\taligned_len = roundup(tmpl->len, 4);\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + aligned_len;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev %i set FILS discovery template\\n\", vdev_id);\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_fils_discovery_tmpl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_FILS_DISCOVERY_TMPL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->buf_len = tmpl->len;\n\tptr = skb->data + sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, aligned_len);\n\tmemcpy(tlv->value, tmpl->data, tmpl->len);\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_FILS_DISCOVERY_TMPL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"WMI vdev %i failed to send FILS discovery template command\\n\",\n\t\t\t    vdev_id);\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint ath11k_wmi_probe_resp_tmpl(struct ath11k *ar, u32 vdev_id,\n\t\t\t       struct sk_buff *tmpl)\n{\n\tstruct wmi_probe_tmpl_cmd *cmd;\n\tstruct wmi_bcn_prb_info *probe_info;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tint ret, len;\n\tsize_t aligned_len = roundup(tmpl->len, 4);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev %i set probe response template\\n\", vdev_id);\n\n\tlen = sizeof(*cmd) + sizeof(*probe_info) + TLV_HDR_SIZE + aligned_len;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_probe_tmpl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PRB_TMPL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->buf_len = tmpl->len;\n\n\tptr = skb->data + sizeof(*cmd);\n\n\tprobe_info = ptr;\n\tlen = sizeof(*probe_info);\n\tprobe_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t    WMI_TAG_BCN_PRB_INFO) |\n\t\t\t\t FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tprobe_info->caps = 0;\n\tprobe_info->erp = 0;\n\n\tptr += sizeof(*probe_info);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, aligned_len);\n\tmemcpy(tlv->value, tmpl->data, tmpl->len);\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_PRB_TMPL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"WMI vdev %i failed to send probe response template command\\n\",\n\t\t\t    vdev_id);\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nint ath11k_wmi_fils_discovery(struct ath11k *ar, u32 vdev_id, u32 interval,\n\t\t\t      bool unsol_bcast_probe_resp_enabled)\n{\n\tstruct sk_buff *skb;\n\tint ret, len;\n\tstruct wmi_fils_discovery_cmd *cmd;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI vdev %i set %s interval to %u TU\\n\",\n\t\t   vdev_id, unsol_bcast_probe_resp_enabled ?\n\t\t   \"unsolicited broadcast probe response\" : \"FILS discovery\",\n\t\t   interval);\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_fils_discovery_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ENABLE_FILS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->interval = interval;\n\tcmd->config = unsol_bcast_probe_resp_enabled;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_ENABLE_FILS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"WMI vdev %i failed to send FILS discovery enable/disable command\\n\",\n\t\t\t    vdev_id);\n\t\tdev_kfree_skb(skb);\n\t}\n\treturn ret;\n}\n\nstatic void\nath11k_fill_band_to_mac_param(struct ath11k_base  *soc,\n\t\t\t      struct wmi_host_pdev_band_to_mac *band_to_mac)\n{\n\tu8 i;\n\tstruct ath11k_hal_reg_capabilities_ext *hal_reg_cap;\n\tstruct ath11k_pdev *pdev;\n\n\tfor (i = 0; i < soc->num_radios; i++) {\n\t\tpdev = &soc->pdevs[i];\n\t\thal_reg_cap = &soc->hal_reg_cap[i];\n\t\tband_to_mac[i].pdev_id = pdev->pdev_id;\n\n\t\tswitch (pdev->cap.supported_bands) {\n\t\tcase WMI_HOST_WLAN_2G_5G_CAP:\n\t\t\tband_to_mac[i].start_freq = hal_reg_cap->low_2ghz_chan;\n\t\t\tband_to_mac[i].end_freq = hal_reg_cap->high_5ghz_chan;\n\t\t\tbreak;\n\t\tcase WMI_HOST_WLAN_2G_CAP:\n\t\t\tband_to_mac[i].start_freq = hal_reg_cap->low_2ghz_chan;\n\t\t\tband_to_mac[i].end_freq = hal_reg_cap->high_2ghz_chan;\n\t\t\tbreak;\n\t\tcase WMI_HOST_WLAN_5G_CAP:\n\t\t\tband_to_mac[i].start_freq = hal_reg_cap->low_5ghz_chan;\n\t\t\tband_to_mac[i].end_freq = hal_reg_cap->high_5ghz_chan;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nath11k_wmi_copy_resource_config(struct wmi_resource_config *wmi_cfg,\n\t\t\t\tstruct target_resource_config *tg_cfg)\n{\n\twmi_cfg->num_vdevs = tg_cfg->num_vdevs;\n\twmi_cfg->num_peers = tg_cfg->num_peers;\n\twmi_cfg->num_offload_peers = tg_cfg->num_offload_peers;\n\twmi_cfg->num_offload_reorder_buffs = tg_cfg->num_offload_reorder_buffs;\n\twmi_cfg->num_peer_keys = tg_cfg->num_peer_keys;\n\twmi_cfg->num_tids = tg_cfg->num_tids;\n\twmi_cfg->ast_skid_limit = tg_cfg->ast_skid_limit;\n\twmi_cfg->tx_chain_mask = tg_cfg->tx_chain_mask;\n\twmi_cfg->rx_chain_mask = tg_cfg->rx_chain_mask;\n\twmi_cfg->rx_timeout_pri[0] = tg_cfg->rx_timeout_pri[0];\n\twmi_cfg->rx_timeout_pri[1] = tg_cfg->rx_timeout_pri[1];\n\twmi_cfg->rx_timeout_pri[2] = tg_cfg->rx_timeout_pri[2];\n\twmi_cfg->rx_timeout_pri[3] = tg_cfg->rx_timeout_pri[3];\n\twmi_cfg->rx_decap_mode = tg_cfg->rx_decap_mode;\n\twmi_cfg->scan_max_pending_req = tg_cfg->scan_max_pending_req;\n\twmi_cfg->bmiss_offload_max_vdev = tg_cfg->bmiss_offload_max_vdev;\n\twmi_cfg->roam_offload_max_vdev = tg_cfg->roam_offload_max_vdev;\n\twmi_cfg->roam_offload_max_ap_profiles =\n\t\ttg_cfg->roam_offload_max_ap_profiles;\n\twmi_cfg->num_mcast_groups = tg_cfg->num_mcast_groups;\n\twmi_cfg->num_mcast_table_elems = tg_cfg->num_mcast_table_elems;\n\twmi_cfg->mcast2ucast_mode = tg_cfg->mcast2ucast_mode;\n\twmi_cfg->tx_dbg_log_size = tg_cfg->tx_dbg_log_size;\n\twmi_cfg->num_wds_entries = tg_cfg->num_wds_entries;\n\twmi_cfg->dma_burst_size = tg_cfg->dma_burst_size;\n\twmi_cfg->mac_aggr_delim = tg_cfg->mac_aggr_delim;\n\twmi_cfg->rx_skip_defrag_timeout_dup_detection_check =\n\t\ttg_cfg->rx_skip_defrag_timeout_dup_detection_check;\n\twmi_cfg->vow_config = tg_cfg->vow_config;\n\twmi_cfg->gtk_offload_max_vdev = tg_cfg->gtk_offload_max_vdev;\n\twmi_cfg->num_msdu_desc = tg_cfg->num_msdu_desc;\n\twmi_cfg->max_frag_entries = tg_cfg->max_frag_entries;\n\twmi_cfg->num_tdls_vdevs = tg_cfg->num_tdls_vdevs;\n\twmi_cfg->num_tdls_conn_table_entries =\n\t\ttg_cfg->num_tdls_conn_table_entries;\n\twmi_cfg->beacon_tx_offload_max_vdev =\n\t\ttg_cfg->beacon_tx_offload_max_vdev;\n\twmi_cfg->num_multicast_filter_entries =\n\t\ttg_cfg->num_multicast_filter_entries;\n\twmi_cfg->num_wow_filters = tg_cfg->num_wow_filters;\n\twmi_cfg->num_keep_alive_pattern = tg_cfg->num_keep_alive_pattern;\n\twmi_cfg->keep_alive_pattern_size = tg_cfg->keep_alive_pattern_size;\n\twmi_cfg->max_tdls_concurrent_sleep_sta =\n\t\ttg_cfg->max_tdls_concurrent_sleep_sta;\n\twmi_cfg->max_tdls_concurrent_buffer_sta =\n\t\ttg_cfg->max_tdls_concurrent_buffer_sta;\n\twmi_cfg->wmi_send_separate = tg_cfg->wmi_send_separate;\n\twmi_cfg->num_ocb_vdevs = tg_cfg->num_ocb_vdevs;\n\twmi_cfg->num_ocb_channels = tg_cfg->num_ocb_channels;\n\twmi_cfg->num_ocb_schedules = tg_cfg->num_ocb_schedules;\n\twmi_cfg->bpf_instruction_size = tg_cfg->bpf_instruction_size;\n\twmi_cfg->max_bssid_rx_filters = tg_cfg->max_bssid_rx_filters;\n\twmi_cfg->use_pdev_id = tg_cfg->use_pdev_id;\n\twmi_cfg->flag1 = tg_cfg->atf_config;\n\twmi_cfg->peer_map_unmap_v2_support = tg_cfg->peer_map_unmap_v2_support;\n\twmi_cfg->sched_params = tg_cfg->sched_params;\n\twmi_cfg->twt_ap_pdev_count = tg_cfg->twt_ap_pdev_count;\n\twmi_cfg->twt_ap_sta_count = tg_cfg->twt_ap_sta_count;\n}\n\nstatic int ath11k_init_cmd_send(struct ath11k_pdev_wmi *wmi,\n\t\t\t\tstruct wmi_init_cmd_param *param)\n{\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct sk_buff *skb;\n\tstruct wmi_init_cmd *cmd;\n\tstruct wmi_resource_config *cfg;\n\tstruct wmi_pdev_set_hw_mode_cmd_param *hw_mode;\n\tstruct wmi_pdev_band_to_mac *band_to_mac;\n\tstruct wlan_host_mem_chunk *host_mem_chunks;\n\tstruct wmi_tlv *tlv;\n\tsize_t ret, len;\n\tvoid *ptr;\n\tu32 hw_mode_len = 0;\n\tu16 idx;\n\n\tif (param->hw_mode_id != WMI_HOST_HW_MODE_MAX)\n\t\thw_mode_len = sizeof(*hw_mode) + TLV_HDR_SIZE +\n\t\t\t      (param->num_band_to_mac * sizeof(*band_to_mac));\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + sizeof(*cfg) + hw_mode_len +\n\t      (param->num_mem_chunks ? (sizeof(*host_mem_chunks) * WMI_MAX_MEM_REQS) : 0);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_init_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_INIT_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tptr = skb->data + sizeof(*cmd);\n\tcfg = ptr;\n\n\tath11k_wmi_copy_resource_config(cfg, param->res_cfg);\n\n\tcfg->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_RESOURCE_CONFIG) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cfg) - TLV_HDR_SIZE);\n\n\tptr += sizeof(*cfg);\n\thost_mem_chunks = ptr + TLV_HDR_SIZE;\n\tlen = sizeof(struct wlan_host_mem_chunk);\n\n\tfor (idx = 0; idx < param->num_mem_chunks; ++idx) {\n\t\thost_mem_chunks[idx].tlv_header =\n\t\t\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t   WMI_TAG_WLAN_HOST_MEMORY_CHUNK) |\n\t\t\t\tFIELD_PREP(WMI_TLV_LEN, len);\n\n\t\thost_mem_chunks[idx].ptr = param->mem_chunks[idx].paddr;\n\t\thost_mem_chunks[idx].size = param->mem_chunks[idx].len;\n\t\thost_mem_chunks[idx].req_id = param->mem_chunks[idx].req_id;\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"WMI host mem chunk req_id %d paddr 0x%llx len %d\\n\",\n\t\t\t   param->mem_chunks[idx].req_id,\n\t\t\t   (u64)param->mem_chunks[idx].paddr,\n\t\t\t   param->mem_chunks[idx].len);\n\t}\n\tcmd->num_host_mem_chunks = param->num_mem_chunks;\n\tlen = sizeof(struct wlan_host_mem_chunk) * param->num_mem_chunks;\n\n\t/* num_mem_chunks is zero */\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE + len;\n\n\tif (param->hw_mode_id != WMI_HOST_HW_MODE_MAX) {\n\t\thw_mode = (struct wmi_pdev_set_hw_mode_cmd_param *)ptr;\n\t\thw_mode->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\t WMI_TAG_PDEV_SET_HW_MODE_CMD) |\n\t\t\t\t      FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\t sizeof(*hw_mode) - TLV_HDR_SIZE);\n\n\t\thw_mode->hw_mode_index = param->hw_mode_id;\n\t\thw_mode->num_band_to_mac = param->num_band_to_mac;\n\n\t\tptr += sizeof(*hw_mode);\n\n\t\tlen = param->num_band_to_mac * sizeof(*band_to_mac);\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\t\tptr += TLV_HDR_SIZE;\n\t\tlen = sizeof(*band_to_mac);\n\n\t\tfor (idx = 0; idx < param->num_band_to_mac; idx++) {\n\t\t\tband_to_mac = (void *)ptr;\n\n\t\t\tband_to_mac->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\t\t     WMI_TAG_PDEV_BAND_TO_MAC) |\n\t\t\t\t\t\t  FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\t\t     len - TLV_HDR_SIZE);\n\t\t\tband_to_mac->pdev_id = param->band_to_mac[idx].pdev_id;\n\t\t\tband_to_mac->start_freq =\n\t\t\t\tparam->band_to_mac[idx].start_freq;\n\t\t\tband_to_mac->end_freq =\n\t\t\t\tparam->band_to_mac[idx].end_freq;\n\t\t\tptr += sizeof(*band_to_mac);\n\t\t}\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_INIT_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to send WMI_INIT_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_lro_cfg(struct ath11k *ar,\n\t\t\t    int pdev_id)\n{\n\tstruct ath11k_wmi_pdev_lro_config_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_pdev_lro_config_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_LRO_INFO_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tget_random_bytes(cmd->th_4, sizeof(uint32_t) * ATH11K_IPV4_TH_SEED_SIZE);\n\tget_random_bytes(cmd->th_6, sizeof(uint32_t) * ATH11K_IPV6_TH_SEED_SIZE);\n\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_LRO_CONFIG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send lro cfg req wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI lro cfg cmd pdev_id 0x%x\\n\", pdev_id);\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_wait_for_service_ready(struct ath11k_base *ab)\n{\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&ab->wmi_ab.service_ready,\n\t\t\t\t\t\tWMI_SERVICE_READY_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint ath11k_wmi_wait_for_unified_ready(struct ath11k_base *ab)\n{\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&ab->wmi_ab.unified_ready,\n\t\t\t\t\t\tWMI_SERVICE_READY_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint ath11k_wmi_set_hw_mode(struct ath11k_base *ab,\n\t\t\t   enum wmi_host_hw_mode_config_type mode)\n{\n\tstruct wmi_pdev_set_hw_mode_cmd_param *cmd;\n\tstruct sk_buff *skb;\n\tstruct ath11k_wmi_base *wmi_ab = &ab->wmi_ab;\n\tint len;\n\tint ret;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_hw_mode_cmd_param *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SET_HW_MODE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = WMI_PDEV_ID_SOC;\n\tcmd->hw_mode_index = mode;\n\n\tret = ath11k_wmi_cmd_send(&wmi_ab->wmi[0], skb, WMI_PDEV_SET_HW_MODE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to send WMI_PDEV_SET_HW_MODE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_wmi_cmd_init(struct ath11k_base *ab)\n{\n\tstruct ath11k_wmi_base *wmi_sc = &ab->wmi_ab;\n\tstruct wmi_init_cmd_param init_param;\n\tstruct target_resource_config  config;\n\n\tmemset(&init_param, 0, sizeof(init_param));\n\tmemset(&config, 0, sizeof(config));\n\n\tab->hw_params.hw_ops->wmi_init_config(ab, &config);\n\n\tmemcpy(&wmi_sc->wlan_resource_config, &config, sizeof(config));\n\n\tinit_param.res_cfg = &wmi_sc->wlan_resource_config;\n\tinit_param.num_mem_chunks = wmi_sc->num_mem_chunks;\n\tinit_param.hw_mode_id = wmi_sc->preferred_hw_mode;\n\tinit_param.mem_chunks = wmi_sc->mem_chunks;\n\n\tif (ab->hw_params.single_pdev_only)\n\t\tinit_param.hw_mode_id = WMI_HOST_HW_MODE_MAX;\n\n\tinit_param.num_band_to_mac = ab->num_radios;\n\tath11k_fill_band_to_mac_param(ab, init_param.band_to_mac);\n\n\treturn ath11k_init_cmd_send(&wmi_sc->wmi[0], &init_param);\n}\n\nint ath11k_wmi_vdev_spectral_conf(struct ath11k *ar,\n\t\t\t\t  struct ath11k_wmi_vdev_spectral_conf_param *param)\n{\n\tstruct ath11k_wmi_vdev_spectral_conf_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_vdev_spectral_conf_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_SPECTRAL_CONFIGURE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tmemcpy(&cmd->param, param, sizeof(*param));\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send spectral scan config wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI spectral scan config cmd vdev_id 0x%x\\n\",\n\t\t   param->vdev_id);\n\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_spectral_enable(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t    u32 trigger, u32 enable)\n{\n\tstruct ath11k_wmi_vdev_spectral_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_vdev_spectral_enable_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_SPECTRAL_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->trigger_cmd = trigger;\n\tcmd->enable_cmd = enable;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_VDEV_SPECTRAL_SCAN_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send spectral enable wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI spectral enable cmd vdev id 0x%x\\n\",\n\t\t   vdev_id);\n\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_dma_ring_cfg(struct ath11k *ar,\n\t\t\t\t struct ath11k_wmi_pdev_dma_ring_cfg_req_cmd *param)\n{\n\tstruct ath11k_wmi_pdev_dma_ring_cfg_req_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_pdev_dma_ring_cfg_req_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_DMA_RING_CFG_REQ) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id\t\t= param->pdev_id;\n\tcmd->module_id\t\t= param->module_id;\n\tcmd->base_paddr_lo\t= param->base_paddr_lo;\n\tcmd->base_paddr_hi\t= param->base_paddr_hi;\n\tcmd->head_idx_paddr_lo\t= param->head_idx_paddr_lo;\n\tcmd->head_idx_paddr_hi\t= param->head_idx_paddr_hi;\n\tcmd->tail_idx_paddr_lo\t= param->tail_idx_paddr_lo;\n\tcmd->tail_idx_paddr_hi\t= param->tail_idx_paddr_hi;\n\tcmd->num_elems\t\t= param->num_elems;\n\tcmd->buf_size\t\t= param->buf_size;\n\tcmd->num_resp_per_event\t= param->num_resp_per_event;\n\tcmd->event_timeout_ms\t= param->event_timeout_ms;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_PDEV_DMA_RING_CFG_REQ_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send dma ring cfg req wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI DMA ring cfg req cmd pdev_id 0x%x\\n\",\n\t\t   param->pdev_id);\n\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_dma_buf_entry_parse(struct ath11k_base *soc,\n\t\t\t\t\t      u16 tag, u16 len,\n\t\t\t\t\t      const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_buf_release_parse *parse = data;\n\n\tif (tag != WMI_TAG_DMA_BUF_RELEASE_ENTRY)\n\t\treturn -EPROTO;\n\n\tif (parse->num_buf_entry >= parse->fixed.num_buf_release_entry)\n\t\treturn -ENOBUFS;\n\n\tparse->num_buf_entry++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_dma_buf_meta_parse(struct ath11k_base *soc,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_buf_release_parse *parse = data;\n\n\tif (tag != WMI_TAG_DMA_BUF_RELEASE_SPECTRAL_META_DATA)\n\t\treturn -EPROTO;\n\n\tif (parse->num_meta >= parse->fixed.num_meta_data_entry)\n\t\treturn -ENOBUFS;\n\n\tparse->num_meta++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_dma_buf_parse(struct ath11k_base *ab,\n\t\t\t\t\tu16 tag, u16 len,\n\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_buf_release_parse *parse = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TAG_DMA_BUF_RELEASE:\n\t\tmemcpy(&parse->fixed, ptr,\n\t\t       sizeof(struct ath11k_wmi_dma_buf_release_fixed_param));\n\t\tparse->fixed.pdev_id = DP_HW2SW_MACID(parse->fixed.pdev_id);\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (!parse->buf_entry_done) {\n\t\t\tparse->num_buf_entry = 0;\n\t\t\tparse->buf_entry = (struct wmi_dma_buf_release_entry *)ptr;\n\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_dma_buf_entry_parse,\n\t\t\t\t\t\t  parse);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse dma buf entry tlv %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tparse->buf_entry_done = true;\n\t\t} else if (!parse->meta_data_done) {\n\t\t\tparse->num_meta = 0;\n\t\t\tparse->meta_data = (struct wmi_dma_buf_release_meta_data *)ptr;\n\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_dma_buf_meta_parse,\n\t\t\t\t\t\t  parse);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse dma buf meta tlv %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tparse->meta_data_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void ath11k_wmi_pdev_dma_ring_buf_release_event(struct ath11k_base *ab,\n\t\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct wmi_tlv_dma_buf_release_parse parse = { };\n\tstruct ath11k_dbring_buf_release_event param;\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_dma_buf_parse,\n\t\t\t\t  &parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse dma buf release tlv %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tparam.fixed\t\t= parse.fixed;\n\tparam.buf_entry\t\t= parse.buf_entry;\n\tparam.num_buf_entry\t= parse.num_buf_entry;\n\tparam.meta_data\t\t= parse.meta_data;\n\tparam.num_meta\t\t= parse.num_meta;\n\n\tret = ath11k_dbring_buffer_release_event(ab, &param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to handle dma buf release event %d\\n\", ret);\n\t\treturn;\n\t}\n}\n\nstatic int ath11k_wmi_tlv_hw_mode_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tstruct wmi_hw_mode_capabilities *hw_mode_cap;\n\tu32 phy_map = 0;\n\n\tif (tag != WMI_TAG_HW_MODE_CAPABILITIES)\n\t\treturn -EPROTO;\n\n\tif (svc_rdy_ext->n_hw_mode_caps >= svc_rdy_ext->param.num_hw_modes)\n\t\treturn -ENOBUFS;\n\n\thw_mode_cap = container_of(ptr, struct wmi_hw_mode_capabilities,\n\t\t\t\t   hw_mode_id);\n\tsvc_rdy_ext->n_hw_mode_caps++;\n\n\tphy_map = hw_mode_cap->phy_id_map;\n\twhile (phy_map) {\n\t\tsvc_rdy_ext->tot_phy_id++;\n\t\tphy_map = phy_map >> 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_hw_mode_caps(struct ath11k_base *soc,\n\t\t\t\t       u16 len, const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tstruct wmi_hw_mode_capabilities *hw_mode_caps;\n\tenum wmi_host_hw_mode_config_type mode, pref;\n\tu32 i;\n\tint ret;\n\n\tsvc_rdy_ext->n_hw_mode_caps = 0;\n\tsvc_rdy_ext->hw_mode_caps = (struct wmi_hw_mode_capabilities *)ptr;\n\n\tret = ath11k_wmi_tlv_iter(soc, ptr, len,\n\t\t\t\t  ath11k_wmi_tlv_hw_mode_caps_parse,\n\t\t\t\t  svc_rdy_ext);\n\tif (ret) {\n\t\tath11k_warn(soc, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti = 0;\n\twhile (i < svc_rdy_ext->n_hw_mode_caps) {\n\t\thw_mode_caps = &svc_rdy_ext->hw_mode_caps[i];\n\t\tmode = hw_mode_caps->hw_mode_id;\n\t\tpref = soc->wmi_ab.preferred_hw_mode;\n\n\t\tif (ath11k_hw_mode_pri_map[mode] < ath11k_hw_mode_pri_map[pref]) {\n\t\t\tsvc_rdy_ext->pref_hw_mode_caps = *hw_mode_caps;\n\t\t\tsoc->wmi_ab.preferred_hw_mode = mode;\n\t\t}\n\t\ti++;\n\t}\n\n\tath11k_dbg(soc, ATH11K_DBG_WMI, \"preferred_hw_mode:%d\\n\",\n\t\t   soc->wmi_ab.preferred_hw_mode);\n\tif (soc->wmi_ab.preferred_hw_mode == WMI_HOST_HW_MODE_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_mac_phy_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\n\tif (tag != WMI_TAG_MAC_PHY_CAPABILITIES)\n\t\treturn -EPROTO;\n\n\tif (svc_rdy_ext->n_mac_phy_caps >= svc_rdy_ext->tot_phy_id)\n\t\treturn -ENOBUFS;\n\n\tlen = min_t(u16, len, sizeof(struct wmi_mac_phy_capabilities));\n\tif (!svc_rdy_ext->n_mac_phy_caps) {\n\t\tsvc_rdy_ext->mac_phy_caps = kzalloc((svc_rdy_ext->tot_phy_id) * len,\n\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!svc_rdy_ext->mac_phy_caps)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(svc_rdy_ext->mac_phy_caps + svc_rdy_ext->n_mac_phy_caps, ptr, len);\n\tsvc_rdy_ext->n_mac_phy_caps++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_ext_hal_reg_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t\t u16 tag, u16 len,\n\t\t\t\t\t\t const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\n\tif (tag != WMI_TAG_HAL_REG_CAPABILITIES_EXT)\n\t\treturn -EPROTO;\n\n\tif (svc_rdy_ext->n_ext_hal_reg_caps >= svc_rdy_ext->param.num_phy)\n\t\treturn -ENOBUFS;\n\n\tsvc_rdy_ext->n_ext_hal_reg_caps++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_ext_hal_reg_caps(struct ath11k_base *soc,\n\t\t\t\t\t   u16 len, const void *ptr, void *data)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle = &soc->wmi_ab.wmi[0];\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tstruct ath11k_hal_reg_capabilities_ext reg_cap;\n\tint ret;\n\tu32 i;\n\n\tsvc_rdy_ext->n_ext_hal_reg_caps = 0;\n\tsvc_rdy_ext->ext_hal_reg_caps = (struct wmi_hal_reg_capabilities_ext *)ptr;\n\tret = ath11k_wmi_tlv_iter(soc, ptr, len,\n\t\t\t\t  ath11k_wmi_tlv_ext_hal_reg_caps_parse,\n\t\t\t\t  svc_rdy_ext);\n\tif (ret) {\n\t\tath11k_warn(soc, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < svc_rdy_ext->param.num_phy; i++) {\n\t\tret = ath11k_pull_reg_cap_svc_rdy_ext(wmi_handle,\n\t\t\t\t\t\t      svc_rdy_ext->soc_hal_reg_caps,\n\t\t\t\t\t\t      svc_rdy_ext->ext_hal_reg_caps, i,\n\t\t\t\t\t\t      &reg_cap);\n\t\tif (ret) {\n\t\t\tath11k_warn(soc, \"failed to extract reg cap %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(&soc->hal_reg_cap[reg_cap.phy_id],\n\t\t       &reg_cap, sizeof(reg_cap));\n\t}\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_ext_soc_hal_reg_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t\t     u16 len, const void *ptr,\n\t\t\t\t\t\t     void *data)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle = &soc->wmi_ab.wmi[0];\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tu8 hw_mode_id = svc_rdy_ext->pref_hw_mode_caps.hw_mode_id;\n\tu32 phy_id_map;\n\tint pdev_index = 0;\n\tint ret;\n\n\tsvc_rdy_ext->soc_hal_reg_caps = (struct wmi_soc_hal_reg_capabilities *)ptr;\n\tsvc_rdy_ext->param.num_phy = svc_rdy_ext->soc_hal_reg_caps->num_phy;\n\n\tsoc->num_radios = 0;\n\tphy_id_map = svc_rdy_ext->pref_hw_mode_caps.phy_id_map;\n\n\twhile (phy_id_map && soc->num_radios < MAX_RADIOS) {\n\t\tret = ath11k_pull_mac_phy_cap_svc_ready_ext(wmi_handle,\n\t\t\t\t\t\t\t    svc_rdy_ext->hw_caps,\n\t\t\t\t\t\t\t    svc_rdy_ext->hw_mode_caps,\n\t\t\t\t\t\t\t    svc_rdy_ext->soc_hal_reg_caps,\n\t\t\t\t\t\t\t    svc_rdy_ext->mac_phy_caps,\n\t\t\t\t\t\t\t    hw_mode_id, soc->num_radios,\n\t\t\t\t\t\t\t    &soc->pdevs[pdev_index]);\n\t\tif (ret) {\n\t\t\tath11k_warn(soc, \"failed to extract mac caps, idx :%d\\n\",\n\t\t\t\t    soc->num_radios);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsoc->num_radios++;\n\n\t\t/* For QCA6390, save mac_phy capability in the same pdev */\n\t\tif (soc->hw_params.single_pdev_only)\n\t\t\tpdev_index = 0;\n\t\telse\n\t\t\tpdev_index = soc->num_radios;\n\n\t\t/* TODO: mac_phy_cap prints */\n\t\tphy_id_map >>= 1;\n\t}\n\n\t/* For QCA6390, set num_radios to 1 because host manages\n\t * both 2G and 5G radio in one pdev.\n\t * Set pdev_id = 0 and 0 means soc level.\n\t */\n\tif (soc->hw_params.single_pdev_only) {\n\t\tsoc->num_radios = 1;\n\t\tsoc->pdevs[0].pdev_id = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_dma_ring_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t      u16 tag, u16 len,\n\t\t\t\t\t      const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_ring_caps_parse *parse = data;\n\n\tif (tag != WMI_TAG_DMA_RING_CAPABILITIES)\n\t\treturn -EPROTO;\n\n\tparse->n_dma_ring_caps++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_alloc_dbring_caps(struct ath11k_base *ab,\n\t\t\t\t\tu32 num_cap)\n{\n\tsize_t sz;\n\tvoid *ptr;\n\n\tsz = num_cap * sizeof(struct ath11k_dbring_cap);\n\tptr = kzalloc(sz, GFP_ATOMIC);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tab->db_caps = ptr;\n\tab->num_db_cap = num_cap;\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_free_dbring_caps(struct ath11k_base *ab)\n{\n\tkfree(ab->db_caps);\n\tab->db_caps = NULL;\n}\n\nstatic int ath11k_wmi_tlv_dma_ring_caps(struct ath11k_base *ab,\n\t\t\t\t\tu16 len, const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_ring_caps_parse *dma_caps_parse = data;\n\tstruct wmi_dma_ring_capabilities *dma_caps;\n\tstruct ath11k_dbring_cap *dir_buff_caps;\n\tint ret;\n\tu32 i;\n\n\tdma_caps_parse->n_dma_ring_caps = 0;\n\tdma_caps = (struct wmi_dma_ring_capabilities *)ptr;\n\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t  ath11k_wmi_tlv_dma_ring_caps_parse,\n\t\t\t\t  dma_caps_parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse dma ring caps tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!dma_caps_parse->n_dma_ring_caps)\n\t\treturn 0;\n\n\tif (ab->num_db_cap) {\n\t\tath11k_warn(ab, \"Already processed, so ignoring dma ring caps\\n\");\n\t\treturn 0;\n\t}\n\n\tret = ath11k_wmi_alloc_dbring_caps(ab, dma_caps_parse->n_dma_ring_caps);\n\tif (ret)\n\t\treturn ret;\n\n\tdir_buff_caps = ab->db_caps;\n\tfor (i = 0; i < dma_caps_parse->n_dma_ring_caps; i++) {\n\t\tif (dma_caps[i].module_id >= WMI_DIRECT_BUF_MAX) {\n\t\t\tath11k_warn(ab, \"Invalid module id %d\\n\", dma_caps[i].module_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_dir_buff;\n\t\t}\n\n\t\tdir_buff_caps[i].id = dma_caps[i].module_id;\n\t\tdir_buff_caps[i].pdev_id = DP_HW2SW_MACID(dma_caps[i].pdev_id);\n\t\tdir_buff_caps[i].min_elem = dma_caps[i].min_elem;\n\t\tdir_buff_caps[i].min_buf_sz = dma_caps[i].min_buf_sz;\n\t\tdir_buff_caps[i].min_buf_align = dma_caps[i].min_buf_align;\n\t}\n\n\treturn 0;\n\nfree_dir_buff:\n\tath11k_wmi_free_dbring_caps(ab);\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_svc_rdy_ext_parse(struct ath11k_base *ab,\n\t\t\t\t\t    u16 tag, u16 len,\n\t\t\t\t\t    const void *ptr, void *data)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle = &ab->wmi_ab.wmi[0];\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TAG_SERVICE_READY_EXT_EVENT:\n\t\tret = ath11k_pull_svc_ready_ext(wmi_handle, ptr,\n\t\t\t\t\t\t&svc_rdy_ext->param);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"unable to extract ext params\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase WMI_TAG_SOC_MAC_PHY_HW_MODE_CAPS:\n\t\tsvc_rdy_ext->hw_caps = (struct wmi_soc_mac_phy_hw_mode_caps *)ptr;\n\t\tsvc_rdy_ext->param.num_hw_modes = svc_rdy_ext->hw_caps->num_hw_modes;\n\t\tbreak;\n\n\tcase WMI_TAG_SOC_HAL_REG_CAPABILITIES:\n\t\tret = ath11k_wmi_tlv_ext_soc_hal_reg_caps_parse(ab, len, ptr,\n\t\t\t\t\t\t\t\tsvc_rdy_ext);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (!svc_rdy_ext->hw_mode_done) {\n\t\t\tret = ath11k_wmi_tlv_hw_mode_caps(ab, len, ptr,\n\t\t\t\t\t\t\t  svc_rdy_ext);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsvc_rdy_ext->hw_mode_done = true;\n\t\t} else if (!svc_rdy_ext->mac_phy_done) {\n\t\t\tsvc_rdy_ext->n_mac_phy_caps = 0;\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_mac_phy_caps_parse,\n\t\t\t\t\t\t  svc_rdy_ext);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tsvc_rdy_ext->mac_phy_done = true;\n\t\t} else if (!svc_rdy_ext->ext_hal_reg_done) {\n\t\t\tret = ath11k_wmi_tlv_ext_hal_reg_caps(ab, len, ptr,\n\t\t\t\t\t\t\t      svc_rdy_ext);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsvc_rdy_ext->ext_hal_reg_done = true;\n\t\t} else if (!svc_rdy_ext->mac_phy_chainmask_combo_done) {\n\t\t\tsvc_rdy_ext->mac_phy_chainmask_combo_done = true;\n\t\t} else if (!svc_rdy_ext->mac_phy_chainmask_cap_done) {\n\t\t\tsvc_rdy_ext->mac_phy_chainmask_cap_done = true;\n\t\t} else if (!svc_rdy_ext->oem_dma_ring_cap_done) {\n\t\t\tsvc_rdy_ext->oem_dma_ring_cap_done = true;\n\t\t} else if (!svc_rdy_ext->dma_ring_cap_done) {\n\t\t\tret = ath11k_wmi_tlv_dma_ring_caps(ab, len, ptr,\n\t\t\t\t\t\t\t   &svc_rdy_ext->dma_caps_parse);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsvc_rdy_ext->dma_ring_cap_done = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath11k_service_ready_ext_event(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse svc_rdy_ext = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_svc_rdy_ext_parse,\n\t\t\t\t  &svc_rdy_ext);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (!test_bit(WMI_TLV_SERVICE_EXT2_MSG, ab->wmi_ab.svc_map))\n\t\tcomplete(&ab->wmi_ab.service_ready);\n\n\tkfree(svc_rdy_ext.mac_phy_caps);\n\treturn 0;\n\nerr:\n\tath11k_wmi_free_dbring_caps(ab);\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_svc_rdy_ext2_parse(struct ath11k_base *ab,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext2_parse *parse = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (!parse->dma_ring_cap_done) {\n\t\t\tret = ath11k_wmi_tlv_dma_ring_caps(ab, len, ptr,\n\t\t\t\t\t\t\t   &parse->dma_caps_parse);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tparse->dma_ring_cap_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_service_ready_ext2_event(struct ath11k_base *ab,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct wmi_tlv_svc_rdy_ext2_parse svc_rdy_ext2 = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_svc_rdy_ext2_parse,\n\t\t\t\t  &svc_rdy_ext2);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse ext2 event tlv %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tcomplete(&ab->wmi_ab.service_ready);\n\n\treturn 0;\n\nerr:\n\tath11k_wmi_free_dbring_caps(ab);\n\treturn ret;\n}\n\nstatic int ath11k_pull_vdev_start_resp_tlv(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t   struct wmi_vdev_start_resp_event *vdev_rsp)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_start_resp_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_START_RESPONSE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev start resp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tmemset(vdev_rsp, 0, sizeof(*vdev_rsp));\n\n\tvdev_rsp->vdev_id = ev->vdev_id;\n\tvdev_rsp->requestor_id = ev->requestor_id;\n\tvdev_rsp->resp_type = ev->resp_type;\n\tvdev_rsp->status = ev->status;\n\tvdev_rsp->chain_mask = ev->chain_mask;\n\tvdev_rsp->smps_mode = ev->smps_mode;\n\tvdev_rsp->mac_id = ev->mac_id;\n\tvdev_rsp->cfgd_tx_streams = ev->cfgd_tx_streams;\n\tvdev_rsp->cfgd_rx_streams = ev->cfgd_rx_streams;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic struct cur_reg_rule\n*create_reg_rules_from_wmi(u32 num_reg_rules,\n\t\t\t   struct wmi_regulatory_rule_struct *wmi_reg_rule)\n{\n\tstruct cur_reg_rule *reg_rule_ptr;\n\tu32 count;\n\n\treg_rule_ptr =  kzalloc((num_reg_rules * sizeof(*reg_rule_ptr)),\n\t\t\t\tGFP_ATOMIC);\n\n\tif (!reg_rule_ptr)\n\t\treturn NULL;\n\n\tfor (count = 0; count < num_reg_rules; count++) {\n\t\treg_rule_ptr[count].start_freq =\n\t\t\tFIELD_GET(REG_RULE_START_FREQ,\n\t\t\t\t  wmi_reg_rule[count].freq_info);\n\t\treg_rule_ptr[count].end_freq =\n\t\t\tFIELD_GET(REG_RULE_END_FREQ,\n\t\t\t\t  wmi_reg_rule[count].freq_info);\n\t\treg_rule_ptr[count].max_bw =\n\t\t\tFIELD_GET(REG_RULE_MAX_BW,\n\t\t\t\t  wmi_reg_rule[count].bw_pwr_info);\n\t\treg_rule_ptr[count].reg_power =\n\t\t\tFIELD_GET(REG_RULE_REG_PWR,\n\t\t\t\t  wmi_reg_rule[count].bw_pwr_info);\n\t\treg_rule_ptr[count].ant_gain =\n\t\t\tFIELD_GET(REG_RULE_ANT_GAIN,\n\t\t\t\t  wmi_reg_rule[count].bw_pwr_info);\n\t\treg_rule_ptr[count].flags =\n\t\t\tFIELD_GET(REG_RULE_FLAGS,\n\t\t\t\t  wmi_reg_rule[count].flag_info);\n\t}\n\n\treturn reg_rule_ptr;\n}\n\nstatic int ath11k_pull_reg_chan_list_update_ev(struct ath11k_base *ab,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct cur_regulatory_info *reg_info)\n{\n\tconst void **tb;\n\tconst struct wmi_reg_chan_list_cc_event *chan_list_event_hdr;\n\tstruct wmi_regulatory_rule_struct *wmi_reg_rule;\n\tu32 num_2g_reg_rules, num_5g_reg_rules;\n\tint ret;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"processing regulatory channel list\\n\");\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchan_list_event_hdr = tb[WMI_TAG_REG_CHAN_LIST_CC_EVENT];\n\tif (!chan_list_event_hdr) {\n\t\tath11k_warn(ab, \"failed to fetch reg chan list update ev\\n\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\treg_info->num_2g_reg_rules = chan_list_event_hdr->num_2g_reg_rules;\n\treg_info->num_5g_reg_rules = chan_list_event_hdr->num_5g_reg_rules;\n\n\tif (!(reg_info->num_2g_reg_rules + reg_info->num_5g_reg_rules)) {\n\t\tath11k_warn(ab, \"No regulatory rules available in the event info\\n\");\n\t\tkfree(tb);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(reg_info->alpha2, &chan_list_event_hdr->alpha2,\n\t       REG_ALPHA2_LEN);\n\treg_info->dfs_region = chan_list_event_hdr->dfs_region;\n\treg_info->phybitmap = chan_list_event_hdr->phybitmap;\n\treg_info->num_phy = chan_list_event_hdr->num_phy;\n\treg_info->phy_id = chan_list_event_hdr->phy_id;\n\treg_info->ctry_code = chan_list_event_hdr->country_id;\n\treg_info->reg_dmn_pair = chan_list_event_hdr->domain_code;\n\tif (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_PASS)\n\t\treg_info->status_code = REG_SET_CC_STATUS_PASS;\n\telse if (chan_list_event_hdr->status_code == WMI_REG_CURRENT_ALPHA2_NOT_FOUND)\n\t\treg_info->status_code = REG_CURRENT_ALPHA2_NOT_FOUND;\n\telse if (chan_list_event_hdr->status_code == WMI_REG_INIT_ALPHA2_NOT_FOUND)\n\t\treg_info->status_code = REG_INIT_ALPHA2_NOT_FOUND;\n\telse if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_CHANGE_NOT_ALLOWED)\n\t\treg_info->status_code = REG_SET_CC_CHANGE_NOT_ALLOWED;\n\telse if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_NO_MEMORY)\n\t\treg_info->status_code = REG_SET_CC_STATUS_NO_MEMORY;\n\telse if (chan_list_event_hdr->status_code == WMI_REG_SET_CC_STATUS_FAIL)\n\t\treg_info->status_code = REG_SET_CC_STATUS_FAIL;\n\n\treg_info->min_bw_2g = chan_list_event_hdr->min_bw_2g;\n\treg_info->max_bw_2g = chan_list_event_hdr->max_bw_2g;\n\treg_info->min_bw_5g = chan_list_event_hdr->min_bw_5g;\n\treg_info->max_bw_5g = chan_list_event_hdr->max_bw_5g;\n\n\tnum_2g_reg_rules = reg_info->num_2g_reg_rules;\n\tnum_5g_reg_rules = reg_info->num_5g_reg_rules;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"%s:cc %s dsf %d BW: min_2g %d max_2g %d min_5g %d max_5g %d\",\n\t\t   __func__, reg_info->alpha2, reg_info->dfs_region,\n\t\t   reg_info->min_bw_2g, reg_info->max_bw_2g,\n\t\t   reg_info->min_bw_5g, reg_info->max_bw_5g);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"%s: num_2g_reg_rules %d num_5g_reg_rules %d\", __func__,\n\t\t   num_2g_reg_rules, num_5g_reg_rules);\n\n\twmi_reg_rule =\n\t\t(struct wmi_regulatory_rule_struct *)((u8 *)chan_list_event_hdr\n\t\t\t\t\t\t+ sizeof(*chan_list_event_hdr)\n\t\t\t\t\t\t+ sizeof(struct wmi_tlv));\n\n\tif (num_2g_reg_rules) {\n\t\treg_info->reg_rules_2g_ptr = create_reg_rules_from_wmi(num_2g_reg_rules,\n\t\t\t\t\t\t\t\t       wmi_reg_rule);\n\t\tif (!reg_info->reg_rules_2g_ptr) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 2g rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (num_5g_reg_rules) {\n\t\twmi_reg_rule += num_2g_reg_rules;\n\t\treg_info->reg_rules_5g_ptr = create_reg_rules_from_wmi(num_5g_reg_rules,\n\t\t\t\t\t\t\t\t       wmi_reg_rule);\n\t\tif (!reg_info->reg_rules_5g_ptr) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 5g rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"processed regulatory channel list\\n\");\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_peer_del_resp_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\tstruct wmi_peer_delete_resp_event *peer_del_resp)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_delete_resp_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PEER_DELETE_RESP_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch peer delete resp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tmemset(peer_del_resp, 0, sizeof(*peer_del_resp));\n\n\tpeer_del_resp->vdev_id = ev->vdev_id;\n\tether_addr_copy(peer_del_resp->peer_macaddr.addr,\n\t\t\tev->peer_macaddr.addr);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_vdev_del_resp_ev(struct ath11k_base *ab,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tu32 *vdev_id)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_delete_resp_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_DELETE_RESP_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev delete resp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t*vdev_id = ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_bcn_tx_status_ev(struct ath11k_base *ab, void *evt_buf,\n\t\t\t\t\tu32 len, u32 *vdev_id,\n\t\t\t\t\tu32 *tx_status)\n{\n\tconst void **tb;\n\tconst struct wmi_bcn_tx_status_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, evt_buf, len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_OFFLOAD_BCN_TX_STATUS_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch bcn tx status ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t*vdev_id   = ev->vdev_id;\n\t*tx_status = ev->tx_status;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_vdev_stopped_param_tlv(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t      u32 *vdev_id)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_stopped_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_STOPPED_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev stop ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t*vdev_id =  ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_mgmt_rx_params_tlv(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct mgmt_rx_event_params *hdr)\n{\n\tconst void **tb;\n\tconst struct wmi_mgmt_rx_hdr *ev;\n\tconst u8 *frame;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_MGMT_RX_HDR];\n\tframe = tb[WMI_TAG_ARRAY_BYTE];\n\n\tif (!ev || !frame) {\n\t\tath11k_warn(ab, \"failed to fetch mgmt rx hdr\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\thdr->pdev_id =  ev->pdev_id;\n\thdr->chan_freq = ev->chan_freq;\n\thdr->channel =  ev->channel;\n\thdr->snr =  ev->snr;\n\thdr->rate =  ev->rate;\n\thdr->phy_mode =  ev->phy_mode;\n\thdr->buf_len =  ev->buf_len;\n\thdr->status =  ev->status;\n\thdr->flags =  ev->flags;\n\thdr->rssi =  ev->rssi;\n\thdr->tsf_delta =  ev->tsf_delta;\n\tmemcpy(hdr->rssi_ctl, ev->rssi_ctl, sizeof(hdr->rssi_ctl));\n\n\tif (skb->len < (frame - skb->data) + hdr->buf_len) {\n\t\tath11k_warn(ab, \"invalid length in mgmt rx hdr ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t/* shift the sk_buff to point to `frame` */\n\tskb_trim(skb, 0);\n\tskb_put(skb, frame - skb->data);\n\tskb_pull(skb, frame - skb->data);\n\tskb_put(skb, hdr->buf_len);\n\n\tath11k_ce_byte_swap(skb->data, hdr->buf_len);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int wmi_process_mgmt_tx_comp(struct ath11k *ar, u32 desc_id,\n\t\t\t\t    u32 status)\n{\n\tstruct sk_buff *msdu;\n\tstruct ieee80211_tx_info *info;\n\tstruct ath11k_skb_cb *skb_cb;\n\n\tspin_lock_bh(&ar->txmgmt_idr_lock);\n\tmsdu = idr_find(&ar->txmgmt_idr, desc_id);\n\n\tif (!msdu) {\n\t\tath11k_warn(ar->ab, \"received mgmt tx compl for invalid msdu_id: %d\\n\",\n\t\t\t    desc_id);\n\t\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tidr_remove(&ar->txmgmt_idr, desc_id);\n\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\n\tskb_cb = ATH11K_SKB_CB(msdu);\n\tdma_unmap_single(ar->ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\n\tinfo = IEEE80211_SKB_CB(msdu);\n\tif ((!(info->flags & IEEE80211_TX_CTL_NO_ACK)) && !status)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tieee80211_tx_status_irqsafe(ar->hw, msdu);\n\n\t/* WARN when we received this event without doing any mgmt tx */\n\tif (atomic_dec_if_positive(&ar->num_pending_mgmt_tx) < 0)\n\t\tWARN_ON_ONCE(1);\n\n\treturn 0;\n}\n\nstatic int ath11k_pull_mgmt_tx_compl_param_tlv(struct ath11k_base *ab,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct wmi_mgmt_tx_compl_event *param)\n{\n\tconst void **tb;\n\tconst struct wmi_mgmt_tx_compl_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_MGMT_TX_COMPL_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch mgmt tx compl ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tparam->pdev_id = ev->pdev_id;\n\tparam->desc_id = ev->desc_id;\n\tparam->status = ev->status;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath11k_wmi_event_scan_started(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tath11k_warn(ar->ab, \"received scan started event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\t\tar->scan.state = ATH11K_SCAN_RUNNING;\n\t\tcomplete(&ar->scan.started);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_start_failed(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tath11k_warn(ar->ab, \"received scan start failed event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\t\tcomplete(&ar->scan.started);\n\t\t__ath11k_mac_scan_finish(ar);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_completed(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\t/* One suspected reason scan can be completed while starting is\n\t\t * if firmware fails to deliver all scan events to the host,\n\t\t * e.g. when transport pipe is full. This has been observed\n\t\t * with spectral scan phyerr events starving wmi transport\n\t\t * pipe. In such case the \"scan completed\" event should be (and\n\t\t * is) ignored by the host as it may be just firmware's scan\n\t\t * state machine recovering.\n\t\t */\n\t\tath11k_warn(ar->ab, \"received scan completed event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\t__ath11k_mac_scan_finish(ar);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_bss_chan(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\tath11k_warn(ar->ab, \"received scan bss chan event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tar->scan_channel = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_foreign_chan(struct ath11k *ar, u32 freq)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\tath11k_warn(ar->ab, \"received scan foreign chan event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tar->scan_channel = ieee80211_get_channel(ar->hw->wiphy, freq);\n\t\tbreak;\n\t}\n}\n\nstatic const char *\nath11k_wmi_event_scan_type_str(enum wmi_scan_event_type type,\n\t\t\t       enum wmi_scan_completion_reason reason)\n{\n\tswitch (type) {\n\tcase WMI_SCAN_EVENT_STARTED:\n\t\treturn \"started\";\n\tcase WMI_SCAN_EVENT_COMPLETED:\n\t\tswitch (reason) {\n\t\tcase WMI_SCAN_REASON_COMPLETED:\n\t\t\treturn \"completed\";\n\t\tcase WMI_SCAN_REASON_CANCELLED:\n\t\t\treturn \"completed [cancelled]\";\n\t\tcase WMI_SCAN_REASON_PREEMPTED:\n\t\t\treturn \"completed [preempted]\";\n\t\tcase WMI_SCAN_REASON_TIMEDOUT:\n\t\t\treturn \"completed [timedout]\";\n\t\tcase WMI_SCAN_REASON_INTERNAL_FAILURE:\n\t\t\treturn \"completed [internal err]\";\n\t\tcase WMI_SCAN_REASON_MAX:\n\t\t\tbreak;\n\t\t}\n\t\treturn \"completed [unknown]\";\n\tcase WMI_SCAN_EVENT_BSS_CHANNEL:\n\t\treturn \"bss channel\";\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN:\n\t\treturn \"foreign channel\";\n\tcase WMI_SCAN_EVENT_DEQUEUED:\n\t\treturn \"dequeued\";\n\tcase WMI_SCAN_EVENT_PREEMPTED:\n\t\treturn \"preempted\";\n\tcase WMI_SCAN_EVENT_START_FAILED:\n\t\treturn \"start failed\";\n\tcase WMI_SCAN_EVENT_RESTARTED:\n\t\treturn \"restarted\";\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN_EXIT:\n\t\treturn \"foreign channel exit\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic int ath11k_pull_scan_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t       struct wmi_scan_event *scan_evt_param)\n{\n\tconst void **tb;\n\tconst struct wmi_scan_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_SCAN_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch scan ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tscan_evt_param->event_type = ev->event_type;\n\tscan_evt_param->reason = ev->reason;\n\tscan_evt_param->channel_freq = ev->channel_freq;\n\tscan_evt_param->scan_req_id = ev->scan_req_id;\n\tscan_evt_param->scan_id = ev->scan_id;\n\tscan_evt_param->vdev_id = ev->vdev_id;\n\tscan_evt_param->tsf_timestamp = ev->tsf_timestamp;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_peer_sta_kickout_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t   struct wmi_peer_sta_kickout_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_sta_kickout_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PEER_STA_KICKOUT_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch peer sta kickout ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->mac_addr = ev->peer_macaddr.addr;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_roam_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t       struct wmi_roam_event *roam_ev)\n{\n\tconst void **tb;\n\tconst struct wmi_roam_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_ROAM_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch roam ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\troam_ev->vdev_id = ev->vdev_id;\n\troam_ev->reason = ev->reason;\n\troam_ev->rssi = ev->rssi;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int freq_to_idx(struct ath11k *ar, int freq)\n{\n\tstruct ieee80211_supported_band *sband;\n\tint band, ch, idx = 0;\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = ar->hw->wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (ch = 0; ch < sband->n_channels; ch++, idx++)\n\t\t\tif (sband->channels[ch].center_freq == freq)\n\t\t\t\tgoto exit;\n\t}\n\nexit:\n\treturn idx;\n}\n\nstatic int ath11k_pull_chan_info_ev(struct ath11k_base *ab, u8 *evt_buf,\n\t\t\t\t    u32 len, struct wmi_chan_info_event *ch_info_ev)\n{\n\tconst void **tb;\n\tconst struct wmi_chan_info_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, evt_buf, len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_CHAN_INFO_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch chan info ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tch_info_ev->err_code = ev->err_code;\n\tch_info_ev->freq = ev->freq;\n\tch_info_ev->cmd_flags = ev->cmd_flags;\n\tch_info_ev->noise_floor = ev->noise_floor;\n\tch_info_ev->rx_clear_count = ev->rx_clear_count;\n\tch_info_ev->cycle_count = ev->cycle_count;\n\tch_info_ev->chan_tx_pwr_range = ev->chan_tx_pwr_range;\n\tch_info_ev->chan_tx_pwr_tp = ev->chan_tx_pwr_tp;\n\tch_info_ev->rx_frame_count = ev->rx_frame_count;\n\tch_info_ev->tx_frame_cnt = ev->tx_frame_cnt;\n\tch_info_ev->mac_clk_mhz = ev->mac_clk_mhz;\n\tch_info_ev->vdev_id = ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath11k_pull_pdev_bss_chan_info_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t  struct wmi_pdev_bss_chan_info_event *bss_ch_info_ev)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_bss_chan_info_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_BSS_CHAN_INFO_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev bss chan info ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tbss_ch_info_ev->pdev_id = ev->pdev_id;\n\tbss_ch_info_ev->freq = ev->freq;\n\tbss_ch_info_ev->noise_floor = ev->noise_floor;\n\tbss_ch_info_ev->rx_clear_count_low = ev->rx_clear_count_low;\n\tbss_ch_info_ev->rx_clear_count_high = ev->rx_clear_count_high;\n\tbss_ch_info_ev->cycle_count_low = ev->cycle_count_low;\n\tbss_ch_info_ev->cycle_count_high = ev->cycle_count_high;\n\tbss_ch_info_ev->tx_cycle_count_low = ev->tx_cycle_count_low;\n\tbss_ch_info_ev->tx_cycle_count_high = ev->tx_cycle_count_high;\n\tbss_ch_info_ev->rx_cycle_count_low = ev->rx_cycle_count_low;\n\tbss_ch_info_ev->rx_cycle_count_high = ev->rx_cycle_count_high;\n\tbss_ch_info_ev->rx_bss_cycle_count_low = ev->rx_bss_cycle_count_low;\n\tbss_ch_info_ev->rx_bss_cycle_count_high = ev->rx_bss_cycle_count_high;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath11k_pull_vdev_install_key_compl_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t      struct wmi_vdev_install_key_complete_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_install_key_compl_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_INSTALL_KEY_COMPLETE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev install key compl ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->vdev_id = ev->vdev_id;\n\targ->macaddr = ev->peer_macaddr.addr;\n\targ->key_idx = ev->key_idx;\n\targ->key_flags = ev->key_flags;\n\targ->status = ev->status;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_peer_assoc_conf_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t  struct wmi_peer_assoc_conf_arg *peer_assoc_conf)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_assoc_conf_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PEER_ASSOC_CONF_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch peer assoc conf ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tpeer_assoc_conf->vdev_id = ev->vdev_id;\n\tpeer_assoc_conf->macaddr = ev->peer_macaddr.addr;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath11k_wmi_pull_pdev_stats_base(const struct wmi_pdev_stats_base *src,\n\t\t\t\t\t    struct ath11k_fw_stats_pdev *dst)\n{\n\tdst->ch_noise_floor = src->chan_nf;\n\tdst->tx_frame_count = src->tx_frame_count;\n\tdst->rx_frame_count = src->rx_frame_count;\n\tdst->rx_clear_count = src->rx_clear_count;\n\tdst->cycle_count = src->cycle_count;\n\tdst->phy_err_count = src->phy_err_count;\n\tdst->chan_tx_power = src->chan_tx_pwr;\n}\n\nstatic void\nath11k_wmi_pull_pdev_stats_tx(const struct wmi_pdev_stats_tx *src,\n\t\t\t      struct ath11k_fw_stats_pdev *dst)\n{\n\tdst->comp_queued = src->comp_queued;\n\tdst->comp_delivered = src->comp_delivered;\n\tdst->msdu_enqued = src->msdu_enqued;\n\tdst->mpdu_enqued = src->mpdu_enqued;\n\tdst->wmm_drop = src->wmm_drop;\n\tdst->local_enqued = src->local_enqued;\n\tdst->local_freed = src->local_freed;\n\tdst->hw_queued = src->hw_queued;\n\tdst->hw_reaped = src->hw_reaped;\n\tdst->underrun = src->underrun;\n\tdst->tx_abort = src->tx_abort;\n\tdst->mpdus_requed = src->mpdus_requed;\n\tdst->tx_ko = src->tx_ko;\n\tdst->data_rc = src->data_rc;\n\tdst->self_triggers = src->self_triggers;\n\tdst->sw_retry_failure = src->sw_retry_failure;\n\tdst->illgl_rate_phy_err = src->illgl_rate_phy_err;\n\tdst->pdev_cont_xretry = src->pdev_cont_xretry;\n\tdst->pdev_tx_timeout = src->pdev_tx_timeout;\n\tdst->pdev_resets = src->pdev_resets;\n\tdst->stateless_tid_alloc_failure = src->stateless_tid_alloc_failure;\n\tdst->phy_underrun = src->phy_underrun;\n\tdst->txop_ovf = src->txop_ovf;\n}\n\nstatic void ath11k_wmi_pull_pdev_stats_rx(const struct wmi_pdev_stats_rx *src,\n\t\t\t\t\t  struct ath11k_fw_stats_pdev *dst)\n{\n\tdst->mid_ppdu_route_change = src->mid_ppdu_route_change;\n\tdst->status_rcvd = src->status_rcvd;\n\tdst->r0_frags = src->r0_frags;\n\tdst->r1_frags = src->r1_frags;\n\tdst->r2_frags = src->r2_frags;\n\tdst->r3_frags = src->r3_frags;\n\tdst->htt_msdus = src->htt_msdus;\n\tdst->htt_mpdus = src->htt_mpdus;\n\tdst->loc_msdus = src->loc_msdus;\n\tdst->loc_mpdus = src->loc_mpdus;\n\tdst->oversize_amsdu = src->oversize_amsdu;\n\tdst->phy_errs = src->phy_errs;\n\tdst->phy_err_drop = src->phy_err_drop;\n\tdst->mpdu_errs = src->mpdu_errs;\n}\n\nstatic void\nath11k_wmi_pull_vdev_stats(const struct wmi_vdev_stats *src,\n\t\t\t   struct ath11k_fw_stats_vdev *dst)\n{\n\tint i;\n\n\tdst->vdev_id = src->vdev_id;\n\tdst->beacon_snr = src->beacon_snr;\n\tdst->data_snr = src->data_snr;\n\tdst->num_rx_frames = src->num_rx_frames;\n\tdst->num_rts_fail = src->num_rts_fail;\n\tdst->num_rts_success = src->num_rts_success;\n\tdst->num_rx_err = src->num_rx_err;\n\tdst->num_rx_discard = src->num_rx_discard;\n\tdst->num_tx_not_acked = src->num_tx_not_acked;\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames); i++)\n\t\tdst->num_tx_frames[i] = src->num_tx_frames[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_retries); i++)\n\t\tdst->num_tx_frames_retries[i] = src->num_tx_frames_retries[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_failures); i++)\n\t\tdst->num_tx_frames_failures[i] = src->num_tx_frames_failures[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->tx_rate_history); i++)\n\t\tdst->tx_rate_history[i] = src->tx_rate_history[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->beacon_rssi_history); i++)\n\t\tdst->beacon_rssi_history[i] = src->beacon_rssi_history[i];\n}\n\nstatic void\nath11k_wmi_pull_bcn_stats(const struct wmi_bcn_stats *src,\n\t\t\t  struct ath11k_fw_stats_bcn *dst)\n{\n\tdst->vdev_id = src->vdev_id;\n\tdst->tx_bcn_succ_cnt = src->tx_bcn_succ_cnt;\n\tdst->tx_bcn_outage_cnt = src->tx_bcn_outage_cnt;\n}\n\nint ath11k_wmi_pull_fw_stats(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t     struct ath11k_fw_stats *stats)\n{\n\tconst void **tb;\n\tconst struct wmi_stats_event *ev;\n\tconst void *data;\n\tint i, ret;\n\tu32 len = skb->len;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_STATS_EVENT];\n\tdata = tb[WMI_TAG_ARRAY_BYTE];\n\tif (!ev || !data) {\n\t\tath11k_warn(ab, \"failed to fetch update stats ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"wmi stats update ev pdev_id %d pdev %i vdev %i bcn %i\\n\",\n\t\t   ev->pdev_id,\n\t\t   ev->num_pdev_stats, ev->num_vdev_stats,\n\t\t   ev->num_bcn_stats);\n\n\tstats->pdev_id = ev->pdev_id;\n\tstats->stats_id = 0;\n\n\tfor (i = 0; i < ev->num_pdev_stats; i++) {\n\t\tconst struct wmi_pdev_stats *src;\n\t\tstruct ath11k_fw_stats_pdev *dst;\n\n\t\tsrc = data;\n\t\tif (len < sizeof(*src)) {\n\t\t\tkfree(tb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tstats->stats_id = WMI_REQUEST_PDEV_STAT;\n\n\t\tdata += sizeof(*src);\n\t\tlen -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath11k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath11k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath11k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\tfor (i = 0; i < ev->num_vdev_stats; i++) {\n\t\tconst struct wmi_vdev_stats *src;\n\t\tstruct ath11k_fw_stats_vdev *dst;\n\n\t\tsrc = data;\n\t\tif (len < sizeof(*src)) {\n\t\t\tkfree(tb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tstats->stats_id = WMI_REQUEST_VDEV_STAT;\n\n\t\tdata += sizeof(*src);\n\t\tlen -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath11k_wmi_pull_vdev_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->vdevs);\n\t}\n\n\tfor (i = 0; i < ev->num_bcn_stats; i++) {\n\t\tconst struct wmi_bcn_stats *src;\n\t\tstruct ath11k_fw_stats_bcn *dst;\n\n\t\tsrc = data;\n\t\tif (len < sizeof(*src)) {\n\t\t\tkfree(tb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tstats->stats_id = WMI_REQUEST_BCN_STAT;\n\n\t\tdata += sizeof(*src);\n\t\tlen -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath11k_wmi_pull_bcn_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->bcn);\n\t}\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath11k_pull_pdev_temp_ev(struct ath11k_base *ab, u8 *evt_buf,\n\t\t\t u32 len, const struct wmi_pdev_temperature_event *ev)\n{\n\tconst void **tb;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, evt_buf, len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_TEMPERATURE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev temp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tkfree(tb);\n\treturn 0;\n}\n\nsize_t ath11k_wmi_fw_stats_num_vdevs(struct list_head *head)\n{\n\tstruct ath11k_fw_stats_vdev *i;\n\tsize_t num = 0;\n\n\tlist_for_each_entry(i, head, list)\n\t\t++num;\n\n\treturn num;\n}\n\nstatic size_t ath11k_wmi_fw_stats_num_bcn(struct list_head *head)\n{\n\tstruct ath11k_fw_stats_bcn *i;\n\tsize_t num = 0;\n\n\tlist_for_each_entry(i, head, list)\n\t\t++num;\n\n\treturn num;\n}\n\nstatic void\nath11k_wmi_fw_pdev_base_stats_fill(const struct ath11k_fw_stats_pdev *pdev,\n\t\t\t\t   char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\",\n\t\t\t\"ath11k PDEV stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\"=================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Channel noise floor\", pdev->ch_noise_floor);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"Channel TX power\", pdev->chan_tx_power);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"TX frame count\", pdev->tx_frame_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RX frame count\", pdev->rx_frame_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RX clear count\", pdev->rx_clear_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"Cycle count\", pdev->cycle_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"PHY error count\", pdev->phy_err_count);\n\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_pdev_tx_stats_fill(const struct ath11k_fw_stats_pdev *pdev,\n\t\t\t\t char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n%30s\\n\",\n\t\t\t \"ath11k PDEV TX stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t \"====================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HTT cookies queued\", pdev->comp_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HTT cookies disp.\", pdev->comp_delivered);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDU queued\", pdev->msdu_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU queued\", pdev->mpdu_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs dropped\", pdev->wmm_drop);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Local enqued\", pdev->local_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Local freed\", pdev->local_freed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HW queued\", pdev->hw_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PPDUs reaped\", pdev->hw_reaped);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Num underruns\", pdev->underrun);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PPDUs cleaned\", pdev->tx_abort);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs requed\", pdev->mpdus_requed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Excessive retries\", pdev->tx_ko);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"HW rate\", pdev->data_rc);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Sched self triggers\", pdev->self_triggers);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Dropped due to SW retries\",\n\t\t\t pdev->sw_retry_failure);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Illegal rate phy errors\",\n\t\t\t pdev->illgl_rate_phy_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PDEV continuous xretry\", pdev->pdev_cont_xretry);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"TX timeout\", pdev->pdev_tx_timeout);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PDEV resets\", pdev->pdev_resets);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Stateless TIDs alloc failures\",\n\t\t\t pdev->stateless_tid_alloc_failure);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PHY underrun\", pdev->phy_underrun);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"MPDU is more than txop limit\", pdev->txop_ovf);\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_pdev_rx_stats_fill(const struct ath11k_fw_stats_pdev *pdev,\n\t\t\t\t char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n%30s\\n\",\n\t\t\t \"ath11k PDEV RX stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t \"====================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Mid PPDU route change\",\n\t\t\t pdev->mid_ppdu_route_change);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Tot. number of statuses\", pdev->status_rcvd);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 0\", pdev->r0_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 1\", pdev->r1_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 2\", pdev->r2_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 3\", pdev->r3_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs delivered to HTT\", pdev->htt_msdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs delivered to HTT\", pdev->htt_mpdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs delivered to stack\", pdev->loc_msdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs delivered to stack\", pdev->loc_mpdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Oversized AMSUs\", pdev->oversize_amsdu);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY errors\", pdev->phy_errs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY errors drops\", pdev->phy_err_drop);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU errors (FCS, MIC, ENC)\", pdev->mpdu_errs);\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_vdev_stats_fill(struct ath11k *ar,\n\t\t\t      const struct ath11k_fw_stats_vdev *vdev,\n\t\t\t      char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\tstruct ath11k_vif *arvif = ath11k_mac_get_arvif(ar, vdev->vdev_id);\n\tu8 *vif_macaddr;\n\tint i;\n\n\t/* VDEV stats has all the active VDEVs of other PDEVs as well,\n\t * ignoring those not part of requested PDEV\n\t */\n\tif (!arvif)\n\t\treturn;\n\n\tvif_macaddr = arvif->vif->addr;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"VDEV ID\", vdev->vdev_id);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %pM\\n\",\n\t\t\t \"VDEV MAC address\", vif_macaddr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"beacon snr\", vdev->beacon_snr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"data snr\", vdev->data_snr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rx frames\", vdev->num_rx_frames);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rts fail\", vdev->num_rts_fail);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rts success\", vdev->num_rts_success);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rx err\", vdev->num_rx_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rx discard\", vdev->num_rx_discard);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num tx not acked\", vdev->num_tx_not_acked);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames\", i,\n\t\t\t\tvdev->num_tx_frames[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames_retries); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames retries\", i,\n\t\t\t\tvdev->num_tx_frames_retries[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames_failures); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames failures\", i,\n\t\t\t\tvdev->num_tx_frames_failures[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->tx_rate_history); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] 0x%08x\\n\",\n\t\t\t\t\"tx rate history\", i,\n\t\t\t\tvdev->tx_rate_history[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->beacon_rssi_history); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"beacon rssi history\", i,\n\t\t\t\tvdev->beacon_rssi_history[i]);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_bcn_stats_fill(struct ath11k *ar,\n\t\t\t     const struct ath11k_fw_stats_bcn *bcn,\n\t\t\t     char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\tstruct ath11k_vif *arvif = ath11k_mac_get_arvif(ar, bcn->vdev_id);\n\tu8 *vdev_macaddr;\n\n\tif (!arvif) {\n\t\tath11k_warn(ar->ab, \"invalid vdev id %d in bcn stats\",\n\t\t\t    bcn->vdev_id);\n\t\treturn;\n\t}\n\n\tvdev_macaddr = arvif->vif->addr;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"VDEV ID\", bcn->vdev_id);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %pM\\n\",\n\t\t\t \"VDEV MAC address\", vdev_macaddr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t \"================\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"Num of beacon tx success\", bcn->tx_bcn_succ_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"Num of beacon tx failures\", bcn->tx_bcn_outage_cnt);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nvoid ath11k_wmi_fw_stats_fill(struct ath11k *ar,\n\t\t\t      struct ath11k_fw_stats *fw_stats,\n\t\t\t      u32 stats_id, char *buf)\n{\n\tu32 len = 0;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\tconst struct ath11k_fw_stats_pdev *pdev;\n\tconst struct ath11k_fw_stats_vdev *vdev;\n\tconst struct ath11k_fw_stats_bcn *bcn;\n\tsize_t num_bcn;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (stats_id == WMI_REQUEST_PDEV_STAT) {\n\t\tpdev = list_first_entry_or_null(&fw_stats->pdevs,\n\t\t\t\t\t\tstruct ath11k_fw_stats_pdev, list);\n\t\tif (!pdev) {\n\t\t\tath11k_warn(ar->ab, \"failed to get pdev stats\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tath11k_wmi_fw_pdev_base_stats_fill(pdev, buf, &len);\n\t\tath11k_wmi_fw_pdev_tx_stats_fill(pdev, buf, &len);\n\t\tath11k_wmi_fw_pdev_rx_stats_fill(pdev, buf, &len);\n\t}\n\n\tif (stats_id == WMI_REQUEST_VDEV_STAT) {\n\t\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\",\n\t\t\t\t \"ath11k VDEV stats\");\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\t\tlist_for_each_entry(vdev, &fw_stats->vdevs, list)\n\t\t\tath11k_wmi_fw_vdev_stats_fill(ar, vdev, buf, &len);\n\t}\n\n\tif (stats_id == WMI_REQUEST_BCN_STAT) {\n\t\tnum_bcn = ath11k_wmi_fw_stats_num_bcn(&fw_stats->bcn);\n\n\t\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t\t \"ath11k Beacon stats\", num_bcn);\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"===================\");\n\n\t\tlist_for_each_entry(bcn, &fw_stats->bcn, list)\n\t\t\tath11k_wmi_fw_bcn_stats_fill(ar, bcn, buf, &len);\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len >= buf_len)\n\t\tbuf[len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n}\n\nstatic void ath11k_wmi_op_ep_tx_credits(struct ath11k_base *ab)\n{\n\t/* try to send pending beacons first. they take priority */\n\twake_up(&ab->wmi_ab.tx_credits_wq);\n}\n\nstatic void ath11k_wmi_htc_tx_complete(struct ath11k_base *ab,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tdev_kfree_skb(skb);\n}\n\nstatic bool ath11k_reg_is_world_alpha(char *alpha)\n{\n\treturn alpha[0] == '0' && alpha[1] == '0';\n}\n\nstatic int ath11k_reg_chan_list_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct cur_regulatory_info *reg_info = NULL;\n\tstruct ieee80211_regdomain *regd = NULL;\n\tbool intersect = false;\n\tint ret = 0, pdev_idx;\n\tstruct ath11k *ar;\n\n\treg_info = kzalloc(sizeof(*reg_info), GFP_ATOMIC);\n\tif (!reg_info) {\n\t\tret = -ENOMEM;\n\t\tgoto fallback;\n\t}\n\n\tret = ath11k_pull_reg_chan_list_update_ev(ab, skb, reg_info);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to extract regulatory info from received event\\n\");\n\t\tgoto fallback;\n\t}\n\n\tif (reg_info->status_code != REG_SET_CC_STATUS_PASS) {\n\t\t/* In case of failure to set the requested ctry,\n\t\t * fw retains the current regd. We print a failure info\n\t\t * and return from here.\n\t\t */\n\t\tath11k_warn(ab, \"Failed to set the requested Country regulatory setting\\n\");\n\t\tgoto mem_free;\n\t}\n\n\tpdev_idx = reg_info->phy_id;\n\n\tif (pdev_idx >= ab->num_radios) {\n\t\t/* Process the event for phy0 only if single_pdev_only\n\t\t * is true. If pdev_idx is valid but not 0, discard the\n\t\t * event. Otherwise, it goes to fallback.\n\t\t */\n\t\tif (ab->hw_params.single_pdev_only &&\n\t\t    pdev_idx < ab->hw_params.num_rxmda_per_pdev)\n\t\t\tgoto mem_free;\n\t\telse\n\t\t\tgoto fallback;\n\t}\n\n\t/* Avoid multiple overwrites to default regd, during core\n\t * stop-start after mac registration.\n\t */\n\tif (ab->default_regd[pdev_idx] && !ab->new_regd[pdev_idx] &&\n\t    !memcmp((char *)ab->default_regd[pdev_idx]->alpha2,\n\t\t    (char *)reg_info->alpha2, 2))\n\t\tgoto mem_free;\n\n\t/* Intersect new rules with default regd if a new country setting was\n\t * requested, i.e a default regd was already set during initialization\n\t * and the regd coming from this event has a valid country info.\n\t */\n\tif (ab->default_regd[pdev_idx] &&\n\t    !ath11k_reg_is_world_alpha((char *)\n\t\tab->default_regd[pdev_idx]->alpha2) &&\n\t    !ath11k_reg_is_world_alpha((char *)reg_info->alpha2))\n\t\tintersect = true;\n\n\tregd = ath11k_reg_build_regd(ab, reg_info, intersect);\n\tif (!regd) {\n\t\tath11k_warn(ab, \"failed to build regd from reg_info\\n\");\n\t\tgoto fallback;\n\t}\n\n\tspin_lock(&ab->base_lock);\n\tif (test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags)) {\n\t\t/* Once mac is registered, ar is valid and all CC events from\n\t\t * fw is considered to be received due to user requests\n\t\t * currently.\n\t\t * Free previously built regd before assigning the newly\n\t\t * generated regd to ar. NULL pointer handling will be\n\t\t * taken care by kfree itself.\n\t\t */\n\t\tar = ab->pdevs[pdev_idx].ar;\n\t\tkfree(ab->new_regd[pdev_idx]);\n\t\tab->new_regd[pdev_idx] = regd;\n\t\tieee80211_queue_work(ar->hw, &ar->regd_update_work);\n\t} else {\n\t\t/* Multiple events for the same *ar is not expected. But we\n\t\t * can still clear any previously stored default_regd if we\n\t\t * are receiving this event for the same radio by mistake.\n\t\t * NULL pointer handling will be taken care by kfree itself.\n\t\t */\n\t\tkfree(ab->default_regd[pdev_idx]);\n\t\t/* This regd would be applied during mac registration */\n\t\tab->default_regd[pdev_idx] = regd;\n\t}\n\tab->dfs_region = reg_info->dfs_region;\n\tspin_unlock(&ab->base_lock);\n\n\tgoto mem_free;\n\nfallback:\n\t/* Fallback to older reg (by sending previous country setting\n\t * again if fw has succeded and we failed to process here.\n\t * The Regdomain should be uniform across driver and fw. Since the\n\t * FW has processed the command and sent a success status, we expect\n\t * this function to succeed as well. If it doesn't, CTRY needs to be\n\t * reverted at the fw and the old SCAN_CHAN_LIST cmd needs to be sent.\n\t */\n\t/* TODO: This is rare, but still should also be handled */\n\tWARN_ON(1);\nmem_free:\n\tif (reg_info) {\n\t\tkfree(reg_info->reg_rules_2g_ptr);\n\t\tkfree(reg_info->reg_rules_5g_ptr);\n\t\tkfree(reg_info);\n\t}\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_rdy_parse(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\t    const void *ptr, void *data)\n{\n\tstruct wmi_tlv_rdy_parse *rdy_parse = data;\n\tstruct wmi_ready_event fixed_param;\n\tstruct wmi_mac_addr *addr_list;\n\tstruct ath11k_pdev *pdev;\n\tu32 num_mac_addr;\n\tint i;\n\n\tswitch (tag) {\n\tcase WMI_TAG_READY_EVENT:\n\t\tmemset(&fixed_param, 0, sizeof(fixed_param));\n\t\tmemcpy(&fixed_param, (struct wmi_ready_event *)ptr,\n\t\t       min_t(u16, sizeof(fixed_param), len));\n\t\tab->wlan_init_status = fixed_param.ready_event_min.status;\n\t\trdy_parse->num_extra_mac_addr =\n\t\t\tfixed_param.ready_event_min.num_extra_mac_addr;\n\n\t\tether_addr_copy(ab->mac_addr,\n\t\t\t\tfixed_param.ready_event_min.mac_addr.addr);\n\t\tab->pktlog_defs_checksum = fixed_param.pktlog_defs_checksum;\n\t\tab->wmi_ready = true;\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_FIXED_STRUCT:\n\t\taddr_list = (struct wmi_mac_addr *)ptr;\n\t\tnum_mac_addr = rdy_parse->num_extra_mac_addr;\n\n\t\tif (!(ab->num_radios > 1 && num_mac_addr >= ab->num_radios))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ab->num_radios; i++) {\n\t\t\tpdev = &ab->pdevs[i];\n\t\t\tether_addr_copy(pdev->mac_addr, addr_list[i].addr);\n\t\t}\n\t\tab->pdevs_macaddr_valid = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_ready_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_tlv_rdy_parse rdy_parse = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_rdy_parse, &rdy_parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcomplete(&ab->wmi_ab.unified_ready);\n\treturn 0;\n}\n\nstatic void ath11k_peer_delete_resp_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_peer_delete_resp_event peer_del_resp;\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_peer_del_resp_ev(ab, skb, &peer_del_resp) != 0) {\n\t\tath11k_warn(ab, \"failed to extract peer delete resp\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, peer_del_resp.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in peer delete resp ev %d\",\n\t\t\t    peer_del_resp.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->peer_delete_done);\n\trcu_read_unlock();\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"peer delete resp for vdev id %d addr %pM\\n\",\n\t\t   peer_del_resp.vdev_id, peer_del_resp.peer_macaddr.addr);\n}\n\nstatic void ath11k_vdev_delete_resp_event(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tu32 vdev_id = 0;\n\n\tif (ath11k_pull_vdev_del_resp_ev(ab, skb, &vdev_id) != 0) {\n\t\tath11k_warn(ab, \"failed to extract vdev delete resp\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in vdev delete resp ev %d\",\n\t\t\t    vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->vdev_delete_done);\n\n\trcu_read_unlock();\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"vdev delete resp for vdev id %d\\n\",\n\t\t   vdev_id);\n}\n\nstatic inline const char *ath11k_wmi_vdev_resp_print(u32 vdev_resp_status)\n{\n\tswitch (vdev_resp_status) {\n\tcase WMI_VDEV_START_RESPONSE_INVALID_VDEVID:\n\t\treturn \"invalid vdev id\";\n\tcase WMI_VDEV_START_RESPONSE_NOT_SUPPORTED:\n\t\treturn \"not supported\";\n\tcase WMI_VDEV_START_RESPONSE_DFS_VIOLATION:\n\t\treturn \"dfs violation\";\n\tcase WMI_VDEV_START_RESPONSE_INVALID_REGDOMAIN:\n\t\treturn \"invalid regdomain\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void ath11k_vdev_start_resp_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_vdev_start_resp_event vdev_start_resp;\n\tstruct ath11k *ar;\n\tu32 status;\n\n\tif (ath11k_pull_vdev_start_resp_tlv(ab, skb, &vdev_start_resp) != 0) {\n\t\tath11k_warn(ab, \"failed to extract vdev start resp\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_start_resp.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in vdev start resp ev %d\",\n\t\t\t    vdev_start_resp.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tar->last_wmi_vdev_start_status = 0;\n\n\tstatus = vdev_start_resp.status;\n\n\tif (WARN_ON_ONCE(status)) {\n\t\tath11k_warn(ab, \"vdev start resp error status %d (%s)\\n\",\n\t\t\t    status, ath11k_wmi_vdev_resp_print(status));\n\t\tar->last_wmi_vdev_start_status = status;\n\t}\n\n\tcomplete(&ar->vdev_setup_done);\n\n\trcu_read_unlock();\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"vdev start resp for vdev id %d\",\n\t\t   vdev_start_resp.vdev_id);\n}\n\nstatic void ath11k_bcn_tx_status_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tu32 vdev_id, tx_status;\n\n\tif (ath11k_pull_bcn_tx_status_ev(ab, skb->data, skb->len,\n\t\t\t\t\t &vdev_id, &tx_status) != 0) {\n\t\tath11k_warn(ab, \"failed to extract bcn tx status\");\n\t\treturn;\n\t}\n}\n\nstatic void ath11k_vdev_stopped_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tu32 vdev_id = 0;\n\n\tif (ath11k_pull_vdev_stopped_param_tlv(ab, skb, &vdev_id) != 0) {\n\t\tath11k_warn(ab, \"failed to extract vdev stopped event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in vdev stopped ev %d\",\n\t\t\t    vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->vdev_setup_done);\n\n\trcu_read_unlock();\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"vdev stopped for vdev id %d\", vdev_id);\n}\n\nstatic void ath11k_mgmt_rx_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct mgmt_rx_event_params rx_ev = {0};\n\tstruct ath11k *ar;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (ath11k_pull_mgmt_rx_params_tlv(ab, skb, &rx_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract mgmt rx event\");\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tmemset(status, 0, sizeof(*status));\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT, \"mgmt rx event status %08x\\n\",\n\t\t   rx_ev.status);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, rx_ev.pdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev_id %d in mgmt_rx_event\\n\",\n\t\t\t    rx_ev.pdev_id);\n\t\tdev_kfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tif ((test_bit(ATH11K_CAC_RUNNING, &ar->dev_flags)) ||\n\t    (rx_ev.status & (WMI_RX_STATUS_ERR_DECRYPT |\n\t    WMI_RX_STATUS_ERR_KEY_CACHE_MISS | WMI_RX_STATUS_ERR_CRC))) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tif (rx_ev.status & WMI_RX_STATUS_ERR_MIC)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (rx_ev.chan_freq >= ATH11K_MIN_6G_FREQ) {\n\t\tstatus->band = NL80211_BAND_6GHZ;\n\t} else if (rx_ev.channel >= 1 && rx_ev.channel <= 14) {\n\t\tstatus->band = NL80211_BAND_2GHZ;\n\t} else if (rx_ev.channel >= 36 && rx_ev.channel <= ATH11K_MAX_5G_CHAN) {\n\t\tstatus->band = NL80211_BAND_5GHZ;\n\t} else {\n\t\t/* Shouldn't happen unless list of advertised channels to\n\t\t * mac80211 has been changed.\n\t\t */\n\t\tWARN_ON_ONCE(1);\n\t\tdev_kfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tif (rx_ev.phy_mode == MODE_11B &&\n\t    (status->band == NL80211_BAND_5GHZ || status->band == NL80211_BAND_6GHZ))\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"wmi mgmt rx 11b (CCK) on 5/6GHz, band = %d\\n\", status->band);\n\n\tsband = &ar->mac.sbands[status->band];\n\n\tstatus->freq = ieee80211_channel_to_frequency(rx_ev.channel,\n\t\t\t\t\t\t      status->band);\n\tstatus->signal = rx_ev.snr + ATH11K_DEFAULT_NOISE_FLOOR;\n\tstatus->rate_idx = ath11k_mac_bitrate_to_idx(sband, rx_ev.rate / 100);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\t/* Firmware is guaranteed to report all essential management frames via\n\t * WMI while it can deliver some extra via HTT. Since there can be\n\t * duplicates split the reporting wrt monitor/sniffing.\n\t */\n\tstatus->flag |= RX_FLAG_SKIP_MONITOR;\n\n\t/* In case of PMF, FW delivers decrypted frames with Protected Bit set.\n\t * Don't clear that. Also, FW delivers broadcast management frames\n\t * (ex: group privacy action frames in mesh) as encrypted payload.\n\t */\n\tif (ieee80211_has_protected(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(ieee80211_get_DA(hdr))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\n\t\tif (!ieee80211_is_robust_mgmt_frame(skb)) {\n\t\t\tstatus->flag |= RX_FLAG_IV_STRIPPED |\n\t\t\t\t\tRX_FLAG_MMIC_STRIPPED;\n\t\t\thdr->frame_control = __cpu_to_le16(fc &\n\t\t\t\t\t     ~IEEE80211_FCTL_PROTECTED);\n\t\t}\n\t}\n\n\t/* TODO: Pending handle beacon implementation\n\t *if (ieee80211_is_beacon(hdr->frame_control))\n\t *\tath11k_mac_handle_beacon(ar, skb);\n\t */\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT,\n\t\t   \"event mgmt rx skb %pK len %d ftype %02x stype %02x\\n\",\n\t\t   skb, skb->len,\n\t\t   fc & IEEE80211_FCTL_FTYPE, fc & IEEE80211_FCTL_STYPE);\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT,\n\t\t   \"event mgmt rx freq %d band %d snr %d, rate_idx %d\\n\",\n\t\t   status->freq, status->band, status->signal,\n\t\t   status->rate_idx);\n\n\tieee80211_rx_ni(ar->hw, skb);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic void ath11k_mgmt_tx_compl_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_mgmt_tx_compl_event tx_compl_param = {0};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_mgmt_tx_compl_param_tlv(ab, skb, &tx_compl_param) != 0) {\n\t\tath11k_warn(ab, \"failed to extract mgmt tx compl event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, tx_compl_param.pdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev id %d in mgmt_tx_compl_event\\n\",\n\t\t\t    tx_compl_param.pdev_id);\n\t\tgoto exit;\n\t}\n\n\twmi_process_mgmt_tx_comp(ar, tx_compl_param.desc_id,\n\t\t\t\t tx_compl_param.status);\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT,\n\t\t   \"mgmt tx compl ev pdev_id %d, desc_id %d, status %d\",\n\t\t   tx_compl_param.pdev_id, tx_compl_param.desc_id,\n\t\t   tx_compl_param.status);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic struct ath11k *ath11k_get_ar_on_scan_abort(struct ath11k_base *ab,\n\t\t\t\t\t\t  u32 vdev_id)\n{\n\tint i;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k *ar;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n\t\tif (pdev && pdev->ar) {\n\t\t\tar = pdev->ar;\n\n\t\t\tspin_lock_bh(&ar->data_lock);\n\t\t\tif (ar->scan.state == ATH11K_SCAN_ABORTING &&\n\t\t\t    ar->scan.vdev_id == vdev_id) {\n\t\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\t\treturn ar;\n\t\t\t}\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void ath11k_scan_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tstruct wmi_scan_event scan_ev = {0};\n\n\tif (ath11k_pull_scan_ev(ab, skb, &scan_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract scan event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\t/* In case the scan was cancelled, ex. during interface teardown,\n\t * the interface will not be found in active interfaces.\n\t * Rather, in such scenarios, iterate over the active pdev's to\n\t * search 'ar' if the corresponding 'ar' scan is ABORTING and the\n\t * aborting scan's vdev id matches this event info.\n\t */\n\tif (scan_ev.event_type == WMI_SCAN_EVENT_COMPLETED &&\n\t    scan_ev.reason == WMI_SCAN_REASON_CANCELLED)\n\t\tar = ath11k_get_ar_on_scan_abort(ab, scan_ev.vdev_id);\n\telse\n\t\tar = ath11k_mac_get_ar_by_vdev_id(ab, scan_ev.vdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"Received scan event for unknown vdev\");\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"scan event %s type %d reason %d freq %d req_id %d scan_id %d vdev_id %d state %s (%d)\\n\",\n\t\t   ath11k_wmi_event_scan_type_str(scan_ev.event_type, scan_ev.reason),\n\t\t   scan_ev.event_type, scan_ev.reason, scan_ev.channel_freq,\n\t\t   scan_ev.scan_req_id, scan_ev.scan_id, scan_ev.vdev_id,\n\t\t   ath11k_scan_state_str(ar->scan.state), ar->scan.state);\n\n\tswitch (scan_ev.event_type) {\n\tcase WMI_SCAN_EVENT_STARTED:\n\t\tath11k_wmi_event_scan_started(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_COMPLETED:\n\t\tath11k_wmi_event_scan_completed(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_BSS_CHANNEL:\n\t\tath11k_wmi_event_scan_bss_chan(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN:\n\t\tath11k_wmi_event_scan_foreign_chan(ar, scan_ev.channel_freq);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_START_FAILED:\n\t\tath11k_warn(ab, \"received scan start failure event\\n\");\n\t\tath11k_wmi_event_scan_start_failed(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_DEQUEUED:\n\tcase WMI_SCAN_EVENT_PREEMPTED:\n\tcase WMI_SCAN_EVENT_RESTARTED:\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\trcu_read_unlock();\n}\n\nstatic void ath11k_peer_sta_kickout_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_peer_sta_kickout_arg arg = {};\n\tstruct ieee80211_sta *sta;\n\tstruct ath11k_peer *peer;\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_peer_sta_kickout_ev(ab, skb, &arg) != 0) {\n\t\tath11k_warn(ab, \"failed to extract peer sta kickout event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath11k_peer_find_by_addr(ab, arg.mac_addr);\n\n\tif (!peer) {\n\t\tath11k_warn(ab, \"peer not found %pM\\n\",\n\t\t\t    arg.mac_addr);\n\t\tgoto exit;\n\t}\n\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, peer->vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in peer sta kickout ev %d\",\n\t\t\t    peer->vdev_id);\n\t\tgoto exit;\n\t}\n\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw,\n\t\t\t\t\t   arg.mac_addr, NULL);\n\tif (!sta) {\n\t\tath11k_warn(ab, \"Spurious quick kickout for STA %pM\\n\",\n\t\t\t    arg.mac_addr);\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"peer sta kickout event %pM\",\n\t\t   arg.mac_addr);\n\n\tieee80211_report_low_ack(sta, 10);\n\nexit:\n\tspin_unlock_bh(&ab->base_lock);\n\trcu_read_unlock();\n}\n\nstatic void ath11k_roam_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_roam_event roam_ev = {};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_roam_ev(ab, skb, &roam_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract roam event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"wmi roam event vdev %u reason 0x%08x rssi %d\\n\",\n\t\t   roam_ev.vdev_id, roam_ev.reason, roam_ev.rssi);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, roam_ev.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in roam ev %d\",\n\t\t\t    roam_ev.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (roam_ev.reason >= WMI_ROAM_REASON_MAX)\n\t\tath11k_warn(ab, \"ignoring unknown roam event reason %d on vdev %i\\n\",\n\t\t\t    roam_ev.reason, roam_ev.vdev_id);\n\n\tswitch (roam_ev.reason) {\n\tcase WMI_ROAM_REASON_BEACON_MISS:\n\t\t/* TODO: Pending beacon miss and connection_loss_work\n\t\t * implementation\n\t\t * ath11k_mac_handle_beacon_miss(ar, vdev_id);\n\t\t */\n\t\tbreak;\n\tcase WMI_ROAM_REASON_BETTER_AP:\n\tcase WMI_ROAM_REASON_LOW_RSSI:\n\tcase WMI_ROAM_REASON_SUITABLE_AP_FOUND:\n\tcase WMI_ROAM_REASON_HO_FAILED:\n\t\tath11k_warn(ab, \"ignoring not implemented roam event reason %d on vdev %i\\n\",\n\t\t\t    roam_ev.reason, roam_ev.vdev_id);\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void ath11k_chan_info_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_chan_info_event ch_info_ev = {0};\n\tstruct ath11k *ar;\n\tstruct survey_info *survey;\n\tint idx;\n\t/* HW channel counters frequency value in hertz */\n\tu32 cc_freq_hz = ab->cc_freq_hz;\n\n\tif (ath11k_pull_chan_info_ev(ab, skb->data, skb->len, &ch_info_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract chan info event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"chan info vdev_id %d err_code %d freq %d cmd_flags %d noise_floor %d rx_clear_count %d cycle_count %d mac_clk_mhz %d\\n\",\n\t\t   ch_info_ev.vdev_id, ch_info_ev.err_code, ch_info_ev.freq,\n\t\t   ch_info_ev.cmd_flags, ch_info_ev.noise_floor,\n\t\t   ch_info_ev.rx_clear_count, ch_info_ev.cycle_count,\n\t\t   ch_info_ev.mac_clk_mhz);\n\n\tif (ch_info_ev.cmd_flags == WMI_CHAN_INFO_END_RESP) {\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"chan info report completed\\n\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, ch_info_ev.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in chan info ev %d\",\n\t\t\t    ch_info_ev.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tspin_lock_bh(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\tath11k_warn(ab, \"received chan info event without a scan request, ignoring\\n\");\n\t\tgoto exit;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tbreak;\n\t}\n\n\tidx = freq_to_idx(ar, ch_info_ev.freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath11k_warn(ab, \"chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    ch_info_ev.freq, idx);\n\t\tgoto exit;\n\t}\n\n\t/* If FW provides MAC clock frequency in Mhz, overriding the initialized\n\t * HW channel counters frequency value\n\t */\n\tif (ch_info_ev.mac_clk_mhz)\n\t\tcc_freq_hz = (ch_info_ev.mac_clk_mhz * 1000);\n\n\tif (ch_info_ev.cmd_flags == WMI_CHAN_INFO_START_RESP) {\n\t\tsurvey = &ar->survey[idx];\n\t\tmemset(survey, 0, sizeof(*survey));\n\t\tsurvey->noise = ch_info_ev.noise_floor;\n\t\tsurvey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME |\n\t\t\t\t SURVEY_INFO_TIME_BUSY;\n\t\tsurvey->time = div_u64(ch_info_ev.cycle_count, cc_freq_hz);\n\t\tsurvey->time_busy = div_u64(ch_info_ev.rx_clear_count, cc_freq_hz);\n\t}\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n\trcu_read_unlock();\n}\n\nstatic void\nath11k_pdev_bss_chan_info_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_pdev_bss_chan_info_event bss_ch_info_ev = {};\n\tstruct survey_info *survey;\n\tstruct ath11k *ar;\n\tu32 cc_freq_hz = ab->cc_freq_hz;\n\tu64 busy, total, tx, rx, rx_bss;\n\tint idx;\n\n\tif (ath11k_pull_pdev_bss_chan_info_ev(ab, skb, &bss_ch_info_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract pdev bss chan info event\");\n\t\treturn;\n\t}\n\n\tbusy = (u64)(bss_ch_info_ev.rx_clear_count_high) << 32 |\n\t\t\tbss_ch_info_ev.rx_clear_count_low;\n\n\ttotal = (u64)(bss_ch_info_ev.cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.cycle_count_low;\n\n\ttx = (u64)(bss_ch_info_ev.tx_cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.tx_cycle_count_low;\n\n\trx = (u64)(bss_ch_info_ev.rx_cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.rx_cycle_count_low;\n\n\trx_bss = (u64)(bss_ch_info_ev.rx_bss_cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.rx_bss_cycle_count_low;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"pdev bss chan info:\\n pdev_id: %d freq: %d noise: %d cycle: busy %llu total %llu tx %llu rx %llu rx_bss %llu\\n\",\n\t\t   bss_ch_info_ev.pdev_id, bss_ch_info_ev.freq,\n\t\t   bss_ch_info_ev.noise_floor, busy, total,\n\t\t   tx, rx, rx_bss);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, bss_ch_info_ev.pdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev id %d in bss_chan_info event\\n\",\n\t\t\t    bss_ch_info_ev.pdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tidx = freq_to_idx(ar, bss_ch_info_ev.freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath11k_warn(ab, \"bss chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    bss_ch_info_ev.freq, idx);\n\t\tgoto exit;\n\t}\n\n\tsurvey = &ar->survey[idx];\n\n\tsurvey->noise     = bss_ch_info_ev.noise_floor;\n\tsurvey->time      = div_u64(total, cc_freq_hz);\n\tsurvey->time_busy = div_u64(busy, cc_freq_hz);\n\tsurvey->time_rx   = div_u64(rx_bss, cc_freq_hz);\n\tsurvey->time_tx   = div_u64(tx, cc_freq_hz);\n\tsurvey->filled   |= (SURVEY_INFO_NOISE_DBM |\n\t\t\t     SURVEY_INFO_TIME |\n\t\t\t     SURVEY_INFO_TIME_BUSY |\n\t\t\t     SURVEY_INFO_TIME_RX |\n\t\t\t     SURVEY_INFO_TIME_TX);\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n\tcomplete(&ar->bss_survey_done);\n\n\trcu_read_unlock();\n}\n\nstatic void ath11k_vdev_install_key_compl_event(struct ath11k_base *ab,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct wmi_vdev_install_key_complete_arg install_key_compl = {0};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_vdev_install_key_compl_ev(ab, skb, &install_key_compl) != 0) {\n\t\tath11k_warn(ab, \"failed to extract install key compl event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"vdev install key ev idx %d flags %08x macaddr %pM status %d\\n\",\n\t\t   install_key_compl.key_idx, install_key_compl.key_flags,\n\t\t   install_key_compl.macaddr, install_key_compl.status);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, install_key_compl.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in install key compl ev %d\",\n\t\t\t    install_key_compl.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tar->install_key_status = 0;\n\n\tif (install_key_compl.status != WMI_VDEV_INSTALL_KEY_COMPL_STATUS_SUCCESS) {\n\t\tath11k_warn(ab, \"install key failed for %pM status %d\\n\",\n\t\t\t    install_key_compl.macaddr, install_key_compl.status);\n\t\tar->install_key_status = install_key_compl.status;\n\t}\n\n\tcomplete(&ar->install_key_done);\n\trcu_read_unlock();\n}\n\nstatic void ath11k_service_available_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_service_available_event *ev;\n\tint ret;\n\tint i, j;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_SERVICE_AVAILABLE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch svc available ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\t/* TODO: Use wmi_service_segment_offset information to get the service\n\t * especially when more services are advertised in multiple sevice\n\t * available events.\n\t */\n\tfor (i = 0, j = WMI_MAX_SERVICE;\n\t     i < WMI_SERVICE_SEGMENT_BM_SIZE32 && j < WMI_MAX_EXT_SERVICE;\n\t     i++) {\n\t\tdo {\n\t\t\tif (ev->wmi_service_segment_bitmap[i] &\n\t\t\t    BIT(j % WMI_AVAIL_SERVICE_BITS_IN_SIZE32))\n\t\t\t\tset_bit(j, ab->wmi_ab.svc_map);\n\t\t} while (++j % WMI_AVAIL_SERVICE_BITS_IN_SIZE32);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"wmi_ext_service_bitmap 0:0x%x, 1:0x%x, 2:0x%x, 3:0x%x\",\n\t\t   ev->wmi_service_segment_bitmap[0], ev->wmi_service_segment_bitmap[1],\n\t\t   ev->wmi_service_segment_bitmap[2], ev->wmi_service_segment_bitmap[3]);\n\n\tkfree(tb);\n}\n\nstatic void ath11k_peer_assoc_conf_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_peer_assoc_conf_arg peer_assoc_conf = {0};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_peer_assoc_conf_ev(ab, skb, &peer_assoc_conf) != 0) {\n\t\tath11k_warn(ab, \"failed to extract peer assoc conf event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"peer assoc conf ev vdev id %d macaddr %pM\\n\",\n\t\t   peer_assoc_conf.vdev_id, peer_assoc_conf.macaddr);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, peer_assoc_conf.vdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in peer assoc conf ev %d\",\n\t\t\t    peer_assoc_conf.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->peer_assoc_done);\n\trcu_read_unlock();\n}\n\nstatic void ath11k_update_stats_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tath11k_debugfs_fw_stats_process(ab, skb);\n}\n\n/* PDEV_CTL_FAILSAFE_CHECK_EVENT is received from FW when the frequency scanned\n * is not part of BDF CTL(Conformance test limits) table entries.\n */\nstatic void ath11k_pdev_ctl_failsafe_check_event(struct ath11k_base *ab,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_ctl_failsafe_chk_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_CTL_FAILSAFE_CHECK_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev ctl failsafe check ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"pdev ctl failsafe check ev status %d\\n\",\n\t\t   ev->ctl_failsafe_status);\n\n\t/* If ctl_failsafe_status is set to 1 FW will max out the Transmit power\n\t * to 10 dBm else the CTL power entry in the BDF would be picked up.\n\t */\n\tif (ev->ctl_failsafe_status != 0)\n\t\tath11k_warn(ab, \"pdev ctl failsafe failure status %d\",\n\t\t\t    ev->ctl_failsafe_status);\n\n\tkfree(tb);\n}\n\nstatic void\nath11k_wmi_process_csa_switch_count_event(struct ath11k_base *ab,\n\t\t\t\t\t  const struct wmi_pdev_csa_switch_ev *ev,\n\t\t\t\t\t  const u32 *vdev_ids)\n{\n\tint i;\n\tstruct ath11k_vif *arvif;\n\n\t/* Finish CSA once the switch count becomes NULL */\n\tif (ev->current_switch_count)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (i = 0; i < ev->num_vdevs; i++) {\n\t\tarvif = ath11k_mac_get_arvif_by_vdev_id(ab, vdev_ids[i]);\n\n\t\tif (!arvif) {\n\t\t\tath11k_warn(ab, \"Recvd csa status for unknown vdev %d\",\n\t\t\t\t    vdev_ids[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arvif->is_up && arvif->vif->csa_active)\n\t\t\tieee80211_csa_finish(arvif->vif);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nath11k_wmi_pdev_csa_switch_count_status_event(struct ath11k_base *ab,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_csa_switch_ev *ev;\n\tconst u32 *vdev_ids;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_CSA_SWITCH_COUNT_STATUS_EVENT];\n\tvdev_ids = tb[WMI_TAG_ARRAY_UINT32];\n\n\tif (!ev || !vdev_ids) {\n\t\tath11k_warn(ab, \"failed to fetch pdev csa switch count ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"pdev csa switch count %d for pdev %d, num_vdevs %d\",\n\t\t   ev->current_switch_count, ev->pdev_id,\n\t\t   ev->num_vdevs);\n\n\tath11k_wmi_process_csa_switch_count_event(ab, ev, vdev_ids);\n\n\tkfree(tb);\n}\n\nstatic void\nath11k_wmi_pdev_dfs_radar_detected_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_radar_ev *ev;\n\tstruct ath11k *ar;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_DFS_RADAR_DETECTION_EVENT];\n\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev dfs radar detected ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"pdev dfs radar detected on pdev %d, detection mode %d, chan freq %d, chan_width %d, detector id %d, seg id %d, timestamp %d, chirp %d, freq offset %d, sidx %d\",\n\t\t   ev->pdev_id, ev->detection_mode, ev->chan_freq, ev->chan_width,\n\t\t   ev->detector_id, ev->segment_id, ev->timestamp, ev->is_chirp,\n\t\t   ev->freq_offset, ev->sidx);\n\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, ev->pdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"radar detected in invalid pdev %d\\n\",\n\t\t\t    ev->pdev_id);\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_REG, \"DFS Radar Detected in pdev %d\\n\",\n\t\t   ev->pdev_id);\n\n\tif (ar->dfs_block_radar_events)\n\t\tath11k_info(ab, \"DFS Radar detected, but ignored as requested\\n\");\n\telse\n\t\tieee80211_radar_detected(ar->hw);\n\nexit:\n\tkfree(tb);\n}\n\nstatic void\nath11k_wmi_pdev_temperature_event(struct ath11k_base *ab,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tstruct wmi_pdev_temperature_event ev = {0};\n\n\tif (ath11k_pull_pdev_temp_ev(ab, skb->data, skb->len, &ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract pdev temperature event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"pdev temperature ev temp %d pdev_id %d\\n\", ev.temp, ev.pdev_id);\n\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, ev.pdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev id in pdev temperature ev %d\", ev.pdev_id);\n\t\treturn;\n\t}\n\n\tath11k_thermal_event_temperature(ar, ev.temp);\n}\n\nstatic void ath11k_fils_discovery_event(struct ath11k_base *ab,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_fils_discovery_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to parse FILS discovery event tlv %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_HOST_SWFDA_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch FILS discovery event\\n\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_warn(ab,\n\t\t    \"FILS discovery frame expected from host for vdev_id: %u, transmission scheduled at %u, next TBTT: %u\\n\",\n\t\t    ev->vdev_id, ev->fils_tt, ev->tbtt);\n\n\tkfree(tb);\n}\n\nstatic void ath11k_probe_resp_tx_status_event(struct ath11k_base *ab,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_probe_resp_tx_status_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to parse probe response transmission status event tlv: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_OFFLOAD_PRB_RSP_TX_STATUS_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to fetch probe response transmission status event\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tif (ev->tx_status)\n\t\tath11k_warn(ab,\n\t\t\t    \"Probe response transmission failed for vdev_id %u, status %u\\n\",\n\t\t\t    ev->vdev_id, ev->tx_status);\n\n\tkfree(tb);\n}\n\nstatic int ath11k_wmi_tlv_wow_wakeup_host_parse(struct ath11k_base *ab,\n\t\t\t\t\t\tu16 tag, u16 len,\n\t\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_wow_ev_arg *ev = data;\n\tconst char *wow_pg_fault;\n\tint wow_pg_len;\n\n\tswitch (tag) {\n\tcase WMI_TAG_WOW_EVENT_INFO:\n\t\tmemcpy(ev, ptr, sizeof(*ev));\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"wow wakeup host reason %d %s\\n\",\n\t\t\t   ev->wake_reason, wow_reason(ev->wake_reason));\n\t\tbreak;\n\n\tcase WMI_TAG_ARRAY_BYTE:\n\t\tif (ev && ev->wake_reason == WOW_REASON_PAGE_FAULT) {\n\t\t\twow_pg_fault = ptr;\n\t\t\t/* the first 4 bytes are length */\n\t\t\twow_pg_len = *(int *)wow_pg_fault;\n\t\t\twow_pg_fault += sizeof(int);\n\t\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"wow data_len = %d\\n\",\n\t\t\t\t   wow_pg_len);\n\t\t\tath11k_dbg_dump(ab, ATH11K_DBG_WMI,\n\t\t\t\t\t\"wow_event_info_type packet present\",\n\t\t\t\t\t\"wow_pg_fault \",\n\t\t\t\t\twow_pg_fault,\n\t\t\t\t\twow_pg_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_event_wow_wakeup_host(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_wow_ev_arg ev = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_wow_wakeup_host_parse,\n\t\t\t\t  &ev);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse wmi wow tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tcomplete(&ab->wow.wakeup_completed);\n}\n\nstatic void ath11k_wmi_tlv_op_rx(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_tlv_event_id id;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = FIELD_GET(WMI_CMD_HDR_CMD_ID, (cmd_hdr->cmd_id));\n\n\tif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\tgoto out;\n\n\tswitch (id) {\n\t\t/* Process all the WMI events here */\n\tcase WMI_SERVICE_READY_EVENTID:\n\t\tath11k_service_ready_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_READY_EXT_EVENTID:\n\t\tath11k_service_ready_ext_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_READY_EXT2_EVENTID:\n\t\tath11k_service_ready_ext2_event(ab, skb);\n\t\tbreak;\n\tcase WMI_REG_CHAN_LIST_CC_EVENTID:\n\t\tath11k_reg_chan_list_event(ab, skb);\n\t\tbreak;\n\tcase WMI_READY_EVENTID:\n\t\tath11k_ready_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_DELETE_RESP_EVENTID:\n\t\tath11k_peer_delete_resp_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_START_RESP_EVENTID:\n\t\tath11k_vdev_start_resp_event(ab, skb);\n\t\tbreak;\n\tcase WMI_OFFLOAD_BCN_TX_STATUS_EVENTID:\n\t\tath11k_bcn_tx_status_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_STOPPED_EVENTID:\n\t\tath11k_vdev_stopped_event(ab, skb);\n\t\tbreak;\n\tcase WMI_MGMT_RX_EVENTID:\n\t\tath11k_mgmt_rx_event(ab, skb);\n\t\t/* mgmt_rx_event() owns the skb now! */\n\t\treturn;\n\tcase WMI_MGMT_TX_COMPLETION_EVENTID:\n\t\tath11k_mgmt_tx_compl_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SCAN_EVENTID:\n\t\tath11k_scan_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_STA_KICKOUT_EVENTID:\n\t\tath11k_peer_sta_kickout_event(ab, skb);\n\t\tbreak;\n\tcase WMI_ROAM_EVENTID:\n\t\tath11k_roam_event(ab, skb);\n\t\tbreak;\n\tcase WMI_CHAN_INFO_EVENTID:\n\t\tath11k_chan_info_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_BSS_CHAN_INFO_EVENTID:\n\t\tath11k_pdev_bss_chan_info_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_INSTALL_KEY_COMPLETE_EVENTID:\n\t\tath11k_vdev_install_key_compl_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_AVAILABLE_EVENTID:\n\t\tath11k_service_available_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_ASSOC_CONF_EVENTID:\n\t\tath11k_peer_assoc_conf_event(ab, skb);\n\t\tbreak;\n\tcase WMI_UPDATE_STATS_EVENTID:\n\t\tath11k_update_stats_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_CTL_FAILSAFE_CHECK_EVENTID:\n\t\tath11k_pdev_ctl_failsafe_check_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_CSA_SWITCH_COUNT_STATUS_EVENTID:\n\t\tath11k_wmi_pdev_csa_switch_count_status_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_TEMPERATURE_EVENTID:\n\t\tath11k_wmi_pdev_temperature_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_DMA_RING_BUF_RELEASE_EVENTID:\n\t\tath11k_wmi_pdev_dma_ring_buf_release_event(ab, skb);\n\t\tbreak;\n\tcase WMI_HOST_FILS_DISCOVERY_EVENTID:\n\t\tath11k_fils_discovery_event(ab, skb);\n\t\tbreak;\n\tcase WMI_OFFLOAD_PROB_RESP_TX_STATUS_EVENTID:\n\t\tath11k_probe_resp_tx_status_event(ab, skb);\n\t\tbreak;\n\t/* add Unsupported events here */\n\tcase WMI_TBTTOFFSET_EXT_UPDATE_EVENTID:\n\tcase WMI_PEER_OPER_MODE_CHANGE_EVENTID:\n\tcase WMI_TWT_ENABLE_EVENTID:\n\tcase WMI_TWT_DISABLE_EVENTID:\n\tcase WMI_PDEV_DMA_RING_CFG_RSP_EVENTID:\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"ignoring unsupported event 0x%x\\n\", id);\n\t\tbreak;\n\tcase WMI_PDEV_DFS_RADAR_DETECTION_EVENTID:\n\t\tath11k_wmi_pdev_dfs_radar_detected_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_DELETE_RESP_EVENTID:\n\t\tath11k_vdev_delete_resp_event(ab, skb);\n\t\tbreak;\n\tcase WMI_WOW_WAKEUP_HOST_EVENTID:\n\t\tath11k_wmi_event_wow_wakeup_host(ab, skb);\n\t\tbreak;\n\t/* TODO: Add remaining events */\n\tdefault:\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"Unknown eventid: 0x%x\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic int ath11k_connect_pdev_htc_service(struct ath11k_base *ab,\n\t\t\t\t\t   u32 pdev_idx)\n{\n\tint status;\n\tu32 svc_id[] = { ATH11K_HTC_SVC_ID_WMI_CONTROL,\n\t\t\t ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC1,\n\t\t\t ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC2 };\n\n\tstruct ath11k_htc_svc_conn_req conn_req;\n\tstruct ath11k_htc_svc_conn_resp conn_resp;\n\n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\n\t/* these fields are the same for all service endpoints */\n\tconn_req.ep_ops.ep_tx_complete = ath11k_wmi_htc_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath11k_wmi_tlv_op_rx;\n\tconn_req.ep_ops.ep_tx_credits = ath11k_wmi_op_ep_tx_credits;\n\n\t/* connect to control service */\n\tconn_req.service_id = svc_id[pdev_idx];\n\n\tstatus = ath11k_htc_connect_service(&ab->htc, &conn_req, &conn_resp);\n\tif (status) {\n\t\tath11k_warn(ab, \"failed to connect to WMI CONTROL service status: %d\\n\",\n\t\t\t    status);\n\t\treturn status;\n\t}\n\n\tab->wmi_ab.wmi_endpoint_id[pdev_idx] = conn_resp.eid;\n\tab->wmi_ab.wmi[pdev_idx].eid = conn_resp.eid;\n\tab->wmi_ab.max_msg_len[pdev_idx] = conn_resp.max_msg_len;\n\n\treturn 0;\n}\n\nstatic int\nath11k_wmi_send_unit_test_cmd(struct ath11k *ar,\n\t\t\t      struct wmi_unit_test_cmd ut_cmd,\n\t\t\t      u32 *test_args)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_unit_test_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tu32 *ut_cmd_args;\n\tint buf_len, arg_len;\n\tint ret;\n\tint i;\n\n\targ_len = sizeof(u32) * ut_cmd.num_args;\n\tbuf_len = sizeof(ut_cmd) + arg_len + TLV_HDR_SIZE;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, buf_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_unit_test_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_UNIT_TEST_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(ut_cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = ut_cmd.vdev_id;\n\tcmd->module_id = ut_cmd.module_id;\n\tcmd->num_args = ut_cmd.num_args;\n\tcmd->diag_token = ut_cmd.diag_token;\n\n\tptr = skb->data + sizeof(ut_cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, arg_len);\n\n\tptr += TLV_HDR_SIZE;\n\n\tut_cmd_args = ptr;\n\tfor (i = 0; i < ut_cmd.num_args; i++)\n\t\tut_cmd_args[i] = test_args[i];\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_UNIT_TEST_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_UNIT_TEST CMD :%d\\n\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"WMI unit test : module %d vdev %d n_args %d token %d\\n\",\n\t\t   cmd->module_id, cmd->vdev_id, cmd->num_args,\n\t\t   cmd->diag_token);\n\n\treturn ret;\n}\n\nint ath11k_wmi_simulate_radar(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tu32 dfs_args[DFS_MAX_TEST_ARGS];\n\tstruct wmi_unit_test_cmd wmi_ut;\n\tbool arvif_found = false;\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->is_started && arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\t\tarvif_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!arvif_found)\n\t\treturn -EINVAL;\n\n\tdfs_args[DFS_TEST_CMDID] = 0;\n\tdfs_args[DFS_TEST_PDEV_ID] = ar->pdev->pdev_id;\n\t/* Currently we could pass segment_id(b0 - b1), chirp(b2)\n\t * freq offset (b3 - b10) to unit test. For simulation\n\t * purpose this can be set to 0 which is valid.\n\t */\n\tdfs_args[DFS_TEST_RADAR_PARAM] = 0;\n\n\twmi_ut.vdev_id = arvif->vdev_id;\n\twmi_ut.module_id = DFS_UNIT_TEST_MODULE;\n\twmi_ut.num_args = DFS_MAX_TEST_ARGS;\n\twmi_ut.diag_token = DFS_UNIT_TEST_TOKEN;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_REG, \"Triggering Radar Simulation\\n\");\n\n\treturn ath11k_wmi_send_unit_test_cmd(ar, wmi_ut, dfs_args);\n}\n\nint ath11k_wmi_connect(struct ath11k_base *ab)\n{\n\tu32 i;\n\tu8 wmi_ep_count;\n\n\twmi_ep_count = ab->htc.wmi_ep_count;\n\tif (wmi_ep_count > ab->hw_params.max_radios)\n\t\treturn -1;\n\n\tfor (i = 0; i < wmi_ep_count; i++)\n\t\tath11k_connect_pdev_htc_service(ab, i);\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_pdev_detach(struct ath11k_base *ab, u8 pdev_id)\n{\n\tif (WARN_ON(pdev_id >= MAX_RADIOS))\n\t\treturn;\n\n\t/* TODO: Deinit any pdev specific wmi resource */\n}\n\nint ath11k_wmi_pdev_attach(struct ath11k_base *ab,\n\t\t\t   u8 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle;\n\n\tif (pdev_id >= ab->hw_params.max_radios)\n\t\treturn -EINVAL;\n\n\twmi_handle = &ab->wmi_ab.wmi[pdev_id];\n\n\twmi_handle->wmi_ab = &ab->wmi_ab;\n\n\tab->wmi_ab.ab = ab;\n\t/* TODO: Init remaining resource specific to pdev */\n\n\treturn 0;\n}\n\nint ath11k_wmi_attach(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_wmi_pdev_attach(ab, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tab->wmi_ab.ab = ab;\n\tab->wmi_ab.preferred_hw_mode = WMI_HOST_HW_MODE_MAX;\n\n\t/* It's overwritten when service_ext_ready is handled */\n\tif (ab->hw_params.single_pdev_only)\n\t\tab->wmi_ab.preferred_hw_mode = WMI_HOST_HW_MODE_SINGLE;\n\n\t/* TODO: Init remaining wmi soc resources required */\n\tinit_completion(&ab->wmi_ab.service_ready);\n\tinit_completion(&ab->wmi_ab.unified_ready);\n\n\treturn 0;\n}\n\nvoid ath11k_wmi_detach(struct ath11k_base *ab)\n{\n\tint i;\n\n\t/* TODO: Deinit wmi resource specific to SOC as required */\n\n\tfor (i = 0; i < ab->htc.wmi_ep_count; i++)\n\t\tath11k_wmi_pdev_detach(ab, i);\n\n\tath11k_wmi_free_dbring_caps(ab);\n}\n\nint ath11k_wmi_wow_host_wakeup_ind(struct ath11k *ar)\n{\n\tstruct wmi_wow_host_wakeup_ind *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_wow_host_wakeup_ind *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_WOW_HOSTWAKEUP_FROM_SLEEP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"wmi tlv wow host wakeup ind\\n\");\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID);\n}\n\nint ath11k_wmi_wow_enable(struct ath11k *ar)\n{\n\tstruct wmi_wow_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_wow_enable_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_WOW_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->enable = 1;\n\tcmd->pause_iface_config = WOW_IFACE_PAUSE_ENABLED;\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"wmi tlv wow enable\\n\");\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_ENABLE_CMDID);\n}\n"}}, "reports": [{"events": [{"location": {"col": 18, "file": 0, "line": 6999}, "message": "ERROR: invalid reference to the index variable of the iterator on line 6981"}], "macros": [], "notes": [], "path": "/src/drivers/net/wireless/ath/ath11k/wmi.c", "reportHash": "242d74d17d92faeb95ba7b97b07cb930", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
