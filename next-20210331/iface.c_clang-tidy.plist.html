<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/mac80211/iface.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Interface handling\n *\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>\n * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright (c) 2016        Intel Deutschland GmbH\n * Copyright (C) 2018-2020 Intel Corporation\n */\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/kcov.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include \"ieee80211_i.h\"\n#include \"sta_info.h\"\n#include \"debugfs_netdev.h\"\n#include \"mesh.h\"\n#include \"led.h\"\n#include \"driver-ops.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/**\n * DOC: Interface list locking\n *\n * The interface list in each struct ieee80211_local is protected\n * three-fold:\n *\n * (1) modifications may only be done under the RTNL\n * (2) modifications and readers are protected against each other by\n *     the iflist_mtx.\n * (3) modifications are done in an RCU manner so atomic readers\n *     can traverse the list in RCU-safe blocks.\n *\n * As a consequence, reads (traversals) of the list can be protected\n * by either the RTNL, the iflist_mtx or RCU.\n */\n\nstatic void ieee80211_iface_work(struct work_struct *work);\n\nbool __ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint power;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\tpower = ieee80211_chandef_max_power(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\tif (sdata->user_power_level != IEEE80211_UNSET_POWER_LEVEL)\n\t\tpower = min(power, sdata->user_power_level);\n\n\tif (sdata->ap_power_level != IEEE80211_UNSET_POWER_LEVEL)\n\t\tpower = min(power, sdata->ap_power_level);\n\n\tif (power != sdata->vif.bss_conf.txpower) {\n\t\tsdata->vif.bss_conf.txpower = power;\n\t\tieee80211_hw_config(sdata->local, 0);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata,\n\t\t\t      bool update_bss)\n{\n\tif (__ieee80211_recalc_txpower(sdata) ||\n\t    (update_bss && ieee80211_sdata_running(sdata)))\n\t\tieee80211_bss_info_change_notify(sdata, BSS_CHANGED_TXPOWER);\n}\n\nstatic u32 __ieee80211_idle_off(struct ieee80211_local *local)\n{\n\tif (!(local->hw.conf.flags & IEEE80211_CONF_IDLE))\n\t\treturn 0;\n\n\tlocal->hw.conf.flags &= ~IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nstatic u32 __ieee80211_idle_on(struct ieee80211_local *local)\n{\n\tif (local->hw.conf.flags & IEEE80211_CONF_IDLE)\n\t\treturn 0;\n\n\tieee80211_flush_queues(local, NULL, false);\n\n\tlocal->hw.conf.flags |= IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nstatic u32 __ieee80211_recalc_idle(struct ieee80211_local *local,\n\t\t\t\t   bool force_active)\n{\n\tbool working, scanning, active;\n\tunsigned int led_trig_start = 0, led_trig_stop = 0;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tactive = force_active ||\n\t\t !list_empty(&local->chanctx_list) ||\n\t\t local->monitors;\n\n\tworking = !local->ops->remain_on_channel &&\n\t\t  !list_empty(&local->roc_list);\n\n\tscanning = test_bit(SCAN_SW_SCANNING, &local->scanning) ||\n\t\t   test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning);\n\n\tif (working || scanning)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\n\tif (active)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\n\tieee80211_mod_tpt_led_trig(local, led_trig_start, led_trig_stop);\n\n\tif (working || scanning || active)\n\t\treturn __ieee80211_idle_off(local);\n\treturn __ieee80211_idle_on(local);\n}\n\nu32 ieee80211_idle_off(struct ieee80211_local *local)\n{\n\treturn __ieee80211_recalc_idle(local, true);\n}\n\nvoid ieee80211_recalc_idle(struct ieee80211_local *local)\n{\n\tu32 change = __ieee80211_recalc_idle(local, false);\n\tif (change)\n\t\tieee80211_hw_config(local, change);\n}\n\nstatic int ieee80211_verify_mac(struct ieee80211_sub_if_data *sdata, u8 *addr,\n\t\t\t\tbool check_dup)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *iter;\n\tu64 new, mask, tmp;\n\tu8 *m;\n\tint ret = 0;\n\n\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask))\n\t\treturn 0;\n\n\tm = addr;\n\tnew =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\tm = local->hw.wiphy->addr_mask;\n\tmask =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\tif (!check_dup)\n\t\treturn ret;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(iter, &local->interfaces, list) {\n\t\tif (iter == sdata)\n\t\t\tcontinue;\n\n\t\tif (iter->vif.type == NL80211_IFTYPE_MONITOR &&\n\t\t    !(iter->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\t\tcontinue;\n\n\t\tm = iter->vif.addr;\n\t\ttmp =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tif ((new & ~mask) != (tmp & ~mask)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_change_mac(struct net_device *dev, void *addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sockaddr *sa = addr;\n\tbool check_dup = true;\n\tint ret;\n\n\tif (ieee80211_sdata_running(sdata))\n\t\treturn -EBUSY;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR &&\n\t    !(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\tcheck_dup = false;\n\n\tret = ieee80211_verify_mac(sdata, sa->sa_data, check_dup);\n\tif (ret)\n\t\treturn ret;\n\n\tret = eth_mac_addr(dev, sa);\n\n\tif (ret == 0)\n\t\tmemcpy(sdata->vif.addr, sa->sa_data, ETH_ALEN);\n\n\treturn ret;\n}\n\nstatic inline int identical_mac_addr_allowed(int type1, int type2)\n{\n\treturn type1 == NL80211_IFTYPE_MONITOR ||\n\t\ttype2 == NL80211_IFTYPE_MONITOR ||\n\t\ttype1 == NL80211_IFTYPE_P2P_DEVICE ||\n\t\ttype2 == NL80211_IFTYPE_P2P_DEVICE ||\n\t\t(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_AP_VLAN) ||\n\t\t(type1 == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t(type2 == NL80211_IFTYPE_AP ||\n\t\t\t type2 == NL80211_IFTYPE_AP_VLAN));\n}\n\nstatic int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    enum nl80211_iftype iftype)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *nsdata;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\t/* we hold the RTNL here so can safely walk the list */\n\tlist_for_each_entry(nsdata, &local->interfaces, list) {\n\t\tif (nsdata != sdata && ieee80211_sdata_running(nsdata)) {\n\t\t\t/*\n\t\t\t * Only OCB and monitor mode may coexist\n\t\t\t */\n\t\t\tif ((sdata->vif.type == NL80211_IFTYPE_OCB &&\n\t\t\t     nsdata->vif.type != NL80211_IFTYPE_MONITOR) ||\n\t\t\t    (sdata->vif.type != NL80211_IFTYPE_MONITOR &&\n\t\t\t     nsdata->vif.type == NL80211_IFTYPE_OCB))\n\t\t\t\treturn -EBUSY;\n\n\t\t\t/*\n\t\t\t * Allow only a single IBSS interface to be up at any\n\t\t\t * time. This is restricted because beacon distribution\n\t\t\t * cannot work properly if both are in the same IBSS.\n\t\t\t *\n\t\t\t * To remove this restriction we'd have to disallow them\n\t\t\t * from setting the same SSID on different IBSS interfaces\n\t\t\t * belonging to the same hardware. Then, however, we're\n\t\t\t * faced with having to adopt two different TSF timers...\n\t\t\t */\n\t\t\tif (iftype == NL80211_IFTYPE_ADHOC &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\t\treturn -EBUSY;\n\t\t\t/*\n\t\t\t * will not add another interface while any channel\n\t\t\t * switch is active.\n\t\t\t */\n\t\t\tif (nsdata->vif.csa_active)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t/*\n\t\t\t * The remaining checks are only performed for interfaces\n\t\t\t * with the same MAC address.\n\t\t\t */\n\t\t\tif (!ether_addr_equal(sdata->vif.addr,\n\t\t\t\t\t      nsdata->vif.addr))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * check whether it may have the same address\n\t\t\t */\n\t\t\tif (!identical_mac_addr_allowed(iftype,\n\t\t\t\t\t\t\tnsdata->vif.type))\n\t\t\t\treturn -ENOTUNIQ;\n\n\t\t\t/*\n\t\t\t * can only add VLANs to enabled APs\n\t\t\t */\n\t\t\tif (iftype == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\t\tsdata->bss = &nsdata->u.ap;\n\t\t}\n\t}\n\n\tmutex_lock(&local->chanctx_mtx);\n\tret = ieee80211_check_combinations(sdata, NULL, 0, 0);\n\tmutex_unlock(&local->chanctx_mtx);\n\treturn ret;\n}\n\nstatic int ieee80211_check_queues(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum nl80211_iftype iftype)\n{\n\tint n_queues = sdata->local->hw.queues;\n\tint i;\n\n\tif (iftype == NL80211_IFTYPE_NAN)\n\t\treturn 0;\n\n\tif (iftype != NL80211_IFTYPE_P2P_DEVICE) {\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tif (WARN_ON_ONCE(sdata->vif.hw_queue[i] ==\n\t\t\t\t\t IEEE80211_INVAL_HW_QUEUE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (WARN_ON_ONCE(sdata->vif.hw_queue[i] >=\n\t\t\t\t\t n_queues))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif ((iftype != NL80211_IFTYPE_AP &&\n\t     iftype != NL80211_IFTYPE_P2P_GO &&\n\t     iftype != NL80211_IFTYPE_MESH_POINT) ||\n\t    !ieee80211_hw_check(&sdata->local->hw, QUEUE_CONTROL)) {\n\t\tsdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(sdata->vif.cab_queue == IEEE80211_INVAL_HW_QUEUE))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(sdata->vif.cab_queue >= n_queues))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ieee80211_open(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint err;\n\n\t/* fail early if user set an invalid address */\n\tif (!is_valid_ether_addr(dev->dev_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = ieee80211_check_concurrent_iface(sdata, sdata->vif.type);\n\tif (err)\n\t\treturn err;\n\n\twiphy_lock(sdata->local->hw.wiphy);\n\terr = ieee80211_do_open(&sdata->wdev, true);\n\twiphy_unlock(sdata->local->hw.wiphy);\n\n\treturn err;\n}\n\nstatic void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, bool going_down)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long flags;\n\tstruct sk_buff *skb, *tmp;\n\tu32 hw_reconf_flags = 0;\n\tint i, flushed;\n\tstruct ps_data *ps;\n\tstruct cfg80211_chan_def chandef;\n\tbool cancel_scan;\n\tstruct cfg80211_nan_func *func;\n\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tcancel_scan = rcu_access_pointer(local->scan_sdata) == sdata;\n\tif (cancel_scan)\n\t\tieee80211_scan_cancel(local);\n\n\t/*\n\t * Stop TX on this interface first.\n\t */\n\tif (sdata->dev)\n\t\tnetif_tx_stop_all_queues(sdata->dev);\n\n\tieee80211_roc_purge(local, sdata);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_mgd_stop(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_stop(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES)\n\t\t\tbreak;\n\t\tlist_del_rcu(&sdata->u.mntr.list);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Remove all stations associated with this interface.\n\t *\n\t * This must be done before calling ops->remove_interface()\n\t * because otherwise we can later invoke ops->sta_notify()\n\t * whenever the STAs are removed, and that invalidates driver\n\t * assumptions about always getting a vif pointer that is valid\n\t * (because if we remove a STA after ops->remove_interface()\n\t * the driver will have removed the vif info already!)\n\t *\n\t * For AP_VLANs stations may exist since there's nothing else that\n\t * would have removed them, but in other modes there shouldn't\n\t * be any stations.\n\t */\n\tflushed = sta_info_flush(sdata);\n\tWARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_AP_VLAN && flushed > 0);\n\n\t/* don't count this interface for allmulti while it is down */\n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_dec(&local->iff_allmultis);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlocal->fif_pspoll--;\n\t\tlocal->fif_probe_req--;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tlocal->fif_probe_req--;\n\t}\n\n\tif (sdata->dev) {\n\t\tnetif_addr_lock_bh(sdata->dev);\n\t\tspin_lock_bh(&local->filter_lock);\n\t\t__hw_addr_unsync(&local->mc_list, &sdata->dev->mc,\n\t\t\t\t sdata->dev->addr_len);\n\t\tspin_unlock_bh(&local->filter_lock);\n\t\tnetif_addr_unlock_bh(sdata->dev);\n\t}\n\n\tdel_timer_sync(&local->dynamic_ps_timer);\n\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\n\tcancel_work_sync(&sdata->recalc_smps);\n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\tsdata->vif.csa_active = false;\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tsdata->u.mgd.csa_waiting_bcn = false;\n\tif (sdata->csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tsdata->csa_block_tx = false;\n\t}\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n\n\tcancel_work_sync(&sdata->csa_finalize_work);\n\n\tcancel_delayed_work_sync(&sdata->dfs_cac_timer_work);\n\n\tif (sdata->wdev.cac_started) {\n\t\tchandef = sdata->vif.bss_conf.chandef;\n\t\tWARN_ON(local->suspended);\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_vif_release_channel(sdata);\n\t\tmutex_unlock(&local->mtx);\n\t\tcfg80211_cac_event(sdata->dev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_ABORTED,\n\t\t\t\t   GFP_KERNEL);\n\t}\n\n\t/* APs need special treatment */\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_sub_if_data *vlan, *tmpsdata;\n\n\t\t/* down all dependent devices, that is VLANs */\n\t\tlist_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,\n\t\t\t\t\t u.vlan.list)\n\t\t\tdev_close(vlan->dev);\n\t\tWARN_ON(!list_empty(&sdata->u.ap.vlans));\n\t} else if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\t/* remove all packets in parent bc_buf pointing to this dev */\n\t\tps = &sdata->bss->ps;\n\n\t\tspin_lock_irqsave(&ps->bc_buf.lock, flags);\n\t\tskb_queue_walk_safe(&ps->bc_buf, skb, tmp) {\n\t\t\tif (skb->dev == sdata->dev) {\n\t\t\t\t__skb_unlink(skb, &ps->bc_buf);\n\t\t\t\tlocal->total_ps_buffered--;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ps->bc_buf.lock, flags);\n\t}\n\n\tif (going_down)\n\t\tlocal->open_count--;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tmutex_lock(&local->mtx);\n\t\tlist_del(&sdata->u.vlan.list);\n\t\tmutex_unlock(&local->mtx);\n\t\tRCU_INIT_POINTER(sdata->vif.chanctx_conf, NULL);\n\t\t/* see comment in the default case below */\n\t\tieee80211_free_keys(sdata, true);\n\t\t/* no need to tell driver */\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs--;\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal->monitors--;\n\t\tif (local->monitors == 0) {\n\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, -1);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\t/* clean all the functions */\n\t\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\t\tidr_for_each_entry(&sdata->u.nan.function_inst_ids, func, i) {\n\t\t\tidr_remove(&sdata->u.nan.function_inst_ids, i);\n\t\t\tcfg80211_free_nan_func(func);\n\t\t}\n\t\tidr_destroy(&sdata->u.nan.function_inst_ids);\n\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t/* relies on synchronize_rcu() below */\n\t\tRCU_INIT_POINTER(local->p2p_sdata, NULL);\n\t\tfallthrough;\n\tdefault:\n\t\tcancel_work_sync(&sdata->work);\n\t\t/*\n\t\t * When we get here, the interface is marked down.\n\t\t * Free the remaining keys, if there are any\n\t\t * (which can happen in AP mode if userspace sets\n\t\t * keys before the interface is operating)\n\t\t *\n\t\t * Force the key freeing to always synchronize_net()\n\t\t * to wait for the RX path in case it is using this\n\t\t * interface enqueuing frames at this very time on\n\t\t * another CPU.\n\t\t */\n\t\tieee80211_free_keys(sdata, true);\n\t\tskb_queue_purge(&sdata->skb_queue);\n\t}\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < IEEE80211_MAX_QUEUES; i++) {\n\t\tskb_queue_walk_safe(&local->pending[i], skb, tmp) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tif (info->control.vif == &sdata->vif) {\n\t\t\t\t__skb_unlink(skb, &local->pending[i]);\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tieee80211_txq_remove_vlan(local, sdata);\n\n\tsdata->bss = NULL;\n\n\tif (local->open_count == 0)\n\t\tieee80211_clear_tx_pending(local);\n\n\tsdata->vif.bss_conf.beacon_int = 0;\n\n\t/*\n\t * If the interface goes down while suspended, presumably because\n\t * the device was unplugged and that happens before our resume,\n\t * then the driver is already unconfigured and the remainder of\n\t * this function isn't needed.\n\t * XXX: what about WoWLAN? If the device has software state, e.g.\n\t *\tmemory allocated, it might expect teardown commands from\n\t *\tmac80211 here?\n\t */\n\tif (local->suspended) {\n\t\tWARN_ON(local->wowlan);\n\t\tWARN_ON(rtnl_dereference(local->monitor_sdata));\n\t\treturn;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (local->monitors == 0)\n\t\t\tieee80211_del_virtual_monitor(local);\n\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_recalc_idle(local);\n\t\tmutex_unlock(&local->mtx);\n\n\t\tif (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\t\tbreak;\n\n\t\tfallthrough;\n\tdefault:\n\t\tif (going_down)\n\t\t\tdrv_remove_interface(local, sdata);\n\t}\n\n\tieee80211_recalc_ps(local);\n\n\tif (cancel_scan)\n\t\tflush_delayed_work(&local->scan_work);\n\n\tif (local->open_count == 0) {\n\t\tieee80211_stop_device(local);\n\n\t\t/* no reconfiguring after stop! */\n\t\treturn;\n\t}\n\n\t/* do after stop to avoid reconfiguring when we stop anyway */\n\tieee80211_configure_filter(local);\n\tieee80211_hw_config(local, hw_reconf_flags);\n\n\tif (local->monitors == local->open_count)\n\t\tieee80211_add_virtual_monitor(local);\n}\n\nstatic int ieee80211_stop(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\twiphy_lock(sdata->local->hw.wiphy);\n\tieee80211_do_stop(sdata, true);\n\twiphy_unlock(sdata->local->hw.wiphy);\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_multicast_list(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint allmulti, sdata_allmulti;\n\n\tallmulti = !!(dev->flags & IFF_ALLMULTI);\n\tsdata_allmulti = !!(sdata->flags & IEEE80211_SDATA_ALLMULTI);\n\n\tif (allmulti != sdata_allmulti) {\n\t\tif (dev->flags & IFF_ALLMULTI)\n\t\t\tatomic_inc(&local->iff_allmultis);\n\t\telse\n\t\t\tatomic_dec(&local->iff_allmultis);\n\t\tsdata->flags ^= IEEE80211_SDATA_ALLMULTI;\n\t}\n\n\tspin_lock_bh(&local->filter_lock);\n\t__hw_addr_sync(&local->mc_list, &dev->mc, dev->addr_len);\n\tspin_unlock_bh(&local->filter_lock);\n\tieee80211_queue_work(&local->hw, &local->reconfig_filter);\n}\n\n/*\n * Called when the netdev is removed or, by the code below, before\n * the interface type changes.\n */\nstatic void ieee80211_teardown_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tint i;\n\n\t/* free extra data */\n\tieee80211_free_keys(sdata, false);\n\n\tieee80211_debugfs_remove_netdev(sdata);\n\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)\n\t\t__skb_queue_purge(&sdata->fragments[i].skb_list);\n\tsdata->fragment_next = 0;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tieee80211_mesh_teardown_sdata(sdata);\n}\n\nstatic void ieee80211_uninit(struct net_device *dev)\n{\n\tieee80211_teardown_sdata(IEEE80211_DEV_TO_SUB_IF(dev));\n}\n\nstatic u16 ieee80211_netdev_select_queue(struct net_device *dev,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct net_device *sb_dev)\n{\n\treturn ieee80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);\n}\n\nstatic void\nieee80211_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tdev_fetch_sw_netstats(stats, dev->tstats);\n}\n\nstatic const struct net_device_ops ieee80211_dataif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_uninit,\n\t.ndo_start_xmit\t\t= ieee80211_subif_start_xmit,\n\t.ndo_set_rx_mode\t= ieee80211_set_multicast_list,\n\t.ndo_set_mac_address \t= ieee80211_change_mac,\n\t.ndo_select_queue\t= ieee80211_netdev_select_queue,\n\t.ndo_get_stats64\t= ieee80211_get_stats64,\n};\n\nstatic u16 ieee80211_monitor_select_queue(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *sb_dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tint len_rthdr;\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn 0;\n\n\t/* reset flags and info before parsing radiotap header */\n\tmemset(info, 0, sizeof(*info));\n\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\treturn 0; /* doesn't matter, frame will be dropped */\n\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\tif (skb->len < len_rthdr + 2 ||\n\t    skb->len < len_rthdr + ieee80211_hdrlen(hdr->frame_control))\n\t\treturn 0; /* doesn't matter, frame will be dropped */\n\n\treturn ieee80211_select_queue_80211(sdata, skb, hdr);\n}\n\nstatic const struct net_device_ops ieee80211_monitorif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_uninit,\n\t.ndo_start_xmit\t\t= ieee80211_monitor_start_xmit,\n\t.ndo_set_rx_mode\t= ieee80211_set_multicast_list,\n\t.ndo_set_mac_address \t= ieee80211_change_mac,\n\t.ndo_select_queue\t= ieee80211_monitor_select_queue,\n\t.ndo_get_stats64\t= ieee80211_get_stats64,\n};\n\nstatic const struct net_device_ops ieee80211_dataif_8023_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_uninit,\n\t.ndo_start_xmit\t\t= ieee80211_subif_start_xmit_8023,\n\t.ndo_set_rx_mode\t= ieee80211_set_multicast_list,\n\t.ndo_set_mac_address\t= ieee80211_change_mac,\n\t.ndo_select_queue\t= ieee80211_netdev_select_queue,\n\t.ndo_get_stats64\t= ieee80211_get_stats64,\n};\n\nstatic bool ieee80211_iftype_supports_hdr_offload(enum nl80211_iftype iftype)\n{\n\tswitch (iftype) {\n\t/* P2P GO and client are mapped to AP/STATION types */\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ieee80211_set_sdata_offload_flags(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 flags;\n\n\tflags = sdata->vif.offload_flags;\n\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD) &&\n\t    ieee80211_iftype_supports_hdr_offload(sdata->vif.type)) {\n\t\tflags |= IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\n\t\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_FRAG) &&\n\t\t    local->hw.wiphy->frag_threshold != (u32)-1)\n\t\t\tflags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\n\t\tif (local->monitors)\n\t\t\tflags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\t} else {\n\t\tflags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_RX_DECAP_OFFLOAD) &&\n\t    ieee80211_iftype_supports_hdr_offload(sdata->vif.type)) {\n\t\tflags |= IEEE80211_OFFLOAD_DECAP_ENABLED;\n\n\t\tif (local->monitors)\n\t\t\tflags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;\n\t} else {\n\t\tflags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;\n\t}\n\n\tif (sdata->vif.offload_flags == flags)\n\t\treturn false;\n\n\tsdata->vif.offload_flags = flags;\n\tieee80211_check_fast_rx_iface(sdata);\n\treturn true;\n}\n\nstatic void ieee80211_set_vif_encap_ops(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *bss = sdata;\n\tbool enabled;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!sdata->bss)\n\t\t\treturn;\n\n\t\tbss = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\t}\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD) ||\n\t    !ieee80211_iftype_supports_hdr_offload(bss->vif.type))\n\t\treturn;\n\n\tenabled = bss->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\tif (sdata->wdev.use_4addr &&\n\t    !(bss->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_4ADDR))\n\t\tenabled = false;\n\n\tsdata->dev->netdev_ops = enabled ? &ieee80211_dataif_8023_ops :\n\t\t\t\t\t   &ieee80211_dataif_ops;\n}\n\nstatic void ieee80211_recalc_sdata_offload(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *vsdata;\n\n\tif (ieee80211_set_sdata_offload_flags(sdata)) {\n\t\tdrv_update_vif_offload(local, sdata);\n\t\tieee80211_set_vif_encap_ops(sdata);\n\t}\n\n\tlist_for_each_entry(vsdata, &local->interfaces, list) {\n\t\tif (vsdata->vif.type != NL80211_IFTYPE_AP_VLAN ||\n\t\t    vsdata->bss != &sdata->u.ap)\n\t\t\tcontinue;\n\n\t\tieee80211_set_vif_encap_ops(vsdata);\n\t}\n}\n\nvoid ieee80211_recalc_offload(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD))\n\t\treturn;\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tieee80211_recalc_sdata_offload(sdata);\n\t}\n\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nvoid ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const int offset)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 flags = sdata->u.mntr.flags;\n\n#define ADJUST(_f, _s)\tdo {\t\t\t\t\t\\\n\tif (flags & MONITOR_FLAG_##_f)\t\t\t\t\\\n\t\tlocal->fif_##_s += offset;\t\t\t\\\n\t} while (0)\n\n\tADJUST(FCSFAIL, fcsfail);\n\tADJUST(PLCPFAIL, plcpfail);\n\tADJUST(CONTROL, control);\n\tADJUST(CONTROL, pspoll);\n\tADJUST(OTHER_BSS, other_bss);\n\n#undef ADJUST\n}\n\nstatic void ieee80211_set_default_queues(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tif (ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\t\tsdata->vif.hw_queue[i] = IEEE80211_INVAL_HW_QUEUE;\n\t\telse if (local->hw.queues >= IEEE80211_NUM_ACS)\n\t\t\tsdata->vif.hw_queue[i] = i;\n\t\telse\n\t\t\tsdata->vif.hw_queue[i] = 0;\n\t}\n\tsdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;\n}\n\nint ieee80211_add_virtual_monitor(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tif (!ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF))\n\t\treturn 0;\n\n\tASSERT_RTNL();\n\n\tif (local->monitor_sdata)\n\t\treturn 0;\n\n\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size, GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\t/* set up data */\n\tsdata->local = local;\n\tsdata->vif.type = NL80211_IFTYPE_MONITOR;\n\tsnprintf(sdata->name, IFNAMSIZ, \"%s-monitor\",\n\t\t wiphy_name(local->hw.wiphy));\n\tsdata->wdev.iftype = NL80211_IFTYPE_MONITOR;\n\n\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;\n\n\tieee80211_set_default_queues(sdata);\n\n\tret = drv_add_interface(local, sdata);\n\tif (WARN_ON(ret)) {\n\t\t/* ok .. stupid driver, it asked for this! */\n\t\tkfree(sdata);\n\t\treturn ret;\n\t}\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tret = ieee80211_check_queues(sdata, NL80211_IFTYPE_MONITOR);\n\tif (ret) {\n\t\tkfree(sdata);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&local->iflist_mtx);\n\trcu_assign_pointer(local->monitor_sdata, sdata);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tmutex_lock(&local->mtx);\n\tret = ieee80211_vif_use_channel(sdata, &local->monitor_chandef,\n\t\t\t\t\tIEEE80211_CHANCTX_EXCLUSIVE);\n\tmutex_unlock(&local->mtx);\n\tif (ret) {\n\t\tmutex_lock(&local->iflist_mtx);\n\t\tRCU_INIT_POINTER(local->monitor_sdata, NULL);\n\t\tmutex_unlock(&local->iflist_mtx);\n\t\tsynchronize_net();\n\t\tdrv_remove_interface(local, sdata);\n\t\tkfree(sdata);\n\t\treturn ret;\n\t}\n\n\tskb_queue_head_init(&sdata->skb_queue);\n\tINIT_WORK(&sdata->work, ieee80211_iface_work);\n\n\treturn 0;\n}\n\nvoid ieee80211_del_virtual_monitor(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (!ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF))\n\t\treturn;\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tsdata = rcu_dereference_protected(local->monitor_sdata,\n\t\t\t\t\t  lockdep_is_held(&local->iflist_mtx));\n\tif (!sdata) {\n\t\tmutex_unlock(&local->iflist_mtx);\n\t\treturn;\n\t}\n\n\tRCU_INIT_POINTER(local->monitor_sdata, NULL);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tsynchronize_net();\n\n\tmutex_lock(&local->mtx);\n\tieee80211_vif_release_channel(sdata);\n\tmutex_unlock(&local->mtx);\n\n\tdrv_remove_interface(local, sdata);\n\n\tkfree(sdata);\n}\n\n/*\n * NOTE: Be very careful when changing this function, it must NOT return\n * an error on interface type changes that have been pre-checked, so most\n * checks should be in ieee80211_check_concurrent_iface.\n */\nint ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct net_device *dev = wdev->netdev;\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 changed = 0;\n\tint res;\n\tu32 hw_reconf_flags = 0;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN: {\n\t\tstruct ieee80211_sub_if_data *master;\n\n\t\tif (!sdata->bss)\n\t\t\treturn -ENOLINK;\n\n\t\tmutex_lock(&local->mtx);\n\t\tlist_add(&sdata->u.vlan.list, &sdata->bss->vlans);\n\t\tmutex_unlock(&local->mtx);\n\n\t\tmaster = container_of(sdata->bss,\n\t\t\t\t      struct ieee80211_sub_if_data, u.ap);\n\t\tsdata->control_port_protocol =\n\t\t\tmaster->control_port_protocol;\n\t\tsdata->control_port_no_encrypt =\n\t\t\tmaster->control_port_no_encrypt;\n\t\tsdata->control_port_over_nl80211 =\n\t\t\tmaster->control_port_over_nl80211;\n\t\tsdata->control_port_no_preauth =\n\t\t\tmaster->control_port_no_preauth;\n\t\tsdata->vif.cab_queue = master->vif.cab_queue;\n\t\tmemcpy(sdata->vif.hw_queue, master->vif.hw_queue,\n\t\t       sizeof(sdata->vif.hw_queue));\n\t\tsdata->vif.bss_conf.chandef = master->vif.bss_conf.chandef;\n\n\t\tmutex_lock(&local->key_mtx);\n\t\tsdata->crypto_tx_tailroom_needed_cnt +=\n\t\t\tmaster->crypto_tx_tailroom_needed_cnt;\n\t\tmutex_unlock(&local->key_mtx);\n\n\t\tbreak;\n\t\t}\n\tcase NL80211_IFTYPE_AP:\n\t\tsdata->bss = &sdata->u.ap;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_NAN:\n\t\t/* no special treatment */\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_WDS:\n\t\t/* cannot happen */\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (local->open_count == 0) {\n\t\tres = drv_start(local);\n\t\tif (res)\n\t\t\tgoto err_del_bss;\n\t\t/* we're brought up, everything changes */\n\t\thw_reconf_flags = ~0;\n\t\tieee80211_led_radio(local, true);\n\t\tieee80211_mod_tpt_led_trig(local,\n\t\t\t\t\t   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);\n\t}\n\n\t/*\n\t * Copy the hopefully now-present MAC address to\n\t * this interface, if it has the special null one.\n\t */\n\tif (dev && is_zero_ether_addr(dev->dev_addr)) {\n\t\tmemcpy(dev->dev_addr,\n\t\t       local->hw.wiphy->perm_addr,\n\t\t       ETH_ALEN);\n\t\tmemcpy(dev->perm_addr, dev->dev_addr, ETH_ALEN);\n\n\t\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t\tres = -EADDRNOTAVAIL;\n\t\t\tgoto err_stop;\n\t\t}\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t/* no need to tell driver, but set carrier and chanctx */\n\t\tif (rtnl_dereference(sdata->bss->beacon)) {\n\t\t\tieee80211_vif_vlan_copy_chanctx(sdata);\n\t\t\tnetif_carrier_on(dev);\n\t\t\tieee80211_set_vif_encap_ops(sdata);\n\t\t} else {\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tres = drv_add_interface(local, sdata);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\t\t} else if (local->monitors == 0 && local->open_count == 0) {\n\t\t\tres = ieee80211_add_virtual_monitor(local);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\t\t}\n\n\t\t/* must be before the call to ieee80211_configure_filter */\n\t\tlocal->monitors++;\n\t\tif (local->monitors == 1) {\n\t\t\tlocal->hw.conf.flags |= IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, 1);\n\t\tieee80211_configure_filter(local);\n\t\tieee80211_recalc_offload(local);\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_recalc_idle(local);\n\t\tmutex_unlock(&local->mtx);\n\n\t\tnetif_carrier_on(dev);\n\t\tbreak;\n\tdefault:\n\t\tif (coming_up) {\n\t\t\tieee80211_del_virtual_monitor(local);\n\t\t\tieee80211_set_sdata_offload_flags(sdata);\n\n\t\t\tres = drv_add_interface(local, sdata);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\n\t\t\tieee80211_set_vif_encap_ops(sdata);\n\t\t\tres = ieee80211_check_queues(sdata,\n\t\t\t\tieee80211_vif_type_p2p(&sdata->vif));\n\t\t\tif (res)\n\t\t\t\tgoto err_del_interface;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\t\tlocal->fif_pspoll++;\n\t\t\tlocal->fif_probe_req++;\n\n\t\t\tieee80211_configure_filter(local);\n\t\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\t\tlocal->fif_probe_req++;\n\t\t}\n\n\t\tif (sdata->vif.probe_req_reg)\n\t\t\tdrv_config_iface_filter(local, sdata,\n\t\t\t\t\t\tFIF_PROBE_REQ,\n\t\t\t\t\t\tFIF_PROBE_REQ);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_NAN)\n\t\t\tchanged |= ieee80211_reset_erp_info(sdata);\n\t\tieee80211_bss_info_change_notify(sdata, changed);\n\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\tnetif_carrier_off(dev);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* not reached */\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * Set default queue parameters so drivers don't\n\t\t * need to initialise the hardware if the hardware\n\t\t * doesn't start up with sane defaults.\n\t\t * Enable QoS for anything but station interfaces.\n\t\t */\n\t\tieee80211_set_wmm_default(sdata, true,\n\t\t\tsdata->vif.type != NL80211_IFTYPE_STATION);\n\t}\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\trcu_assign_pointer(local->p2p_sdata, sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES)\n\t\t\tbreak;\n\t\tlist_add_tail_rcu(&sdata->u.mntr.list, &local->mon_list);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * set_multicast_list will be invoked by the networking core\n\t * which will check whether any increments here were done in\n\t * error and sync them down to the hardware as filter flags.\n\t */\n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_inc(&local->iff_allmultis);\n\n\tif (coming_up)\n\t\tlocal->open_count++;\n\n\tif (hw_reconf_flags)\n\t\tieee80211_hw_config(local, hw_reconf_flags);\n\n\tieee80211_recalc_ps(local);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t    local->ops->wake_tx_queue) {\n\t\t/* XXX: for AP_VLAN, actually track AP queues */\n\t\tif (dev)\n\t\t\tnetif_tx_start_all_queues(dev);\n\t} else if (dev) {\n\t\tunsigned long flags;\n\t\tint n_acs = IEEE80211_NUM_ACS;\n\t\tint ac;\n\n\t\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\t\tn_acs = 1;\n\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tif (sdata->vif.cab_queue == IEEE80211_INVAL_HW_QUEUE ||\n\t\t    (local->queue_stop_reasons[sdata->vif.cab_queue] == 0 &&\n\t\t     skb_queue_empty(&local->pending[sdata->vif.cab_queue]))) {\n\t\t\tfor (ac = 0; ac < n_acs; ac++) {\n\t\t\t\tint ac_queue = sdata->vif.hw_queue[ac];\n\n\t\t\t\tif (local->queue_stop_reasons[ac_queue] == 0 &&\n\t\t\t\t    skb_queue_empty(&local->pending[ac_queue]))\n\t\t\t\t\tnetif_start_subqueue(dev, ac);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\t}\n\n\treturn 0;\n err_del_interface:\n\tdrv_remove_interface(local, sdata);\n err_stop:\n\tif (!local->open_count)\n\t\tdrv_stop(local);\n err_del_bss:\n\tsdata->bss = NULL;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tmutex_lock(&local->mtx);\n\t\tlist_del(&sdata->u.vlan.list);\n\t\tmutex_unlock(&local->mtx);\n\t}\n\t/* might already be clear but that doesn't matter */\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\treturn res;\n}\n\nstatic void ieee80211_if_free(struct net_device *dev)\n{\n\tfree_percpu(dev->tstats);\n}\n\nstatic void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ieee80211_if_free;\n}\n\nstatic void ieee80211_if_setup_no_queue(struct net_device *dev)\n{\n\tieee80211_if_setup(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n}\n\nstatic void ieee80211_iface_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data, work);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct sta_info *sta;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tif (test_bit(SCAN_SW_SCANNING, &local->scanning))\n\t\treturn;\n\n\tif (!ieee80211_can_run_worker(local))\n\t\treturn;\n\n\t/* first process frames */\n\twhile ((skb = skb_dequeue(&sdata->skb_queue))) {\n\t\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\t\tif (ieee80211_is_action(mgmt->frame_control) &&\n\t\t    mgmt->u.action.category == WLAN_CATEGORY_BACK) {\n\t\t\tint len = skb->len;\n\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\t\tif (sta) {\n\t\t\t\tswitch (mgmt->u.action.u.addba_req.action_code) {\n\t\t\t\tcase WLAN_ACTION_ADDBA_REQ:\n\t\t\t\t\tieee80211_process_addba_request(\n\t\t\t\t\t\t\tlocal, sta, mgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WLAN_ACTION_ADDBA_RESP:\n\t\t\t\t\tieee80211_process_addba_resp(local, sta,\n\t\t\t\t\t\t\t\t     mgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WLAN_ACTION_DELBA:\n\t\t\t\t\tieee80211_process_delba(sdata, sta,\n\t\t\t\t\t\t\t\tmgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t} else if (ieee80211_is_action(mgmt->frame_control) &&\n\t\t\t   mgmt->u.action.category == WLAN_CATEGORY_VHT) {\n\t\t\tswitch (mgmt->u.action.u.vht_group_notif.action_code) {\n\t\t\tcase WLAN_VHT_ACTION_OPMODE_NOTIF: {\n\t\t\t\tstruct ieee80211_rx_status *status;\n\t\t\t\tenum nl80211_band band;\n\t\t\t\tu8 opmode;\n\n\t\t\t\tstatus = IEEE80211_SKB_RXCB(skb);\n\t\t\t\tband = status->band;\n\t\t\t\topmode = mgmt->u.action.u.vht_opmode_notif.operating_mode;\n\n\t\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\n\t\t\t\tif (sta)\n\t\t\t\t\tieee80211_vht_handle_opmode(sdata, sta,\n\t\t\t\t\t\t\t\t    opmode,\n\t\t\t\t\t\t\t\t    band);\n\n\t\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase WLAN_VHT_ACTION_GROUPID_MGMT:\n\t\t\t\tieee80211_process_mu_groups(sdata, mgmt);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ieee80211_is_ext(mgmt->frame_control)) {\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\t\tieee80211_sta_rx_queued_ext(sdata, skb);\n\t\t\telse\n\t\t\t\tWARN_ON(1);\n\t\t} else if (ieee80211_is_data_qos(mgmt->frame_control)) {\n\t\t\tstruct ieee80211_hdr *hdr = (void *)mgmt;\n\t\t\t/*\n\t\t\t * So the frame isn't mgmt, but frame_control\n\t\t\t * is at the right place anyway, of course, so\n\t\t\t * the if statement is correct.\n\t\t\t *\n\t\t\t * Warn if we have other data frame types here,\n\t\t\t * they must not get here.\n\t\t\t */\n\t\t\tWARN_ON(hdr->frame_control &\n\t\t\t\t\tcpu_to_le16(IEEE80211_STYPE_NULLFUNC));\n\t\t\tWARN_ON(!(hdr->seq_ctrl &\n\t\t\t\t\tcpu_to_le16(IEEE80211_SCTL_FRAG)));\n\t\t\t/*\n\t\t\t * This was a fragment of a frame, received while\n\t\t\t * a block-ack session was active. That cannot be\n\t\t\t * right, so terminate the session.\n\t\t\t */\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\t\tif (sta) {\n\t\t\t\tu16 tid = ieee80211_get_tid(hdr);\n\n\t\t\t\t__ieee80211_stop_rx_ba_session(\n\t\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\t\tWLAN_REASON_QSTA_REQUIRE_SETUP,\n\t\t\t\t\ttrue);\n\t\t\t}\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t} else switch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tieee80211_sta_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tieee80211_ibss_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tbreak;\n\t\t\tieee80211_mesh_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"frame for unexpected interface type\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tkcov_remote_stop();\n\t}\n\n\t/* then other type-dependent work */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tieee80211_mesh_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\tieee80211_ocb_work(sdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ieee80211_recalc_smps_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data, recalc_smps);\n\n\tieee80211_recalc_smps(sdata);\n}\n\n/*\n * Helper function to initialise an interface to a specific type.\n */\nstatic void ieee80211_setup_sdata(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum nl80211_iftype type)\n{\n\tstatic const u8 bssid_wildcard[ETH_ALEN] = {0xff, 0xff, 0xff,\n\t\t\t\t\t\t    0xff, 0xff, 0xff};\n\n\t/* clear type-dependent union */\n\tmemset(&sdata->u, 0, sizeof(sdata->u));\n\n\t/* and set some type-dependent values */\n\tsdata->vif.type = type;\n\tsdata->vif.p2p = false;\n\tsdata->wdev.iftype = type;\n\n\tsdata->control_port_protocol = cpu_to_be16(ETH_P_PAE);\n\tsdata->control_port_no_encrypt = false;\n\tsdata->control_port_over_nl80211 = false;\n\tsdata->control_port_no_preauth = false;\n\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;\n\tsdata->vif.bss_conf.idle = true;\n\tsdata->vif.bss_conf.txpower = INT_MIN; /* unset */\n\n\tsdata->noack_map = 0;\n\n\t/* only monitor/p2p-device differ */\n\tif (sdata->dev) {\n\t\tsdata->dev->netdev_ops = &ieee80211_dataif_ops;\n\t\tsdata->dev->type = ARPHRD_ETHER;\n\t}\n\n\tskb_queue_head_init(&sdata->skb_queue);\n\tINIT_WORK(&sdata->work, ieee80211_iface_work);\n\tINIT_WORK(&sdata->recalc_smps, ieee80211_recalc_smps_work);\n\tINIT_WORK(&sdata->csa_finalize_work, ieee80211_csa_finalize_work);\n\tINIT_LIST_HEAD(&sdata->assigned_chanctx_list);\n\tINIT_LIST_HEAD(&sdata->reserved_chanctx_list);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\ttype = NL80211_IFTYPE_AP;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tskb_queue_head_init(&sdata->u.ap.ps.bc_buf);\n\t\tINIT_LIST_HEAD(&sdata->u.ap.vlans);\n\t\tsdata->vif.bss_conf.bssid = sdata->vif.addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\ttype = NL80211_IFTYPE_STATION;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_STATION:\n\t\tsdata->vif.bss_conf.bssid = sdata->u.mgd.bssid;\n\t\tieee80211_sta_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\tsdata->vif.bss_conf.bssid = bssid_wildcard;\n\t\tieee80211_ocb_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tsdata->vif.bss_conf.bssid = sdata->u.ibss.bssid;\n\t\tieee80211_ibss_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tieee80211_mesh_init_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tsdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\tsdata->dev->netdev_ops = &ieee80211_monitorif_ops;\n\t\tsdata->u.mntr.flags = MONITOR_FLAG_CONTROL |\n\t\t\t\t      MONITOR_FLAG_OTHER_BSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\tidr_init(&sdata->u.nan.function_inst_ids);\n\t\tspin_lock_init(&sdata->u.nan.func_lock);\n\t\tsdata->vif.bss_conf.bssid = sdata->vif.addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tsdata->vif.bss_conf.bssid = sdata->vif.addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tieee80211_debugfs_add_netdev(sdata);\n}\n\nstatic int ieee80211_runtime_change_iftype(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret, err;\n\tenum nl80211_iftype internal_type = type;\n\tbool p2p = false;\n\n\tASSERT_RTNL();\n\n\tif (!local->ops->change_interface)\n\t\treturn -EBUSY;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_OCB:\n\t\t/*\n\t\t * Could maybe also all others here?\n\t\t * Just not sure how that interacts\n\t\t * with the RX/config path e.g. for\n\t\t * mesh.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_OCB:\n\t\t/*\n\t\t * Could probably support everything\n\t\t * but here.\n\t\t */\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_AP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tret = ieee80211_check_concurrent_iface(sdata, internal_type);\n\tif (ret)\n\t\treturn ret;\n\n\tieee80211_stop_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE);\n\tsynchronize_net();\n\n\tieee80211_do_stop(sdata, false);\n\n\tieee80211_teardown_sdata(sdata);\n\n\tieee80211_set_sdata_offload_flags(sdata);\n\tret = drv_change_interface(local, sdata, internal_type, p2p);\n\tif (ret)\n\t\ttype = ieee80211_vif_type_p2p(&sdata->vif);\n\n\t/*\n\t * Ignore return value here, there's not much we can do since\n\t * the driver changed the interface type internally already.\n\t * The warnings will hopefully make driver authors fix it :-)\n\t */\n\tieee80211_check_queues(sdata, type);\n\n\tieee80211_setup_sdata(sdata, type);\n\tieee80211_set_vif_encap_ops(sdata);\n\n\terr = ieee80211_do_open(&sdata->wdev, false);\n\tWARN(err, \"type change: do_open returned %d\", err);\n\n\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE);\n\treturn ret;\n}\n\nint ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,\n\t\t\t     enum nl80211_iftype type)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (type == ieee80211_vif_type_p2p(&sdata->vif))\n\t\treturn 0;\n\n\tif (ieee80211_sdata_running(sdata)) {\n\t\tret = ieee80211_runtime_change_iftype(sdata, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Purge and reset type-dependent state. */\n\t\tieee80211_teardown_sdata(sdata);\n\t\tieee80211_setup_sdata(sdata, type);\n\t}\n\n\t/* reset some values that shouldn't be kept across type changes */\n\tif (type == NL80211_IFTYPE_STATION)\n\t\tsdata->u.mgd.use_4addr = false;\n\n\treturn 0;\n}\n\nstatic void ieee80211_assign_perm_addr(struct ieee80211_local *local,\n\t\t\t\t       u8 *perm_addr, enum nl80211_iftype type)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu64 mask, start, addr, val, inc;\n\tu8 *m;\n\tu8 tmp_addr[ETH_ALEN];\n\tint i;\n\n\t/* default ... something at least */\n\tmemcpy(perm_addr, local->hw.wiphy->perm_addr, ETH_ALEN);\n\n\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask) &&\n\t    local->hw.wiphy->n_addresses <= 1)\n\t\treturn;\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t/* doesn't matter */\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t/* match up with an AP interface */\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(perm_addr, sdata->vif.addr, ETH_ALEN);\n\t\t\tbreak;\n\t\t}\n\t\t/* keep default if no AP interface present */\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (ieee80211_hw_check(&local->hw, P2P_DEV_ADDR_FOR_INTF)) {\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(perm_addr, sdata->vif.addr, ETH_ALEN);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t/* assign a new address if possible -- try n_addresses first */\n\t\tfor (i = 0; i < local->hw.wiphy->n_addresses; i++) {\n\t\t\tbool used = false;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (ether_addr_equal(local->hw.wiphy->addresses[i].addr,\n\t\t\t\t\t\t     sdata->vif.addr)) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(perm_addr,\n\t\t\t\t       local->hw.wiphy->addresses[i].addr,\n\t\t\t\t       ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* try mask if available */\n\t\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask))\n\t\t\tbreak;\n\n\t\tm = local->hw.wiphy->addr_mask;\n\t\tmask =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tif (__ffs64(mask) + hweight64(mask) != fls64(mask)) {\n\t\t\t/* not a contiguous mask ... not handled now! */\n\t\t\tpr_info(\"not contiguous\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Pick address of existing interface in case user changed\n\t\t * MAC address manually, default to perm_addr.\n\t\t */\n\t\tm = local->hw.wiphy->perm_addr;\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR)\n\t\t\t\tcontinue;\n\t\t\tm = sdata->vif.addr;\n\t\t\tbreak;\n\t\t}\n\t\tstart = ((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tinc = 1ULL<<__ffs64(mask);\n\t\tval = (start & mask);\n\t\taddr = (start & ~mask) | (val & mask);\n\t\tdo {\n\t\t\tbool used = false;\n\n\t\t\ttmp_addr[5] = addr >> 0*8;\n\t\t\ttmp_addr[4] = addr >> 1*8;\n\t\t\ttmp_addr[3] = addr >> 2*8;\n\t\t\ttmp_addr[2] = addr >> 3*8;\n\t\t\ttmp_addr[1] = addr >> 4*8;\n\t\t\ttmp_addr[0] = addr >> 5*8;\n\n\t\t\tval += inc;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (ether_addr_equal(tmp_addr, sdata->vif.addr)) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(perm_addr, tmp_addr, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddr = (start & ~mask) | (val & mask);\n\t\t} while (addr != start);\n\n\t\tbreak;\n\t}\n\n out_unlock:\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nint ieee80211_if_add(struct ieee80211_local *local, const char *name,\n\t\t     unsigned char name_assign_type,\n\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,\n\t\t     struct vif_params *params)\n{\n\tstruct net_device *ndev = NULL;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tstruct txq_info *txqi;\n\tvoid (*if_setup)(struct net_device *dev);\n\tint ret, i;\n\tint txqs = 1;\n\n\tASSERT_RTNL();\n\n\tif (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sdata)\n\t\t\treturn -ENOMEM;\n\t\twdev = &sdata->wdev;\n\n\t\tsdata->dev = NULL;\n\t\tstrlcpy(sdata->name, name, IFNAMSIZ);\n\t\tieee80211_assign_perm_addr(local, wdev->address, type);\n\t\tmemcpy(sdata->vif.addr, wdev->address, ETH_ALEN);\n\t} else {\n\t\tint size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,\n\t\t\t\t sizeof(void *));\n\t\tint txq_size = 0;\n\n\t\tif (local->ops->wake_tx_queue &&\n\t\t    type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    (type != NL80211_IFTYPE_MONITOR ||\n\t\t     (params->flags & MONITOR_FLAG_ACTIVE)))\n\t\t\ttxq_size += sizeof(struct txq_info) +\n\t\t\t\t    local->hw.txq_data_size;\n\n\t\tif (local->ops->wake_tx_queue) {\n\t\t\tif_setup = ieee80211_if_setup_no_queue;\n\t\t} else {\n\t\t\tif_setup = ieee80211_if_setup;\n\t\t\tif (local->hw.queues >= IEEE80211_NUM_ACS)\n\t\t\t\ttxqs = IEEE80211_NUM_ACS;\n\t\t}\n\n\t\tndev = alloc_netdev_mqs(size + txq_size,\n\t\t\t\t\tname, name_assign_type,\n\t\t\t\t\tif_setup, txqs, 1);\n\t\tif (!ndev)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!local->ops->wake_tx_queue && local->hw.wiphy->tx_queue_len)\n\t\t\tndev->tx_queue_len = local->hw.wiphy->tx_queue_len;\n\n\t\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));\n\n\t\tndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\t\tif (!ndev->tstats) {\n\t\t\tfree_netdev(ndev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tndev->needed_headroom = local->tx_headroom +\n\t\t\t\t\t4*6 /* four MAC addresses */\n\t\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */\n\t\t\t\t\t+ 6 /* mesh */\n\t\t\t\t\t+ 8 /* rfc1042/bridge tunnel */\n\t\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */\n\t\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;\n\t\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;\n\n\t\tret = dev_alloc_name(ndev, ndev->name);\n\t\tif (ret < 0) {\n\t\t\tieee80211_if_free(ndev);\n\t\t\tfree_netdev(ndev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tieee80211_assign_perm_addr(local, ndev->perm_addr, type);\n\t\tif (is_valid_ether_addr(params->macaddr))\n\t\t\tmemcpy(ndev->dev_addr, params->macaddr, ETH_ALEN);\n\t\telse\n\t\t\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);\n\t\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));\n\n\t\t/* don't use IEEE80211_DEV_TO_SUB_IF -- it checks too much */\n\t\tsdata = netdev_priv(ndev);\n\t\tndev->ieee80211_ptr = &sdata->wdev;\n\t\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);\n\t\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);\n\n\t\tif (txq_size) {\n\t\t\ttxqi = netdev_priv(ndev) + size;\n\t\t\tieee80211_txq_init(sdata, NULL, txqi, 0);\n\t\t}\n\n\t\tsdata->dev = ndev;\n\t}\n\n\t/* initialise type-independent data */\n\tsdata->wdev.wiphy = local->hw.wiphy;\n\tsdata->local = local;\n\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)\n\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);\n\n\tINIT_LIST_HEAD(&sdata->key_list);\n\n\tINIT_DELAYED_WORK(&sdata->dfs_cac_timer_work,\n\t\t\t  ieee80211_dfs_cac_timer_work);\n\tINIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,\n\t\t\t  ieee80211_delayed_tailroom_dec);\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = local->hw.wiphy->bands[i];\n\t\tsdata->rc_rateidx_mask[i] =\n\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;\n\t\tif (sband) {\n\t\t\t__le16 cap;\n\t\t\tu16 *vht_rate_mask;\n\n\t\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i],\n\t\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));\n\n\t\t\tcap = sband->vht_cap.vht_mcs.rx_mcs_map;\n\t\t\tvht_rate_mask = sdata->rc_rateidx_vht_mcs_mask[i];\n\t\t\tieee80211_get_vht_mask_from_cap(cap, vht_rate_mask);\n\t\t} else {\n\t\t\tmemset(sdata->rc_rateidx_mcs_mask[i], 0,\n\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));\n\t\t\tmemset(sdata->rc_rateidx_vht_mcs_mask[i], 0,\n\t\t\t       sizeof(sdata->rc_rateidx_vht_mcs_mask[i]));\n\t\t}\n\t}\n\n\tieee80211_set_default_queues(sdata);\n\n\tsdata->ap_power_level = IEEE80211_UNSET_POWER_LEVEL;\n\tsdata->user_power_level = local->user_power_level;\n\n\tsdata->encrypt_headroom = IEEE80211_ENCRYPT_HEADROOM;\n\n\t/* setup type-dependent data */\n\tieee80211_setup_sdata(sdata, type);\n\n\tif (ndev) {\n\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;\n\t\tif (type == NL80211_IFTYPE_STATION)\n\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;\n\n\t\tndev->features |= local->hw.netdev_features;\n\t\tndev->hw_features |= ndev->features &\n\t\t\t\t\tMAC80211_SUPPORTED_FEATURES_TX;\n\n\t\tnetdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);\n\n\t\t/* MTU range: 256 - 2304 */\n\t\tndev->min_mtu = 256;\n\t\tndev->max_mtu = local->hw.max_mtu;\n\n\t\tret = cfg80211_register_netdevice(ndev);\n\t\tif (ret) {\n\t\t\tfree_netdev(ndev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_add_tail_rcu(&sdata->list, &local->interfaces);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tif (new_wdev)\n\t\t*new_wdev = &sdata->wdev;\n\n\treturn 0;\n}\n\nvoid ieee80211_if_remove(struct ieee80211_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tlist_del_rcu(&sdata->list);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tif (sdata->vif.txq)\n\t\tieee80211_txq_purge(sdata->local, to_txq_info(sdata->vif.txq));\n\n\tsynchronize_rcu();\n\n\tcfg80211_unregister_wdev(&sdata->wdev);\n\n\tif (!sdata->dev) {\n\t\tieee80211_teardown_sdata(sdata);\n\t\tkfree(sdata);\n\t}\n}\n\nvoid ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata)\n{\n\tif (WARN_ON_ONCE(!test_bit(SDATA_STATE_RUNNING, &sdata->state)))\n\t\treturn;\n\tieee80211_do_stop(sdata, true);\n}\n\nvoid ieee80211_remove_interfaces(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata, *tmp;\n\tLIST_HEAD(unreg_list);\n\tLIST_HEAD(wdev_list);\n\n\tASSERT_RTNL();\n\n\t/* Before destroying the interfaces, make sure they're all stopped so\n\t * that the hardware is stopped. Otherwise, the driver might still be\n\t * iterating the interfaces during the shutdown, e.g. from a worker\n\t * or from RX processing or similar, and if it does so (using atomic\n\t * iteration) while we're manipulating the list, the iteration will\n\t * crash.\n\t *\n\t * After this, the hardware should be stopped and the driver should\n\t * have stopped all of its activities, so that we can do RCU-unaware\n\t * manipulations of the interface list below.\n\t */\n\tcfg80211_shutdown_all_interfaces(local->hw.wiphy);\n\n\tWARN(local->open_count, \"%s: open count remains %d\\n\",\n\t     wiphy_name(local->hw.wiphy), local->open_count);\n\n\tieee80211_txq_teardown_flows(local);\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {\n\t\tlist_del(&sdata->list);\n\n\t\tif (sdata->dev)\n\t\t\tunregister_netdevice_queue(sdata->dev, &unreg_list);\n\t\telse\n\t\t\tlist_add(&sdata->list, &wdev_list);\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\tunregister_netdevice_many(&unreg_list);\n\n\twiphy_lock(local->hw.wiphy);\n\tlist_for_each_entry_safe(sdata, tmp, &wdev_list, list) {\n\t\tlist_del(&sdata->list);\n\t\tcfg80211_unregister_wdev(&sdata->wdev);\n\t\tkfree(sdata);\n\t}\n\twiphy_unlock(local->hw.wiphy);\n}\n\nstatic int netdev_notify(struct notifier_block *nb,\n\t\t\t unsigned long state, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (state != NETDEV_CHANGENAME)\n\t\treturn NOTIFY_DONE;\n\n\tif (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)\n\t\treturn NOTIFY_DONE;\n\n\tif (dev->ieee80211_ptr->wiphy->privid != mac80211_wiphy_privid)\n\t\treturn NOTIFY_DONE;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tmemcpy(sdata->name, dev->name, IFNAMSIZ);\n\tieee80211_debugfs_rename_netdev(sdata);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mac80211_netdev_notifier = {\n\t.notifier_call = netdev_notify,\n};\n\nint ieee80211_iface_init(void)\n{\n\treturn register_netdevice_notifier(&mac80211_netdev_notifier);\n}\n\nvoid ieee80211_iface_exit(void)\n{\n\tunregister_netdevice_notifier(&mac80211_netdev_notifier);\n}\n\nvoid ieee80211_vif_inc_num_mcast(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tatomic_inc(&sdata->u.ap.num_mcast_sta);\n\telse if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tatomic_inc(&sdata->u.vlan.num_mcast_sta);\n}\n\nvoid ieee80211_vif_dec_num_mcast(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tatomic_dec(&sdata->u.ap.num_mcast_sta);\n\telse if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tatomic_dec(&sdata->u.vlan.num_mcast_sta);\n}\n"}, "1": {"id": 1, "path": "/src/include/linux/rtnetlink.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_RTNETLINK_H\n#define __LINUX_RTNETLINK_H\n\n\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/wait.h>\n#include <linux/refcount.h>\n#include <uapi/linux/rtnetlink.h>\n\nextern int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, u32 group, int echo);\nextern int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid);\nextern void rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid,\n\t\t\tu32 group, struct nlmsghdr *nlh, gfp_t flags);\nextern void rtnl_set_sk_err(struct net *net, u32 group, int error);\nextern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);\nextern int rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst,\n\t\t\t      u32 id, long expires, u32 error);\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned change, gfp_t flags);\nvoid rtmsg_ifinfo_newnet(int type, struct net_device *dev, unsigned int change,\n\t\t\t gfp_t flags, int *new_nsid, int new_ifindex);\nstruct sk_buff *rtmsg_ifinfo_build_skb(int type, struct net_device *dev,\n\t\t\t\t       unsigned change, u32 event,\n\t\t\t\t       gfp_t flags, int *new_nsid,\n\t\t\t\t       int new_ifindex);\nvoid rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev,\n\t\t       gfp_t flags);\n\n\n/* RTNL is used as a global lock for all changes to network configuration  */\nextern void rtnl_lock(void);\nextern void rtnl_unlock(void);\nextern int rtnl_trylock(void);\nextern int rtnl_is_locked(void);\nextern int rtnl_lock_killable(void);\nextern bool refcount_dec_and_rtnl_lock(refcount_t *r);\n\nextern wait_queue_head_t netdev_unregistering_wq;\nextern struct rw_semaphore pernet_ops_rwsem;\nextern struct rw_semaphore net_rwsem;\n\n#ifdef CONFIG_PROVE_LOCKING\nextern bool lockdep_rtnl_is_held(void);\n#else\nstatic inline bool lockdep_rtnl_is_held(void)\n{\n\treturn true;\n}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n\n/**\n * rcu_dereference_rtnl - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n *\n * Do an rcu_dereference(p), but check caller either holds rcu_read_lock()\n * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference()\n */\n#define rcu_dereference_rtnl(p)\t\t\t\t\t\\\n\trcu_dereference_check(p, lockdep_rtnl_is_held())\n\n/**\n * rcu_dereference_bh_rtnl - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereference\n *\n * Do an rcu_dereference_bh(p), but check caller either holds rcu_read_lock_bh()\n * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference_bh()\n */\n#define rcu_dereference_bh_rtnl(p)\t\t\t\t\\\n\trcu_dereference_bh_check(p, lockdep_rtnl_is_held())\n\n/**\n * rtnl_dereference - fetch RCU pointer when updates are prevented by RTNL\n * @p: The pointer to read, prior to dereferencing\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE(), because caller holds RTNL.\n */\n#define rtnl_dereference(p)\t\t\t\t\t\\\n\trcu_dereference_protected(p, lockdep_rtnl_is_held())\n\nstatic inline struct netdev_queue *dev_ingress_queue(struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->ingress_queue);\n}\n\nstatic inline struct netdev_queue *dev_ingress_queue_rcu(struct net_device *dev)\n{\n\treturn rcu_dereference(dev->ingress_queue);\n}\n\nstruct netdev_queue *dev_ingress_queue_create(struct net_device *dev);\n\n#ifdef CONFIG_NET_INGRESS\nvoid net_inc_ingress_queue(void);\nvoid net_dec_ingress_queue(void);\n#endif\n\n#ifdef CONFIG_NET_EGRESS\nvoid net_inc_egress_queue(void);\nvoid net_dec_egress_queue(void);\n#endif\n\nvoid rtnetlink_init(void);\nvoid __rtnl_unlock(void);\nvoid rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail);\n\n#define ASSERT_RTNL() \\\n\tWARN_ONCE(!rtnl_is_locked(), \\\n\t\t  \"RTNL: assertion failed at %s (%d)\\n\", __FILE__,  __LINE__)\n\nextern int ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     struct net_device *dev,\n\t\t\t     struct net_device *filter_dev,\n\t\t\t     int *idx);\nextern int ndo_dflt_fdb_add(struct ndmsg *ndm,\n\t\t\t    struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid,\n\t\t\t    u16 flags);\nextern int ndo_dflt_fdb_del(struct ndmsg *ndm,\n\t\t\t    struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid);\n\nextern int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t   struct net_device *dev, u16 mode,\n\t\t\t\t   u32 flags, u32 mask, int nlflags,\n\t\t\t\t   u32 filter_mask,\n\t\t\t\t   int (*vlan_fill)(struct sk_buff *skb,\n\t\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t\t    u32 filter_mask));\n#endif\t/* __LINUX_RTNETLINK_H */\n"}, "2": {"id": 2, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}, "3": {"id": 3, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n# define likely_notrace(x)\tlikely(x)\n# define unlikely_notrace(x)\tunlikely(x)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "4": {"id": 4, "path": "/src/net/mac80211/ieee80211_i.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2015  Intel Mobile Communications GmbH\n * Copyright (C) 2018-2020 Intel Corporation\n */\n\n#ifndef IEEE80211_I_H\n#define IEEE80211_I_H\n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/if_ether.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/etherdevice.h>\n#include <linux/leds.h>\n#include <linux/idr.h>\n#include <linux/rhashtable.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <net/fq.h>\n#include \"key.h\"\n#include \"sta_info.h\"\n#include \"debug.h\"\n\nextern const struct cfg80211_ops mac80211_config_ops;\n\nstruct ieee80211_local;\n\n/* Maximum number of broadcast/multicast frames to buffer when some of the\n * associated stations are using power saving. */\n#define AP_MAX_BC_BUFFER 128\n\n/* Maximum number of frames buffered to all STAs, including multicast frames.\n * Note: increasing this limit increases the potential memory requirement. Each\n * frame can be up to about 2 kB long. */\n#define TOTAL_MAX_TX_BUFFER 512\n\n/* Required encryption head and tailroom */\n#define IEEE80211_ENCRYPT_HEADROOM 8\n#define IEEE80211_ENCRYPT_TAILROOM 18\n\n/* IEEE 802.11 (Ch. 9.5 Defragmentation) requires support for concurrent\n * reception of at least three fragmented frames. This limit can be increased\n * by changing this define, at the cost of slower frame reassembly and\n * increased memory use (about 2 kB of RAM per entry). */\n#define IEEE80211_FRAGMENT_MAX 4\n\n/* power level hasn't been configured (or set to automatic) */\n#define IEEE80211_UNSET_POWER_LEVEL\tINT_MIN\n\n/*\n * Some APs experience problems when working with U-APSD. Decreasing the\n * probability of that happening by using legacy mode for all ACs but VO isn't\n * enough.\n *\n * Cisco 4410N originally forced us to enable VO by default only because it\n * treated non-VO ACs as legacy.\n *\n * However some APs (notably Netgear R7000) silently reclassify packets to\n * different ACs. Since u-APSD ACs require trigger frames for frame retrieval\n * clients would never see some frames (e.g. ARP responses) or would fetch them\n * accidentally after a long time.\n *\n * It makes little sense to enable u-APSD queues by default because it needs\n * userspace applications to be aware of it to actually take advantage of the\n * possible additional powersavings. Implicitly depending on driver autotrigger\n * frame support doesn't make much sense.\n */\n#define IEEE80211_DEFAULT_UAPSD_QUEUES 0\n\n#define IEEE80211_DEFAULT_MAX_SP_LEN\t\t\\\n\tIEEE80211_WMM_IE_STA_QOSINFO_SP_ALL\n\nextern const u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS];\n\n#define IEEE80211_DEAUTH_FRAME_LEN\t(24 /* hdr */ + 2 /* reason */)\n\n#define IEEE80211_MAX_NAN_INSTANCE_ID 255\n\nstruct ieee80211_fragment_entry {\n\tstruct sk_buff_head skb_list;\n\tunsigned long first_frag_time;\n\tu16 seq;\n\tu16 extra_len;\n\tu16 last_frag;\n\tu8 rx_queue;\n\tbool check_sequential_pn; /* needed for CCMP/GCMP */\n\tu8 last_pn[6]; /* PN of the last fragment if CCMP was used */\n};\n\n\nstruct ieee80211_bss {\n\tu32 device_ts_beacon, device_ts_presp;\n\n\tbool wmm_used;\n\tbool uapsd_supported;\n\n#define IEEE80211_MAX_SUPP_RATES 32\n\tu8 supp_rates[IEEE80211_MAX_SUPP_RATES];\n\tsize_t supp_rates_len;\n\tstruct ieee80211_rate *beacon_rate;\n\n\tu32 vht_cap_info;\n\n\t/*\n\t * During association, we save an ERP value from a probe response so\n\t * that we can feed ERP info to the driver when handling the\n\t * association completes. these fields probably won't be up-to-date\n\t * otherwise, you probably don't want to use them.\n\t */\n\tbool has_erp_value;\n\tu8 erp_value;\n\n\t/* Keep track of the corruption of the last beacon/probe response. */\n\tu8 corrupt_data;\n\n\t/* Keep track of what bits of information we have valid info for. */\n\tu8 valid_data;\n};\n\n/**\n * enum ieee80211_corrupt_data_flags - BSS data corruption flags\n * @IEEE80211_BSS_CORRUPT_BEACON: last beacon frame received was corrupted\n * @IEEE80211_BSS_CORRUPT_PROBE_RESP: last probe response received was corrupted\n *\n * These are bss flags that are attached to a bss in the\n * @corrupt_data field of &struct ieee80211_bss.\n */\nenum ieee80211_bss_corrupt_data_flags {\n\tIEEE80211_BSS_CORRUPT_BEACON\t\t= BIT(0),\n\tIEEE80211_BSS_CORRUPT_PROBE_RESP\t= BIT(1)\n};\n\n/**\n * enum ieee80211_valid_data_flags - BSS valid data flags\n * @IEEE80211_BSS_VALID_WMM: WMM/UAPSD data was gathered from non-corrupt IE\n * @IEEE80211_BSS_VALID_RATES: Supported rates were gathered from non-corrupt IE\n * @IEEE80211_BSS_VALID_ERP: ERP flag was gathered from non-corrupt IE\n *\n * These are bss flags that are attached to a bss in the\n * @valid_data field of &struct ieee80211_bss.  They show which parts\n * of the data structure were received as a result of an un-corrupted\n * beacon/probe response.\n */\nenum ieee80211_bss_valid_data_flags {\n\tIEEE80211_BSS_VALID_WMM\t\t\t= BIT(1),\n\tIEEE80211_BSS_VALID_RATES\t\t= BIT(2),\n\tIEEE80211_BSS_VALID_ERP\t\t\t= BIT(3)\n};\n\ntypedef unsigned __bitwise ieee80211_tx_result;\n#define TX_CONTINUE\t((__force ieee80211_tx_result) 0u)\n#define TX_DROP\t\t((__force ieee80211_tx_result) 1u)\n#define TX_QUEUED\t((__force ieee80211_tx_result) 2u)\n\n#define IEEE80211_TX_UNICAST\t\tBIT(1)\n#define IEEE80211_TX_PS_BUFFERED\tBIT(2)\n\nstruct ieee80211_tx_data {\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head skbs;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_rate rate;\n\n\tunsigned int flags;\n};\n\n\ntypedef unsigned __bitwise ieee80211_rx_result;\n#define RX_CONTINUE\t\t((__force ieee80211_rx_result) 0u)\n#define RX_DROP_UNUSABLE\t((__force ieee80211_rx_result) 1u)\n#define RX_DROP_MONITOR\t\t((__force ieee80211_rx_result) 2u)\n#define RX_QUEUED\t\t((__force ieee80211_rx_result) 3u)\n\n/**\n * enum ieee80211_packet_rx_flags - packet RX flags\n * @IEEE80211_RX_AMSDU: a-MSDU packet\n * @IEEE80211_RX_MALFORMED_ACTION_FRM: action frame is malformed\n * @IEEE80211_RX_DEFERRED_RELEASE: frame was subjected to receive reordering\n *\n * These are per-frame flags that are attached to a frame in the\n * @rx_flags field of &struct ieee80211_rx_status.\n */\nenum ieee80211_packet_rx_flags {\n\tIEEE80211_RX_AMSDU\t\t\t= BIT(3),\n\tIEEE80211_RX_MALFORMED_ACTION_FRM\t= BIT(4),\n\tIEEE80211_RX_DEFERRED_RELEASE\t\t= BIT(5),\n};\n\n/**\n * enum ieee80211_rx_flags - RX data flags\n *\n * @IEEE80211_RX_CMNTR: received on cooked monitor already\n * @IEEE80211_RX_BEACON_REPORTED: This frame was already reported\n *\tto cfg80211_report_obss_beacon().\n *\n * These flags are used across handling multiple interfaces\n * for a single frame.\n */\nenum ieee80211_rx_flags {\n\tIEEE80211_RX_CMNTR\t\t= BIT(0),\n\tIEEE80211_RX_BEACON_REPORTED\t= BIT(1),\n};\n\nstruct ieee80211_rx_data {\n\tstruct list_head *list;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_key *key;\n\n\tunsigned int flags;\n\n\t/*\n\t * Index into sequence numbers array, 0..16\n\t * since the last (16) is used for non-QoS,\n\t * will be 16 on non-QoS frames.\n\t */\n\tint seqno_idx;\n\n\t/*\n\t * Index into the security IV/PN arrays, 0..16\n\t * since the last (16) is used for CCMP-encrypted\n\t * management frames, will be set to 16 on mgmt\n\t * frames and 0 on non-QoS frames.\n\t */\n\tint security_idx;\n\n\tu32 tkip_iv32;\n\tu16 tkip_iv16;\n};\n\nstruct ieee80211_csa_settings {\n\tconst u16 *counter_offsets_beacon;\n\tconst u16 *counter_offsets_presp;\n\n\tint n_counter_offsets_beacon;\n\tint n_counter_offsets_presp;\n\n\tu8 count;\n};\n\nstruct beacon_data {\n\tu8 *head, *tail;\n\tint head_len, tail_len;\n\tstruct ieee80211_meshconf_ie *meshconf;\n\tu16 cntdwn_counter_offsets[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n\tu8 cntdwn_current_counter;\n\tstruct rcu_head rcu_head;\n};\n\nstruct probe_resp {\n\tstruct rcu_head rcu_head;\n\tint len;\n\tu16 cntdwn_counter_offsets[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n\tu8 data[];\n};\n\nstruct fils_discovery_data {\n\tstruct rcu_head rcu_head;\n\tint len;\n\tu8 data[];\n};\n\nstruct unsol_bcast_probe_resp_data {\n\tstruct rcu_head rcu_head;\n\tint len;\n\tu8 data[];\n};\n\nstruct ps_data {\n\t/* yes, this looks ugly, but guarantees that we can later use\n\t * bitmap_empty :)\n\t * NB: don't touch this bitmap, use sta_info_{set,clear}_tim_bit */\n\tu8 tim[sizeof(unsigned long) * BITS_TO_LONGS(IEEE80211_MAX_AID + 1)]\n\t\t\t__aligned(__alignof__(unsigned long));\n\tstruct sk_buff_head bc_buf;\n\tatomic_t num_sta_ps; /* number of stations in PS mode */\n\tint dtim_count;\n\tbool dtim_bc_mc;\n};\n\nstruct ieee80211_if_ap {\n\tstruct beacon_data __rcu *beacon;\n\tstruct probe_resp __rcu *probe_resp;\n\tstruct fils_discovery_data __rcu *fils_discovery;\n\tstruct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;\n\n\t/* to be used after channel switch. */\n\tstruct cfg80211_beacon_data *next_beacon;\n\tstruct list_head vlans; /* write-protected with RTNL and local->mtx */\n\n\tstruct ps_data ps;\n\tatomic_t num_mcast_sta; /* number of stations receiving multicast */\n\n\tbool multicast_to_unicast;\n};\n\nstruct ieee80211_if_vlan {\n\tstruct list_head list; /* write-protected with RTNL and local->mtx */\n\n\t/* used for all tx if the VLAN is configured to 4-addr mode */\n\tstruct sta_info __rcu *sta;\n\tatomic_t num_mcast_sta; /* number of stations receiving multicast */\n};\n\nstruct mesh_stats {\n\t__u32 fwded_mcast;\t\t/* Mesh forwarded multicast frames */\n\t__u32 fwded_unicast;\t\t/* Mesh forwarded unicast frames */\n\t__u32 fwded_frames;\t\t/* Mesh total forwarded frames */\n\t__u32 dropped_frames_ttl;\t/* Not transmitted since mesh_ttl == 0*/\n\t__u32 dropped_frames_no_route;\t/* Not transmitted, no route found */\n\t__u32 dropped_frames_congestion;/* Not forwarded due to congestion */\n};\n\n#define PREQ_Q_F_START\t\t0x1\n#define PREQ_Q_F_REFRESH\t0x2\nstruct mesh_preq_queue {\n\tstruct list_head list;\n\tu8 dst[ETH_ALEN];\n\tu8 flags;\n};\n\nstruct ieee80211_roc_work {\n\tstruct list_head list;\n\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tstruct ieee80211_channel *chan;\n\n\tbool started, abort, hw_begun, notified;\n\tbool on_channel;\n\n\tunsigned long start_time;\n\n\tu32 duration, req_duration;\n\tstruct sk_buff *frame;\n\tu64 cookie, mgmt_tx_cookie;\n\tenum ieee80211_roc_type type;\n};\n\n/* flags used in struct ieee80211_if_managed.flags */\nenum ieee80211_sta_flags {\n\tIEEE80211_STA_CONNECTION_POLL\t= BIT(1),\n\tIEEE80211_STA_CONTROL_PORT\t= BIT(2),\n\tIEEE80211_STA_DISABLE_HT\t= BIT(4),\n\tIEEE80211_STA_MFP_ENABLED\t= BIT(6),\n\tIEEE80211_STA_UAPSD_ENABLED\t= BIT(7),\n\tIEEE80211_STA_NULLFUNC_ACKED\t= BIT(8),\n\tIEEE80211_STA_RESET_SIGNAL_AVE\t= BIT(9),\n\tIEEE80211_STA_DISABLE_40MHZ\t= BIT(10),\n\tIEEE80211_STA_DISABLE_VHT\t= BIT(11),\n\tIEEE80211_STA_DISABLE_80P80MHZ\t= BIT(12),\n\tIEEE80211_STA_DISABLE_160MHZ\t= BIT(13),\n\tIEEE80211_STA_DISABLE_WMM\t= BIT(14),\n\tIEEE80211_STA_ENABLE_RRM\t= BIT(15),\n\tIEEE80211_STA_DISABLE_HE\t= BIT(16),\n};\n\nstruct ieee80211_mgd_auth_data {\n\tstruct cfg80211_bss *bss;\n\tunsigned long timeout;\n\tint tries;\n\tu16 algorithm, expected_transaction;\n\n\tu8 key[WLAN_KEY_LEN_WEP104];\n\tu8 key_len, key_idx;\n\tbool done;\n\tbool peer_confirmed;\n\tbool timeout_started;\n\n\tu16 sae_trans, sae_status;\n\tsize_t data_len;\n\tu8 data[];\n};\n\nstruct ieee80211_mgd_assoc_data {\n\tstruct cfg80211_bss *bss;\n\tconst u8 *supp_rates;\n\n\tunsigned long timeout;\n\tint tries;\n\n\tu16 capability;\n\tu8 prev_bssid[ETH_ALEN];\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len;\n\tu8 supp_rates_len;\n\tbool wmm, uapsd;\n\tbool need_beacon;\n\tbool synced;\n\tbool timeout_started;\n\n\tu8 ap_ht_param;\n\n\tstruct ieee80211_vht_cap ap_vht_cap;\n\n\tu8 fils_nonces[2 * FILS_NONCE_LEN];\n\tu8 fils_kek[FILS_MAX_KEK_LEN];\n\tsize_t fils_kek_len;\n\n\tsize_t ie_len;\n\tu8 ie[];\n};\n\nstruct ieee80211_sta_tx_tspec {\n\t/* timestamp of the first packet in the time slice */\n\tunsigned long time_slice_start;\n\n\tu32 admitted_time; /* in usecs, unlike over the air */\n\tu8 tsid;\n\ts8 up; /* signed to be able to invalidate with -1 during teardown */\n\n\t/* consumed TX time in microseconds in the time slice */\n\tu32 consumed_tx_time;\n\tenum {\n\t\tTX_TSPEC_ACTION_NONE = 0,\n\t\tTX_TSPEC_ACTION_DOWNGRADE,\n\t\tTX_TSPEC_ACTION_STOP_DOWNGRADE,\n\t} action;\n\tbool downgraded;\n};\n\nDECLARE_EWMA(beacon_signal, 4, 4)\n\nstruct ieee80211_if_managed {\n\tstruct timer_list timer;\n\tstruct timer_list conn_mon_timer;\n\tstruct timer_list bcn_mon_timer;\n\tstruct timer_list chswitch_timer;\n\tstruct work_struct monitor_work;\n\tstruct work_struct chswitch_work;\n\tstruct work_struct beacon_connection_loss_work;\n\tstruct work_struct csa_connection_drop_work;\n\n\tunsigned long beacon_timeout;\n\tunsigned long probe_timeout;\n\tint probe_send_count;\n\tbool nullfunc_failed;\n\tu8 connection_loss:1,\n\t   driver_disconnect:1,\n\t   reconnect:1;\n\n\tstruct cfg80211_bss *associated;\n\tstruct ieee80211_mgd_auth_data *auth_data;\n\tstruct ieee80211_mgd_assoc_data *assoc_data;\n\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\n\tbool powersave; /* powersave requested for this iface */\n\tbool broken_ap; /* AP is broken -- turn off powersave */\n\tbool have_beacon;\n\tu8 dtim_period;\n\tenum ieee80211_smps_mode req_smps, /* requested smps mode */\n\t\t\t\t driver_smps_mode; /* smps mode request */\n\n\tstruct work_struct request_smps_work;\n\n\tunsigned int flags;\n\n\tbool csa_waiting_bcn;\n\tbool csa_ignored_same_chan;\n\n\tbool beacon_crc_valid;\n\tu32 beacon_crc;\n\n\tbool status_acked;\n\tbool status_received;\n\t__le16 status_fc;\n\n\tenum {\n\t\tIEEE80211_MFP_DISABLED,\n\t\tIEEE80211_MFP_OPTIONAL,\n\t\tIEEE80211_MFP_REQUIRED\n\t} mfp; /* management frame protection */\n\n\t/*\n\t * Bitmask of enabled u-apsd queues,\n\t * IEEE80211_WMM_IE_STA_QOSINFO_AC_BE & co. Needs a new association\n\t * to take effect.\n\t */\n\tunsigned int uapsd_queues;\n\n\t/*\n\t * Maximum number of buffered frames AP can deliver during a\n\t * service period, IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL or similar.\n\t * Needs a new association to take effect.\n\t */\n\tunsigned int uapsd_max_sp_len;\n\n\tint wmm_last_param_set;\n\tint mu_edca_last_param_set;\n\n\tu8 use_4addr;\n\n\ts16 p2p_noa_index;\n\n\tstruct ewma_beacon_signal ave_beacon_signal;\n\n\t/*\n\t * Number of Beacon frames used in ave_beacon_signal. This can be used\n\t * to avoid generating less reliable cqm events that would be based\n\t * only on couple of received frames.\n\t */\n\tunsigned int count_beacon_signal;\n\n\t/* Number of times beacon loss was invoked. */\n\tunsigned int beacon_loss_count;\n\n\t/*\n\t * Last Beacon frame signal strength average (ave_beacon_signal / 16)\n\t * that triggered a cqm event. 0 indicates that no event has been\n\t * generated for the current association.\n\t */\n\tint last_cqm_event_signal;\n\n\t/*\n\t * State variables for keeping track of RSSI of the AP currently\n\t * connected to and informing driver when RSSI has gone\n\t * below/above a certain threshold.\n\t */\n\tint rssi_min_thold, rssi_max_thold;\n\tint last_ave_beacon_signal;\n\n\tstruct ieee80211_ht_cap ht_capa; /* configured ht-cap over-rides */\n\tstruct ieee80211_ht_cap ht_capa_mask; /* Valid parts of ht_capa */\n\tstruct ieee80211_vht_cap vht_capa; /* configured VHT overrides */\n\tstruct ieee80211_vht_cap vht_capa_mask; /* Valid parts of vht_capa */\n\tstruct ieee80211_s1g_cap s1g_capa; /* configured S1G overrides */\n\tstruct ieee80211_s1g_cap s1g_capa_mask; /* valid s1g_capa bits */\n\n\t/* TDLS support */\n\tu8 tdls_peer[ETH_ALEN] __aligned(2);\n\tstruct delayed_work tdls_peer_del_work;\n\tstruct sk_buff *orig_teardown_skb; /* The original teardown skb */\n\tstruct sk_buff *teardown_skb; /* A copy to send through the AP */\n\tspinlock_t teardown_lock; /* To lock changing teardown_skb */\n\tbool tdls_chan_switch_prohibited;\n\tbool tdls_wider_bw_prohibited;\n\n\t/* WMM-AC TSPEC support */\n\tstruct ieee80211_sta_tx_tspec tx_tspec[IEEE80211_NUM_ACS];\n\t/* Use a separate work struct so that we can do something here\n\t * while the sdata->work is flushing the queues, for example.\n\t * otherwise, in scenarios where we hardly get any traffic out\n\t * on the BE queue, but there's a lot of VO traffic, we might\n\t * get stuck in a downgraded situation and flush takes forever.\n\t */\n\tstruct delayed_work tx_tspec_wk;\n\n\t/* Information elements from the last transmitted (Re)Association\n\t * Request frame.\n\t */\n\tu8 *assoc_req_ies;\n\tsize_t assoc_req_ies_len;\n};\n\nstruct ieee80211_if_ibss {\n\tstruct timer_list timer;\n\tstruct work_struct csa_connection_drop_work;\n\n\tunsigned long last_scan_completed;\n\n\tu32 basic_rates;\n\n\tbool fixed_bssid;\n\tbool fixed_channel;\n\tbool privacy;\n\n\tbool control_port;\n\tbool userspace_handles_dfs;\n\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len, ie_len;\n\tu8 *ie;\n\tstruct cfg80211_chan_def chandef;\n\n\tunsigned long ibss_join_req;\n\t/* probe response/beacon for IBSS */\n\tstruct beacon_data __rcu *presp;\n\n\tstruct ieee80211_ht_cap ht_capa; /* configured ht-cap over-rides */\n\tstruct ieee80211_ht_cap ht_capa_mask; /* Valid parts of ht_capa */\n\n\tspinlock_t incomplete_lock;\n\tstruct list_head incomplete_stations;\n\n\tenum {\n\t\tIEEE80211_IBSS_MLME_SEARCH,\n\t\tIEEE80211_IBSS_MLME_JOINED,\n\t} state;\n};\n\n/**\n * struct ieee80211_if_ocb - OCB mode state\n *\n * @housekeeping_timer: timer for periodic invocation of a housekeeping task\n * @wrkq_flags: OCB deferred task action\n * @incomplete_lock: delayed STA insertion lock\n * @incomplete_stations: list of STAs waiting for delayed insertion\n * @joined: indication if the interface is connected to an OCB network\n */\nstruct ieee80211_if_ocb {\n\tstruct timer_list housekeeping_timer;\n\tunsigned long wrkq_flags;\n\n\tspinlock_t incomplete_lock;\n\tstruct list_head incomplete_stations;\n\n\tbool joined;\n};\n\n/**\n * struct ieee80211_mesh_sync_ops - Extensible synchronization framework interface\n *\n * these declarations define the interface, which enables\n * vendor-specific mesh synchronization\n *\n */\nstruct ieee802_11_elems;\nstruct ieee80211_mesh_sync_ops {\n\tvoid (*rx_bcn_presp)(struct ieee80211_sub_if_data *sdata,\n\t\t\t     u16 stype,\n\t\t\t     struct ieee80211_mgmt *mgmt,\n\t\t\t     struct ieee802_11_elems *elems,\n\t\t\t     struct ieee80211_rx_status *rx_status);\n\n\t/* should be called with beacon_data under RCU read lock */\n\tvoid (*adjust_tsf)(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct beacon_data *beacon);\n\t/* add other framework functions here */\n};\n\nstruct mesh_csa_settings {\n\tstruct rcu_head rcu_head;\n\tstruct cfg80211_csa_settings settings;\n};\n\nstruct ieee80211_if_mesh {\n\tstruct timer_list housekeeping_timer;\n\tstruct timer_list mesh_path_timer;\n\tstruct timer_list mesh_path_root_timer;\n\n\tunsigned long wrkq_flags;\n\tunsigned long mbss_changed;\n\n\tbool userspace_handles_dfs;\n\n\tu8 mesh_id[IEEE80211_MAX_MESH_ID_LEN];\n\tsize_t mesh_id_len;\n\t/* Active Path Selection Protocol Identifier */\n\tu8 mesh_pp_id;\n\t/* Active Path Selection Metric Identifier */\n\tu8 mesh_pm_id;\n\t/* Congestion Control Mode Identifier */\n\tu8 mesh_cc_id;\n\t/* Synchronization Protocol Identifier */\n\tu8 mesh_sp_id;\n\t/* Authentication Protocol Identifier */\n\tu8 mesh_auth_id;\n\t/* Local mesh Sequence Number */\n\tu32 sn;\n\t/* Last used PREQ ID */\n\tu32 preq_id;\n\tatomic_t mpaths;\n\t/* Timestamp of last SN update */\n\tunsigned long last_sn_update;\n\t/* Time when it's ok to send next PERR */\n\tunsigned long next_perr;\n\t/* Timestamp of last PREQ sent */\n\tunsigned long last_preq;\n\tstruct mesh_rmc *rmc;\n\tspinlock_t mesh_preq_queue_lock;\n\tstruct mesh_preq_queue preq_queue;\n\tint preq_queue_len;\n\tstruct mesh_stats mshstats;\n\tstruct mesh_config mshcfg;\n\tatomic_t estab_plinks;\n\tu32 mesh_seqnum;\n\tbool accepting_plinks;\n\tint num_gates;\n\tstruct beacon_data __rcu *beacon;\n\tconst u8 *ie;\n\tu8 ie_len;\n\tenum {\n\t\tIEEE80211_MESH_SEC_NONE = 0x0,\n\t\tIEEE80211_MESH_SEC_AUTHED = 0x1,\n\t\tIEEE80211_MESH_SEC_SECURED = 0x2,\n\t} security;\n\tbool user_mpm;\n\t/* Extensible Synchronization Framework */\n\tconst struct ieee80211_mesh_sync_ops *sync_ops;\n\ts64 sync_offset_clockdrift_max;\n\tspinlock_t sync_offset_lock;\n\t/* mesh power save */\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n\tint ps_peers_light_sleep;\n\tint ps_peers_deep_sleep;\n\tstruct ps_data ps;\n\t/* Channel Switching Support */\n\tstruct mesh_csa_settings __rcu *csa;\n\tenum {\n\t\tIEEE80211_MESH_CSA_ROLE_NONE,\n\t\tIEEE80211_MESH_CSA_ROLE_INIT,\n\t\tIEEE80211_MESH_CSA_ROLE_REPEATER,\n\t} csa_role;\n\tu8 chsw_ttl;\n\tu16 pre_value;\n\n\t/* offset from skb->data while building IE */\n\tint meshconf_offset;\n\n\tstruct mesh_table *mesh_paths;\n\tstruct mesh_table *mpp_paths; /* Store paths for MPP&MAP */\n\tint mesh_paths_generation;\n\tint mpp_paths_generation;\n};\n\n#ifdef CONFIG_MAC80211_MESH\n#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name)\t\\\n\tdo { (msh)->mshstats.name++; } while (0)\n#else\n#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name) \\\n\tdo { } while (0)\n#endif\n\n/**\n * enum ieee80211_sub_if_data_flags - virtual interface flags\n *\n * @IEEE80211_SDATA_ALLMULTI: interface wants all multicast packets\n * @IEEE80211_SDATA_OPERATING_GMODE: operating in G-only mode\n * @IEEE80211_SDATA_DONT_BRIDGE_PACKETS: bridge packets between\n *\tassociated stations and deliver multicast frames both\n *\tback to wireless media and to the local net stack.\n * @IEEE80211_SDATA_DISCONNECT_RESUME: Disconnect after resume.\n * @IEEE80211_SDATA_IN_DRIVER: indicates interface was added to driver\n */\nenum ieee80211_sub_if_data_flags {\n\tIEEE80211_SDATA_ALLMULTI\t\t= BIT(0),\n\tIEEE80211_SDATA_OPERATING_GMODE\t\t= BIT(2),\n\tIEEE80211_SDATA_DONT_BRIDGE_PACKETS\t= BIT(3),\n\tIEEE80211_SDATA_DISCONNECT_RESUME\t= BIT(4),\n\tIEEE80211_SDATA_IN_DRIVER\t\t= BIT(5),\n};\n\n/**\n * enum ieee80211_sdata_state_bits - virtual interface state bits\n * @SDATA_STATE_RUNNING: virtual interface is up & running; this\n *\tmirrors netif_running() but is separate for interface type\n *\tchange handling while the interface is up\n * @SDATA_STATE_OFFCHANNEL: This interface is currently in offchannel\n *\tmode, so queues are stopped\n * @SDATA_STATE_OFFCHANNEL_BEACON_STOPPED: Beaconing was stopped due\n *\tto offchannel, reset when offchannel returns\n */\nenum ieee80211_sdata_state_bits {\n\tSDATA_STATE_RUNNING,\n\tSDATA_STATE_OFFCHANNEL,\n\tSDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\n};\n\n/**\n * enum ieee80211_chanctx_mode - channel context configuration mode\n *\n * @IEEE80211_CHANCTX_SHARED: channel context may be used by\n *\tmultiple interfaces\n * @IEEE80211_CHANCTX_EXCLUSIVE: channel context can be used\n *\tonly by a single interface. This can be used for example for\n *\tnon-fixed channel IBSS.\n */\nenum ieee80211_chanctx_mode {\n\tIEEE80211_CHANCTX_SHARED,\n\tIEEE80211_CHANCTX_EXCLUSIVE\n};\n\n/**\n * enum ieee80211_chanctx_replace_state - channel context replacement state\n *\n * This is used for channel context in-place reservations that require channel\n * context switch/swap.\n *\n * @IEEE80211_CHANCTX_REPLACE_NONE: no replacement is taking place\n * @IEEE80211_CHANCTX_WILL_BE_REPLACED: this channel context will be replaced\n *\tby a (not yet registered) channel context pointed by %replace_ctx.\n * @IEEE80211_CHANCTX_REPLACES_OTHER: this (not yet registered) channel context\n *\treplaces an existing channel context pointed to by %replace_ctx.\n */\nenum ieee80211_chanctx_replace_state {\n\tIEEE80211_CHANCTX_REPLACE_NONE,\n\tIEEE80211_CHANCTX_WILL_BE_REPLACED,\n\tIEEE80211_CHANCTX_REPLACES_OTHER,\n};\n\nstruct ieee80211_chanctx {\n\tstruct list_head list;\n\tstruct rcu_head rcu_head;\n\n\tstruct list_head assigned_vifs;\n\tstruct list_head reserved_vifs;\n\n\tenum ieee80211_chanctx_replace_state replace_state;\n\tstruct ieee80211_chanctx *replace_ctx;\n\n\tenum ieee80211_chanctx_mode mode;\n\tbool driver_present;\n\n\tstruct ieee80211_chanctx_conf conf;\n};\n\nstruct mac80211_qos_map {\n\tstruct cfg80211_qos_map qos_map;\n\tstruct rcu_head rcu_head;\n};\n\nenum txq_info_flags {\n\tIEEE80211_TXQ_STOP,\n\tIEEE80211_TXQ_AMPDU,\n\tIEEE80211_TXQ_NO_AMSDU,\n\tIEEE80211_TXQ_STOP_NETIF_TX,\n};\n\n/**\n * struct txq_info - per tid queue\n *\n * @tin: contains packets split into multiple flows\n * @def_flow: used as a fallback flow when a packet destined to @tin hashes to\n *\ta fq_flow which is already owned by a different tin\n * @def_cvars: codel vars for @def_flow\n * @frags: used to keep fragments created after dequeue\n * @schedule_order: used with ieee80211_local->active_txqs\n * @schedule_round: counter to prevent infinite loops on TXQ scheduling\n */\nstruct txq_info {\n\tstruct fq_tin tin;\n\tstruct codel_vars def_cvars;\n\tstruct codel_stats cstats;\n\tstruct sk_buff_head frags;\n\tstruct list_head schedule_order;\n\tu16 schedule_round;\n\tunsigned long flags;\n\n\t/* keep last! */\n\tstruct ieee80211_txq txq;\n};\n\nstruct ieee80211_if_mntr {\n\tu32 flags;\n\tu8 mu_follow_addr[ETH_ALEN] __aligned(2);\n\n\tstruct list_head list;\n};\n\n/**\n * struct ieee80211_if_nan - NAN state\n *\n * @conf: current NAN configuration\n * @func_ids: a bitmap of available instance_id's\n */\nstruct ieee80211_if_nan {\n\tstruct cfg80211_nan_conf conf;\n\n\t/* protects function_inst_ids */\n\tspinlock_t func_lock;\n\tstruct idr function_inst_ids;\n};\n\nstruct ieee80211_sub_if_data {\n\tstruct list_head list;\n\n\tstruct wireless_dev wdev;\n\n\t/* keys */\n\tstruct list_head key_list;\n\n\t/* count for keys needing tailroom space allocation */\n\tint crypto_tx_tailroom_needed_cnt;\n\tint crypto_tx_tailroom_pending_dec;\n\tstruct delayed_work dec_tailroom_needed_wk;\n\n\tstruct net_device *dev;\n\tstruct ieee80211_local *local;\n\n\tunsigned int flags;\n\n\tunsigned long state;\n\n\tchar name[IFNAMSIZ];\n\n\t/* Fragment table for host-based reassembly */\n\tstruct ieee80211_fragment_entry\tfragments[IEEE80211_FRAGMENT_MAX];\n\tunsigned int fragment_next;\n\n\t/* TID bitmap for NoAck policy */\n\tu16 noack_map;\n\n\t/* bit field of ACM bits (BIT(802.1D tag)) */\n\tu8 wmm_acm;\n\n\tstruct ieee80211_key __rcu *keys[NUM_DEFAULT_KEYS +\n\t\t\t\t\t NUM_DEFAULT_MGMT_KEYS +\n\t\t\t\t\t NUM_DEFAULT_BEACON_KEYS];\n\tstruct ieee80211_key __rcu *default_unicast_key;\n\tstruct ieee80211_key __rcu *default_multicast_key;\n\tstruct ieee80211_key __rcu *default_mgmt_key;\n\tstruct ieee80211_key __rcu *default_beacon_key;\n\n\tu16 sequence_number;\n\t__be16 control_port_protocol;\n\tbool control_port_no_encrypt;\n\tbool control_port_no_preauth;\n\tbool control_port_over_nl80211;\n\tint encrypt_headroom;\n\n\tatomic_t num_tx_queued;\n\tstruct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];\n\tstruct mac80211_qos_map __rcu *qos_map;\n\n\tstruct work_struct csa_finalize_work;\n\tbool csa_block_tx; /* write-protected by sdata_lock and local->mtx */\n\tstruct cfg80211_chan_def csa_chandef;\n\n\tstruct list_head assigned_chanctx_list; /* protected by chanctx_mtx */\n\tstruct list_head reserved_chanctx_list; /* protected by chanctx_mtx */\n\n\t/* context reservation -- protected with chanctx_mtx */\n\tstruct ieee80211_chanctx *reserved_chanctx;\n\tstruct cfg80211_chan_def reserved_chandef;\n\tbool reserved_radar_required;\n\tbool reserved_ready;\n\n\t/* used to reconfigure hardware SM PS */\n\tstruct work_struct recalc_smps;\n\n\tstruct work_struct work;\n\tstruct sk_buff_head skb_queue;\n\n\tu8 needed_rx_chains;\n\tenum ieee80211_smps_mode smps_mode;\n\n\tint user_power_level; /* in dBm */\n\tint ap_power_level; /* in dBm */\n\n\tbool radar_required;\n\tstruct delayed_work dfs_cac_timer_work;\n\n\t/*\n\t * AP this belongs to: self in AP mode and\n\t * corresponding AP in VLAN mode, NULL for\n\t * all others (might be needed later in IBSS)\n\t */\n\tstruct ieee80211_if_ap *bss;\n\n\t/* bitmap of allowed (non-MCS) rate indexes for rate control */\n\tu32 rc_rateidx_mask[NUM_NL80211_BANDS];\n\n\tbool rc_has_mcs_mask[NUM_NL80211_BANDS];\n\tu8  rc_rateidx_mcs_mask[NUM_NL80211_BANDS][IEEE80211_HT_MCS_MASK_LEN];\n\n\tbool rc_has_vht_mcs_mask[NUM_NL80211_BANDS];\n\tu16 rc_rateidx_vht_mcs_mask[NUM_NL80211_BANDS][NL80211_VHT_NSS_MAX];\n\n\t/* Beacon frame (non-MCS) rate (as a bitmap) */\n\tu32 beacon_rateidx_mask[NUM_NL80211_BANDS];\n\tbool beacon_rate_set;\n\n\tunion {\n\t\tstruct ieee80211_if_ap ap;\n\t\tstruct ieee80211_if_vlan vlan;\n\t\tstruct ieee80211_if_managed mgd;\n\t\tstruct ieee80211_if_ibss ibss;\n\t\tstruct ieee80211_if_mesh mesh;\n\t\tstruct ieee80211_if_ocb ocb;\n\t\tstruct ieee80211_if_mntr mntr;\n\t\tstruct ieee80211_if_nan nan;\n\t} u;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct {\n\t\tstruct dentry *subdir_stations;\n\t\tstruct dentry *default_unicast_key;\n\t\tstruct dentry *default_multicast_key;\n\t\tstruct dentry *default_mgmt_key;\n\t\tstruct dentry *default_beacon_key;\n\t} debugfs;\n#endif\n\n\t/* must be last, dynamically sized area in this! */\n\tstruct ieee80211_vif vif;\n};\n\nstatic inline\nstruct ieee80211_sub_if_data *vif_to_sdata(struct ieee80211_vif *p)\n{\n\treturn container_of(p, struct ieee80211_sub_if_data, vif);\n}\n\nstatic inline void sdata_lock(struct ieee80211_sub_if_data *sdata)\n\t__acquires(&sdata->wdev.mtx)\n{\n\tmutex_lock(&sdata->wdev.mtx);\n\t__acquire(&sdata->wdev.mtx);\n}\n\nstatic inline void sdata_unlock(struct ieee80211_sub_if_data *sdata)\n\t__releases(&sdata->wdev.mtx)\n{\n\tmutex_unlock(&sdata->wdev.mtx);\n\t__release(&sdata->wdev.mtx);\n}\n\n#define sdata_dereference(p, sdata) \\\n\trcu_dereference_protected(p, lockdep_is_held(&sdata->wdev.mtx))\n\nstatic inline void\nsdata_assert_lock(struct ieee80211_sub_if_data *sdata)\n{\n\tlockdep_assert_held(&sdata->wdev.mtx);\n}\n\nstatic inline int\nieee80211_chandef_get_shift(struct cfg80211_chan_def *chandef)\n{\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn 2;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int\nieee80211_vif_get_shift(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint shift = 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(vif->chanctx_conf);\n\tif (chanctx_conf)\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\treturn shift;\n}\n\nenum {\n\tIEEE80211_RX_MSG\t= 1,\n\tIEEE80211_TX_STATUS_MSG\t= 2,\n};\n\nenum queue_stop_reason {\n\tIEEE80211_QUEUE_STOP_REASON_DRIVER,\n\tIEEE80211_QUEUE_STOP_REASON_PS,\n\tIEEE80211_QUEUE_STOP_REASON_CSA,\n\tIEEE80211_QUEUE_STOP_REASON_AGGREGATION,\n\tIEEE80211_QUEUE_STOP_REASON_SUSPEND,\n\tIEEE80211_QUEUE_STOP_REASON_SKB_ADD,\n\tIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\n\tIEEE80211_QUEUE_STOP_REASON_FLUSH,\n\tIEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN,\n\tIEEE80211_QUEUE_STOP_REASON_RESERVE_TID,\n\tIEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE,\n\n\tIEEE80211_QUEUE_STOP_REASONS,\n};\n\n#ifdef CONFIG_MAC80211_LEDS\nstruct tpt_led_trigger {\n\tchar name[32];\n\tconst struct ieee80211_tpt_blink *blink_table;\n\tunsigned int blink_table_len;\n\tstruct timer_list timer;\n\tstruct ieee80211_local *local;\n\tunsigned long prev_traffic;\n\tunsigned long tx_bytes, rx_bytes;\n\tunsigned int active, want;\n\tbool running;\n};\n#endif\n\n/**\n * mac80211 scan flags - currently active scan mode\n *\n * @SCAN_SW_SCANNING: We're currently in the process of scanning but may as\n *\twell be on the operating channel\n * @SCAN_HW_SCANNING: The hardware is scanning for us, we have no way to\n *\tdetermine if we are on the operating channel or not\n * @SCAN_ONCHANNEL_SCANNING:  Do a software scan on only the current operating\n *\tchannel. This should not interrupt normal traffic.\n * @SCAN_COMPLETED: Set for our scan work function when the driver reported\n *\tthat the scan completed.\n * @SCAN_ABORTED: Set for our scan work function when the driver reported\n *\ta scan complete for an aborted scan.\n * @SCAN_HW_CANCELLED: Set for our scan work function when the scan is being\n *\tcancelled.\n */\nenum {\n\tSCAN_SW_SCANNING,\n\tSCAN_HW_SCANNING,\n\tSCAN_ONCHANNEL_SCANNING,\n\tSCAN_COMPLETED,\n\tSCAN_ABORTED,\n\tSCAN_HW_CANCELLED,\n};\n\n/**\n * enum mac80211_scan_state - scan state machine states\n *\n * @SCAN_DECISION: Main entry point to the scan state machine, this state\n *\tdetermines if we should keep on scanning or switch back to the\n *\toperating channel\n * @SCAN_SET_CHANNEL: Set the next channel to be scanned\n * @SCAN_SEND_PROBE: Send probe requests and wait for probe responses\n * @SCAN_SUSPEND: Suspend the scan and go back to operating channel to\n *\tsend out data\n * @SCAN_RESUME: Resume the scan and scan the next channel\n * @SCAN_ABORT: Abort the scan and go back to operating channel\n */\nenum mac80211_scan_state {\n\tSCAN_DECISION,\n\tSCAN_SET_CHANNEL,\n\tSCAN_SEND_PROBE,\n\tSCAN_SUSPEND,\n\tSCAN_RESUME,\n\tSCAN_ABORT,\n};\n\nDECLARE_STATIC_KEY_FALSE(aql_disable);\n\nstruct ieee80211_local {\n\t/* embed the driver visible part.\n\t * don't cast (use the static inlines below), but we keep\n\t * it first anyway so they become a no-op */\n\tstruct ieee80211_hw hw;\n\n\tstruct fq fq;\n\tstruct codel_vars *cvars;\n\tstruct codel_params cparams;\n\n\t/* protects active_txqs and txqi->schedule_order */\n\tspinlock_t active_txq_lock[IEEE80211_NUM_ACS];\n\tstruct list_head active_txqs[IEEE80211_NUM_ACS];\n\tu16 schedule_round[IEEE80211_NUM_ACS];\n\n\tu16 airtime_flags;\n\tu32 aql_txq_limit_low[IEEE80211_NUM_ACS];\n\tu32 aql_txq_limit_high[IEEE80211_NUM_ACS];\n\tu32 aql_threshold;\n\tatomic_t aql_total_pending_airtime;\n\n\tconst struct ieee80211_ops *ops;\n\n\t/*\n\t * private workqueue to mac80211. mac80211 makes this accessible\n\t * via ieee80211_queue_work()\n\t */\n\tstruct workqueue_struct *workqueue;\n\n\tunsigned long queue_stop_reasons[IEEE80211_MAX_QUEUES];\n\tint q_stop_reasons[IEEE80211_MAX_QUEUES][IEEE80211_QUEUE_STOP_REASONS];\n\t/* also used to protect ampdu_ac_queue and amdpu_ac_stop_refcnt */\n\tspinlock_t queue_stop_reason_lock;\n\n\tint open_count;\n\tint monitors, cooked_mntrs;\n\t/* number of interfaces with corresponding FIF_ flags */\n\tint fif_fcsfail, fif_plcpfail, fif_control, fif_other_bss, fif_pspoll,\n\t    fif_probe_req;\n\tbool probe_req_reg;\n\tbool rx_mcast_action_reg;\n\tunsigned int filter_flags; /* FIF_* */\n\n\tbool wiphy_ciphers_allocated;\n\n\tbool use_chanctx;\n\n\t/* protects the aggregated multicast list and filter calls */\n\tspinlock_t filter_lock;\n\n\t/* used for uploading changed mc list */\n\tstruct work_struct reconfig_filter;\n\n\t/* aggregated multicast list */\n\tstruct netdev_hw_addr_list mc_list;\n\n\tbool tim_in_locked_section; /* see ieee80211_beacon_get() */\n\n\t/*\n\t * suspended is true if we finished all the suspend _and_ we have\n\t * not yet come up from resume. This is to be used by mac80211\n\t * to ensure driver sanity during suspend and mac80211's own\n\t * sanity. It can eventually be used for WoW as well.\n\t */\n\tbool suspended;\n\n\t/*\n\t * Resuming is true while suspended, but when we're reprogramming the\n\t * hardware -- at that time it's allowed to use ieee80211_queue_work()\n\t * again even though some other parts of the stack are still suspended\n\t * and we still drop received frames to avoid waking the stack.\n\t */\n\tbool resuming;\n\n\t/*\n\t * quiescing is true during the suspend process _only_ to\n\t * ease timer cancelling etc.\n\t */\n\tbool quiescing;\n\n\t/* device is started */\n\tbool started;\n\n\t/* device is during a HW reconfig */\n\tbool in_reconfig;\n\n\t/* wowlan is enabled -- don't reconfig on resume */\n\tbool wowlan;\n\n\tstruct work_struct radar_detected_work;\n\n\t/* number of RX chains the hardware has */\n\tu8 rx_chains;\n\n\t/* bitmap of which sbands were copied */\n\tu8 sband_allocated;\n\n\tint tx_headroom; /* required headroom for hardware/radiotap */\n\n\t/* Tasklet and skb queue to process calls from IRQ mode. All frames\n\t * added to skb_queue will be processed, but frames in\n\t * skb_queue_unreliable may be dropped if the total length of these\n\t * queues increases over the limit. */\n#define IEEE80211_IRQSAFE_QUEUE_LIMIT 128\n\tstruct tasklet_struct tasklet;\n\tstruct sk_buff_head skb_queue;\n\tstruct sk_buff_head skb_queue_unreliable;\n\n\tspinlock_t rx_path_lock;\n\n\t/* Station data */\n\t/*\n\t * The mutex only protects the list, hash table and\n\t * counter, reads are done with RCU.\n\t */\n\tstruct mutex sta_mtx;\n\tspinlock_t tim_lock;\n\tunsigned long num_sta;\n\tstruct list_head sta_list;\n\tstruct rhltable sta_hash;\n\tstruct timer_list sta_cleanup;\n\tint sta_generation;\n\n\tstruct sk_buff_head pending[IEEE80211_MAX_QUEUES];\n\tstruct tasklet_struct tx_pending_tasklet;\n\tstruct tasklet_struct wake_txqs_tasklet;\n\n\tatomic_t agg_queue_stop[IEEE80211_MAX_QUEUES];\n\n\t/* number of interfaces with allmulti RX */\n\tatomic_t iff_allmultis;\n\n\tstruct rate_control_ref *rate_ctrl;\n\n\tstruct arc4_ctx wep_tx_ctx;\n\tstruct arc4_ctx wep_rx_ctx;\n\tu32 wep_iv;\n\n\t/* see iface.c */\n\tstruct list_head interfaces;\n\tstruct list_head mon_list; /* only that are IFF_UP && !cooked */\n\tstruct mutex iflist_mtx;\n\n\t/*\n\t * Key mutex, protects sdata's key_list and sta_info's\n\t * key pointers and ptk_idx (write access, they're RCU.)\n\t */\n\tstruct mutex key_mtx;\n\n\t/* mutex for scan and work locking */\n\tstruct mutex mtx;\n\n\t/* Scanning and BSS list */\n\tunsigned long scanning;\n\tstruct cfg80211_ssid scan_ssid;\n\tstruct cfg80211_scan_request *int_scan_req;\n\tstruct cfg80211_scan_request __rcu *scan_req;\n\tstruct ieee80211_scan_request *hw_scan_req;\n\tstruct cfg80211_chan_def scan_chandef;\n\tenum nl80211_band hw_scan_band;\n\tint scan_channel_idx;\n\tint scan_ies_len;\n\tint hw_scan_ies_bufsize;\n\tstruct cfg80211_scan_info scan_info;\n\n\tstruct work_struct sched_scan_stopped_work;\n\tstruct ieee80211_sub_if_data __rcu *sched_scan_sdata;\n\tstruct cfg80211_sched_scan_request __rcu *sched_scan_req;\n\tu8 scan_addr[ETH_ALEN];\n\n\tunsigned long leave_oper_channel_time;\n\tenum mac80211_scan_state next_scan_state;\n\tstruct delayed_work scan_work;\n\tstruct ieee80211_sub_if_data __rcu *scan_sdata;\n\t/* For backward compatibility only -- do not use */\n\tstruct cfg80211_chan_def _oper_chandef;\n\n\t/* Temporary remain-on-channel for off-channel operations */\n\tstruct ieee80211_channel *tmp_channel;\n\n\t/* channel contexts */\n\tstruct list_head chanctx_list;\n\tstruct mutex chanctx_mtx;\n\n#ifdef CONFIG_MAC80211_LEDS\n\tstruct led_trigger tx_led, rx_led, assoc_led, radio_led;\n\tstruct led_trigger tpt_led;\n\tatomic_t tx_led_active, rx_led_active, assoc_led_active;\n\tatomic_t radio_led_active, tpt_led_active;\n\tstruct tpt_led_trigger *tpt_led_trigger;\n#endif\n\n#ifdef CONFIG_MAC80211_DEBUG_COUNTERS\n\t/* SNMP counters */\n\t/* dot11CountersTable */\n\tu32 dot11TransmittedFragmentCount;\n\tu32 dot11MulticastTransmittedFrameCount;\n\tu32 dot11FailedCount;\n\tu32 dot11RetryCount;\n\tu32 dot11MultipleRetryCount;\n\tu32 dot11FrameDuplicateCount;\n\tu32 dot11ReceivedFragmentCount;\n\tu32 dot11MulticastReceivedFrameCount;\n\tu32 dot11TransmittedFrameCount;\n\n\t/* TX/RX handler statistics */\n\tunsigned int tx_handlers_drop;\n\tunsigned int tx_handlers_queued;\n\tunsigned int tx_handlers_drop_wep;\n\tunsigned int tx_handlers_drop_not_assoc;\n\tunsigned int tx_handlers_drop_unauth_port;\n\tunsigned int rx_handlers_drop;\n\tunsigned int rx_handlers_queued;\n\tunsigned int rx_handlers_drop_nullfunc;\n\tunsigned int rx_handlers_drop_defrag;\n\tunsigned int tx_expand_skb_head;\n\tunsigned int tx_expand_skb_head_cloned;\n\tunsigned int rx_expand_skb_head_defrag;\n\tunsigned int rx_handlers_fragments;\n\tunsigned int tx_status_drop;\n#define I802_DEBUG_INC(c) (c)++\n#else /* CONFIG_MAC80211_DEBUG_COUNTERS */\n#define I802_DEBUG_INC(c) do { } while (0)\n#endif /* CONFIG_MAC80211_DEBUG_COUNTERS */\n\n\n\tint total_ps_buffered; /* total number of all buffered unicast and\n\t\t\t\t* multicast packets for power saving stations\n\t\t\t\t*/\n\n\tbool pspolling;\n\t/*\n\t * PS can only be enabled when we have exactly one managed\n\t * interface (and monitors) in PS, this then points there.\n\t */\n\tstruct ieee80211_sub_if_data *ps_sdata;\n\tstruct work_struct dynamic_ps_enable_work;\n\tstruct work_struct dynamic_ps_disable_work;\n\tstruct timer_list dynamic_ps_timer;\n\tstruct notifier_block ifa_notifier;\n\tstruct notifier_block ifa6_notifier;\n\n\t/*\n\t * The dynamic ps timeout configured from user space via WEXT -\n\t * this will override whatever chosen by mac80211 internally.\n\t */\n\tint dynamic_ps_forced_timeout;\n\n\tint user_power_level; /* in dBm, for all interfaces */\n\n\tenum ieee80211_smps_mode smps_mode;\n\n\tstruct work_struct restart_work;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct local_debugfsdentries {\n\t\tstruct dentry *rcdir;\n\t\tstruct dentry *keys;\n\t} debugfs;\n\tbool force_tx_status;\n#endif\n\n\t/*\n\t * Remain-on-channel support\n\t */\n\tstruct delayed_work roc_work;\n\tstruct list_head roc_list;\n\tstruct work_struct hw_roc_start, hw_roc_done;\n\tunsigned long hw_roc_start_time;\n\tu64 roc_cookie_counter;\n\n\tstruct idr ack_status_frames;\n\tspinlock_t ack_status_lock;\n\n\tstruct ieee80211_sub_if_data __rcu *p2p_sdata;\n\n\t/* virtual monitor interface */\n\tstruct ieee80211_sub_if_data __rcu *monitor_sdata;\n\tstruct cfg80211_chan_def monitor_chandef;\n\n\t/* extended capabilities provided by mac80211 */\n\tu8 ext_capa[8];\n\n\t/* TDLS channel switch */\n\tstruct work_struct tdls_chsw_work;\n\tstruct sk_buff_head skb_queue_tdls_chsw;\n};\n\nstatic inline struct ieee80211_sub_if_data *\nIEEE80211_DEV_TO_SUB_IF(struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\nstatic inline struct ieee80211_sub_if_data *\nIEEE80211_WDEV_TO_SUB_IF(struct wireless_dev *wdev)\n{\n\treturn container_of(wdev, struct ieee80211_sub_if_data, wdev);\n}\n\nstatic inline struct ieee80211_supported_band *\nieee80211_get_sband(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum nl80211_band band;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\n\tif (WARN_ON_ONCE(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\treturn local->hw.wiphy->bands[band];\n}\n\n/* this struct holds the value parsing from channel switch IE  */\nstruct ieee80211_csa_ie {\n\tstruct cfg80211_chan_def chandef;\n\tu8 mode;\n\tu8 count;\n\tu8 ttl;\n\tu16 pre_value;\n\tu16 reason_code;\n\tu32 max_switch_time;\n};\n\n/* Parsed Information Elements */\nstruct ieee802_11_elems {\n\tconst u8 *ie_start;\n\tsize_t total_len;\n\n\t/* pointers to IEs */\n\tconst struct ieee80211_tdls_lnkie *lnk_id;\n\tconst struct ieee80211_ch_switch_timing *ch_sw_timing;\n\tconst u8 *ext_capab;\n\tconst u8 *ssid;\n\tconst u8 *supp_rates;\n\tconst u8 *ds_params;\n\tconst struct ieee80211_tim_ie *tim;\n\tconst u8 *challenge;\n\tconst u8 *rsn;\n\tconst u8 *rsnx;\n\tconst u8 *erp_info;\n\tconst u8 *ext_supp_rates;\n\tconst u8 *wmm_info;\n\tconst u8 *wmm_param;\n\tconst struct ieee80211_ht_cap *ht_cap_elem;\n\tconst struct ieee80211_ht_operation *ht_operation;\n\tconst struct ieee80211_vht_cap *vht_cap_elem;\n\tconst struct ieee80211_vht_operation *vht_operation;\n\tconst struct ieee80211_meshconf_ie *mesh_config;\n\tconst u8 *he_cap;\n\tconst struct ieee80211_he_operation *he_operation;\n\tconst struct ieee80211_he_spr *he_spr;\n\tconst struct ieee80211_mu_edca_param_set *mu_edca_param_set;\n\tconst struct ieee80211_he_6ghz_capa *he_6ghz_capa;\n\tconst u8 *uora_element;\n\tconst u8 *mesh_id;\n\tconst u8 *peering;\n\tconst __le16 *awake_window;\n\tconst u8 *preq;\n\tconst u8 *prep;\n\tconst u8 *perr;\n\tconst struct ieee80211_rann_ie *rann;\n\tconst struct ieee80211_channel_sw_ie *ch_switch_ie;\n\tconst struct ieee80211_ext_chansw_ie *ext_chansw_ie;\n\tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n\tconst u8 *max_channel_switch_time;\n\tconst u8 *country_elem;\n\tconst u8 *pwr_constr_elem;\n\tconst u8 *cisco_dtpc_elem;\n\tconst struct ieee80211_timeout_interval_ie *timeout_int;\n\tconst u8 *opmode_notif;\n\tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n\tstruct ieee80211_mesh_chansw_params_ie *mesh_chansw_params_ie;\n\tconst struct ieee80211_bss_max_idle_period_ie *max_idle_period_ie;\n\tconst struct ieee80211_multiple_bssid_configuration *mbssid_config_ie;\n\tconst struct ieee80211_bssid_index *bssid_index;\n\tu8 max_bssid_indicator;\n\tu8 dtim_count;\n\tu8 dtim_period;\n\tconst struct ieee80211_addba_ext_ie *addba_ext_ie;\n\tconst struct ieee80211_s1g_cap *s1g_capab;\n\tconst struct ieee80211_s1g_oper_ie *s1g_oper;\n\tconst struct ieee80211_s1g_bcn_compat_ie *s1g_bcn_compat;\n\tconst struct ieee80211_aid_response_ie *aid_resp;\n\n\t/* length of them, respectively */\n\tu8 ext_capab_len;\n\tu8 ssid_len;\n\tu8 supp_rates_len;\n\tu8 tim_len;\n\tu8 challenge_len;\n\tu8 rsn_len;\n\tu8 rsnx_len;\n\tu8 ext_supp_rates_len;\n\tu8 wmm_info_len;\n\tu8 wmm_param_len;\n\tu8 he_cap_len;\n\tu8 mesh_id_len;\n\tu8 peering_len;\n\tu8 preq_len;\n\tu8 prep_len;\n\tu8 perr_len;\n\tu8 country_elem_len;\n\tu8 bssid_index_len;\n\n\t/* whether a parse error occurred while retrieving these elements */\n\tbool parse_error;\n};\n\nstatic inline struct ieee80211_local *hw_to_local(\n\tstruct ieee80211_hw *hw)\n{\n\treturn container_of(hw, struct ieee80211_local, hw);\n}\n\nstatic inline struct txq_info *to_txq_info(struct ieee80211_txq *txq)\n{\n\treturn container_of(txq, struct txq_info, txq);\n}\n\nstatic inline bool txq_has_queue(struct ieee80211_txq *txq)\n{\n\tstruct txq_info *txqi = to_txq_info(txq);\n\n\treturn !(skb_queue_empty(&txqi->frags) && !txqi->tin.backlog_packets);\n}\n\nstatic inline int ieee80211_bssid_match(const u8 *raddr, const u8 *addr)\n{\n\treturn ether_addr_equal(raddr, addr) ||\n\t       is_broadcast_ether_addr(raddr);\n}\n\nstatic inline bool\nieee80211_have_rx_timestamp(struct ieee80211_rx_status *status)\n{\n\tWARN_ON_ONCE(status->flag & RX_FLAG_MACTIME_START &&\n\t\t     status->flag & RX_FLAG_MACTIME_END);\n\treturn !!(status->flag & (RX_FLAG_MACTIME_START | RX_FLAG_MACTIME_END |\n\t\t\t\t  RX_FLAG_MACTIME_PLCP_START));\n}\n\nvoid ieee80211_vif_inc_num_mcast(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_vif_dec_num_mcast(struct ieee80211_sub_if_data *sdata);\n\n/* This function returns the number of multicast stations connected to this\n * interface. It returns -1 if that number is not tracked, that is for netdevs\n * not in AP or AP_VLAN mode or when using 4addr.\n */\nstatic inline int\nieee80211_vif_get_num_mcast_if(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\treturn atomic_read(&sdata->u.ap.num_mcast_sta);\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN && !sdata->u.vlan.sta)\n\t\treturn atomic_read(&sdata->u.vlan.num_mcast_sta);\n\treturn -1;\n}\n\nu64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t\t     unsigned int mpdu_len,\n\t\t\t\t     unsigned int mpdu_offset);\nint ieee80211_hw_config(struct ieee80211_local *local, u32 changed);\nvoid ieee80211_tx_set_protected(struct ieee80211_tx_data *tx);\nvoid ieee80211_bss_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      u32 changed);\nvoid ieee80211_configure_filter(struct ieee80211_local *local);\nu32 ieee80211_reset_erp_info(struct ieee80211_sub_if_data *sdata);\n\nu64 ieee80211_mgmt_tx_cookie(struct ieee80211_local *local);\nint ieee80211_attach_ack_skb(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t     u64 *cookie, gfp_t gfp);\n\nvoid ieee80211_check_fast_rx(struct sta_info *sta);\nvoid __ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_clear_fast_rx(struct sta_info *sta);\n\n/* STA code */\nvoid ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata);\nint ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,\n\t\t       struct cfg80211_auth_request *req);\nint ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct cfg80211_assoc_request *req);\nint ieee80211_mgd_deauth(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct cfg80211_deauth_request *req);\nint ieee80211_mgd_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct cfg80211_disassoc_request *req);\nvoid ieee80211_send_pspoll(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_recalc_ps(struct ieee80211_local *local);\nvoid ieee80211_recalc_ps_vif(struct ieee80211_sub_if_data *sdata);\nint ieee80211_set_arp_filter(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb);\nvoid ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb);\nvoid ieee80211_sta_reset_beacon_monitor(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_reset_conn_monitor(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mgd_stop(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  __le16 fc, bool acked);\nvoid ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata);\n\n/* IBSS code */\nvoid ieee80211_ibss_notify_scan_completed(struct ieee80211_local *local);\nvoid ieee80211_ibss_setup_sdata(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_rx_no_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *bssid, const u8 *addr, u32 supp_rates);\nint ieee80211_ibss_join(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct cfg80211_ibss_params *params);\nint ieee80211_ibss_leave(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb);\nint ieee80211_ibss_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings);\nint ieee80211_ibss_finish_csa(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_stop(struct ieee80211_sub_if_data *sdata);\n\n/* OCB code */\nvoid ieee80211_ocb_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ocb_rx_no_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t     const u8 *bssid, const u8 *addr, u32 supp_rates);\nvoid ieee80211_ocb_setup_sdata(struct ieee80211_sub_if_data *sdata);\nint ieee80211_ocb_join(struct ieee80211_sub_if_data *sdata,\n\t\t       struct ocb_setup *setup);\nint ieee80211_ocb_leave(struct ieee80211_sub_if_data *sdata);\n\n/* mesh code */\nvoid ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb);\nint ieee80211_mesh_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings);\nint ieee80211_mesh_finish_csa(struct ieee80211_sub_if_data *sdata);\n\n/* scan/BSS handling */\nvoid ieee80211_scan_work(struct work_struct *work);\nint ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *ssid, u8 ssid_len,\n\t\t\t\tstruct ieee80211_channel **channels,\n\t\t\t\tunsigned int n_channels,\n\t\t\t\tenum nl80211_bss_scan_width scan_width);\nint ieee80211_request_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct cfg80211_scan_request *req);\nvoid ieee80211_scan_cancel(struct ieee80211_local *local);\nvoid ieee80211_run_deferred_scan(struct ieee80211_local *local);\nvoid ieee80211_scan_rx(struct ieee80211_local *local, struct sk_buff *skb);\n\nvoid ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local);\nstruct ieee80211_bss *\nieee80211_bss_info_update(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_rx_status *rx_status,\n\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t  size_t len,\n\t\t\t  struct ieee80211_channel *channel);\nvoid ieee80211_rx_bss_put(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_bss *bss);\n\n/* scheduled scan handling */\nint\n__ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct cfg80211_sched_scan_request *req);\nint ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct cfg80211_sched_scan_request *req);\nint ieee80211_request_sched_scan_stop(struct ieee80211_local *local);\nvoid ieee80211_sched_scan_end(struct ieee80211_local *local);\nvoid ieee80211_sched_scan_stopped_work(struct work_struct *work);\n\n/* off-channel/mgmt-tx */\nvoid ieee80211_offchannel_stop_vifs(struct ieee80211_local *local);\nvoid ieee80211_offchannel_return(struct ieee80211_local *local);\nvoid ieee80211_roc_setup(struct ieee80211_local *local);\nvoid ieee80211_start_next_roc(struct ieee80211_local *local);\nvoid ieee80211_roc_purge(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata);\nint ieee80211_remain_on_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\tunsigned int duration, u64 *cookie);\nint ieee80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev, u64 cookie);\nint ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t      struct cfg80211_mgmt_tx_params *params, u64 *cookie);\nint ieee80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev, u64 cookie);\n\n/* channel switch handling */\nvoid ieee80211_csa_finalize_work(struct work_struct *work);\nint ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     struct cfg80211_csa_settings *params);\n\n/* interface handling */\n#define MAC80211_SUPPORTED_FEATURES_TX\t(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \\\n\t\t\t\t\t NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t\t\t NETIF_F_HIGHDMA | NETIF_F_GSO_SOFTWARE)\n#define MAC80211_SUPPORTED_FEATURES_RX\t(NETIF_F_RXCSUM)\n#define MAC80211_SUPPORTED_FEATURES\t(MAC80211_SUPPORTED_FEATURES_TX | \\\n\t\t\t\t\t MAC80211_SUPPORTED_FEATURES_RX)\n\nint ieee80211_iface_init(void);\nvoid ieee80211_iface_exit(void);\nint ieee80211_if_add(struct ieee80211_local *local, const char *name,\n\t\t     unsigned char name_assign_type,\n\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,\n\t\t     struct vif_params *params);\nint ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,\n\t\t\t     enum nl80211_iftype type);\nvoid ieee80211_if_remove(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_remove_interfaces(struct ieee80211_local *local);\nu32 ieee80211_idle_off(struct ieee80211_local *local);\nvoid ieee80211_recalc_idle(struct ieee80211_local *local);\nvoid ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const int offset);\nint ieee80211_do_open(struct wireless_dev *wdev, bool coming_up);\nvoid ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata);\nint ieee80211_add_virtual_monitor(struct ieee80211_local *local);\nvoid ieee80211_del_virtual_monitor(struct ieee80211_local *local);\n\nbool __ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata,\n\t\t\t      bool update_bss);\nvoid ieee80211_recalc_offload(struct ieee80211_local *local);\n\nstatic inline bool ieee80211_sdata_running(struct ieee80211_sub_if_data *sdata)\n{\n\treturn test_bit(SDATA_STATE_RUNNING, &sdata->state);\n}\n\n/* tx handling */\nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local);\nvoid ieee80211_tx_pending(struct tasklet_struct *t);\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev);\nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev);\nnetdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev);\nvoid __ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u32 info_flags,\n\t\t\t\t  u32 ctrl_flags,\n\t\t\t\t  u64 *cookie);\nvoid ieee80211_purge_tx_queue(struct ieee80211_hw *hw,\n\t\t\t      struct sk_buff_head *skbs);\nstruct sk_buff *\nieee80211_build_data_template(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 info_flags);\nvoid ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t  int retry_count, int shift, bool send_to_cooked,\n\t\t\t  struct ieee80211_tx_status *status);\n\nvoid ieee80211_check_fast_xmit(struct sta_info *sta);\nvoid ieee80211_check_fast_xmit_all(struct ieee80211_local *local);\nvoid ieee80211_check_fast_xmit_iface(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_clear_fast_xmit(struct sta_info *sta);\nint ieee80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len,\n\t\t\t      const u8 *dest, __be16 proto, bool unencrypted,\n\t\t\t      u64 *cookie);\nint ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len);\n\n/* HT */\nvoid ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_sta_ht_cap *ht_cap);\nbool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_supported_band *sband,\n\t\t\t\t       const struct ieee80211_ht_cap *ht_cap_ie,\n\t\t\t\t       struct sta_info *sta);\nvoid ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *da, u16 tid,\n\t\t\t  u16 initiator, u16 reason_code);\nint ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum ieee80211_smps_mode smps, const u8 *da,\n\t\t\t       const u8 *bssid);\nvoid ieee80211_request_smps_ap_work(struct work_struct *work);\nvoid ieee80211_request_smps_mgd_work(struct work_struct *work);\nbool ieee80211_smps_is_restrictive(enum ieee80211_smps_mode smps_mode_old,\n\t\t\t\t   enum ieee80211_smps_mode smps_mode_new);\n\nvoid ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t     u16 initiator, u16 reason, bool stop);\nvoid __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t    u16 initiator, u16 reason, bool stop);\nvoid ___ieee80211_start_rx_ba_session(struct sta_info *sta,\n\t\t\t\t      u8 dialog_token, u16 timeout,\n\t\t\t\t      u16 start_seq_num, u16 ba_policy, u16 tid,\n\t\t\t\t      u16 buf_size, bool tx, bool auto_seq,\n\t\t\t\t      const struct ieee80211_addba_ext_ie *addbaext);\nvoid ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,\n\t\t\t\t\t enum ieee80211_agg_stop_reason reason);\nvoid ieee80211_process_delba(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct sta_info *sta,\n\t\t\t     struct ieee80211_mgmt *mgmt, size_t len);\nvoid ieee80211_process_addba_resp(struct ieee80211_local *local,\n\t\t\t\t  struct sta_info *sta,\n\t\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t\t  size_t len);\nvoid ieee80211_process_addba_request(struct ieee80211_local *local,\n\t\t\t\t     struct sta_info *sta,\n\t\t\t\t     struct ieee80211_mgmt *mgmt,\n\t\t\t\t     size_t len);\n\nint __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t   enum ieee80211_agg_stop_reason reason);\nint ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t    enum ieee80211_agg_stop_reason reason);\nvoid ieee80211_start_tx_ba_cb(struct sta_info *sta, int tid,\n\t\t\t      struct tid_ampdu_tx *tid_tx);\nvoid ieee80211_stop_tx_ba_cb(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx);\nvoid ieee80211_ba_session_work(struct work_struct *work);\nvoid ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid);\nvoid ieee80211_release_reorder_timeout(struct sta_info *sta, int tid);\n\nu8 ieee80211_mcs_to_chains(const struct ieee80211_mcs_info *mcs);\nenum nl80211_smps_mode\nieee80211_smps_mode_to_smps_mode(enum ieee80211_smps_mode smps);\n\n/* VHT */\nvoid\nieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    const struct ieee80211_vht_cap *vht_cap_ie,\n\t\t\t\t    struct sta_info *sta);\nenum ieee80211_sta_rx_bandwidth ieee80211_sta_cap_rx_bw(struct sta_info *sta);\nenum ieee80211_sta_rx_bandwidth ieee80211_sta_cur_vht_bw(struct sta_info *sta);\nvoid ieee80211_sta_set_rx_nss(struct sta_info *sta);\nenum ieee80211_sta_rx_bandwidth\nieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width);\nenum nl80211_chan_width ieee80211_sta_cap_chan_bw(struct sta_info *sta);\nvoid ieee80211_sta_set_rx_nss(struct sta_info *sta);\nvoid ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_mgmt *mgmt);\nu32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\n                                  struct sta_info *sta, u8 opmode,\n\t\t\t\t  enum nl80211_band band);\nvoid ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sta_info *sta, u8 opmode,\n\t\t\t\t enum nl80211_band band);\nvoid ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_sta_vht_cap *vht_cap);\nvoid ieee80211_get_vht_mask_from_cap(__le16 vht_cap,\n\t\t\t\t     u16 vht_mask[NL80211_VHT_NSS_MAX]);\nenum nl80211_chan_width\nieee80211_sta_rx_bw_to_chan_width(struct sta_info *sta);\n\n/* HE */\nvoid\nieee80211_he_cap_ie_to_sta_he_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t\t  const u8 *he_cap_ie, u8 he_cap_len,\n\t\t\t\t  const struct ieee80211_he_6ghz_capa *he_6ghz_capa,\n\t\t\t\t  struct sta_info *sta);\nvoid\nieee80211_he_spr_ie_to_bss_conf(struct ieee80211_vif *vif,\n\t\t\t\tconst struct ieee80211_he_spr *he_spr_ie_elem);\n\nvoid\nieee80211_he_op_ie_to_bss_conf(struct ieee80211_vif *vif,\n\t\t\tconst struct ieee80211_he_operation *he_op_ie_elem);\n\n/* S1G */\nvoid ieee80211_s1g_sta_rate_init(struct sta_info *sta);\n\n/* Spectrum management */\nvoid ieee80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_mgmt *mgmt,\n\t\t\t\t       size_t len);\n/**\n * ieee80211_parse_ch_switch_ie - parses channel switch IEs\n * @sdata: the sdata of the interface which has received the frame\n * @elems: parsed 802.11 elements received with the frame\n * @current_band: indicates the current band\n * @vht_cap_info: VHT capabilities of the transmitter\n * @sta_flags: contains information about own capabilities and restrictions\n *\tto decide which channel switch announcements can be accepted. Only the\n *\tfollowing subset of &enum ieee80211_sta_flags are evaluated:\n *\t%IEEE80211_STA_DISABLE_HT, %IEEE80211_STA_DISABLE_VHT,\n *\t%IEEE80211_STA_DISABLE_40MHZ, %IEEE80211_STA_DISABLE_80P80MHZ,\n *\t%IEEE80211_STA_DISABLE_160MHZ.\n * @bssid: the currently connected bssid (for reporting)\n * @csa_ie: parsed 802.11 csa elements on count, mode, chandef and mesh ttl.\n\tAll of them will be filled with if success only.\n * Return: 0 on success, <0 on error and >0 if there is nothing to parse.\n */\nint ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee802_11_elems *elems,\n\t\t\t\t enum nl80211_band current_band,\n\t\t\t\t u32 vht_cap_info,\n\t\t\t\t u32 sta_flags, u8 *bssid,\n\t\t\t\t struct ieee80211_csa_ie *csa_ie);\n\n/* Suspend/resume and hw reconfiguration */\nint ieee80211_reconfig(struct ieee80211_local *local);\nvoid ieee80211_stop_device(struct ieee80211_local *local);\n\nint __ieee80211_suspend(struct ieee80211_hw *hw,\n\t\t\tstruct cfg80211_wowlan *wowlan);\n\nstatic inline int __ieee80211_resume(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tWARN(test_bit(SCAN_HW_SCANNING, &local->scanning) &&\n\t     !test_bit(SCAN_COMPLETED, &local->scanning),\n\t\t\"%s: resume with hardware scan still in progress\\n\",\n\t\twiphy_name(hw->wiphy));\n\n\treturn ieee80211_reconfig(hw_to_local(hw));\n}\n\n/* utility functions/constants */\nextern const void *const mac80211_wiphy_privid; /* for wiphy privid */\nint ieee80211_frame_duration(enum nl80211_band band, size_t len,\n\t\t\t     int rate, int erp, int short_preamble,\n\t\t\t     int shift);\nvoid ieee80211_regulatory_limit_wmm_params(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_tx_queue_params *qparam,\n\t\t\t\t\t   int ac);\nvoid ieee80211_set_wmm_default(struct ieee80211_sub_if_data *sdata,\n\t\t\t       bool bss_notify, bool enable_qos);\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sta_info *sta, struct sk_buff *skb);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid,\n\t\t\t\t enum nl80211_band band);\n\n/* sta_out needs to be checked for ERR_PTR() before using */\nint ieee80211_lookup_ra_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct sta_info **sta_out);\n\nstatic inline void\nieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sk_buff *skb, int tid,\n\t\t\t  enum nl80211_band band)\n{\n\trcu_read_lock();\n\t__ieee80211_tx_skb_tid_band(sdata, skb, tid, band);\n\trcu_read_unlock();\n}\n\nstatic inline void ieee80211_tx_skb_tid(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct sk_buff *skb, int tid)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t__ieee80211_tx_skb_tid_band(sdata, skb, tid,\n\t\t\t\t    chanctx_conf->def.chan->band);\n\trcu_read_unlock();\n}\n\nstatic inline void ieee80211_tx_skb(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct sk_buff *skb)\n{\n\t/* Send all internal mgmt frames on VO. Accordingly set TID to 7. */\n\tieee80211_tx_skb_tid(sdata, skb, 7);\n}\n\nu32 ieee802_11_parse_elems_crc(const u8 *start, size_t len, bool action,\n\t\t\t       struct ieee802_11_elems *elems,\n\t\t\t       u64 filter, u32 crc, u8 *transmitter_bssid,\n\t\t\t       u8 *bss_bssid);\nstatic inline void ieee802_11_parse_elems(const u8 *start, size_t len,\n\t\t\t\t\t  bool action,\n\t\t\t\t\t  struct ieee802_11_elems *elems,\n\t\t\t\t\t  u8 *transmitter_bssid,\n\t\t\t\t\t  u8 *bss_bssid)\n{\n\tieee802_11_parse_elems_crc(start, len, action, elems, 0, 0,\n\t\t\t\t   transmitter_bssid, bss_bssid);\n}\n\n\nextern const int ieee802_1d_to_ac[8];\n\nstatic inline int ieee80211_ac_from_tid(int tid)\n{\n\treturn ieee802_1d_to_ac[tid & 7];\n}\n\nvoid ieee80211_dynamic_ps_enable_work(struct work_struct *work);\nvoid ieee80211_dynamic_ps_disable_work(struct work_struct *work);\nvoid ieee80211_dynamic_ps_timer(struct timer_list *t);\nvoid ieee80211_send_nullfunc(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t     bool powersave);\nvoid ieee80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct ieee80211_hdr *hdr, bool ack, u16 tx_time);\n\nvoid ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned long queues,\n\t\t\t\t     enum queue_stop_reason reason,\n\t\t\t\t     bool refcounted);\nvoid ieee80211_stop_vif_queues(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum queue_stop_reason reason);\nvoid ieee80211_wake_vif_queues(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum queue_stop_reason reason);\nvoid ieee80211_stop_queues_by_reason(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned long queues,\n\t\t\t\t     enum queue_stop_reason reason,\n\t\t\t\t     bool refcounted);\nvoid ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,\n\t\t\t\t    enum queue_stop_reason reason,\n\t\t\t\t    bool refcounted);\nvoid ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,\n\t\t\t\t    enum queue_stop_reason reason,\n\t\t\t\t    bool refcounted);\nvoid ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue);\nvoid ieee80211_add_pending_skb(struct ieee80211_local *local,\n\t\t\t       struct sk_buff *skb);\nvoid ieee80211_add_pending_skbs(struct ieee80211_local *local,\n\t\t\t\tstruct sk_buff_head *skbs);\nvoid ieee80211_flush_queues(struct ieee80211_local *local,\n\t\t\t    struct ieee80211_sub_if_data *sdata, bool drop);\nvoid __ieee80211_flush_queues(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      unsigned int queues, bool drop);\n\nstatic inline bool ieee80211_can_run_worker(struct ieee80211_local *local)\n{\n\t/*\n\t * It's unsafe to try to do any work during reconfigure flow.\n\t * When the flow ends the work will be requeued.\n\t */\n\tif (local->in_reconfig)\n\t\treturn false;\n\n\t/*\n\t * If quiescing is set, we are racing with __ieee80211_suspend.\n\t * __ieee80211_suspend flushes the workers after setting quiescing,\n\t * and we check quiescing / suspended before enqueing new workers.\n\t * We should abort the worker to avoid the races below.\n\t */\n\tif (local->quiescing)\n\t\treturn false;\n\n\t/*\n\t * We might already be suspended if the following scenario occurs:\n\t * __ieee80211_suspend\t\tControl path\n\t *\n\t *\t\t\t\tif (local->quiescing)\n\t *\t\t\t\t\treturn;\n\t * local->quiescing = true;\n\t * flush_workqueue();\n\t *\t\t\t\tqueue_work(...);\n\t * local->suspended = true;\n\t * local->quiescing = false;\n\t *\t\t\t\tworker starts running...\n\t */\n\tif (local->suspended)\n\t\treturn false;\n\n\treturn true;\n}\n\nint ieee80211_txq_setup_flows(struct ieee80211_local *local);\nvoid ieee80211_txq_set_params(struct ieee80211_local *local);\nvoid ieee80211_txq_teardown_flows(struct ieee80211_local *local);\nvoid ieee80211_txq_init(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sta_info *sta,\n\t\t\tstruct txq_info *txq, int tid);\nvoid ieee80211_txq_purge(struct ieee80211_local *local,\n\t\t\t struct txq_info *txqi);\nvoid ieee80211_txq_remove_vlan(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,\n\t\t\t      struct txq_info *txqi);\nvoid ieee80211_wake_txqs(struct tasklet_struct *t);\nvoid ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,\n\t\t\t u16 transaction, u16 auth_alg, u16 status,\n\t\t\t const u8 *extra, size_t extra_len, const u8 *bssid,\n\t\t\t const u8 *da, const u8 *key, u8 key_len, u8 key_idx,\n\t\t\t u32 tx_flags);\nvoid ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const u8 *da, const u8 *bssid,\n\t\t\t\t    u16 stype, u16 reason,\n\t\t\t\t    bool send_frame, u8 *frame_buf);\n\nenum {\n\tIEEE80211_PROBE_FLAG_DIRECTED\t\t= BIT(0),\n\tIEEE80211_PROBE_FLAG_MIN_CONTENT\t= BIT(1),\n\tIEEE80211_PROBE_FLAG_RANDOM_SN\t\t= BIT(2),\n};\n\nint ieee80211_build_preq_ies(struct ieee80211_sub_if_data *sdata, u8 *buffer,\n\t\t\t     size_t buffer_len,\n\t\t\t     struct ieee80211_scan_ies *ie_desc,\n\t\t\t     const u8 *ie, size_t ie_len,\n\t\t\t     u8 bands_used, u32 *rate_masks,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     u32 flags);\nstruct sk_buff *ieee80211_build_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *src, const u8 *dst,\n\t\t\t\t\t  u32 ratemask,\n\t\t\t\t\t  struct ieee80211_channel *chan,\n\t\t\t\t\t  const u8 *ssid, size_t ssid_len,\n\t\t\t\t\t  const u8 *ie, size_t ie_len,\n\t\t\t\t\t  u32 flags);\nu32 ieee80211_sta_get_rates(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct ieee802_11_elems *elems,\n\t\t\t    enum nl80211_band band, u32 *basic_rates);\nint __ieee80211_request_smps_mgd(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t enum ieee80211_smps_mode smps_mode);\nvoid ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata);\n\nsize_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset);\nu8 *ieee80211_ie_build_ht_cap(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t      u16 cap);\nu8 *ieee80211_ie_build_ht_oper(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t       const struct cfg80211_chan_def *chandef,\n\t\t\t       u16 prot_mode, bool rifs_mode);\nvoid ieee80211_ie_build_wide_bw_cs(u8 *pos,\n\t\t\t\t   const struct cfg80211_chan_def *chandef);\nu8 *ieee80211_ie_build_vht_cap(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t       u32 cap);\nu8 *ieee80211_ie_build_vht_oper(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\tconst struct cfg80211_chan_def *chandef);\nu8 ieee80211_ie_len_he_cap(struct ieee80211_sub_if_data *sdata, u8 iftype);\nu8 *ieee80211_ie_build_he_cap(u8 *pos,\n\t\t\t      const struct ieee80211_sta_he_cap *he_cap,\n\t\t\t      u8 *end);\nvoid ieee80211_ie_build_he_6ghz_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct sk_buff *skb);\nu8 *ieee80211_ie_build_he_oper(u8 *pos, struct cfg80211_chan_def *chandef);\nint ieee80211_parse_bitrates(struct cfg80211_chan_def *chandef,\n\t\t\t     const struct ieee80211_supported_band *sband,\n\t\t\t     const u8 *srates, int srates_len, u32 *rates);\nint ieee80211_add_srates_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb, bool need_basic,\n\t\t\t    enum nl80211_band band);\nint ieee80211_add_ext_srates_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb, bool need_basic,\n\t\t\t\tenum nl80211_band band);\nu8 *ieee80211_add_wmm_info_ie(u8 *buf, u8 qosinfo);\nvoid ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct ieee80211_sta_s1g_cap *caps,\n\t\t\t\tstruct sk_buff *skb);\nvoid ieee80211_add_aid_request_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb);\n\n/* channel management */\nbool ieee80211_chandef_ht_oper(const struct ieee80211_ht_operation *ht_oper,\n\t\t\t       struct cfg80211_chan_def *chandef);\nbool ieee80211_chandef_vht_oper(struct ieee80211_hw *hw, u32 vht_cap_info,\n\t\t\t\tconst struct ieee80211_vht_operation *oper,\n\t\t\t\tconst struct ieee80211_ht_operation *htop,\n\t\t\t\tstruct cfg80211_chan_def *chandef);\nbool ieee80211_chandef_he_6ghz_oper(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const struct ieee80211_he_operation *he_oper,\n\t\t\t\t    struct cfg80211_chan_def *chandef);\nbool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,\n\t\t\t\tstruct cfg80211_chan_def *chandef);\nu32 ieee80211_chandef_downgrade(struct cfg80211_chan_def *c);\n\nint __must_check\nieee80211_vif_use_channel(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const struct cfg80211_chan_def *chandef,\n\t\t\t  enum ieee80211_chanctx_mode mode);\nint __must_check\nieee80211_vif_reserve_chanctx(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const struct cfg80211_chan_def *chandef,\n\t\t\t      enum ieee80211_chanctx_mode mode,\n\t\t\t      bool radar_required);\nint __must_check\nieee80211_vif_use_reserved_context(struct ieee80211_sub_if_data *sdata);\nint ieee80211_vif_unreserve_chanctx(struct ieee80211_sub_if_data *sdata);\n\nint __must_check\nieee80211_vif_change_bandwidth(struct ieee80211_sub_if_data *sdata,\n\t\t\t       const struct cfg80211_chan_def *chandef,\n\t\t\t       u32 *changed);\nvoid ieee80211_vif_release_channel(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_vif_vlan_copy_chanctx(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_vif_copy_chanctx_to_vlans(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t bool clear);\nint ieee80211_chanctx_refcount(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_chanctx *ctx);\n\nvoid ieee80211_recalc_smps_chanctx(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_chanctx *chanctx);\nvoid ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx);\nbool ieee80211_is_radar_required(struct ieee80211_local *local);\n\nvoid ieee80211_dfs_cac_timer(unsigned long data);\nvoid ieee80211_dfs_cac_timer_work(struct work_struct *work);\nvoid ieee80211_dfs_cac_cancel(struct ieee80211_local *local);\nvoid ieee80211_dfs_radar_detected_work(struct work_struct *work);\nint ieee80211_send_action_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings);\n\nbool ieee80211_cs_valid(const struct ieee80211_cipher_scheme *cs);\nbool ieee80211_cs_list_valid(const struct ieee80211_cipher_scheme *cs, int n);\nconst struct ieee80211_cipher_scheme *\nieee80211_cs_get(struct ieee80211_local *local, u32 cipher,\n\t\t enum nl80211_iftype iftype);\nint ieee80211_cs_headroom(struct ieee80211_local *local,\n\t\t\t  struct cfg80211_crypto_settings *crypto,\n\t\t\t  enum nl80211_iftype iftype);\nvoid ieee80211_recalc_dtim(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata);\nint ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t const struct cfg80211_chan_def *chandef,\n\t\t\t\t enum ieee80211_chanctx_mode chanmode,\n\t\t\t\t u8 radar_detect);\nint ieee80211_max_num_channels(struct ieee80211_local *local);\nvoid ieee80211_recalc_chanctx_chantype(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_chanctx *ctx);\n\n/* TDLS */\nint ieee80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tconst u8 *peer, u8 action_code, u8 dialog_token,\n\t\t\tu16 status_code, u32 peer_capability,\n\t\t\tbool initiator, const u8 *extra_ies,\n\t\t\tsize_t extra_ies_len);\nint ieee80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tconst u8 *peer, enum nl80211_tdls_operation oper);\nvoid ieee80211_tdls_peer_del_work(struct work_struct *wk);\nint ieee80211_tdls_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *addr, u8 oper_class,\n\t\t\t\t  struct cfg80211_chan_def *chandef);\nvoid ieee80211_tdls_cancel_channel_switch(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  const u8 *addr);\nvoid ieee80211_teardown_tdls_peers(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_tdls_chsw_work(struct work_struct *wk);\nvoid ieee80211_tdls_handle_disconnect(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      const u8 *peer, u16 reason);\nconst char *ieee80211_get_reason_code_string(u16 reason_code);\nu16 ieee80211_encode_usf(int val);\nu8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,\n\t\t\tenum nl80211_iftype type);\n\nextern const struct ethtool_ops ieee80211_ethtool_ops;\n\nu32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *pubsta,\n\t\t\t\t       int len, bool ampdu);\n#ifdef CONFIG_MAC80211_NOINLINE\n#define debug_noinline noinline\n#else\n#define debug_noinline\n#endif\n\n#endif /* IEEE80211_I_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/workqueue.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * workqueue.h --- work queue handling for Linux.\n */\n\n#ifndef _LINUX_WORKQUEUE_H\n#define _LINUX_WORKQUEUE_H\n\n#include <linux/timer.h>\n#include <linux/linkage.h>\n#include <linux/bitops.h>\n#include <linux/lockdep.h>\n#include <linux/threads.h>\n#include <linux/atomic.h>\n#include <linux/cpumask.h>\n#include <linux/rcupdate.h>\n\nstruct workqueue_struct;\n\nstruct work_struct;\ntypedef void (*work_func_t)(struct work_struct *work);\nvoid delayed_work_timer_fn(struct timer_list *t);\n\n/*\n * The first word is the work queue pointer and the flags rolled into\n * one\n */\n#define work_data_bits(work) ((unsigned long *)(&(work)->data))\n\nenum {\n\tWORK_STRUCT_PENDING_BIT\t= 0,\t/* work item is pending execution */\n\tWORK_STRUCT_DELAYED_BIT\t= 1,\t/* work item is delayed */\n\tWORK_STRUCT_PWQ_BIT\t= 2,\t/* data points to pwq */\n\tWORK_STRUCT_LINKED_BIT\t= 3,\t/* next work is linked to this one */\n#ifdef CONFIG_DEBUG_OBJECTS_WORK\n\tWORK_STRUCT_STATIC_BIT\t= 4,\t/* static initializer (debugobjects) */\n\tWORK_STRUCT_COLOR_SHIFT\t= 5,\t/* color for workqueue flushing */\n#else\n\tWORK_STRUCT_COLOR_SHIFT\t= 4,\t/* color for workqueue flushing */\n#endif\n\n\tWORK_STRUCT_COLOR_BITS\t= 4,\n\n\tWORK_STRUCT_PENDING\t= 1 << WORK_STRUCT_PENDING_BIT,\n\tWORK_STRUCT_DELAYED\t= 1 << WORK_STRUCT_DELAYED_BIT,\n\tWORK_STRUCT_PWQ\t\t= 1 << WORK_STRUCT_PWQ_BIT,\n\tWORK_STRUCT_LINKED\t= 1 << WORK_STRUCT_LINKED_BIT,\n#ifdef CONFIG_DEBUG_OBJECTS_WORK\n\tWORK_STRUCT_STATIC\t= 1 << WORK_STRUCT_STATIC_BIT,\n#else\n\tWORK_STRUCT_STATIC\t= 0,\n#endif\n\n\t/*\n\t * The last color is no color used for works which don't\n\t * participate in workqueue flushing.\n\t */\n\tWORK_NR_COLORS\t\t= (1 << WORK_STRUCT_COLOR_BITS) - 1,\n\tWORK_NO_COLOR\t\t= WORK_NR_COLORS,\n\n\t/* not bound to any CPU, prefer the local CPU */\n\tWORK_CPU_UNBOUND\t= NR_CPUS,\n\n\t/*\n\t * Reserve 8 bits off of pwq pointer w/ debugobjects turned off.\n\t * This makes pwqs aligned to 256 bytes and allows 15 workqueue\n\t * flush colors.\n\t */\n\tWORK_STRUCT_FLAG_BITS\t= WORK_STRUCT_COLOR_SHIFT +\n\t\t\t\t  WORK_STRUCT_COLOR_BITS,\n\n\t/* data contains off-queue information when !WORK_STRUCT_PWQ */\n\tWORK_OFFQ_FLAG_BASE\t= WORK_STRUCT_COLOR_SHIFT,\n\n\t__WORK_OFFQ_CANCELING\t= WORK_OFFQ_FLAG_BASE,\n\tWORK_OFFQ_CANCELING\t= (1 << __WORK_OFFQ_CANCELING),\n\n\t/*\n\t * When a work item is off queue, its high bits point to the last\n\t * pool it was on.  Cap at 31 bits and use the highest number to\n\t * indicate that no pool is associated.\n\t */\n\tWORK_OFFQ_FLAG_BITS\t= 1,\n\tWORK_OFFQ_POOL_SHIFT\t= WORK_OFFQ_FLAG_BASE + WORK_OFFQ_FLAG_BITS,\n\tWORK_OFFQ_LEFT\t\t= BITS_PER_LONG - WORK_OFFQ_POOL_SHIFT,\n\tWORK_OFFQ_POOL_BITS\t= WORK_OFFQ_LEFT <= 31 ? WORK_OFFQ_LEFT : 31,\n\tWORK_OFFQ_POOL_NONE\t= (1LU << WORK_OFFQ_POOL_BITS) - 1,\n\n\t/* convenience constants */\n\tWORK_STRUCT_FLAG_MASK\t= (1UL << WORK_STRUCT_FLAG_BITS) - 1,\n\tWORK_STRUCT_WQ_DATA_MASK = ~WORK_STRUCT_FLAG_MASK,\n\tWORK_STRUCT_NO_POOL\t= (unsigned long)WORK_OFFQ_POOL_NONE << WORK_OFFQ_POOL_SHIFT,\n\n\t/* bit mask for work_busy() return values */\n\tWORK_BUSY_PENDING\t= 1 << 0,\n\tWORK_BUSY_RUNNING\t= 1 << 1,\n\n\t/* maximum string length for set_worker_desc() */\n\tWORKER_DESC_LEN\t\t= 24,\n};\n\nstruct work_struct {\n\tatomic_long_t data;\n\tstruct list_head entry;\n\twork_func_t func;\n#ifdef CONFIG_LOCKDEP\n\tstruct lockdep_map lockdep_map;\n#endif\n};\n\n#define WORK_DATA_INIT()\tATOMIC_LONG_INIT((unsigned long)WORK_STRUCT_NO_POOL)\n#define WORK_DATA_STATIC_INIT()\t\\\n\tATOMIC_LONG_INIT((unsigned long)(WORK_STRUCT_NO_POOL | WORK_STRUCT_STATIC))\n\nstruct delayed_work {\n\tstruct work_struct work;\n\tstruct timer_list timer;\n\n\t/* target workqueue and CPU ->timer uses to queue ->work */\n\tstruct workqueue_struct *wq;\n\tint cpu;\n};\n\nstruct rcu_work {\n\tstruct work_struct work;\n\tstruct rcu_head rcu;\n\n\t/* target workqueue ->rcu uses to queue ->work */\n\tstruct workqueue_struct *wq;\n};\n\n/**\n * struct workqueue_attrs - A struct for workqueue attributes.\n *\n * This can be used to change attributes of an unbound workqueue.\n */\nstruct workqueue_attrs {\n\t/**\n\t * @nice: nice level\n\t */\n\tint nice;\n\n\t/**\n\t * @cpumask: allowed CPUs\n\t */\n\tcpumask_var_t cpumask;\n\n\t/**\n\t * @no_numa: disable NUMA affinity\n\t *\n\t * Unlike other fields, ``no_numa`` isn't a property of a worker_pool. It\n\t * only modifies how :c:func:`apply_workqueue_attrs` select pools and thus\n\t * doesn't participate in pool hash calculations or equality comparisons.\n\t */\n\tbool no_numa;\n};\n\nstatic inline struct delayed_work *to_delayed_work(struct work_struct *work)\n{\n\treturn container_of(work, struct delayed_work, work);\n}\n\nstatic inline struct rcu_work *to_rcu_work(struct work_struct *work)\n{\n\treturn container_of(work, struct rcu_work, work);\n}\n\nstruct execute_work {\n\tstruct work_struct work;\n};\n\n#ifdef CONFIG_LOCKDEP\n/*\n * NB: because we have to copy the lockdep_map, setting _key\n * here is required, otherwise it could get initialised to the\n * copy of the lockdep_map!\n */\n#define __WORK_INIT_LOCKDEP_MAP(n, k) \\\n\t.lockdep_map = STATIC_LOCKDEP_MAP_INIT(n, k),\n#else\n#define __WORK_INIT_LOCKDEP_MAP(n, k)\n#endif\n\n#define __WORK_INITIALIZER(n, f) {\t\t\t\t\t\\\n\t.data = WORK_DATA_STATIC_INIT(),\t\t\t\t\\\n\t.entry\t= { &(n).entry, &(n).entry },\t\t\t\t\\\n\t.func = (f),\t\t\t\t\t\t\t\\\n\t__WORK_INIT_LOCKDEP_MAP(#n, &(n))\t\t\t\t\\\n\t}\n\n#define __DELAYED_WORK_INITIALIZER(n, f, tflags) {\t\t\t\\\n\t.work = __WORK_INITIALIZER((n).work, (f)),\t\t\t\\\n\t.timer = __TIMER_INITIALIZER(delayed_work_timer_fn,\\\n\t\t\t\t     (tflags) | TIMER_IRQSAFE),\t\t\\\n\t}\n\n#define DECLARE_WORK(n, f)\t\t\t\t\t\t\\\n\tstruct work_struct n = __WORK_INITIALIZER(n, f)\n\n#define DECLARE_DELAYED_WORK(n, f)\t\t\t\t\t\\\n\tstruct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)\n\n#define DECLARE_DEFERRABLE_WORK(n, f)\t\t\t\t\t\\\n\tstruct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, TIMER_DEFERRABLE)\n\n#ifdef CONFIG_DEBUG_OBJECTS_WORK\nextern void __init_work(struct work_struct *work, int onstack);\nextern void destroy_work_on_stack(struct work_struct *work);\nextern void destroy_delayed_work_on_stack(struct delayed_work *work);\nstatic inline unsigned int work_static(struct work_struct *work)\n{\n\treturn *work_data_bits(work) & WORK_STRUCT_STATIC;\n}\n#else\nstatic inline void __init_work(struct work_struct *work, int onstack) { }\nstatic inline void destroy_work_on_stack(struct work_struct *work) { }\nstatic inline void destroy_delayed_work_on_stack(struct delayed_work *work) { }\nstatic inline unsigned int work_static(struct work_struct *work) { return 0; }\n#endif\n\n/*\n * initialize all of a work item in one go\n *\n * NOTE! No point in using \"atomic_long_set()\": using a direct\n * assignment of the work data initializer allows the compiler\n * to generate better code.\n */\n#ifdef CONFIG_LOCKDEP\n#define __INIT_WORK(_work, _func, _onstack)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__init_work((_work), _onstack);\t\t\t\t\\\n\t\t(_work)->data = (atomic_long_t) WORK_DATA_INIT();\t\\\n\t\tlockdep_init_map(&(_work)->lockdep_map, \"(work_completion)\"#_work, &__key, 0); \\\n\t\tINIT_LIST_HEAD(&(_work)->entry);\t\t\t\\\n\t\t(_work)->func = (_func);\t\t\t\t\\\n\t} while (0)\n#else\n#define __INIT_WORK(_work, _func, _onstack)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t__init_work((_work), _onstack);\t\t\t\t\\\n\t\t(_work)->data = (atomic_long_t) WORK_DATA_INIT();\t\\\n\t\tINIT_LIST_HEAD(&(_work)->entry);\t\t\t\\\n\t\t(_work)->func = (_func);\t\t\t\t\\\n\t} while (0)\n#endif\n\n#define INIT_WORK(_work, _func)\t\t\t\t\t\t\\\n\t__INIT_WORK((_work), (_func), 0)\n\n#define INIT_WORK_ONSTACK(_work, _func)\t\t\t\t\t\\\n\t__INIT_WORK((_work), (_func), 1)\n\n#define __INIT_DELAYED_WORK(_work, _func, _tflags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tINIT_WORK(&(_work)->work, (_func));\t\t\t\\\n\t\t__init_timer(&(_work)->timer,\t\t\t\t\\\n\t\t\t     delayed_work_timer_fn,\t\t\t\\\n\t\t\t     (_tflags) | TIMER_IRQSAFE);\t\t\\\n\t} while (0)\n\n#define __INIT_DELAYED_WORK_ONSTACK(_work, _func, _tflags)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tINIT_WORK_ONSTACK(&(_work)->work, (_func));\t\t\\\n\t\t__init_timer_on_stack(&(_work)->timer,\t\t\t\\\n\t\t\t\t      delayed_work_timer_fn,\t\t\\\n\t\t\t\t      (_tflags) | TIMER_IRQSAFE);\t\\\n\t} while (0)\n\n#define INIT_DELAYED_WORK(_work, _func)\t\t\t\t\t\\\n\t__INIT_DELAYED_WORK(_work, _func, 0)\n\n#define INIT_DELAYED_WORK_ONSTACK(_work, _func)\t\t\t\t\\\n\t__INIT_DELAYED_WORK_ONSTACK(_work, _func, 0)\n\n#define INIT_DEFERRABLE_WORK(_work, _func)\t\t\t\t\\\n\t__INIT_DELAYED_WORK(_work, _func, TIMER_DEFERRABLE)\n\n#define INIT_DEFERRABLE_WORK_ONSTACK(_work, _func)\t\t\t\\\n\t__INIT_DELAYED_WORK_ONSTACK(_work, _func, TIMER_DEFERRABLE)\n\n#define INIT_RCU_WORK(_work, _func)\t\t\t\t\t\\\n\tINIT_WORK(&(_work)->work, (_func))\n\n#define INIT_RCU_WORK_ONSTACK(_work, _func)\t\t\t\t\\\n\tINIT_WORK_ONSTACK(&(_work)->work, (_func))\n\n/**\n * work_pending - Find out whether a work item is currently pending\n * @work: The work item in question\n */\n#define work_pending(work) \\\n\ttest_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))\n\n/**\n * delayed_work_pending - Find out whether a delayable work item is currently\n * pending\n * @w: The work item in question\n */\n#define delayed_work_pending(w) \\\n\twork_pending(&(w)->work)\n\n/*\n * Workqueue flags and constants.  For details, please refer to\n * Documentation/core-api/workqueue.rst.\n */\nenum {\n\tWQ_UNBOUND\t\t= 1 << 1, /* not bound to any cpu */\n\tWQ_FREEZABLE\t\t= 1 << 2, /* freeze during suspend */\n\tWQ_MEM_RECLAIM\t\t= 1 << 3, /* may be used for memory reclaim */\n\tWQ_HIGHPRI\t\t= 1 << 4, /* high priority */\n\tWQ_CPU_INTENSIVE\t= 1 << 5, /* cpu intensive workqueue */\n\tWQ_SYSFS\t\t= 1 << 6, /* visible in sysfs, see workqueue_sysfs_register() */\n\n\t/*\n\t * Per-cpu workqueues are generally preferred because they tend to\n\t * show better performance thanks to cache locality.  Per-cpu\n\t * workqueues exclude the scheduler from choosing the CPU to\n\t * execute the worker threads, which has an unfortunate side effect\n\t * of increasing power consumption.\n\t *\n\t * The scheduler considers a CPU idle if it doesn't have any task\n\t * to execute and tries to keep idle cores idle to conserve power;\n\t * however, for example, a per-cpu work item scheduled from an\n\t * interrupt handler on an idle CPU will force the scheduler to\n\t * excute the work item on that CPU breaking the idleness, which in\n\t * turn may lead to more scheduling choices which are sub-optimal\n\t * in terms of power consumption.\n\t *\n\t * Workqueues marked with WQ_POWER_EFFICIENT are per-cpu by default\n\t * but become unbound if workqueue.power_efficient kernel param is\n\t * specified.  Per-cpu workqueues which are identified to\n\t * contribute significantly to power-consumption are identified and\n\t * marked with this flag and enabling the power_efficient mode\n\t * leads to noticeable power saving at the cost of small\n\t * performance disadvantage.\n\t *\n\t * http://thread.gmane.org/gmane.linux.kernel/1480396\n\t */\n\tWQ_POWER_EFFICIENT\t= 1 << 7,\n\n\t__WQ_DRAINING\t\t= 1 << 16, /* internal: workqueue is draining */\n\t__WQ_ORDERED\t\t= 1 << 17, /* internal: workqueue is ordered */\n\t__WQ_LEGACY\t\t= 1 << 18, /* internal: create*_workqueue() */\n\t__WQ_ORDERED_EXPLICIT\t= 1 << 19, /* internal: alloc_ordered_workqueue() */\n\n\tWQ_MAX_ACTIVE\t\t= 512,\t  /* I like 512, better ideas? */\n\tWQ_MAX_UNBOUND_PER_CPU\t= 4,\t  /* 4 * #cpus for unbound wq */\n\tWQ_DFL_ACTIVE\t\t= WQ_MAX_ACTIVE / 2,\n};\n\n/* unbound wq's aren't per-cpu, scale max_active according to #cpus */\n#define WQ_UNBOUND_MAX_ACTIVE\t\\\n\tmax_t(int, WQ_MAX_ACTIVE, num_possible_cpus() * WQ_MAX_UNBOUND_PER_CPU)\n\n/*\n * System-wide workqueues which are always present.\n *\n * system_wq is the one used by schedule[_delayed]_work[_on]().\n * Multi-CPU multi-threaded.  There are users which expect relatively\n * short queue flush time.  Don't queue works which can run for too\n * long.\n *\n * system_highpri_wq is similar to system_wq but for work items which\n * require WQ_HIGHPRI.\n *\n * system_long_wq is similar to system_wq but may host long running\n * works.  Queue flushing might take relatively long.\n *\n * system_unbound_wq is unbound workqueue.  Workers are not bound to\n * any specific CPU, not concurrency managed, and all queued works are\n * executed immediately as long as max_active limit is not reached and\n * resources are available.\n *\n * system_freezable_wq is equivalent to system_wq except that it's\n * freezable.\n *\n * *_power_efficient_wq are inclined towards saving power and converted\n * into WQ_UNBOUND variants if 'wq_power_efficient' is enabled; otherwise,\n * they are same as their non-power-efficient counterparts - e.g.\n * system_power_efficient_wq is identical to system_wq if\n * 'wq_power_efficient' is disabled.  See WQ_POWER_EFFICIENT for more info.\n */\nextern struct workqueue_struct *system_wq;\nextern struct workqueue_struct *system_highpri_wq;\nextern struct workqueue_struct *system_long_wq;\nextern struct workqueue_struct *system_unbound_wq;\nextern struct workqueue_struct *system_freezable_wq;\nextern struct workqueue_struct *system_power_efficient_wq;\nextern struct workqueue_struct *system_freezable_power_efficient_wq;\n\n/**\n * alloc_workqueue - allocate a workqueue\n * @fmt: printf format for the name of the workqueue\n * @flags: WQ_* flags\n * @max_active: max in-flight work items, 0 for default\n * remaining args: args for @fmt\n *\n * Allocate a workqueue with the specified parameters.  For detailed\n * information on WQ_* flags, please refer to\n * Documentation/core-api/workqueue.rst.\n *\n * RETURNS:\n * Pointer to the allocated workqueue on success, %NULL on failure.\n */\nstruct workqueue_struct *alloc_workqueue(const char *fmt,\n\t\t\t\t\t unsigned int flags,\n\t\t\t\t\t int max_active, ...);\n\n/**\n * alloc_ordered_workqueue - allocate an ordered workqueue\n * @fmt: printf format for the name of the workqueue\n * @flags: WQ_* flags (only WQ_FREEZABLE and WQ_MEM_RECLAIM are meaningful)\n * @args...: args for @fmt\n *\n * Allocate an ordered workqueue.  An ordered workqueue executes at\n * most one work item at any given time in the queued order.  They are\n * implemented as unbound workqueues with @max_active of one.\n *\n * RETURNS:\n * Pointer to the allocated workqueue on success, %NULL on failure.\n */\n#define alloc_ordered_workqueue(fmt, flags, args...)\t\t\t\\\n\talloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED |\t\t\\\n\t\t\t__WQ_ORDERED_EXPLICIT | (flags), 1, ##args)\n\n#define create_workqueue(name)\t\t\t\t\t\t\\\n\talloc_workqueue(\"%s\", __WQ_LEGACY | WQ_MEM_RECLAIM, 1, (name))\n#define create_freezable_workqueue(name)\t\t\t\t\\\n\talloc_workqueue(\"%s\", __WQ_LEGACY | WQ_FREEZABLE | WQ_UNBOUND |\t\\\n\t\t\tWQ_MEM_RECLAIM, 1, (name))\n#define create_singlethread_workqueue(name)\t\t\t\t\\\n\talloc_ordered_workqueue(\"%s\", __WQ_LEGACY | WQ_MEM_RECLAIM, name)\n\nextern void destroy_workqueue(struct workqueue_struct *wq);\n\nstruct workqueue_attrs *alloc_workqueue_attrs(void);\nvoid free_workqueue_attrs(struct workqueue_attrs *attrs);\nint apply_workqueue_attrs(struct workqueue_struct *wq,\n\t\t\t  const struct workqueue_attrs *attrs);\nint workqueue_set_unbound_cpumask(cpumask_var_t cpumask);\n\nextern bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\tstruct work_struct *work);\nextern bool queue_work_node(int node, struct workqueue_struct *wq,\n\t\t\t    struct work_struct *work);\nextern bool queue_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\tstruct delayed_work *work, unsigned long delay);\nextern bool mod_delayed_work_on(int cpu, struct workqueue_struct *wq,\n\t\t\tstruct delayed_work *dwork, unsigned long delay);\nextern bool queue_rcu_work(struct workqueue_struct *wq, struct rcu_work *rwork);\n\nextern void flush_workqueue(struct workqueue_struct *wq);\nextern void drain_workqueue(struct workqueue_struct *wq);\n\nextern int schedule_on_each_cpu(work_func_t func);\n\nint execute_in_process_context(work_func_t fn, struct execute_work *);\n\nextern bool flush_work(struct work_struct *work);\nextern bool cancel_work_sync(struct work_struct *work);\n\nextern bool flush_delayed_work(struct delayed_work *dwork);\nextern bool cancel_delayed_work(struct delayed_work *dwork);\nextern bool cancel_delayed_work_sync(struct delayed_work *dwork);\n\nextern bool flush_rcu_work(struct rcu_work *rwork);\n\nextern void workqueue_set_max_active(struct workqueue_struct *wq,\n\t\t\t\t     int max_active);\nextern struct work_struct *current_work(void);\nextern bool current_is_workqueue_rescuer(void);\nextern bool workqueue_congested(int cpu, struct workqueue_struct *wq);\nextern unsigned int work_busy(struct work_struct *work);\nextern __printf(1, 2) void set_worker_desc(const char *fmt, ...);\nextern void print_worker_info(const char *log_lvl, struct task_struct *task);\nextern void show_workqueue_state(void);\nextern void wq_worker_comm(char *buf, size_t size, struct task_struct *task);\n\n/**\n * queue_work - queue work on a workqueue\n * @wq: workqueue to use\n * @work: work to queue\n *\n * Returns %false if @work was already on a queue, %true otherwise.\n *\n * We queue the work to the CPU on which it was submitted, but if the CPU dies\n * it can be processed by another CPU.\n *\n * Memory-ordering properties:  If it returns %true, guarantees that all stores\n * preceding the call to queue_work() in the program order will be visible from\n * the CPU which will execute @work by the time such work executes, e.g.,\n *\n * { x is initially 0 }\n *\n *   CPU0\t\t\t\tCPU1\n *\n *   WRITE_ONCE(x, 1);\t\t\t[ @work is being executed ]\n *   r0 = queue_work(wq, work);\t\t  r1 = READ_ONCE(x);\n *\n * Forbids: r0 == true && r1 == 0\n */\nstatic inline bool queue_work(struct workqueue_struct *wq,\n\t\t\t      struct work_struct *work)\n{\n\treturn queue_work_on(WORK_CPU_UNBOUND, wq, work);\n}\n\n/**\n * queue_delayed_work - queue work on a workqueue after delay\n * @wq: workqueue to use\n * @dwork: delayable work to queue\n * @delay: number of jiffies to wait before queueing\n *\n * Equivalent to queue_delayed_work_on() but tries to use the local CPU.\n */\nstatic inline bool queue_delayed_work(struct workqueue_struct *wq,\n\t\t\t\t      struct delayed_work *dwork,\n\t\t\t\t      unsigned long delay)\n{\n\treturn queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);\n}\n\n/**\n * mod_delayed_work - modify delay of or queue a delayed work\n * @wq: workqueue to use\n * @dwork: work to queue\n * @delay: number of jiffies to wait before queueing\n *\n * mod_delayed_work_on() on local CPU.\n */\nstatic inline bool mod_delayed_work(struct workqueue_struct *wq,\n\t\t\t\t    struct delayed_work *dwork,\n\t\t\t\t    unsigned long delay)\n{\n\treturn mod_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);\n}\n\n/**\n * schedule_work_on - put work task on a specific cpu\n * @cpu: cpu to put the work task on\n * @work: job to be done\n *\n * This puts a job on a specific cpu\n */\nstatic inline bool schedule_work_on(int cpu, struct work_struct *work)\n{\n\treturn queue_work_on(cpu, system_wq, work);\n}\n\n/**\n * schedule_work - put work task in global workqueue\n * @work: job to be done\n *\n * Returns %false if @work was already on the kernel-global workqueue and\n * %true otherwise.\n *\n * This puts a job in the kernel-global workqueue if it was not already\n * queued and leaves it in the same position on the kernel-global\n * workqueue otherwise.\n *\n * Shares the same memory-ordering properties of queue_work(), cf. the\n * DocBook header of queue_work().\n */\nstatic inline bool schedule_work(struct work_struct *work)\n{\n\treturn queue_work(system_wq, work);\n}\n\n/**\n * flush_scheduled_work - ensure that any scheduled work has run to completion.\n *\n * Forces execution of the kernel-global workqueue and blocks until its\n * completion.\n *\n * Think twice before calling this function!  It's very easy to get into\n * trouble if you don't take great care.  Either of the following situations\n * will lead to deadlock:\n *\n *\tOne of the work items currently on the workqueue needs to acquire\n *\ta lock held by your code or its caller.\n *\n *\tYour code is running in the context of a work routine.\n *\n * They will be detected by lockdep when they occur, but the first might not\n * occur very often.  It depends on what work items are on the workqueue and\n * what locks they need, which you have no control over.\n *\n * In most situations flushing the entire workqueue is overkill; you merely\n * need to know that a particular work item isn't queued and isn't running.\n * In such cases you should use cancel_delayed_work_sync() or\n * cancel_work_sync() instead.\n */\nstatic inline void flush_scheduled_work(void)\n{\n\tflush_workqueue(system_wq);\n}\n\n/**\n * schedule_delayed_work_on - queue work in global workqueue on CPU after delay\n * @cpu: cpu to use\n * @dwork: job to be done\n * @delay: number of jiffies to wait\n *\n * After waiting for a given time this puts a job in the kernel-global\n * workqueue on the specified CPU.\n */\nstatic inline bool schedule_delayed_work_on(int cpu, struct delayed_work *dwork,\n\t\t\t\t\t    unsigned long delay)\n{\n\treturn queue_delayed_work_on(cpu, system_wq, dwork, delay);\n}\n\n/**\n * schedule_delayed_work - put work task in global workqueue after delay\n * @dwork: job to be done\n * @delay: number of jiffies to wait or 0 for immediate execution\n *\n * After waiting for a given time this puts a job in the kernel-global\n * workqueue.\n */\nstatic inline bool schedule_delayed_work(struct delayed_work *dwork,\n\t\t\t\t\t unsigned long delay)\n{\n\treturn queue_delayed_work(system_wq, dwork, delay);\n}\n\n#ifndef CONFIG_SMP\nstatic inline long work_on_cpu(int cpu, long (*fn)(void *), void *arg)\n{\n\treturn fn(arg);\n}\nstatic inline long work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg)\n{\n\treturn fn(arg);\n}\n#else\nlong work_on_cpu(int cpu, long (*fn)(void *), void *arg);\nlong work_on_cpu_safe(int cpu, long (*fn)(void *), void *arg);\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_FREEZER\nextern void freeze_workqueues_begin(void);\nextern bool freeze_workqueues_busy(void);\nextern void thaw_workqueues(void);\n#endif /* CONFIG_FREEZER */\n\n#ifdef CONFIG_SYSFS\nint workqueue_sysfs_register(struct workqueue_struct *wq);\n#else\t/* CONFIG_SYSFS */\nstatic inline int workqueue_sysfs_register(struct workqueue_struct *wq)\n{ return 0; }\n#endif\t/* CONFIG_SYSFS */\n\n#ifdef CONFIG_WQ_WATCHDOG\nvoid wq_watchdog_touch(int cpu);\n#else\t/* CONFIG_WQ_WATCHDOG */\nstatic inline void wq_watchdog_touch(int cpu) { }\n#endif\t/* CONFIG_WQ_WATCHDOG */\n\n#ifdef CONFIG_SMP\nint workqueue_prepare_cpu(unsigned int cpu);\nint workqueue_online_cpu(unsigned int cpu);\nint workqueue_offline_cpu(unsigned int cpu);\n#endif\n\nvoid __init workqueue_init_early(void);\nvoid __init workqueue_init(void);\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 1673}, "message": "Assuming the condition is false"}, {"location": {"col": 12, "file": 1, "line": 110}, "message": "expanded from macro 'ASSERT_RTNL'"}, {"location": {"col": 27, "file": 2, "line": 157}, "message": "expanded from macro 'WARN_ONCE'"}, {"location": {"col": 2, "file": 0, "line": 1673}, "message": "'__ret_warn_once' is 0"}, {"location": {"col": 2, "file": 1, "line": 110}, "message": "expanded from macro 'ASSERT_RTNL'"}, {"location": {"col": 15, "file": 2, "line": 159}, "message": "expanded from macro 'WARN_ONCE'"}, {"location": {"col": 42, "file": 3, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 0, "line": 1673}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 1, "line": 110}, "message": "expanded from macro 'ASSERT_RTNL'"}, {"location": {"col": 31, "file": 2, "line": 159}, "message": "expanded from macro 'WARN_ONCE'"}, {"location": {"col": 2, "file": 0, "line": 1673}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 1, "line": 110}, "message": "expanded from macro 'ASSERT_RTNL'"}, {"location": {"col": 2, "file": 2, "line": 159}, "message": "expanded from macro 'WARN_ONCE'"}, {"location": {"col": 6, "file": 0, "line": 1675}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1675}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 1678}, "message": "Calling 'ieee80211_sdata_running'"}, {"location": {"col": 2, "file": 4, "line": 1786}, "message": "Returning without writing to 'sdata->dev'"}, {"location": {"col": 6, "file": 0, "line": 1678}, "message": "Returning from 'ieee80211_sdata_running'"}, {"location": {"col": 6, "file": 0, "line": 1678}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 1678}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 1684}, "message": "Value assigned to field 'dev'"}, {"location": {"col": 3, "file": 0, "line": 1685}, "message": "Calling 'ieee80211_setup_sdata'"}, {"location": {"col": 6, "file": 0, "line": 1513}, "message": "Assuming field 'dev' is null"}, {"location": {"col": 2, "file": 0, "line": 1513}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1519}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 5, "line": 250}, "message": "expanded from macro 'INIT_WORK'"}, {"location": {"col": 2, "file": 5, "line": 241}, "message": "expanded from macro '__INIT_WORK'"}, {"location": {"col": 2, "file": 0, "line": 1520}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 5, "line": 250}, "message": "expanded from macro 'INIT_WORK'"}, {"location": {"col": 2, "file": 5, "line": 241}, "message": "expanded from macro '__INIT_WORK'"}, {"location": {"col": 2, "file": 0, "line": 1521}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 5, "line": 250}, "message": "expanded from macro 'INIT_WORK'"}, {"location": {"col": 2, "file": 5, "line": 241}, "message": "expanded from macro '__INIT_WORK'"}, {"location": {"col": 2, "file": 0, "line": 1525}, "message": "Control jumps to 'case NL80211_IFTYPE_MONITOR:'  at line 1557"}, {"location": {"col": 20, "file": 0, "line": 1558}, "message": "Access to field 'type' results in a dereference of a null pointer (loaded from field 'dev')"}, {"location": {"col": 20, "file": 0, "line": 1558}, "message": "Access to field 'type' results in a dereference of a null pointer (loaded from field 'dev')"}], "macros": [], "notes": [], "path": "/src/net/mac80211/iface.c", "reportHash": "c83780593b47ce1e669bc347ac19fa10", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
