<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/btrfs/send.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2012 Alexander Block.  All rights reserved.\n */\n\n#include <linux/bsearch.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sort.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/radix-tree.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/compat.h>\n#include <linux/crc32c.h>\n\n#include \"send.h\"\n#include \"backref.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"compression.h\"\n#include \"xattr.h\"\n\n/*\n * Maximum number of references an extent can have in order for us to attempt to\n * issue clone operations instead of write operations. This currently exists to\n * avoid hitting limitations of the backreference walking code (taking a lot of\n * time and using too much memory for extents with large number of references).\n */\n#define SEND_MAX_EXTENT_REFS\t64\n\n/*\n * A fs_path is a helper to dynamically build path names with unknown size.\n * It reallocates the internal buffer on demand.\n * It allows fast adding of path elements on the right side (normal path) and\n * fast adding to the left side (reversed path). A reversed path can also be\n * unreversed if needed.\n */\nstruct fs_path {\n\tunion {\n\t\tstruct {\n\t\t\tchar *start;\n\t\t\tchar *end;\n\n\t\t\tchar *buf;\n\t\t\tunsigned short buf_len:15;\n\t\t\tunsigned short reversed:1;\n\t\t\tchar inline_buf[];\n\t\t};\n\t\t/*\n\t\t * Average path length does not exceed 200 bytes, we'll have\n\t\t * better packing in the slab and higher chance to satisfy\n\t\t * a allocation later during send.\n\t\t */\n\t\tchar pad[256];\n\t};\n};\n#define FS_PATH_INLINE_SIZE \\\n\t(sizeof(struct fs_path) - offsetof(struct fs_path, inline_buf))\n\n\n/* reused for each extent */\nstruct clone_root {\n\tstruct btrfs_root *root;\n\tu64 ino;\n\tu64 offset;\n\n\tu64 found_refs;\n};\n\n#define SEND_CTX_MAX_NAME_CACHE_SIZE 128\n#define SEND_CTX_NAME_CACHE_CLEAN_SIZE (SEND_CTX_MAX_NAME_CACHE_SIZE * 2)\n\nstruct send_ctx {\n\tstruct file *send_filp;\n\tloff_t send_off;\n\tchar *send_buf;\n\tu32 send_size;\n\tu32 send_max_size;\n\tu64 total_send_size;\n\tu64 cmd_send_size[BTRFS_SEND_C_MAX + 1];\n\tu64 flags;\t/* 'flags' member of btrfs_ioctl_send_args is u64 */\n\n\tstruct btrfs_root *send_root;\n\tstruct btrfs_root *parent_root;\n\tstruct clone_root *clone_roots;\n\tint clone_roots_cnt;\n\n\t/* current state of the compare_tree call */\n\tstruct btrfs_path *left_path;\n\tstruct btrfs_path *right_path;\n\tstruct btrfs_key *cmp_key;\n\n\t/*\n\t * infos of the currently processed inode. In case of deleted inodes,\n\t * these are the values from the deleted inode.\n\t */\n\tu64 cur_ino;\n\tu64 cur_inode_gen;\n\tint cur_inode_new;\n\tint cur_inode_new_gen;\n\tint cur_inode_deleted;\n\tu64 cur_inode_size;\n\tu64 cur_inode_mode;\n\tu64 cur_inode_rdev;\n\tu64 cur_inode_last_extent;\n\tu64 cur_inode_next_write_offset;\n\tbool ignore_cur_inode;\n\n\tu64 send_progress;\n\n\tstruct list_head new_refs;\n\tstruct list_head deleted_refs;\n\n\tstruct radix_tree_root name_cache;\n\tstruct list_head name_cache_list;\n\tint name_cache_size;\n\n\tstruct file_ra_state ra;\n\n\t/*\n\t * We process inodes by their increasing order, so if before an\n\t * incremental send we reverse the parent/child relationship of\n\t * directories such that a directory with a lower inode number was\n\t * the parent of a directory with a higher inode number, and the one\n\t * becoming the new parent got renamed too, we can't rename/move the\n\t * directory with lower inode number when we finish processing it - we\n\t * must process the directory with higher inode number first, then\n\t * rename/move it and then rename/move the directory with lower inode\n\t * number. Example follows.\n\t *\n\t * Tree state when the first send was performed:\n\t *\n\t * .\n\t * |-- a                   (ino 257)\n\t *     |-- b               (ino 258)\n\t *         |\n\t *         |\n\t *         |-- c           (ino 259)\n\t *         |   |-- d       (ino 260)\n\t *         |\n\t *         |-- c2          (ino 261)\n\t *\n\t * Tree state when the second (incremental) send is performed:\n\t *\n\t * .\n\t * |-- a                   (ino 257)\n\t *     |-- b               (ino 258)\n\t *         |-- c2          (ino 261)\n\t *             |-- d2      (ino 260)\n\t *                 |-- cc  (ino 259)\n\t *\n\t * The sequence of steps that lead to the second state was:\n\t *\n\t * mv /a/b/c/d /a/b/c2/d2\n\t * mv /a/b/c /a/b/c2/d2/cc\n\t *\n\t * \"c\" has lower inode number, but we can't move it (2nd mv operation)\n\t * before we move \"d\", which has higher inode number.\n\t *\n\t * So we just memorize which move/rename operations must be performed\n\t * later when their respective parent is processed and moved/renamed.\n\t */\n\n\t/* Indexed by parent directory inode number. */\n\tstruct rb_root pending_dir_moves;\n\n\t/*\n\t * Reverse index, indexed by the inode number of a directory that\n\t * is waiting for the move/rename of its immediate parent before its\n\t * own move/rename can be performed.\n\t */\n\tstruct rb_root waiting_dir_moves;\n\n\t/*\n\t * A directory that is going to be rm'ed might have a child directory\n\t * which is in the pending directory moves index above. In this case,\n\t * the directory can only be removed after the move/rename of its child\n\t * is performed. Example:\n\t *\n\t * Parent snapshot:\n\t *\n\t * .                        (ino 256)\n\t * |-- a/                   (ino 257)\n\t *     |-- b/               (ino 258)\n\t *         |-- c/           (ino 259)\n\t *         |   |-- x/       (ino 260)\n\t *         |\n\t *         |-- y/           (ino 261)\n\t *\n\t * Send snapshot:\n\t *\n\t * .                        (ino 256)\n\t * |-- a/                   (ino 257)\n\t *     |-- b/               (ino 258)\n\t *         |-- YY/          (ino 261)\n\t *              |-- x/      (ino 260)\n\t *\n\t * Sequence of steps that lead to the send snapshot:\n\t * rm -f /a/b/c/foo.txt\n\t * mv /a/b/y /a/b/YY\n\t * mv /a/b/c/x /a/b/YY\n\t * rmdir /a/b/c\n\t *\n\t * When the child is processed, its move/rename is delayed until its\n\t * parent is processed (as explained above), but all other operations\n\t * like update utimes, chown, chgrp, etc, are performed and the paths\n\t * that it uses for those operations must use the orphanized name of\n\t * its parent (the directory we're going to rm later), so we need to\n\t * memorize that name.\n\t *\n\t * Indexed by the inode number of the directory to be deleted.\n\t */\n\tstruct rb_root orphan_dirs;\n};\n\nstruct pending_dir_move {\n\tstruct rb_node node;\n\tstruct list_head list;\n\tu64 parent_ino;\n\tu64 ino;\n\tu64 gen;\n\tstruct list_head update_refs;\n};\n\nstruct waiting_dir_move {\n\tstruct rb_node node;\n\tu64 ino;\n\t/*\n\t * There might be some directory that could not be removed because it\n\t * was waiting for this directory inode to be moved first. Therefore\n\t * after this directory is moved, we can try to rmdir the ino rmdir_ino.\n\t */\n\tu64 rmdir_ino;\n\tu64 rmdir_gen;\n\tbool orphanized;\n};\n\nstruct orphan_dir_info {\n\tstruct rb_node node;\n\tu64 ino;\n\tu64 gen;\n\tu64 last_dir_index_offset;\n};\n\nstruct name_cache_entry {\n\tstruct list_head list;\n\t/*\n\t * radix_tree has only 32bit entries but we need to handle 64bit inums.\n\t * We use the lower 32bit of the 64bit inum to store it in the tree. If\n\t * more then one inum would fall into the same entry, we use radix_list\n\t * to store the additional entries. radix_list is also used to store\n\t * entries where two entries have the same inum but different\n\t * generations.\n\t */\n\tstruct list_head radix_list;\n\tu64 ino;\n\tu64 gen;\n\tu64 parent_ino;\n\tu64 parent_gen;\n\tint ret;\n\tint need_later_update;\n\tint name_len;\n\tchar name[];\n};\n\n#define ADVANCE\t\t\t\t\t\t\t1\n#define ADVANCE_ONLY_NEXT\t\t\t\t\t-1\n\nenum btrfs_compare_tree_result {\n\tBTRFS_COMPARE_TREE_NEW,\n\tBTRFS_COMPARE_TREE_DELETED,\n\tBTRFS_COMPARE_TREE_CHANGED,\n\tBTRFS_COMPARE_TREE_SAME,\n};\n\n__cold\nstatic void inconsistent_snapshot_error(struct send_ctx *sctx,\n\t\t\t\t\tenum btrfs_compare_tree_result result,\n\t\t\t\t\tconst char *what)\n{\n\tconst char *result_string;\n\n\tswitch (result) {\n\tcase BTRFS_COMPARE_TREE_NEW:\n\t\tresult_string = \"new\";\n\t\tbreak;\n\tcase BTRFS_COMPARE_TREE_DELETED:\n\t\tresult_string = \"deleted\";\n\t\tbreak;\n\tcase BTRFS_COMPARE_TREE_CHANGED:\n\t\tresult_string = \"updated\";\n\t\tbreak;\n\tcase BTRFS_COMPARE_TREE_SAME:\n\t\tASSERT(0);\n\t\tresult_string = \"unchanged\";\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tresult_string = \"unexpected\";\n\t}\n\n\tbtrfs_err(sctx->send_root->fs_info,\n\t\t  \"Send: inconsistent snapshot, found %s %s for inode %llu without updated inode item, send root is %llu, parent root is %llu\",\n\t\t  result_string, what, sctx->cmp_key->objectid,\n\t\t  sctx->send_root->root_key.objectid,\n\t\t  (sctx->parent_root ?\n\t\t   sctx->parent_root->root_key.objectid : 0));\n}\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino, u64 gen);\n\nstatic int need_send_hole(struct send_ctx *sctx)\n{\n\treturn (sctx->parent_root && !sctx->cur_inode_new &&\n\t\t!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted &&\n\t\tS_ISREG(sctx->cur_inode_mode));\n}\n\nstatic void fs_path_reset(struct fs_path *p)\n{\n\tif (p->reversed) {\n\t\tp->start = p->buf + p->buf_len - 1;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start;\n\t\t*p->start = 0;\n\t}\n}\n\nstatic struct fs_path *fs_path_alloc(void)\n{\n\tstruct fs_path *p;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 0;\n\tp->buf = p->inline_buf;\n\tp->buf_len = FS_PATH_INLINE_SIZE;\n\tfs_path_reset(p);\n\treturn p;\n}\n\nstatic struct fs_path *fs_path_alloc_reversed(void)\n{\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn NULL;\n\tp->reversed = 1;\n\tfs_path_reset(p);\n\treturn p;\n}\n\nstatic void fs_path_free(struct fs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tif (p->buf != p->inline_buf)\n\t\tkfree(p->buf);\n\tkfree(p);\n}\n\nstatic int fs_path_len(struct fs_path *p)\n{\n\treturn p->end - p->start;\n}\n\nstatic int fs_path_ensure_buf(struct fs_path *p, int len)\n{\n\tchar *tmp_buf;\n\tint path_len;\n\tint old_buf_len;\n\n\tlen++;\n\n\tif (p->buf_len >= len)\n\t\treturn 0;\n\n\tif (len > PATH_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath_len = p->end - p->start;\n\told_buf_len = p->buf_len;\n\n\t/*\n\t * First time the inline_buf does not suffice\n\t */\n\tif (p->buf == p->inline_buf) {\n\t\ttmp_buf = kmalloc(len, GFP_KERNEL);\n\t\tif (tmp_buf)\n\t\t\tmemcpy(tmp_buf, p->buf, old_buf_len);\n\t} else {\n\t\ttmp_buf = krealloc(p->buf, len, GFP_KERNEL);\n\t}\n\tif (!tmp_buf)\n\t\treturn -ENOMEM;\n\tp->buf = tmp_buf;\n\t/*\n\t * The real size of the buffer is bigger, this will let the fast path\n\t * happen most of the time\n\t */\n\tp->buf_len = ksize(p->buf);\n\n\tif (p->reversed) {\n\t\ttmp_buf = p->buf + old_buf_len - path_len - 1;\n\t\tp->end = p->buf + p->buf_len - 1;\n\t\tp->start = p->end - path_len;\n\t\tmemmove(p->start, tmp_buf, path_len + 1);\n\t} else {\n\t\tp->start = p->buf;\n\t\tp->end = p->start + path_len;\n\t}\n\treturn 0;\n}\n\nstatic int fs_path_prepare_for_add(struct fs_path *p, int name_len,\n\t\t\t\t   char **prepared)\n{\n\tint ret;\n\tint new_len;\n\n\tnew_len = p->end - p->start + name_len;\n\tif (p->start != p->end)\n\t\tnew_len++;\n\tret = fs_path_ensure_buf(p, new_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (p->reversed) {\n\t\tif (p->start != p->end)\n\t\t\t*--p->start = '/';\n\t\tp->start -= name_len;\n\t\t*prepared = p->start;\n\t} else {\n\t\tif (p->start != p->end)\n\t\t\t*p->end++ = '/';\n\t\t*prepared = p->end;\n\t\tp->end += name_len;\n\t\t*p->end = 0;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_add(struct fs_path *p, const char *name, int name_len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, name_len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, name, name_len);\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_add_path(struct fs_path *p, struct fs_path *p2)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, p2->end - p2->start, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\tmemcpy(prepared, p2->start, p2->end - p2->start);\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_add_from_extent_buffer(struct fs_path *p,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  unsigned long off, int len)\n{\n\tint ret;\n\tchar *prepared;\n\n\tret = fs_path_prepare_for_add(p, len, &prepared);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tread_extent_buffer(eb, prepared, off, len);\n\nout:\n\treturn ret;\n}\n\nstatic int fs_path_copy(struct fs_path *p, struct fs_path *from)\n{\n\tint ret;\n\n\tp->reversed = from->reversed;\n\tfs_path_reset(p);\n\n\tret = fs_path_add_path(p, from);\n\n\treturn ret;\n}\n\n\nstatic void fs_path_unreverse(struct fs_path *p)\n{\n\tchar *tmp;\n\tint len;\n\n\tif (!p->reversed)\n\t\treturn;\n\n\ttmp = p->start;\n\tlen = p->end - p->start;\n\tp->start = p->buf;\n\tp->end = p->start + len;\n\tmemmove(p->start, tmp, len + 1);\n\tp->reversed = 0;\n}\n\nstatic struct btrfs_path *alloc_path_for_send(void)\n{\n\tstruct btrfs_path *path;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn NULL;\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tpath->need_commit_sem = 1;\n\treturn path;\n}\n\nstatic int write_buf(struct file *filp, const void *buf, u32 len, loff_t *off)\n{\n\tint ret;\n\tu32 pos = 0;\n\n\twhile (pos < len) {\n\t\tret = kernel_write(filp, buf + pos, len - pos, off);\n\t\t/* TODO handle that correctly */\n\t\t/*if (ret == -ERESTARTSYS) {\n\t\t\tcontinue;\n\t\t}*/\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\treturn -EIO;\n\t\t}\n\t\tpos += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tlv_put(struct send_ctx *sctx, u16 attr, const void *data, int len)\n{\n\tstruct btrfs_tlv_header *hdr;\n\tint total_len = sizeof(*hdr) + len;\n\tint left = sctx->send_max_size - sctx->send_size;\n\n\tif (unlikely(left < total_len))\n\t\treturn -EOVERFLOW;\n\n\thdr = (struct btrfs_tlv_header *) (sctx->send_buf + sctx->send_size);\n\tput_unaligned_le16(attr, &hdr->tlv_type);\n\tput_unaligned_le16(len, &hdr->tlv_len);\n\tmemcpy(hdr + 1, data, len);\n\tsctx->send_size += total_len;\n\n\treturn 0;\n}\n\n#define TLV_PUT_DEFINE_INT(bits) \\\n\tstatic int tlv_put_u##bits(struct send_ctx *sctx,\t \t\\\n\t\t\tu##bits attr, u##bits value)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t__le##bits __tmp = cpu_to_le##bits(value);\t\t\\\n\t\treturn tlv_put(sctx, attr, &__tmp, sizeof(__tmp));\t\\\n\t}\n\nTLV_PUT_DEFINE_INT(64)\n\nstatic int tlv_put_string(struct send_ctx *sctx, u16 attr,\n\t\t\t  const char *str, int len)\n{\n\tif (len == -1)\n\t\tlen = strlen(str);\n\treturn tlv_put(sctx, attr, str, len);\n}\n\nstatic int tlv_put_uuid(struct send_ctx *sctx, u16 attr,\n\t\t\tconst u8 *uuid)\n{\n\treturn tlv_put(sctx, attr, uuid, BTRFS_UUID_SIZE);\n}\n\nstatic int tlv_put_btrfs_timespec(struct send_ctx *sctx, u16 attr,\n\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_timespec *ts)\n{\n\tstruct btrfs_timespec bts;\n\tread_extent_buffer(eb, &bts, (unsigned long)ts, sizeof(bts));\n\treturn tlv_put(sctx, attr, &bts, sizeof(bts));\n}\n\n\n#define TLV_PUT(sctx, attrtype, data, attrlen) \\\n\tdo { \\\n\t\tret = tlv_put(sctx, attrtype, data, attrlen); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n\n#define TLV_PUT_INT(sctx, attrtype, bits, value) \\\n\tdo { \\\n\t\tret = tlv_put_u##bits(sctx, attrtype, value); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n\n#define TLV_PUT_U8(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 8, data)\n#define TLV_PUT_U16(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 16, data)\n#define TLV_PUT_U32(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 32, data)\n#define TLV_PUT_U64(sctx, attrtype, data) TLV_PUT_INT(sctx, attrtype, 64, data)\n#define TLV_PUT_STRING(sctx, attrtype, str, len) \\\n\tdo { \\\n\t\tret = tlv_put_string(sctx, attrtype, str, len); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n#define TLV_PUT_PATH(sctx, attrtype, p) \\\n\tdo { \\\n\t\tret = tlv_put_string(sctx, attrtype, p->start, \\\n\t\t\tp->end - p->start); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while(0)\n#define TLV_PUT_UUID(sctx, attrtype, uuid) \\\n\tdo { \\\n\t\tret = tlv_put_uuid(sctx, attrtype, uuid); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n#define TLV_PUT_BTRFS_TIMESPEC(sctx, attrtype, eb, ts) \\\n\tdo { \\\n\t\tret = tlv_put_btrfs_timespec(sctx, attrtype, eb, ts); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto tlv_put_failure; \\\n\t} while (0)\n\nstatic int send_header(struct send_ctx *sctx)\n{\n\tstruct btrfs_stream_header hdr;\n\n\tstrcpy(hdr.magic, BTRFS_SEND_STREAM_MAGIC);\n\thdr.version = cpu_to_le32(BTRFS_SEND_STREAM_VERSION);\n\n\treturn write_buf(sctx->send_filp, &hdr, sizeof(hdr),\n\t\t\t\t\t&sctx->send_off);\n}\n\n/*\n * For each command/item we want to send to userspace, we call this function.\n */\nstatic int begin_cmd(struct send_ctx *sctx, int cmd)\n{\n\tstruct btrfs_cmd_header *hdr;\n\n\tif (WARN_ON(!sctx->send_buf))\n\t\treturn -EINVAL;\n\n\tBUG_ON(sctx->send_size);\n\n\tsctx->send_size += sizeof(*hdr);\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\tput_unaligned_le16(cmd, &hdr->cmd);\n\n\treturn 0;\n}\n\nstatic int send_cmd(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_cmd_header *hdr;\n\tu32 crc;\n\n\thdr = (struct btrfs_cmd_header *)sctx->send_buf;\n\tput_unaligned_le32(sctx->send_size - sizeof(*hdr), &hdr->len);\n\tput_unaligned_le32(0, &hdr->crc);\n\n\tcrc = btrfs_crc32c(0, (unsigned char *)sctx->send_buf, sctx->send_size);\n\tput_unaligned_le32(crc, &hdr->crc);\n\n\tret = write_buf(sctx->send_filp, sctx->send_buf, sctx->send_size,\n\t\t\t\t\t&sctx->send_off);\n\n\tsctx->total_send_size += sctx->send_size;\n\tsctx->cmd_send_size[get_unaligned_le16(&hdr->cmd)] += sctx->send_size;\n\tsctx->send_size = 0;\n\n\treturn ret;\n}\n\n/*\n * Sends a move instruction to user space\n */\nstatic int send_rename(struct send_ctx *sctx,\n\t\t     struct fs_path *from, struct fs_path *to)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_rename %s -> %s\", from->start, to->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RENAME);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, from);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_TO, to);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n/*\n * Sends a link instruction to user space\n */\nstatic int send_link(struct send_ctx *sctx,\n\t\t     struct fs_path *path, struct fs_path *lnk)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_link %s -> %s\", path->start, lnk->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_LINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, lnk);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n/*\n * Sends an unlink instruction to user space\n */\nstatic int send_unlink(struct send_ctx *sctx, struct fs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_unlink %s\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UNLINK);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n/*\n * Sends a rmdir instruction to user space\n */\nstatic int send_rmdir(struct send_ctx *sctx, struct fs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\n\tbtrfs_debug(fs_info, \"send_rmdir %s\", path->start);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_RMDIR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\n/*\n * Helper function to retrieve some fields from an inode item.\n */\nstatic int __get_inode_info(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t  u64 ino, u64 *size, u64 *gen, u64 *mode, u64 *uid,\n\t\t\t  u64 *gid, u64 *rdev)\n{\n\tint ret;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_key key;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\n\tii = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_inode_item);\n\tif (size)\n\t\t*size = btrfs_inode_size(path->nodes[0], ii);\n\tif (gen)\n\t\t*gen = btrfs_inode_generation(path->nodes[0], ii);\n\tif (mode)\n\t\t*mode = btrfs_inode_mode(path->nodes[0], ii);\n\tif (uid)\n\t\t*uid = btrfs_inode_uid(path->nodes[0], ii);\n\tif (gid)\n\t\t*gid = btrfs_inode_gid(path->nodes[0], ii);\n\tif (rdev)\n\t\t*rdev = btrfs_inode_rdev(path->nodes[0], ii);\n\n\treturn ret;\n}\n\nstatic int get_inode_info(struct btrfs_root *root,\n\t\t\t  u64 ino, u64 *size, u64 *gen,\n\t\t\t  u64 *mode, u64 *uid, u64 *gid,\n\t\t\t  u64 *rdev)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = __get_inode_info(root, path, ino, size, gen, mode, uid, gid,\n\t\t\t       rdev);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\ntypedef int (*iterate_inode_ref_t)(int num, u64 dir, int index,\n\t\t\t\t   struct fs_path *p,\n\t\t\t\t   void *ctx);\n\n/*\n * Helper function to iterate the entries in ONE btrfs_inode_ref or\n * btrfs_inode_extref.\n * The iterate callback may return a non zero value to stop iteration. This can\n * be a negative value for error codes or 1 to simply stop it.\n *\n * path must point to the INODE_REF or INODE_EXTREF when called.\n */\nstatic int iterate_inode_ref(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *found_key, int resolve,\n\t\t\t     iterate_inode_ref_t iterate, void *ctx)\n{\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_inode_extref *extref;\n\tstruct btrfs_path *tmp_path;\n\tstruct fs_path *p;\n\tu32 cur = 0;\n\tu32 total;\n\tint slot = path->slots[0];\n\tu32 name_len;\n\tchar *start;\n\tint ret = 0;\n\tint num = 0;\n\tint index;\n\tu64 dir;\n\tunsigned long name_off;\n\tunsigned long elem_size;\n\tunsigned long ptr;\n\n\tp = fs_path_alloc_reversed();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path) {\n\t\tfs_path_free(p);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\tptr = (unsigned long)btrfs_item_ptr(eb, slot,\n\t\t\t\t\t\t    struct btrfs_inode_ref);\n\t\titem = btrfs_item_nr(slot);\n\t\ttotal = btrfs_item_size(eb, item);\n\t\telem_size = sizeof(*iref);\n\t} else {\n\t\tptr = btrfs_item_ptr_offset(eb, slot);\n\t\ttotal = btrfs_item_size_nr(eb, slot);\n\t\telem_size = sizeof(*extref);\n\t}\n\n\twhile (cur < total) {\n\t\tfs_path_reset(p);\n\n\t\tif (found_key->type == BTRFS_INODE_REF_KEY) {\n\t\t\tiref = (struct btrfs_inode_ref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\tname_off = (unsigned long)(iref + 1);\n\t\t\tindex = btrfs_inode_ref_index(eb, iref);\n\t\t\tdir = found_key->offset;\n\t\t} else {\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tname_off = (unsigned long)&extref->name;\n\t\t\tindex = btrfs_inode_extref_index(eb, extref);\n\t\t\tdir = btrfs_inode_extref_parent(eb, extref);\n\t\t}\n\n\t\tif (resolve) {\n\t\t\tstart = btrfs_ref_to_path(root, tmp_path, name_len,\n\t\t\t\t\t\t  name_off, eb, dir,\n\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\tif (IS_ERR(start)) {\n\t\t\t\tret = PTR_ERR(start);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (start < p->buf) {\n\t\t\t\t/* overflow , try again with larger buffer */\n\t\t\t\tret = fs_path_ensure_buf(p,\n\t\t\t\t\t\tp->buf_len + p->buf - start);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tstart = btrfs_ref_to_path(root, tmp_path,\n\t\t\t\t\t\t\t  name_len, name_off,\n\t\t\t\t\t\t\t  eb, dir,\n\t\t\t\t\t\t\t  p->buf, p->buf_len);\n\t\t\t\tif (IS_ERR(start)) {\n\t\t\t\t\tret = PTR_ERR(start);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tBUG_ON(start < p->buf);\n\t\t\t}\n\t\t\tp->start = start;\n\t\t} else {\n\t\t\tret = fs_path_add_from_extent_buffer(p, eb, name_off,\n\t\t\t\t\t\t\t     name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcur += elem_size + name_len;\n\t\tret = iterate(num, dir, index, p, ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tnum++;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tfs_path_free(p);\n\treturn ret;\n}\n\ntypedef int (*iterate_dir_item_t)(int num, struct btrfs_key *di_key,\n\t\t\t\t  const char *name, int name_len,\n\t\t\t\t  const char *data, int data_len,\n\t\t\t\t  u8 type, void *ctx);\n\n/*\n * Helper function to iterate the entries in ONE btrfs_dir_item.\n * The iterate callback may return a non zero value to stop iteration. This can\n * be a negative value for error codes or 1 to simply stop it.\n *\n * path must point to the dir item when called.\n */\nstatic int iterate_dir_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    iterate_dir_item_t iterate, void *ctx)\n{\n\tint ret = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key di_key;\n\tchar *buf = NULL;\n\tint buf_len;\n\tu32 name_len;\n\tu32 data_len;\n\tu32 cur;\n\tu32 len;\n\tu32 total;\n\tint slot;\n\tint num;\n\tu8 type;\n\n\t/*\n\t * Start with a small buffer (1 page). If later we end up needing more\n\t * space, which can happen for xattrs on a fs with a leaf size greater\n\t * then the page size, attempt to increase the buffer. Typically xattr\n\t * values are small.\n\t */\n\tbuf_len = PATH_MAX;\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\titem = btrfs_item_nr(slot);\n\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\tcur = 0;\n\tlen = 0;\n\ttotal = btrfs_item_size(eb, item);\n\n\tnum = 0;\n\twhile (cur < total) {\n\t\tname_len = btrfs_dir_name_len(eb, di);\n\t\tdata_len = btrfs_dir_data_len(eb, di);\n\t\ttype = btrfs_dir_type(eb, di);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (type == BTRFS_FT_XATTR) {\n\t\t\tif (name_len > XATTR_NAME_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (name_len + data_len >\n\t\t\t\t\tBTRFS_MAX_XATTR_SIZE(root->fs_info)) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Path too long\n\t\t\t */\n\t\t\tif (name_len + data_len > PATH_MAX) {\n\t\t\t\tret = -ENAMETOOLONG;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (name_len + data_len > buf_len) {\n\t\t\tbuf_len = name_len + data_len;\n\t\t\tif (is_vmalloc_addr(buf)) {\n\t\t\t\tvfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t} else {\n\t\t\t\tchar *tmp = krealloc(buf, buf_len,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\n\t\t\t\tif (!tmp)\n\t\t\t\t\tkfree(buf);\n\t\t\t\tbuf = tmp;\n\t\t\t}\n\t\t\tif (!buf) {\n\t\t\t\tbuf = kvmalloc(buf_len, GFP_KERNEL);\n\t\t\t\tif (!buf) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tread_extent_buffer(eb, buf, (unsigned long)(di + 1),\n\t\t\t\tname_len + data_len);\n\n\t\tlen = sizeof(*di) + name_len + data_len;\n\t\tdi = (struct btrfs_dir_item *)((char *)di + len);\n\t\tcur += len;\n\n\t\tret = iterate(num, &di_key, buf, name_len, buf + name_len,\n\t\t\t\tdata_len, type, ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnum++;\n\t}\n\nout:\n\tkvfree(buf);\n\treturn ret;\n}\n\nstatic int __copy_first_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *p, void *ctx)\n{\n\tint ret;\n\tstruct fs_path *pt = ctx;\n\n\tret = fs_path_copy(pt, p);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* we want the first only */\n\treturn 1;\n}\n\n/*\n * Retrieve the first path of an inode. If an inode has more then one\n * ref/hardlink, this is ignored.\n */\nstatic int get_inode_path(struct btrfs_root *root,\n\t\t\t  u64 ino, struct fs_path *path)\n{\n\tint ret;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *p;\n\n\tp = alloc_path_for_send();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(path);\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, p, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tbtrfs_item_key_to_cpu(p->nodes[0], &found_key, p->slots[0]);\n\tif (found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = iterate_inode_ref(root, p, &found_key, 1,\n\t\t\t\t__copy_first_ref, path);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tbtrfs_free_path(p);\n\treturn ret;\n}\n\nstruct backref_ctx {\n\tstruct send_ctx *sctx;\n\n\t/* number of total found references */\n\tu64 found;\n\n\t/*\n\t * used for clones found in send_root. clones found behind cur_objectid\n\t * and cur_offset are not considered as allowed clones.\n\t */\n\tu64 cur_objectid;\n\tu64 cur_offset;\n\n\t/* may be truncated in case it's the last extent in a file */\n\tu64 extent_len;\n\n\t/* Just to check for bugs in backref resolving */\n\tint found_itself;\n};\n\nstatic int __clone_root_cmp_bsearch(const void *key, const void *elt)\n{\n\tu64 root = (u64)(uintptr_t)key;\n\tstruct clone_root *cr = (struct clone_root *)elt;\n\n\tif (root < cr->root->root_key.objectid)\n\t\treturn -1;\n\tif (root > cr->root->root_key.objectid)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int __clone_root_cmp_sort(const void *e1, const void *e2)\n{\n\tstruct clone_root *cr1 = (struct clone_root *)e1;\n\tstruct clone_root *cr2 = (struct clone_root *)e2;\n\n\tif (cr1->root->root_key.objectid < cr2->root->root_key.objectid)\n\t\treturn -1;\n\tif (cr1->root->root_key.objectid > cr2->root->root_key.objectid)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Called for every backref that is found for the current extent.\n * Results are collected in sctx->clone_roots->ino/offset/found_refs\n */\nstatic int __iterate_backrefs(u64 ino, u64 offset, u64 root, void *ctx_)\n{\n\tstruct backref_ctx *bctx = ctx_;\n\tstruct clone_root *found;\n\n\t/* First check if the root is in the list of accepted clone sources */\n\tfound = bsearch((void *)(uintptr_t)root, bctx->sctx->clone_roots,\n\t\t\tbctx->sctx->clone_roots_cnt,\n\t\t\tsizeof(struct clone_root),\n\t\t\t__clone_root_cmp_bsearch);\n\tif (!found)\n\t\treturn 0;\n\n\tif (found->root == bctx->sctx->send_root &&\n\t    ino == bctx->cur_objectid &&\n\t    offset == bctx->cur_offset) {\n\t\tbctx->found_itself = 1;\n\t}\n\n\t/*\n\t * Make sure we don't consider clones from send_root that are\n\t * behind the current inode/offset.\n\t */\n\tif (found->root == bctx->sctx->send_root) {\n\t\t/*\n\t\t * If the source inode was not yet processed we can't issue a\n\t\t * clone operation, as the source extent does not exist yet at\n\t\t * the destination of the stream.\n\t\t */\n\t\tif (ino > bctx->cur_objectid)\n\t\t\treturn 0;\n\t\t/*\n\t\t * We clone from the inode currently being sent as long as the\n\t\t * source extent is already processed, otherwise we could try\n\t\t * to clone from an extent that does not exist yet at the\n\t\t * destination of the stream.\n\t\t */\n\t\tif (ino == bctx->cur_objectid &&\n\t\t    offset + bctx->extent_len >\n\t\t    bctx->sctx->cur_inode_next_write_offset)\n\t\t\treturn 0;\n\t}\n\n\tbctx->found++;\n\tfound->found_refs++;\n\tif (ino < found->ino) {\n\t\tfound->ino = ino;\n\t\tfound->offset = offset;\n\t} else if (found->ino == ino) {\n\t\t/*\n\t\t * same extent found more then once in the same file.\n\t\t */\n\t\tif (found->offset > offset + bctx->extent_len)\n\t\t\tfound->offset = offset;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Given an inode, offset and extent item, it finds a good clone for a clone\n * instruction. Returns -ENOENT when none could be found. The function makes\n * sure that the returned clone is usable at the point where sending is at the\n * moment. This means, that no clones are accepted which lie behind the current\n * inode+offset.\n *\n * path must point to the extent item when called.\n */\nstatic int find_extent_clone(struct send_ctx *sctx,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     u64 ino, u64 data_offset,\n\t\t\t     u64 ino_size,\n\t\t\t     struct clone_root **found)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret;\n\tint extent_type;\n\tu64 logical;\n\tu64 disk_byte;\n\tu64 num_bytes;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *eb = path->nodes[0];\n\tstruct backref_ctx *backref_ctx = NULL;\n\tstruct clone_root *cur_clone_root;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *tmp_path;\n\tstruct btrfs_extent_item *ei;\n\tint compressed;\n\tu32 i;\n\n\ttmp_path = alloc_path_for_send();\n\tif (!tmp_path)\n\t\treturn -ENOMEM;\n\n\t/* We only use this path under the commit sem */\n\ttmp_path->need_commit_sem = 0;\n\n\tbackref_ctx = kmalloc(sizeof(*backref_ctx), GFP_KERNEL);\n\tif (!backref_ctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (data_offset >= ino_size) {\n\t\t/*\n\t\t * There may be extents that lie behind the file's size.\n\t\t * I at least had this in combination with snapshotting while\n\t\t * writing large files.\n\t\t */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfi = btrfs_item_ptr(eb, path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\textent_type = btrfs_file_extent_type(eb, fi);\n\tif (extent_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tcompressed = btrfs_file_extent_compression(eb, fi);\n\n\tnum_bytes = btrfs_file_extent_num_bytes(eb, fi);\n\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\tif (disk_byte == 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tlogical = disk_byte + btrfs_file_extent_offset(eb, fi);\n\n\tdown_read(&fs_info->commit_root_sem);\n\tret = extent_from_logical(fs_info, disk_byte, tmp_path,\n\t\t\t\t  &found_key, &flags);\n\tup_read(&fs_info->commit_root_sem);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tei = btrfs_item_ptr(tmp_path->nodes[0], tmp_path->slots[0],\n\t\t\t    struct btrfs_extent_item);\n\t/*\n\t * Backreference walking (iterate_extent_inodes() below) is currently\n\t * too expensive when an extent has a large number of references, both\n\t * in time spent and used memory. So for now just fallback to write\n\t * operations instead of clone operations when an extent has more than\n\t * a certain amount of references.\n\t */\n\tif (btrfs_extent_refs(tmp_path->nodes[0], ei) > SEND_MAX_EXTENT_REFS) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tbtrfs_release_path(tmp_path);\n\n\t/*\n\t * Setup the clone roots.\n\t */\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tcur_clone_root = sctx->clone_roots + i;\n\t\tcur_clone_root->ino = (u64)-1;\n\t\tcur_clone_root->offset = 0;\n\t\tcur_clone_root->found_refs = 0;\n\t}\n\n\tbackref_ctx->sctx = sctx;\n\tbackref_ctx->found = 0;\n\tbackref_ctx->cur_objectid = ino;\n\tbackref_ctx->cur_offset = data_offset;\n\tbackref_ctx->found_itself = 0;\n\tbackref_ctx->extent_len = num_bytes;\n\n\t/*\n\t * The last extent of a file may be too large due to page alignment.\n\t * We need to adjust extent_len in this case so that the checks in\n\t * __iterate_backrefs work.\n\t */\n\tif (data_offset + num_bytes >= ino_size)\n\t\tbackref_ctx->extent_len = ino_size - data_offset;\n\n\t/*\n\t * Now collect all backrefs.\n\t */\n\tif (compressed == BTRFS_COMPRESS_NONE)\n\t\textent_item_pos = logical - found_key.objectid;\n\telse\n\t\textent_item_pos = 0;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t    extent_item_pos, 1, __iterate_backrefs,\n\t\t\t\t    backref_ctx, false);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!backref_ctx->found_itself) {\n\t\t/* found a bug in backref code? */\n\t\tret = -EIO;\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"did not find backref in send_root. inode=%llu, offset=%llu, disk_byte=%llu found extent=%llu\",\n\t\t\t  ino, data_offset, disk_byte, found_key.objectid);\n\t\tgoto out;\n\t}\n\n\tbtrfs_debug(fs_info,\n\t\t    \"find_extent_clone: data_offset=%llu, ino=%llu, num_bytes=%llu, logical=%llu\",\n\t\t    data_offset, ino, num_bytes, logical);\n\n\tif (!backref_ctx->found)\n\t\tbtrfs_debug(fs_info, \"no clones found\");\n\n\tcur_clone_root = NULL;\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\tif (sctx->clone_roots[i].found_refs) {\n\t\t\tif (!cur_clone_root)\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t\telse if (sctx->clone_roots[i].root == sctx->send_root)\n\t\t\t\t/* prefer clones from send_root over others */\n\t\t\t\tcur_clone_root = sctx->clone_roots + i;\n\t\t}\n\n\t}\n\n\tif (cur_clone_root) {\n\t\t*found = cur_clone_root;\n\t\tret = 0;\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\tbtrfs_free_path(tmp_path);\n\tkfree(backref_ctx);\n\treturn ret;\n}\n\nstatic int read_symlink(struct btrfs_root *root,\n\t\t\tu64 ino,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *ei;\n\tu8 type;\n\tu8 compression;\n\tunsigned long off;\n\tint len;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\t/*\n\t\t * An empty symlink inode. Can happen in rare error paths when\n\t\t * creating a symlink (transaction committed before the inode\n\t\t * eviction handler removed the symlink inode items and a crash\n\t\t * happened in between or the subvol was snapshoted in between).\n\t\t * Print an informative message to dmesg/syslog so that the user\n\t\t * can delete the symlink.\n\t\t */\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"Found empty symlink inode %llu at root %llu\",\n\t\t\t  ino, root->root_key.objectid);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\tstruct btrfs_file_extent_item);\n\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\tcompression = btrfs_file_extent_compression(path->nodes[0], ei);\n\tBUG_ON(type != BTRFS_FILE_EXTENT_INLINE);\n\tBUG_ON(compression);\n\n\toff = btrfs_file_extent_inline_start(ei);\n\tlen = btrfs_file_extent_ram_bytes(path->nodes[0], ei);\n\n\tret = fs_path_add_from_extent_buffer(dest, path->nodes[0], off, len);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * Helper function to generate a file name that is unique in the root of\n * send_root and parent_root. This is used to generate names for orphan inodes.\n */\nstatic int gen_unique_name(struct send_ctx *sctx,\n\t\t\t   u64 ino, u64 gen,\n\t\t\t   struct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tchar tmp[64];\n\tint len;\n\tu64 idx = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twhile (1) {\n\t\tlen = snprintf(tmp, sizeof(tmp), \"o%llu-%llu-%llu\",\n\t\t\t\tino, gen, idx);\n\t\tASSERT(len < sizeof(tmp));\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->send_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sctx->parent_root) {\n\t\t\t/* unique */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdi = btrfs_lookup_dir_item(NULL, sctx->parent_root,\n\t\t\t\tpath, BTRFS_FIRST_FREE_OBJECTID,\n\t\t\t\ttmp, strlen(tmp), 0);\n\t\tbtrfs_release_path(path);\n\t\tif (IS_ERR(di)) {\n\t\t\tret = PTR_ERR(di);\n\t\t\tgoto out;\n\t\t}\n\t\tif (di) {\n\t\t\t/* not unique, try again */\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* unique */\n\t\tbreak;\n\t}\n\n\tret = fs_path_add(dest, tmp, strlen(tmp));\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nenum inode_state {\n\tinode_state_no_change,\n\tinode_state_will_create,\n\tinode_state_did_create,\n\tinode_state_will_delete,\n\tinode_state_did_delete,\n};\n\nstatic int get_cur_inode_state(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\tint left_ret;\n\tint right_ret;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tret = get_inode_info(sctx->send_root, ino, NULL, &left_gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tleft_ret = ret;\n\n\tif (!sctx->parent_root) {\n\t\tright_ret = -ENOENT;\n\t} else {\n\t\tret = get_inode_info(sctx->parent_root, ino, NULL, &right_gen,\n\t\t\t\tNULL, NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tright_ret = ret;\n\t}\n\n\tif (!left_ret && !right_ret) {\n\t\tif (left_gen == gen && right_gen == gen) {\n\t\t\tret = inode_state_no_change;\n\t\t} else if (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else if (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else  {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!left_ret) {\n\t\tif (left_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_create;\n\t\t\telse\n\t\t\t\tret = inode_state_will_create;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else if (!right_ret) {\n\t\tif (right_gen == gen) {\n\t\t\tif (ino < sctx->send_progress)\n\t\t\t\tret = inode_state_did_delete;\n\t\t\telse\n\t\t\t\tret = inode_state_will_delete;\n\t\t} else {\n\t\t\tret = -ENOENT;\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int is_inode_existent(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret;\n\n\tif (ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\n\tret = get_cur_inode_state(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret == inode_state_no_change ||\n\t    ret == inode_state_did_create ||\n\t    ret == inode_state_will_delete)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\n/*\n * Helper function to lookup a dir item in a dir.\n */\nstatic int lookup_dir_item_inode(struct btrfs_root *root,\n\t\t\t\t u64 dir, const char *name, int name_len,\n\t\t\t\t u64 *found_inode,\n\t\t\t\t u8 *found_type)\n{\n\tint ret = 0;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_dir_item(NULL, root, path,\n\t\t\tdir, name, name_len, 0);\n\tif (IS_ERR_OR_NULL(di)) {\n\t\tret = di ? PTR_ERR(di) : -ENOENT;\n\t\tgoto out;\n\t}\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &key);\n\tif (key.type == BTRFS_ROOT_ITEM_KEY) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*found_inode = key.objectid;\n\t*found_type = btrfs_dir_type(path->nodes[0], di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * Looks up the first btrfs_inode_ref of a given ino. It returns the parent dir,\n * generation of the parent dir and the name of the dir entry.\n */\nstatic int get_first_ref(struct btrfs_root *root, u64 ino,\n\t\t\t u64 *dir, u64 *dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_path *path;\n\tint len;\n\tu64 parent_dir;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret)\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\tpath->slots[0]);\n\tif (ret || found_key.objectid != ino ||\n\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t     found_key.type != BTRFS_INODE_EXTREF_KEY)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (found_key.type == BTRFS_INODE_REF_KEY) {\n\t\tstruct btrfs_inode_ref *iref;\n\t\tiref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_inode_ref);\n\t\tlen = btrfs_inode_ref_name_len(path->nodes[0], iref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t\t     (unsigned long)(iref + 1),\n\t\t\t\t\t\t     len);\n\t\tparent_dir = found_key.offset;\n\t} else {\n\t\tstruct btrfs_inode_extref *extref;\n\t\textref = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t\tstruct btrfs_inode_extref);\n\t\tlen = btrfs_inode_extref_name_len(path->nodes[0], extref);\n\t\tret = fs_path_add_from_extent_buffer(name, path->nodes[0],\n\t\t\t\t\t(unsigned long)&extref->name, len);\n\t\tparent_dir = btrfs_inode_extref_parent(path->nodes[0], extref);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\tbtrfs_release_path(path);\n\n\tif (dir_gen) {\n\t\tret = get_inode_info(root, parent_dir, NULL, dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t*dir = parent_dir;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int is_first_ref(struct btrfs_root *root,\n\t\t\tu64 ino, u64 dir,\n\t\t\tconst char *name, int name_len)\n{\n\tint ret;\n\tstruct fs_path *tmp_name;\n\tu64 tmp_dir;\n\n\ttmp_name = fs_path_alloc();\n\tif (!tmp_name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(root, ino, &tmp_dir, NULL, tmp_name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (dir != tmp_dir || name_len != fs_path_len(tmp_name)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = !memcmp(tmp_name->start, name, name_len);\n\nout:\n\tfs_path_free(tmp_name);\n\treturn ret;\n}\n\n/*\n * Used by process_recorded_refs to determine if a new ref would overwrite an\n * already existing ref. In case it detects an overwrite, it returns the\n * inode/gen in who_ino/who_gen.\n * When an overwrite is detected, process_recorded_refs does proper orphanizing\n * to make sure later references to the overwritten inode are possible.\n * Orphanizing is however only required for the first ref of an inode.\n * process_recorded_refs does an additional is_first_ref check to see if\n * orphanizing is really required.\n */\nstatic int will_overwrite_ref(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t\t      const char *name, int name_len,\n\t\t\t      u64 *who_ino, u64 *who_gen, u64 *who_mode)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 other_inode = 0;\n\tu8 other_type = 0;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\t/*\n\t * If we have a parent root we need to verify that the parent dir was\n\t * not deleted and then re-created, if it was then we have no overwrite\n\t * and we can just unlink this entry.\n\t */\n\tif (sctx->parent_root && dir != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = get_inode_info(sctx->parent_root, dir, NULL, &gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (gen != dir_gen)\n\t\t\tgoto out;\n\t}\n\n\tret = lookup_dir_item_inode(sctx->parent_root, dir, name, name_len,\n\t\t\t&other_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check if the overwritten ref was already processed. If yes, the ref\n\t * was already unlinked/moved, so we can safely assume that we will not\n\t * overwrite anything at this point in time.\n\t */\n\tif (other_inode > sctx->send_progress ||\n\t    is_waiting_for_move(sctx, other_inode)) {\n\t\tret = get_inode_info(sctx->parent_root, other_inode, NULL,\n\t\t\t\twho_gen, who_mode, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = 1;\n\t\t*who_ino = other_inode;\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}\n\n/*\n * Checks if the ref was overwritten by an already processed inode. This is\n * used by __get_cur_name_and_parent to find out if the ref was orphanized and\n * thus the orphan name needs be used.\n * process_recorded_refs also uses it to avoid unlinking of refs that were\n * overwritten.\n */\nstatic int did_overwrite_ref(struct send_ctx *sctx,\n\t\t\t    u64 dir, u64 dir_gen,\n\t\t\t    u64 ino, u64 ino_gen,\n\t\t\t    const char *name, int name_len)\n{\n\tint ret = 0;\n\tu64 gen;\n\tu64 ow_inode;\n\tu8 other_type;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tret = is_inode_existent(sctx, dir, dir_gen);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (dir != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = get_inode_info(sctx->send_root, dir, NULL, &gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (gen != dir_gen)\n\t\t\tgoto out;\n\t}\n\n\t/* check if the ref was overwritten by another ref */\n\tret = lookup_dir_item_inode(sctx->send_root, dir, name, name_len,\n\t\t\t&ow_inode, &other_type);\n\tif (ret < 0 && ret != -ENOENT)\n\t\tgoto out;\n\tif (ret) {\n\t\t/* was never and will never be overwritten */\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->send_root, ow_inode, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ow_inode == ino && gen == ino_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We know that it is or will be overwritten. Check this now.\n\t * The current inode being processed might have been the one that caused\n\t * inode 'ino' to be orphanized, therefore check if ow_inode matches\n\t * the current inode being processed.\n\t */\n\tif ((ow_inode < sctx->send_progress) ||\n\t    (ino != sctx->cur_ino && ow_inode == sctx->cur_ino &&\n\t     gen == sctx->cur_inode_gen))\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}\n\n/*\n * Same as did_overwrite_ref, but also checks if it is the first ref of an inode\n * that got overwritten. This is used by process_recorded_refs to determine\n * if it has to use the path as returned by get_cur_path or the orphan name.\n */\nstatic int did_overwrite_first_ref(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 dir;\n\tu64 dir_gen;\n\n\tif (!sctx->parent_root)\n\t\tgoto out;\n\n\tname = fs_path_alloc();\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tret = get_first_ref(sctx->parent_root, ino, &dir, &dir_gen, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = did_overwrite_ref(sctx, dir, dir_gen, ino, gen,\n\t\t\tname->start, fs_path_len(name));\n\nout:\n\tfs_path_free(name);\n\treturn ret;\n}\n\n/*\n * Insert a name cache entry. On 32bit kernels the radix tree index is 32bit,\n * so we need to do some special handling in case we have clashes. This function\n * takes care of this with the help of name_cache_entry::radix_list.\n * In case of error, nce is kfreed.\n */\nstatic int name_cache_insert(struct send_ctx *sctx,\n\t\t\t     struct name_cache_entry *nce)\n{\n\tint ret = 0;\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tnce_head = kmalloc(sizeof(*nce_head), GFP_KERNEL);\n\t\tif (!nce_head) {\n\t\t\tkfree(nce);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_LIST_HEAD(nce_head);\n\n\t\tret = radix_tree_insert(&sctx->name_cache, nce->ino, nce_head);\n\t\tif (ret < 0) {\n\t\t\tkfree(nce_head);\n\t\t\tkfree(nce);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tlist_add_tail(&nce->radix_list, nce_head);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n\tsctx->name_cache_size++;\n\n\treturn ret;\n}\n\nstatic void name_cache_delete(struct send_ctx *sctx,\n\t\t\t      struct name_cache_entry *nce)\n{\n\tstruct list_head *nce_head;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache,\n\t\t\t(unsigned long)nce->ino);\n\tif (!nce_head) {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t      \"name_cache_delete lookup failed ino %llu cache size %d, leaking memory\",\n\t\t\tnce->ino, sctx->name_cache_size);\n\t}\n\n\tlist_del(&nce->radix_list);\n\tlist_del(&nce->list);\n\tsctx->name_cache_size--;\n\n\t/*\n\t * We may not get to the final release of nce_head if the lookup fails\n\t */\n\tif (nce_head && list_empty(nce_head)) {\n\t\tradix_tree_delete(&sctx->name_cache, (unsigned long)nce->ino);\n\t\tkfree(nce_head);\n\t}\n}\n\nstatic struct name_cache_entry *name_cache_search(struct send_ctx *sctx,\n\t\t\t\t\t\t    u64 ino, u64 gen)\n{\n\tstruct list_head *nce_head;\n\tstruct name_cache_entry *cur;\n\n\tnce_head = radix_tree_lookup(&sctx->name_cache, (unsigned long)ino);\n\tif (!nce_head)\n\t\treturn NULL;\n\n\tlist_for_each_entry(cur, nce_head, radix_list) {\n\t\tif (cur->ino == ino && cur->gen == gen)\n\t\t\treturn cur;\n\t}\n\treturn NULL;\n}\n\n/*\n * Removes the entry from the list and adds it back to the end. This marks the\n * entry as recently used so that name_cache_clean_unused does not remove it.\n */\nstatic void name_cache_used(struct send_ctx *sctx, struct name_cache_entry *nce)\n{\n\tlist_del(&nce->list);\n\tlist_add_tail(&nce->list, &sctx->name_cache_list);\n}\n\n/*\n * Remove some entries from the beginning of name_cache_list.\n */\nstatic void name_cache_clean_unused(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\tif (sctx->name_cache_size < SEND_CTX_NAME_CACHE_CLEAN_SIZE)\n\t\treturn;\n\n\twhile (sctx->name_cache_size > SEND_CTX_MAX_NAME_CACHE_SIZE) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}\n\nstatic void name_cache_free(struct send_ctx *sctx)\n{\n\tstruct name_cache_entry *nce;\n\n\twhile (!list_empty(&sctx->name_cache_list)) {\n\t\tnce = list_entry(sctx->name_cache_list.next,\n\t\t\t\tstruct name_cache_entry, list);\n\t\tname_cache_delete(sctx, nce);\n\t\tkfree(nce);\n\t}\n}\n\n/*\n * Used by get_cur_path for each ref up to the root.\n * Returns 0 if it succeeded.\n * Returns 1 if the inode is not existent or got overwritten. In that case, the\n * name is an orphan name. This instructs get_cur_path to stop iterating. If 1\n * is returned, parent_ino/parent_gen are not guaranteed to be valid.\n * Returns <0 in case of error.\n */\nstatic int __get_cur_name_and_parent(struct send_ctx *sctx,\n\t\t\t\t     u64 ino, u64 gen,\n\t\t\t\t     u64 *parent_ino,\n\t\t\t\t     u64 *parent_gen,\n\t\t\t\t     struct fs_path *dest)\n{\n\tint ret;\n\tint nce_ret;\n\tstruct name_cache_entry *nce = NULL;\n\n\t/*\n\t * First check if we already did a call to this function with the same\n\t * ino/gen. If yes, check if the cache entry is still up-to-date. If yes\n\t * return the cached result.\n\t */\n\tnce = name_cache_search(sctx, ino, gen);\n\tif (nce) {\n\t\tif (ino < sctx->send_progress && nce->need_later_update) {\n\t\t\tname_cache_delete(sctx, nce);\n\t\t\tkfree(nce);\n\t\t\tnce = NULL;\n\t\t} else {\n\t\t\tname_cache_used(sctx, nce);\n\t\t\t*parent_ino = nce->parent_ino;\n\t\t\t*parent_gen = nce->parent_gen;\n\t\t\tret = fs_path_add(dest, nce->name, nce->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = nce->ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the inode is not existent yet, add the orphan name and return 1.\n\t * This should only happen for the parent dir that we determine in\n\t * __record_new_ref\n\t */\n\tret = is_inode_existent(sctx, ino, gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!ret) {\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t\tgoto out_cache;\n\t}\n\n\t/*\n\t * Depending on whether the inode was already processed or not, use\n\t * send_root or parent_root for ref lookup.\n\t */\n\tif (ino < sctx->send_progress)\n\t\tret = get_first_ref(sctx->send_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\telse\n\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t    parent_ino, parent_gen, dest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Check if the ref was overwritten by an inode's ref that was processed\n\t * earlier. If yes, treat as orphan and return 1.\n\t */\n\tret = did_overwrite_ref(sctx, *parent_ino, *parent_gen, ino, gen,\n\t\t\tdest->start, dest->end - dest->start);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tfs_path_reset(dest);\n\t\tret = gen_unique_name(sctx, ino, gen, dest);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 1;\n\t}\n\nout_cache:\n\t/*\n\t * Store the result of the lookup in the name cache.\n\t */\n\tnce = kmalloc(sizeof(*nce) + fs_path_len(dest) + 1, GFP_KERNEL);\n\tif (!nce) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnce->ino = ino;\n\tnce->gen = gen;\n\tnce->parent_ino = *parent_ino;\n\tnce->parent_gen = *parent_gen;\n\tnce->name_len = fs_path_len(dest);\n\tnce->ret = ret;\n\tstrcpy(nce->name, dest->start);\n\n\tif (ino < sctx->send_progress)\n\t\tnce->need_later_update = 0;\n\telse\n\t\tnce->need_later_update = 1;\n\n\tnce_ret = name_cache_insert(sctx, nce);\n\tif (nce_ret < 0)\n\t\tret = nce_ret;\n\tname_cache_clean_unused(sctx);\n\nout:\n\treturn ret;\n}\n\n/*\n * Magic happens here. This function returns the first ref to an inode as it\n * would look like while receiving the stream at this point in time.\n * We walk the path up to the root. For every inode in between, we check if it\n * was already processed/sent. If yes, we continue with the parent as found\n * in send_root. If not, we continue with the parent as found in parent_root.\n * If we encounter an inode that was deleted at this point in time, we use the\n * inodes \"orphan\" name instead of the real name and stop. Same with new inodes\n * that were not created yet and overwritten inodes/refs.\n *\n * When do we have orphan inodes:\n * 1. When an inode is freshly created and thus no valid refs are available yet\n * 2. When a directory lost all it's refs (deleted) but still has dir items\n *    inside which were not processed yet (pending for move/delete). If anyone\n *    tried to get the path to the dir items, it would get a path inside that\n *    orphan directory.\n * 3. When an inode is moved around or gets new links, it may overwrite the ref\n *    of an unprocessed inode. If in that case the first ref would be\n *    overwritten, the overwritten inode gets \"orphanized\". Later when we\n *    process this overwritten inode, it is restored at a new place by moving\n *    the orphan inode.\n *\n * sctx->send_progress tells this function at which point in time receiving\n * would be.\n */\nstatic int get_cur_path(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\tstruct fs_path *dest)\n{\n\tint ret = 0;\n\tstruct fs_path *name = NULL;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tint stop = 0;\n\n\tname = fs_path_alloc();\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdest->reversed = 1;\n\tfs_path_reset(dest);\n\n\twhile (!stop && ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tstruct waiting_dir_move *wdm;\n\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino, gen)) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = fs_path_add_path(dest, name);\n\t\t\tbreak;\n\t\t}\n\n\t\twdm = get_waiting_dir_move(sctx, ino);\n\t\tif (wdm && wdm->orphanized) {\n\t\t\tret = gen_unique_name(sctx, ino, gen, name);\n\t\t\tstop = 1;\n\t\t} else if (wdm) {\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret)\n\t\t\t\tstop = 1;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = fs_path_add_path(dest, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\nout:\n\tfs_path_free(name);\n\tif (!ret)\n\t\tfs_path_unreverse(dest);\n\treturn ret;\n}\n\n/*\n * Sends a BTRFS_SEND_C_SUBVOL command/item to userspace\n */\nstatic int send_subvol_begin(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_root *parent_root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_ref *ref;\n\tstruct extent_buffer *leaf;\n\tchar *name = NULL;\n\tint namelen;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tname = kmalloc(BTRFS_PATH_NAME_MAX, GFP_KERNEL);\n\tif (!name) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tkey.objectid = send_root->root_key.objectid;\n\tkey.type = BTRFS_ROOT_BACKREF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root->fs_info->tree_root,\n\t\t\t\t&key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\tif (key.type != BTRFS_ROOT_BACKREF_KEY ||\n\t    key.objectid != send_root->root_key.objectid) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\n\tnamelen = btrfs_root_ref_name_len(leaf, ref);\n\tread_extent_buffer(leaf, name, (unsigned long)(ref + 1), namelen);\n\tbtrfs_release_path(path);\n\n\tif (parent_root) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SNAPSHOT);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_SUBVOL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_PATH, name, namelen);\n\n\tif (!btrfs_is_empty_uuid(sctx->send_root->root_item.received_uuid))\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\t    sctx->send_root->root_item.received_uuid);\n\telse\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_UUID,\n\t\t\t    sctx->send_root->root_item.uuid);\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CTRANSID,\n\t\t    btrfs_root_ctransid(&sctx->send_root->root_item));\n\tif (parent_root) {\n\t\tif (!btrfs_is_empty_uuid(parent_root->root_item.received_uuid))\n\t\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\t     parent_root->root_item.received_uuid);\n\t\telse\n\t\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t\t     parent_root->root_item.uuid);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t\t    btrfs_root_ctransid(&sctx->parent_root->root_item));\n\t}\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tbtrfs_free_path(path);\n\tkfree(name);\n\treturn ret;\n}\n\nstatic int send_truncate(struct send_ctx *sctx, u64 ino, u64 gen, u64 size)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, \"send_truncate %llu size=%llu\", ino, size);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_TRUNCATE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, size);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_chmod(struct send_ctx *sctx, u64 ino, u64 gen, u64 mode)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, \"send_chmod %llu mode=%llu\", ino, mode);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHMOD);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode & 07777);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_chown(struct send_ctx *sctx, u64 ino, u64 gen, u64 uid, u64 gid)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tbtrfs_debug(fs_info, \"send_chown %llu uid=%llu, gid=%llu\",\n\t\t    ino, uid, gid);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CHOWN);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_UID, uid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_GID, gid);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_utimes(struct send_ctx *sctx, u64 ino, u64 gen)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p = NULL;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tint slot;\n\n\tbtrfs_debug(fs_info, \"send_utimes %llu\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tii = btrfs_item_ptr(eb, slot, struct btrfs_inode_item);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UTIMES);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_ATIME, eb, &ii->atime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_MTIME, eb, &ii->mtime);\n\tTLV_PUT_BTRFS_TIMESPEC(sctx, BTRFS_SEND_A_CTIME, eb, &ii->ctime);\n\t/* TODO Add otime support when the otime patches get into upstream */\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * Sends a BTRFS_SEND_C_MKXXX or SYMLINK command to user space. We don't have\n * a valid path yet because we did not process the refs yet. So, the inode\n * is created as orphan.\n */\nstatic int send_create_inode(struct send_ctx *sctx, u64 ino)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\tint cmd;\n\tu64 gen;\n\tu64 mode;\n\tu64 rdev;\n\n\tbtrfs_debug(fs_info, \"send_create_inode %llu\", ino);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (ino != sctx->cur_ino) {\n\t\tret = get_inode_info(sctx->send_root, ino, NULL, &gen, &mode,\n\t\t\t\t     NULL, NULL, &rdev);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tgen = sctx->cur_inode_gen;\n\t\tmode = sctx->cur_inode_mode;\n\t\trdev = sctx->cur_inode_rdev;\n\t}\n\n\tif (S_ISREG(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFILE;\n\t} else if (S_ISDIR(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKDIR;\n\t} else if (S_ISLNK(mode)) {\n\t\tcmd = BTRFS_SEND_C_SYMLINK;\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKNOD;\n\t} else if (S_ISFIFO(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKFIFO;\n\t} else if (S_ISSOCK(mode)) {\n\t\tcmd = BTRFS_SEND_C_MKSOCK;\n\t} else {\n\t\tbtrfs_warn(sctx->send_root->fs_info, \"unexpected inode type %o\",\n\t\t\t\t(int)(mode & S_IFMT));\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = begin_cmd(sctx, cmd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = gen_unique_name(sctx, ino, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_INO, ino);\n\n\tif (S_ISLNK(mode)) {\n\t\tfs_path_reset(p);\n\t\tret = read_symlink(sctx->send_root, ino, p);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH_LINK, p);\n\t} else if (S_ISCHR(mode) || S_ISBLK(mode) ||\n\t\t   S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_RDEV, new_encode_dev(rdev));\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_MODE, mode);\n\t}\n\n\tret = send_cmd(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\n/*\n * We need some special handling for inodes that get processed before the parent\n * directory got created. See process_recorded_refs for details.\n * This function does the check if we already created the dir out of order.\n */\nstatic int did_create_dir(struct send_ctx *sctx, u64 dir)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key di_key;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_dir_item *di;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->send_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->send_root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = btrfs_item_ptr(eb, slot, struct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(eb, di, &di_key);\n\n\t\tif (di_key.type != BTRFS_ROOT_ITEM_KEY &&\n\t\t    di_key.objectid < sctx->send_progress) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * Only creates the inode if it is:\n * 1. Not a directory\n * 2. Or a directory which was not created already due to out of order\n *    directories. See did_create_dir and process_recorded_refs for details.\n */\nstatic int send_create_inode_if_needed(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\tret = did_create_dir(sctx, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = send_create_inode(sctx, sctx->cur_ino);\n\tif (ret < 0)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstruct recorded_ref {\n\tstruct list_head list;\n\tchar *name;\n\tstruct fs_path *full_path;\n\tu64 dir;\n\tu64 dir_gen;\n\tint name_len;\n};\n\nstatic void set_ref_path(struct recorded_ref *ref, struct fs_path *path)\n{\n\tref->full_path = path;\n\tref->name = (char *)kbasename(ref->full_path->start);\n\tref->name_len = ref->full_path->end - ref->name;\n}\n\n/*\n * We need to process new refs before deleted refs, but compare_tree gives us\n * everything mixed. So we first record all refs and later process them.\n * This function is a helper to record one ref.\n */\nstatic int __record_ref(struct list_head *head, u64 dir,\n\t\t      u64 dir_gen, struct fs_path *path)\n{\n\tstruct recorded_ref *ref;\n\n\tref = kmalloc(sizeof(*ref), GFP_KERNEL);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->dir = dir;\n\tref->dir_gen = dir_gen;\n\tset_ref_path(ref, path);\n\tlist_add_tail(&ref->list, head);\n\treturn 0;\n}\n\nstatic int dup_ref(struct recorded_ref *ref, struct list_head *list)\n{\n\tstruct recorded_ref *new;\n\n\tnew = kmalloc(sizeof(*ref), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->dir = ref->dir;\n\tnew->dir_gen = ref->dir_gen;\n\tnew->full_path = NULL;\n\tINIT_LIST_HEAD(&new->list);\n\tlist_add_tail(&new->list, list);\n\treturn 0;\n}\n\nstatic void __free_recorded_refs(struct list_head *head)\n{\n\tstruct recorded_ref *cur;\n\n\twhile (!list_empty(head)) {\n\t\tcur = list_entry(head->next, struct recorded_ref, list);\n\t\tfs_path_free(cur->full_path);\n\t\tlist_del(&cur->list);\n\t\tkfree(cur);\n\t}\n}\n\nstatic void free_recorded_refs(struct send_ctx *sctx)\n{\n\t__free_recorded_refs(&sctx->new_refs);\n\t__free_recorded_refs(&sctx->deleted_refs);\n}\n\n/*\n * Renames/moves a file/dir to its orphan name. Used when the first\n * ref of an unprocessed inode gets overwritten and for all non empty\n * directories.\n */\nstatic int orphanize_inode(struct send_ctx *sctx, u64 ino, u64 gen,\n\t\t\t  struct fs_path *path)\n{\n\tint ret;\n\tstruct fs_path *orphan;\n\n\torphan = fs_path_alloc();\n\tif (!orphan)\n\t\treturn -ENOMEM;\n\n\tret = gen_unique_name(sctx, ino, gen, orphan);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, path, orphan);\n\nout:\n\tfs_path_free(orphan);\n\treturn ret;\n}\n\nstatic struct orphan_dir_info *add_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t\t\t   u64 dir_ino, u64 dir_gen)\n{\n\tstruct rb_node **p = &sctx->orphan_dirs.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct orphan_dir_info *entry, *odi;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (dir_gen < entry->gen)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (dir_gen > entry->gen)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\todi = kmalloc(sizeof(*odi), GFP_KERNEL);\n\tif (!odi)\n\t\treturn ERR_PTR(-ENOMEM);\n\todi->ino = dir_ino;\n\todi->gen = dir_gen;\n\todi->last_dir_index_offset = 0;\n\n\trb_link_node(&odi->node, parent, p);\n\trb_insert_color(&odi->node, &sctx->orphan_dirs);\n\treturn odi;\n}\n\nstatic struct orphan_dir_info *get_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t\t\t   u64 dir_ino, u64 gen)\n{\n\tstruct rb_node *n = sctx->orphan_dirs.rb_node;\n\tstruct orphan_dir_info *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct orphan_dir_info, node);\n\t\tif (dir_ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (dir_ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse if (gen < entry->gen)\n\t\t\tn = n->rb_left;\n\t\telse if (gen > entry->gen)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic int is_waiting_for_rm(struct send_ctx *sctx, u64 dir_ino, u64 gen)\n{\n\tstruct orphan_dir_info *odi = get_orphan_dir_info(sctx, dir_ino, gen);\n\n\treturn odi != NULL;\n}\n\nstatic void free_orphan_dir_info(struct send_ctx *sctx,\n\t\t\t\t struct orphan_dir_info *odi)\n{\n\tif (!odi)\n\t\treturn;\n\trb_erase(&odi->node, &sctx->orphan_dirs);\n\tkfree(odi);\n}\n\n/*\n * Returns 1 if a directory can be removed at this point in time.\n * We check this by iterating all dir items and checking if the inode behind\n * the dir item was already processed.\n */\nstatic int can_rmdir(struct send_ctx *sctx, u64 dir, u64 dir_gen,\n\t\t     u64 send_progress)\n{\n\tint ret = 0;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_key loc;\n\tstruct btrfs_dir_item *di;\n\tstruct orphan_dir_info *odi = NULL;\n\n\t/*\n\t * Don't try to rmdir the top/root subvolume dir.\n\t */\n\tif (dir == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_INDEX_KEY;\n\tkey.offset = 0;\n\n\todi = get_orphan_dir_info(sctx, dir, dir_gen);\n\tif (odi)\n\t\tkey.offset = odi->last_dir_index_offset;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct waiting_dir_move *dm;\n\n\t\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0])) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\n\t\t\t\t      path->slots[0]);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type)\n\t\t\tbreak;\n\n\t\tdi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\tstruct btrfs_dir_item);\n\t\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &loc);\n\n\t\tdm = get_waiting_dir_move(sctx, loc.objectid);\n\t\tif (dm) {\n\t\t\todi = add_orphan_dir_info(sctx, dir, dir_gen);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\todi->last_dir_index_offset = found_key.offset;\n\t\t\tdm->rmdir_ino = dir;\n\t\t\tdm->rmdir_gen = dir_gen;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (loc.objectid > send_progress) {\n\t\t\todi = add_orphan_dir_info(sctx, dir, dir_gen);\n\t\t\tif (IS_ERR(odi)) {\n\t\t\t\tret = PTR_ERR(odi);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\todi->gen = dir_gen;\n\t\t\todi->last_dir_index_offset = found_key.offset;\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\n\tfree_orphan_dir_info(sctx, odi);\n\n\tret = 1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct waiting_dir_move *entry = get_waiting_dir_move(sctx, ino);\n\n\treturn entry != NULL;\n}\n\nstatic int add_waiting_dir_move(struct send_ctx *sctx, u64 ino, bool orphanized)\n{\n\tstruct rb_node **p = &sctx->waiting_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct waiting_dir_move *entry, *dm;\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->ino = ino;\n\tdm->rmdir_ino = 0;\n\tdm->rmdir_gen = 0;\n\tdm->orphanized = orphanized;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (ino > entry->ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(dm);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&dm->node, parent, p);\n\trb_insert_color(&dm->node, &sctx->waiting_dir_moves);\n\treturn 0;\n}\n\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino)\n{\n\tstruct rb_node *n = sctx->waiting_dir_moves.rb_node;\n\tstruct waiting_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct waiting_dir_move, node);\n\t\tif (ino < entry->ino)\n\t\t\tn = n->rb_left;\n\t\telse if (ino > entry->ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic void free_waiting_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct waiting_dir_move *dm)\n{\n\tif (!dm)\n\t\treturn;\n\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\tkfree(dm);\n}\n\nstatic int add_pending_dir_move(struct send_ctx *sctx,\n\t\t\t\tu64 ino,\n\t\t\t\tu64 ino_gen,\n\t\t\t\tu64 parent_ino,\n\t\t\t\tstruct list_head *new_refs,\n\t\t\t\tstruct list_head *deleted_refs,\n\t\t\t\tconst bool is_orphan)\n{\n\tstruct rb_node **p = &sctx->pending_dir_moves.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct pending_dir_move *entry = NULL, *pm;\n\tstruct recorded_ref *cur;\n\tint exists = 0;\n\tint ret;\n\n\tpm = kmalloc(sizeof(*pm), GFP_KERNEL);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tpm->parent_ino = parent_ino;\n\tpm->ino = ino;\n\tpm->gen = ino_gen;\n\tINIT_LIST_HEAD(&pm->list);\n\tINIT_LIST_HEAD(&pm->update_refs);\n\tRB_CLEAR_NODE(&pm->node);\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (parent_ino > entry->parent_ino) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\texists = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cur, deleted_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry(cur, new_refs, list) {\n\t\tret = dup_ref(cur, &pm->update_refs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = add_waiting_dir_move(sctx, pm->ino, is_orphan);\n\tif (ret)\n\t\tgoto out;\n\n\tif (exists) {\n\t\tlist_add_tail(&pm->list, &entry->list);\n\t} else {\n\t\trb_link_node(&pm->node, parent, p);\n\t\trb_insert_color(&pm->node, &sctx->pending_dir_moves);\n\t}\n\tret = 0;\nout:\n\tif (ret) {\n\t\t__free_recorded_refs(&pm->update_refs);\n\t\tkfree(pm);\n\t}\n\treturn ret;\n}\n\nstatic struct pending_dir_move *get_pending_dir_moves(struct send_ctx *sctx,\n\t\t\t\t\t\t      u64 parent_ino)\n{\n\tstruct rb_node *n = sctx->pending_dir_moves.rb_node;\n\tstruct pending_dir_move *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct pending_dir_move, node);\n\t\tif (parent_ino < entry->parent_ino)\n\t\t\tn = n->rb_left;\n\t\telse if (parent_ino > entry->parent_ino)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic int path_loop(struct send_ctx *sctx, struct fs_path *name,\n\t\t     u64 ino, u64 gen, u64 *ancestor_ino)\n{\n\tint ret = 0;\n\tu64 parent_inode = 0;\n\tu64 parent_gen = 0;\n\tu64 start_ino = ino;\n\n\t*ancestor_ino = 0;\n\twhile (ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tfs_path_reset(name);\n\n\t\tif (is_waiting_for_rm(sctx, ino, gen))\n\t\t\tbreak;\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tret = get_first_ref(sctx->parent_root, ino,\n\t\t\t\t\t    &parent_inode, &parent_gen, name);\n\t\t} else {\n\t\t\tret = __get_cur_name_and_parent(sctx, ino, gen,\n\t\t\t\t\t\t\t&parent_inode,\n\t\t\t\t\t\t\t&parent_gen, name);\n\t\t\tif (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (parent_inode == start_ino) {\n\t\t\tret = 1;\n\t\t\tif (*ancestor_ino == 0)\n\t\t\t\t*ancestor_ino = ino;\n\t\t\tbreak;\n\t\t}\n\t\tino = parent_inode;\n\t\tgen = parent_gen;\n\t}\n\treturn ret;\n}\n\nstatic int apply_dir_move(struct send_ctx *sctx, struct pending_dir_move *pm)\n{\n\tstruct fs_path *from_path = NULL;\n\tstruct fs_path *to_path = NULL;\n\tstruct fs_path *name = NULL;\n\tu64 orig_progress = sctx->send_progress;\n\tstruct recorded_ref *cur;\n\tu64 parent_ino, parent_gen;\n\tstruct waiting_dir_move *dm = NULL;\n\tu64 rmdir_ino = 0;\n\tu64 rmdir_gen;\n\tu64 ancestor;\n\tbool is_orphan;\n\tint ret;\n\n\tname = fs_path_alloc();\n\tfrom_path = fs_path_alloc();\n\tif (!name || !from_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdm = get_waiting_dir_move(sctx, pm->ino);\n\tASSERT(dm);\n\trmdir_ino = dm->rmdir_ino;\n\trmdir_gen = dm->rmdir_gen;\n\tis_orphan = dm->orphanized;\n\tfree_waiting_dir_move(sctx, dm);\n\n\tif (is_orphan) {\n\t\tret = gen_unique_name(sctx, pm->ino,\n\t\t\t\t      pm->gen, from_path);\n\t} else {\n\t\tret = get_first_ref(sctx->parent_root, pm->ino,\n\t\t\t\t    &parent_ino, &parent_gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, parent_ino, parent_gen,\n\t\t\t\t   from_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = fs_path_add_path(from_path, name);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsctx->send_progress = sctx->cur_ino + 1;\n\tret = path_loop(sctx, name, pm->ino, pm->gen, &ancestor);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tLIST_HEAD(deleted_refs);\n\t\tASSERT(ancestor > BTRFS_FIRST_FREE_OBJECTID);\n\t\tret = add_pending_dir_move(sctx, pm->ino, pm->gen, ancestor,\n\t\t\t\t\t   &pm->update_refs, &deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (rmdir_ino) {\n\t\t\tdm = get_waiting_dir_move(sctx, pm->ino);\n\t\t\tASSERT(dm);\n\t\t\tdm->rmdir_ino = rmdir_ino;\n\t\t\tdm->rmdir_gen = rmdir_gen;\n\t\t}\n\t\tgoto out;\n\t}\n\tfs_path_reset(name);\n\tto_path = name;\n\tname = NULL;\n\tret = get_cur_path(sctx, pm->ino, pm->gen, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_rename(sctx, from_path, to_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (rmdir_ino) {\n\t\tstruct orphan_dir_info *odi;\n\t\tu64 gen;\n\n\t\todi = get_orphan_dir_info(sctx, rmdir_ino, rmdir_gen);\n\t\tif (!odi) {\n\t\t\t/* already deleted */\n\t\t\tgoto finish;\n\t\t}\n\t\tgen = odi->gen;\n\n\t\tret = can_rmdir(sctx, rmdir_ino, gen, sctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret)\n\t\t\tgoto finish;\n\n\t\tname = fs_path_alloc();\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = get_cur_path(sctx, rmdir_ino, gen, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_rmdir(sctx, name);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nfinish:\n\tret = send_utimes(sctx, pm->ino, pm->gen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * After rename/move, need to update the utimes of both new parent(s)\n\t * and old parent(s).\n\t */\n\tlist_for_each_entry(cur, &pm->update_refs, list) {\n\t\t/*\n\t\t * The parent inode might have been deleted in the send snapshot\n\t\t */\n\t\tret = get_inode_info(sctx->send_root, cur->dir, NULL,\n\t\t\t\t     NULL, NULL, NULL, NULL, NULL);\n\t\tif (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfs_path_free(name);\n\tfs_path_free(from_path);\n\tfs_path_free(to_path);\n\tsctx->send_progress = orig_progress;\n\n\treturn ret;\n}\n\nstatic void free_pending_move(struct send_ctx *sctx, struct pending_dir_move *m)\n{\n\tif (!list_empty(&m->list))\n\t\tlist_del(&m->list);\n\tif (!RB_EMPTY_NODE(&m->node))\n\t\trb_erase(&m->node, &sctx->pending_dir_moves);\n\t__free_recorded_refs(&m->update_refs);\n\tkfree(m);\n}\n\nstatic void tail_append_pending_moves(struct send_ctx *sctx,\n\t\t\t\t      struct pending_dir_move *moves,\n\t\t\t\t      struct list_head *stack)\n{\n\tif (list_empty(&moves->list)) {\n\t\tlist_add_tail(&moves->list, stack);\n\t} else {\n\t\tLIST_HEAD(list);\n\t\tlist_splice_init(&moves->list, &list);\n\t\tlist_add_tail(&moves->list, stack);\n\t\tlist_splice_tail(&list, stack);\n\t}\n\tif (!RB_EMPTY_NODE(&moves->node)) {\n\t\trb_erase(&moves->node, &sctx->pending_dir_moves);\n\t\tRB_CLEAR_NODE(&moves->node);\n\t}\n}\n\nstatic int apply_children_dir_moves(struct send_ctx *sctx)\n{\n\tstruct pending_dir_move *pm;\n\tstruct list_head stack;\n\tu64 parent_ino = sctx->cur_ino;\n\tint ret = 0;\n\n\tpm = get_pending_dir_moves(sctx, parent_ino);\n\tif (!pm)\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&stack);\n\ttail_append_pending_moves(sctx, pm, &stack);\n\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tparent_ino = pm->ino;\n\t\tret = apply_dir_move(sctx, pm);\n\t\tfree_pending_move(sctx, pm);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpm = get_pending_dir_moves(sctx, parent_ino);\n\t\tif (pm)\n\t\t\ttail_append_pending_moves(sctx, pm, &stack);\n\t}\n\treturn 0;\n\nout:\n\twhile (!list_empty(&stack)) {\n\t\tpm = list_first_entry(&stack, struct pending_dir_move, list);\n\t\tfree_pending_move(sctx, pm);\n\t}\n\treturn ret;\n}\n\n/*\n * We might need to delay a directory rename even when no ancestor directory\n * (in the send root) with a higher inode number than ours (sctx->cur_ino) was\n * renamed. This happens when we rename a directory to the old name (the name\n * in the parent root) of some other unrelated directory that got its rename\n * delayed due to some ancestor with higher number that got renamed.\n *\n * Example:\n *\n * Parent snapshot:\n * .                                       (ino 256)\n * |---- a/                                (ino 257)\n * |     |---- file                        (ino 260)\n * |\n * |---- b/                                (ino 258)\n * |---- c/                                (ino 259)\n *\n * Send snapshot:\n * .                                       (ino 256)\n * |---- a/                                (ino 258)\n * |---- x/                                (ino 259)\n *       |---- y/                          (ino 257)\n *             |----- file                 (ino 260)\n *\n * Here we can not rename 258 from 'b' to 'a' without the rename of inode 257\n * from 'a' to 'x/y' happening first, which in turn depends on the rename of\n * inode 259 from 'c' to 'x'. So the order of rename commands the send stream\n * must issue is:\n *\n * 1 - rename 259 from 'c' to 'x'\n * 2 - rename 257 from 'a' to 'x/y'\n * 3 - rename 258 from 'b' to 'a'\n *\n * Returns 1 if the rename of sctx->cur_ino needs to be delayed, 0 if it can\n * be done right away and < 0 on error.\n */\nstatic int wait_for_dest_dir_move(struct send_ctx *sctx,\n\t\t\t\t  struct recorded_ref *parent_ref,\n\t\t\t\t  const bool is_orphan)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->parent_root->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key di_key;\n\tstruct btrfs_dir_item *di;\n\tu64 left_gen;\n\tu64 right_gen;\n\tint ret = 0;\n\tstruct waiting_dir_move *wdm;\n\n\tif (RB_EMPTY_ROOT(&sctx->waiting_dir_moves))\n\t\treturn 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = parent_ref->dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\tkey.offset = btrfs_name_hash(parent_ref->name, parent_ref->name_len);\n\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tdi = btrfs_match_dir_item_name(fs_info, path, parent_ref->name,\n\t\t\t\t       parent_ref->name_len);\n\tif (!di) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * di_key.objectid has the number of the inode that has a dentry in the\n\t * parent directory with the same name that sctx->cur_ino is being\n\t * renamed to. We need to check if that inode is in the send root as\n\t * well and if it is currently marked as an inode with a pending rename,\n\t * if it is, we need to delay the rename of sctx->cur_ino as well, so\n\t * that it happens after that other inode is renamed.\n\t */\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &di_key);\n\tif (di_key.type != BTRFS_INODE_ITEM_KEY) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = get_inode_info(sctx->parent_root, di_key.objectid, NULL,\n\t\t\t     &left_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = get_inode_info(sctx->send_root, di_key.objectid, NULL,\n\t\t\t     &right_gen, NULL, NULL, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/* Different inode, no need to delay the rename of sctx->cur_ino */\n\tif (right_gen != left_gen) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\twdm = get_waiting_dir_move(sctx, di_key.objectid);\n\tif (wdm && !wdm->orphanized) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   di_key.objectid,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\n/*\n * Check if inode ino2, or any of its ancestors, is inode ino1.\n * Return 1 if true, 0 if false and < 0 on error.\n */\nstatic int check_ino_in_path(struct btrfs_root *root,\n\t\t\t     const u64 ino1,\n\t\t\t     const u64 ino1_gen,\n\t\t\t     const u64 ino2,\n\t\t\t     const u64 ino2_gen,\n\t\t\t     struct fs_path *fs_path)\n{\n\tu64 ino = ino2;\n\n\tif (ino1 == ino2)\n\t\treturn ino1_gen == ino2_gen;\n\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tu64 parent;\n\t\tu64 parent_gen;\n\t\tint ret;\n\n\t\tfs_path_reset(fs_path);\n\t\tret = get_first_ref(root, ino, &parent, &parent_gen, fs_path);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (parent == ino1)\n\t\t\treturn parent_gen == ino1_gen;\n\t\tino = parent;\n\t}\n\treturn 0;\n}\n\n/*\n * Check if ino ino1 is an ancestor of inode ino2 in the given root for any\n * possible path (in case ino2 is not a directory and has multiple hard links).\n * Return 1 if true, 0 if false and < 0 on error.\n */\nstatic int is_ancestor(struct btrfs_root *root,\n\t\t       const u64 ino1,\n\t\t       const u64 ino1_gen,\n\t\t       const u64 ino2,\n\t\t       struct fs_path *fs_path)\n{\n\tbool free_fs_path = false;\n\tint ret = 0;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_key key;\n\n\tif (!fs_path) {\n\t\tfs_path = fs_path_alloc();\n\t\tif (!fs_path)\n\t\t\treturn -ENOMEM;\n\t\tfree_fs_path = true;\n\t}\n\n\tpath = alloc_path_for_send();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ino2;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tu32 cur_offset = 0;\n\t\tu32 item_size;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != ino2)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\twhile (cur_offset < item_size) {\n\t\t\tu64 parent;\n\t\t\tu64 parent_gen;\n\n\t\t\tif (key.type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\t\tunsigned long ptr;\n\t\t\t\tstruct btrfs_inode_extref *extref;\n\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\textref = (struct btrfs_inode_extref *)\n\t\t\t\t\t(ptr + cur_offset);\n\t\t\t\tparent = btrfs_inode_extref_parent(leaf,\n\t\t\t\t\t\t\t\t   extref);\n\t\t\t\tcur_offset += sizeof(*extref);\n\t\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf,\n\t\t\t\t\t\t\t\t  extref);\n\t\t\t} else {\n\t\t\t\tparent = key.offset;\n\t\t\t\tcur_offset = item_size;\n\t\t\t}\n\n\t\t\tret = get_inode_info(root, parent, NULL, &parent_gen,\n\t\t\t\t\t     NULL, NULL, NULL, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = check_ino_in_path(root, ino1, ino1_gen,\n\t\t\t\t\t\tparent, parent_gen, fs_path);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\n out:\n\tbtrfs_free_path(path);\n\tif (free_fs_path)\n\t\tfs_path_free(fs_path);\n\treturn ret;\n}\n\nstatic int wait_for_parent_move(struct send_ctx *sctx,\n\t\t\t\tstruct recorded_ref *parent_ref,\n\t\t\t\tconst bool is_orphan)\n{\n\tint ret = 0;\n\tu64 ino = parent_ref->dir;\n\tu64 ino_gen = parent_ref->dir_gen;\n\tu64 parent_ino_before, parent_ino_after;\n\tstruct fs_path *path_before = NULL;\n\tstruct fs_path *path_after = NULL;\n\tint len1, len2;\n\n\tpath_after = fs_path_alloc();\n\tpath_before = fs_path_alloc();\n\tif (!path_after || !path_before) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Our current directory inode may not yet be renamed/moved because some\n\t * ancestor (immediate or not) has to be renamed/moved first. So find if\n\t * such ancestor exists and make sure our own rename/move happens after\n\t * that ancestor is processed to avoid path build infinite loops (done\n\t * at get_cur_path()).\n\t */\n\twhile (ino > BTRFS_FIRST_FREE_OBJECTID) {\n\t\tu64 parent_ino_after_gen;\n\n\t\tif (is_waiting_for_move(sctx, ino)) {\n\t\t\t/*\n\t\t\t * If the current inode is an ancestor of ino in the\n\t\t\t * parent root, we need to delay the rename of the\n\t\t\t * current inode, otherwise don't delayed the rename\n\t\t\t * because we can end up with a circular dependency\n\t\t\t * of renames, resulting in some directories never\n\t\t\t * getting the respective rename operations issued in\n\t\t\t * the send stream or getting into infinite path build\n\t\t\t * loops.\n\t\t\t */\n\t\t\tret = is_ancestor(sctx->parent_root,\n\t\t\t\t\t  sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\t  ino, path_before);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfs_path_reset(path_before);\n\t\tfs_path_reset(path_after);\n\n\t\tret = get_first_ref(sctx->send_root, ino, &parent_ino_after,\n\t\t\t\t    &parent_ino_after_gen, path_after);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_first_ref(sctx->parent_root, ino, &parent_ino_before,\n\t\t\t\t    NULL, path_before);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tgoto out;\n\t\t} else if (ret == -ENOENT) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen1 = fs_path_len(path_before);\n\t\tlen2 = fs_path_len(path_after);\n\t\tif (ino > sctx->cur_ino &&\n\t\t    (parent_ino_before != parent_ino_after || len1 != len2 ||\n\t\t     memcmp(path_before->start, path_after->start, len1))) {\n\t\t\tu64 parent_ino_gen;\n\n\t\t\tret = get_inode_info(sctx->parent_root, ino, NULL,\n\t\t\t\t\t     &parent_ino_gen, NULL, NULL, NULL,\n\t\t\t\t\t     NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ino_gen == parent_ino_gen) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tino = parent_ino_after;\n\t\tino_gen = parent_ino_after_gen;\n\t}\n\nout:\n\tfs_path_free(path_before);\n\tfs_path_free(path_after);\n\n\tif (ret == 1) {\n\t\tret = add_pending_dir_move(sctx,\n\t\t\t\t\t   sctx->cur_ino,\n\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t   ino,\n\t\t\t\t\t   &sctx->new_refs,\n\t\t\t\t\t   &sctx->deleted_refs,\n\t\t\t\t\t   is_orphan);\n\t\tif (!ret)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int update_ref_path(struct send_ctx *sctx, struct recorded_ref *ref)\n{\n\tint ret;\n\tstruct fs_path *new_path;\n\n\t/*\n\t * Our reference's name member points to its full_path member string, so\n\t * we use here a new path.\n\t */\n\tnew_path = fs_path_alloc();\n\tif (!new_path)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, ref->dir, ref->dir_gen, new_path);\n\tif (ret < 0) {\n\t\tfs_path_free(new_path);\n\t\treturn ret;\n\t}\n\tret = fs_path_add(new_path, ref->name, ref->name_len);\n\tif (ret < 0) {\n\t\tfs_path_free(new_path);\n\t\treturn ret;\n\t}\n\n\tfs_path_free(ref->full_path);\n\tset_ref_path(ref, new_path);\n\n\treturn 0;\n}\n\n/*\n * When processing the new references for an inode we may orphanize an existing\n * directory inode because its old name conflicts with one of the new references\n * of the current inode. Later, when processing another new reference of our\n * inode, we might need to orphanize another inode, but the path we have in the\n * reference reflects the pre-orphanization name of the directory we previously\n * orphanized. For example:\n *\n * parent snapshot looks like:\n *\n * .                                     (ino 256)\n * |----- f1                             (ino 257)\n * |----- f2                             (ino 258)\n * |----- d1/                            (ino 259)\n *        |----- d2/                     (ino 260)\n *\n * send snapshot looks like:\n *\n * .                                     (ino 256)\n * |----- d1                             (ino 258)\n * |----- f2/                            (ino 259)\n *        |----- f2_link/                (ino 260)\n *        |       |----- f1              (ino 257)\n *        |\n *        |----- d2                      (ino 258)\n *\n * When processing inode 257 we compute the name for inode 259 as \"d1\", and we\n * cache it in the name cache. Later when we start processing inode 258, when\n * collecting all its new references we set a full path of \"d1/d2\" for its new\n * reference with name \"d2\". When we start processing the new references we\n * start by processing the new reference with name \"d1\", and this results in\n * orphanizing inode 259, since its old reference causes a conflict. Then we\n * move on the next new reference, with name \"d2\", and we find out we must\n * orphanize inode 260, as its old reference conflicts with ours - but for the\n * orphanization we use a source path corresponding to the path we stored in the\n * new reference, which is \"d1/d2\" and not \"o259-6-0/d2\" - this makes the\n * receiver fail since the path component \"d1/\" no longer exists, it was renamed\n * to \"o259-6-0/\" when processing the previous new reference. So in this case we\n * must recompute the path in the new reference and use it for the new\n * orphanization operation.\n */\nstatic int refresh_ref_path(struct send_ctx *sctx, struct recorded_ref *ref)\n{\n\tchar *name;\n\tint ret;\n\n\tname = kmemdup(ref->name, ref->name_len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tfs_path_reset(ref->full_path);\n\tret = get_cur_path(sctx, ref->dir, ref->dir_gen, ref->full_path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = fs_path_add(ref->full_path, name, ref->name_len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Update the reference's base name pointer. */\n\tset_ref_path(ref, ref->full_path);\nout:\n\tkfree(name);\n\treturn ret;\n}\n\n/*\n * This does all the move/link/unlink/rmdir magic.\n */\nstatic int process_recorded_refs(struct send_ctx *sctx, int *pending_move)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct recorded_ref *cur;\n\tstruct recorded_ref *cur2;\n\tstruct list_head check_dirs;\n\tstruct fs_path *valid_path = NULL;\n\tu64 ow_inode = 0;\n\tu64 ow_gen;\n\tu64 ow_mode;\n\tint did_overwrite = 0;\n\tint is_orphan = 0;\n\tu64 last_dir_ino_rm = 0;\n\tbool can_rename = true;\n\tbool orphanized_dir = false;\n\tbool orphanized_ancestor = false;\n\n\tbtrfs_debug(fs_info, \"process_recorded_refs %llu\", sctx->cur_ino);\n\n\t/*\n\t * This should never happen as the root dir always has the same ref\n\t * which is always '..'\n\t */\n\tBUG_ON(sctx->cur_ino <= BTRFS_FIRST_FREE_OBJECTID);\n\tINIT_LIST_HEAD(&check_dirs);\n\n\tvalid_path = fs_path_alloc();\n\tif (!valid_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, check if the first ref of the current inode was overwritten\n\t * before. If yes, we know that the current inode was already orphanized\n\t * and thus use the orphan name. If not, we can use get_cur_path to\n\t * get the path of the first ref as it would like while receiving at\n\t * this point in time.\n\t * New inodes are always orphan at the beginning, so force to use the\n\t * orphan name in this case.\n\t * The first ref is stored in valid_path and will be updated if it\n\t * gets moved around.\n\t */\n\tif (!sctx->cur_inode_new) {\n\t\tret = did_overwrite_first_ref(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tdid_overwrite = 1;\n\t}\n\tif (sctx->cur_inode_new || did_overwrite) {\n\t\tret = gen_unique_name(sctx, sctx->cur_ino,\n\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tis_orphan = 1;\n\t} else {\n\t\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tvalid_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Before doing any rename and link operations, do a first pass on the\n\t * new references to orphanize any unprocessed inodes that may have a\n\t * reference that conflicts with one of the new references of the current\n\t * inode. This needs to happen first because a new reference may conflict\n\t * with the old reference of a parent directory, so we must make sure\n\t * that the path used for link and rename commands don't use an\n\t * orphanized name when an ancestor was not yet orphanized.\n\t *\n\t * Example:\n\t *\n\t * Parent snapshot:\n\t *\n\t * .                                                      (ino 256)\n\t * |----- testdir/                                        (ino 259)\n\t * |          |----- a                                    (ino 257)\n\t * |\n\t * |----- b                                               (ino 258)\n\t *\n\t * Send snapshot:\n\t *\n\t * .                                                      (ino 256)\n\t * |----- testdir_2/                                      (ino 259)\n\t * |          |----- a                                    (ino 260)\n\t * |\n\t * |----- testdir                                         (ino 257)\n\t * |----- b                                               (ino 257)\n\t * |----- b2                                              (ino 258)\n\t *\n\t * Processing the new reference for inode 257 with name \"b\" may happen\n\t * before processing the new reference with name \"testdir\". If so, we\n\t * must make sure that by the time we send a link command to create the\n\t * hard link \"b\", inode 259 was already orphanized, since the generated\n\t * path in \"valid_path\" already contains the orphanized name for 259.\n\t * We are processing inode 257, so only later when processing 259 we do\n\t * the rename operation to change its temporary (orphanized) name to\n\t * \"testdir_2\".\n\t */\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check if this new ref would overwrite the first ref of another\n\t\t * unprocessed inode. If yes, orphanize the overwritten inode.\n\t\t * If we find an overwritten ref that is not the first ref,\n\t\t * simply unlink it.\n\t\t */\n\t\tret = will_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\tcur->name, cur->name_len,\n\t\t\t\t&ow_inode, &ow_gen, &ow_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = is_first_ref(sctx->parent_root,\n\t\t\t\t\t   ow_inode, cur->dir, cur->name,\n\t\t\t\t\t   cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tstruct name_cache_entry *nce;\n\t\t\t\tstruct waiting_dir_move *wdm;\n\n\t\t\t\tif (orphanized_dir) {\n\t\t\t\t\tret = refresh_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tret = orphanize_inode(sctx, ow_inode, ow_gen,\n\t\t\t\t\t\tcur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (S_ISDIR(ow_mode))\n\t\t\t\t\torphanized_dir = true;\n\n\t\t\t\t/*\n\t\t\t\t * If ow_inode has its rename operation delayed\n\t\t\t\t * make sure that its orphanized name is used in\n\t\t\t\t * the source path when performing its rename\n\t\t\t\t * operation.\n\t\t\t\t */\n\t\t\t\tif (is_waiting_for_move(sctx, ow_inode)) {\n\t\t\t\t\twdm = get_waiting_dir_move(sctx,\n\t\t\t\t\t\t\t\t   ow_inode);\n\t\t\t\t\tASSERT(wdm);\n\t\t\t\t\twdm->orphanized = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make sure we clear our orphanized inode's\n\t\t\t\t * name from the name cache. This is because the\n\t\t\t\t * inode ow_inode might be an ancestor of some\n\t\t\t\t * other inode that will be orphanized as well\n\t\t\t\t * later and has an inode number greater than\n\t\t\t\t * sctx->send_progress. We need to prevent\n\t\t\t\t * future name lookups from using the old name\n\t\t\t\t * and get instead the orphan name.\n\t\t\t\t */\n\t\t\t\tnce = name_cache_search(sctx, ow_inode, ow_gen);\n\t\t\t\tif (nce) {\n\t\t\t\t\tname_cache_delete(sctx, nce);\n\t\t\t\t\tkfree(nce);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * ow_inode might currently be an ancestor of\n\t\t\t\t * cur_ino, therefore compute valid_path (the\n\t\t\t\t * current path of cur_ino) again because it\n\t\t\t\t * might contain the pre-orphanization name of\n\t\t\t\t * ow_inode, which is no longer valid.\n\t\t\t\t */\n\t\t\t\tret = is_ancestor(sctx->parent_root,\n\t\t\t\t\t\t  ow_inode, ow_gen,\n\t\t\t\t\t\t  sctx->cur_ino, NULL);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\torphanized_ancestor = true;\n\t\t\t\t\tfs_path_reset(valid_path);\n\t\t\t\t\tret = get_cur_path(sctx, sctx->cur_ino,\n\t\t\t\t\t\t\t   sctx->cur_inode_gen,\n\t\t\t\t\t\t\t   valid_path);\n\t\t\t\t}\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tlist_for_each_entry(cur, &sctx->new_refs, list) {\n\t\t/*\n\t\t * We may have refs where the parent directory does not exist\n\t\t * yet. This happens if the parent directories inum is higher\n\t\t * than the current inum. To handle this case, we create the\n\t\t * parent directory out of order. But we need to check if this\n\t\t * did already happen before due to other refs in the same dir.\n\t\t */\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret == inode_state_will_create) {\n\t\t\tret = 0;\n\t\t\t/*\n\t\t\t * First check if any of the current inodes refs did\n\t\t\t * already create the dir.\n\t\t\t */\n\t\t\tlist_for_each_entry(cur2, &sctx->new_refs, list) {\n\t\t\t\tif (cur == cur2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (cur2->dir == cur->dir) {\n\t\t\t\t\tret = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If that did not happen, check if a previous inode\n\t\t\t * did already create the dir.\n\t\t\t */\n\t\t\tif (!ret)\n\t\t\t\tret = did_create_dir(sctx, cur->dir);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\tret = send_create_inode(sctx, cur->dir);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root) {\n\t\t\tret = wait_for_dest_dir_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->parent_root &&\n\t\t    can_rename) {\n\t\t\tret = wait_for_parent_move(sctx, cur, is_orphan);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 1) {\n\t\t\t\tcan_rename = false;\n\t\t\t\t*pending_move = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * link/move the ref to the new place. If we have an orphan\n\t\t * inode, move it and update valid_path. If not, link or move\n\t\t * it depending on the inode mode.\n\t\t */\n\t\tif (is_orphan && can_rename) {\n\t\t\tret = send_rename(sctx, valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 0;\n\t\t\tret = fs_path_copy(valid_path, cur->full_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (can_rename) {\n\t\t\tif (S_ISDIR(sctx->cur_inode_mode)) {\n\t\t\t\t/*\n\t\t\t\t * Dirs can't be linked, so move it. For moved\n\t\t\t\t * dirs, we always have one new and one deleted\n\t\t\t\t * ref. The deleted ref is ignored later.\n\t\t\t\t */\n\t\t\t\tret = send_rename(sctx, valid_path,\n\t\t\t\t\t\t  cur->full_path);\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = fs_path_copy(valid_path,\n\t\t\t\t\t\t\t   cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We might have previously orphanized an inode\n\t\t\t\t * which is an ancestor of our current inode,\n\t\t\t\t * so our reference's full path, which was\n\t\t\t\t * computed before any such orphanizations, must\n\t\t\t\t * be updated.\n\t\t\t\t */\n\t\t\t\tif (orphanized_dir) {\n\t\t\t\t\tret = update_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_link(sctx, cur->full_path,\n\t\t\t\t\t\tvalid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (S_ISDIR(sctx->cur_inode_mode) && sctx->cur_inode_deleted) {\n\t\t/*\n\t\t * Check if we can already rmdir the directory. If not,\n\t\t * orphanize it. For every dir item inside that gets deleted\n\t\t * later, we do this check again and rmdir it then if possible.\n\t\t * See the use of check_dirs for more details.\n\t\t */\n\t\tret = can_rmdir(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tsctx->cur_ino);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (!is_orphan) {\n\t\t\tret = orphanize_inode(sctx, sctx->cur_ino,\n\t\t\t\t\tsctx->cur_inode_gen, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tis_orphan = 1;\n\t\t}\n\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (S_ISDIR(sctx->cur_inode_mode) &&\n\t\t   !list_empty(&sctx->deleted_refs)) {\n\t\t/*\n\t\t * We have a moved dir. Add the old parent to check_dirs\n\t\t */\n\t\tcur = list_entry(sctx->deleted_refs.next, struct recorded_ref,\n\t\t\t\tlist);\n\t\tret = dup_ref(cur, &check_dirs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else if (!S_ISDIR(sctx->cur_inode_mode)) {\n\t\t/*\n\t\t * We have a non dir inode. Go through all deleted refs and\n\t\t * unlink them if they were not already overwritten by other\n\t\t * inodes.\n\t\t */\n\t\tlist_for_each_entry(cur, &sctx->deleted_refs, list) {\n\t\t\tret = did_overwrite_ref(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\t\tcur->name, cur->name_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (!ret) {\n\t\t\t\t/*\n\t\t\t\t * If we orphanized any ancestor before, we need\n\t\t\t\t * to recompute the full path for deleted names,\n\t\t\t\t * since any such path was computed before we\n\t\t\t\t * processed any references and orphanized any\n\t\t\t\t * ancestor inode.\n\t\t\t\t */\n\t\t\t\tif (orphanized_ancestor) {\n\t\t\t\t\tret = update_ref_path(sctx, cur);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_unlink(sctx, cur->full_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = dup_ref(cur, &check_dirs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * If the inode is still orphan, unlink the orphan. This may\n\t\t * happen when a previous inode did overwrite the first ref\n\t\t * of this inode and no new refs were added for the current\n\t\t * inode. Unlinking does not mean that the inode is deleted in\n\t\t * all cases. There may still be links to this inode in other\n\t\t * places.\n\t\t */\n\t\tif (is_orphan) {\n\t\t\tret = send_unlink(sctx, valid_path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We did collect all parent dirs where cur_inode was once located. We\n\t * now go through all these dirs and check if they are pending for\n\t * deletion and if it's finally possible to perform the rmdir now.\n\t * We also update the inode stats of the parent dirs here.\n\t */\n\tlist_for_each_entry(cur, &check_dirs, list) {\n\t\t/*\n\t\t * In case we had refs into dirs that were not processed yet,\n\t\t * we don't need to do the utime and rmdir logic for these dirs.\n\t\t * The dir will be processed later.\n\t\t */\n\t\tif (cur->dir > sctx->cur_ino)\n\t\t\tcontinue;\n\n\t\tret = get_cur_inode_state(sctx, cur->dir, cur->dir_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (ret == inode_state_did_create ||\n\t\t    ret == inode_state_no_change) {\n\t\t\t/* TODO delayed utimes */\n\t\t\tret = send_utimes(sctx, cur->dir, cur->dir_gen);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else if (ret == inode_state_did_delete &&\n\t\t\t   cur->dir != last_dir_ino_rm) {\n\t\t\tret = can_rmdir(sctx, cur->dir, cur->dir_gen,\n\t\t\t\t\tsctx->cur_ino);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret) {\n\t\t\t\tret = get_cur_path(sctx, cur->dir,\n\t\t\t\t\t\t   cur->dir_gen, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tret = send_rmdir(sctx, valid_path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tlast_dir_ino_rm = cur->dir;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nout:\n\t__free_recorded_refs(&check_dirs);\n\tfree_recorded_refs(sctx);\n\tfs_path_free(valid_path);\n\treturn ret;\n}\n\nstatic int record_ref(struct btrfs_root *root, u64 dir, struct fs_path *name,\n\t\t      void *ctx, struct list_head *refs)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_inode_info(root, dir, NULL, &gen, NULL, NULL,\n\t\t\tNULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, dir, gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = fs_path_add_path(p, name);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __record_ref(refs, dir, gen, p);\n\nout:\n\tif (ret)\n\t\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int __record_new_ref(int num, u64 dir, int index,\n\t\t\t    struct fs_path *name,\n\t\t\t    void *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->send_root, dir, name, ctx, &sctx->new_refs);\n}\n\n\nstatic int __record_deleted_ref(int num, u64 dir, int index,\n\t\t\t\tstruct fs_path *name,\n\t\t\t\tvoid *ctx)\n{\n\tstruct send_ctx *sctx = ctx;\n\treturn record_ref(sctx->parent_root, dir, name, ctx,\n\t\t\t  &sctx->deleted_refs);\n}\n\nstatic int record_new_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\t\tsctx->cmp_key, 0, __record_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int record_deleted_ref(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\t\tsctx->cmp_key, 0, __record_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstruct find_ref_ctx {\n\tu64 dir;\n\tu64 dir_gen;\n\tstruct btrfs_root *root;\n\tstruct fs_path *name;\n\tint found_idx;\n};\n\nstatic int __find_iref(int num, u64 dir, int index,\n\t\t       struct fs_path *name,\n\t\t       void *ctx_)\n{\n\tstruct find_ref_ctx *ctx = ctx_;\n\tu64 dir_gen;\n\tint ret;\n\n\tif (dir == ctx->dir && fs_path_len(name) == fs_path_len(ctx->name) &&\n\t    strncmp(name->start, ctx->name->start, fs_path_len(name)) == 0) {\n\t\t/*\n\t\t * To avoid doing extra lookups we'll only do this if everything\n\t\t * else matches.\n\t\t */\n\t\tret = get_inode_info(ctx->root, dir, NULL, &dir_gen, NULL,\n\t\t\t\t     NULL, NULL, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (dir_gen != ctx->dir_gen)\n\t\t\treturn 0;\n\t\tctx->found_idx = num;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int find_iref(struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *key,\n\t\t     u64 dir, u64 dir_gen, struct fs_path *name)\n{\n\tint ret;\n\tstruct find_ref_ctx ctx;\n\n\tctx.dir = dir;\n\tctx.name = name;\n\tctx.dir_gen = dir_gen;\n\tctx.found_idx = -1;\n\tctx.root = root;\n\n\tret = iterate_inode_ref(root, path, key, 0, __find_iref, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\n\treturn ctx.found_idx;\n}\n\nstatic int __record_changed_new_ref(int num, u64 dir, int index,\n\t\t\t\t    struct fs_path *name,\n\t\t\t\t    void *ctx)\n{\n\tu64 dir_gen;\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &dir_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = find_iref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, dir, dir_gen, name);\n\tif (ret == -ENOENT)\n\t\tret = __record_new_ref(num, dir, index, name, sctx);\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int __record_changed_deleted_ref(int num, u64 dir, int index,\n\t\t\t\t\tstruct fs_path *name,\n\t\t\t\t\tvoid *ctx)\n{\n\tu64 dir_gen;\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &dir_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = find_iref(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\tdir, dir_gen, name);\n\tif (ret == -ENOENT)\n\t\tret = __record_deleted_ref(num, dir, index, name, sctx);\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int record_changed_ref(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_inode_ref(sctx->send_root, sctx->left_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_new_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_inode_ref(sctx->parent_root, sctx->right_path,\n\t\t\tsctx->cmp_key, 0, __record_changed_deleted_ref, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\n/*\n * Record and process all refs at once. Needed when an inode changes the\n * generation number, which means that it was deleted and recreated.\n */\nstatic int process_all_refs(struct send_ctx *sctx,\n\t\t\t    enum btrfs_compare_tree_result cmd)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\titerate_inode_ref_t cb;\n\tint pending_move = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (cmd == BTRFS_COMPARE_TREE_NEW) {\n\t\troot = sctx->send_root;\n\t\tcb = __record_new_ref;\n\t} else if (cmd == BTRFS_COMPARE_TREE_DELETED) {\n\t\troot = sctx->parent_root;\n\t\tcb = __record_deleted_ref;\n\t} else {\n\t\tbtrfs_err(sctx->send_root->fs_info,\n\t\t\t\t\"Wrong command %d in process_all_refs\", cmd);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    (found_key.type != BTRFS_INODE_REF_KEY &&\n\t\t     found_key.type != BTRFS_INODE_EXTREF_KEY))\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(root, path, &found_key, 0, cb, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * We don't actually care about pending_move as we are simply\n\t * re-creating this inode and will be rename'ing it into place once we\n\t * rename the parent directory.\n\t */\n\tret = process_recorded_refs(sctx, &pending_move);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int send_set_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len,\n\t\t\t  const char *data, int data_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_SET_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\tTLV_PUT(sctx, BTRFS_SEND_A_XATTR_DATA, data, data_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\nstatic int send_remove_xattr(struct send_ctx *sctx,\n\t\t\t  struct fs_path *path,\n\t\t\t  const char *name, int name_len)\n{\n\tint ret = 0;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_REMOVE_XATTR);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, path);\n\tTLV_PUT_STRING(sctx, BTRFS_SEND_A_XATTR_NAME, name, name_len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\treturn ret;\n}\n\nstatic int __process_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t       const char *name, int name_len,\n\t\t\t       const char *data, int data_len,\n\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\tstruct posix_acl_xattr_header dummy_acl;\n\n\t/* Capabilities are emitted by finish_inode_if_needed */\n\tif (!strncmp(name, XATTR_NAME_CAPS, name_len))\n\t\treturn 0;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * This hack is needed because empty acls are stored as zero byte\n\t * data in xattrs. Problem with that is, that receiving these zero byte\n\t * acls will fail later. To fix this, we send a dummy acl list that\n\t * only contains the version number and no entries.\n\t */\n\tif (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS, name_len) ||\n\t    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT, name_len)) {\n\t\tif (data_len == 0) {\n\t\t\tdummy_acl.a_version =\n\t\t\t\t\tcpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\t\t\tdata = (char *)&dummy_acl;\n\t\t\tdata_len = sizeof(dummy_acl);\n\t\t}\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_set_xattr(sctx, p, name, name_len, data, data_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int __process_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t   const char *name, int name_len,\n\t\t\t\t   const char *data, int data_len,\n\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_remove_xattr(sctx, p, name, name_len);\n\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int process_new_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t       __process_new_xattr, sctx);\n\n\treturn ret;\n}\n\nstatic int process_deleted_xattr(struct send_ctx *sctx)\n{\n\treturn iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t\t__process_deleted_xattr, sctx);\n}\n\nstruct find_xattr_ctx {\n\tconst char *name;\n\tint name_len;\n\tint found_idx;\n\tchar *found_data;\n\tint found_data_len;\n};\n\nstatic int __find_xattr(int num, struct btrfs_key *di_key,\n\t\t\tconst char *name, int name_len,\n\t\t\tconst char *data, int data_len,\n\t\t\tu8 type, void *vctx)\n{\n\tstruct find_xattr_ctx *ctx = vctx;\n\n\tif (name_len == ctx->name_len &&\n\t    strncmp(name, ctx->name, name_len) == 0) {\n\t\tctx->found_idx = num;\n\t\tctx->found_data_len = data_len;\n\t\tctx->found_data = kmemdup(data, data_len, GFP_KERNEL);\n\t\tif (!ctx->found_data)\n\t\t\treturn -ENOMEM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int find_xattr(struct btrfs_root *root,\n\t\t      struct btrfs_path *path,\n\t\t      struct btrfs_key *key,\n\t\t      const char *name, int name_len,\n\t\t      char **data, int *data_len)\n{\n\tint ret;\n\tstruct find_xattr_ctx ctx;\n\n\tctx.name = name;\n\tctx.name_len = name_len;\n\tctx.found_idx = -1;\n\tctx.found_data = NULL;\n\tctx.found_data_len = 0;\n\n\tret = iterate_dir_item(root, path, __find_xattr, &ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ctx.found_idx == -1)\n\t\treturn -ENOENT;\n\tif (data) {\n\t\t*data = ctx.found_data;\n\t\t*data_len = ctx.found_data_len;\n\t} else {\n\t\tkfree(ctx.found_data);\n\t}\n\treturn ctx.found_idx;\n}\n\n\nstatic int __process_changed_new_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t       const char *name, int name_len,\n\t\t\t\t       const char *data, int data_len,\n\t\t\t\t       u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\tchar *found_data = NULL;\n\tint found_data_len  = 0;\n\n\tret = find_xattr(sctx->parent_root, sctx->right_path,\n\t\t\t sctx->cmp_key, name, name_len, &found_data,\n\t\t\t &found_data_len);\n\tif (ret == -ENOENT) {\n\t\tret = __process_new_xattr(num, di_key, name, name_len, data,\n\t\t\t\tdata_len, type, ctx);\n\t} else if (ret >= 0) {\n\t\tif (data_len != found_data_len ||\n\t\t    memcmp(data, found_data, data_len)) {\n\t\t\tret = __process_new_xattr(num, di_key, name, name_len,\n\t\t\t\t\tdata, data_len, type, ctx);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tkfree(found_data);\n\treturn ret;\n}\n\nstatic int __process_changed_deleted_xattr(int num, struct btrfs_key *di_key,\n\t\t\t\t\t   const char *name, int name_len,\n\t\t\t\t\t   const char *data, int data_len,\n\t\t\t\t\t   u8 type, void *ctx)\n{\n\tint ret;\n\tstruct send_ctx *sctx = ctx;\n\n\tret = find_xattr(sctx->send_root, sctx->left_path, sctx->cmp_key,\n\t\t\t name, name_len, NULL, NULL);\n\tif (ret == -ENOENT)\n\t\tret = __process_deleted_xattr(num, di_key, name, name_len, data,\n\t\t\t\tdata_len, type, ctx);\n\telse if (ret >= 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int process_changed_xattr(struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tret = iterate_dir_item(sctx->send_root, sctx->left_path,\n\t\t\t__process_changed_new_xattr, sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = iterate_dir_item(sctx->parent_root, sctx->right_path,\n\t\t\t__process_changed_deleted_xattr, sctx);\n\nout:\n\treturn ret;\n}\n\nstatic int process_all_new_xattrs(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\troot = sctx->send_root;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_XATTR_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = iterate_dir_item(root, path, __process_new_xattr, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic inline u64 max_send_read_size(const struct send_ctx *sctx)\n{\n\treturn sctx->send_max_size - SZ_16K;\n}\n\nstatic int put_data_header(struct send_ctx *sctx, u32 len)\n{\n\tstruct btrfs_tlv_header *hdr;\n\n\tif (sctx->send_max_size - sctx->send_size < sizeof(*hdr) + len)\n\t\treturn -EOVERFLOW;\n\thdr = (struct btrfs_tlv_header *)(sctx->send_buf + sctx->send_size);\n\tput_unaligned_le16(BTRFS_SEND_A_DATA, &hdr->tlv_type);\n\tput_unaligned_le16(len, &hdr->tlv_len);\n\tsctx->send_size += sizeof(*hdr);\n\treturn 0;\n}\n\nstatic int put_file_data(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct inode *inode;\n\tstruct page *page;\n\tpgoff_t index = offset >> PAGE_SHIFT;\n\tpgoff_t last_index;\n\tunsigned pg_offset = offset_in_page(offset);\n\tint ret;\n\n\tret = put_data_header(sctx, len);\n\tif (ret)\n\t\treturn ret;\n\n\tinode = btrfs_iget(fs_info->sb, sctx->cur_ino, root);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tlast_index = (offset + len - 1) >> PAGE_SHIFT;\n\n\t/* initial readahead */\n\tmemset(&sctx->ra, 0, sizeof(struct file_ra_state));\n\tfile_ra_state_init(&sctx->ra, inode->i_mapping);\n\n\twhile (index <= last_index) {\n\t\tunsigned cur_len = min_t(unsigned, len,\n\t\t\t\t\t PAGE_SIZE - pg_offset);\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping, &sctx->ra,\n\t\t\t\tNULL, index, last_index + 1 - index);\n\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!page) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping, &sctx->ra,\n\t\t\t\tNULL, page, index, last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy_from_page(sctx->send_buf + sctx->send_size, page,\n\t\t\t\t pg_offset, cur_len);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tindex++;\n\t\tpg_offset = 0;\n\t\tlen -= cur_len;\n\t\tsctx->send_size += cur_len;\n\t}\n\tiput(inode);\n\treturn ret;\n}\n\n/*\n * Read some bytes from the current inode/file and send a write command to\n * user space.\n */\nstatic int send_write(struct send_ctx *sctx, u64 offset, u32 len)\n{\n\tstruct btrfs_fs_info *fs_info = sctx->send_root->fs_info;\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tbtrfs_debug(fs_info, \"send_write offset=%llu, len=%d\", offset, len);\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tret = put_file_data(sctx, offset, len);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\n/*\n * Send a clone command to user space.\n */\nstatic int send_clone(struct send_ctx *sctx,\n\t\t      u64 offset, u32 len,\n\t\t      struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\tu64 gen;\n\n\tbtrfs_debug(sctx->send_root->fs_info,\n\t\t    \"send_clone offset=%llu, len=%d, clone_root=%llu, clone_inode=%llu, clone_offset=%llu\",\n\t\t    offset, len, clone_root->root->root_key.objectid,\n\t\t    clone_root->ino, clone_root->offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_CLONE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_LEN, len);\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\n\tif (clone_root->root == sctx->send_root) {\n\t\tret = get_inode_info(sctx->send_root, clone_root->ino, NULL,\n\t\t\t\t&gen, NULL, NULL, NULL, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = get_cur_path(sctx, clone_root->ino, gen, p);\n\t} else {\n\t\tret = get_inode_path(clone_root->root, clone_root->ino, p);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * If the parent we're using has a received_uuid set then use that as\n\t * our clone source as that is what we will look for when doing a\n\t * receive.\n\t *\n\t * This covers the case that we create a snapshot off of a received\n\t * subvolume and then use that as the parent and try to receive on a\n\t * different host.\n\t */\n\tif (!btrfs_is_empty_uuid(clone_root->root->root_item.received_uuid))\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t     clone_root->root->root_item.received_uuid);\n\telse\n\t\tTLV_PUT_UUID(sctx, BTRFS_SEND_A_CLONE_UUID,\n\t\t\t     clone_root->root->root_item.uuid);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_CTRANSID,\n\t\t    btrfs_root_ctransid(&clone_root->root->root_item));\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_CLONE_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_CLONE_OFFSET,\n\t\t\tclone_root->offset);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\n/*\n * Send an update extent command to user space.\n */\nstatic int send_update_extent(struct send_ctx *sctx,\n\t\t\t      u64 offset, u32 len)\n{\n\tint ret = 0;\n\tstruct fs_path *p;\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = begin_cmd(sctx, BTRFS_SEND_C_UPDATE_EXTENT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\tTLV_PUT_U64(sctx, BTRFS_SEND_A_SIZE, len);\n\n\tret = send_cmd(sctx);\n\ntlv_put_failure:\nout:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_hole(struct send_ctx *sctx, u64 end)\n{\n\tstruct fs_path *p = NULL;\n\tu64 read_size = max_send_read_size(sctx);\n\tu64 offset = sctx->cur_inode_last_extent;\n\tint ret = 0;\n\n\t/*\n\t * A hole that starts at EOF or beyond it. Since we do not yet support\n\t * fallocate (for extent preallocation and hole punching), sending a\n\t * write of zeroes starting at EOF or beyond would later require issuing\n\t * a truncate operation which would undo the write and achieve nothing.\n\t */\n\tif (offset >= sctx->cur_inode_size)\n\t\treturn 0;\n\n\t/*\n\t * Don't go beyond the inode's i_size due to prealloc extents that start\n\t * after the i_size.\n\t */\n\tend = min_t(u64, end, sctx->cur_inode_size);\n\n\tif (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA)\n\t\treturn send_update_extent(sctx, offset, end - offset);\n\n\tp = fs_path_alloc();\n\tif (!p)\n\t\treturn -ENOMEM;\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, p);\n\tif (ret < 0)\n\t\tgoto tlv_put_failure;\n\twhile (offset < end) {\n\t\tu64 len = min(end - offset, read_size);\n\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_WRITE);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tTLV_PUT_PATH(sctx, BTRFS_SEND_A_PATH, p);\n\t\tTLV_PUT_U64(sctx, BTRFS_SEND_A_FILE_OFFSET, offset);\n\t\tret = put_data_header(sctx, len);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tmemset(sctx->send_buf + sctx->send_size, 0, len);\n\t\tsctx->send_size += len;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\toffset += len;\n\t}\n\tsctx->cur_inode_next_write_offset = offset;\ntlv_put_failure:\n\tfs_path_free(p);\n\treturn ret;\n}\n\nstatic int send_extent_data(struct send_ctx *sctx,\n\t\t\t    const u64 offset,\n\t\t\t    const u64 len)\n{\n\tu64 read_size = max_send_read_size(sctx);\n\tu64 sent = 0;\n\n\tif (sctx->flags & BTRFS_SEND_FLAG_NO_FILE_DATA)\n\t\treturn send_update_extent(sctx, offset, len);\n\n\twhile (sent < len) {\n\t\tu64 size = min(len - sent, read_size);\n\t\tint ret;\n\n\t\tret = send_write(sctx, offset + sent, size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsent += size;\n\t}\n\treturn 0;\n}\n\n/*\n * Search for a capability xattr related to sctx->cur_ino. If the capability is\n * found, call send_set_xattr function to emit it.\n *\n * Return 0 if there isn't a capability, or when the capability was emitted\n * successfully, or < 0 if an error occurred.\n */\nstatic int send_capabilities(struct send_ctx *sctx)\n{\n\tstruct fs_path *fspath = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *di;\n\tstruct extent_buffer *leaf;\n\tunsigned long data_ptr;\n\tchar *buf = NULL;\n\tint buf_len;\n\tint ret = 0;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tdi = btrfs_lookup_xattr(NULL, sctx->send_root, path, sctx->cur_ino,\n\t\t\t\tXATTR_NAME_CAPS, strlen(XATTR_NAME_CAPS), 0);\n\tif (!di) {\n\t\t/* There is no xattr for this inode */\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tbuf_len = btrfs_dir_data_len(leaf, di);\n\n\tfspath = fs_path_alloc();\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!fspath || !buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = get_cur_path(sctx, sctx->cur_ino, sctx->cur_inode_gen, fspath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdata_ptr = (unsigned long)(di + 1) + btrfs_dir_name_len(leaf, di);\n\tread_extent_buffer(leaf, buf, data_ptr, buf_len);\n\n\tret = send_set_xattr(sctx, fspath, XATTR_NAME_CAPS,\n\t\t\tstrlen(XATTR_NAME_CAPS), buf, buf_len);\nout:\n\tkfree(buf);\n\tfs_path_free(fspath);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int clone_range(struct send_ctx *sctx,\n\t\t       struct clone_root *clone_root,\n\t\t       const u64 disk_byte,\n\t\t       u64 data_offset,\n\t\t       u64 offset,\n\t\t       u64 len)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tu64 clone_src_i_size = 0;\n\n\t/*\n\t * Prevent cloning from a zero offset with a length matching the sector\n\t * size because in some scenarios this will make the receiver fail.\n\t *\n\t * For example, if in the source filesystem the extent at offset 0\n\t * has a length of sectorsize and it was written using direct IO, then\n\t * it can never be an inline extent (even if compression is enabled).\n\t * Then this extent can be cloned in the original filesystem to a non\n\t * zero file offset, but it may not be possible to clone in the\n\t * destination filesystem because it can be inlined due to compression\n\t * on the destination filesystem (as the receiver's write operations are\n\t * always done using buffered IO). The same happens when the original\n\t * filesystem does not have compression enabled but the destination\n\t * filesystem has.\n\t */\n\tif (clone_root->offset == 0 &&\n\t    len == sctx->send_root->fs_info->sectorsize)\n\t\treturn send_extent_data(sctx, offset, len);\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * There are inodes that have extents that lie behind its i_size. Don't\n\t * accept clones from these extents.\n\t */\n\tret = __get_inode_info(clone_root->root, path, clone_root->ino,\n\t\t\t       &clone_src_i_size, NULL, NULL, NULL, NULL, NULL);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We can't send a clone operation for the entire range if we find\n\t * extent items in the respective range in the source file that\n\t * refer to different extents or if we find holes.\n\t * So check for that and do a mix of clone and regular write/copy\n\t * operations if needed.\n\t *\n\t * Example:\n\t *\n\t * mkfs.btrfs -f /dev/sda\n\t * mount /dev/sda /mnt\n\t * xfs_io -f -c \"pwrite -S 0xaa 0K 100K\" /mnt/foo\n\t * cp --reflink=always /mnt/foo /mnt/bar\n\t * xfs_io -c \"pwrite -S 0xbb 50K 50K\" /mnt/foo\n\t * btrfs subvolume snapshot -r /mnt /mnt/snap\n\t *\n\t * If when we send the snapshot and we are processing file bar (which\n\t * has a higher inode number than foo) we blindly send a clone operation\n\t * for the [0, 100K[ range from foo to bar, the receiver ends up getting\n\t * a file bar that matches the content of file foo - iow, doesn't match\n\t * the content from bar in the original filesystem.\n\t */\n\tkey.objectid = clone_root->ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = clone_root->offset;\n\tret = btrfs_search_slot(NULL, clone_root->root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0] - 1);\n\t\tif (key.objectid == clone_root->ino &&\n\t\t    key.type == BTRFS_EXTENT_DATA_KEY)\n\t\t\tpath->slots[0]--;\n\t}\n\n\twhile (true) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\t\tu64 ext_len;\n\t\tu64 clone_len;\n\t\tu64 clone_data_offset;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(clone_root->root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\t/*\n\t\t * We might have an implicit trailing hole (NO_HOLES feature\n\t\t * enabled). We deal with it after leaving this loop.\n\t\t */\n\t\tif (key.objectid != clone_root->ino ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\tei = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(leaf, ei);\n\t\tif (type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\text_len = btrfs_file_extent_ram_bytes(leaf, ei);\n\t\t\text_len = PAGE_ALIGN(ext_len);\n\t\t} else {\n\t\t\text_len = btrfs_file_extent_num_bytes(leaf, ei);\n\t\t}\n\n\t\tif (key.offset + ext_len <= clone_root->offset)\n\t\t\tgoto next;\n\n\t\tif (key.offset > clone_root->offset) {\n\t\t\t/* Implicit hole, NO_HOLES feature enabled. */\n\t\t\tu64 hole_len = key.offset - clone_root->offset;\n\n\t\t\tif (hole_len > len)\n\t\t\t\thole_len = len;\n\t\t\tret = send_extent_data(sctx, offset, hole_len);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tlen -= hole_len;\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\toffset += hole_len;\n\t\t\tclone_root->offset += hole_len;\n\t\t\tdata_offset += hole_len;\n\t\t}\n\n\t\tif (key.offset >= clone_root->offset + len)\n\t\t\tbreak;\n\n\t\tif (key.offset >= clone_src_i_size)\n\t\t\tbreak;\n\n\t\tif (key.offset + ext_len > clone_src_i_size)\n\t\t\text_len = clone_src_i_size - key.offset;\n\n\t\tclone_data_offset = btrfs_file_extent_offset(leaf, ei);\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, ei) == disk_byte) {\n\t\t\tclone_root->offset = key.offset;\n\t\t\tif (clone_data_offset < data_offset &&\n\t\t\t\tclone_data_offset + ext_len > data_offset) {\n\t\t\t\tu64 extent_offset;\n\n\t\t\t\textent_offset = data_offset - clone_data_offset;\n\t\t\t\text_len -= extent_offset;\n\t\t\t\tclone_data_offset += extent_offset;\n\t\t\t\tclone_root->offset += extent_offset;\n\t\t\t}\n\t\t}\n\n\t\tclone_len = min_t(u64, ext_len, len);\n\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, ei) == disk_byte &&\n\t\t    clone_data_offset == data_offset) {\n\t\t\tconst u64 src_end = clone_root->offset + clone_len;\n\t\t\tconst u64 sectorsize = SZ_64K;\n\n\t\t\t/*\n\t\t\t * We can't clone the last block, when its size is not\n\t\t\t * sector size aligned, into the middle of a file. If we\n\t\t\t * do so, the receiver will get a failure (-EINVAL) when\n\t\t\t * trying to clone or will silently corrupt the data in\n\t\t\t * the destination file if it's on a kernel without the\n\t\t\t * fix introduced by commit ac765f83f1397646\n\t\t\t * (\"Btrfs: fix data corruption due to cloning of eof\n\t\t\t * block).\n\t\t\t *\n\t\t\t * So issue a clone of the aligned down range plus a\n\t\t\t * regular write for the eof block, if we hit that case.\n\t\t\t *\n\t\t\t * Also, we use the maximum possible sector size, 64K,\n\t\t\t * because we don't know what's the sector size of the\n\t\t\t * filesystem that receives the stream, so we have to\n\t\t\t * assume the largest possible sector size.\n\t\t\t */\n\t\t\tif (src_end == clone_src_i_size &&\n\t\t\t    !IS_ALIGNED(src_end, sectorsize) &&\n\t\t\t    offset + clone_len < sctx->cur_inode_size) {\n\t\t\t\tu64 slen;\n\n\t\t\t\tslen = ALIGN_DOWN(src_end - clone_root->offset,\n\t\t\t\t\t\t  sectorsize);\n\t\t\t\tif (slen > 0) {\n\t\t\t\t\tret = send_clone(sctx, offset, slen,\n\t\t\t\t\t\t\t clone_root);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = send_extent_data(sctx, offset + slen,\n\t\t\t\t\t\t       clone_len - slen);\n\t\t\t} else {\n\t\t\t\tret = send_clone(sctx, offset, clone_len,\n\t\t\t\t\t\t clone_root);\n\t\t\t}\n\t\t} else {\n\t\t\tret = send_extent_data(sctx, offset, clone_len);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tlen -= clone_len;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\toffset += clone_len;\n\t\tclone_root->offset += clone_len;\n\n\t\t/*\n\t\t * If we are cloning from the file we are currently processing,\n\t\t * and using the send root as the clone root, we must stop once\n\t\t * the current clone offset reaches the current eof of the file\n\t\t * at the receiver, otherwise we would issue an invalid clone\n\t\t * operation (source range going beyond eof) and cause the\n\t\t * receiver to fail. So if we reach the current eof, bail out\n\t\t * and fallback to a regular write.\n\t\t */\n\t\tif (clone_root->root == sctx->send_root &&\n\t\t    clone_root->ino == sctx->cur_ino &&\n\t\t    clone_root->offset >= sctx->cur_inode_next_write_offset)\n\t\t\tbreak;\n\n\t\tdata_offset += clone_len;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\n\tif (len > 0)\n\t\tret = send_extent_data(sctx, offset, len);\n\telse\n\t\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int send_write_or_clone(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *key,\n\t\t\t       struct clone_root *clone_root)\n{\n\tint ret = 0;\n\tu64 offset = key->offset;\n\tu64 end;\n\tu64 bs = sctx->send_root->fs_info->sb->s_blocksize;\n\n\tend = min_t(u64, btrfs_file_extent_end(path), sctx->cur_inode_size);\n\tif (offset >= end)\n\t\treturn 0;\n\n\tif (clone_root && IS_ALIGNED(end, bs)) {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu64 disk_byte;\n\t\tu64 data_offset;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(path->nodes[0], ei);\n\t\tdata_offset = btrfs_file_extent_offset(path->nodes[0], ei);\n\t\tret = clone_range(sctx, clone_root, disk_byte, data_offset,\n\t\t\t\t  offset, end - offset);\n\t} else {\n\t\tret = send_extent_data(sctx, offset, end - offset);\n\t}\n\tsctx->cur_inode_next_write_offset = end;\n\treturn ret;\n}\n\nstatic int is_extent_unchanged(struct send_ctx *sctx,\n\t\t\t       struct btrfs_path *left_path,\n\t\t\t       struct btrfs_key *ekey)\n{\n\tint ret = 0;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_file_extent_item *ei;\n\tu64 left_disknr;\n\tu64 right_disknr;\n\tu64 left_offset;\n\tu64 right_offset;\n\tu64 left_offset_fixed;\n\tu64 left_len;\n\tu64 right_len;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu8 left_type;\n\tu8 right_type;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\teb = left_path->nodes[0];\n\tslot = left_path->slots[0];\n\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\tleft_type = btrfs_file_extent_type(eb, ei);\n\n\tif (left_type != BTRFS_FILE_EXTENT_REG) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tleft_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\tleft_len = btrfs_file_extent_num_bytes(eb, ei);\n\tleft_offset = btrfs_file_extent_offset(eb, ei);\n\tleft_gen = btrfs_file_extent_generation(eb, ei);\n\n\t/*\n\t * Following comments will refer to these graphics. L is the left\n\t * extents which we are checking at the moment. 1-8 are the right\n\t * extents that we iterate.\n\t *\n\t *       |-----L-----|\n\t * |-1-|-2a-|-3-|-4-|-5-|-6-|\n\t *\n\t *       |-----L-----|\n\t * |--1--|-2b-|...(same as above)\n\t *\n\t * Alternative situation. Happens on files where extents got split.\n\t *       |-----L-----|\n\t * |-----------7-----------|-6-|\n\t *\n\t * Alternative situation. Happens on files which got larger.\n\t *       |-----L-----|\n\t * |-8-|\n\t * Nothing follows after 8.\n\t */\n\n\tkey.objectid = ekey->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = ekey->offset;\n\tret = btrfs_search_slot_for_read(sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Handle special case where the right side has no extents at all.\n\t */\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\tif (found_key.objectid != key.objectid ||\n\t    found_key.type != key.type) {\n\t\t/* If we're a hole then just pretend nothing changed */\n\t\tret = (left_disknr) ? 0 : 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We're now on 2a, 2b or 7.\n\t */\n\tkey = found_key;\n\twhile (key.offset < ekey->offset + left_len) {\n\t\tei = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tright_type = btrfs_file_extent_type(eb, ei);\n\t\tif (right_type != BTRFS_FILE_EXTENT_REG &&\n\t\t    right_type != BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (right_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tright_len = btrfs_file_extent_ram_bytes(eb, ei);\n\t\t\tright_len = PAGE_ALIGN(right_len);\n\t\t} else {\n\t\t\tright_len = btrfs_file_extent_num_bytes(eb, ei);\n\t\t}\n\n\t\t/*\n\t\t * Are we at extent 8? If yes, we know the extent is changed.\n\t\t * This may only happen on the first iteration.\n\t\t */\n\t\tif (found_key.offset + right_len <= ekey->offset) {\n\t\t\t/* If we're a hole just pretend nothing changed */\n\t\t\tret = (left_disknr) ? 0 : 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We just wanted to see if when we have an inline extent, what\n\t\t * follows it is a regular extent (wanted to check the above\n\t\t * condition for inline extents too). This should normally not\n\t\t * happen but it's possible for example when we have an inline\n\t\t * compressed extent representing data with a size matching\n\t\t * the page size (currently the same as sector size).\n\t\t */\n\t\tif (right_type == BTRFS_FILE_EXTENT_INLINE) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tright_disknr = btrfs_file_extent_disk_bytenr(eb, ei);\n\t\tright_offset = btrfs_file_extent_offset(eb, ei);\n\t\tright_gen = btrfs_file_extent_generation(eb, ei);\n\n\t\tleft_offset_fixed = left_offset;\n\t\tif (key.offset < ekey->offset) {\n\t\t\t/* Fix the right offset for 2a and 7. */\n\t\t\tright_offset += ekey->offset - key.offset;\n\t\t} else {\n\t\t\t/* Fix the left offset for all behind 2a and 2b */\n\t\t\tleft_offset_fixed += key.offset - ekey->offset;\n\t\t}\n\n\t\t/*\n\t\t * Check if we have the same extent.\n\t\t */\n\t\tif (left_disknr != right_disknr ||\n\t\t    left_offset_fixed != right_offset ||\n\t\t    left_gen != right_gen) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Go to the next extent.\n\t\t */\n\t\tret = btrfs_next_item(sctx->parent_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (!ret) {\n\t\t\teb = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\t}\n\t\tif (ret || found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tkey.offset += right_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (found_key.offset != key.offset + right_len) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkey = found_key;\n\t}\n\n\t/*\n\t * We're now behind the left extent (treat as unchanged) or at the end\n\t * of the right side (treat as changed).\n\t */\n\tif (key.offset >= ekey->offset + left_len)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int get_last_extent(struct send_ctx *sctx, u64 offset)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = sctx->send_root;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tsctx->cur_inode_last_extent = 0;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = offset;\n\tret = btrfs_search_slot_for_read(root, &key, path, 0, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = 0;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, path->slots[0]);\n\tif (key.objectid != sctx->cur_ino || key.type != BTRFS_EXTENT_DATA_KEY)\n\t\tgoto out;\n\n\tsctx->cur_inode_last_extent = btrfs_file_extent_end(path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int range_is_hole_in_parent(struct send_ctx *sctx,\n\t\t\t\t   const u64 start,\n\t\t\t\t   const u64 end)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = sctx->parent_root;\n\tu64 search_start = start;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = search_start;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0 && path->slots[0] > 0)\n\t\tpath->slots[0]--;\n\n\twhile (search_start < end) {\n\t\tstruct extent_buffer *leaf = path->nodes[0];\n\t\tint slot = path->slots[0];\n\t\tstruct btrfs_file_extent_item *fi;\n\t\tu64 extent_end;\n\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid < sctx->cur_ino ||\n\t\t    key.type < BTRFS_EXTENT_DATA_KEY)\n\t\t\tgoto next;\n\t\tif (key.objectid > sctx->cur_ino ||\n\t\t    key.type > BTRFS_EXTENT_DATA_KEY ||\n\t\t    key.offset >= end)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\t\textent_end = btrfs_file_extent_end(path);\n\t\tif (extent_end <= start)\n\t\t\tgoto next;\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, fi) == 0) {\n\t\t\tsearch_start = extent_end;\n\t\t\tgoto next;\n\t\t}\n\t\tret = 0;\n\t\tgoto out;\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int maybe_send_hole(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\t   struct btrfs_key *key)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino != key->objectid || !need_send_hole(sctx))\n\t\treturn 0;\n\n\tif (sctx->cur_inode_last_extent == (u64)-1) {\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (path->slots[0] == 0 &&\n\t    sctx->cur_inode_last_extent < key->offset) {\n\t\t/*\n\t\t * We might have skipped entire leafs that contained only\n\t\t * file extent items for our current inode. These leafs have\n\t\t * a generation number smaller (older) than the one in the\n\t\t * current leaf and the leaf our last extent came from, and\n\t\t * are located between these 2 leafs.\n\t\t */\n\t\tret = get_last_extent(sctx, key->offset - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sctx->cur_inode_last_extent < key->offset) {\n\t\tret = range_is_hole_in_parent(sctx,\n\t\t\t\t\t      sctx->cur_inode_last_extent,\n\t\t\t\t\t      key->offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == 0)\n\t\t\tret = send_hole(sctx, key->offset);\n\t\telse\n\t\t\tret = 0;\n\t}\n\tsctx->cur_inode_last_extent = btrfs_file_extent_end(path);\n\treturn ret;\n}\n\nstatic int process_extent(struct send_ctx *sctx,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct btrfs_key *key)\n{\n\tstruct clone_root *found_clone = NULL;\n\tint ret = 0;\n\n\tif (S_ISLNK(sctx->cur_inode_mode))\n\t\treturn 0;\n\n\tif (sctx->parent_root && !sctx->cur_inode_new) {\n\t\tret = is_extent_unchanged(sctx, path, key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto out_hole;\n\t\t}\n\t} else {\n\t\tstruct btrfs_file_extent_item *ei;\n\t\tu8 type;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\ttype = btrfs_file_extent_type(path->nodes[0], ei);\n\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC ||\n\t\t    type == BTRFS_FILE_EXTENT_REG) {\n\t\t\t/*\n\t\t\t * The send spec does not have a prealloc command yet,\n\t\t\t * so just leave a hole for prealloc'ed extents until\n\t\t\t * we have enough commands queued up to justify rev'ing\n\t\t\t * the send spec.\n\t\t\t */\n\t\t\tif (type == BTRFS_FILE_EXTENT_PREALLOC) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* Have a hole, just skip it. */\n\t\t\tif (btrfs_file_extent_disk_bytenr(path->nodes[0], ei) == 0) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = find_extent_clone(sctx, path, key->objectid, key->offset,\n\t\t\tsctx->cur_inode_size, &found_clone);\n\tif (ret != -ENOENT && ret < 0)\n\t\tgoto out;\n\n\tret = send_write_or_clone(sctx, path, key, found_clone);\n\tif (ret)\n\t\tgoto out;\nout_hole:\n\tret = maybe_send_hole(sctx, path, key);\nout:\n\treturn ret;\n}\n\nstatic int process_all_extents(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\troot = sctx->send_root;\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cmp_key->objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\tgoto out;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\n\t\tif (found_key.objectid != key.objectid ||\n\t\t    found_key.type != key.type) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = process_extent(sctx, path, &found_key);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int process_recorded_refs_if_needed(struct send_ctx *sctx, int at_end,\n\t\t\t\t\t   int *pending_move,\n\t\t\t\t\t   int *refs_processed)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino == 0)\n\t\tgoto out;\n\tif (!at_end && sctx->cur_ino == sctx->cmp_key->objectid &&\n\t    sctx->cmp_key->type <= BTRFS_INODE_EXTREF_KEY)\n\t\tgoto out;\n\tif (list_empty(&sctx->new_refs) && list_empty(&sctx->deleted_refs))\n\t\tgoto out;\n\n\tret = process_recorded_refs(sctx, pending_move);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t*refs_processed = 1;\nout:\n\treturn ret;\n}\n\nstatic int finish_inode_if_needed(struct send_ctx *sctx, int at_end)\n{\n\tint ret = 0;\n\tu64 left_mode;\n\tu64 left_uid;\n\tu64 left_gid;\n\tu64 right_mode;\n\tu64 right_uid;\n\tu64 right_gid;\n\tint need_chmod = 0;\n\tint need_chown = 0;\n\tint need_truncate = 1;\n\tint pending_move = 0;\n\tint refs_processed = 0;\n\n\tif (sctx->ignore_cur_inode)\n\t\treturn 0;\n\n\tret = process_recorded_refs_if_needed(sctx, at_end, &pending_move,\n\t\t\t\t\t      &refs_processed);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We have processed the refs and thus need to advance send_progress.\n\t * Now, calls to get_cur_xxx will take the updated refs of the current\n\t * inode into account.\n\t *\n\t * On the other hand, if our current inode is a directory and couldn't\n\t * be moved/renamed because its parent was renamed/moved too and it has\n\t * a higher inode number, we can only move/rename our current inode\n\t * after we moved/renamed its parent. Therefore in this case operate on\n\t * the old path (pre move/rename) of our current inode, and the\n\t * move/rename will be performed later.\n\t */\n\tif (refs_processed && !pending_move)\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\tif (sctx->cur_ino == 0 || sctx->cur_inode_deleted)\n\t\tgoto out;\n\tif (!at_end && sctx->cmp_key->objectid == sctx->cur_ino)\n\t\tgoto out;\n\n\tret = get_inode_info(sctx->send_root, sctx->cur_ino, NULL, NULL,\n\t\t\t&left_mode, &left_uid, &left_gid, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!sctx->parent_root || sctx->cur_inode_new) {\n\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode))\n\t\t\tneed_chmod = 1;\n\t\tif (sctx->cur_inode_next_write_offset == sctx->cur_inode_size)\n\t\t\tneed_truncate = 0;\n\t} else {\n\t\tu64 old_size;\n\n\t\tret = get_inode_info(sctx->parent_root, sctx->cur_ino,\n\t\t\t\t&old_size, NULL, &right_mode, &right_uid,\n\t\t\t\t&right_gid, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (left_uid != right_uid || left_gid != right_gid)\n\t\t\tneed_chown = 1;\n\t\tif (!S_ISLNK(sctx->cur_inode_mode) && left_mode != right_mode)\n\t\t\tneed_chmod = 1;\n\t\tif ((old_size == sctx->cur_inode_size) ||\n\t\t    (sctx->cur_inode_size > old_size &&\n\t\t     sctx->cur_inode_next_write_offset == sctx->cur_inode_size))\n\t\t\tneed_truncate = 0;\n\t}\n\n\tif (S_ISREG(sctx->cur_inode_mode)) {\n\t\tif (need_send_hole(sctx)) {\n\t\t\tif (sctx->cur_inode_last_extent == (u64)-1 ||\n\t\t\t    sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = get_last_extent(sctx, (u64)-1);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (sctx->cur_inode_last_extent <\n\t\t\t    sctx->cur_inode_size) {\n\t\t\t\tret = send_hole(sctx, sctx->cur_inode_size);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (need_truncate) {\n\t\t\tret = send_truncate(sctx, sctx->cur_ino,\n\t\t\t\t\t    sctx->cur_inode_gen,\n\t\t\t\t\t    sctx->cur_inode_size);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (need_chown) {\n\t\tret = send_chown(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_uid, left_gid);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tif (need_chmod) {\n\t\tret = send_chmod(sctx, sctx->cur_ino, sctx->cur_inode_gen,\n\t\t\t\tleft_mode);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_capabilities(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * If other directory inodes depended on our current directory\n\t * inode's move/rename, now do their move/rename operations.\n\t */\n\tif (!is_waiting_for_move(sctx, sctx->cur_ino)) {\n\t\tret = apply_children_dir_moves(sctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Need to send that every time, no matter if it actually\n\t\t * changed between the two trees as we have done changes to\n\t\t * the inode before. If our inode is a directory and it's\n\t\t * waiting to be moved/renamed, we will send its utimes when\n\t\t * it's moved/renamed, therefore we don't need to do it here.\n\t\t */\n\t\tsctx->send_progress = sctx->cur_ino + 1;\n\t\tret = send_utimes(sctx, sctx->cur_ino, sctx->cur_inode_gen);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstruct parent_paths_ctx {\n\tstruct list_head *refs;\n\tstruct send_ctx *sctx;\n};\n\nstatic int record_parent_ref(int num, u64 dir, int index, struct fs_path *name,\n\t\t\t     void *ctx)\n{\n\tstruct parent_paths_ctx *ppctx = ctx;\n\n\treturn record_ref(ppctx->sctx->parent_root, dir, name, ppctx->sctx,\n\t\t\t  ppctx->refs);\n}\n\n/*\n * Issue unlink operations for all paths of the current inode found in the\n * parent snapshot.\n */\nstatic int btrfs_unlink_all_paths(struct send_ctx *sctx)\n{\n\tLIST_HEAD(deleted_refs);\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct parent_paths_ctx ctx;\n\tint ret;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = sctx->cur_ino;\n\tkey.type = BTRFS_INODE_REF_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(NULL, sctx->parent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tctx.refs = &deleted_refs;\n\tctx.sctx = sctx;\n\n\twhile (true) {\n\t\tstruct extent_buffer *eb = path->nodes[0];\n\t\tint slot = path->slots[0];\n\n\t\tif (slot >= btrfs_header_nritems(eb)) {\n\t\t\tret = btrfs_next_leaf(sctx->parent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\telse if (ret > 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\t\tif (key.objectid != sctx->cur_ino)\n\t\t\tbreak;\n\t\tif (key.type != BTRFS_INODE_REF_KEY &&\n\t\t    key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = iterate_inode_ref(sctx->parent_root, path, &key, 1,\n\t\t\t\t\trecord_parent_ref, &ctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tpath->slots[0]++;\n\t}\n\n\twhile (!list_empty(&deleted_refs)) {\n\t\tstruct recorded_ref *ref;\n\n\t\tref = list_first_entry(&deleted_refs, struct recorded_ref, list);\n\t\tret = send_unlink(sctx, ref->full_path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tfs_path_free(ref->full_path);\n\t\tlist_del(&ref->list);\n\t\tkfree(ref);\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\tif (ret)\n\t\t__free_recorded_refs(&deleted_refs);\n\treturn ret;\n}\n\nstatic int changed_inode(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\tstruct btrfs_key *key = sctx->cmp_key;\n\tstruct btrfs_inode_item *left_ii = NULL;\n\tstruct btrfs_inode_item *right_ii = NULL;\n\tu64 left_gen = 0;\n\tu64 right_gen = 0;\n\n\tsctx->cur_ino = key->objectid;\n\tsctx->cur_inode_new_gen = 0;\n\tsctx->cur_inode_last_extent = (u64)-1;\n\tsctx->cur_inode_next_write_offset = 0;\n\tsctx->ignore_cur_inode = false;\n\n\t/*\n\t * Set send_progress to current inode. This will tell all get_cur_xxx\n\t * functions that the current inode's refs are not updated yet. Later,\n\t * when process_recorded_refs is finished, it is set to cur_ino + 1.\n\t */\n\tsctx->send_progress = sctx->cur_ino;\n\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tleft_ii = btrfs_item_ptr(sctx->left_path->nodes[0],\n\t\t\t\tsctx->left_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tleft_gen = btrfs_inode_generation(sctx->left_path->nodes[0],\n\t\t\t\tleft_ii);\n\t} else {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\t}\n\tif (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tright_ii = btrfs_item_ptr(sctx->right_path->nodes[0],\n\t\t\t\tsctx->right_path->slots[0],\n\t\t\t\tstruct btrfs_inode_item);\n\n\t\tright_gen = btrfs_inode_generation(sctx->right_path->nodes[0],\n\t\t\t\tright_ii);\n\n\t\t/*\n\t\t * The cur_ino = root dir case is special here. We can't treat\n\t\t * the inode as deleted+reused because it would generate a\n\t\t * stream that tries to delete/mkdir the root dir.\n\t\t */\n\t\tif (left_gen != right_gen &&\n\t\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tsctx->cur_inode_new_gen = 1;\n\t}\n\n\t/*\n\t * Normally we do not find inodes with a link count of zero (orphans)\n\t * because the most common case is to create a snapshot and use it\n\t * for a send operation. However other less common use cases involve\n\t * using a subvolume and send it after turning it to RO mode just\n\t * after deleting all hard links of a file while holding an open\n\t * file descriptor against it or turning a RO snapshot into RW mode,\n\t * keep an open file descriptor against a file, delete it and then\n\t * turn the snapshot back to RO mode before using it for a send\n\t * operation. So if we find such cases, ignore the inode and all its\n\t * items completely if it's a new inode, or if it's a changed inode\n\t * make sure all its previous paths (from the parent snapshot) are all\n\t * unlinked and all other the inode items are ignored.\n\t */\n\tif (result == BTRFS_COMPARE_TREE_NEW ||\n\t    result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\tu32 nlinks;\n\n\t\tnlinks = btrfs_inode_nlink(sctx->left_path->nodes[0], left_ii);\n\t\tif (nlinks == 0) {\n\t\t\tsctx->ignore_cur_inode = true;\n\t\t\tif (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\t\tret = btrfs_unlink_all_paths(sctx);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (result == BTRFS_COMPARE_TREE_NEW) {\n\t\tsctx->cur_inode_gen = left_gen;\n\t\tsctx->cur_inode_new = 1;\n\t\tsctx->cur_inode_deleted = 0;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\tif (sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID)\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t} else if (result == BTRFS_COMPARE_TREE_DELETED) {\n\t\tsctx->cur_inode_gen = right_gen;\n\t\tsctx->cur_inode_new = 0;\n\t\tsctx->cur_inode_deleted = 1;\n\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t} else if (result == BTRFS_COMPARE_TREE_CHANGED) {\n\t\t/*\n\t\t * We need to do some special handling in case the inode was\n\t\t * reported as changed with a changed generation number. This\n\t\t * means that the original inode was deleted and new inode\n\t\t * reused the same inum. So we have to treat the old inode as\n\t\t * deleted and the new one as new.\n\t\t */\n\t\tif (sctx->cur_inode_new_gen) {\n\t\t\t/*\n\t\t\t * First, process the inode as if it was deleted.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = right_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_deleted = 1;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->right_path->nodes[0], right_ii);\n\t\t\tret = process_all_refs(sctx,\n\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Now process the inode as if it was new.\n\t\t\t */\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 1;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_rdev = btrfs_inode_rdev(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tret = send_create_inode_if_needed(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret = process_all_refs(sctx, BTRFS_COMPARE_TREE_NEW);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Advance send_progress now as we did not get into\n\t\t\t * process_recorded_refs_if_needed in the new_gen case.\n\t\t\t */\n\t\t\tsctx->send_progress = sctx->cur_ino + 1;\n\n\t\t\t/*\n\t\t\t * Now process all extents and xattrs of the inode as if\n\t\t\t * they were all new.\n\t\t\t */\n\t\t\tret = process_all_extents(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = process_all_new_xattrs(sctx);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tsctx->cur_inode_gen = left_gen;\n\t\t\tsctx->cur_inode_new = 0;\n\t\t\tsctx->cur_inode_new_gen = 0;\n\t\t\tsctx->cur_inode_deleted = 0;\n\t\t\tsctx->cur_inode_size = btrfs_inode_size(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t\tsctx->cur_inode_mode = btrfs_inode_mode(\n\t\t\t\t\tsctx->left_path->nodes[0], left_ii);\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\n/*\n * We have to process new refs before deleted refs, but compare_trees gives us\n * the new and deleted refs mixed. To fix this, we record the new/deleted refs\n * first and later process them in process_recorded_refs.\n * For the cur_inode_new_gen case, we skip recording completely because\n * changed_inode did already initiate processing of refs. The reason for this is\n * that in this case, compare_tree actually compares the refs of 2 different\n * inodes. To fix this, process_all_refs is used in changed_inode to handle all\n * refs of the right tree as deleted and all refs of the left tree as new.\n */\nstatic int changed_ref(struct send_ctx *sctx,\n\t\t       enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino != sctx->cmp_key->objectid) {\n\t\tinconsistent_snapshot_error(sctx, result, \"reference\");\n\t\treturn -EIO;\n\t}\n\n\tif (!sctx->cur_inode_new_gen &&\n\t    sctx->cur_ino != BTRFS_FIRST_FREE_OBJECTID) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = record_new_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = record_deleted_ref(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = record_changed_ref(sctx);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Process new/deleted/changed xattrs. We skip processing in the\n * cur_inode_new_gen case because changed_inode did already initiate processing\n * of xattrs. The reason is the same as in changed_ref\n */\nstatic int changed_xattr(struct send_ctx *sctx,\n\t\t\t enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\tif (sctx->cur_ino != sctx->cmp_key->objectid) {\n\t\tinconsistent_snapshot_error(sctx, result, \"xattr\");\n\t\treturn -EIO;\n\t}\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result == BTRFS_COMPARE_TREE_NEW)\n\t\t\tret = process_new_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_deleted_xattr(sctx);\n\t\telse if (result == BTRFS_COMPARE_TREE_CHANGED)\n\t\t\tret = process_changed_xattr(sctx);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Process new/deleted/changed extents. We skip processing in the\n * cur_inode_new_gen case because changed_inode did already initiate processing\n * of extents. The reason is the same as in changed_ref\n */\nstatic int changed_extent(struct send_ctx *sctx,\n\t\t\t  enum btrfs_compare_tree_result result)\n{\n\tint ret = 0;\n\n\t/*\n\t * We have found an extent item that changed without the inode item\n\t * having changed. This can happen either after relocation (where the\n\t * disk_bytenr of an extent item is replaced at\n\t * relocation.c:replace_file_extents()) or after deduplication into a\n\t * file in both the parent and send snapshots (where an extent item can\n\t * get modified or replaced with a new one). Note that deduplication\n\t * updates the inode item, but it only changes the iversion (sequence\n\t * field in the inode item) of the inode, so if a file is deduplicated\n\t * the same amount of times in both the parent and send snapshots, its\n\t * iversion becames the same in both snapshots, whence the inode item is\n\t * the same on both snapshots.\n\t */\n\tif (sctx->cur_ino != sctx->cmp_key->objectid)\n\t\treturn 0;\n\n\tif (!sctx->cur_inode_new_gen && !sctx->cur_inode_deleted) {\n\t\tif (result != BTRFS_COMPARE_TREE_DELETED)\n\t\t\tret = process_extent(sctx, sctx->left_path,\n\t\t\t\t\tsctx->cmp_key);\n\t}\n\n\treturn ret;\n}\n\nstatic int dir_changed(struct send_ctx *sctx, u64 dir)\n{\n\tu64 orig_gen, new_gen;\n\tint ret;\n\n\tret = get_inode_info(sctx->send_root, dir, NULL, &new_gen, NULL, NULL,\n\t\t\t     NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = get_inode_info(sctx->parent_root, dir, NULL, &orig_gen, NULL,\n\t\t\t     NULL, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (orig_gen != new_gen) ? 1 : 0;\n}\n\nstatic int compare_refs(struct send_ctx *sctx, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key)\n{\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu64 dirid = 0, last_dirid = 0;\n\tunsigned long ptr;\n\tu32 item_size;\n\tu32 cur_offset = 0;\n\tint ref_name_len;\n\tint ret = 0;\n\n\t/* Easy case, just check this one dirid */\n\tif (key->type == BTRFS_INODE_REF_KEY) {\n\t\tdirid = key->offset;\n\n\t\tret = dir_changed(sctx, dirid);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\twhile (cur_offset < item_size) {\n\t\textref = (struct btrfs_inode_extref *)(ptr +\n\t\t\t\t\t\t       cur_offset);\n\t\tdirid = btrfs_inode_extref_parent(leaf, extref);\n\t\tref_name_len = btrfs_inode_extref_name_len(leaf, extref);\n\t\tcur_offset += ref_name_len + sizeof(*extref);\n\t\tif (dirid == last_dirid)\n\t\t\tcontinue;\n\t\tret = dir_changed(sctx, dirid);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tlast_dirid = dirid;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * Updates compare related fields in sctx and simply forwards to the actual\n * changed_xxx functions.\n */\nstatic int changed_cb(struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      struct send_ctx *sctx)\n{\n\tint ret = 0;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY) {\n\t\tret = changed_inode(sctx, result);\n\t} else if (!sctx->ignore_cur_inode) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY)\n\t\t\tret = changed_ref(sctx, result);\n\t\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\t\tret = changed_xattr(sctx, result);\n\t\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\t\tret = changed_extent(sctx, result);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int full_send_tree(struct send_ctx *sctx)\n{\n\tint ret;\n\tstruct btrfs_root *send_root = sctx->send_root;\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\tpath = alloc_path_for_send();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = READA_FORWARD;\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_search_slot_for_read(send_root, &key, path, 1, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret)\n\t\tgoto out_finish;\n\n\twhile (1) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\n\t\tret = changed_cb(path, NULL, &key,\n\t\t\t\t BTRFS_COMPARE_TREE_NEW, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = btrfs_next_item(send_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret) {\n\t\t\tret  = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_finish:\n\tret = finish_inode_if_needed(sctx, 1);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int tree_move_down(struct btrfs_path *path, int *level, u64 reada_min_gen)\n{\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent = path->nodes[*level];\n\tint slot = path->slots[*level];\n\tconst int nritems = btrfs_header_nritems(parent);\n\tu64 reada_max;\n\tu64 reada_done = 0;\n\n\tBUG_ON(*level == 0);\n\teb = btrfs_read_node_slot(parent, slot);\n\tif (IS_ERR(eb))\n\t\treturn PTR_ERR(eb);\n\n\t/*\n\t * Trigger readahead for the next leaves we will process, so that it is\n\t * very likely that when we need them they are already in memory and we\n\t * will not block on disk IO. For nodes we only do readahead for one,\n\t * since the time window between processing nodes is typically larger.\n\t */\n\treada_max = (*level == 1 ? SZ_128K : eb->fs_info->nodesize);\n\n\tfor (slot++; slot < nritems && reada_done < reada_max; slot++) {\n\t\tif (btrfs_node_ptr_generation(parent, slot) > reada_min_gen) {\n\t\t\tbtrfs_readahead_node_child(parent, slot);\n\t\t\treada_done += eb->fs_info->nodesize;\n\t\t}\n\t}\n\n\tpath->nodes[*level - 1] = eb;\n\tpath->slots[*level - 1] = 0;\n\t(*level)--;\n\treturn 0;\n}\n\nstatic int tree_move_next_or_upnext(struct btrfs_path *path,\n\t\t\t\t    int *level, int root_level)\n{\n\tint ret = 0;\n\tint nritems;\n\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\n\tpath->slots[*level]++;\n\n\twhile (path->slots[*level] >= nritems) {\n\t\tif (*level == root_level)\n\t\t\treturn -1;\n\n\t\t/* move upnext */\n\t\tpath->slots[*level] = 0;\n\t\tfree_extent_buffer(path->nodes[*level]);\n\t\tpath->nodes[*level] = NULL;\n\t\t(*level)++;\n\t\tpath->slots[*level]++;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\t\tret = 1;\n\t}\n\treturn ret;\n}\n\n/*\n * Returns 1 if it had to move up and next. 0 is returned if it moved only next\n * or down.\n */\nstatic int tree_advance(struct btrfs_path *path,\n\t\t\tint *level, int root_level,\n\t\t\tint allow_down,\n\t\t\tstruct btrfs_key *key,\n\t\t\tu64 reada_min_gen)\n{\n\tint ret;\n\n\tif (*level == 0 || !allow_down) {\n\t\tret = tree_move_next_or_upnext(path, level, root_level);\n\t} else {\n\t\tret = tree_move_down(path, level, reada_min_gen);\n\t}\n\tif (ret >= 0) {\n\t\tif (*level == 0)\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t}\n\treturn ret;\n}\n\nstatic int tree_compare_item(struct btrfs_path *left_path,\n\t\t\t     struct btrfs_path *right_path,\n\t\t\t     char *tmp_buf)\n{\n\tint cmp;\n\tint len1, len2;\n\tunsigned long off1, off2;\n\n\tlen1 = btrfs_item_size_nr(left_path->nodes[0], left_path->slots[0]);\n\tlen2 = btrfs_item_size_nr(right_path->nodes[0], right_path->slots[0]);\n\tif (len1 != len2)\n\t\treturn 1;\n\n\toff1 = btrfs_item_ptr_offset(left_path->nodes[0], left_path->slots[0]);\n\toff2 = btrfs_item_ptr_offset(right_path->nodes[0],\n\t\t\t\tright_path->slots[0]);\n\n\tread_extent_buffer(left_path->nodes[0], tmp_buf, off1, len1);\n\n\tcmp = memcmp_extent_buffer(right_path->nodes[0], tmp_buf, off2, len1);\n\tif (cmp)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * This function compares two trees and calls the provided callback for\n * every changed/new/deleted item it finds.\n * If shared tree blocks are encountered, whole subtrees are skipped, making\n * the compare pretty fast on snapshotted subvolumes.\n *\n * This currently works on commit roots only. As commit roots are read only,\n * we don't do any locking. The commit roots are protected with transactions.\n * Transactions are ended and rejoined when a commit is tried in between.\n *\n * This function checks for modifications done to the trees while comparing.\n * If it detects a change, it aborts immediately.\n */\nstatic int btrfs_compare_trees(struct btrfs_root *left_root,\n\t\t\tstruct btrfs_root *right_root, struct send_ctx *sctx)\n{\n\tstruct btrfs_fs_info *fs_info = left_root->fs_info;\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached;\n\tint right_end_reached;\n\tint advance_left;\n\tint advance_right;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\tu64 reada_min_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kvmalloc(fs_info->nodesize, GFP_KERNEL);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t/*\n\t * Strategy: Go to the first items of both trees. Then do\n\t *\n\t * If both trees are at level 0\n\t *   Compare keys of current items\n\t *     If left < right treat left item as new, advance left tree\n\t *       and repeat\n\t *     If left > right treat right item as deleted, advance right tree\n\t *       and repeat\n\t *     If left == right do deep compare of items, treat as changed if\n\t *       needed, advance both trees and repeat\n\t * If both trees are at the same level but not at level 0\n\t *   Compare keys of current nodes/leafs\n\t *     If left < right advance left tree and repeat\n\t *     If left > right advance right tree and repeat\n\t *     If left == right compare blockptrs of the next nodes/leafs\n\t *       If they match advance both trees but stay at the same level\n\t *         and repeat\n\t *       If they don't match advance both trees while allowing to go\n\t *         deeper and repeat\n\t * If tree levels are different\n\t *   Advance the tree that needs it and repeat\n\t *\n\t * Advancing a tree means:\n\t *   If we are at level 0, try to go to the next slot. If that's not\n\t *   possible, go one level up and repeat. Stop when we found a level\n\t *   where we could go to the next slot. We may at this point be on a\n\t *   node or a leaf.\n\t *\n\t *   If we are not at level 0 and not on shared tree blocks, go one\n\t *   level deeper.\n\t *\n\t *   If we are not at level 0 and on shared tree blocks, go one slot to\n\t *   the right if possible or go up and right.\n\t */\n\n\tdown_read(&fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\tleft_path->nodes[left_level] =\n\t\t\tbtrfs_clone_extent_buffer(left_root->commit_root);\n\tif (!left_path->nodes[left_level]) {\n\t\tup_read(&fs_info->commit_root_sem);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] =\n\t\t\tbtrfs_clone_extent_buffer(right_root->commit_root);\n\tif (!right_path->nodes[right_level]) {\n\t\tup_read(&fs_info->commit_root_sem);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/*\n\t * Our right root is the parent root, while the left root is the \"send\"\n\t * root. We know that all new nodes/leaves in the left root must have\n\t * a generation greater than the right root's generation, so we trigger\n\t * readahead for those nodes and leaves of the left root, as we know we\n\t * will need to read them at some point.\n\t */\n\treada_min_gen = btrfs_header_generation(right_root->commit_root);\n\tup_read(&fs_info->commit_root_sem);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tleft_end_reached = right_end_reached = 0;\n\tadvance_left = advance_right = 0;\n\n\twhile (1) {\n\t\tcond_resched();\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key, reada_min_gen);\n\t\t\tif (ret == -1)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key, reada_min_gen);\n\t\t\tif (ret == -1)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tsctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_right = ADVANCE;\n\t\t\tcontinue;\n\t\t} else if (right_end_reached) {\n\t\t\tif (left_level == 0) {\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tsctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_left = ADVANCE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (left_level == 0 && right_level == 0) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tsctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tsctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tenum btrfs_compare_tree_result result;\n\n\t\t\t\tWARN_ON(!extent_buffer_uptodate(left_path->nodes[0]));\n\t\t\t\tret = tree_compare_item(left_path, right_path,\n\t\t\t\t\t\t\ttmp_buf);\n\t\t\t\tif (ret)\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\t\t\telse\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_SAME;\n\t\t\t\tret = changed_cb(left_path, right_path,\n\t\t\t\t\t\t &left_key, result, sctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t}\n\t\t} else if (left_level == right_level) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tleft_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tleft_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tif (left_blockptr == right_blockptr &&\n\t\t\t\t    left_gen == right_gen) {\n\t\t\t\t\t/*\n\t\t\t\t\t * As we're on a shared block, don't\n\t\t\t\t\t * allow to go deeper.\n\t\t\t\t\t */\n\t\t\t\t\tadvance_left = ADVANCE_ONLY_NEXT;\n\t\t\t\t\tadvance_right = ADVANCE_ONLY_NEXT;\n\t\t\t\t} else {\n\t\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\t\tadvance_right = ADVANCE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (left_level < right_level) {\n\t\t\tadvance_right = ADVANCE;\n\t\t} else {\n\t\t\tadvance_left = ADVANCE;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(left_path);\n\tbtrfs_free_path(right_path);\n\tkvfree(tmp_buf);\n\treturn ret;\n}\n\nstatic int send_subvol(struct send_ctx *sctx)\n{\n\tint ret;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_STREAM_HEADER)) {\n\t\tret = send_header(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = send_subvol_begin(sctx);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (sctx->parent_root) {\n\t\tret = btrfs_compare_trees(sctx->send_root, sctx->parent_root, sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = finish_inode_if_needed(sctx, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tret = full_send_tree(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tfree_recorded_refs(sctx);\n\treturn ret;\n}\n\n/*\n * If orphan cleanup did remove any orphans from a root, it means the tree\n * was modified and therefore the commit root is not the same as the current\n * root anymore. This is a problem, because send uses the commit root and\n * therefore can see inode items that don't exist in the current root anymore,\n * and for example make calls to btrfs_iget, which will do tree lookups based\n * on the current root and not on the commit root. Those lookups will fail,\n * returning a -ESTALE error, and making send fail with that error. So make\n * sure a send does not see any orphans we have just removed, and that it will\n * see the same inodes regardless of whether a transaction commit happened\n * before it started (meaning that the commit root will be the same as the\n * current root) or not.\n */\nstatic int ensure_commit_roots_uptodate(struct send_ctx *sctx)\n{\n\tint i;\n\tstruct btrfs_trans_handle *trans = NULL;\n\nagain:\n\tif (sctx->parent_root &&\n\t    sctx->parent_root->node != sctx->parent_root->commit_root)\n\t\tgoto commit_trans;\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++)\n\t\tif (sctx->clone_roots[i].root->node !=\n\t\t    sctx->clone_roots[i].root->commit_root)\n\t\t\tgoto commit_trans;\n\n\tif (trans)\n\t\treturn btrfs_end_transaction(trans);\n\n\treturn 0;\n\ncommit_trans:\n\t/* Use any root, all fs roots will get their commit roots updated. */\n\tif (!trans) {\n\t\ttrans = btrfs_join_transaction(sctx->send_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tgoto again;\n\t}\n\n\treturn btrfs_commit_transaction(trans);\n}\n\n/*\n * Make sure any existing dellaloc is flushed for any root used by a send\n * operation so that we do not miss any data and we do not race with writeback\n * finishing and changing a tree while send is using the tree. This could\n * happen if a subvolume is in RW mode, has delalloc, is turned to RO mode and\n * a send operation then uses the subvolume.\n * After flushing delalloc ensure_commit_roots_uptodate() must be called.\n */\nstatic int flush_delalloc_roots(struct send_ctx *sctx)\n{\n\tstruct btrfs_root *root = sctx->parent_root;\n\tint ret;\n\tint i;\n\n\tif (root) {\n\t\tret = btrfs_start_delalloc_snapshot(root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, U64_MAX);\n\t}\n\n\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\troot = sctx->clone_roots[i].root;\n\t\tret = btrfs_start_delalloc_snapshot(root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbtrfs_wait_ordered_extents(root, U64_MAX, 0, U64_MAX);\n\t}\n\n\treturn 0;\n}\n\nstatic void btrfs_root_dec_send_in_progress(struct btrfs_root* root)\n{\n\tspin_lock(&root->root_item_lock);\n\troot->send_in_progress--;\n\t/*\n\t * Not much left to do, we don't know why it's unbalanced and\n\t * can't blindly reset it to 0.\n\t */\n\tif (root->send_in_progress < 0)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t  \"send_in_progress unbalanced %d root %llu\",\n\t\t\t  root->send_in_progress, root->root_key.objectid);\n\tspin_unlock(&root->root_item_lock);\n}\n\nstatic void dedupe_in_progress_warn(const struct btrfs_root *root)\n{\n\tbtrfs_warn_rl(root->fs_info,\n\"cannot use root %llu for send while deduplications on it are in progress (%d in progress)\",\n\t\t      root->root_key.objectid, root->dedupe_in_progress);\n}\n\nlong btrfs_ioctl_send(struct file *mnt_file, struct btrfs_ioctl_send_args *arg)\n{\n\tint ret = 0;\n\tstruct btrfs_root *send_root = BTRFS_I(file_inode(mnt_file))->root;\n\tstruct btrfs_fs_info *fs_info = send_root->fs_info;\n\tstruct btrfs_root *clone_root;\n\tstruct send_ctx *sctx = NULL;\n\tu32 i;\n\tu64 *clone_sources_tmp = NULL;\n\tint clone_sources_to_rollback = 0;\n\tsize_t alloc_size;\n\tint sort_clone_roots = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * The subvolume must remain read-only during send, protect against\n\t * making it RW. This also protects against deletion.\n\t */\n\tspin_lock(&send_root->root_item_lock);\n\tif (btrfs_root_readonly(send_root) && send_root->dedupe_in_progress) {\n\t\tdedupe_in_progress_warn(send_root);\n\t\tspin_unlock(&send_root->root_item_lock);\n\t\treturn -EAGAIN;\n\t}\n\tsend_root->send_in_progress++;\n\tspin_unlock(&send_root->root_item_lock);\n\n\t/*\n\t * Userspace tools do the checks and warn the user if it's\n\t * not RO.\n\t */\n\tif (!btrfs_root_readonly(send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Check that we don't overflow at later allocations, we request\n\t * clone_sources_count + 1 items, and compare to unsigned long inside\n\t * access_ok.\n\t */\n\tif (arg->clone_sources_count >\n\t    ULONG_MAX / sizeof(struct clone_root) - 1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (arg->flags & ~BTRFS_SEND_FLAG_MASK) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsctx = kzalloc(sizeof(struct send_ctx), GFP_KERNEL);\n\tif (!sctx) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&sctx->new_refs);\n\tINIT_LIST_HEAD(&sctx->deleted_refs);\n\tINIT_RADIX_TREE(&sctx->name_cache, GFP_KERNEL);\n\tINIT_LIST_HEAD(&sctx->name_cache_list);\n\n\tsctx->flags = arg->flags;\n\n\tsctx->send_filp = fget(arg->send_fd);\n\tif (!sctx->send_filp) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsctx->send_root = send_root;\n\t/*\n\t * Unlikely but possible, if the subvolume is marked for deletion but\n\t * is slow to remove the directory entry, send can still be started\n\t */\n\tif (btrfs_root_dead(sctx->send_root)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tsctx->clone_roots_cnt = arg->clone_sources_count;\n\n\tsctx->send_max_size = BTRFS_SEND_BUF_SIZE;\n\tsctx->send_buf = kvmalloc(sctx->send_max_size, GFP_KERNEL);\n\tif (!sctx->send_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsctx->pending_dir_moves = RB_ROOT;\n\tsctx->waiting_dir_moves = RB_ROOT;\n\tsctx->orphan_dirs = RB_ROOT;\n\n\tsctx->clone_roots = kvcalloc(sizeof(*sctx->clone_roots),\n\t\t\t\t     arg->clone_sources_count + 1,\n\t\t\t\t     GFP_KERNEL);\n\tif (!sctx->clone_roots) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\talloc_size = array_size(sizeof(*arg->clone_sources),\n\t\t\t\targ->clone_sources_count);\n\n\tif (arg->clone_sources_count) {\n\t\tclone_sources_tmp = kvmalloc(alloc_size, GFP_KERNEL);\n\t\tif (!clone_sources_tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = copy_from_user(clone_sources_tmp, arg->clone_sources,\n\t\t\t\talloc_size);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < arg->clone_sources_count; i++) {\n\t\t\tclone_root = btrfs_get_fs_root(fs_info,\n\t\t\t\t\t\tclone_sources_tmp[i], true);\n\t\t\tif (IS_ERR(clone_root)) {\n\t\t\t\tret = PTR_ERR(clone_root);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_lock(&clone_root->root_item_lock);\n\t\t\tif (!btrfs_root_readonly(clone_root) ||\n\t\t\t    btrfs_root_dead(clone_root)) {\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tbtrfs_put_root(clone_root);\n\t\t\t\tret = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (clone_root->dedupe_in_progress) {\n\t\t\t\tdedupe_in_progress_warn(clone_root);\n\t\t\t\tspin_unlock(&clone_root->root_item_lock);\n\t\t\t\tbtrfs_put_root(clone_root);\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tclone_root->send_in_progress++;\n\t\t\tspin_unlock(&clone_root->root_item_lock);\n\n\t\t\tsctx->clone_roots[i].root = clone_root;\n\t\t\tclone_sources_to_rollback = i + 1;\n\t\t}\n\t\tkvfree(clone_sources_tmp);\n\t\tclone_sources_tmp = NULL;\n\t}\n\n\tif (arg->parent_root) {\n\t\tsctx->parent_root = btrfs_get_fs_root(fs_info, arg->parent_root,\n\t\t\t\t\t\t      true);\n\t\tif (IS_ERR(sctx->parent_root)) {\n\t\t\tret = PTR_ERR(sctx->parent_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&sctx->parent_root->root_item_lock);\n\t\tsctx->parent_root->send_in_progress++;\n\t\tif (!btrfs_root_readonly(sctx->parent_root) ||\n\t\t\t\tbtrfs_root_dead(sctx->parent_root)) {\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sctx->parent_root->dedupe_in_progress) {\n\t\t\tdedupe_in_progress_warn(sctx->parent_root);\n\t\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&sctx->parent_root->root_item_lock);\n\t}\n\n\t/*\n\t * Clones from send_root are allowed, but only if the clone source\n\t * is behind the current send position. This is checked while searching\n\t * for possible clone sources.\n\t */\n\tsctx->clone_roots[sctx->clone_roots_cnt++].root =\n\t\tbtrfs_grab_root(sctx->send_root);\n\n\t/* We do a bsearch later */\n\tsort(sctx->clone_roots, sctx->clone_roots_cnt,\n\t\t\tsizeof(*sctx->clone_roots), __clone_root_cmp_sort,\n\t\t\tNULL);\n\tsort_clone_roots = 1;\n\n\tret = flush_delalloc_roots(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ensure_commit_roots_uptodate(sctx);\n\tif (ret)\n\t\tgoto out;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (test_bit(BTRFS_FS_BALANCE_RUNNING, &fs_info->flags)) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\tbtrfs_warn_rl(fs_info,\n\t\t\"cannot run send because a balance operation is in progress\");\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tfs_info->send_in_progress++;\n\tmutex_unlock(&fs_info->balance_mutex);\n\n\tcurrent->journal_info = BTRFS_SEND_TRANS_STUB;\n\tret = send_subvol(sctx);\n\tcurrent->journal_info = NULL;\n\tmutex_lock(&fs_info->balance_mutex);\n\tfs_info->send_in_progress--;\n\tmutex_unlock(&fs_info->balance_mutex);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!(sctx->flags & BTRFS_SEND_FLAG_OMIT_END_CMD)) {\n\t\tret = begin_cmd(sctx, BTRFS_SEND_C_END);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = send_cmd(sctx);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->pending_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->pending_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct pending_dir_move *pm;\n\n\t\tn = rb_first(&sctx->pending_dir_moves);\n\t\tpm = rb_entry(n, struct pending_dir_move, node);\n\t\twhile (!list_empty(&pm->list)) {\n\t\t\tstruct pending_dir_move *pm2;\n\n\t\t\tpm2 = list_first_entry(&pm->list,\n\t\t\t\t\t       struct pending_dir_move, list);\n\t\t\tfree_pending_move(sctx, pm2);\n\t\t}\n\t\tfree_pending_move(sctx, pm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->waiting_dir_moves)) {\n\t\tstruct rb_node *n;\n\t\tstruct waiting_dir_move *dm;\n\n\t\tn = rb_first(&sctx->waiting_dir_moves);\n\t\tdm = rb_entry(n, struct waiting_dir_move, node);\n\t\trb_erase(&dm->node, &sctx->waiting_dir_moves);\n\t\tkfree(dm);\n\t}\n\n\tWARN_ON(sctx && !ret && !RB_EMPTY_ROOT(&sctx->orphan_dirs));\n\twhile (sctx && !RB_EMPTY_ROOT(&sctx->orphan_dirs)) {\n\t\tstruct rb_node *n;\n\t\tstruct orphan_dir_info *odi;\n\n\t\tn = rb_first(&sctx->orphan_dirs);\n\t\todi = rb_entry(n, struct orphan_dir_info, node);\n\t\tfree_orphan_dir_info(sctx, odi);\n\t}\n\n\tif (sort_clone_roots) {\n\t\tfor (i = 0; i < sctx->clone_roots_cnt; i++) {\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t\t\tbtrfs_put_root(sctx->clone_roots[i].root);\n\t\t}\n\t} else {\n\t\tfor (i = 0; sctx && i < clone_sources_to_rollback; i++) {\n\t\t\tbtrfs_root_dec_send_in_progress(\n\t\t\t\t\tsctx->clone_roots[i].root);\n\t\t\tbtrfs_put_root(sctx->clone_roots[i].root);\n\t\t}\n\n\t\tbtrfs_root_dec_send_in_progress(send_root);\n\t}\n\tif (sctx && !IS_ERR_OR_NULL(sctx->parent_root)) {\n\t\tbtrfs_root_dec_send_in_progress(sctx->parent_root);\n\t\tbtrfs_put_root(sctx->parent_root);\n\t}\n\n\tkvfree(clone_sources_tmp);\n\n\tif (sctx) {\n\t\tif (sctx->send_filp)\n\t\t\tfput(sctx->send_filp);\n\n\t\tkvfree(sctx->clone_roots);\n\t\tkvfree(sctx->send_buf);\n\n\t\tname_cache_free(sctx);\n\n\t\tkfree(sctx);\n\t}\n\n\treturn ret;\n}\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 0, "line": 7447}, "message": "ERROR: sctx is NULL but dereferenced."}], "macros": [], "notes": [], "path": "/src/fs/btrfs/send.c", "reportHash": "137453059cc8cab489e9c41466aad606", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 0, "line": 7464}, "message": "ERROR: sctx is NULL but dereferenced."}], "macros": [], "notes": [], "path": "/src/fs/btrfs/send.c", "reportHash": "604c59e3acaf9f752d48cf533b0a662a", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 0, "line": 7475}, "message": "ERROR: sctx is NULL but dereferenced."}], "macros": [], "notes": [], "path": "/src/fs/btrfs/send.c", "reportHash": "a292571d956e6fbbb9f002e3ea0b767e", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
