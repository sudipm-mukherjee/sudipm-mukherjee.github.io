<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/bpf/btf.c", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/* Copyright (c) 2018 Facebook */\n\n#include <uapi/linux/btf.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/types.h>\n#include <linux/seq_file.h>\n#include <linux/compiler.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/idr.h>\n#include <linux/sort.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/btf_ids.h>\n#include <linux/skmsg.h>\n#include <linux/perf_event.h>\n#include <linux/bsearch.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <net/sock.h>\n\n/* BTF (BPF Type Format) is the meta data format which describes\n * the data types of BPF program/map.  Hence, it basically focus\n * on the C programming language which the modern BPF is primary\n * using.\n *\n * ELF Section:\n * ~~~~~~~~~~~\n * The BTF data is stored under the \".BTF\" ELF section\n *\n * struct btf_type:\n * ~~~~~~~~~~~~~~~\n * Each 'struct btf_type' object describes a C data type.\n * Depending on the type it is describing, a 'struct btf_type'\n * object may be followed by more data.  F.e.\n * To describe an array, 'struct btf_type' is followed by\n * 'struct btf_array'.\n *\n * 'struct btf_type' and any extra data following it are\n * 4 bytes aligned.\n *\n * Type section:\n * ~~~~~~~~~~~~~\n * The BTF type section contains a list of 'struct btf_type' objects.\n * Each one describes a C type.  Recall from the above section\n * that a 'struct btf_type' object could be immediately followed by extra\n * data in order to desribe some particular C types.\n *\n * type_id:\n * ~~~~~~~\n * Each btf_type object is identified by a type_id.  The type_id\n * is implicitly implied by the location of the btf_type object in\n * the BTF type section.  The first one has type_id 1.  The second\n * one has type_id 2...etc.  Hence, an earlier btf_type has\n * a smaller type_id.\n *\n * A btf_type object may refer to another btf_type object by using\n * type_id (i.e. the \"type\" in the \"struct btf_type\").\n *\n * NOTE that we cannot assume any reference-order.\n * A btf_type object can refer to an earlier btf_type object\n * but it can also refer to a later btf_type object.\n *\n * For example, to describe \"const void *\".  A btf_type\n * object describing \"const\" may refer to another btf_type\n * object describing \"void *\".  This type-reference is done\n * by specifying type_id:\n *\n * [1] CONST (anon) type_id=2\n * [2] PTR (anon) type_id=0\n *\n * The above is the btf_verifier debug log:\n *   - Each line started with \"[?]\" is a btf_type object\n *   - [?] is the type_id of the btf_type object.\n *   - CONST/PTR is the BTF_KIND_XXX\n *   - \"(anon)\" is the name of the type.  It just\n *     happens that CONST and PTR has no name.\n *   - type_id=XXX is the 'u32 type' in btf_type\n *\n * NOTE: \"void\" has type_id 0\n *\n * String section:\n * ~~~~~~~~~~~~~~\n * The BTF string section contains the names used by the type section.\n * Each string is referred by an \"offset\" from the beginning of the\n * string section.\n *\n * Each string is '\\0' terminated.\n *\n * The first character in the string section must be '\\0'\n * which is used to mean 'anonymous'. Some btf_type may not\n * have a name.\n */\n\n/* BTF verification:\n *\n * To verify BTF data, two passes are needed.\n *\n * Pass #1\n * ~~~~~~~\n * The first pass is to collect all btf_type objects to\n * an array: \"btf->types\".\n *\n * Depending on the C type that a btf_type is describing,\n * a btf_type may be followed by extra data.  We don't know\n * how many btf_type is there, and more importantly we don't\n * know where each btf_type is located in the type section.\n *\n * Without knowing the location of each type_id, most verifications\n * cannot be done.  e.g. an earlier btf_type may refer to a later\n * btf_type (recall the \"const void *\" above), so we cannot\n * check this type-reference in the first pass.\n *\n * In the first pass, it still does some verifications (e.g.\n * checking the name is a valid offset to the string section).\n *\n * Pass #2\n * ~~~~~~~\n * The main focus is to resolve a btf_type that is referring\n * to another type.\n *\n * We have to ensure the referring type:\n * 1) does exist in the BTF (i.e. in btf->types[])\n * 2) does not cause a loop:\n *\tstruct A {\n *\t\tstruct B b;\n *\t};\n *\n *\tstruct B {\n *\t\tstruct A a;\n *\t};\n *\n * btf_type_needs_resolve() decides if a btf_type needs\n * to be resolved.\n *\n * The needs_resolve type implements the \"resolve()\" ops which\n * essentially does a DFS and detects backedge.\n *\n * During resolve (or DFS), different C types have different\n * \"RESOLVED\" conditions.\n *\n * When resolving a BTF_KIND_STRUCT, we need to resolve all its\n * members because a member is always referring to another\n * type.  A struct's member can be treated as \"RESOLVED\" if\n * it is referring to a BTF_KIND_PTR.  Otherwise, the\n * following valid C struct would be rejected:\n *\n *\tstruct A {\n *\t\tint m;\n *\t\tstruct A *a;\n *\t};\n *\n * When resolving a BTF_KIND_PTR, it needs to keep resolving if\n * it is referring to another BTF_KIND_PTR.  Otherwise, we cannot\n * detect a pointer loop, e.g.:\n * BTF_KIND_CONST -> BTF_KIND_PTR -> BTF_KIND_CONST -> BTF_KIND_PTR +\n *                        ^                                         |\n *                        +-----------------------------------------+\n *\n */\n\n#define BITS_PER_U128 (sizeof(u64) * BITS_PER_BYTE * 2)\n#define BITS_PER_BYTE_MASK (BITS_PER_BYTE - 1)\n#define BITS_PER_BYTE_MASKED(bits) ((bits) & BITS_PER_BYTE_MASK)\n#define BITS_ROUNDDOWN_BYTES(bits) ((bits) >> 3)\n#define BITS_ROUNDUP_BYTES(bits) \\\n\t(BITS_ROUNDDOWN_BYTES(bits) + !!BITS_PER_BYTE_MASKED(bits))\n\n#define BTF_INFO_MASK 0x8f00ffff\n#define BTF_INT_MASK 0x0fffffff\n#define BTF_TYPE_ID_VALID(type_id) ((type_id) <= BTF_MAX_TYPE)\n#define BTF_STR_OFFSET_VALID(name_off) ((name_off) <= BTF_MAX_NAME_OFFSET)\n\n/* 16MB for 64k structs and each has 16 members and\n * a few MB spaces for the string section.\n * The hard limit is S32_MAX.\n */\n#define BTF_MAX_SIZE (16 * 1024 * 1024)\n\n#define for_each_member_from(i, from, struct_type, member)\t\t\\\n\tfor (i = from, member = btf_type_member(struct_type) + from;\t\\\n\t     i < btf_type_vlen(struct_type);\t\t\t\t\\\n\t     i++, member++)\n\n#define for_each_vsi_from(i, from, struct_type, member)\t\t\t\t\\\n\tfor (i = from, member = btf_type_var_secinfo(struct_type) + from;\t\\\n\t     i < btf_type_vlen(struct_type);\t\t\t\t\t\\\n\t     i++, member++)\n\nDEFINE_IDR(btf_idr);\nDEFINE_SPINLOCK(btf_idr_lock);\n\nstruct btf {\n\tvoid *data;\n\tstruct btf_type **types;\n\tu32 *resolved_ids;\n\tu32 *resolved_sizes;\n\tconst char *strings;\n\tvoid *nohdr_data;\n\tstruct btf_header hdr;\n\tu32 nr_types; /* includes VOID for base BTF */\n\tu32 types_size;\n\tu32 data_size;\n\trefcount_t refcnt;\n\tu32 id;\n\tstruct rcu_head rcu;\n\n\t/* split BTF support */\n\tstruct btf *base_btf;\n\tu32 start_id; /* first type ID in this BTF (0 for base BTF) */\n\tu32 start_str_off; /* first string offset (0 for base BTF) */\n\tchar name[MODULE_NAME_LEN];\n\tbool kernel_btf;\n};\n\nenum verifier_phase {\n\tCHECK_META,\n\tCHECK_TYPE,\n};\n\nstruct resolve_vertex {\n\tconst struct btf_type *t;\n\tu32 type_id;\n\tu16 next_member;\n};\n\nenum visit_state {\n\tNOT_VISITED,\n\tVISITED,\n\tRESOLVED,\n};\n\nenum resolve_mode {\n\tRESOLVE_TBD,\t/* To Be Determined */\n\tRESOLVE_PTR,\t/* Resolving for Pointer */\n\tRESOLVE_STRUCT_OR_ARRAY,\t/* Resolving for struct/union\n\t\t\t\t\t * or array\n\t\t\t\t\t */\n};\n\n#define MAX_RESOLVE_DEPTH 32\n\nstruct btf_sec_info {\n\tu32 off;\n\tu32 len;\n};\n\nstruct btf_verifier_env {\n\tstruct btf *btf;\n\tu8 *visit_states;\n\tstruct resolve_vertex stack[MAX_RESOLVE_DEPTH];\n\tstruct bpf_verifier_log log;\n\tu32 log_type_id;\n\tu32 top_stack;\n\tenum verifier_phase phase;\n\tenum resolve_mode resolve_mode;\n};\n\nstatic const char * const btf_kind_str[NR_BTF_KINDS] = {\n\t[BTF_KIND_UNKN]\t\t= \"UNKNOWN\",\n\t[BTF_KIND_INT]\t\t= \"INT\",\n\t[BTF_KIND_PTR]\t\t= \"PTR\",\n\t[BTF_KIND_ARRAY]\t= \"ARRAY\",\n\t[BTF_KIND_STRUCT]\t= \"STRUCT\",\n\t[BTF_KIND_UNION]\t= \"UNION\",\n\t[BTF_KIND_ENUM]\t\t= \"ENUM\",\n\t[BTF_KIND_FWD]\t\t= \"FWD\",\n\t[BTF_KIND_TYPEDEF]\t= \"TYPEDEF\",\n\t[BTF_KIND_VOLATILE]\t= \"VOLATILE\",\n\t[BTF_KIND_CONST]\t= \"CONST\",\n\t[BTF_KIND_RESTRICT]\t= \"RESTRICT\",\n\t[BTF_KIND_FUNC]\t\t= \"FUNC\",\n\t[BTF_KIND_FUNC_PROTO]\t= \"FUNC_PROTO\",\n\t[BTF_KIND_VAR]\t\t= \"VAR\",\n\t[BTF_KIND_DATASEC]\t= \"DATASEC\",\n};\n\nstatic const char *btf_type_str(const struct btf_type *t)\n{\n\treturn btf_kind_str[BTF_INFO_KIND(t->info)];\n}\n\n/* Chunk size we use in safe copy of data to be shown. */\n#define BTF_SHOW_OBJ_SAFE_SIZE\t\t32\n\n/*\n * This is the maximum size of a base type value (equivalent to a\n * 128-bit int); if we are at the end of our safe buffer and have\n * less than 16 bytes space we can't be assured of being able\n * to copy the next type safely, so in such cases we will initiate\n * a new copy.\n */\n#define BTF_SHOW_OBJ_BASE_TYPE_SIZE\t16\n\n/* Type name size */\n#define BTF_SHOW_NAME_SIZE\t\t80\n\n/*\n * Common data to all BTF show operations. Private show functions can add\n * their own data to a structure containing a struct btf_show and consult it\n * in the show callback.  See btf_type_show() below.\n *\n * One challenge with showing nested data is we want to skip 0-valued\n * data, but in order to figure out whether a nested object is all zeros\n * we need to walk through it.  As a result, we need to make two passes\n * when handling structs, unions and arrays; the first path simply looks\n * for nonzero data, while the second actually does the display.  The first\n * pass is signalled by show->state.depth_check being set, and if we\n * encounter a non-zero value we set show->state.depth_to_show to\n * the depth at which we encountered it.  When we have completed the\n * first pass, we will know if anything needs to be displayed if\n * depth_to_show > depth.  See btf_[struct,array]_show() for the\n * implementation of this.\n *\n * Another problem is we want to ensure the data for display is safe to\n * access.  To support this, the anonymous \"struct {} obj\" tracks the data\n * object and our safe copy of it.  We copy portions of the data needed\n * to the object \"copy\" buffer, but because its size is limited to\n * BTF_SHOW_OBJ_COPY_LEN bytes, multiple copies may be required as we\n * traverse larger objects for display.\n *\n * The various data type show functions all start with a call to\n * btf_show_start_type() which returns a pointer to the safe copy\n * of the data needed (or if BTF_SHOW_UNSAFE is specified, to the\n * raw data itself).  btf_show_obj_safe() is responsible for\n * using copy_from_kernel_nofault() to update the safe data if necessary\n * as we traverse the object's data.  skbuff-like semantics are\n * used:\n *\n * - obj.head points to the start of the toplevel object for display\n * - obj.size is the size of the toplevel object\n * - obj.data points to the current point in the original data at\n *   which our safe data starts.  obj.data will advance as we copy\n *   portions of the data.\n *\n * In most cases a single copy will suffice, but larger data structures\n * such as \"struct task_struct\" will require many copies.  The logic in\n * btf_show_obj_safe() handles the logic that determines if a new\n * copy_from_kernel_nofault() is needed.\n */\nstruct btf_show {\n\tu64 flags;\n\tvoid *target;\t/* target of show operation (seq file, buffer) */\n\tvoid (*showfn)(struct btf_show *show, const char *fmt, va_list args);\n\tconst struct btf *btf;\n\t/* below are used during iteration */\n\tstruct {\n\t\tu8 depth;\n\t\tu8 depth_to_show;\n\t\tu8 depth_check;\n\t\tu8 array_member:1,\n\t\t   array_terminated:1;\n\t\tu16 array_encoding;\n\t\tu32 type_id;\n\t\tint status;\t\t\t/* non-zero for error */\n\t\tconst struct btf_type *type;\n\t\tconst struct btf_member *member;\n\t\tchar name[BTF_SHOW_NAME_SIZE];\t/* space for member name/type */\n\t} state;\n\tstruct {\n\t\tu32 size;\n\t\tvoid *head;\n\t\tvoid *data;\n\t\tu8 safe[BTF_SHOW_OBJ_SAFE_SIZE];\n\t} obj;\n};\n\nstruct btf_kind_operations {\n\ts32 (*check_meta)(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left);\n\tint (*resolve)(struct btf_verifier_env *env,\n\t\t       const struct resolve_vertex *v);\n\tint (*check_member)(struct btf_verifier_env *env,\n\t\t\t    const struct btf_type *struct_type,\n\t\t\t    const struct btf_member *member,\n\t\t\t    const struct btf_type *member_type);\n\tint (*check_kflag_member)(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type);\n\tvoid (*log_details)(struct btf_verifier_env *env,\n\t\t\t    const struct btf_type *t);\n\tvoid (*show)(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offsets,\n\t\t\t struct btf_show *show);\n};\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS];\nstatic struct btf_type btf_void;\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nstatic bool btf_type_is_modifier(const struct btf_type *t)\n{\n\t/* Some of them is not strictly a C modifier\n\t * but they are grouped into the same bucket\n\t * for BTF concern:\n\t *   A type (t) that refers to another\n\t *   type through t->type AND its size cannot\n\t *   be determined without following the t->type.\n\t *\n\t * ptr does not fall into this bucket\n\t * because its size is always sizeof(void *).\n\t */\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_TYPEDEF:\n\tcase BTF_KIND_VOLATILE:\n\tcase BTF_KIND_CONST:\n\tcase BTF_KIND_RESTRICT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}\n\nstatic bool btf_type_is_fwd(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_FWD;\n}\n\nstatic bool btf_type_nosize(const struct btf_type *t)\n{\n\treturn btf_type_is_void(t) || btf_type_is_fwd(t) ||\n\t       btf_type_is_func(t) || btf_type_is_func_proto(t);\n}\n\nstatic bool btf_type_nosize_or_null(const struct btf_type *t)\n{\n\treturn !t || btf_type_nosize(t);\n}\n\nstatic bool __btf_type_is_struct(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT;\n}\n\nstatic bool btf_type_is_array(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_ARRAY;\n}\n\nstatic bool btf_type_is_datasec(const struct btf_type *t)\n{\n\treturn BTF_INFO_KIND(t->info) == BTF_KIND_DATASEC;\n}\n\nstatic u32 btf_nr_types_total(const struct btf *btf)\n{\n\tu32 total = 0;\n\n\twhile (btf) {\n\t\ttotal += btf->nr_types;\n\t\tbtf = btf->base_btf;\n\t}\n\n\treturn total;\n}\n\ns32 btf_find_by_name_kind(const struct btf *btf, const char *name, u8 kind)\n{\n\tconst struct btf_type *t;\n\tconst char *tname;\n\tu32 i, total;\n\n\ttotal = btf_nr_types_total(btf);\n\tfor (i = 1; i < total; i++) {\n\t\tt = btf_type_by_id(btf, i);\n\t\tif (BTF_INFO_KIND(t->info) != kind)\n\t\t\tcontinue;\n\n\t\ttname = btf_name_by_offset(btf, t->name_off);\n\t\tif (!strcmp(tname, name))\n\t\t\treturn i;\n\t}\n\n\treturn -ENOENT;\n}\n\nconst struct btf_type *btf_type_skip_modifiers(const struct btf *btf,\n\t\t\t\t\t       u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t)) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\tif (res_id)\n\t\t*res_id = id;\n\n\treturn t;\n}\n\nconst struct btf_type *btf_type_resolve_ptr(const struct btf *btf,\n\t\t\t\t\t    u32 id, u32 *res_id)\n{\n\tconst struct btf_type *t;\n\n\tt = btf_type_skip_modifiers(btf, id, NULL);\n\tif (!btf_type_is_ptr(t))\n\t\treturn NULL;\n\n\treturn btf_type_skip_modifiers(btf, t->type, res_id);\n}\n\nconst struct btf_type *btf_type_resolve_func_ptr(const struct btf *btf,\n\t\t\t\t\t\t u32 id, u32 *res_id)\n{\n\tconst struct btf_type *ptype;\n\n\tptype = btf_type_resolve_ptr(btf, id, res_id);\n\tif (ptype && btf_type_is_func_proto(ptype))\n\t\treturn ptype;\n\n\treturn NULL;\n}\n\n/* Types that act only as a source, not sink or intermediate\n * type when resolving.\n */\nstatic bool btf_type_is_resolve_source_only(const struct btf_type *t)\n{\n\treturn btf_type_is_var(t) ||\n\t       btf_type_is_datasec(t);\n}\n\n/* What types need to be resolved?\n *\n * btf_type_is_modifier() is an obvious one.\n *\n * btf_type_is_struct() because its member refers to\n * another type (through member->type).\n *\n * btf_type_is_var() because the variable refers to\n * another type. btf_type_is_datasec() holds multiple\n * btf_type_is_var() types that need resolving.\n *\n * btf_type_is_array() because its element (array->type)\n * refers to another type.  Array can be thought of a\n * special case of struct while array just has the same\n * member-type repeated by array->nelems of times.\n */\nstatic bool btf_type_needs_resolve(const struct btf_type *t)\n{\n\treturn btf_type_is_modifier(t) ||\n\t       btf_type_is_ptr(t) ||\n\t       btf_type_is_struct(t) ||\n\t       btf_type_is_array(t) ||\n\t       btf_type_is_var(t) ||\n\t       btf_type_is_datasec(t);\n}\n\n/* t->size can be used */\nstatic bool btf_type_has_size(const struct btf_type *t)\n{\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_INT:\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\tcase BTF_KIND_ENUM:\n\tcase BTF_KIND_DATASEC:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const char *btf_int_encoding_str(u8 encoding)\n{\n\tif (encoding == 0)\n\t\treturn \"(none)\";\n\telse if (encoding == BTF_INT_SIGNED)\n\t\treturn \"SIGNED\";\n\telse if (encoding == BTF_INT_CHAR)\n\t\treturn \"CHAR\";\n\telse if (encoding == BTF_INT_BOOL)\n\t\treturn \"BOOL\";\n\telse\n\t\treturn \"UNKN\";\n}\n\nstatic u32 btf_type_int(const struct btf_type *t)\n{\n\treturn *(u32 *)(t + 1);\n}\n\nstatic const struct btf_array *btf_type_array(const struct btf_type *t)\n{\n\treturn (const struct btf_array *)(t + 1);\n}\n\nstatic const struct btf_enum *btf_type_enum(const struct btf_type *t)\n{\n\treturn (const struct btf_enum *)(t + 1);\n}\n\nstatic const struct btf_var *btf_type_var(const struct btf_type *t)\n{\n\treturn (const struct btf_var *)(t + 1);\n}\n\nstatic const struct btf_kind_operations *btf_type_ops(const struct btf_type *t)\n{\n\treturn kind_ops[BTF_INFO_KIND(t->info)];\n}\n\nstatic bool btf_name_offset_valid(const struct btf *btf, u32 offset)\n{\n\tif (!BTF_STR_OFFSET_VALID(offset))\n\t\treturn false;\n\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\treturn offset < btf->hdr.str_len;\n}\n\nstatic bool __btf_name_char_ok(char c, bool first, bool dot_ok)\n{\n\tif ((first ? !isalpha(c) :\n\t\t     !isalnum(c)) &&\n\t    c != '_' &&\n\t    ((c == '.' && !dot_ok) ||\n\t      c != '.'))\n\t\treturn false;\n\treturn true;\n}\n\nstatic const char *btf_str_by_offset(const struct btf *btf, u32 offset)\n{\n\twhile (offset < btf->start_str_off)\n\t\tbtf = btf->base_btf;\n\n\toffset -= btf->start_str_off;\n\tif (offset < btf->hdr.str_len)\n\t\treturn &btf->strings[offset];\n\n\treturn NULL;\n}\n\nstatic bool __btf_name_valid(const struct btf *btf, u32 offset, bool dot_ok)\n{\n\t/* offset must be valid */\n\tconst char *src = btf_str_by_offset(btf, offset);\n\tconst char *src_limit;\n\n\tif (!__btf_name_char_ok(*src, true, dot_ok))\n\t\treturn false;\n\n\t/* set a limit on identifier length */\n\tsrc_limit = src + KSYM_NAME_LEN;\n\tsrc++;\n\twhile (*src && src < src_limit) {\n\t\tif (!__btf_name_char_ok(*src, false, dot_ok))\n\t\t\treturn false;\n\t\tsrc++;\n\t}\n\n\treturn !*src;\n}\n\n/* Only C-style identifier is permitted. This can be relaxed if\n * necessary.\n */\nstatic bool btf_name_valid_identifier(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, false);\n}\n\nstatic bool btf_name_valid_section(const struct btf *btf, u32 offset)\n{\n\treturn __btf_name_valid(btf, offset, true);\n}\n\nstatic const char *__btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\tconst char *name;\n\n\tif (!offset)\n\t\treturn \"(anon)\";\n\n\tname = btf_str_by_offset(btf, offset);\n\treturn name ?: \"(invalid-name-offset)\";\n}\n\nconst char *btf_name_by_offset(const struct btf *btf, u32 offset)\n{\n\treturn btf_str_by_offset(btf, offset);\n}\n\nconst struct btf_type *btf_type_by_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\ttype_id -= btf->start_id;\n\tif (type_id >= btf->nr_types)\n\t\treturn NULL;\n\treturn btf->types[type_id];\n}\n\n/*\n * Regular int is not a bit field and it must be either\n * u8/u16/u32/u64 or __int128.\n */\nstatic bool btf_type_int_is_regular(const struct btf_type *t)\n{\n\tu8 nr_bits, nr_bytes;\n\tu32 int_data;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tnr_bytes = BITS_ROUNDUP_BYTES(nr_bits);\n\tif (BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BTF_INT_OFFSET(int_data) ||\n\t    (nr_bytes != sizeof(u8) && nr_bytes != sizeof(u16) &&\n\t     nr_bytes != sizeof(u32) && nr_bytes != sizeof(u64) &&\n\t     nr_bytes != (2 * sizeof(u64)))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/*\n * Check that given struct member is a regular int with expected\n * offset and size.\n */\nbool btf_member_is_reg_int(const struct btf *btf, const struct btf_type *s,\n\t\t\t   const struct btf_member *m,\n\t\t\t   u32 expected_offset, u32 expected_size)\n{\n\tconst struct btf_type *t;\n\tu32 id, int_data;\n\tu8 nr_bits;\n\n\tid = m->type;\n\tt = btf_type_id_size(btf, &id, NULL);\n\tif (!t || !btf_type_is_int(t))\n\t\treturn false;\n\n\tint_data = btf_type_int(t);\n\tnr_bits = BTF_INT_BITS(int_data);\n\tif (btf_type_kflag(s)) {\n\t\tu32 bitfield_size = BTF_MEMBER_BITFIELD_SIZE(m->offset);\n\t\tu32 bit_offset = BTF_MEMBER_BIT_OFFSET(m->offset);\n\n\t\t/* if kflag set, int should be a regular int and\n\t\t * bit offset should be at byte boundary.\n\t\t */\n\t\treturn !bitfield_size &&\n\t\t       BITS_ROUNDUP_BYTES(bit_offset) == expected_offset &&\n\t\t       BITS_ROUNDUP_BYTES(nr_bits) == expected_size;\n\t}\n\n\tif (BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(m->offset) ||\n\t    BITS_ROUNDUP_BYTES(m->offset) != expected_offset ||\n\t    BITS_PER_BYTE_MASKED(nr_bits) ||\n\t    BITS_ROUNDUP_BYTES(nr_bits) != expected_size)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* Similar to btf_type_skip_modifiers() but does not skip typedefs. */\nstatic const struct btf_type *btf_type_skip_qualifiers(const struct btf *btf,\n\t\t\t\t\t\t       u32 id)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, id);\n\n\twhile (btf_type_is_modifier(t) &&\n\t       BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF) {\n\t\tid = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\n\treturn t;\n}\n\n#define BTF_SHOW_MAX_ITER\t10\n\n#define BTF_KIND_BIT(kind)\t(1ULL << kind)\n\n/*\n * Populate show->state.name with type name information.\n * Format of type name is\n *\n * [.member_name = ] (type_name)\n */\nstatic const char *btf_show_name(struct btf_show *show)\n{\n\t/* BTF_MAX_ITER array suffixes \"[]\" */\n\tconst char *array_suffixes = \"[][][][][][][][][][]\";\n\tconst char *array_suffix = &array_suffixes[strlen(array_suffixes)];\n\t/* BTF_MAX_ITER pointer suffixes \"*\" */\n\tconst char *ptr_suffixes = \"**********\";\n\tconst char *ptr_suffix = &ptr_suffixes[strlen(ptr_suffixes)];\n\tconst char *name = NULL, *prefix = \"\", *parens = \"\";\n\tconst struct btf_member *m = show->state.member;\n\tconst struct btf_type *t = show->state.type;\n\tconst struct btf_array *array;\n\tu32 id = show->state.type_id;\n\tconst char *member = NULL;\n\tbool show_member = false;\n\tu64 kinds = 0;\n\tint i;\n\n\tshow->state.name[0] = '\\0';\n\n\t/*\n\t * Don't show type name if we're showing an array member;\n\t * in that case we show the array type so don't need to repeat\n\t * ourselves for each member.\n\t */\n\tif (show->state.array_member)\n\t\treturn \"\";\n\n\t/* Retrieve member name, if any. */\n\tif (m) {\n\t\tmember = btf_name_by_offset(show->btf, m->name_off);\n\t\tshow_member = strlen(member) > 0;\n\t\tid = m->type;\n\t}\n\n\t/*\n\t * Start with type_id, as we have resolved the struct btf_type *\n\t * via btf_modifier_show() past the parent typedef to the child\n\t * struct, int etc it is defined as.  In such cases, the type_id\n\t * still represents the starting type while the struct btf_type *\n\t * in our show->state points at the resolved type of the typedef.\n\t */\n\tt = btf_type_by_id(show->btf, id);\n\tif (!t)\n\t\treturn \"\";\n\n\t/*\n\t * The goal here is to build up the right number of pointer and\n\t * array suffixes while ensuring the type name for a typedef\n\t * is represented.  Along the way we accumulate a list of\n\t * BTF kinds we have encountered, since these will inform later\n\t * display; for example, pointer types will not require an\n\t * opening \"{\" for struct, we will just display the pointer value.\n\t *\n\t * We also want to accumulate the right number of pointer or array\n\t * indices in the format string while iterating until we get to\n\t * the typedef/pointee/array member target type.\n\t *\n\t * We start by pointing at the end of pointer and array suffix\n\t * strings; as we accumulate pointers and arrays we move the pointer\n\t * or array string backwards so it will show the expected number of\n\t * '*' or '[]' for the type.  BTF_SHOW_MAX_ITER of nesting of pointers\n\t * and/or arrays and typedefs are supported as a precaution.\n\t *\n\t * We also want to get typedef name while proceeding to resolve\n\t * type it points to so that we can add parentheses if it is a\n\t * \"typedef struct\" etc.\n\t */\n\tfor (i = 0; i < BTF_SHOW_MAX_ITER; i++) {\n\n\t\tswitch (BTF_INFO_KIND(t->info)) {\n\t\tcase BTF_KIND_TYPEDEF:\n\t\t\tif (!name)\n\t\t\t\tname = btf_name_by_offset(show->btf,\n\t\t\t\t\t\t\t       t->name_off);\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_TYPEDEF);\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_ARRAY);\n\t\t\tparens = \"[\";\n\t\t\tif (!t)\n\t\t\t\treturn \"\";\n\t\t\tarray = btf_type_array(t);\n\t\t\tif (array_suffix > array_suffixes)\n\t\t\t\tarray_suffix -= 2;\n\t\t\tid = array->type;\n\t\t\tbreak;\n\t\tcase BTF_KIND_PTR:\n\t\t\tkinds |= BTF_KIND_BIT(BTF_KIND_PTR);\n\t\t\tif (ptr_suffix > ptr_suffixes)\n\t\t\t\tptr_suffix -= 1;\n\t\t\tid = t->type;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tid = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!id)\n\t\t\tbreak;\n\t\tt = btf_type_skip_qualifiers(show->btf, id);\n\t}\n\t/* We may not be able to represent this type; bail to be safe */\n\tif (i == BTF_SHOW_MAX_ITER)\n\t\treturn \"\";\n\n\tif (!name)\n\t\tname = btf_name_by_offset(show->btf, t->name_off);\n\n\tswitch (BTF_INFO_KIND(t->info)) {\n\tcase BTF_KIND_STRUCT:\n\tcase BTF_KIND_UNION:\n\t\tprefix = BTF_INFO_KIND(t->info) == BTF_KIND_STRUCT ?\n\t\t\t \"struct\" : \"union\";\n\t\t/* if it's an array of struct/union, parens is already set */\n\t\tif (!(kinds & (BTF_KIND_BIT(BTF_KIND_ARRAY))))\n\t\t\tparens = \"{\";\n\t\tbreak;\n\tcase BTF_KIND_ENUM:\n\t\tprefix = \"enum\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* pointer does not require parens */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_PTR))\n\t\tparens = \"\";\n\t/* typedef does not require struct/union/enum prefix */\n\tif (kinds & BTF_KIND_BIT(BTF_KIND_TYPEDEF))\n\t\tprefix = \"\";\n\n\tif (!name)\n\t\tname = \"\";\n\n\t/* Even if we don't want type name info, we want parentheses etc */\n\tif (show->flags & BTF_SHOW_NONAME)\n\t\tsnprintf(show->state.name, sizeof(show->state.name), \"%s\",\n\t\t\t parens);\n\telse\n\t\tsnprintf(show->state.name, sizeof(show->state.name),\n\t\t\t \"%s%s%s(%s%s%s%s%s%s)%s\",\n\t\t\t /* first 3 strings comprise \".member = \" */\n\t\t\t show_member ? \".\" : \"\",\n\t\t\t show_member ? member : \"\",\n\t\t\t show_member ? \" = \" : \"\",\n\t\t\t /* ...next is our prefix (struct, enum, etc) */\n\t\t\t prefix,\n\t\t\t strlen(prefix) > 0 && strlen(name) > 0 ? \" \" : \"\",\n\t\t\t /* ...this is the type name itself */\n\t\t\t name,\n\t\t\t /* ...suffixed by the appropriate '*', '[]' suffixes */\n\t\t\t strlen(ptr_suffix) > 0 ? \" \" : \"\", ptr_suffix,\n\t\t\t array_suffix, parens);\n\n\treturn show->state.name;\n}\n\nstatic const char *__btf_show_indent(struct btf_show *show)\n{\n\tconst char *indents = \"                                \";\n\tconst char *indent = &indents[strlen(indents)];\n\n\tif ((indent - show->state.depth) >= indents)\n\t\treturn indent - show->state.depth;\n\treturn indents;\n}\n\nstatic const char *btf_show_indent(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : __btf_show_indent(show);\n}\n\nstatic const char *btf_show_newline(struct btf_show *show)\n{\n\treturn show->flags & BTF_SHOW_COMPACT ? \"\" : \"\\n\";\n}\n\nstatic const char *btf_show_delim(struct btf_show *show)\n{\n\tif (show->state.depth == 0)\n\t\treturn \"\";\n\n\tif ((show->flags & BTF_SHOW_COMPACT) && show->state.type &&\n\t\tBTF_INFO_KIND(show->state.type->info) == BTF_KIND_UNION)\n\t\treturn \"|\";\n\n\treturn \",\";\n}\n\n__printf(2, 3) static void btf_show(struct btf_show *show, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!show->state.depth_check) {\n\t\tva_start(args, fmt);\n\t\tshow->showfn(show, fmt, args);\n\t\tva_end(args);\n\t}\n}\n\n/* Macros are used here as btf_show_type_value[s]() prepends and appends\n * format specifiers to the format specifier passed in; these do the work of\n * adding indentation, delimiters etc while the caller simply has to specify\n * the type value(s) in the format specifier + value(s).\n */\n#define btf_show_type_value(show, fmt, value)\t\t\t\t       \\\n\tdo {\t\t\t\t\t\t\t\t       \\\n\t\tif ((value) != 0 || (show->flags & BTF_SHOW_ZERO) ||\t       \\\n\t\t    show->state.depth == 0) {\t\t\t\t       \\\n\t\t\tbtf_show(show, \"%s%s\" fmt \"%s%s\",\t\t       \\\n\t\t\t\t btf_show_indent(show),\t\t\t       \\\n\t\t\t\t btf_show_name(show),\t\t\t       \\\n\t\t\t\t value, btf_show_delim(show),\t\t       \\\n\t\t\t\t btf_show_newline(show));\t\t       \\\n\t\t\tif (show->state.depth > show->state.depth_to_show)     \\\n\t\t\t\tshow->state.depth_to_show = show->state.depth; \\\n\t\t}\t\t\t\t\t\t\t       \\\n\t} while (0)\n\n#define btf_show_type_values(show, fmt, ...)\t\t\t\t       \\\n\tdo {\t\t\t\t\t\t\t\t       \\\n\t\tbtf_show(show, \"%s%s\" fmt \"%s%s\", btf_show_indent(show),       \\\n\t\t\t btf_show_name(show),\t\t\t\t       \\\n\t\t\t __VA_ARGS__, btf_show_delim(show),\t\t       \\\n\t\t\t btf_show_newline(show));\t\t\t       \\\n\t\tif (show->state.depth > show->state.depth_to_show)\t       \\\n\t\t\tshow->state.depth_to_show = show->state.depth;\t       \\\n\t} while (0)\n\n/* How much is left to copy to safe buffer after @data? */\nstatic int btf_show_obj_size_left(struct btf_show *show, void *data)\n{\n\treturn show->obj.head + show->obj.size - data;\n}\n\n/* Is object pointed to by @data of @size already copied to our safe buffer? */\nstatic bool btf_show_obj_is_safe(struct btf_show *show, void *data, int size)\n{\n\treturn data >= show->obj.data &&\n\t       (data + size) < (show->obj.data + BTF_SHOW_OBJ_SAFE_SIZE);\n}\n\n/*\n * If object pointed to by @data of @size falls within our safe buffer, return\n * the equivalent pointer to the same safe data.  Assumes\n * copy_from_kernel_nofault() has already happened and our safe buffer is\n * populated.\n */\nstatic void *__btf_show_obj_safe(struct btf_show *show, void *data, int size)\n{\n\tif (btf_show_obj_is_safe(show, data, size))\n\t\treturn show->obj.safe + (data - show->obj.data);\n\treturn NULL;\n}\n\n/*\n * Return a safe-to-access version of data pointed to by @data.\n * We do this by copying the relevant amount of information\n * to the struct btf_show obj.safe buffer using copy_from_kernel_nofault().\n *\n * If BTF_SHOW_UNSAFE is specified, just return data as-is; no\n * safe copy is needed.\n *\n * Otherwise we need to determine if we have the required amount\n * of data (determined by the @data pointer and the size of the\n * largest base type we can encounter (represented by\n * BTF_SHOW_OBJ_BASE_TYPE_SIZE). Having that much data ensures\n * that we will be able to print some of the current object,\n * and if more is needed a copy will be triggered.\n * Some objects such as structs will not fit into the buffer;\n * in such cases additional copies when we iterate over their\n * members may be needed.\n *\n * btf_show_obj_safe() is used to return a safe buffer for\n * btf_show_start_type(); this ensures that as we recurse into\n * nested types we always have safe data for the given type.\n * This approach is somewhat wasteful; it's possible for example\n * that when iterating over a large union we'll end up copying the\n * same data repeatedly, but the goal is safety not performance.\n * We use stack data as opposed to per-CPU buffers because the\n * iteration over a type can take some time, and preemption handling\n * would greatly complicate use of the safe buffer.\n */\nstatic void *btf_show_obj_safe(struct btf_show *show,\n\t\t\t       const struct btf_type *t,\n\t\t\t       void *data)\n{\n\tconst struct btf_type *rt;\n\tint size_left, size;\n\tvoid *safe = NULL;\n\n\tif (show->flags & BTF_SHOW_UNSAFE)\n\t\treturn data;\n\n\trt = btf_resolve_size(show->btf, t, &size);\n\tif (IS_ERR(rt)) {\n\t\tshow->state.status = PTR_ERR(rt);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Is this toplevel object? If so, set total object size and\n\t * initialize pointers.  Otherwise check if we still fall within\n\t * our safe object data.\n\t */\n\tif (show->state.depth == 0) {\n\t\tshow->obj.size = size;\n\t\tshow->obj.head = data;\n\t} else {\n\t\t/*\n\t\t * If the size of the current object is > our remaining\n\t\t * safe buffer we _may_ need to do a new copy.  However\n\t\t * consider the case of a nested struct; it's size pushes\n\t\t * us over the safe buffer limit, but showing any individual\n\t\t * struct members does not.  In such cases, we don't need\n\t\t * to initiate a fresh copy yet; however we definitely need\n\t\t * at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes left\n\t\t * in our buffer, regardless of the current object size.\n\t\t * The logic here is that as we resolve types we will\n\t\t * hit a base type at some point, and we need to be sure\n\t\t * the next chunk of data is safely available to display\n\t\t * that type info safely.  We cannot rely on the size of\n\t\t * the current object here because it may be much larger\n\t\t * than our current buffer (e.g. task_struct is 8k).\n\t\t * All we want to do here is ensure that we can print the\n\t\t * next basic type, which we can if either\n\t\t * - the current type size is within the safe buffer; or\n\t\t * - at least BTF_SHOW_OBJ_BASE_TYPE_SIZE bytes are left in\n\t\t *   the safe buffer.\n\t\t */\n\t\tsafe = __btf_show_obj_safe(show, data,\n\t\t\t\t\t   min(size,\n\t\t\t\t\t       BTF_SHOW_OBJ_BASE_TYPE_SIZE));\n\t}\n\n\t/*\n\t * We need a new copy to our safe object, either because we haven't\n\t * yet copied and are intializing safe data, or because the data\n\t * we want falls outside the boundaries of the safe object.\n\t */\n\tif (!safe) {\n\t\tsize_left = btf_show_obj_size_left(show, data);\n\t\tif (size_left > BTF_SHOW_OBJ_SAFE_SIZE)\n\t\t\tsize_left = BTF_SHOW_OBJ_SAFE_SIZE;\n\t\tshow->state.status = copy_from_kernel_nofault(show->obj.safe,\n\t\t\t\t\t\t\t      data, size_left);\n\t\tif (!show->state.status) {\n\t\t\tshow->obj.data = data;\n\t\t\tsafe = show->obj.safe;\n\t\t}\n\t}\n\n\treturn safe;\n}\n\n/*\n * Set the type we are starting to show and return a safe data pointer\n * to be used for showing the associated data.\n */\nstatic void *btf_show_start_type(struct btf_show *show,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 type_id, void *data)\n{\n\tshow->state.type = t;\n\tshow->state.type_id = type_id;\n\tshow->state.name[0] = '\\0';\n\n\treturn btf_show_obj_safe(show, t, data);\n}\n\nstatic void btf_show_end_type(struct btf_show *show)\n{\n\tshow->state.type = NULL;\n\tshow->state.type_id = 0;\n\tshow->state.name[0] = '\\0';\n}\n\nstatic void *btf_show_start_aggr_type(struct btf_show *show,\n\t\t\t\t      const struct btf_type *t,\n\t\t\t\t      u32 type_id, void *data)\n{\n\tvoid *safe_data = btf_show_start_type(show, t, type_id, data);\n\n\tif (!safe_data)\n\t\treturn safe_data;\n\n\tbtf_show(show, \"%s%s%s\", btf_show_indent(show),\n\t\t btf_show_name(show),\n\t\t btf_show_newline(show));\n\tshow->state.depth++;\n\treturn safe_data;\n}\n\nstatic void btf_show_end_aggr_type(struct btf_show *show,\n\t\t\t\t   const char *suffix)\n{\n\tshow->state.depth--;\n\tbtf_show(show, \"%s%s%s%s\", btf_show_indent(show), suffix,\n\t\t btf_show_delim(show), btf_show_newline(show));\n\tbtf_show_end_type(show);\n}\n\nstatic void btf_show_start_member(struct btf_show *show,\n\t\t\t\t  const struct btf_member *m)\n{\n\tshow->state.member = m;\n}\n\nstatic void btf_show_start_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 1;\n\tbtf_show_start_member(show, NULL);\n}\n\nstatic void btf_show_end_member(struct btf_show *show)\n{\n\tshow->state.member = NULL;\n}\n\nstatic void btf_show_end_array_member(struct btf_show *show)\n{\n\tshow->state.array_member = 0;\n\tbtf_show_end_member(show);\n}\n\nstatic void *btf_show_start_array_type(struct btf_show *show,\n\t\t\t\t       const struct btf_type *t,\n\t\t\t\t       u32 type_id,\n\t\t\t\t       u16 array_encoding,\n\t\t\t\t       void *data)\n{\n\tshow->state.array_encoding = array_encoding;\n\tshow->state.array_terminated = 0;\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}\n\nstatic void btf_show_end_array_type(struct btf_show *show)\n{\n\tshow->state.array_encoding = 0;\n\tshow->state.array_terminated = 0;\n\tbtf_show_end_aggr_type(show, \"]\");\n}\n\nstatic void *btf_show_start_struct_type(struct btf_show *show,\n\t\t\t\t\tconst struct btf_type *t,\n\t\t\t\t\tu32 type_id,\n\t\t\t\t\tvoid *data)\n{\n\treturn btf_show_start_aggr_type(show, t, type_id, data);\n}\n\nstatic void btf_show_end_struct_type(struct btf_show *show)\n{\n\tbtf_show_end_aggr_type(show, \"}\");\n}\n\n__printf(2, 3) static void __btf_verifier_log(struct bpf_verifier_log *log,\n\t\t\t\t\t      const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}\n\n__printf(2, 3) static void btf_verifier_log(struct btf_verifier_env *env,\n\t\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(log, fmt, args);\n\tva_end(args);\n}\n\n__printf(4, 5) static void __btf_verifier_log_type(struct btf_verifier_env *env,\n\t\t\t\t\t\t   const struct btf_type *t,\n\t\t\t\t\t\t   bool log_details,\n\t\t\t\t\t\t   const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tu8 kind = BTF_INFO_KIND(t->info);\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\t/* btf verifier prints all types it is processing via\n\t * btf_verifier_log_type(..., fmt = NULL).\n\t * Skip those prints for in-kernel BTF verification.\n\t */\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\n\t__btf_verifier_log(log, \"[%u] %s %s%s\",\n\t\t\t   env->log_type_id,\n\t\t\t   btf_kind_str[kind],\n\t\t\t   __btf_name_by_offset(btf, t->name_off),\n\t\t\t   log_details ? \" \" : \"\");\n\n\tif (log_details)\n\t\tbtf_type_ops(t)->log_details(env, t);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}\n\n#define btf_verifier_log_type(env, t, ...) \\\n\t__btf_verifier_log_type((env), (t), true, __VA_ARGS__)\n#define btf_verifier_log_basic(env, t, ...) \\\n\t__btf_verifier_log_type((env), (t), false, __VA_ARGS__)\n\n__printf(4, 5)\nstatic void btf_verifier_log_member(struct btf_verifier_env *env,\n\t\t\t\t    const struct btf_type *struct_type,\n\t\t\t\t    const struct btf_member *member,\n\t\t\t\t    const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct btf *btf = env->btf;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\t/* The CHECK_META phase already did a btf dump.\n\t *\n\t * If member is logged again, it must hit an error in\n\t * parsing this member.  It is useful to print out which\n\t * struct this member belongs to.\n\t */\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, struct_type, NULL);\n\n\tif (btf_type_kflag(struct_type))\n\t\t__btf_verifier_log(log,\n\t\t\t\t   \"\\t%s type_id=%u bitfield_size=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type,\n\t\t\t\t   BTF_MEMBER_BITFIELD_SIZE(member->offset),\n\t\t\t\t   BTF_MEMBER_BIT_OFFSET(member->offset));\n\telse\n\t\t__btf_verifier_log(log, \"\\t%s type_id=%u bits_offset=%u\",\n\t\t\t\t   __btf_name_by_offset(btf, member->name_off),\n\t\t\t\t   member->type, member->offset);\n\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}\n\n__printf(4, 5)\nstatic void btf_verifier_log_vsi(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *datasec_type,\n\t\t\t\t const struct btf_var_secinfo *vsi,\n\t\t\t\t const char *fmt, ...)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\tif (log->level == BPF_LOG_KERNEL && !fmt)\n\t\treturn;\n\tif (env->phase != CHECK_META)\n\t\tbtf_verifier_log_type(env, datasec_type, NULL);\n\n\t__btf_verifier_log(log, \"\\t type_id=%u offset=%u size=%u\",\n\t\t\t   vsi->type, vsi->offset, vsi->size);\n\tif (fmt && *fmt) {\n\t\t__btf_verifier_log(log, \" \");\n\t\tva_start(args, fmt);\n\t\tbpf_verifier_vlog(log, fmt, args);\n\t\tva_end(args);\n\t}\n\n\t__btf_verifier_log(log, \"\\n\");\n}\n\nstatic void btf_verifier_log_hdr(struct btf_verifier_env *env,\n\t\t\t\t u32 btf_data_size)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tconst struct btf *btf = env->btf;\n\tconst struct btf_header *hdr;\n\n\tif (!bpf_verifier_log_needed(log))\n\t\treturn;\n\n\tif (log->level == BPF_LOG_KERNEL)\n\t\treturn;\n\thdr = &btf->hdr;\n\t__btf_verifier_log(log, \"magic: 0x%x\\n\", hdr->magic);\n\t__btf_verifier_log(log, \"version: %u\\n\", hdr->version);\n\t__btf_verifier_log(log, \"flags: 0x%x\\n\", hdr->flags);\n\t__btf_verifier_log(log, \"hdr_len: %u\\n\", hdr->hdr_len);\n\t__btf_verifier_log(log, \"type_off: %u\\n\", hdr->type_off);\n\t__btf_verifier_log(log, \"type_len: %u\\n\", hdr->type_len);\n\t__btf_verifier_log(log, \"str_off: %u\\n\", hdr->str_off);\n\t__btf_verifier_log(log, \"str_len: %u\\n\", hdr->str_len);\n\t__btf_verifier_log(log, \"btf_total_size: %u\\n\", btf_data_size);\n}\n\nstatic int btf_add_type(struct btf_verifier_env *env, struct btf_type *t)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (btf->types_size == btf->nr_types) {\n\t\t/* Expand 'types' array */\n\n\t\tstruct btf_type **new_types;\n\t\tu32 expand_by, new_size;\n\n\t\tif (btf->start_id + btf->types_size == BTF_MAX_TYPE) {\n\t\t\tbtf_verifier_log(env, \"Exceeded max num of types\");\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\texpand_by = max_t(u32, btf->types_size >> 2, 16);\n\t\tnew_size = min_t(u32, BTF_MAX_TYPE,\n\t\t\t\t btf->types_size + expand_by);\n\n\t\tnew_types = kvcalloc(new_size, sizeof(*new_types),\n\t\t\t\t     GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!new_types)\n\t\t\treturn -ENOMEM;\n\n\t\tif (btf->nr_types == 0) {\n\t\t\tif (!btf->base_btf) {\n\t\t\t\t/* lazily init VOID type */\n\t\t\t\tnew_types[0] = &btf_void;\n\t\t\t\tbtf->nr_types++;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(new_types, btf->types,\n\t\t\t       sizeof(*btf->types) * btf->nr_types);\n\t\t}\n\n\t\tkvfree(btf->types);\n\t\tbtf->types = new_types;\n\t\tbtf->types_size = new_size;\n\t}\n\n\tbtf->types[btf->nr_types++] = t;\n\n\treturn 0;\n}\n\nstatic int btf_alloc_id(struct btf *btf)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&btf_idr_lock);\n\tid = idr_alloc_cyclic(&btf_idr, btf, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tbtf->id = id;\n\tspin_unlock_bh(&btf_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}\n\nstatic void btf_free_id(struct btf *btf)\n{\n\tunsigned long flags;\n\n\t/*\n\t * In map-in-map, calling map_delete_elem() on outer\n\t * map will call bpf_map_put on the inner map.\n\t * It will then eventually call btf_free_id()\n\t * on the inner map.  Some of the map_delete_elem()\n\t * implementation may have irq disabled, so\n\t * we need to use the _irqsave() version instead\n\t * of the _bh() version.\n\t */\n\tspin_lock_irqsave(&btf_idr_lock, flags);\n\tidr_remove(&btf_idr, btf->id);\n\tspin_unlock_irqrestore(&btf_idr_lock, flags);\n}\n\nstatic void btf_free(struct btf *btf)\n{\n\tkvfree(btf->types);\n\tkvfree(btf->resolved_sizes);\n\tkvfree(btf->resolved_ids);\n\tkvfree(btf->data);\n\tkfree(btf);\n}\n\nstatic void btf_free_rcu(struct rcu_head *rcu)\n{\n\tstruct btf *btf = container_of(rcu, struct btf, rcu);\n\n\tbtf_free(btf);\n}\n\nvoid btf_get(struct btf *btf)\n{\n\trefcount_inc(&btf->refcnt);\n}\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}\n\nstatic int env_resolve_init(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tu32 nr_types = btf->nr_types;\n\tu32 *resolved_sizes = NULL;\n\tu32 *resolved_ids = NULL;\n\tu8 *visit_states = NULL;\n\n\tresolved_sizes = kvcalloc(nr_types, sizeof(*resolved_sizes),\n\t\t\t\t  GFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_sizes)\n\t\tgoto nomem;\n\n\tresolved_ids = kvcalloc(nr_types, sizeof(*resolved_ids),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!resolved_ids)\n\t\tgoto nomem;\n\n\tvisit_states = kvcalloc(nr_types, sizeof(*visit_states),\n\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\tif (!visit_states)\n\t\tgoto nomem;\n\n\tbtf->resolved_sizes = resolved_sizes;\n\tbtf->resolved_ids = resolved_ids;\n\tenv->visit_states = visit_states;\n\n\treturn 0;\n\nnomem:\n\tkvfree(resolved_sizes);\n\tkvfree(resolved_ids);\n\tkvfree(visit_states);\n\treturn -ENOMEM;\n}\n\nstatic void btf_verifier_env_free(struct btf_verifier_env *env)\n{\n\tkvfree(env->visit_states);\n\tkfree(env);\n}\n\nstatic bool env_type_is_resolve_sink(const struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *next_type)\n{\n\tswitch (env->resolve_mode) {\n\tcase RESOLVE_TBD:\n\t\t/* int, enum or void is a sink */\n\t\treturn !btf_type_needs_resolve(next_type);\n\tcase RESOLVE_PTR:\n\t\t/* int, enum, void, struct, array, func or func_proto is a sink\n\t\t * for ptr\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_ptr(next_type);\n\tcase RESOLVE_STRUCT_OR_ARRAY:\n\t\t/* int, enum, void, ptr, func or func_proto is a sink\n\t\t * for struct and array\n\t\t */\n\t\treturn !btf_type_is_modifier(next_type) &&\n\t\t\t!btf_type_is_array(next_type) &&\n\t\t\t!btf_type_is_struct(next_type);\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic bool env_type_is_resolved(const struct btf_verifier_env *env,\n\t\t\t\t u32 type_id)\n{\n\t/* base BTF types should be resolved by now */\n\tif (type_id < env->btf->start_id)\n\t\treturn true;\n\n\treturn env->visit_states[type_id - env->btf->start_id] == RESOLVED;\n}\n\nstatic int env_stack_push(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t, u32 type_id)\n{\n\tconst struct btf *btf = env->btf;\n\tstruct resolve_vertex *v;\n\n\tif (env->top_stack == MAX_RESOLVE_DEPTH)\n\t\treturn -E2BIG;\n\n\tif (type_id < btf->start_id\n\t    || env->visit_states[type_id - btf->start_id] != NOT_VISITED)\n\t\treturn -EEXIST;\n\n\tenv->visit_states[type_id - btf->start_id] = VISITED;\n\n\tv = &env->stack[env->top_stack++];\n\tv->t = t;\n\tv->type_id = type_id;\n\tv->next_member = 0;\n\n\tif (env->resolve_mode == RESOLVE_TBD) {\n\t\tif (btf_type_is_ptr(t))\n\t\t\tenv->resolve_mode = RESOLVE_PTR;\n\t\telse if (btf_type_is_struct(t) || btf_type_is_array(t))\n\t\t\tenv->resolve_mode = RESOLVE_STRUCT_OR_ARRAY;\n\t}\n\n\treturn 0;\n}\n\nstatic void env_stack_set_next_member(struct btf_verifier_env *env,\n\t\t\t\t      u16 next_member)\n{\n\tenv->stack[env->top_stack - 1].next_member = next_member;\n}\n\nstatic void env_stack_pop_resolved(struct btf_verifier_env *env,\n\t\t\t\t   u32 resolved_type_id,\n\t\t\t\t   u32 resolved_size)\n{\n\tu32 type_id = env->stack[--(env->top_stack)].type_id;\n\tstruct btf *btf = env->btf;\n\n\ttype_id -= btf->start_id; /* adjust to local type id */\n\tbtf->resolved_sizes[type_id] = resolved_size;\n\tbtf->resolved_ids[type_id] = resolved_type_id;\n\tenv->visit_states[type_id] = RESOLVED;\n}\n\nstatic const struct resolve_vertex *env_stack_peak(struct btf_verifier_env *env)\n{\n\treturn env->top_stack ? &env->stack[env->top_stack - 1] : NULL;\n}\n\n/* Resolve the size of a passed-in \"type\"\n *\n * type: is an array (e.g. u32 array[x][y])\n * return type: type \"u32[x][y]\", i.e. BTF_KIND_ARRAY,\n * *type_size: (x * y * sizeof(u32)).  Hence, *type_size always\n *             corresponds to the return type.\n * *elem_type: u32\n * *elem_id: id of u32\n * *total_nelems: (x * y).  Hence, individual elem size is\n *                (*type_size / *total_nelems)\n * *type_id: id of type if it's changed within the function, 0 if not\n *\n * type: is not an array (e.g. const struct X)\n * return type: type \"struct X\"\n * *type_size: sizeof(struct X)\n * *elem_type: same as return type (\"struct X\")\n * *elem_id: 0\n * *total_nelems: 1\n * *type_id: id of type if it's changed within the function, 0 if not\n */\nstatic const struct btf_type *\n__btf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t   u32 *type_size, const struct btf_type **elem_type,\n\t\t   u32 *elem_id, u32 *total_nelems, u32 *type_id)\n{\n\tconst struct btf_type *array_type = NULL;\n\tconst struct btf_array *array = NULL;\n\tu32 i, size, nelems = 1, id = 0;\n\n\tfor (i = 0; i < MAX_RESOLVE_DEPTH; i++) {\n\t\tswitch (BTF_INFO_KIND(type->info)) {\n\t\t/* type->size can be used */\n\t\tcase BTF_KIND_INT:\n\t\tcase BTF_KIND_STRUCT:\n\t\tcase BTF_KIND_UNION:\n\t\tcase BTF_KIND_ENUM:\n\t\t\tsize = type->size;\n\t\t\tgoto resolved;\n\n\t\tcase BTF_KIND_PTR:\n\t\t\tsize = sizeof(void *);\n\t\t\tgoto resolved;\n\n\t\t/* Modifiers */\n\t\tcase BTF_KIND_TYPEDEF:\n\t\tcase BTF_KIND_VOLATILE:\n\t\tcase BTF_KIND_CONST:\n\t\tcase BTF_KIND_RESTRICT:\n\t\t\tid = type->type;\n\t\t\ttype = btf_type_by_id(btf, type->type);\n\t\t\tbreak;\n\n\t\tcase BTF_KIND_ARRAY:\n\t\t\tif (!array_type)\n\t\t\t\tarray_type = type;\n\t\t\tarray = btf_type_array(type);\n\t\t\tif (nelems && array->nelems > U32_MAX / nelems)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\tnelems *= array->nelems;\n\t\t\ttype = btf_type_by_id(btf, array->type);\n\t\t\tbreak;\n\n\t\t/* type without size */\n\t\tdefault:\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n\nresolved:\n\tif (nelems && size > U32_MAX / nelems)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*type_size = nelems * size;\n\tif (total_nelems)\n\t\t*total_nelems = nelems;\n\tif (elem_type)\n\t\t*elem_type = type;\n\tif (elem_id)\n\t\t*elem_id = array ? array->type : 0;\n\tif (type_id && id)\n\t\t*type_id = id;\n\n\treturn array_type ? : type;\n}\n\nconst struct btf_type *\nbtf_resolve_size(const struct btf *btf, const struct btf_type *type,\n\t\t u32 *type_size)\n{\n\treturn __btf_resolve_size(btf, type, type_size, NULL, NULL, NULL, NULL);\n}\n\nstatic u32 btf_resolved_type_id(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_ids[type_id - btf->start_id];\n}\n\n/* The input param \"type_id\" must point to a needs_resolve type */\nstatic const struct btf_type *btf_type_id_resolve(const struct btf *btf,\n\t\t\t\t\t\t  u32 *type_id)\n{\n\t*type_id = btf_resolved_type_id(btf, *type_id);\n\treturn btf_type_by_id(btf, *type_id);\n}\n\nstatic u32 btf_resolved_type_size(const struct btf *btf, u32 type_id)\n{\n\twhile (type_id < btf->start_id)\n\t\tbtf = btf->base_btf;\n\n\treturn btf->resolved_sizes[type_id - btf->start_id];\n}\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_nosize_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type) &&\n\t\t\t\t !btf_type_is_var(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize_type_id = btf_resolved_type_id(btf, size_type_id);\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_nosize_or_null(size_type))\n\t\t\treturn NULL;\n\t\telse if (btf_type_has_size(size_type))\n\t\t\tsize = size_type->size;\n\t\telse if (btf_type_is_array(size_type))\n\t\t\tsize = btf_resolved_type_size(btf, size_type_id);\n\t\telse if (btf_type_is_ptr(size_type))\n\t\t\tsize = sizeof(void *);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}\n\nstatic int btf_df_check_member(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *struct_type,\n\t\t\t       const struct btf_member *member,\n\t\t\t       const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_member\");\n\treturn -EINVAL;\n}\n\nstatic int btf_df_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tbtf_verifier_log_basic(env, struct_type,\n\t\t\t       \"Unsupported check_kflag_member\");\n\treturn -EINVAL;\n}\n\n/* Used for ptr, array and struct/union type members.\n * int, enum and modifier types have their specific callback functions.\n */\nstatic int btf_generic_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t\t  const struct btf_member *member,\n\t\t\t\t\t  const struct btf_type *member_type)\n{\n\tif (BTF_MEMBER_BITFIELD_SIZE(member->offset)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* bitfield size is 0, so member->offset represents bit offset only.\n\t * It is safe to call non kflag check_member variants.\n\t */\n\treturn btf_type_ops(member_type)->check_member(env, struct_type,\n\t\t\t\t\t\t       member,\n\t\t\t\t\t\t       member_type);\n}\n\nstatic int btf_df_resolve(struct btf_verifier_env *env,\n\t\t\t  const struct resolve_vertex *v)\n{\n\tbtf_verifier_log_basic(env, v->t, \"Unsupported resolve\");\n\treturn -EINVAL;\n}\n\nstatic void btf_df_show(const struct btf *btf, const struct btf_type *t,\n\t\t\tu32 type_id, void *data, u8 bits_offsets,\n\t\t\tstruct btf_show *show)\n{\n\tbtf_show(show, \"<unsupported kind:%u>\", BTF_INFO_KIND(t->info));\n}\n\nstatic int btf_int_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\tu32 bytes_offset;\n\n\tif (U32_MAX - struct_bits_off < BTF_INT_OFFSET(int_data)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"bits_offset exceeds U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_bits_off += BTF_INT_OFFSET(int_data);\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = BTF_INT_BITS(int_data) +\n\t\tBITS_PER_BYTE_MASKED(struct_bits_off);\n\n\tif (nr_copy_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 128\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_int_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t      const struct btf_type *struct_type,\n\t\t\t\t      const struct btf_member *member,\n\t\t\t\t      const struct btf_type *member_type)\n{\n\tu32 struct_bits_off, nr_bits, nr_int_data_bits, bytes_offset;\n\tu32 int_data = btf_type_int(member_type);\n\tu32 struct_size = struct_type->size;\n\tu32 nr_copy_bits;\n\n\t/* a regular int type is required for the kflag int member */\n\tif (!btf_type_int_is_regular(member_type)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member base type\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check sanity of bitfield size */\n\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);\n\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);\n\tnr_int_data_bits = BTF_INT_BITS(int_data);\n\tif (!nr_bits) {\n\t\t/* Not a bitfield member, member offset must be at byte\n\t\t * boundary.\n\t\t */\n\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\t\"Invalid member offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnr_bits = nr_int_data_bits;\n\t} else if (nr_bits > nr_int_data_bits) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tnr_copy_bits = nr_bits + BITS_PER_BYTE_MASKED(struct_bits_off);\n\tif (nr_copy_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"nr_copy_bits exceeds 128\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size < bytes_offset ||\n\t    struct_size - bytes_offset < BITS_ROUNDUP_BYTES(nr_copy_bits)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic s32 btf_int_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tu32 int_data, nr_bits, meta_needed = sizeof(int_data);\n\tu16 encoding;\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tint_data = btf_type_int(t);\n\tif (int_data & ~BTF_INT_MASK) {\n\t\tbtf_verifier_log_basic(env, t, \"Invalid int_data:%x\",\n\t\t\t\t       int_data);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_bits = BTF_INT_BITS(int_data) + BTF_INT_OFFSET(int_data);\n\n\tif (nr_bits > BITS_PER_U128) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds %zu\",\n\t\t\t\t      BITS_PER_U128);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BITS_ROUNDUP_BYTES(nr_bits) > t->size) {\n\t\tbtf_verifier_log_type(env, t, \"nr_bits exceeds type_size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Only one of the encoding bits is allowed and it\n\t * should be sufficient for the pretty print purpose (i.e. decoding).\n\t * Multiple bits can be allowed later if it is found\n\t * to be insufficient.\n\t */\n\tencoding = BTF_INT_ENCODING(int_data);\n\tif (encoding &&\n\t    encoding != BTF_INT_SIGNED &&\n\t    encoding != BTF_INT_CHAR &&\n\t    encoding != BTF_INT_BOOL) {\n\t\tbtf_verifier_log_type(env, t, \"Unsupported encoding\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}\n\nstatic void btf_int_log(struct btf_verifier_env *env,\n\t\t\tconst struct btf_type *t)\n{\n\tint int_data = btf_type_int(t);\n\n\tbtf_verifier_log(env,\n\t\t\t \"size=%u bits_offset=%u nr_bits=%u encoding=%s\",\n\t\t\t t->size, BTF_INT_OFFSET(int_data),\n\t\t\t BTF_INT_BITS(int_data),\n\t\t\t btf_int_encoding_str(BTF_INT_ENCODING(int_data)));\n}\n\nstatic void btf_int128_print(struct btf_show *show, void *data)\n{\n\t/* data points to a __int128 number.\n\t * Suppose\n\t *     int128_num = *(__int128 *)data;\n\t * The below formulas shows what upper_num and lower_num represents:\n\t *     upper_num = int128_num >> 64;\n\t *     lower_num = int128_num & 0xffffffffFFFFFFFFULL;\n\t */\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = *(u64 *)data;\n\tlower_num = *(u64 *)(data + 8);\n#else\n\tupper_num = *(u64 *)(data + 8);\n\tlower_num = *(u64 *)data;\n#endif\n\tif (upper_num == 0)\n\t\tbtf_show_type_value(show, \"0x%llx\", lower_num);\n\telse\n\t\tbtf_show_type_values(show, \"0x%llx%016llx\", upper_num,\n\t\t\t\t     lower_num);\n}\n\nstatic void btf_int128_shift(u64 *print_num, u16 left_shift_bits,\n\t\t\t     u16 right_shift_bits)\n{\n\tu64 upper_num, lower_num;\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tupper_num = print_num[0];\n\tlower_num = print_num[1];\n#else\n\tupper_num = print_num[1];\n\tlower_num = print_num[0];\n#endif\n\n\t/* shake out un-needed bits by shift/or operations */\n\tif (left_shift_bits >= 64) {\n\t\tupper_num = lower_num << (left_shift_bits - 64);\n\t\tlower_num = 0;\n\t} else {\n\t\tupper_num = (upper_num << left_shift_bits) |\n\t\t\t    (lower_num >> (64 - left_shift_bits));\n\t\tlower_num = lower_num << left_shift_bits;\n\t}\n\n\tif (right_shift_bits >= 64) {\n\t\tlower_num = upper_num >> (right_shift_bits - 64);\n\t\tupper_num = 0;\n\t} else {\n\t\tlower_num = (lower_num >> right_shift_bits) |\n\t\t\t    (upper_num << (64 - right_shift_bits));\n\t\tupper_num = upper_num >> right_shift_bits;\n\t}\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tprint_num[0] = upper_num;\n\tprint_num[1] = lower_num;\n#else\n\tprint_num[0] = lower_num;\n\tprint_num[1] = upper_num;\n#endif\n}\n\nstatic void btf_bitfield_show(void *data, u8 bits_offset,\n\t\t\t      u8 nr_bits, struct btf_show *show)\n{\n\tu16 left_shift_bits, right_shift_bits;\n\tu8 nr_copy_bytes;\n\tu8 nr_copy_bits;\n\tu64 print_num[2] = {};\n\n\tnr_copy_bits = nr_bits + bits_offset;\n\tnr_copy_bytes = BITS_ROUNDUP_BYTES(nr_copy_bits);\n\n\tmemcpy(print_num, data, nr_copy_bytes);\n\n#ifdef __BIG_ENDIAN_BITFIELD\n\tleft_shift_bits = bits_offset;\n#else\n\tleft_shift_bits = BITS_PER_U128 - nr_copy_bits;\n#endif\n\tright_shift_bits = BITS_PER_U128 - nr_bits;\n\n\tbtf_int128_shift(print_num, left_shift_bits, right_shift_bits);\n\tbtf_int128_print(show, print_num);\n}\n\n\nstatic void btf_int_bits_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tu8 total_bits_offset;\n\n\t/*\n\t * bits_offset is at most 7.\n\t * BTF_INT_OFFSET() cannot exceed 128 bits.\n\t */\n\ttotal_bits_offset = bits_offset + BTF_INT_OFFSET(int_data);\n\tdata += BITS_ROUNDDOWN_BYTES(total_bits_offset);\n\tbits_offset = BITS_PER_BYTE_MASKED(total_bits_offset);\n\tbtf_bitfield_show(data, bits_offset, nr_bits, show);\n}\n\nstatic void btf_int_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tu32 int_data = btf_type_int(t);\n\tu8 encoding = BTF_INT_ENCODING(int_data);\n\tbool sign = encoding & BTF_INT_SIGNED;\n\tu8 nr_bits = BTF_INT_BITS(int_data);\n\tvoid *safe_data;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tif (bits_offset || BTF_INT_OFFSET(int_data) ||\n\t    BITS_PER_BYTE_MASKED(nr_bits)) {\n\t\tbtf_int_bits_show(btf, t, safe_data, bits_offset, show);\n\t\tgoto out;\n\t}\n\n\tswitch (nr_bits) {\n\tcase 128:\n\t\tbtf_int128_print(show, safe_data);\n\t\tbreak;\n\tcase 64:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%lld\", *(s64 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%llu\", *(u64 *)safe_data);\n\t\tbreak;\n\tcase 32:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s32 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u32 *)safe_data);\n\t\tbreak;\n\tcase 16:\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s16 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u16 *)safe_data);\n\t\tbreak;\n\tcase 8:\n\t\tif (show->state.array_encoding == BTF_INT_CHAR) {\n\t\t\t/* check for null terminator */\n\t\t\tif (show->state.array_terminated)\n\t\t\t\tbreak;\n\t\t\tif (*(char *)data == '\\0') {\n\t\t\t\tshow->state.array_terminated = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isprint(*(char *)data)) {\n\t\t\t\tbtf_show_type_value(show, \"'%c'\",\n\t\t\t\t\t\t    *(char *)safe_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sign)\n\t\t\tbtf_show_type_value(show, \"%d\", *(s8 *)safe_data);\n\t\telse\n\t\t\tbtf_show_type_value(show, \"%u\", *(u8 *)safe_data);\n\t\tbreak;\n\tdefault:\n\t\tbtf_int_bits_show(btf, t, safe_data, bits_offset, show);\n\t\tbreak;\n\t}\nout:\n\tbtf_show_end_type(show);\n}\n\nstatic const struct btf_kind_operations int_ops = {\n\t.check_meta = btf_int_check_meta,\n\t.resolve = btf_df_resolve,\n\t.check_member = btf_int_check_member,\n\t.check_kflag_member = btf_int_check_kflag_member,\n\t.log_details = btf_int_log,\n\t.show = btf_int_show,\n};\n\nstatic int btf_modifier_check_member(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *struct_type,\n\t\t\t\t     const struct btf_member *member,\n\t\t\t\t     const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_member(env, struct_type,\n\t\t\t\t\t\t\t &resolved_member,\n\t\t\t\t\t\t\t resolved_type);\n}\n\nstatic int btf_modifier_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t\t   const struct btf_member *member,\n\t\t\t\t\t   const struct btf_type *member_type)\n{\n\tconst struct btf_type *resolved_type;\n\tu32 resolved_type_id = member->type;\n\tstruct btf_member resolved_member;\n\tstruct btf *btf = env->btf;\n\n\tresolved_type = btf_type_id_size(btf, &resolved_type_id, NULL);\n\tif (!resolved_type) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member\");\n\t\treturn -EINVAL;\n\t}\n\n\tresolved_member = *member;\n\tresolved_member.type = resolved_type_id;\n\n\treturn btf_type_ops(resolved_type)->check_kflag_member(env, struct_type,\n\t\t\t\t\t\t\t       &resolved_member,\n\t\t\t\t\t\t\t       resolved_type);\n}\n\nstatic int btf_ptr_check_member(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *struct_type,\n\t\t\t\tconst struct btf_member *member,\n\t\t\t\tconst struct btf_type *member_type)\n{\n\tu32 struct_size, struct_bits_off, bytes_offset;\n\n\tstruct_size = struct_type->size;\n\tstruct_bits_off = member->offset;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (struct_size - bytes_offset < sizeof(void *)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_ref_type_check_meta(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *t,\n\t\t\t\t   u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* typedef type must have a valid name, and other ref types,\n\t * volatile, const, restrict, should have a null name.\n\t */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_TYPEDEF) {\n\t\tif (!t->name_off ||\n\t\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (t->name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}\n\nstatic int btf_modifier_resolve(struct btf_verifier_env *env,\n\t\t\t\tconst struct resolve_vertex *v)\n{\n\tconst struct btf_type *t = v->t;\n\tconst struct btf_type *next_type;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* Figure out the resolved next_type_id with size.\n\t * They will be stored in the current modifier's\n\t * resolved_ids and resolved_sizes such that it can\n\t * save us a few type-following when we use it later (e.g. in\n\t * pretty print).\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tif (env_type_is_resolved(env, next_type_id))\n\t\t\tnext_type = btf_type_id_resolve(btf, &next_type_id);\n\n\t\t/* \"typedef void new_void\", \"const void\"...etc */\n\t\tif (!btf_type_is_void(next_type) &&\n\t\t    !btf_type_is_fwd(next_type) &&\n\t\t    !btf_type_is_func_proto(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}\n\nstatic int btf_var_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\t/* We must resolve to something concrete at this point, no\n\t * forward types or similar that would resolve to size of\n\t * zero is allowed.\n\t */\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}\n\nstatic int btf_ptr_resolve(struct btf_verifier_env *env,\n\t\t\t   const struct resolve_vertex *v)\n{\n\tconst struct btf_type *next_type;\n\tconst struct btf_type *t = v->t;\n\tu32 next_type_id = t->type;\n\tstruct btf *btf = env->btf;\n\n\tnext_type = btf_type_by_id(btf, next_type_id);\n\tif (!next_type || btf_type_is_resolve_source_only(next_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, next_type) &&\n\t    !env_type_is_resolved(env, next_type_id))\n\t\treturn env_stack_push(env, next_type, next_type_id);\n\n\t/* If the modifier was RESOLVED during RESOLVE_STRUCT_OR_ARRAY,\n\t * the modifier may have stopped resolving when it was resolved\n\t * to a ptr (last-resolved-ptr).\n\t *\n\t * We now need to continue from the last-resolved-ptr to\n\t * ensure the last-resolved-ptr will not referring back to\n\t * the currenct ptr (t).\n\t */\n\tif (btf_type_is_modifier(next_type)) {\n\t\tconst struct btf_type *resolved_type;\n\t\tu32 resolved_type_id;\n\n\t\tresolved_type_id = next_type_id;\n\t\tresolved_type = btf_type_id_resolve(btf, &resolved_type_id);\n\n\t\tif (btf_type_is_ptr(resolved_type) &&\n\t\t    !env_type_is_resolve_sink(env, resolved_type) &&\n\t\t    !env_type_is_resolved(env, resolved_type_id))\n\t\t\treturn env_stack_push(env, resolved_type,\n\t\t\t\t\t      resolved_type_id);\n\t}\n\n\tif (!btf_type_id_size(btf, &next_type_id, NULL)) {\n\t\tif (env_type_is_resolved(env, next_type_id))\n\t\t\tnext_type = btf_type_id_resolve(btf, &next_type_id);\n\n\t\tif (!btf_type_is_void(next_type) &&\n\t\t    !btf_type_is_fwd(next_type) &&\n\t\t    !btf_type_is_func_proto(next_type)) {\n\t\t\tbtf_verifier_log_type(env, v->t, \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, next_type_id, 0);\n\n\treturn 0;\n}\n\nstatic void btf_modifier_show(const struct btf *btf,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id, void *data,\n\t\t\t      u8 bits_offset, struct btf_show *show)\n{\n\tif (btf->resolved_ids)\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\telse\n\t\tt = btf_type_skip_modifiers(btf, type_id, NULL);\n\n\tbtf_type_ops(t)->show(btf, t, type_id, data, bits_offset, show);\n}\n\nstatic void btf_var_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tt = btf_type_id_resolve(btf, &type_id);\n\n\tbtf_type_ops(t)->show(btf, t, type_id, data, bits_offset, show);\n}\n\nstatic void btf_ptr_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t u32 type_id, void *data, u8 bits_offset,\n\t\t\t struct btf_show *show)\n{\n\tvoid *safe_data;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\t/* It is a hashed value unless BTF_SHOW_PTR_RAW is specified */\n\tif (show->flags & BTF_SHOW_PTR_RAW)\n\t\tbtf_show_type_value(show, \"0x%px\", *(void **)safe_data);\n\telse\n\t\tbtf_show_type_value(show, \"0x%p\", *(void **)safe_data);\n\tbtf_show_end_type(show);\n}\n\nstatic void btf_ref_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"type_id=%u\", t->type);\n}\n\nstatic struct btf_kind_operations modifier_ops = {\n\t.check_meta = btf_ref_type_check_meta,\n\t.resolve = btf_modifier_resolve,\n\t.check_member = btf_modifier_check_member,\n\t.check_kflag_member = btf_modifier_check_kflag_member,\n\t.log_details = btf_ref_type_log,\n\t.show = btf_modifier_show,\n};\n\nstatic struct btf_kind_operations ptr_ops = {\n\t.check_meta = btf_ref_type_check_meta,\n\t.resolve = btf_ptr_resolve,\n\t.check_member = btf_ptr_check_member,\n\t.check_kflag_member = btf_generic_check_kflag_member,\n\t.log_details = btf_ref_type_log,\n\t.show = btf_ptr_show,\n};\n\nstatic s32 btf_fwd_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->type) {\n\t\tbtf_verifier_log_type(env, t, \"type != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* fwd type must have a valid name */\n\tif (!t->name_off ||\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}\n\nstatic void btf_fwd_type_log(struct btf_verifier_env *env,\n\t\t\t     const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"%s\", btf_type_kflag(t) ? \"union\" : \"struct\");\n}\n\nstatic struct btf_kind_operations fwd_ops = {\n\t.check_meta = btf_fwd_check_meta,\n\t.resolve = btf_df_resolve,\n\t.check_member = btf_df_check_member,\n\t.check_kflag_member = btf_df_check_kflag_member,\n\t.log_details = btf_fwd_type_log,\n\t.show = btf_df_show,\n};\n\nstatic int btf_array_check_member(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *struct_type,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\tu32 array_type_id, array_size;\n\tstruct btf *btf = env->btf;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tarray_type_id = member->type;\n\tbtf_type_id_size(btf, &array_type_id, &array_size);\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < array_size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic s32 btf_array_check_meta(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t,\n\t\t\t\tu32 meta_left)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tu32 meta_needed = sizeof(*array);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\t/* array type should not have a name */\n\tif (t->name_off) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Array elem type and index type cannot be in type void,\n\t * so !array->type and !array->index_type are not allowed.\n\t */\n\tif (!array->type || !BTF_TYPE_ID_VALID(array->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!array->index_type || !BTF_TYPE_ID_VALID(array->index_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}\n\nstatic int btf_array_resolve(struct btf_verifier_env *env,\n\t\t\t     const struct resolve_vertex *v)\n{\n\tconst struct btf_array *array = btf_type_array(v->t);\n\tconst struct btf_type *elem_type, *index_type;\n\tu32 elem_type_id, index_type_id;\n\tstruct btf *btf = env->btf;\n\tu32 elem_size;\n\n\t/* Check array->index_type */\n\tindex_type_id = array->index_type;\n\tindex_type = btf_type_by_id(btf, index_type_id);\n\tif (btf_type_nosize_or_null(index_type) ||\n\t    btf_type_is_resolve_source_only(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, index_type) &&\n\t    !env_type_is_resolved(env, index_type_id))\n\t\treturn env_stack_push(env, index_type, index_type_id);\n\n\tindex_type = btf_type_id_size(btf, &index_type_id, NULL);\n\tif (!index_type || !btf_type_is_int(index_type) ||\n\t    !btf_type_int_is_regular(index_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid index\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check array->type */\n\telem_type_id = array->type;\n\telem_type = btf_type_by_id(btf, elem_type_id);\n\tif (btf_type_nosize_or_null(elem_type) ||\n\t    btf_type_is_resolve_source_only(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env_type_is_resolve_sink(env, elem_type) &&\n\t    !env_type_is_resolved(env, elem_type_id))\n\t\treturn env_stack_push(env, elem_type, elem_type_id);\n\n\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\tif (!elem_type) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid elem\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_is_int(elem_type) && !btf_type_int_is_regular(elem_type)) {\n\t\tbtf_verifier_log_type(env, v->t, \"Invalid array of int\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (array->nelems && elem_size > U32_MAX / array->nelems) {\n\t\tbtf_verifier_log_type(env, v->t,\n\t\t\t\t      \"Array size overflows U32_MAX\");\n\t\treturn -EINVAL;\n\t}\n\n\tenv_stack_pop_resolved(env, elem_type_id, elem_size * array->nelems);\n\n\treturn 0;\n}\n\nstatic void btf_array_log(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\n\tbtf_verifier_log(env, \"type_id=%u index_type_id=%u nr_elems=%u\",\n\t\t\t array->type, array->index_type, array->nelems);\n}\n\nstatic void __btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t     u32 type_id, void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_array *array = btf_type_array(t);\n\tconst struct btf_kind_operations *elem_ops;\n\tconst struct btf_type *elem_type;\n\tu32 i, elem_size = 0, elem_type_id;\n\tu16 encoding = 0;\n\n\telem_type_id = array->type;\n\telem_type = btf_type_skip_modifiers(btf, elem_type_id, NULL);\n\tif (elem_type && btf_type_has_size(elem_type))\n\t\telem_size = elem_type->size;\n\n\tif (elem_type && btf_type_is_int(elem_type)) {\n\t\tu32 int_type = btf_type_int(elem_type);\n\n\t\tencoding = BTF_INT_ENCODING(int_type);\n\n\t\t/*\n\t\t * BTF_INT_CHAR encoding never seems to be set for\n\t\t * char arrays, so if size is 1 and element is\n\t\t * printable as a char, we'll do that.\n\t\t */\n\t\tif (elem_size == 1)\n\t\t\tencoding = BTF_INT_CHAR;\n\t}\n\n\tif (!btf_show_start_array_type(show, t, type_id, encoding, data))\n\t\treturn;\n\n\tif (!elem_type)\n\t\tgoto out;\n\telem_ops = btf_type_ops(elem_type);\n\n\tfor (i = 0; i < array->nelems; i++) {\n\n\t\tbtf_show_start_array_member(show);\n\n\t\telem_ops->show(btf, elem_type, elem_type_id, data,\n\t\t\t       bits_offset, show);\n\t\tdata += elem_size;\n\n\t\tbtf_show_end_array_member(show);\n\n\t\tif (show->state.array_terminated)\n\t\t\tbreak;\n\t}\nout:\n\tbtf_show_end_array_type(show);\n}\n\nstatic void btf_array_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t   u32 type_id, void *data, u8 bits_offset,\n\t\t\t   struct btf_show *show)\n{\n\tconst struct btf_member *m = show->state.member;\n\n\t/*\n\t * First check if any members would be shown (are non-zero).\n\t * See comments above \"struct btf_show\" definition for more\n\t * details on how this works at a high-level.\n\t */\n\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {\n\t\tif (!show->state.depth_check) {\n\t\t\tshow->state.depth_check = show->state.depth + 1;\n\t\t\tshow->state.depth_to_show = 0;\n\t\t}\n\t\t__btf_array_show(btf, t, type_id, data, bits_offset, show);\n\t\tshow->state.member = m;\n\n\t\tif (show->state.depth_check != show->state.depth + 1)\n\t\t\treturn;\n\t\tshow->state.depth_check = 0;\n\n\t\tif (show->state.depth_to_show <= show->state.depth)\n\t\t\treturn;\n\t\t/*\n\t\t * Reaching here indicates we have recursed and found\n\t\t * non-zero array member(s).\n\t\t */\n\t}\n\t__btf_array_show(btf, t, type_id, data, bits_offset, show);\n}\n\nstatic struct btf_kind_operations array_ops = {\n\t.check_meta = btf_array_check_meta,\n\t.resolve = btf_array_resolve,\n\t.check_member = btf_array_check_member,\n\t.check_kflag_member = btf_generic_check_kflag_member,\n\t.log_details = btf_array_log,\n\t.show = btf_array_show,\n};\n\nstatic int btf_struct_check_member(struct btf_verifier_env *env,\n\t\t\t\t   const struct btf_type *struct_type,\n\t\t\t\t   const struct btf_member *member,\n\t\t\t\t   const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic s32 btf_struct_check_meta(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *t,\n\t\t\t\t u32 meta_left)\n{\n\tbool is_union = BTF_INFO_KIND(t->info) == BTF_KIND_UNION;\n\tconst struct btf_member *member;\n\tu32 meta_needed, last_offset;\n\tstruct btf *btf = env->btf;\n\tu32 struct_size = t->size;\n\tu32 offset;\n\tu16 i;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*member);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\t/* struct type either no name or a valid one */\n\tif (t->name_off &&\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tlast_offset = 0;\n\tfor_each_member(i, t, member) {\n\t\tif (!btf_name_offset_valid(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member name_offset:%u\",\n\t\t\t\t\t\tmember->name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* struct member either no name or a valid one */\n\t\tif (member->name_off &&\n\t\t    !btf_name_valid_identifier(btf, member->name_off)) {\n\t\t\tbtf_verifier_log_member(env, t, member, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* A member cannot be in type void */\n\t\tif (!member->type || !BTF_TYPE_ID_VALID(member->type)) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = btf_member_bit_offset(t, member);\n\t\tif (is_union && offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/*\n\t\t * \">\" instead of \">=\" because the last member could be\n\t\t * \"char a[0];\"\n\t\t */\n\t\tif (last_offset > offset) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Invalid member bits_offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BITS_ROUNDUP_BYTES(offset) > struct_size) {\n\t\t\tbtf_verifier_log_member(env, t, member,\n\t\t\t\t\t\t\"Member bits_offset exceeds its struct size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_member(env, t, member, NULL);\n\t\tlast_offset = offset;\n\t}\n\n\treturn meta_needed;\n}\n\nstatic int btf_struct_resolve(struct btf_verifier_env *env,\n\t\t\t      const struct resolve_vertex *v)\n{\n\tconst struct btf_member *member;\n\tint err;\n\tu16 i;\n\n\t/* Before continue resolving the next_member,\n\t * ensure the last member is indeed resolved to a\n\t * type with size info.\n\t */\n\tif (v->next_member) {\n\t\tconst struct btf_type *last_member_type;\n\t\tconst struct btf_member *last_member;\n\t\tu16 last_member_type_id;\n\n\t\tlast_member = btf_type_member(v->t) + v->next_member - 1;\n\t\tlast_member_type_id = last_member->type;\n\t\tif (WARN_ON_ONCE(!env_type_is_resolved(env,\n\t\t\t\t\t\t       last_member_type_id)))\n\t\t\treturn -EINVAL;\n\n\t\tlast_member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t  last_member_type_id);\n\t\tif (btf_type_kflag(v->t))\n\t\t\terr = btf_type_ops(last_member_type)->check_kflag_member(env, v->t,\n\t\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\t\tlast_member_type);\n\t\telse\n\t\t\terr = btf_type_ops(last_member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t\tlast_member,\n\t\t\t\t\t\t\t\tlast_member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_member_from(i, v->next_member, v->t, member) {\n\t\tu32 member_type_id = member->type;\n\t\tconst struct btf_type *member_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\tmember_type_id);\n\n\t\tif (btf_type_nosize_or_null(member_type) ||\n\t\t    btf_type_is_resolve_source_only(member_type)) {\n\t\t\tbtf_verifier_log_member(env, v->t, member,\n\t\t\t\t\t\t\"Invalid member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, member_type) &&\n\t\t    !env_type_is_resolved(env, member_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, member_type, member_type_id);\n\t\t}\n\n\t\tif (btf_type_kflag(v->t))\n\t\t\terr = btf_type_ops(member_type)->check_kflag_member(env, v->t,\n\t\t\t\t\t\t\t\t\t    member,\n\t\t\t\t\t\t\t\t\t    member_type);\n\t\telse\n\t\t\terr = btf_type_ops(member_type)->check_member(env, v->t,\n\t\t\t\t\t\t\t\t      member,\n\t\t\t\t\t\t\t\t      member_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\n\treturn 0;\n}\n\nstatic void btf_struct_log(struct btf_verifier_env *env,\n\t\t\t   const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}\n\n/* find 'struct bpf_spin_lock' in map value.\n * return >= 0 offset if found\n * and < 0 in case of error\n */\nint btf_find_spin_lock(const struct btf *btf, const struct btf_type *t)\n{\n\tconst struct btf_member *member;\n\tu32 i, off = -ENOENT;\n\n\tif (!__btf_type_is_struct(t))\n\t\treturn -EINVAL;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\t    member->type);\n\t\tif (!__btf_type_is_struct(member_type))\n\t\t\tcontinue;\n\t\tif (member_type->size != sizeof(struct bpf_spin_lock))\n\t\t\tcontinue;\n\t\tif (strcmp(__btf_name_by_offset(btf, member_type->name_off),\n\t\t\t   \"bpf_spin_lock\"))\n\t\t\tcontinue;\n\t\tif (off != -ENOENT)\n\t\t\t/* only one 'struct bpf_spin_lock' is allowed */\n\t\t\treturn -E2BIG;\n\t\toff = btf_member_bit_offset(t, member);\n\t\tif (off % 8)\n\t\t\t/* valid C code cannot generate such BTF */\n\t\t\treturn -EINVAL;\n\t\toff /= 8;\n\t\tif (off % __alignof__(struct bpf_spin_lock))\n\t\t\t/* valid struct bpf_spin_lock will be 4 byte aligned */\n\t\t\treturn -EINVAL;\n\t}\n\treturn off;\n}\n\nstatic void __btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t      u32 type_id, void *data, u8 bits_offset,\n\t\t\t      struct btf_show *show)\n{\n\tconst struct btf_member *member;\n\tvoid *safe_data;\n\tu32 i;\n\n\tsafe_data = btf_show_start_struct_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tfor_each_member(i, t, member) {\n\t\tconst struct btf_type *member_type = btf_type_by_id(btf,\n\t\t\t\t\t\t\t\tmember->type);\n\t\tconst struct btf_kind_operations *ops;\n\t\tu32 member_offset, bitfield_size;\n\t\tu32 bytes_offset;\n\t\tu8 bits8_offset;\n\n\t\tbtf_show_start_member(show, member);\n\n\t\tmember_offset = btf_member_bit_offset(t, member);\n\t\tbitfield_size = btf_member_bitfield_size(t, member);\n\t\tbytes_offset = BITS_ROUNDDOWN_BYTES(member_offset);\n\t\tbits8_offset = BITS_PER_BYTE_MASKED(member_offset);\n\t\tif (bitfield_size) {\n\t\t\tsafe_data = btf_show_start_type(show, member_type,\n\t\t\t\t\t\t\tmember->type,\n\t\t\t\t\t\t\tdata + bytes_offset);\n\t\t\tif (safe_data)\n\t\t\t\tbtf_bitfield_show(safe_data,\n\t\t\t\t\t\t  bits8_offset,\n\t\t\t\t\t\t  bitfield_size, show);\n\t\t\tbtf_show_end_type(show);\n\t\t} else {\n\t\t\tops = btf_type_ops(member_type);\n\t\t\tops->show(btf, member_type, member->type,\n\t\t\t\t  data + bytes_offset, bits8_offset, show);\n\t\t}\n\n\t\tbtf_show_end_member(show);\n\t}\n\n\tbtf_show_end_struct_type(show);\n}\n\nstatic void btf_struct_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t    u32 type_id, void *data, u8 bits_offset,\n\t\t\t    struct btf_show *show)\n{\n\tconst struct btf_member *m = show->state.member;\n\n\t/*\n\t * First check if any members would be shown (are non-zero).\n\t * See comments above \"struct btf_show\" definition for more\n\t * details on how this works at a high-level.\n\t */\n\tif (show->state.depth > 0 && !(show->flags & BTF_SHOW_ZERO)) {\n\t\tif (!show->state.depth_check) {\n\t\t\tshow->state.depth_check = show->state.depth + 1;\n\t\t\tshow->state.depth_to_show = 0;\n\t\t}\n\t\t__btf_struct_show(btf, t, type_id, data, bits_offset, show);\n\t\t/* Restore saved member data here */\n\t\tshow->state.member = m;\n\t\tif (show->state.depth_check != show->state.depth + 1)\n\t\t\treturn;\n\t\tshow->state.depth_check = 0;\n\n\t\tif (show->state.depth_to_show <= show->state.depth)\n\t\t\treturn;\n\t\t/*\n\t\t * Reaching here indicates we have recursed and found\n\t\t * non-zero child values.\n\t\t */\n\t}\n\n\t__btf_struct_show(btf, t, type_id, data, bits_offset, show);\n}\n\nstatic struct btf_kind_operations struct_ops = {\n\t.check_meta = btf_struct_check_meta,\n\t.resolve = btf_struct_resolve,\n\t.check_member = btf_struct_check_member,\n\t.check_kflag_member = btf_generic_check_kflag_member,\n\t.log_details = btf_struct_log,\n\t.show = btf_struct_show,\n};\n\nstatic int btf_enum_check_member(struct btf_verifier_env *env,\n\t\t\t\t const struct btf_type *struct_type,\n\t\t\t\t const struct btf_member *member,\n\t\t\t\t const struct btf_type *member_type)\n{\n\tu32 struct_bits_off = member->offset;\n\tu32 struct_size, bytes_offset;\n\n\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member is not byte aligned\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_offset = BITS_ROUNDDOWN_BYTES(struct_bits_off);\n\tif (struct_size - bytes_offset < member_type->size) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_enum_check_kflag_member(struct btf_verifier_env *env,\n\t\t\t\t       const struct btf_type *struct_type,\n\t\t\t\t       const struct btf_member *member,\n\t\t\t\t       const struct btf_type *member_type)\n{\n\tu32 struct_bits_off, nr_bits, bytes_end, struct_size;\n\tu32 int_bitsize = sizeof(int) * BITS_PER_BYTE;\n\n\tstruct_bits_off = BTF_MEMBER_BIT_OFFSET(member->offset);\n\tnr_bits = BTF_MEMBER_BITFIELD_SIZE(member->offset);\n\tif (!nr_bits) {\n\t\tif (BITS_PER_BYTE_MASKED(struct_bits_off)) {\n\t\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\t\"Member is not byte aligned\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnr_bits = int_bitsize;\n\t} else if (nr_bits > int_bitsize) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Invalid member bitfield_size\");\n\t\treturn -EINVAL;\n\t}\n\n\tstruct_size = struct_type->size;\n\tbytes_end = BITS_ROUNDUP_BYTES(struct_bits_off + nr_bits);\n\tif (struct_size < bytes_end) {\n\t\tbtf_verifier_log_member(env, struct_type, member,\n\t\t\t\t\t\"Member exceeds struct_size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic s32 btf_enum_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tstruct btf *btf = env->btf;\n\tu16 i, nr_enums;\n\tu32 meta_needed;\n\n\tnr_enums = btf_type_vlen(t);\n\tmeta_needed = nr_enums * sizeof(*enums);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->size > 8 || !is_power_of_2(t->size)) {\n\t\tbtf_verifier_log_type(env, t, \"Unexpected size\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* enum type either no name or a valid one */\n\tif (t->name_off &&\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (!btf_name_offset_valid(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log(env, \"\\tInvalid name_offset:%u\",\n\t\t\t\t\t enums[i].name_off);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* enum member must have a valid name */\n\t\tif (!enums[i].name_off ||\n\t\t    !btf_name_valid_identifier(btf, enums[i].name_off)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (env->log.level == BPF_LOG_KERNEL)\n\t\t\tcontinue;\n\t\tbtf_verifier_log(env, \"\\t%s val=%d\\n\",\n\t\t\t\t __btf_name_by_offset(btf, enums[i].name_off),\n\t\t\t\t enums[i].val);\n\t}\n\n\treturn meta_needed;\n}\n\nstatic void btf_enum_log(struct btf_verifier_env *env,\n\t\t\t const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}\n\nstatic void btf_enum_show(const struct btf *btf, const struct btf_type *t,\n\t\t\t  u32 type_id, void *data, u8 bits_offset,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_enum *enums = btf_type_enum(t);\n\tu32 i, nr_enums = btf_type_vlen(t);\n\tvoid *safe_data;\n\tint v;\n\n\tsafe_data = btf_show_start_type(show, t, type_id, data);\n\tif (!safe_data)\n\t\treturn;\n\n\tv = *(int *)safe_data;\n\n\tfor (i = 0; i < nr_enums; i++) {\n\t\tif (v != enums[i].val)\n\t\t\tcontinue;\n\n\t\tbtf_show_type_value(show, \"%s\",\n\t\t\t\t    __btf_name_by_offset(btf,\n\t\t\t\t\t\t\t enums[i].name_off));\n\n\t\tbtf_show_end_type(show);\n\t\treturn;\n\t}\n\n\tbtf_show_type_value(show, \"%d\", v);\n\tbtf_show_end_type(show);\n}\n\nstatic struct btf_kind_operations enum_ops = {\n\t.check_meta = btf_enum_check_meta,\n\t.resolve = btf_df_resolve,\n\t.check_member = btf_enum_check_member,\n\t.check_kflag_member = btf_enum_check_kflag_member,\n\t.log_details = btf_enum_log,\n\t.show = btf_enum_show,\n};\n\nstatic s32 btf_func_proto_check_meta(struct btf_verifier_env *env,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     u32 meta_left)\n{\n\tu32 meta_needed = btf_type_vlen(t) * sizeof(struct btf_param);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t->name_off) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}\n\nstatic void btf_func_proto_log(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t)\n{\n\tconst struct btf_param *args = (const struct btf_param *)(t + 1);\n\tu16 nr_args = btf_type_vlen(t), i;\n\n\tbtf_verifier_log(env, \"return=%u args=(\", t->type);\n\tif (!nr_args) {\n\t\tbtf_verifier_log(env, \"void\");\n\t\tgoto done;\n\t}\n\n\tif (nr_args == 1 && !args[0].type) {\n\t\t/* Only one vararg */\n\t\tbtf_verifier_log(env, \"vararg\");\n\t\tgoto done;\n\t}\n\n\tbtf_verifier_log(env, \"%u %s\", args[0].type,\n\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t      args[0].name_off));\n\tfor (i = 1; i < nr_args - 1; i++)\n\t\tbtf_verifier_log(env, \", %u %s\", args[i].type,\n\t\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t\t      args[i].name_off));\n\n\tif (nr_args > 1) {\n\t\tconst struct btf_param *last_arg = &args[nr_args - 1];\n\n\t\tif (last_arg->type)\n\t\t\tbtf_verifier_log(env, \", %u %s\", last_arg->type,\n\t\t\t\t\t __btf_name_by_offset(env->btf,\n\t\t\t\t\t\t\t      last_arg->name_off));\n\t\telse\n\t\t\tbtf_verifier_log(env, \", vararg\");\n\t}\n\ndone:\n\tbtf_verifier_log(env, \")\");\n}\n\nstatic struct btf_kind_operations func_proto_ops = {\n\t.check_meta = btf_func_proto_check_meta,\n\t.resolve = btf_df_resolve,\n\t/*\n\t * BTF_KIND_FUNC_PROTO cannot be directly referred by\n\t * a struct's member.\n\t *\n\t * It should be a funciton pointer instead.\n\t * (i.e. struct's member -> BTF_KIND_PTR -> BTF_KIND_FUNC_PROTO)\n\t *\n\t * Hence, there is no btf_func_check_member().\n\t */\n\t.check_member = btf_df_check_member,\n\t.check_kflag_member = btf_df_check_kflag_member,\n\t.log_details = btf_func_proto_log,\n\t.show = btf_df_show,\n};\n\nstatic s32 btf_func_check_meta(struct btf_verifier_env *env,\n\t\t\t       const struct btf_type *t,\n\t\t\t       u32 meta_left)\n{\n\tif (!t->name_off ||\n\t    !btf_name_valid_identifier(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t) > BTF_FUNC_GLOBAL) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid func linkage\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn 0;\n}\n\nstatic struct btf_kind_operations func_ops = {\n\t.check_meta = btf_func_check_meta,\n\t.resolve = btf_df_resolve,\n\t.check_member = btf_df_check_member,\n\t.check_kflag_member = btf_df_check_kflag_member,\n\t.log_details = btf_ref_type_log,\n\t.show = btf_df_show,\n};\n\nstatic s32 btf_var_check_meta(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 meta_left)\n{\n\tconst struct btf_var *var;\n\tu32 meta_needed = sizeof(*var);\n\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen != 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->name_off ||\n\t    !__btf_name_valid(env->btf, t->name_off, true)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* A var cannot be in type void */\n\tif (!t->type || !BTF_TYPE_ID_VALID(t->type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\tvar = btf_type_var(t);\n\tif (var->linkage != BTF_VAR_STATIC &&\n\t    var->linkage != BTF_VAR_GLOBAL_ALLOCATED) {\n\t\tbtf_verifier_log_type(env, t, \"Linkage not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\treturn meta_needed;\n}\n\nstatic void btf_var_log(struct btf_verifier_env *env, const struct btf_type *t)\n{\n\tconst struct btf_var *var = btf_type_var(t);\n\n\tbtf_verifier_log(env, \"type_id=%u linkage=%u\", t->type, var->linkage);\n}\n\nstatic const struct btf_kind_operations var_ops = {\n\t.check_meta\t\t= btf_var_check_meta,\n\t.resolve\t\t= btf_var_resolve,\n\t.check_member\t\t= btf_df_check_member,\n\t.check_kflag_member\t= btf_df_check_kflag_member,\n\t.log_details\t\t= btf_var_log,\n\t.show\t\t\t= btf_var_show,\n};\n\nstatic s32 btf_datasec_check_meta(struct btf_verifier_env *env,\n\t\t\t\t  const struct btf_type *t,\n\t\t\t\t  u32 meta_left)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tu64 last_vsi_end_off = 0, sum = 0;\n\tu32 i, meta_needed;\n\n\tmeta_needed = btf_type_vlen(t) * sizeof(*vsi);\n\tif (meta_left < meta_needed) {\n\t\tbtf_verifier_log_basic(env, t,\n\t\t\t\t       \"meta_left:%u meta_needed:%u\",\n\t\t\t\t       meta_left, meta_needed);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_type_vlen(t)) {\n\t\tbtf_verifier_log_type(env, t, \"vlen == 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->size) {\n\t\tbtf_verifier_log_type(env, t, \"size == 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (btf_type_kflag(t)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info kind_flag\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!t->name_off ||\n\t    !btf_name_valid_section(env->btf, t->name_off)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid name\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_verifier_log_type(env, t, NULL);\n\n\tfor_each_vsi(i, t, vsi) {\n\t\t/* A var cannot be in type void */\n\t\tif (!vsi->type || !BTF_TYPE_ID_VALID(vsi->type)) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid type_id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (vsi->offset < last_vsi_end_off || vsi->offset >= t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!vsi->size || vsi->size > t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlast_vsi_end_off = vsi->offset + vsi->size;\n\t\tif (last_vsi_end_off > t->size) {\n\t\t\tbtf_verifier_log_vsi(env, t, vsi,\n\t\t\t\t\t     \"Invalid offset+size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbtf_verifier_log_vsi(env, t, vsi, NULL);\n\t\tsum += vsi->size;\n\t}\n\n\tif (t->size < sum) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid btf_info size\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn meta_needed;\n}\n\nstatic int btf_datasec_resolve(struct btf_verifier_env *env,\n\t\t\t       const struct resolve_vertex *v)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tstruct btf *btf = env->btf;\n\tu16 i;\n\n\tfor_each_vsi_from(i, v->next_member, v->t, vsi) {\n\t\tu32 var_type_id = vsi->type, type_id, type_size = 0;\n\t\tconst struct btf_type *var_type = btf_type_by_id(env->btf,\n\t\t\t\t\t\t\t\t var_type_id);\n\t\tif (!var_type || !btf_type_is_var(var_type)) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi,\n\t\t\t\t\t     \"Not a VAR kind member\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!env_type_is_resolve_sink(env, var_type) &&\n\t\t    !env_type_is_resolved(env, var_type_id)) {\n\t\t\tenv_stack_set_next_member(env, i + 1);\n\t\t\treturn env_stack_push(env, var_type, var_type_id);\n\t\t}\n\n\t\ttype_id = var_type->type;\n\t\tif (!btf_type_id_size(btf, &type_id, &type_size)) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi, \"Invalid type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (vsi->size < type_size) {\n\t\t\tbtf_verifier_log_vsi(env, v->t, vsi, \"Invalid size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tenv_stack_pop_resolved(env, 0, 0);\n\treturn 0;\n}\n\nstatic void btf_datasec_log(struct btf_verifier_env *env,\n\t\t\t    const struct btf_type *t)\n{\n\tbtf_verifier_log(env, \"size=%u vlen=%u\", t->size, btf_type_vlen(t));\n}\n\nstatic void btf_datasec_show(const struct btf *btf,\n\t\t\t     const struct btf_type *t, u32 type_id,\n\t\t\t     void *data, u8 bits_offset,\n\t\t\t     struct btf_show *show)\n{\n\tconst struct btf_var_secinfo *vsi;\n\tconst struct btf_type *var;\n\tu32 i;\n\n\tif (!btf_show_start_type(show, t, type_id, data))\n\t\treturn;\n\n\tbtf_show_type_value(show, \"section (\\\"%s\\\") = {\",\n\t\t\t    __btf_name_by_offset(btf, t->name_off));\n\tfor_each_vsi(i, t, vsi) {\n\t\tvar = btf_type_by_id(btf, vsi->type);\n\t\tif (i)\n\t\t\tbtf_show(show, \",\");\n\t\tbtf_type_ops(var)->show(btf, var, vsi->type,\n\t\t\t\t\tdata + vsi->offset, bits_offset, show);\n\t}\n\tbtf_show_end_type(show);\n}\n\nstatic const struct btf_kind_operations datasec_ops = {\n\t.check_meta\t\t= btf_datasec_check_meta,\n\t.resolve\t\t= btf_datasec_resolve,\n\t.check_member\t\t= btf_df_check_member,\n\t.check_kflag_member\t= btf_df_check_kflag_member,\n\t.log_details\t\t= btf_datasec_log,\n\t.show\t\t\t= btf_datasec_show,\n};\n\nstatic int btf_func_proto_check(struct btf_verifier_env *env,\n\t\t\t\tconst struct btf_type *t)\n{\n\tconst struct btf_type *ret_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\tint err;\n\n\tbtf = env->btf;\n\targs = (const struct btf_param *)(t + 1);\n\tnr_args = btf_type_vlen(t);\n\n\t/* Check func return type which could be \"void\" (t->type == 0) */\n\tif (t->type) {\n\t\tu32 ret_type_id = t->type;\n\n\t\tret_type = btf_type_by_id(btf, ret_type_id);\n\t\tif (!ret_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(ret_type) &&\n\t\t    !env_type_is_resolved(env, ret_type_id)) {\n\t\t\terr = btf_resolve(env, ret_type, ret_type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t/* Ensure the return type is a type that has a size */\n\t\tif (!btf_type_id_size(btf, &ret_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid return type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!nr_args)\n\t\treturn 0;\n\n\t/* Last func arg type_id could be 0 if it is a vararg */\n\tif (!args[nr_args - 1].type) {\n\t\tif (args[nr_args - 1].name_off) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\",\n\t\t\t\t\t      nr_args);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnr_args--;\n\t}\n\n\terr = 0;\n\tfor (i = 0; i < nr_args; i++) {\n\t\tconst struct btf_type *arg_type;\n\t\tu32 arg_type_id;\n\n\t\targ_type_id = args[i].type;\n\t\targ_type = btf_type_by_id(btf, arg_type_id);\n\t\tif (!arg_type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (args[i].name_off &&\n\t\t    (!btf_name_offset_valid(btf, args[i].name_off) ||\n\t\t     !btf_name_valid_identifier(btf, args[i].name_off))) {\n\t\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t\t      \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (btf_type_needs_resolve(arg_type) &&\n\t\t    !env_type_is_resolved(env, arg_type_id)) {\n\t\t\terr = btf_resolve(env, arg_type, arg_type_id);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!btf_type_id_size(btf, &arg_type_id, NULL)) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int btf_func_check(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t)\n{\n\tconst struct btf_type *proto_type;\n\tconst struct btf_param *args;\n\tconst struct btf *btf;\n\tu16 nr_args, i;\n\n\tbtf = env->btf;\n\tproto_type = btf_type_by_id(btf, t->type);\n\n\tif (!proto_type || !btf_type_is_func_proto(proto_type)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid type_id\");\n\t\treturn -EINVAL;\n\t}\n\n\targs = (const struct btf_param *)(proto_type + 1);\n\tnr_args = btf_type_vlen(proto_type);\n\tfor (i = 0; i < nr_args; i++) {\n\t\tif (!args[i].name_off && args[i].type) {\n\t\t\tbtf_verifier_log_type(env, t, \"Invalid arg#%u\", i + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct btf_kind_operations * const kind_ops[NR_BTF_KINDS] = {\n\t[BTF_KIND_INT] = &int_ops,\n\t[BTF_KIND_PTR] = &ptr_ops,\n\t[BTF_KIND_ARRAY] = &array_ops,\n\t[BTF_KIND_STRUCT] = &struct_ops,\n\t[BTF_KIND_UNION] = &struct_ops,\n\t[BTF_KIND_ENUM] = &enum_ops,\n\t[BTF_KIND_FWD] = &fwd_ops,\n\t[BTF_KIND_TYPEDEF] = &modifier_ops,\n\t[BTF_KIND_VOLATILE] = &modifier_ops,\n\t[BTF_KIND_CONST] = &modifier_ops,\n\t[BTF_KIND_RESTRICT] = &modifier_ops,\n\t[BTF_KIND_FUNC] = &func_ops,\n\t[BTF_KIND_FUNC_PROTO] = &func_proto_ops,\n\t[BTF_KIND_VAR] = &var_ops,\n\t[BTF_KIND_DATASEC] = &datasec_ops,\n};\n\nstatic s32 btf_check_meta(struct btf_verifier_env *env,\n\t\t\t  const struct btf_type *t,\n\t\t\t  u32 meta_left)\n{\n\tu32 saved_meta_left = meta_left;\n\ts32 var_meta_size;\n\n\tif (meta_left < sizeof(*t)) {\n\t\tbtf_verifier_log(env, \"[%u] meta_left:%u meta_needed:%zu\",\n\t\t\t\t env->log_type_id, meta_left, sizeof(*t));\n\t\treturn -EINVAL;\n\t}\n\tmeta_left -= sizeof(*t);\n\n\tif (t->info & ~BTF_INFO_MASK) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid btf_info:%x\",\n\t\t\t\t env->log_type_id, t->info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BTF_INFO_KIND(t->info) > BTF_KIND_MAX ||\n\t    BTF_INFO_KIND(t->info) == BTF_KIND_UNKN) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid kind:%u\",\n\t\t\t\t env->log_type_id, BTF_INFO_KIND(t->info));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btf_name_offset_valid(env->btf, t->name_off)) {\n\t\tbtf_verifier_log(env, \"[%u] Invalid name_offset:%u\",\n\t\t\t\t env->log_type_id, t->name_off);\n\t\treturn -EINVAL;\n\t}\n\n\tvar_meta_size = btf_type_ops(t)->check_meta(env, t, meta_left);\n\tif (var_meta_size < 0)\n\t\treturn var_meta_size;\n\n\tmeta_left -= var_meta_size;\n\n\treturn saved_meta_left - meta_left;\n}\n\nstatic int btf_check_all_metas(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tstruct btf_header *hdr;\n\tvoid *cur, *end;\n\n\thdr = &btf->hdr;\n\tcur = btf->nohdr_data + hdr->type_off;\n\tend = cur + hdr->type_len;\n\n\tenv->log_type_id = btf->base_btf ? btf->start_id : 1;\n\twhile (cur < end) {\n\t\tstruct btf_type *t = cur;\n\t\ts32 meta_size;\n\n\t\tmeta_size = btf_check_meta(env, t, end - cur);\n\t\tif (meta_size < 0)\n\t\t\treturn meta_size;\n\n\t\tbtf_add_type(env, t);\n\t\tcur += meta_size;\n\t\tenv->log_type_id++;\n\t}\n\n\treturn 0;\n}\n\nstatic bool btf_resolve_valid(struct btf_verifier_env *env,\n\t\t\t      const struct btf_type *t,\n\t\t\t      u32 type_id)\n{\n\tstruct btf *btf = env->btf;\n\n\tif (!env_type_is_resolved(env, type_id))\n\t\treturn false;\n\n\tif (btf_type_is_struct(t) || btf_type_is_datasec(t))\n\t\treturn !btf_resolved_type_id(btf, type_id) &&\n\t\t       !btf_resolved_type_size(btf, type_id);\n\n\tif (btf_type_is_modifier(t) || btf_type_is_ptr(t) ||\n\t    btf_type_is_var(t)) {\n\t\tt = btf_type_id_resolve(btf, &type_id);\n\t\treturn t &&\n\t\t       !btf_type_is_modifier(t) &&\n\t\t       !btf_type_is_var(t) &&\n\t\t       !btf_type_is_datasec(t);\n\t}\n\n\tif (btf_type_is_array(t)) {\n\t\tconst struct btf_array *array = btf_type_array(t);\n\t\tconst struct btf_type *elem_type;\n\t\tu32 elem_type_id = array->type;\n\t\tu32 elem_size;\n\n\t\telem_type = btf_type_id_size(btf, &elem_type_id, &elem_size);\n\t\treturn elem_type && !btf_type_is_modifier(elem_type) &&\n\t\t\t(array->nelems * elem_size ==\n\t\t\t btf_resolved_type_size(btf, type_id));\n\t}\n\n\treturn false;\n}\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id)\n{\n\tu32 save_log_type_id = env->log_type_id;\n\tconst struct resolve_vertex *v;\n\tint err = 0;\n\n\tenv->resolve_mode = RESOLVE_TBD;\n\tenv_stack_push(env, t, type_id);\n\twhile (!err && (v = env_stack_peak(env))) {\n\t\tenv->log_type_id = v->type_id;\n\t\terr = btf_type_ops(v->t)->resolve(env, v);\n\t}\n\n\tenv->log_type_id = type_id;\n\tif (err == -E2BIG) {\n\t\tbtf_verifier_log_type(env, t,\n\t\t\t\t      \"Exceeded max resolving depth:%u\",\n\t\t\t\t      MAX_RESOLVE_DEPTH);\n\t} else if (err == -EEXIST) {\n\t\tbtf_verifier_log_type(env, t, \"Loop detected\");\n\t}\n\n\t/* Final sanity check */\n\tif (!err && !btf_resolve_valid(env, t, type_id)) {\n\t\tbtf_verifier_log_type(env, t, \"Invalid resolve state\");\n\t\terr = -EINVAL;\n\t}\n\n\tenv->log_type_id = save_log_type_id;\n\treturn err;\n}\n\nstatic int btf_check_all_types(struct btf_verifier_env *env)\n{\n\tstruct btf *btf = env->btf;\n\tconst struct btf_type *t;\n\tu32 type_id, i;\n\tint err;\n\n\terr = env_resolve_init(env);\n\tif (err)\n\t\treturn err;\n\n\tenv->phase++;\n\tfor (i = btf->base_btf ? 0 : 1; i < btf->nr_types; i++) {\n\t\ttype_id = btf->start_id + i;\n\t\tt = btf_type_by_id(btf, type_id);\n\n\t\tenv->log_type_id = type_id;\n\t\tif (btf_type_needs_resolve(t) &&\n\t\t    !env_type_is_resolved(env, type_id)) {\n\t\t\terr = btf_resolve(env, t, type_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func_proto(t)) {\n\t\t\terr = btf_func_proto_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (btf_type_is_func(t)) {\n\t\t\terr = btf_func_check(env, t);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_parse_type_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr = &env->btf->hdr;\n\tint err;\n\n\t/* Type section must align to 4 bytes */\n\tif (hdr->type_off & (sizeof(u32) - 1)) {\n\t\tbtf_verifier_log(env, \"Unaligned type_off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!env->btf->base_btf && !hdr->type_len) {\n\t\tbtf_verifier_log(env, \"No type found\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_check_all_types(env);\n}\n\nstatic int btf_parse_str_sec(struct btf_verifier_env *env)\n{\n\tconst struct btf_header *hdr;\n\tstruct btf *btf = env->btf;\n\tconst char *start, *end;\n\n\thdr = &btf->hdr;\n\tstart = btf->nohdr_data + hdr->str_off;\n\tend = start + hdr->str_len;\n\n\tif (end != btf->data + btf->data_size) {\n\t\tbtf_verifier_log(env, \"String section is not at the end\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf->strings = start;\n\n\tif (btf->base_btf && !hdr->str_len)\n\t\treturn 0;\n\tif (!hdr->str_len || hdr->str_len - 1 > BTF_MAX_NAME_OFFSET || end[-1]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\tif (!btf->base_btf && start[0]) {\n\t\tbtf_verifier_log(env, \"Invalid string section\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const size_t btf_sec_info_offset[] = {\n\toffsetof(struct btf_header, type_off),\n\toffsetof(struct btf_header, str_off),\n};\n\nstatic int btf_sec_info_cmp(const void *a, const void *b)\n{\n\tconst struct btf_sec_info *x = a;\n\tconst struct btf_sec_info *y = b;\n\n\treturn (int)(x->off - y->off) ? : (int)(x->len - y->len);\n}\n\nstatic int btf_check_sec_info(struct btf_verifier_env *env,\n\t\t\t      u32 btf_data_size)\n{\n\tstruct btf_sec_info secs[ARRAY_SIZE(btf_sec_info_offset)];\n\tu32 total, expected_total, i;\n\tconst struct btf_header *hdr;\n\tconst struct btf *btf;\n\n\tbtf = env->btf;\n\thdr = &btf->hdr;\n\n\t/* Populate the secs from hdr */\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++)\n\t\tsecs[i] = *(struct btf_sec_info *)((void *)hdr +\n\t\t\t\t\t\t   btf_sec_info_offset[i]);\n\n\tsort(secs, ARRAY_SIZE(btf_sec_info_offset),\n\t     sizeof(struct btf_sec_info), btf_sec_info_cmp, NULL);\n\n\t/* Check for gaps and overlap among sections */\n\ttotal = 0;\n\texpected_total = btf_data_size - hdr->hdr_len;\n\tfor (i = 0; i < ARRAY_SIZE(btf_sec_info_offset); i++) {\n\t\tif (expected_total < secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Invalid section offset\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total < secs[i].off) {\n\t\t\t/* gap */\n\t\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total > secs[i].off) {\n\t\t\tbtf_verifier_log(env, \"Section overlap found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (expected_total - total < secs[i].len) {\n\t\t\tbtf_verifier_log(env,\n\t\t\t\t\t \"Total section length too long\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttotal += secs[i].len;\n\t}\n\n\t/* There is data other than hdr and known sections */\n\tif (expected_total != total) {\n\t\tbtf_verifier_log(env, \"Unsupported section found\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_parse_hdr(struct btf_verifier_env *env)\n{\n\tu32 hdr_len, hdr_copy, btf_data_size;\n\tconst struct btf_header *hdr;\n\tstruct btf *btf;\n\tint err;\n\n\tbtf = env->btf;\n\tbtf_data_size = btf->data_size;\n\n\tif (btf_data_size <\n\t    offsetof(struct btf_header, hdr_len) + sizeof(hdr->hdr_len)) {\n\t\tbtf_verifier_log(env, \"hdr_len not found\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr = btf->data;\n\thdr_len = hdr->hdr_len;\n\tif (btf_data_size < hdr_len) {\n\t\tbtf_verifier_log(env, \"btf_header not found\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure the unsupported header fields are zero */\n\tif (hdr_len > sizeof(btf->hdr)) {\n\t\tu8 *expected_zero = btf->data + sizeof(btf->hdr);\n\t\tu8 *end = btf->data + hdr_len;\n\n\t\tfor (; expected_zero < end; expected_zero++) {\n\t\t\tif (*expected_zero) {\n\t\t\t\tbtf_verifier_log(env, \"Unsupported btf_header\");\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\t\t}\n\t}\n\n\thdr_copy = min_t(u32, hdr_len, sizeof(btf->hdr));\n\tmemcpy(&btf->hdr, btf->data, hdr_copy);\n\n\thdr = &btf->hdr;\n\n\tbtf_verifier_log_hdr(env, btf_data_size);\n\n\tif (hdr->magic != BTF_MAGIC) {\n\t\tbtf_verifier_log(env, \"Invalid magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->version != BTF_VERSION) {\n\t\tbtf_verifier_log(env, \"Unsupported version\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (hdr->flags) {\n\t\tbtf_verifier_log(env, \"Unsupported flags\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (btf_data_size == hdr->hdr_len) {\n\t\tbtf_verifier_log(env, \"No data\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = btf_check_sec_info(env, btf_data_size);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic struct btf *btf_parse(void __user *btf_data, u32 btf_data_size,\n\t\t\t     u32 log_level, char __user *log_ubuf, u32 log_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tu8 *data;\n\tint err;\n\n\tif (btf_data_size > BTF_MAX_SIZE)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tif (log_level || log_ubuf || log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = log_level;\n\t\tlog->ubuf = log_ubuf;\n\t\tlog->len_total = log_size;\n\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tdata = kvmalloc(btf_data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tbtf->data = data;\n\tbtf->data_size = btf_data_size;\n\n\tif (copy_from_user(data, btf_data, btf_data_size)) {\n\t\terr = -EFAULT;\n\t\tgoto errout;\n\t}\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_parse_type_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\tif (log->level && bpf_verifier_log_full(log)) {\n\t\terr = -ENOSPC;\n\t\tgoto errout;\n\t}\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf)\n\t\tbtf_free(btf);\n\treturn ERR_PTR(err);\n}\n\nextern char __weak __start_BTF[];\nextern char __weak __stop_BTF[];\nextern struct btf *btf_vmlinux;\n\n#define BPF_MAP_TYPE(_id, _ops)\n#define BPF_LINK_TYPE(_id, _name)\nstatic union {\n\tstruct bpf_ctx_convert {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\tprog_ctx_type _id##_prog; \\\n\tkern_ctx_type _id##_kern;\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t} *__t;\n\t/* 't' is written once under lock. Read many times. */\n\tconst struct btf_type *t;\n} bpf_ctx_convert;\nenum {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t__ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t__ctx_convert_unused, /* to avoid empty enum in extreme .config */\n};\nstatic u8 bpf_ctx_convert_map[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \\\n\t[_id] = __ctx_convert##_id,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n\t0, /* avoid empty array */\n};\n#undef BPF_MAP_TYPE\n#undef BPF_LINK_TYPE\n\nstatic const struct btf_member *\nbtf_get_prog_ctx_type(struct bpf_verifier_log *log, struct btf *btf,\n\t\t      const struct btf_type *t, enum bpf_prog_type prog_type,\n\t\t      int arg)\n{\n\tconst struct btf_type *conv_struct;\n\tconst struct btf_type *ctx_struct;\n\tconst struct btf_member *ctx_type;\n\tconst char *tname, *ctx_tname;\n\n\tconv_struct = bpf_ctx_convert.t;\n\tif (!conv_struct) {\n\t\tbpf_log(log, \"btf_vmlinux is malformed\\n\");\n\t\treturn NULL;\n\t}\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_struct(t)) {\n\t\t/* Only pointer to struct is supported for now.\n\t\t * That means that BPF_PROG_TYPE_TRACEPOINT with BTF\n\t\t * is not supported yet.\n\t\t * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.\n\t\t */\n\t\tif (log->level & BPF_LOG_LEVEL)\n\t\t\tbpf_log(log, \"arg#%d type is not a struct\\n\", arg);\n\t\treturn NULL;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\tif (!tname) {\n\t\tbpf_log(log, \"arg#%d struct doesn't have a name\\n\", arg);\n\t\treturn NULL;\n\t}\n\t/* prog_type is valid bpf program type. No need for bounds check. */\n\tctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;\n\t/* ctx_struct is a pointer to prog_ctx_type in vmlinux.\n\t * Like 'struct __sk_buff'\n\t */\n\tctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);\n\tif (!ctx_struct)\n\t\t/* should not happen */\n\t\treturn NULL;\n\tctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);\n\tif (!ctx_tname) {\n\t\t/* should not happen */\n\t\tbpf_log(log, \"Please fix kernel include/linux/bpf_types.h\\n\");\n\t\treturn NULL;\n\t}\n\t/* only compare that prog's ctx type name is the same as\n\t * kernel expects. No need to compare field by field.\n\t * It's ok for bpf prog to do:\n\t * struct __sk_buff {};\n\t * int socket_filter_bpf_prog(struct __sk_buff *skb)\n\t * { // no fields of skb are ever used }\n\t */\n\tif (strcmp(ctx_tname, tname))\n\t\treturn NULL;\n\treturn ctx_type;\n}\n\nstatic const struct bpf_map_ops * const btf_vmlinux_map_ops[] = {\n#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n#define BPF_LINK_TYPE(_id, _name)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_LINK_TYPE\n#undef BPF_MAP_TYPE\n};\n\nstatic int btf_vmlinux_map_ids_init(const struct btf *btf,\n\t\t\t\t    struct bpf_verifier_log *log)\n{\n\tconst struct bpf_map_ops *ops;\n\tint i, btf_id;\n\n\tfor (i = 0; i < ARRAY_SIZE(btf_vmlinux_map_ops); ++i) {\n\t\tops = btf_vmlinux_map_ops[i];\n\t\tif (!ops || (!ops->map_btf_name && !ops->map_btf_id))\n\t\t\tcontinue;\n\t\tif (!ops->map_btf_name || !ops->map_btf_id) {\n\t\t\tbpf_log(log, \"map type %d is misconfigured\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbtf_id = btf_find_by_name_kind(btf, ops->map_btf_name,\n\t\t\t\t\t       BTF_KIND_STRUCT);\n\t\tif (btf_id < 0)\n\t\t\treturn btf_id;\n\t\t*ops->map_btf_id = btf_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int btf_translate_to_vmlinux(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf,\n\t\t\t\t     const struct btf_type *t,\n\t\t\t\t     enum bpf_prog_type prog_type,\n\t\t\t\t     int arg)\n{\n\tconst struct btf_member *prog_ctx_type, *kern_ctx_type;\n\n\tprog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type, arg);\n\tif (!prog_ctx_type)\n\t\treturn -ENOENT;\n\tkern_ctx_type = prog_ctx_type + 1;\n\treturn kern_ctx_type->type;\n}\n\nBTF_ID_LIST(bpf_ctx_convert_btf_id)\nBTF_ID(struct, bpf_ctx_convert)\n\nstruct btf *btf_parse_vmlinux(void)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL;\n\tint err;\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->data = __start_BTF;\n\tbtf->data_size = __stop_BTF - __start_BTF;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"vmlinux\");\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\t/* btf_parse_vmlinux() runs under bpf_verifier_lock */\n\tbpf_ctx_convert.t = btf_type_by_id(btf, bpf_ctx_convert_btf_id[0]);\n\n\t/* find bpf map structs for map_ptr access checking */\n\terr = btf_vmlinux_map_ids_init(btf, log);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tbpf_struct_ops_init(btf, log);\n\n\trefcount_set(&btf->refcnt, 1);\n\n\terr = btf_alloc_id(btf);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}\n\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\n\nstatic struct btf *btf_parse_module(const char *module_name, const void *data, unsigned int data_size)\n{\n\tstruct btf_verifier_env *env = NULL;\n\tstruct bpf_verifier_log *log;\n\tstruct btf *btf = NULL, *base_btf;\n\tint err;\n\n\tbase_btf = bpf_get_btf_vmlinux();\n\tif (IS_ERR(base_btf))\n\t\treturn base_btf;\n\tif (!base_btf)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL | __GFP_NOWARN);\n\tif (!env)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlog = &env->log;\n\tlog->level = BPF_LOG_KERNEL;\n\n\tbtf = kzalloc(sizeof(*btf), GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tenv->btf = btf;\n\n\tbtf->base_btf = base_btf;\n\tbtf->start_id = base_btf->nr_types;\n\tbtf->start_str_off = base_btf->hdr.str_len;\n\tbtf->kernel_btf = true;\n\tsnprintf(btf->name, sizeof(btf->name), \"%s\", module_name);\n\n\tbtf->data = kvmalloc(data_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!btf->data) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tmemcpy(btf->data, data, data_size);\n\tbtf->data_size = data_size;\n\n\terr = btf_parse_hdr(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf->nohdr_data = btf->data + btf->hdr.hdr_len;\n\n\terr = btf_parse_str_sec(env);\n\tif (err)\n\t\tgoto errout;\n\n\terr = btf_check_all_metas(env);\n\tif (err)\n\t\tgoto errout;\n\n\tbtf_verifier_env_free(env);\n\trefcount_set(&btf->refcnt, 1);\n\treturn btf;\n\nerrout:\n\tbtf_verifier_env_free(env);\n\tif (btf) {\n\t\tkvfree(btf->data);\n\t\tkvfree(btf->types);\n\t\tkfree(btf);\n\t}\n\treturn ERR_PTR(err);\n}\n\n#endif /* CONFIG_DEBUG_INFO_BTF_MODULES */\n\nstruct btf *bpf_prog_get_target_btf(const struct bpf_prog *prog)\n{\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\n\tif (tgt_prog)\n\t\treturn tgt_prog->aux->btf;\n\telse\n\t\treturn prog->aux->attach_btf;\n}\n\nstatic bool is_string_ptr(struct btf *btf, const struct btf_type *t)\n{\n\t/* t comes in already as a pointer */\n\tt = btf_type_by_id(btf, t->type);\n\n\t/* allow const */\n\tif (BTF_INFO_KIND(t->info) == BTF_KIND_CONST)\n\t\tt = btf_type_by_id(btf, t->type);\n\n\t/* char, signed char, unsigned char */\n\treturn btf_type_is_int(t) && t->size == 1;\n}\n\nbool btf_ctx_access(int off, int size, enum bpf_access_type type,\n\t\t    const struct bpf_prog *prog,\n\t\t    struct bpf_insn_access_aux *info)\n{\n\tconst struct btf_type *t = prog->aux->attach_func_proto;\n\tstruct bpf_prog *tgt_prog = prog->aux->dst_prog;\n\tstruct btf *btf = bpf_prog_get_target_btf(prog);\n\tconst char *tname = prog->aux->attach_func_name;\n\tstruct bpf_verifier_log *log = info->log;\n\tconst struct btf_param *args;\n\tu32 nr_args, arg;\n\tint i, ret;\n\n\tif (off % 8) {\n\t\tbpf_log(log, \"func '%s' offset %d is not multiple of 8\\n\",\n\t\t\ttname, off);\n\t\treturn false;\n\t}\n\targ = off / 8;\n\targs = (const struct btf_param *)(t + 1);\n\t/* if (t == NULL) Fall back to default BPF prog with 5 u64 arguments */\n\tnr_args = t ? btf_type_vlen(t) : 5;\n\tif (prog->aux->attach_btf_trace) {\n\t\t/* skip first 'void *__data' argument in btf_trace_##name typedef */\n\t\targs++;\n\t\tnr_args--;\n\t}\n\n\tif (arg > nr_args) {\n\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",\n\t\t\ttname, arg + 1);\n\t\treturn false;\n\t}\n\n\tif (arg == nr_args) {\n\t\tswitch (prog->expected_attach_type) {\n\t\tcase BPF_LSM_MAC:\n\t\tcase BPF_TRACE_FEXIT:\n\t\t\t/* When LSM programs are attached to void LSM hooks\n\t\t\t * they use FEXIT trampolines and when attached to\n\t\t\t * int LSM hooks, they use MODIFY_RETURN trampolines.\n\t\t\t *\n\t\t\t * While the LSM programs are BPF_MODIFY_RETURN-like\n\t\t\t * the check:\n\t\t\t *\n\t\t\t *\tif (ret_type != 'int')\n\t\t\t *\t\treturn -EINVAL;\n\t\t\t *\n\t\t\t * is _not_ done here. This is still safe as LSM hooks\n\t\t\t * have only void and int return types.\n\t\t\t */\n\t\t\tif (!t)\n\t\t\t\treturn true;\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\t\tbreak;\n\t\tcase BPF_MODIFY_RETURN:\n\t\t\t/* For now the BPF_MODIFY_RETURN can only be attached to\n\t\t\t * functions that return an int.\n\t\t\t */\n\t\t\tif (!t)\n\t\t\t\treturn false;\n\n\t\t\tt = btf_type_skip_modifiers(btf, t->type, NULL);\n\t\t\tif (!btf_type_is_small_int(t)) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"ret type %s not allowed for fmod_ret\\n\",\n\t\t\t\t\tbtf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_log(log, \"func '%s' doesn't have %d-th argument\\n\",\n\t\t\t\ttname, arg + 1);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (!t)\n\t\t\t/* Default prog with 5 args */\n\t\t\treturn true;\n\t\tt = btf_type_by_id(btf, args[arg].type);\n\t}\n\n\t/* skip modifiers */\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (btf_type_is_small_int(t) || btf_type_is_enum(t))\n\t\t/* accessing a scalar */\n\t\treturn true;\n\tif (!btf_type_is_ptr(t)) {\n\t\tbpf_log(log,\n\t\t\t\"func '%s' arg%d '%s' has type %s. Only pointer access is allowed\\n\",\n\t\t\ttname, arg,\n\t\t\t__btf_name_by_offset(btf, t->name_off),\n\t\t\tbtf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn false;\n\t}\n\n\t/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */\n\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {\n\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];\n\n\t\tif (ctx_arg_info->offset == off &&\n\t\t    (ctx_arg_info->reg_type == PTR_TO_RDONLY_BUF_OR_NULL ||\n\t\t     ctx_arg_info->reg_type == PTR_TO_RDWR_BUF_OR_NULL)) {\n\t\t\tinfo->reg_type = ctx_arg_info->reg_type;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (t->type == 0)\n\t\t/* This is a pointer to void.\n\t\t * It is the same as scalar from the verifier safety pov.\n\t\t * No further pointer walking is allowed.\n\t\t */\n\t\treturn true;\n\n\tif (is_string_ptr(btf, t))\n\t\treturn true;\n\n\t/* this is a pointer to another type */\n\tfor (i = 0; i < prog->aux->ctx_arg_info_size; i++) {\n\t\tconst struct bpf_ctx_arg_aux *ctx_arg_info = &prog->aux->ctx_arg_info[i];\n\n\t\tif (ctx_arg_info->offset == off) {\n\t\t\tinfo->reg_type = ctx_arg_info->reg_type;\n\t\t\tinfo->btf = btf_vmlinux;\n\t\t\tinfo->btf_id = ctx_arg_info->btf_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinfo->reg_type = PTR_TO_BTF_ID;\n\tif (tgt_prog) {\n\t\tenum bpf_prog_type tgt_type;\n\n\t\tif (tgt_prog->type == BPF_PROG_TYPE_EXT)\n\t\t\ttgt_type = tgt_prog->aux->saved_dst_prog_type;\n\t\telse\n\t\t\ttgt_type = tgt_prog->type;\n\n\t\tret = btf_translate_to_vmlinux(log, btf, t, tgt_type, arg);\n\t\tif (ret > 0) {\n\t\t\tinfo->btf = btf_vmlinux;\n\t\t\tinfo->btf_id = ret;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tinfo->btf = btf;\n\tinfo->btf_id = t->type;\n\tt = btf_type_by_id(btf, t->type);\n\t/* skip modifiers */\n\twhile (btf_type_is_modifier(t)) {\n\t\tinfo->btf_id = t->type;\n\t\tt = btf_type_by_id(btf, t->type);\n\t}\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log,\n\t\t\t\"func '%s' arg%d type %s is not a struct\\n\",\n\t\t\ttname, arg, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn false;\n\t}\n\tbpf_log(log, \"func '%s' arg%d has btf_id %d type %s '%s'\\n\",\n\t\ttname, arg, info->btf_id, btf_kind_str[BTF_INFO_KIND(t->info)],\n\t\t__btf_name_by_offset(btf, t->name_off));\n\treturn true;\n}\n\nenum bpf_struct_walk_result {\n\t/* < 0 error */\n\tWALK_SCALAR = 0,\n\tWALK_PTR,\n\tWALK_STRUCT,\n};\n\nstatic int btf_struct_walk(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t\t   const struct btf_type *t, int off, int size,\n\t\t\t   u32 *next_btf_id)\n{\n\tu32 i, moff, mtrue_end, msize = 0, total_nelems = 0;\n\tconst struct btf_type *mtype, *elem_type = NULL;\n\tconst struct btf_member *member;\n\tconst char *tname, *mname;\n\tu32 vlen, elem_id, mid;\n\nagain:\n\ttname = __btf_name_by_offset(btf, t->name_off);\n\tif (!btf_type_is_struct(t)) {\n\t\tbpf_log(log, \"Type '%s' is not a struct\\n\", tname);\n\t\treturn -EINVAL;\n\t}\n\n\tvlen = btf_type_vlen(t);\n\tif (off + size > t->size) {\n\t\t/* If the last element is a variable size array, we may\n\t\t * need to relax the rule.\n\t\t */\n\t\tstruct btf_array *array_elem;\n\n\t\tif (vlen == 0)\n\t\t\tgoto error;\n\n\t\tmember = btf_type_member(t) + vlen - 1;\n\t\tmtype = btf_type_skip_modifiers(btf, member->type,\n\t\t\t\t\t\tNULL);\n\t\tif (!btf_type_is_array(mtype))\n\t\t\tgoto error;\n\n\t\tarray_elem = (struct btf_array *)(mtype + 1);\n\t\tif (array_elem->nelems != 0)\n\t\t\tgoto error;\n\n\t\tmoff = btf_member_bit_offset(t, member) / 8;\n\t\tif (off < moff)\n\t\t\tgoto error;\n\n\t\t/* Only allow structure for now, can be relaxed for\n\t\t * other types later.\n\t\t */\n\t\tt = btf_type_skip_modifiers(btf, array_elem->type,\n\t\t\t\t\t    NULL);\n\t\tif (!btf_type_is_struct(t))\n\t\t\tgoto error;\n\n\t\toff = (off - moff) % t->size;\n\t\tgoto again;\n\nerror:\n\t\tbpf_log(log, \"access beyond struct %s at off %u size %u\\n\",\n\t\t\ttname, off, size);\n\t\treturn -EACCES;\n\t}\n\n\tfor_each_member(i, t, member) {\n\t\t/* offset of the field in bytes */\n\t\tmoff = btf_member_bit_offset(t, member) / 8;\n\t\tif (off + size <= moff)\n\t\t\t/* won't find anything, field is already too far */\n\t\t\tbreak;\n\n\t\tif (btf_member_bitfield_size(t, member)) {\n\t\t\tu32 end_bit = btf_member_bit_offset(t, member) +\n\t\t\t\tbtf_member_bitfield_size(t, member);\n\n\t\t\t/* off <= moff instead of off == moff because clang\n\t\t\t * does not generate a BTF member for anonymous\n\t\t\t * bitfield like the \":16\" here:\n\t\t\t * struct {\n\t\t\t *\tint :16;\n\t\t\t *\tint x:8;\n\t\t\t * };\n\t\t\t */\n\t\t\tif (off <= moff &&\n\t\t\t    BITS_ROUNDUP_BYTES(end_bit) <= off + size)\n\t\t\t\treturn WALK_SCALAR;\n\n\t\t\t/* off may be accessing a following member\n\t\t\t *\n\t\t\t * or\n\t\t\t *\n\t\t\t * Doing partial access at either end of this\n\t\t\t * bitfield.  Continue on this case also to\n\t\t\t * treat it as not accessing this bitfield\n\t\t\t * and eventually error out as field not\n\t\t\t * found to keep it simple.\n\t\t\t * It could be relaxed if there was a legit\n\t\t\t * partial access case later.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* In case of \"off\" is pointing to holes of a struct */\n\t\tif (off < moff)\n\t\t\tbreak;\n\n\t\t/* type of the field */\n\t\tmid = member->type;\n\t\tmtype = btf_type_by_id(btf, member->type);\n\t\tmname = __btf_name_by_offset(btf, member->name_off);\n\n\t\tmtype = __btf_resolve_size(btf, mtype, &msize,\n\t\t\t\t\t   &elem_type, &elem_id, &total_nelems,\n\t\t\t\t\t   &mid);\n\t\tif (IS_ERR(mtype)) {\n\t\t\tbpf_log(log, \"field %s doesn't have size\\n\", mname);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tmtrue_end = moff + msize;\n\t\tif (off >= mtrue_end)\n\t\t\t/* no overlap with member, keep iterating */\n\t\t\tcontinue;\n\n\t\tif (btf_type_is_array(mtype)) {\n\t\t\tu32 elem_idx;\n\n\t\t\t/* __btf_resolve_size() above helps to\n\t\t\t * linearize a multi-dimensional array.\n\t\t\t *\n\t\t\t * The logic here is treating an array\n\t\t\t * in a struct as the following way:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array[2][2];\n\t\t\t * };\n\t\t\t *\n\t\t\t * looks like:\n\t\t\t *\n\t\t\t * struct outer {\n\t\t\t *\tstruct inner array_elem0;\n\t\t\t *\tstruct inner array_elem1;\n\t\t\t *\tstruct inner array_elem2;\n\t\t\t *\tstruct inner array_elem3;\n\t\t\t * };\n\t\t\t *\n\t\t\t * When accessing outer->array[1][0], it moves\n\t\t\t * moff to \"array_elem2\", set mtype to\n\t\t\t * \"struct inner\", and msize also becomes\n\t\t\t * sizeof(struct inner).  Then most of the\n\t\t\t * remaining logic will fall through without\n\t\t\t * caring the current member is an array or\n\t\t\t * not.\n\t\t\t *\n\t\t\t * Unlike mtype/msize/moff, mtrue_end does not\n\t\t\t * change.  The naming difference (\"_true\") tells\n\t\t\t * that it is not always corresponding to\n\t\t\t * the current mtype/msize/moff.\n\t\t\t * It is the true end of the current\n\t\t\t * member (i.e. array in this case).  That\n\t\t\t * will allow an int array to be accessed like\n\t\t\t * a scratch space,\n\t\t\t * i.e. allow access beyond the size of\n\t\t\t *      the array's element as long as it is\n\t\t\t *      within the mtrue_end boundary.\n\t\t\t */\n\n\t\t\t/* skip empty array */\n\t\t\tif (moff == mtrue_end)\n\t\t\t\tcontinue;\n\n\t\t\tmsize /= total_nelems;\n\t\t\telem_idx = (off - moff) / msize;\n\t\t\tmoff += elem_idx * msize;\n\t\t\tmtype = elem_type;\n\t\t\tmid = elem_id;\n\t\t}\n\n\t\t/* the 'off' we're looking for is either equal to start\n\t\t * of this field or inside of this struct\n\t\t */\n\t\tif (btf_type_is_struct(mtype)) {\n\t\t\t/* our field must be inside that union or struct */\n\t\t\tt = mtype;\n\n\t\t\t/* return if the offset matches the member offset */\n\t\t\tif (off == moff) {\n\t\t\t\t*next_btf_id = mid;\n\t\t\t\treturn WALK_STRUCT;\n\t\t\t}\n\n\t\t\t/* adjust offset we're looking for */\n\t\t\toff -= moff;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (btf_type_is_ptr(mtype)) {\n\t\t\tconst struct btf_type *stype;\n\t\t\tu32 id;\n\n\t\t\tif (msize != size || off != moff) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"cannot access ptr member %s with moff %u in struct %s with off %u size %u\\n\",\n\t\t\t\t\tmname, moff, tname, off, size);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tstype = btf_type_skip_modifiers(btf, mtype->type, &id);\n\t\t\tif (btf_type_is_struct(stype)) {\n\t\t\t\t*next_btf_id = id;\n\t\t\t\treturn WALK_PTR;\n\t\t\t}\n\t\t}\n\n\t\t/* Allow more flexible access within an int as long as\n\t\t * it is within mtrue_end.\n\t\t * Since mtrue_end could be the end of an array,\n\t\t * that also allows using an array of int as a scratch\n\t\t * space. e.g. skb->cb[].\n\t\t */\n\t\tif (off + size > mtrue_end) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"access beyond the end of member %s (mend:%u) in struct %s with off %u size %u\\n\",\n\t\t\t\tmname, mtrue_end, tname, off, size);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\treturn WALK_SCALAR;\n\t}\n\tbpf_log(log, \"struct %s doesn't have field at offset %d\\n\", tname, off);\n\treturn -EINVAL;\n}\n\nint btf_struct_access(struct bpf_verifier_log *log, const struct btf *btf,\n\t\t      const struct btf_type *t, int off, int size,\n\t\t      enum bpf_access_type atype __maybe_unused,\n\t\t      u32 *next_btf_id)\n{\n\tint err;\n\tu32 id;\n\n\tdo {\n\t\terr = btf_struct_walk(log, btf, t, off, size, &id);\n\n\t\tswitch (err) {\n\t\tcase WALK_PTR:\n\t\t\t/* If we found the pointer or scalar on t+off,\n\t\t\t * we're done.\n\t\t\t */\n\t\t\t*next_btf_id = id;\n\t\t\treturn PTR_TO_BTF_ID;\n\t\tcase WALK_SCALAR:\n\t\t\treturn SCALAR_VALUE;\n\t\tcase WALK_STRUCT:\n\t\t\t/* We found nested struct, so continue the search\n\t\t\t * by diving in it. At this point the offset is\n\t\t\t * aligned with the new type, so set it to 0.\n\t\t\t */\n\t\t\tt = btf_type_by_id(btf, id);\n\t\t\toff = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* It's either error or unknown return value..\n\t\t\t * scream and leave.\n\t\t\t */\n\t\t\tif (WARN_ONCE(err > 0, \"unknown btf_struct_walk return value\"))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn err;\n\t\t}\n\t} while (t);\n\n\treturn -EINVAL;\n}\n\n/* Check that two BTF types, each specified as an BTF object + id, are exactly\n * the same. Trivial ID check is not enough due to module BTFs, because we can\n * end up with two different module BTFs, but IDs point to the common type in\n * vmlinux BTF.\n */\nstatic bool btf_types_are_same(const struct btf *btf1, u32 id1,\n\t\t\t       const struct btf *btf2, u32 id2)\n{\n\tif (id1 != id2)\n\t\treturn false;\n\tif (btf1 == btf2)\n\t\treturn true;\n\treturn btf_type_by_id(btf1, id1) == btf_type_by_id(btf2, id2);\n}\n\nbool btf_struct_ids_match(struct bpf_verifier_log *log,\n\t\t\t  const struct btf *btf, u32 id, int off,\n\t\t\t  const struct btf *need_btf, u32 need_type_id)\n{\n\tconst struct btf_type *type;\n\tint err;\n\n\t/* Are we already done? */\n\tif (off == 0 && btf_types_are_same(btf, id, need_btf, need_type_id))\n\t\treturn true;\n\nagain:\n\ttype = btf_type_by_id(btf, id);\n\tif (!type)\n\t\treturn false;\n\terr = btf_struct_walk(log, btf, type, off, 1, &id);\n\tif (err != WALK_STRUCT)\n\t\treturn false;\n\n\t/* We found nested struct object. If it matches\n\t * the requested ID, we're done. Otherwise let's\n\t * continue the search with offset 0 in the new\n\t * type.\n\t */\n\tif (!btf_types_are_same(btf, id, need_btf, need_type_id)) {\n\t\toff = 0;\n\t\tgoto again;\n\t}\n\n\treturn true;\n}\n\nstatic int __get_type_size(struct btf *btf, u32 btf_id,\n\t\t\t   const struct btf_type **bad_type)\n{\n\tconst struct btf_type *t;\n\n\tif (!btf_id)\n\t\t/* void */\n\t\treturn 0;\n\tt = btf_type_by_id(btf, btf_id);\n\twhile (t && btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!t) {\n\t\t*bad_type = btf_type_by_id(btf, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_type_is_ptr(t))\n\t\t/* kernel size of pointer. Not BPF's size of pointer*/\n\t\treturn sizeof(void *);\n\tif (btf_type_is_int(t) || btf_type_is_enum(t))\n\t\treturn t->size;\n\t*bad_type = t;\n\treturn -EINVAL;\n}\n\nint btf_distill_func_proto(struct bpf_verifier_log *log,\n\t\t\t   struct btf *btf,\n\t\t\t   const struct btf_type *func,\n\t\t\t   const char *tname,\n\t\t\t   struct btf_func_model *m)\n{\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs;\n\tint ret;\n\n\tif (!func) {\n\t\t/* BTF function prototype doesn't match the verifier types.\n\t\t * Fall back to 5 u64 args.\n\t\t */\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tm->arg_size[i] = 8;\n\t\tm->ret_size = 8;\n\t\tm->nr_args = 5;\n\t\treturn 0;\n\t}\n\targs = (const struct btf_param *)(func + 1);\n\tnargs = btf_type_vlen(func);\n\tif (nargs >= MAX_BPF_FUNC_ARGS) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s has %d arguments. Too many.\\n\",\n\t\t\ttname, nargs);\n\t\treturn -EINVAL;\n\t}\n\tret = __get_type_size(btf, func->type, &t);\n\tif (ret < 0) {\n\t\tbpf_log(log,\n\t\t\t\"The function %s return type %s is unsupported.\\n\",\n\t\t\ttname, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\treturn -EINVAL;\n\t}\n\tm->ret_size = ret;\n\n\tfor (i = 0; i < nargs; i++) {\n\t\tret = __get_type_size(btf, args[i].type, &t);\n\t\tif (ret < 0) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"The function %s arg%d type %s is unsupported.\\n\",\n\t\t\t\ttname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tm->arg_size[i] = ret;\n\t}\n\tm->nr_args = nargs;\n\treturn 0;\n}\n\n/* Compare BTFs of two functions assuming only scalars and pointers to context.\n * t1 points to BTF_KIND_FUNC in btf1\n * t2 points to BTF_KIND_FUNC in btf2\n * Returns:\n * EINVAL - function prototype mismatch\n * EFAULT - verifier bug\n * 0 - 99% match. The last 1% is validated by the verifier.\n */\nstatic int btf_check_func_type_match(struct bpf_verifier_log *log,\n\t\t\t\t     struct btf *btf1, const struct btf_type *t1,\n\t\t\t\t     struct btf *btf2, const struct btf_type *t2)\n{\n\tconst struct btf_param *args1, *args2;\n\tconst char *fn1, *fn2, *s1, *s2;\n\tu32 nargs1, nargs2, i;\n\n\tfn1 = btf_name_by_offset(btf1, t1->name_off);\n\tfn2 = btf_name_by_offset(btf2, t2->name_off);\n\n\tif (btf_func_linkage(t1) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn1);\n\t\treturn -EINVAL;\n\t}\n\tif (btf_func_linkage(t2) != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"%s() is not a global function\\n\", fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_by_id(btf1, t1->type);\n\tif (!t1 || !btf_type_is_func_proto(t1))\n\t\treturn -EFAULT;\n\tt2 = btf_type_by_id(btf2, t2->type);\n\tif (!t2 || !btf_type_is_func_proto(t2))\n\t\treturn -EFAULT;\n\n\targs1 = (const struct btf_param *)(t1 + 1);\n\tnargs1 = btf_type_vlen(t1);\n\targs2 = (const struct btf_param *)(t2 + 1);\n\tnargs2 = btf_type_vlen(t2);\n\n\tif (nargs1 != nargs2) {\n\t\tbpf_log(log, \"%s() has %d args while %s() has %d args\\n\",\n\t\t\tfn1, nargs1, fn2, nargs2);\n\t\treturn -EINVAL;\n\t}\n\n\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\tif (t1->info != t2->info) {\n\t\tbpf_log(log,\n\t\t\t\"Return type %s of %s() doesn't match type %s of %s()\\n\",\n\t\t\tbtf_type_str(t1), fn1,\n\t\t\tbtf_type_str(t2), fn2);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nargs1; i++) {\n\t\tt1 = btf_type_skip_modifiers(btf1, args1[i].type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, args2[i].type, NULL);\n\n\t\tif (t1->info != t2->info) {\n\t\t\tbpf_log(log, \"arg%d in %s() is %s while %s() has %s\\n\",\n\t\t\t\ti, fn1, btf_type_str(t1),\n\t\t\t\tfn2, btf_type_str(t2));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (btf_type_has_size(t1) && t1->size != t2->size) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has size %d while %s() has %d\\n\",\n\t\t\t\ti, fn1, t1->size,\n\t\t\t\tfn2, t2->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* global functions are validated with scalars and pointers\n\t\t * to context only. And only global functions can be replaced.\n\t\t * Hence type check only those types.\n\t\t */\n\t\tif (btf_type_is_int(t1) || btf_type_is_enum(t1))\n\t\t\tcontinue;\n\t\tif (!btf_type_is_ptr(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() has unrecognized type\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tt1 = btf_type_skip_modifiers(btf1, t1->type, NULL);\n\t\tt2 = btf_type_skip_modifiers(btf2, t2->type, NULL);\n\t\tif (!btf_type_is_struct(t1)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_struct(t2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d in %s() is not a pointer to context\\n\",\n\t\t\t\ti, fn2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* This is an optional check to make program writing easier.\n\t\t * Compare names of structs and report an error to the user.\n\t\t * btf_prepare_func_args() already checked that t2 struct\n\t\t * is a context type. btf_prepare_func_args() will check\n\t\t * later that t1 struct is a context type as well.\n\t\t */\n\t\ts1 = btf_name_by_offset(btf1, t1->name_off);\n\t\ts2 = btf_name_by_offset(btf2, t2->name_off);\n\t\tif (strcmp(s1, s2)) {\n\t\t\tbpf_log(log,\n\t\t\t\t\"arg%d %s(struct %s *) doesn't match %s(struct %s *)\\n\",\n\t\t\t\ti, fn1, s1, fn2, s2);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* Compare BTFs of given program with BTF of target program */\nint btf_check_type_match(struct bpf_verifier_log *log, const struct bpf_prog *prog,\n\t\t\t struct btf *btf2, const struct btf_type *t2)\n{\n\tstruct btf *btf1 = prog->aux->btf;\n\tconst struct btf_type *t1;\n\tu32 btf_id = 0;\n\n\tif (!prog->aux->func_info) {\n\t\tbpf_log(log, \"Program extension requires BTF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbtf_id = prog->aux->func_info[0].type_id;\n\tif (!btf_id)\n\t\treturn -EFAULT;\n\n\tt1 = btf_type_by_id(btf1, btf_id);\n\tif (!t1 || !btf_type_is_func(t1))\n\t\treturn -EFAULT;\n\n\treturn btf_check_func_type_match(log, btf1, t1, btf2, t2);\n}\n\n/* Compare BTF of a function with given bpf_reg_state.\n * Returns:\n * EFAULT - there is a verifier bug. Abort verification.\n * EINVAL - there is a type mismatch or BTF is not available.\n * 0 - BTF matches with what bpf_reg_state expects.\n * Only PTR_TO_CTX and SCALAR_VALUE states are recognized.\n */\nint btf_check_func_arg_match(struct bpf_verifier_env *env, int subprog,\n\t\t\t     struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct bpf_prog *prog = env->prog;\n\tstruct btf *btf = prog->aux->btf;\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs, btf_id;\n\tconst char *tname;\n\n\tif (!prog->aux->func_info)\n\t\treturn -EINVAL;\n\n\tbtf_id = prog->aux->func_info[subprog].type_id;\n\tif (!btf_id)\n\t\treturn -EFAULT;\n\n\tif (prog->aux->func_info_aux[subprog].unreliable)\n\t\treturn -EINVAL;\n\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info\n\t\t */\n\t\tbpf_log(log, \"BTF of func#%d doesn't point to KIND_FUNC\\n\",\n\t\t\tsubprog);\n\t\treturn -EFAULT;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > 5) {\n\t\tbpf_log(log, \"Function %s has %d > 5 args\\n\", tname, nargs);\n\t\tgoto out;\n\t}\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tt = btf_type_by_id(btf, args[i].type);\n\t\twhile (btf_type_is_modifier(t))\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (btf_type_is_int(t) || btf_type_is_enum(t)) {\n\t\t\tif (reg[i + 1].type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", i + 1);\n\t\t\tgoto out;\n\t\t}\n\t\tif (btf_type_is_ptr(t)) {\n\t\t\tif (reg[i + 1].type == SCALAR_VALUE) {\n\t\t\t\tbpf_log(log, \"R%d is not a pointer\\n\", i + 1);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (btf_get_prog_ctx_type(log, btf, t, prog->type, i)) {\n\t\t\t\tif (reg[i + 1].type != PTR_TO_CTX) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\t\ti, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (check_ctx_reg(env, &reg[i + 1], i + 1))\n\t\t\t\t\tgoto out;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\ti, btf_kind_str[BTF_INFO_KIND(t->info)]);\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\t/* Compiler optimizations can remove arguments from static functions\n\t * or mismatched type can be passed into a global function.\n\t * In such cases mark the function as unreliable from BTF point of view.\n\t */\n\tprog->aux->func_info_aux[subprog].unreliable = true;\n\treturn -EINVAL;\n}\n\n/* Convert BTF of a function into bpf_reg_state if possible\n * Returns:\n * EFAULT - there is a verifier bug. Abort verification.\n * EINVAL - cannot convert BTF.\n * 0 - Successfully converted BTF into bpf_reg_state\n * (either PTR_TO_CTX or SCALAR_VALUE).\n */\nint btf_prepare_func_args(struct bpf_verifier_env *env, int subprog,\n\t\t\t  struct bpf_reg_state *reg)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tstruct bpf_prog *prog = env->prog;\n\tenum bpf_prog_type prog_type = prog->type;\n\tstruct btf *btf = prog->aux->btf;\n\tconst struct btf_param *args;\n\tconst struct btf_type *t;\n\tu32 i, nargs, btf_id;\n\tconst char *tname;\n\n\tif (!prog->aux->func_info ||\n\t    prog->aux->func_info_aux[subprog].linkage != BTF_FUNC_GLOBAL) {\n\t\tbpf_log(log, \"Verifier bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tbtf_id = prog->aux->func_info[subprog].type_id;\n\tif (!btf_id) {\n\t\tbpf_log(log, \"Global functions need valid BTF\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tt = btf_type_by_id(btf, btf_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info\n\t\t */\n\t\tbpf_log(log, \"BTF of func#%d doesn't point to KIND_FUNC\\n\",\n\t\t\tsubprog);\n\t\treturn -EFAULT;\n\t}\n\ttname = btf_name_by_offset(btf, t->name_off);\n\n\tif (log->level & BPF_LOG_LEVEL)\n\t\tbpf_log(log, \"Validating %s() func#%d...\\n\",\n\t\t\ttname, subprog);\n\n\tif (prog->aux->func_info_aux[subprog].unreliable) {\n\t\tbpf_log(log, \"Verifier bug in function %s()\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\tif (prog_type == BPF_PROG_TYPE_EXT)\n\t\tprog_type = prog->aux->dst_prog->type;\n\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid type of function %s()\\n\", tname);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > 5) {\n\t\tbpf_log(log, \"Global function %s() with %d > 5 args. Buggy compiler.\\n\",\n\t\t\ttname, nargs);\n\t\treturn -EINVAL;\n\t}\n\t/* check that function returns int */\n\tt = btf_type_by_id(btf, t->type);\n\twhile (btf_type_is_modifier(t))\n\t\tt = btf_type_by_id(btf, t->type);\n\tif (!btf_type_is_int(t) && !btf_type_is_enum(t)) {\n\t\tbpf_log(log,\n\t\t\t\"Global function %s() doesn't return scalar. Only those are supported.\\n\",\n\t\t\ttname);\n\t\treturn -EINVAL;\n\t}\n\t/* Convert BTF function arguments into verifier types.\n\t * Only PTR_TO_CTX and SCALAR are supported atm.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tt = btf_type_by_id(btf, args[i].type);\n\t\twhile (btf_type_is_modifier(t))\n\t\t\tt = btf_type_by_id(btf, t->type);\n\t\tif (btf_type_is_int(t) || btf_type_is_enum(t)) {\n\t\t\treg[i + 1].type = SCALAR_VALUE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (btf_type_is_ptr(t) &&\n\t\t    btf_get_prog_ctx_type(log, btf, t, prog_type, i)) {\n\t\t\treg[i + 1].type = PTR_TO_CTX;\n\t\t\tcontinue;\n\t\t}\n\t\tbpf_log(log, \"Arg#%d type %s in %s() is not supported yet.\\n\",\n\t\t\ti, btf_kind_str[BTF_INFO_KIND(t->info)], tname);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void btf_type_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t  struct btf_show *show)\n{\n\tconst struct btf_type *t = btf_type_by_id(btf, type_id);\n\n\tshow->btf = btf;\n\tmemset(&show->state, 0, sizeof(show->state));\n\tmemset(&show->obj, 0, sizeof(show->obj));\n\n\tbtf_type_ops(t)->show(btf, t, type_id, obj, 0, show);\n}\n\nstatic void btf_seq_show(struct btf_show *show, const char *fmt,\n\t\t\t va_list args)\n{\n\tseq_vprintf((struct seq_file *)show->target, fmt, args);\n}\n\nint btf_type_seq_show_flags(const struct btf *btf, u32 type_id,\n\t\t\t    void *obj, struct seq_file *m, u64 flags)\n{\n\tstruct btf_show sseq;\n\n\tsseq.target = m;\n\tsseq.showfn = btf_seq_show;\n\tsseq.flags = flags;\n\n\tbtf_type_show(btf, type_id, obj, &sseq);\n\n\treturn sseq.state.status;\n}\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}\n\nstruct btf_show_snprintf {\n\tstruct btf_show show;\n\tint len_left;\t\t/* space left in string */\n\tint len;\t\t/* length we would have written */\n};\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}\n\nint btf_type_snprintf_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t\t   char *buf, int len, u64 flags)\n{\n\tstruct btf_show_snprintf ssnprintf;\n\n\tssnprintf.show.target = buf;\n\tssnprintf.show.flags = flags;\n\tssnprintf.show.showfn = btf_snprintf_show;\n\tssnprintf.len_left = len;\n\tssnprintf.len = 0;\n\n\tbtf_type_show(btf, type_id, obj, (struct btf_show *)&ssnprintf);\n\n\t/* If we encontered an error, return it. */\n\tif (ssnprintf.show.state.status)\n\t\treturn ssnprintf.show.state.status;\n\n\t/* Otherwise return length we would have written */\n\treturn ssnprintf.len;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void bpf_btf_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct btf *btf = filp->private_data;\n\n\tseq_printf(m, \"btf_id:\\t%u\\n\", btf->id);\n}\n#endif\n\nstatic int btf_release(struct inode *inode, struct file *filp)\n{\n\tbtf_put(filp->private_data);\n\treturn 0;\n}\n\nconst struct file_operations btf_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_btf_show_fdinfo,\n#endif\n\t.release\t= btf_release,\n};\n\nstatic int __btf_new_fd(struct btf *btf)\n{\n\treturn anon_inode_getfd(\"btf\", &btf_fops, btf, O_RDONLY | O_CLOEXEC);\n}\n\nint btf_new_fd(const union bpf_attr *attr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(u64_to_user_ptr(attr->btf),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}\n\nstruct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}\n\nint btf_get_info_by_fd(const struct btf *btf,\n\t\t       const union bpf_attr *attr,\n\t\t       union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo;\n\tstruct bpf_btf_info info;\n\tu32 info_copy, btf_copy;\n\tvoid __user *ubtf;\n\tchar __user *uname;\n\tu32 uinfo_len, uname_len, name_len;\n\tint ret = 0;\n\n\tuinfo = u64_to_user_ptr(attr->info.info);\n\tuinfo_len = attr->info.info_len;\n\n\tinfo_copy = min_t(u32, uinfo_len, sizeof(info));\n\tmemset(&info, 0, sizeof(info));\n\tif (copy_from_user(&info, uinfo, info_copy))\n\t\treturn -EFAULT;\n\n\tinfo.id = btf->id;\n\tubtf = u64_to_user_ptr(info.btf);\n\tbtf_copy = min_t(u32, btf->data_size, info.btf_size);\n\tif (copy_to_user(ubtf, btf->data, btf_copy))\n\t\treturn -EFAULT;\n\tinfo.btf_size = btf->data_size;\n\n\tinfo.kernel_btf = btf->kernel_btf;\n\n\tuname = u64_to_user_ptr(info.name);\n\tuname_len = info.name_len;\n\tif (!uname ^ !uname_len)\n\t\treturn -EINVAL;\n\n\tname_len = strlen(btf->name);\n\tinfo.name_len = name_len;\n\n\tif (uname) {\n\t\tif (uname_len >= name_len + 1) {\n\t\t\tif (copy_to_user(uname, btf->name, name_len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (copy_to_user(uname, btf->name, uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, uname + uname_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\t/* let user-space know about too short buffer */\n\t\t\tret = -ENOSPC;\n\t\t}\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_copy) ||\n\t    put_user(info_copy, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nint btf_get_fd_by_id(u32 id)\n{\n\tstruct btf *btf;\n\tint fd;\n\n\trcu_read_lock();\n\tbtf = idr_find(&btf_idr, id);\n\tif (!btf || !refcount_inc_not_zero(&btf->refcnt))\n\t\tbtf = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tfd = __btf_new_fd(btf);\n\tif (fd < 0)\n\t\tbtf_put(btf);\n\n\treturn fd;\n}\n\nu32 btf_obj_id(const struct btf *btf)\n{\n\treturn btf->id;\n}\n\nbool btf_is_kernel(const struct btf *btf)\n{\n\treturn btf->kernel_btf;\n}\n\nstatic int btf_id_cmp_func(const void *a, const void *b)\n{\n\tconst int *pa = a, *pb = b;\n\n\treturn *pa - *pb;\n}\n\nbool btf_id_set_contains(const struct btf_id_set *set, u32 id)\n{\n\treturn bsearch(&id, set->ids, set->cnt, sizeof(u32), btf_id_cmp_func) != NULL;\n}\n\n#ifdef CONFIG_DEBUG_INFO_BTF_MODULES\nstruct btf_module {\n\tstruct list_head list;\n\tstruct module *module;\n\tstruct btf *btf;\n\tstruct bin_attribute *sysfs_attr;\n};\n\nstatic LIST_HEAD(btf_modules);\nstatic DEFINE_MUTEX(btf_module_mutex);\n\nstatic ssize_t\nbtf_module_read(struct file *file, struct kobject *kobj,\n\t\tstruct bin_attribute *bin_attr,\n\t\tchar *buf, loff_t off, size_t len)\n{\n\tconst struct btf *btf = bin_attr->private;\n\n\tmemcpy(buf, btf->data + off, len);\n\treturn len;\n}\n\nstatic int btf_module_notify(struct notifier_block *nb, unsigned long op,\n\t\t\t     void *module)\n{\n\tstruct btf_module *btf_mod, *tmp;\n\tstruct module *mod = module;\n\tstruct btf *btf;\n\tint err = 0;\n\n\tif (mod->btf_data_size == 0 ||\n\t    (op != MODULE_STATE_COMING && op != MODULE_STATE_GOING))\n\t\tgoto out;\n\n\tswitch (op) {\n\tcase MODULE_STATE_COMING:\n\t\tbtf_mod = kzalloc(sizeof(*btf_mod), GFP_KERNEL);\n\t\tif (!btf_mod) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tbtf = btf_parse_module(mod->name, mod->btf_data, mod->btf_data_size);\n\t\tif (IS_ERR(btf)) {\n\t\t\tpr_warn(\"failed to validate module [%s] BTF: %ld\\n\",\n\t\t\t\tmod->name, PTR_ERR(btf));\n\t\t\tkfree(btf_mod);\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto out;\n\t\t}\n\t\terr = btf_alloc_id(btf);\n\t\tif (err) {\n\t\t\tbtf_free(btf);\n\t\t\tkfree(btf_mod);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_lock(&btf_module_mutex);\n\t\tbtf_mod->module = module;\n\t\tbtf_mod->btf = btf;\n\t\tlist_add(&btf_mod->list, &btf_modules);\n\t\tmutex_unlock(&btf_module_mutex);\n\n\t\tif (IS_ENABLED(CONFIG_SYSFS)) {\n\t\t\tstruct bin_attribute *attr;\n\n\t\t\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\t\t\tif (!attr)\n\t\t\t\tgoto out;\n\n\t\t\tsysfs_bin_attr_init(attr);\n\t\t\tattr->attr.name = btf->name;\n\t\t\tattr->attr.mode = 0444;\n\t\t\tattr->size = btf->data_size;\n\t\t\tattr->private = btf;\n\t\t\tattr->read = btf_module_read;\n\n\t\t\terr = sysfs_create_bin_file(btf_kobj, attr);\n\t\t\tif (err) {\n\t\t\t\tpr_warn(\"failed to register module [%s] BTF in sysfs: %d\\n\",\n\t\t\t\t\tmod->name, err);\n\t\t\t\tkfree(attr);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbtf_mod->sysfs_attr = attr;\n\t\t}\n\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tmutex_lock(&btf_module_mutex);\n\t\tlist_for_each_entry_safe(btf_mod, tmp, &btf_modules, list) {\n\t\t\tif (btf_mod->module != module)\n\t\t\t\tcontinue;\n\n\t\t\tlist_del(&btf_mod->list);\n\t\t\tif (btf_mod->sysfs_attr)\n\t\t\t\tsysfs_remove_bin_file(btf_kobj, btf_mod->sysfs_attr);\n\t\t\tbtf_put(btf_mod->btf);\n\t\t\tkfree(btf_mod->sysfs_attr);\n\t\t\tkfree(btf_mod);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&btf_module_mutex);\n\t\tbreak;\n\t}\nout:\n\treturn notifier_from_errno(err);\n}\n\nstatic struct notifier_block btf_module_nb = {\n\t.notifier_call = btf_module_notify,\n};\n\nstatic int __init btf_module_init(void)\n{\n\tregister_module_notifier(&btf_module_nb);\n\treturn 0;\n}\n\nfs_initcall(btf_module_init);\n#endif /* CONFIG_DEBUG_INFO_BTF_MODULES */\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 715}, "message": "warn: potential spectre issue 'btf->types' [w] (local cap)"}], "macros": [], "notes": [], "path": "/src/kernel/bpf/btf.c", "reportHash": "2394ffd0d14946c93603c2c92e8cde3e", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1770}, "message": "warn: potential spectre issue 'btf->resolved_ids' [w]"}], "macros": [], "notes": [], "path": "/src/kernel/bpf/btf.c", "reportHash": "a3ae9108234b70e29bf5f50d31db5a68", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1786}, "message": "warn: potential spectre issue 'btf->resolved_sizes' [w]"}], "macros": [], "notes": [], "path": "/src/kernel/bpf/btf.c", "reportHash": "a0f5f01148a3285c28cc55710176a348", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
