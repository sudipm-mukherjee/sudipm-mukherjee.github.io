<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c", "content": "/*\n * Copyright 2015 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n/* The caprices of the preprocessor require that this be declared right here */\n#define CREATE_TRACE_POINTS\n\n#include \"dm_services_types.h\"\n#include \"dc.h\"\n#include \"dc/inc/core_types.h\"\n#include \"dal_asic_id.h\"\n#include \"dmub/dmub_srv.h\"\n#include \"dc/inc/hw/dmcu.h\"\n#include \"dc/inc/hw/abm.h\"\n#include \"dc/dc_dmub_srv.h\"\n#include \"amdgpu_dm_trace.h\"\n\n#include \"vid.h\"\n#include \"amdgpu.h\"\n#include \"amdgpu_display.h\"\n#include \"amdgpu_ucode.h\"\n#include \"atom.h\"\n#include \"amdgpu_dm.h\"\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n#include \"amdgpu_dm_hdcp.h\"\n#include <drm/drm_hdcp.h>\n#endif\n#include \"amdgpu_pm.h\"\n\n#include \"amd_shared.h\"\n#include \"amdgpu_dm_irq.h\"\n#include \"dm_helpers.h\"\n#include \"amdgpu_dm_mst_types.h\"\n#if defined(CONFIG_DEBUG_FS)\n#include \"amdgpu_dm_debugfs.h\"\n#endif\n\n#include \"ivsrcid/ivsrcid_vislands30.h\"\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/pm_runtime.h>\n#include <linux/pci.h>\n#include <linux/firmware.h>\n#include <linux/component.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_dp_mst_helper.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_audio_component.h>\n#include <drm/drm_hdcp.h>\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n#include \"ivsrcid/dcn/irqsrcs_dcn_1_0.h\"\n\n#include \"dcn/dcn_1_0_offset.h\"\n#include \"dcn/dcn_1_0_sh_mask.h\"\n#include \"soc15_hw_ip.h\"\n#include \"vega10_ip_offset.h\"\n\n#include \"soc15_common.h\"\n#endif\n\n#include \"modules/inc/mod_freesync.h\"\n#include \"modules/power/power_helpers.h\"\n#include \"modules/inc/mod_info_packet.h\"\n\n#define FIRMWARE_RENOIR_DMUB \"amdgpu/renoir_dmcub.bin\"\nMODULE_FIRMWARE(FIRMWARE_RENOIR_DMUB);\n#define FIRMWARE_SIENNA_CICHLID_DMUB \"amdgpu/sienna_cichlid_dmcub.bin\"\nMODULE_FIRMWARE(FIRMWARE_SIENNA_CICHLID_DMUB);\n#define FIRMWARE_NAVY_FLOUNDER_DMUB \"amdgpu/navy_flounder_dmcub.bin\"\nMODULE_FIRMWARE(FIRMWARE_NAVY_FLOUNDER_DMUB);\n#define FIRMWARE_GREEN_SARDINE_DMUB \"amdgpu/green_sardine_dmcub.bin\"\nMODULE_FIRMWARE(FIRMWARE_GREEN_SARDINE_DMUB);\n#define FIRMWARE_VANGOGH_DMUB \"amdgpu/vangogh_dmcub.bin\"\nMODULE_FIRMWARE(FIRMWARE_VANGOGH_DMUB);\n#define FIRMWARE_DIMGREY_CAVEFISH_DMUB \"amdgpu/dimgrey_cavefish_dmcub.bin\"\nMODULE_FIRMWARE(FIRMWARE_DIMGREY_CAVEFISH_DMUB);\n\n#define FIRMWARE_RAVEN_DMCU\t\t\"amdgpu/raven_dmcu.bin\"\nMODULE_FIRMWARE(FIRMWARE_RAVEN_DMCU);\n\n#define FIRMWARE_NAVI12_DMCU            \"amdgpu/navi12_dmcu.bin\"\nMODULE_FIRMWARE(FIRMWARE_NAVI12_DMCU);\n\n/* Number of bytes in PSP header for firmware. */\n#define PSP_HEADER_BYTES 0x100\n\n/* Number of bytes in PSP footer for firmware. */\n#define PSP_FOOTER_BYTES 0x100\n\n/**\n * DOC: overview\n *\n * The AMDgpu display manager, **amdgpu_dm** (or even simpler,\n * **dm**) sits between DRM and DC. It acts as a liason, converting DRM\n * requests into DC requests, and DC responses into DRM responses.\n *\n * The root control structure is &struct amdgpu_display_manager.\n */\n\n/* basic init/fini API */\nstatic int amdgpu_dm_init(struct amdgpu_device *adev);\nstatic void amdgpu_dm_fini(struct amdgpu_device *adev);\n\nstatic enum drm_mode_subconnector get_subconnector_type(struct dc_link *link)\n{\n\tswitch (link->dpcd_caps.dongle_type) {\n\tcase DISPLAY_DONGLE_NONE:\n\t\treturn DRM_MODE_SUBCONNECTOR_Native;\n\tcase DISPLAY_DONGLE_DP_VGA_CONVERTER:\n\t\treturn DRM_MODE_SUBCONNECTOR_VGA;\n\tcase DISPLAY_DONGLE_DP_DVI_CONVERTER:\n\tcase DISPLAY_DONGLE_DP_DVI_DONGLE:\n\t\treturn DRM_MODE_SUBCONNECTOR_DVID;\n\tcase DISPLAY_DONGLE_DP_HDMI_CONVERTER:\n\tcase DISPLAY_DONGLE_DP_HDMI_DONGLE:\n\t\treturn DRM_MODE_SUBCONNECTOR_HDMIA;\n\tcase DISPLAY_DONGLE_DP_HDMI_MISMATCHED_DONGLE:\n\tdefault:\n\t\treturn DRM_MODE_SUBCONNECTOR_Unknown;\n\t}\n}\n\nstatic void update_subconnector_property(struct amdgpu_dm_connector *aconnector)\n{\n\tstruct dc_link *link = aconnector->dc_link;\n\tstruct drm_connector *connector = &aconnector->base;\n\tenum drm_mode_subconnector subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\n\n\tif (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)\n\t\treturn;\n\n\tif (aconnector->dc_sink)\n\t\tsubconnector = get_subconnector_type(link);\n\n\tdrm_object_property_set_value(&connector->base,\n\t\t\tconnector->dev->mode_config.dp_subconnector_property,\n\t\t\tsubconnector);\n}\n\n/*\n * initializes drm_device display related structures, based on the information\n * provided by DAL. The drm strcutures are: drm_crtc, drm_connector,\n * drm_encoder, drm_mode_config\n *\n * Returns 0 on success\n */\nstatic int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev);\n/* removes and deallocates the drm structures, created by the above function */\nstatic void amdgpu_dm_destroy_drm_device(struct amdgpu_display_manager *dm);\n\nstatic int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,\n\t\t\t\tstruct drm_plane *plane,\n\t\t\t\tunsigned long possible_crtcs,\n\t\t\t\tconst struct dc_plane_cap *plane_cap);\nstatic int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       uint32_t link_index);\nstatic int amdgpu_dm_connector_init(struct amdgpu_display_manager *dm,\n\t\t\t\t    struct amdgpu_dm_connector *amdgpu_dm_connector,\n\t\t\t\t    uint32_t link_index,\n\t\t\t\t    struct amdgpu_encoder *amdgpu_encoder);\nstatic int amdgpu_dm_encoder_init(struct drm_device *dev,\n\t\t\t\t  struct amdgpu_encoder *aencoder,\n\t\t\t\t  uint32_t link_index);\n\nstatic int amdgpu_dm_connector_get_modes(struct drm_connector *connector);\n\nstatic void amdgpu_dm_atomic_commit_tail(struct drm_atomic_state *state);\n\nstatic int amdgpu_dm_atomic_check(struct drm_device *dev,\n\t\t\t\t  struct drm_atomic_state *state);\n\nstatic void handle_cursor_update(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *old_plane_state);\n\nstatic void amdgpu_dm_set_psr_caps(struct dc_link *link);\nstatic bool amdgpu_dm_psr_enable(struct dc_stream_state *stream);\nstatic bool amdgpu_dm_link_setup_psr(struct dc_stream_state *stream);\nstatic bool amdgpu_dm_psr_disable(struct dc_stream_state *stream);\nstatic bool amdgpu_dm_psr_disable_all(struct amdgpu_display_manager *dm);\n\nstatic const struct drm_format_info *\namd_get_format_info(const struct drm_mode_fb_cmd2 *cmd);\n\n/*\n * dm_vblank_get_counter\n *\n * @brief\n * Get counter for number of vertical blanks\n *\n * @param\n * struct amdgpu_device *adev - [in] desired amdgpu device\n * int disp_idx - [in] which CRTC to get the counter from\n *\n * @return\n * Counter for vertical blanks\n */\nstatic u32 dm_vblank_get_counter(struct amdgpu_device *adev, int crtc)\n{\n\tif (crtc >= adev->mode_info.num_crtc)\n\t\treturn 0;\n\telse {\n\t\tstruct amdgpu_crtc *acrtc = adev->mode_info.crtcs[crtc];\n\n\t\tif (acrtc->dm_irq_params.stream == NULL) {\n\t\t\tDRM_ERROR(\"dc_stream_state is NULL for crtc '%d'!\\n\",\n\t\t\t\t  crtc);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn dc_stream_get_vblank_counter(acrtc->dm_irq_params.stream);\n\t}\n}\n\nstatic int dm_crtc_get_scanoutpos(struct amdgpu_device *adev, int crtc,\n\t\t\t\t  u32 *vbl, u32 *position)\n{\n\tuint32_t v_blank_start, v_blank_end, h_position, v_position;\n\n\tif ((crtc < 0) || (crtc >= adev->mode_info.num_crtc))\n\t\treturn -EINVAL;\n\telse {\n\t\tstruct amdgpu_crtc *acrtc = adev->mode_info.crtcs[crtc];\n\n\t\tif (acrtc->dm_irq_params.stream ==  NULL) {\n\t\t\tDRM_ERROR(\"dc_stream_state is NULL for crtc '%d'!\\n\",\n\t\t\t\t  crtc);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * TODO rework base driver to use values directly.\n\t\t * for now parse it back into reg-format\n\t\t */\n\t\tdc_stream_get_scanoutpos(acrtc->dm_irq_params.stream,\n\t\t\t\t\t &v_blank_start,\n\t\t\t\t\t &v_blank_end,\n\t\t\t\t\t &h_position,\n\t\t\t\t\t &v_position);\n\n\t\t*position = v_position | (h_position << 16);\n\t\t*vbl = v_blank_start | (v_blank_end << 16);\n\t}\n\n\treturn 0;\n}\n\nstatic bool dm_is_idle(void *handle)\n{\n\t/* XXX todo */\n\treturn true;\n}\n\nstatic int dm_wait_for_idle(void *handle)\n{\n\t/* XXX todo */\n\treturn 0;\n}\n\nstatic bool dm_check_soft_reset(void *handle)\n{\n\treturn false;\n}\n\nstatic int dm_soft_reset(void *handle)\n{\n\t/* XXX todo */\n\treturn 0;\n}\n\nstatic struct amdgpu_crtc *\nget_crtc_by_otg_inst(struct amdgpu_device *adev,\n\t\t     int otg_inst)\n{\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tstruct drm_crtc *crtc;\n\tstruct amdgpu_crtc *amdgpu_crtc;\n\n\tif (otg_inst == -1) {\n\t\tWARN_ON(1);\n\t\treturn adev->mode_info.crtcs[0];\n\t}\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tamdgpu_crtc = to_amdgpu_crtc(crtc);\n\n\t\tif (amdgpu_crtc->otg_inst == otg_inst)\n\t\t\treturn amdgpu_crtc;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool amdgpu_dm_vrr_active_irq(struct amdgpu_crtc *acrtc)\n{\n\treturn acrtc->dm_irq_params.freesync_config.state ==\n\t\t       VRR_STATE_ACTIVE_VARIABLE ||\n\t       acrtc->dm_irq_params.freesync_config.state ==\n\t\t       VRR_STATE_ACTIVE_FIXED;\n}\n\nstatic inline bool amdgpu_dm_vrr_active(struct dm_crtc_state *dm_state)\n{\n\treturn dm_state->freesync_config.state == VRR_STATE_ACTIVE_VARIABLE ||\n\t       dm_state->freesync_config.state == VRR_STATE_ACTIVE_FIXED;\n}\n\n/**\n * dm_pflip_high_irq() - Handle pageflip interrupt\n * @interrupt_params: ignored\n *\n * Handles the pageflip interrupt by notifying all interested parties\n * that the pageflip has been completed.\n */\nstatic void dm_pflip_high_irq(void *interrupt_params)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc;\n\tstruct common_irq_params *irq_params = interrupt_params;\n\tstruct amdgpu_device *adev = irq_params->adev;\n\tunsigned long flags;\n\tstruct drm_pending_vblank_event *e;\n\tuint32_t vpos, hpos, v_blank_start, v_blank_end;\n\tbool vrr_active;\n\n\tamdgpu_crtc = get_crtc_by_otg_inst(adev, irq_params->irq_src - IRQ_TYPE_PFLIP);\n\n\t/* IRQ could occur when in initial stage */\n\t/* TODO work and BO cleanup */\n\tif (amdgpu_crtc == NULL) {\n\t\tDRM_DEBUG_DRIVER(\"CRTC is null, returning.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\n\tif (amdgpu_crtc->pflip_status != AMDGPU_FLIP_SUBMITTED){\n\t\tDRM_DEBUG_DRIVER(\"amdgpu_crtc->pflip_status = %d !=AMDGPU_FLIP_SUBMITTED(%d) on crtc:%d[%p] \\n\",\n\t\t\t\t\t\t amdgpu_crtc->pflip_status,\n\t\t\t\t\t\t AMDGPU_FLIP_SUBMITTED,\n\t\t\t\t\t\t amdgpu_crtc->crtc_id,\n\t\t\t\t\t\t amdgpu_crtc);\n\t\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\t\treturn;\n\t}\n\n\t/* page flip completed. */\n\te = amdgpu_crtc->event;\n\tamdgpu_crtc->event = NULL;\n\n\tif (!e)\n\t\tWARN_ON(1);\n\n\tvrr_active = amdgpu_dm_vrr_active_irq(amdgpu_crtc);\n\n\t/* Fixed refresh rate, or VRR scanout position outside front-porch? */\n\tif (!vrr_active ||\n\t    !dc_stream_get_scanoutpos(amdgpu_crtc->dm_irq_params.stream, &v_blank_start,\n\t\t\t\t      &v_blank_end, &hpos, &vpos) ||\n\t    (vpos < v_blank_start)) {\n\t\t/* Update to correct count and vblank timestamp if racing with\n\t\t * vblank irq. This also updates to the correct vblank timestamp\n\t\t * even in VRR mode, as scanout is past the front-porch atm.\n\t\t */\n\t\tdrm_crtc_accurate_vblank_count(&amdgpu_crtc->base);\n\n\t\t/* Wake up userspace by sending the pageflip event with proper\n\t\t * count and timestamp of vblank of flip completion.\n\t\t */\n\t\tif (e) {\n\t\t\tdrm_crtc_send_vblank_event(&amdgpu_crtc->base, e);\n\n\t\t\t/* Event sent, so done with vblank for this flip */\n\t\t\tdrm_crtc_vblank_put(&amdgpu_crtc->base);\n\t\t}\n\t} else if (e) {\n\t\t/* VRR active and inside front-porch: vblank count and\n\t\t * timestamp for pageflip event will only be up to date after\n\t\t * drm_crtc_handle_vblank() has been executed from late vblank\n\t\t * irq handler after start of back-porch (vline 0). We queue the\n\t\t * pageflip event for send-out by drm_crtc_handle_vblank() with\n\t\t * updated timestamp and count, once it runs after us.\n\t\t *\n\t\t * We need to open-code this instead of using the helper\n\t\t * drm_crtc_arm_vblank_event(), as that helper would\n\t\t * call drm_crtc_accurate_vblank_count(), which we must\n\t\t * not call in VRR mode while we are in front-porch!\n\t\t */\n\n\t\t/* sequence will be replaced by real count during send-out. */\n\t\te->sequence = drm_crtc_vblank_count(&amdgpu_crtc->base);\n\t\te->pipe = amdgpu_crtc->crtc_id;\n\n\t\tlist_add_tail(&e->base.link, &adev_to_drm(adev)->vblank_event_list);\n\t\te = NULL;\n\t}\n\n\t/* Keep track of vblank of this flip for flip throttling. We use the\n\t * cooked hw counter, as that one incremented at start of this vblank\n\t * of pageflip completion, so last_flip_vblank is the forbidden count\n\t * for queueing new pageflips if vsync + VRR is enabled.\n\t */\n\tamdgpu_crtc->dm_irq_params.last_flip_vblank =\n\t\tamdgpu_get_vblank_counter_kms(&amdgpu_crtc->base);\n\n\tamdgpu_crtc->pflip_status = AMDGPU_FLIP_NONE;\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\n\tDRM_DEBUG_DRIVER(\"crtc:%d[%p], pflip_stat:AMDGPU_FLIP_NONE, vrr[%d]-fp %d\\n\",\n\t\t\t amdgpu_crtc->crtc_id, amdgpu_crtc,\n\t\t\t vrr_active, (int) !e);\n}\n\nstatic void dm_vupdate_high_irq(void *interrupt_params)\n{\n\tstruct common_irq_params *irq_params = interrupt_params;\n\tstruct amdgpu_device *adev = irq_params->adev;\n\tstruct amdgpu_crtc *acrtc;\n\tunsigned long flags;\n\tint vrr_active;\n\n\tacrtc = get_crtc_by_otg_inst(adev, irq_params->irq_src - IRQ_TYPE_VUPDATE);\n\n\tif (acrtc) {\n\t\tvrr_active = amdgpu_dm_vrr_active_irq(acrtc);\n\n\t\tDRM_DEBUG_VBL(\"crtc:%d, vupdate-vrr:%d\\n\",\n\t\t\t      acrtc->crtc_id,\n\t\t\t      vrr_active);\n\n\t\t/* Core vblank handling is done here after end of front-porch in\n\t\t * vrr mode, as vblank timestamping will give valid results\n\t\t * while now done after front-porch. This will also deliver\n\t\t * page-flip completion events that have been queued to us\n\t\t * if a pageflip happened inside front-porch.\n\t\t */\n\t\tif (vrr_active) {\n\t\t\tdrm_crtc_handle_vblank(&acrtc->base);\n\n\t\t\t/* BTR processing for pre-DCE12 ASICs */\n\t\t\tif (acrtc->dm_irq_params.stream &&\n\t\t\t    adev->family < AMDGPU_FAMILY_AI) {\n\t\t\t\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\t\t\t\tmod_freesync_handle_v_update(\n\t\t\t\t    adev->dm.freesync_module,\n\t\t\t\t    acrtc->dm_irq_params.stream,\n\t\t\t\t    &acrtc->dm_irq_params.vrr_params);\n\n\t\t\t\tdc_stream_adjust_vmin_vmax(\n\t\t\t\t    adev->dm.dc,\n\t\t\t\t    acrtc->dm_irq_params.stream,\n\t\t\t\t    &acrtc->dm_irq_params.vrr_params.adjust);\n\t\t\t\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * dm_crtc_high_irq() - Handles CRTC interrupt\n * @interrupt_params: used for determining the CRTC instance\n *\n * Handles the CRTC/VSYNC interrupt by notfying DRM's VBLANK\n * event handler.\n */\nstatic void dm_crtc_high_irq(void *interrupt_params)\n{\n\tstruct common_irq_params *irq_params = interrupt_params;\n\tstruct amdgpu_device *adev = irq_params->adev;\n\tstruct amdgpu_crtc *acrtc;\n\tunsigned long flags;\n\tint vrr_active;\n\n\tacrtc = get_crtc_by_otg_inst(adev, irq_params->irq_src - IRQ_TYPE_VBLANK);\n\tif (!acrtc)\n\t\treturn;\n\n\tvrr_active = amdgpu_dm_vrr_active_irq(acrtc);\n\n\tDRM_DEBUG_VBL(\"crtc:%d, vupdate-vrr:%d, planes:%d\\n\", acrtc->crtc_id,\n\t\t      vrr_active, acrtc->dm_irq_params.active_planes);\n\n\t/**\n\t * Core vblank handling at start of front-porch is only possible\n\t * in non-vrr mode, as only there vblank timestamping will give\n\t * valid results while done in front-porch. Otherwise defer it\n\t * to dm_vupdate_high_irq after end of front-porch.\n\t */\n\tif (!vrr_active)\n\t\tdrm_crtc_handle_vblank(&acrtc->base);\n\n\t/**\n\t * Following stuff must happen at start of vblank, for crc\n\t * computation and below-the-range btr support in vrr mode.\n\t */\n\tamdgpu_dm_crtc_handle_crc_irq(&acrtc->base);\n\n\t/* BTR updates need to happen before VUPDATE on Vega and above. */\n\tif (adev->family < AMDGPU_FAMILY_AI)\n\t\treturn;\n\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\n\tif (acrtc->dm_irq_params.stream &&\n\t    acrtc->dm_irq_params.vrr_params.supported &&\n\t    acrtc->dm_irq_params.freesync_config.state ==\n\t\t    VRR_STATE_ACTIVE_VARIABLE) {\n\t\tmod_freesync_handle_v_update(adev->dm.freesync_module,\n\t\t\t\t\t     acrtc->dm_irq_params.stream,\n\t\t\t\t\t     &acrtc->dm_irq_params.vrr_params);\n\n\t\tdc_stream_adjust_vmin_vmax(adev->dm.dc, acrtc->dm_irq_params.stream,\n\t\t\t\t\t   &acrtc->dm_irq_params.vrr_params.adjust);\n\t}\n\n\t/*\n\t * If there aren't any active_planes then DCH HUBP may be clock-gated.\n\t * In that case, pageflip completion interrupts won't fire and pageflip\n\t * completion events won't get delivered. Prevent this by sending\n\t * pending pageflip events from here if a flip is still pending.\n\t *\n\t * If any planes are enabled, use dm_pflip_high_irq() instead, to\n\t * avoid race conditions between flip programming and completion,\n\t * which could cause too early flip completion events.\n\t */\n\tif (adev->family >= AMDGPU_FAMILY_RV &&\n\t    acrtc->pflip_status == AMDGPU_FLIP_SUBMITTED &&\n\t    acrtc->dm_irq_params.active_planes == 0) {\n\t\tif (acrtc->event) {\n\t\t\tdrm_crtc_send_vblank_event(&acrtc->base, acrtc->event);\n\t\t\tacrtc->event = NULL;\n\t\t\tdrm_crtc_vblank_put(&acrtc->base);\n\t\t}\n\t\tacrtc->pflip_status = AMDGPU_FLIP_NONE;\n\t}\n\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n}\n\nstatic int dm_set_clockgating_state(void *handle,\n\t\t  enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int dm_set_powergating_state(void *handle,\n\t\t  enum amd_powergating_state state)\n{\n\treturn 0;\n}\n\n/* Prototypes of private functions */\nstatic int dm_early_init(void* handle);\n\n/* Allocate memory for FBC compressed data  */\nstatic void amdgpu_dm_fbc_init(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dm_compressor_info *compressor = &adev->dm.compressor;\n\tstruct amdgpu_dm_connector *aconn = to_amdgpu_dm_connector(connector);\n\tstruct drm_display_mode *mode;\n\tunsigned long max_size = 0;\n\n\tif (adev->dm.dc->fbc_compressor == NULL)\n\t\treturn;\n\n\tif (aconn->dc_link->connector_signal != SIGNAL_TYPE_EDP)\n\t\treturn;\n\n\tif (compressor->bo_ptr)\n\t\treturn;\n\n\n\tlist_for_each_entry(mode, &connector->modes, head) {\n\t\tif (max_size < mode->htotal * mode->vtotal)\n\t\t\tmax_size = mode->htotal * mode->vtotal;\n\t}\n\n\tif (max_size) {\n\t\tint r = amdgpu_bo_create_kernel(adev, max_size * 4, PAGE_SIZE,\n\t\t\t    AMDGPU_GEM_DOMAIN_GTT, &compressor->bo_ptr,\n\t\t\t    &compressor->gpu_addr, &compressor->cpu_addr);\n\n\t\tif (r)\n\t\t\tDRM_ERROR(\"DM: Failed to initialize FBC\\n\");\n\t\telse {\n\t\t\tadev->dm.dc->ctx->fbc_gpu_addr = compressor->gpu_addr;\n\t\t\tDRM_INFO(\"DM: FBC alloc %lu\\n\", max_size*4);\n\t\t}\n\n\t}\n\n}\n\nstatic int amdgpu_dm_audio_component_get_eld(struct device *kdev, int port,\n\t\t\t\t\t  int pipe, bool *enabled,\n\t\t\t\t\t  unsigned char *buf, int max_bytes)\n{\n\tstruct drm_device *dev = dev_get_drvdata(kdev);\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct amdgpu_dm_connector *aconnector;\n\tint ret = 0;\n\n\t*enabled = false;\n\n\tmutex_lock(&adev->dm.audio_lock);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\tif (aconnector->audio_inst != port)\n\t\t\tcontinue;\n\n\t\t*enabled = true;\n\t\tret = drm_eld_size(connector->eld);\n\t\tmemcpy(buf, connector->eld, min(max_bytes, ret));\n\n\t\tbreak;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tmutex_unlock(&adev->dm.audio_lock);\n\n\tDRM_DEBUG_KMS(\"Get ELD : idx=%d ret=%d en=%d\\n\", port, ret, *enabled);\n\n\treturn ret;\n}\n\nstatic const struct drm_audio_component_ops amdgpu_dm_audio_component_ops = {\n\t.get_eld = amdgpu_dm_audio_component_get_eld,\n};\n\nstatic int amdgpu_dm_audio_component_bind(struct device *kdev,\n\t\t\t\t       struct device *hda_kdev, void *data)\n{\n\tstruct drm_device *dev = dev_get_drvdata(kdev);\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_audio_component *acomp = data;\n\n\tacomp->ops = &amdgpu_dm_audio_component_ops;\n\tacomp->dev = kdev;\n\tadev->dm.audio_component = acomp;\n\n\treturn 0;\n}\n\nstatic void amdgpu_dm_audio_component_unbind(struct device *kdev,\n\t\t\t\t\t  struct device *hda_kdev, void *data)\n{\n\tstruct drm_device *dev = dev_get_drvdata(kdev);\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct drm_audio_component *acomp = data;\n\n\tacomp->ops = NULL;\n\tacomp->dev = NULL;\n\tadev->dm.audio_component = NULL;\n}\n\nstatic const struct component_ops amdgpu_dm_audio_component_bind_ops = {\n\t.bind\t= amdgpu_dm_audio_component_bind,\n\t.unbind\t= amdgpu_dm_audio_component_unbind,\n};\n\nstatic int amdgpu_dm_audio_init(struct amdgpu_device *adev)\n{\n\tint i, ret;\n\n\tif (!amdgpu_audio)\n\t\treturn 0;\n\n\tadev->mode_info.audio.enabled = true;\n\n\tadev->mode_info.audio.num_pins = adev->dm.dc->res_pool->audio_count;\n\n\tfor (i = 0; i < adev->mode_info.audio.num_pins; i++) {\n\t\tadev->mode_info.audio.pin[i].channels = -1;\n\t\tadev->mode_info.audio.pin[i].rate = -1;\n\t\tadev->mode_info.audio.pin[i].bits_per_sample = -1;\n\t\tadev->mode_info.audio.pin[i].status_bits = 0;\n\t\tadev->mode_info.audio.pin[i].category_code = 0;\n\t\tadev->mode_info.audio.pin[i].connected = false;\n\t\tadev->mode_info.audio.pin[i].id =\n\t\t\tadev->dm.dc->res_pool->audios[i]->inst;\n\t\tadev->mode_info.audio.pin[i].offset = 0;\n\t}\n\n\tret = component_add(adev->dev, &amdgpu_dm_audio_component_bind_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadev->dm.audio_registered = true;\n\n\treturn 0;\n}\n\nstatic void amdgpu_dm_audio_fini(struct amdgpu_device *adev)\n{\n\tif (!amdgpu_audio)\n\t\treturn;\n\n\tif (!adev->mode_info.audio.enabled)\n\t\treturn;\n\n\tif (adev->dm.audio_registered) {\n\t\tcomponent_del(adev->dev, &amdgpu_dm_audio_component_bind_ops);\n\t\tadev->dm.audio_registered = false;\n\t}\n\n\t/* TODO: Disable audio? */\n\n\tadev->mode_info.audio.enabled = false;\n}\n\nstatic  void amdgpu_dm_audio_eld_notify(struct amdgpu_device *adev, int pin)\n{\n\tstruct drm_audio_component *acomp = adev->dm.audio_component;\n\n\tif (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify) {\n\t\tDRM_DEBUG_KMS(\"Notify ELD: %d\\n\", pin);\n\n\t\tacomp->audio_ops->pin_eld_notify(acomp->audio_ops->audio_ptr,\n\t\t\t\t\t\t pin, -1);\n\t}\n}\n\nstatic int dm_dmub_hw_init(struct amdgpu_device *adev)\n{\n\tconst struct dmcub_firmware_header_v1_0 *hdr;\n\tstruct dmub_srv *dmub_srv = adev->dm.dmub_srv;\n\tstruct dmub_srv_fb_info *fb_info = adev->dm.dmub_fb_info;\n\tconst struct firmware *dmub_fw = adev->dm.dmub_fw;\n\tstruct dmcu *dmcu = adev->dm.dc->res_pool->dmcu;\n\tstruct abm *abm = adev->dm.dc->res_pool->abm;\n\tstruct dmub_srv_hw_params hw_params;\n\tenum dmub_status status;\n\tconst unsigned char *fw_inst_const, *fw_bss_data;\n\tuint32_t i, fw_inst_const_size, fw_bss_data_size;\n\tbool has_hw_support;\n\n\tif (!dmub_srv)\n\t\t/* DMUB isn't supported on the ASIC. */\n\t\treturn 0;\n\n\tif (!fb_info) {\n\t\tDRM_ERROR(\"No framebuffer info for DMUB service.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dmub_fw) {\n\t\t/* Firmware required for DMUB support. */\n\t\tDRM_ERROR(\"No firmware provided for DMUB.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = dmub_srv_has_hw_support(dmub_srv, &has_hw_support);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDRM_ERROR(\"Error checking HW support for DMUB: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!has_hw_support) {\n\t\tDRM_INFO(\"DMUB unsupported on ASIC\\n\");\n\t\treturn 0;\n\t}\n\n\thdr = (const struct dmcub_firmware_header_v1_0 *)dmub_fw->data;\n\n\tfw_inst_const = dmub_fw->data +\n\t\t\tle32_to_cpu(hdr->header.ucode_array_offset_bytes) +\n\t\t\tPSP_HEADER_BYTES;\n\n\tfw_bss_data = dmub_fw->data +\n\t\t      le32_to_cpu(hdr->header.ucode_array_offset_bytes) +\n\t\t      le32_to_cpu(hdr->inst_const_bytes);\n\n\t/* Copy firmware and bios info into FB memory. */\n\tfw_inst_const_size = le32_to_cpu(hdr->inst_const_bytes) -\n\t\t\t     PSP_HEADER_BYTES - PSP_FOOTER_BYTES;\n\n\tfw_bss_data_size = le32_to_cpu(hdr->bss_data_bytes);\n\n\t/* if adev->firmware.load_type == AMDGPU_FW_LOAD_PSP,\n\t * amdgpu_ucode_init_single_fw will load dmub firmware\n\t * fw_inst_const part to cw0; otherwise, the firmware back door load\n\t * will be done by dm_dmub_hw_init\n\t */\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {\n\t\tmemcpy(fb_info->fb[DMUB_WINDOW_0_INST_CONST].cpu_addr, fw_inst_const,\n\t\t\t\tfw_inst_const_size);\n\t}\n\n\tif (fw_bss_data_size)\n\t\tmemcpy(fb_info->fb[DMUB_WINDOW_2_BSS_DATA].cpu_addr,\n\t\t       fw_bss_data, fw_bss_data_size);\n\n\t/* Copy firmware bios info into FB memory. */\n\tmemcpy(fb_info->fb[DMUB_WINDOW_3_VBIOS].cpu_addr, adev->bios,\n\t       adev->bios_size);\n\n\t/* Reset regions that need to be reset. */\n\tmemset(fb_info->fb[DMUB_WINDOW_4_MAILBOX].cpu_addr, 0,\n\tfb_info->fb[DMUB_WINDOW_4_MAILBOX].size);\n\n\tmemset(fb_info->fb[DMUB_WINDOW_5_TRACEBUFF].cpu_addr, 0,\n\t       fb_info->fb[DMUB_WINDOW_5_TRACEBUFF].size);\n\n\tmemset(fb_info->fb[DMUB_WINDOW_6_FW_STATE].cpu_addr, 0,\n\t       fb_info->fb[DMUB_WINDOW_6_FW_STATE].size);\n\n\t/* Initialize hardware. */\n\tmemset(&hw_params, 0, sizeof(hw_params));\n\thw_params.fb_base = adev->gmc.fb_start;\n\thw_params.fb_offset = adev->gmc.aper_base;\n\n\t/* backdoor load firmware and trigger dmub running */\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP)\n\t\thw_params.load_inst_const = true;\n\n\tif (dmcu)\n\t\thw_params.psp_version = dmcu->psp_version;\n\n\tfor (i = 0; i < fb_info->num_fb; ++i)\n\t\thw_params.fb[i] = &fb_info->fb[i];\n\n\tstatus = dmub_srv_hw_init(dmub_srv, &hw_params);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDRM_ERROR(\"Error initializing DMUB HW: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Wait for firmware load to finish. */\n\tstatus = dmub_srv_wait_for_auto_load(dmub_srv, 100000);\n\tif (status != DMUB_STATUS_OK)\n\t\tDRM_WARN(\"Wait for DMUB auto-load failed: %d\\n\", status);\n\n\t/* Init DMCU and ABM if available. */\n\tif (dmcu && abm) {\n\t\tdmcu->funcs->dmcu_init(dmcu);\n\t\tabm->dmcu_is_running = dmcu->funcs->is_dmcu_initialized(dmcu);\n\t}\n\n\tadev->dm.dc->ctx->dmub_srv = dc_dmub_srv_create(adev->dm.dc, dmub_srv);\n\tif (!adev->dm.dc->ctx->dmub_srv) {\n\t\tDRM_ERROR(\"Couldn't allocate DC DMUB server!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tDRM_INFO(\"DMUB hardware initialized: version=0x%08X\\n\",\n\t\t adev->dm.dmcub_fw_version);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\nstatic void mmhub_read_system_context(struct amdgpu_device *adev, struct dc_phy_addr_space_config *pa_config)\n{\n\tuint64_t pt_base;\n\tuint32_t logical_addr_low;\n\tuint32_t logical_addr_high;\n\tuint32_t agp_base, agp_bot, agp_top;\n\tPHYSICAL_ADDRESS_LOC page_table_start, page_table_end, page_table_base;\n\n\tlogical_addr_low  = min(adev->gmc.fb_start, adev->gmc.agp_start) >> 18;\n\tpt_base = amdgpu_gmc_pd_addr(adev->gart.bo);\n\n\tif (adev->apu_flags & AMD_APU_IS_RAVEN2)\n\t\t/*\n\t\t * Raven2 has a HW issue that it is unable to use the vram which\n\t\t * is out of MC_VM_SYSTEM_APERTURE_HIGH_ADDR. So here is the\n\t\t * workaround that increase system aperture high address (add 1)\n\t\t * to get rid of the VM fault and hardware hang.\n\t\t */\n\t\tlogical_addr_high = max((adev->gmc.fb_end >> 18) + 0x1, adev->gmc.agp_end >> 18);\n\telse\n\t\tlogical_addr_high = max(adev->gmc.fb_end, adev->gmc.agp_end) >> 18;\n\n\tagp_base = 0;\n\tagp_bot = adev->gmc.agp_start >> 24;\n\tagp_top = adev->gmc.agp_end >> 24;\n\n\n\tpage_table_start.high_part = (u32)(adev->gmc.gart_start >> 44) & 0xF;\n\tpage_table_start.low_part = (u32)(adev->gmc.gart_start >> 12);\n\tpage_table_end.high_part = (u32)(adev->gmc.gart_end >> 44) & 0xF;\n\tpage_table_end.low_part = (u32)(adev->gmc.gart_end >> 12);\n\tpage_table_base.high_part = upper_32_bits(pt_base) & 0xF;\n\tpage_table_base.low_part = lower_32_bits(pt_base);\n\n\tpa_config->system_aperture.start_addr = (uint64_t)logical_addr_low << 18;\n\tpa_config->system_aperture.end_addr = (uint64_t)logical_addr_high << 18;\n\n\tpa_config->system_aperture.agp_base = (uint64_t)agp_base << 24 ;\n\tpa_config->system_aperture.agp_bot = (uint64_t)agp_bot << 24;\n\tpa_config->system_aperture.agp_top = (uint64_t)agp_top << 24;\n\n\tpa_config->system_aperture.fb_base = adev->gmc.fb_start;\n\tpa_config->system_aperture.fb_offset = adev->gmc.aper_base;\n\tpa_config->system_aperture.fb_top = adev->gmc.fb_end;\n\n\tpa_config->gart_config.page_table_start_addr = page_table_start.quad_part << 12;\n\tpa_config->gart_config.page_table_end_addr = page_table_end.quad_part << 12;\n\tpa_config->gart_config.page_table_base_addr = page_table_base.quad_part;\n\n\tpa_config->is_hvm_enabled = 0;\n\n}\n#endif\n\nstatic int amdgpu_dm_init(struct amdgpu_device *adev)\n{\n\tstruct dc_init_data init_data;\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tstruct dc_callback_init init_params;\n#endif\n\tint r;\n\n\tadev->dm.ddev = adev_to_drm(adev);\n\tadev->dm.adev = adev;\n\n\t/* Zero all the fields */\n\tmemset(&init_data, 0, sizeof(init_data));\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tmemset(&init_params, 0, sizeof(init_params));\n#endif\n\n\tmutex_init(&adev->dm.dc_lock);\n\tmutex_init(&adev->dm.audio_lock);\n\n\tif(amdgpu_dm_irq_init(adev)) {\n\t\tDRM_ERROR(\"amdgpu: failed to initialize DM IRQ support.\\n\");\n\t\tgoto error;\n\t}\n\n\tinit_data.asic_id.chip_family = adev->family;\n\n\tinit_data.asic_id.pci_revision_id = adev->pdev->revision;\n\tinit_data.asic_id.hw_internal_rev = adev->external_rev_id;\n\n\tinit_data.asic_id.vram_width = adev->gmc.vram_width;\n\t/* TODO: initialize init_data.asic_id.vram_type here!!!! */\n\tinit_data.asic_id.atombios_base_address =\n\t\tadev->mode_info.atom_context->bios;\n\n\tinit_data.driver = adev;\n\n\tadev->dm.cgs_device = amdgpu_cgs_create_device(adev);\n\n\tif (!adev->dm.cgs_device) {\n\t\tDRM_ERROR(\"amdgpu: failed to create cgs device.\\n\");\n\t\tgoto error;\n\t}\n\n\tinit_data.cgs_device = adev->dm.cgs_device;\n\n\tinit_data.dce_environment = DCE_ENV_PRODUCTION_DRV;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\tcase CHIP_RAVEN:\n\tcase CHIP_RENOIR:\n\t\tinit_data.flags.gpu_vm_support = true;\n\t\tif (ASICREV_IS_GREEN_SARDINE(adev->external_rev_id))\n\t\t\tinit_data.flags.disable_dmcu = true;\n\t\tbreak;\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tcase CHIP_VANGOGH:\n\t\tinit_data.flags.gpu_vm_support = true;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (amdgpu_dc_feature_mask & DC_FBC_MASK)\n\t\tinit_data.flags.fbc_support = true;\n\n\tif (amdgpu_dc_feature_mask & DC_MULTI_MON_PP_MCLK_SWITCH_MASK)\n\t\tinit_data.flags.multi_mon_pp_mclk_switch = true;\n\n\tif (amdgpu_dc_feature_mask & DC_DISABLE_FRACTIONAL_PWM_MASK)\n\t\tinit_data.flags.disable_fractional_pwm = true;\n\n\tinit_data.flags.power_down_display_on_boot = true;\n\n\tinit_data.soc_bounding_box = adev->dm.soc_bounding_box;\n\n\t/* Display Core create. */\n\tadev->dm.dc = dc_create(&init_data);\n\n\tif (adev->dm.dc) {\n\t\tDRM_INFO(\"Display Core initialized with v%s!\\n\", DC_VER);\n\t} else {\n\t\tDRM_INFO(\"Display Core failed to initialize with v%s!\\n\", DC_VER);\n\t\tgoto error;\n\t}\n\n\tif (amdgpu_dc_debug_mask & DC_DISABLE_PIPE_SPLIT) {\n\t\tadev->dm.dc->debug.force_single_disp_pipe_split = false;\n\t\tadev->dm.dc->debug.pipe_split_policy = MPC_SPLIT_AVOID;\n\t}\n\n\tif (adev->asic_type != CHIP_CARRIZO && adev->asic_type != CHIP_STONEY)\n\t\tadev->dm.dc->debug.disable_stutter = amdgpu_pp_feature_mask & PP_STUTTER_MODE ? false : true;\n\n\tif (amdgpu_dc_debug_mask & DC_DISABLE_STUTTER)\n\t\tadev->dm.dc->debug.disable_stutter = true;\n\n\tif (amdgpu_dc_debug_mask & DC_DISABLE_DSC)\n\t\tadev->dm.dc->debug.disable_dsc = true;\n\n\tif (amdgpu_dc_debug_mask & DC_DISABLE_CLOCK_GATING)\n\t\tadev->dm.dc->debug.disable_clock_gate = true;\n\n\tr = dm_dmub_hw_init(adev);\n\tif (r) {\n\t\tDRM_ERROR(\"DMUB interface failed to initialize: status=%d\\n\", r);\n\t\tgoto error;\n\t}\n\n\tdc_hardware_init(adev->dm.dc);\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tif (adev->apu_flags) {\n\t\tstruct dc_phy_addr_space_config pa_config;\n\n\t\tmmhub_read_system_context(adev, &pa_config);\n\n\t\t// Call the DC init_memory func\n\t\tdc_setup_system_context(adev->dm.dc, &pa_config);\n\t}\n#endif\n\n\tadev->dm.freesync_module = mod_freesync_create(adev->dm.dc);\n\tif (!adev->dm.freesync_module) {\n\t\tDRM_ERROR(\n\t\t\"amdgpu: failed to initialize freesync_module.\\n\");\n\t} else\n\t\tDRM_DEBUG_DRIVER(\"amdgpu: freesync_module init done %p.\\n\",\n\t\t\t\tadev->dm.freesync_module);\n\n\tamdgpu_dm_init_color_mod();\n\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tif (adev->dm.dc->caps.max_links > 0 && adev->asic_type >= CHIP_RAVEN) {\n\t\tadev->dm.hdcp_workqueue = hdcp_create_workqueue(adev, &init_params.cp_psp, adev->dm.dc);\n\n\t\tif (!adev->dm.hdcp_workqueue)\n\t\t\tDRM_ERROR(\"amdgpu: failed to initialize hdcp_workqueue.\\n\");\n\t\telse\n\t\t\tDRM_DEBUG_DRIVER(\"amdgpu: hdcp_workqueue init done %p.\\n\", adev->dm.hdcp_workqueue);\n\n\t\tdc_init_callbacks(adev->dm.dc, &init_params);\n\t}\n#endif\n\tif (amdgpu_dm_initialize_drm_device(adev)) {\n\t\tDRM_ERROR(\n\t\t\"amdgpu: failed to initialize sw for display support.\\n\");\n\t\tgoto error;\n\t}\n\n\t/* create fake encoders for MST */\n\tdm_dp_create_fake_mst_encoders(adev);\n\n\t/* TODO: Add_display_info? */\n\n\t/* TODO use dynamic cursor width */\n\tadev_to_drm(adev)->mode_config.cursor_width = adev->dm.dc->caps.max_cursor_size;\n\tadev_to_drm(adev)->mode_config.cursor_height = adev->dm.dc->caps.max_cursor_size;\n\n\tif (drm_vblank_init(adev_to_drm(adev), adev->dm.display_indexes_num)) {\n\t\tDRM_ERROR(\n\t\t\"amdgpu: failed to initialize sw for display support.\\n\");\n\t\tgoto error;\n\t}\n\n\n\tDRM_DEBUG_DRIVER(\"KMS initialized.\\n\");\n\n\treturn 0;\nerror:\n\tamdgpu_dm_fini(adev);\n\n\treturn -EINVAL;\n}\n\nstatic void amdgpu_dm_fini(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tfor (i = 0; i < adev->dm.display_indexes_num; i++) {\n\t\tdrm_encoder_cleanup(&adev->dm.mst_encoders[i].base);\n\t}\n\n\tamdgpu_dm_audio_fini(adev);\n\n\tamdgpu_dm_destroy_drm_device(&adev->dm);\n\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tif (adev->dm.hdcp_workqueue) {\n\t\thdcp_destroy(adev->dm.hdcp_workqueue);\n\t\tadev->dm.hdcp_workqueue = NULL;\n\t}\n\n\tif (adev->dm.dc)\n\t\tdc_deinit_callbacks(adev->dm.dc);\n#endif\n\tif (adev->dm.dc->ctx->dmub_srv) {\n\t\tdc_dmub_srv_destroy(&adev->dm.dc->ctx->dmub_srv);\n\t\tadev->dm.dc->ctx->dmub_srv = NULL;\n\t}\n\n\tif (adev->dm.dmub_bo)\n\t\tamdgpu_bo_free_kernel(&adev->dm.dmub_bo,\n\t\t\t\t      &adev->dm.dmub_bo_gpu_addr,\n\t\t\t\t      &adev->dm.dmub_bo_cpu_addr);\n\n\t/* DC Destroy TODO: Replace destroy DAL */\n\tif (adev->dm.dc)\n\t\tdc_destroy(&adev->dm.dc);\n\t/*\n\t * TODO: pageflip, vlank interrupt\n\t *\n\t * amdgpu_dm_irq_fini(adev);\n\t */\n\n\tif (adev->dm.cgs_device) {\n\t\tamdgpu_cgs_destroy_device(adev->dm.cgs_device);\n\t\tadev->dm.cgs_device = NULL;\n\t}\n\tif (adev->dm.freesync_module) {\n\t\tmod_freesync_destroy(adev->dm.freesync_module);\n\t\tadev->dm.freesync_module = NULL;\n\t}\n\n\tmutex_destroy(&adev->dm.audio_lock);\n\tmutex_destroy(&adev->dm.dc_lock);\n\n\treturn;\n}\n\nstatic int load_dmcu_fw(struct amdgpu_device *adev)\n{\n\tconst char *fw_name_dmcu = NULL;\n\tint r;\n\tconst struct dmcu_firmware_header_v1_0 *hdr;\n\n\tswitch(adev->asic_type) {\n#if defined(CONFIG_DRM_AMD_DC_SI)\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\tcase CHIP_OLAND:\n#endif\n\tcase CHIP_BONAIRE:\n\tcase CHIP_HAWAII:\n\tcase CHIP_KAVERI:\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\tcase CHIP_TONGA:\n\tcase CHIP_FIJI:\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\tcase CHIP_VEGA10:\n\tcase CHIP_VEGA12:\n\tcase CHIP_VEGA20:\n\tcase CHIP_NAVI10:\n\tcase CHIP_NAVI14:\n\tcase CHIP_RENOIR:\n\tcase CHIP_SIENNA_CICHLID:\n\tcase CHIP_NAVY_FLOUNDER:\n\tcase CHIP_DIMGREY_CAVEFISH:\n\tcase CHIP_VANGOGH:\n\t\treturn 0;\n\tcase CHIP_NAVI12:\n\t\tfw_name_dmcu = FIRMWARE_NAVI12_DMCU;\n\t\tbreak;\n\tcase CHIP_RAVEN:\n\t\tif (ASICREV_IS_PICASSO(adev->external_rev_id))\n\t\t\tfw_name_dmcu = FIRMWARE_RAVEN_DMCU;\n\t\telse if (ASICREV_IS_RAVEN2(adev->external_rev_id))\n\t\t\tfw_name_dmcu = FIRMWARE_RAVEN_DMCU;\n\t\telse\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported ASIC type: 0x%X\\n\", adev->asic_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP) {\n\t\tDRM_DEBUG_KMS(\"dm: DMCU firmware not supported on direct or SMU loading\\n\");\n\t\treturn 0;\n\t}\n\n\tr = request_firmware_direct(&adev->dm.fw_dmcu, fw_name_dmcu, adev->dev);\n\tif (r == -ENOENT) {\n\t\t/* DMCU firmware is not necessary, so don't raise a fuss if it's missing */\n\t\tDRM_DEBUG_KMS(\"dm: DMCU firmware not found\\n\");\n\t\tadev->dm.fw_dmcu = NULL;\n\t\treturn 0;\n\t}\n\tif (r) {\n\t\tdev_err(adev->dev, \"amdgpu_dm: Can't load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name_dmcu);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_ucode_validate(adev->dm.fw_dmcu);\n\tif (r) {\n\t\tdev_err(adev->dev, \"amdgpu_dm: Can't validate firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name_dmcu);\n\t\trelease_firmware(adev->dm.fw_dmcu);\n\t\tadev->dm.fw_dmcu = NULL;\n\t\treturn r;\n\t}\n\n\thdr = (const struct dmcu_firmware_header_v1_0 *)adev->dm.fw_dmcu->data;\n\tadev->firmware.ucode[AMDGPU_UCODE_ID_DMCU_ERAM].ucode_id = AMDGPU_UCODE_ID_DMCU_ERAM;\n\tadev->firmware.ucode[AMDGPU_UCODE_ID_DMCU_ERAM].fw = adev->dm.fw_dmcu;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(hdr->header.ucode_size_bytes) - le32_to_cpu(hdr->intv_size_bytes), PAGE_SIZE);\n\n\tadev->firmware.ucode[AMDGPU_UCODE_ID_DMCU_INTV].ucode_id = AMDGPU_UCODE_ID_DMCU_INTV;\n\tadev->firmware.ucode[AMDGPU_UCODE_ID_DMCU_INTV].fw = adev->dm.fw_dmcu;\n\tadev->firmware.fw_size +=\n\t\tALIGN(le32_to_cpu(hdr->intv_size_bytes), PAGE_SIZE);\n\n\tadev->dm.dmcu_fw_version = le32_to_cpu(hdr->header.ucode_version);\n\n\tDRM_DEBUG_KMS(\"PSP loading DMCU firmware\\n\");\n\n\treturn 0;\n}\n\nstatic uint32_t amdgpu_dm_dmub_reg_read(void *ctx, uint32_t address)\n{\n\tstruct amdgpu_device *adev = ctx;\n\n\treturn dm_read_reg(adev->dm.dc->ctx, address);\n}\n\nstatic void amdgpu_dm_dmub_reg_write(void *ctx, uint32_t address,\n\t\t\t\t     uint32_t value)\n{\n\tstruct amdgpu_device *adev = ctx;\n\n\treturn dm_write_reg(adev->dm.dc->ctx, address, value);\n}\n\nstatic int dm_dmub_sw_init(struct amdgpu_device *adev)\n{\n\tstruct dmub_srv_create_params create_params;\n\tstruct dmub_srv_region_params region_params;\n\tstruct dmub_srv_region_info region_info;\n\tstruct dmub_srv_fb_params fb_params;\n\tstruct dmub_srv_fb_info *fb_info;\n\tstruct dmub_srv *dmub_srv;\n\tconst struct dmcub_firmware_header_v1_0 *hdr;\n\tconst char *fw_name_dmub;\n\tenum dmub_asic dmub_asic;\n\tenum dmub_status status;\n\tint r;\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_RENOIR:\n\t\tdmub_asic = DMUB_ASIC_DCN21;\n\t\tfw_name_dmub = FIRMWARE_RENOIR_DMUB;\n\t\tif (ASICREV_IS_GREEN_SARDINE(adev->external_rev_id))\n\t\t\tfw_name_dmub = FIRMWARE_GREEN_SARDINE_DMUB;\n\t\tbreak;\n\tcase CHIP_SIENNA_CICHLID:\n\t\tdmub_asic = DMUB_ASIC_DCN30;\n\t\tfw_name_dmub = FIRMWARE_SIENNA_CICHLID_DMUB;\n\t\tbreak;\n\tcase CHIP_NAVY_FLOUNDER:\n\t\tdmub_asic = DMUB_ASIC_DCN30;\n\t\tfw_name_dmub = FIRMWARE_NAVY_FLOUNDER_DMUB;\n\t\tbreak;\n\tcase CHIP_VANGOGH:\n\t\tdmub_asic = DMUB_ASIC_DCN301;\n\t\tfw_name_dmub = FIRMWARE_VANGOGH_DMUB;\n\t\tbreak;\n\tcase CHIP_DIMGREY_CAVEFISH:\n\t\tdmub_asic = DMUB_ASIC_DCN302;\n\t\tfw_name_dmub = FIRMWARE_DIMGREY_CAVEFISH_DMUB;\n\t\tbreak;\n\n\tdefault:\n\t\t/* ASIC doesn't support DMUB. */\n\t\treturn 0;\n\t}\n\n\tr = request_firmware_direct(&adev->dm.dmub_fw, fw_name_dmub, adev->dev);\n\tif (r) {\n\t\tDRM_ERROR(\"DMUB firmware loading failed: %d\\n\", r);\n\t\treturn 0;\n\t}\n\n\tr = amdgpu_ucode_validate(adev->dm.dmub_fw);\n\tif (r) {\n\t\tDRM_ERROR(\"Couldn't validate DMUB firmware: %d\\n\", r);\n\t\treturn 0;\n\t}\n\n\thdr = (const struct dmcub_firmware_header_v1_0 *)adev->dm.dmub_fw->data;\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tadev->firmware.ucode[AMDGPU_UCODE_ID_DMCUB].ucode_id =\n\t\t\tAMDGPU_UCODE_ID_DMCUB;\n\t\tadev->firmware.ucode[AMDGPU_UCODE_ID_DMCUB].fw =\n\t\t\tadev->dm.dmub_fw;\n\t\tadev->firmware.fw_size +=\n\t\t\tALIGN(le32_to_cpu(hdr->inst_const_bytes), PAGE_SIZE);\n\n\t\tDRM_INFO(\"Loading DMUB firmware via PSP: version=0x%08X\\n\",\n\t\t\t adev->dm.dmcub_fw_version);\n\t}\n\n\tadev->dm.dmcub_fw_version = le32_to_cpu(hdr->header.ucode_version);\n\n\tadev->dm.dmub_srv = kzalloc(sizeof(*adev->dm.dmub_srv), GFP_KERNEL);\n\tdmub_srv = adev->dm.dmub_srv;\n\n\tif (!dmub_srv) {\n\t\tDRM_ERROR(\"Failed to allocate DMUB service!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&create_params, 0, sizeof(create_params));\n\tcreate_params.user_ctx = adev;\n\tcreate_params.funcs.reg_read = amdgpu_dm_dmub_reg_read;\n\tcreate_params.funcs.reg_write = amdgpu_dm_dmub_reg_write;\n\tcreate_params.asic = dmub_asic;\n\n\t/* Create the DMUB service. */\n\tstatus = dmub_srv_create(dmub_srv, &create_params);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDRM_ERROR(\"Error creating DMUB service: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Calculate the size of all the regions for the DMUB service. */\n\tmemset(&region_params, 0, sizeof(region_params));\n\n\tregion_params.inst_const_size = le32_to_cpu(hdr->inst_const_bytes) -\n\t\t\t\t\tPSP_HEADER_BYTES - PSP_FOOTER_BYTES;\n\tregion_params.bss_data_size = le32_to_cpu(hdr->bss_data_bytes);\n\tregion_params.vbios_size = adev->bios_size;\n\tregion_params.fw_bss_data = region_params.bss_data_size ?\n\t\tadev->dm.dmub_fw->data +\n\t\tle32_to_cpu(hdr->header.ucode_array_offset_bytes) +\n\t\tle32_to_cpu(hdr->inst_const_bytes) : NULL;\n\tregion_params.fw_inst_const =\n\t\tadev->dm.dmub_fw->data +\n\t\tle32_to_cpu(hdr->header.ucode_array_offset_bytes) +\n\t\tPSP_HEADER_BYTES;\n\n\tstatus = dmub_srv_calc_region_info(dmub_srv, &region_params,\n\t\t\t\t\t   &region_info);\n\n\tif (status != DMUB_STATUS_OK) {\n\t\tDRM_ERROR(\"Error calculating DMUB region info: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Allocate a framebuffer based on the total size of all the regions.\n\t * TODO: Move this into GART.\n\t */\n\tr = amdgpu_bo_create_kernel(adev, region_info.fb_size, PAGE_SIZE,\n\t\t\t\t    AMDGPU_GEM_DOMAIN_VRAM, &adev->dm.dmub_bo,\n\t\t\t\t    &adev->dm.dmub_bo_gpu_addr,\n\t\t\t\t    &adev->dm.dmub_bo_cpu_addr);\n\tif (r)\n\t\treturn r;\n\n\t/* Rebase the regions on the framebuffer address. */\n\tmemset(&fb_params, 0, sizeof(fb_params));\n\tfb_params.cpu_addr = adev->dm.dmub_bo_cpu_addr;\n\tfb_params.gpu_addr = adev->dm.dmub_bo_gpu_addr;\n\tfb_params.region_info = &region_info;\n\n\tadev->dm.dmub_fb_info =\n\t\tkzalloc(sizeof(*adev->dm.dmub_fb_info), GFP_KERNEL);\n\tfb_info = adev->dm.dmub_fb_info;\n\n\tif (!fb_info) {\n\t\tDRM_ERROR(\n\t\t\t\"Failed to allocate framebuffer info for DMUB service!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstatus = dmub_srv_calc_fb_info(dmub_srv, &fb_params, fb_info);\n\tif (status != DMUB_STATUS_OK) {\n\t\tDRM_ERROR(\"Error calculating DMUB FB info: %d\\n\", status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dm_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tint r;\n\n\tr = dm_dmub_sw_init(adev);\n\tif (r)\n\t\treturn r;\n\n\treturn load_dmcu_fw(adev);\n}\n\nstatic int dm_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tkfree(adev->dm.dmub_fb_info);\n\tadev->dm.dmub_fb_info = NULL;\n\n\tif (adev->dm.dmub_srv) {\n\t\tdmub_srv_destroy(adev->dm.dmub_srv);\n\t\tadev->dm.dmub_srv = NULL;\n\t}\n\n\trelease_firmware(adev->dm.dmub_fw);\n\tadev->dm.dmub_fw = NULL;\n\n\trelease_firmware(adev->dm.fw_dmcu);\n\tadev->dm.fw_dmcu = NULL;\n\n\treturn 0;\n}\n\nstatic int detect_mst_link_for_all_connectors(struct drm_device *dev)\n{\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter iter;\n\tint ret = 0;\n\n\tdrm_connector_list_iter_begin(dev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter) {\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\tif (aconnector->dc_link->type == dc_connection_mst_branch &&\n\t\t    aconnector->mst_mgr.aux) {\n\t\t\tDRM_DEBUG_DRIVER(\"DM_MST: starting TM on aconnector: %p [id: %d]\\n\",\n\t\t\t\t\t aconnector,\n\t\t\t\t\t aconnector->base.base.id);\n\n\t\t\tret = drm_dp_mst_topology_mgr_set_mst(&aconnector->mst_mgr, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tDRM_ERROR(\"DM_MST: Failed to start MST\\n\");\n\t\t\t\taconnector->dc_link->type =\n\t\t\t\t\tdc_connection_single;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\treturn ret;\n}\n\nstatic int dm_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tstruct dmcu_iram_parameters params;\n\tunsigned int linear_lut[16];\n\tint i;\n\tstruct dmcu *dmcu = NULL;\n\tbool ret = true;\n\n\tdmcu = adev->dm.dc->res_pool->dmcu;\n\n\tfor (i = 0; i < 16; i++)\n\t\tlinear_lut[i] = 0xFFFF * i / 15;\n\n\tparams.set = 0;\n\tparams.backlight_ramping_start = 0xCCCC;\n\tparams.backlight_ramping_reduction = 0xCCCCCCCC;\n\tparams.backlight_lut_array_size = 16;\n\tparams.backlight_lut_array = linear_lut;\n\n\t/* Min backlight level after ABM reduction,  Don't allow below 1%\n\t * 0xFFFF x 0.01 = 0x28F\n\t */\n\tparams.min_abm_backlight = 0x28F;\n\n\t/* In the case where abm is implemented on dmcub,\n\t * dmcu object will be null.\n\t * ABM 2.4 and up are implemented on dmcub.\n\t */\n\tif (dmcu)\n\t\tret = dmcu_load_iram(dmcu, params);\n\telse if (adev->dm.dc->ctx->dmub_srv)\n\t\tret = dmub_init_abm_config(adev->dm.dc->res_pool, params);\n\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\treturn detect_mst_link_for_all_connectors(adev_to_drm(adev));\n}\n\nstatic void s3_handle_mst(struct drm_device *dev, bool suspend)\n{\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter iter;\n\tstruct drm_dp_mst_topology_mgr *mgr;\n\tint ret;\n\tbool need_hotplug = false;\n\n\tdrm_connector_list_iter_begin(dev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter) {\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\tif (aconnector->dc_link->type != dc_connection_mst_branch ||\n\t\t    aconnector->mst_port)\n\t\t\tcontinue;\n\n\t\tmgr = &aconnector->mst_mgr;\n\n\t\tif (suspend) {\n\t\t\tdrm_dp_mst_topology_mgr_suspend(mgr);\n\t\t} else {\n\t\t\tret = drm_dp_mst_topology_mgr_resume(mgr, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tdrm_dp_mst_topology_mgr_set_mst(mgr, false);\n\t\t\t\tneed_hotplug = true;\n\t\t\t}\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\tif (need_hotplug)\n\t\tdrm_kms_helper_hotplug_event(dev);\n}\n\nstatic int amdgpu_dm_smu_write_watermarks_table(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = &adev->smu;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn 0;\n\n\t/* This interface is for dGPU Navi1x.Linux dc-pplib interface depends\n\t * on window driver dc implementation.\n\t * For Navi1x, clock settings of dcn watermarks are fixed. the settings\n\t * should be passed to smu during boot up and resume from s3.\n\t * boot up: dc calculate dcn watermark clock settings within dc_create,\n\t * dcn20_resource_construct\n\t * then call pplib functions below to pass the settings to smu:\n\t * smu_set_watermarks_for_clock_ranges\n\t * smu_set_watermarks_table\n\t * navi10_set_watermarks_table\n\t * smu_write_watermarks_table\n\t *\n\t * For Renoir, clock settings of dcn watermark are also fixed values.\n\t * dc has implemented different flow for window driver:\n\t * dc_hardware_init / dc_set_power_state\n\t * dcn10_init_hw\n\t * notify_wm_ranges\n\t * set_wm_ranges\n\t * -- Linux\n\t * smu_set_watermarks_for_clock_ranges\n\t * renoir_set_watermarks_table\n\t * smu_write_watermarks_table\n\t *\n\t * For Linux,\n\t * dc_hardware_init -> amdgpu_dm_init\n\t * dc_set_power_state --> dm_resume\n\t *\n\t * therefore, this function apply to navi10/12/14 but not Renoir\n\t * *\n\t */\n\tswitch(adev->asic_type) {\n\tcase CHIP_NAVI10:\n\tcase CHIP_NAVI14:\n\tcase CHIP_NAVI12:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret = smu_write_watermarks_table(smu);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to update WMTABLE!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n/**\n * dm_hw_init() - Initialize DC device\n * @handle: The base driver device containing the amdgpu_dm device.\n *\n * Initialize the &struct amdgpu_display_manager device. This involves calling\n * the initializers of each DM component, then populating the struct with them.\n *\n * Although the function implies hardware initialization, both hardware and\n * software are initialized here. Splitting them out to their relevant init\n * hooks is a future TODO item.\n *\n * Some notable things that are initialized here:\n *\n * - Display Core, both software and hardware\n * - DC modules that we need (freesync and color management)\n * - DRM software states\n * - Interrupt sources and handlers\n * - Vblank support\n * - Debug FS entries, if enabled\n */\nstatic int dm_hw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\t/* Create DAL display manager */\n\tamdgpu_dm_init(adev);\n\tamdgpu_dm_hpd_init(adev);\n\n\treturn 0;\n}\n\n/**\n * dm_hw_fini() - Teardown DC device\n * @handle: The base driver device containing the amdgpu_dm device.\n *\n * Teardown components within &struct amdgpu_display_manager that require\n * cleanup. This involves cleaning up the DRM device, DC, and any modules that\n * were loaded. Also flush IRQ workqueues and disable them.\n */\nstatic int dm_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_dm_hpd_fini(adev);\n\n\tamdgpu_dm_irq_fini(adev);\n\tamdgpu_dm_fini(adev);\n\treturn 0;\n}\n\n\nstatic int dm_enable_vblank(struct drm_crtc *crtc);\nstatic void dm_disable_vblank(struct drm_crtc *crtc);\n\nstatic void dm_gpureset_toggle_interrupts(struct amdgpu_device *adev,\n\t\t\t\t struct dc_state *state, bool enable)\n{\n\tenum dc_irq_source irq_source;\n\tstruct amdgpu_crtc *acrtc;\n\tint rc = -EBUSY;\n\tint i = 0;\n\n\tfor (i = 0; i < state->stream_count; i++) {\n\t\tacrtc = get_crtc_by_otg_inst(\n\t\t\t\tadev, state->stream_status[i].primary_otg_inst);\n\n\t\tif (acrtc && state->stream_status[i].plane_count != 0) {\n\t\t\tirq_source = IRQ_TYPE_PFLIP + acrtc->otg_inst;\n\t\t\trc = dc_interrupt_set(adev->dm.dc, irq_source, enable) ? 0 : -EBUSY;\n\t\t\tDRM_DEBUG(\"crtc %d - vupdate irq %sabling: r=%d\\n\",\n\t\t\t\t  acrtc->crtc_id, enable ? \"en\" : \"dis\", rc);\n\t\t\tif (rc)\n\t\t\t\tDRM_WARN(\"Failed to %s pflip interrupts\\n\",\n\t\t\t\t\t enable ? \"enable\" : \"disable\");\n\n\t\t\tif (enable) {\n\t\t\t\trc = dm_enable_vblank(&acrtc->base);\n\t\t\t\tif (rc)\n\t\t\t\t\tDRM_WARN(\"Failed to enable vblank interrupts\\n\");\n\t\t\t} else {\n\t\t\t\tdm_disable_vblank(&acrtc->base);\n\t\t\t}\n\n\t\t}\n\t}\n\n}\n\nstatic enum dc_status amdgpu_dm_commit_zero_streams(struct dc *dc)\n{\n\tstruct dc_state *context = NULL;\n\tenum dc_status res = DC_ERROR_UNEXPECTED;\n\tint i;\n\tstruct dc_stream_state *del_streams[MAX_PIPES];\n\tint del_streams_count = 0;\n\n\tmemset(del_streams, 0, sizeof(del_streams));\n\n\tcontext = dc_create_state(dc);\n\tif (context == NULL)\n\t\tgoto context_alloc_fail;\n\n\tdc_resource_state_copy_construct_current(dc, context);\n\n\t/* First remove from context all streams */\n\tfor (i = 0; i < context->stream_count; i++) {\n\t\tstruct dc_stream_state *stream = context->streams[i];\n\n\t\tdel_streams[del_streams_count++] = stream;\n\t}\n\n\t/* Remove all planes for removed streams and then remove the streams */\n\tfor (i = 0; i < del_streams_count; i++) {\n\t\tif (!dc_rem_all_planes_for_stream(dc, del_streams[i], context)) {\n\t\t\tres = DC_FAIL_DETACH_SURFACES;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tres = dc_remove_stream_from_ctx(dc, context, del_streams[i]);\n\t\tif (res != DC_OK)\n\t\t\tgoto fail;\n\t}\n\n\n\tres = dc_validate_global_state(dc, context, false);\n\n\tif (res != DC_OK) {\n\t\tDRM_ERROR(\"%s:resource validation failed, dc_status:%d\\n\", __func__, res);\n\t\tgoto fail;\n\t}\n\n\tres = dc_commit_state(dc, context);\n\nfail:\n\tdc_release_state(context);\n\ncontext_alloc_fail:\n\treturn res;\n}\n\nstatic int dm_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tint ret = 0;\n\n\tif (amdgpu_in_reset(adev)) {\n\t\tmutex_lock(&dm->dc_lock);\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\t\tdc_allow_idle_optimizations(adev->dm.dc, false);\n#endif\n\n\t\tdm->cached_dc_state = dc_copy_state(dm->dc->current_state);\n\n\t\tdm_gpureset_toggle_interrupts(adev, dm->cached_dc_state, false);\n\n\t\tamdgpu_dm_commit_zero_streams(dm->dc);\n\n\t\tamdgpu_dm_irq_suspend(adev);\n\n\t\treturn ret;\n\t}\n\n\tWARN_ON(adev->dm.cached_state);\n\tadev->dm.cached_state = drm_atomic_helper_suspend(adev_to_drm(adev));\n\n\ts3_handle_mst(adev_to_drm(adev), true);\n\n\tamdgpu_dm_irq_suspend(adev);\n\n\n\tdc_set_power_state(dm->dc, DC_ACPI_CM_POWER_STATE_D3);\n\n\treturn 0;\n}\n\nstatic struct amdgpu_dm_connector *\namdgpu_dm_find_first_crtc_matching_connector(struct drm_atomic_state *state,\n\t\t\t\t\t     struct drm_crtc *crtc)\n{\n\tuint32_t i;\n\tstruct drm_connector_state *new_con_state;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc_from_state;\n\n\tfor_each_new_connector_in_state(state, connector, new_con_state, i) {\n\t\tcrtc_from_state = new_con_state->crtc;\n\n\t\tif (crtc_from_state == crtc)\n\t\t\treturn to_amdgpu_dm_connector(connector);\n\t}\n\n\treturn NULL;\n}\n\nstatic void emulated_link_detect(struct dc_link *link)\n{\n\tstruct dc_sink_init_data sink_init_data = { 0 };\n\tstruct display_sink_capability sink_caps = { 0 };\n\tenum dc_edid_status edid_status;\n\tstruct dc_context *dc_ctx = link->ctx;\n\tstruct dc_sink *sink = NULL;\n\tstruct dc_sink *prev_sink = NULL;\n\n\tlink->type = dc_connection_none;\n\tprev_sink = link->local_sink;\n\n\tif (prev_sink != NULL)\n\t\tdc_sink_retain(prev_sink);\n\n\tswitch (link->connector_signal) {\n\tcase SIGNAL_TYPE_HDMI_TYPE_A: {\n\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\tsink_caps.signal = SIGNAL_TYPE_HDMI_TYPE_A;\n\t\tbreak;\n\t}\n\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK: {\n\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\tsink_caps.signal = SIGNAL_TYPE_DVI_SINGLE_LINK;\n\t\tbreak;\n\t}\n\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK: {\n\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\tsink_caps.signal = SIGNAL_TYPE_DVI_DUAL_LINK;\n\t\tbreak;\n\t}\n\n\tcase SIGNAL_TYPE_LVDS: {\n\t\tsink_caps.transaction_type = DDC_TRANSACTION_TYPE_I2C;\n\t\tsink_caps.signal = SIGNAL_TYPE_LVDS;\n\t\tbreak;\n\t}\n\n\tcase SIGNAL_TYPE_EDP: {\n\t\tsink_caps.transaction_type =\n\t\t\tDDC_TRANSACTION_TYPE_I2C_OVER_AUX;\n\t\tsink_caps.signal = SIGNAL_TYPE_EDP;\n\t\tbreak;\n\t}\n\n\tcase SIGNAL_TYPE_DISPLAY_PORT: {\n\t\tsink_caps.transaction_type =\n\t\t\tDDC_TRANSACTION_TYPE_I2C_OVER_AUX;\n\t\tsink_caps.signal = SIGNAL_TYPE_VIRTUAL;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tDC_ERROR(\"Invalid connector type! signal:%d\\n\",\n\t\t\tlink->connector_signal);\n\t\treturn;\n\t}\n\n\tsink_init_data.link = link;\n\tsink_init_data.sink_signal = sink_caps.signal;\n\n\tsink = dc_sink_create(&sink_init_data);\n\tif (!sink) {\n\t\tDC_ERROR(\"Failed to create sink!\\n\");\n\t\treturn;\n\t}\n\n\t/* dc_sink_create returns a new reference */\n\tlink->local_sink = sink;\n\n\tedid_status = dm_helpers_read_local_edid(\n\t\t\tlink->ctx,\n\t\t\tlink,\n\t\t\tsink);\n\n\tif (edid_status != EDID_OK)\n\t\tDC_ERROR(\"Failed to read EDID\");\n\n}\n\nstatic void dm_gpureset_commit_state(struct dc_state *dc_state,\n\t\t\t\t     struct amdgpu_display_manager *dm)\n{\n\tstruct {\n\t\tstruct dc_surface_update surface_updates[MAX_SURFACES];\n\t\tstruct dc_plane_info plane_infos[MAX_SURFACES];\n\t\tstruct dc_scaling_info scaling_infos[MAX_SURFACES];\n\t\tstruct dc_flip_addrs flip_addrs[MAX_SURFACES];\n\t\tstruct dc_stream_update stream_update;\n\t} * bundle;\n\tint k, m;\n\n\tbundle = kzalloc(sizeof(*bundle), GFP_KERNEL);\n\n\tif (!bundle) {\n\t\tdm_error(\"Failed to allocate update bundle\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tfor (k = 0; k < dc_state->stream_count; k++) {\n\t\tbundle->stream_update.stream = dc_state->streams[k];\n\n\t\tfor (m = 0; m < dc_state->stream_status->plane_count; m++) {\n\t\t\tbundle->surface_updates[m].surface =\n\t\t\t\tdc_state->stream_status->plane_states[m];\n\t\t\tbundle->surface_updates[m].surface->force_full_update =\n\t\t\t\ttrue;\n\t\t}\n\t\tdc_commit_updates_for_stream(\n\t\t\tdm->dc, bundle->surface_updates,\n\t\t\tdc_state->stream_status->plane_count,\n\t\t\tdc_state->streams[k], &bundle->stream_update, dc_state);\n\t}\n\ncleanup:\n\tkfree(bundle);\n\n\treturn;\n}\n\nstatic void dm_set_dpms_off(struct dc_link *link)\n{\n\tstruct dc_stream_state *stream_state;\n\tstruct amdgpu_dm_connector *aconnector = link->priv;\n\tstruct amdgpu_device *adev = drm_to_adev(aconnector->base.dev);\n\tstruct dc_stream_update stream_update;\n\tbool dpms_off = true;\n\n\tmemset(&stream_update, 0, sizeof(stream_update));\n\tstream_update.dpms_off = &dpms_off;\n\n\tmutex_lock(&adev->dm.dc_lock);\n\tstream_state = dc_stream_find_from_link(link);\n\n\tif (stream_state == NULL) {\n\t\tDRM_DEBUG_DRIVER(\"Error finding stream state associated with link!\\n\");\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t\treturn;\n\t}\n\n\tstream_update.stream = stream_state;\n\tdc_commit_updates_for_stream(stream_state->ctx->dc, NULL, 0,\n\t\t\t\t     stream_state, &stream_update,\n\t\t\t\t     stream_state->ctx->dc->current_state);\n\tmutex_unlock(&adev->dm.dc_lock);\n}\n\nstatic int dm_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct drm_device *ddev = adev_to_drm(adev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter iter;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct dm_crtc_state *dm_new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tstruct dm_plane_state *dm_new_plane_state;\n\tstruct dm_atomic_state *dm_state = to_dm_atomic_state(dm->atomic_obj.state);\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n\tstruct dc_state *dc_state;\n\tint i, r, j;\n\n\tif (amdgpu_in_reset(adev)) {\n\t\tdc_state = dm->cached_dc_state;\n\n\t\tr = dm_dmub_hw_init(adev);\n\t\tif (r)\n\t\t\tDRM_ERROR(\"DMUB interface failed to initialize: status=%d\\n\", r);\n\n\t\tdc_set_power_state(dm->dc, DC_ACPI_CM_POWER_STATE_D0);\n\t\tdc_resume(dm->dc);\n\n\t\tamdgpu_dm_irq_resume_early(adev);\n\n\t\tfor (i = 0; i < dc_state->stream_count; i++) {\n\t\t\tdc_state->streams[i]->mode_changed = true;\n\t\t\tfor (j = 0; j < dc_state->stream_status->plane_count; j++) {\n\t\t\t\tdc_state->stream_status->plane_states[j]->update_flags.raw\n\t\t\t\t\t= 0xffffffff;\n\t\t\t}\n\t\t}\n\n\t\tWARN_ON(!dc_commit_state(dm->dc, dc_state));\n\n\t\tdm_gpureset_commit_state(dm->cached_dc_state, dm);\n\n\t\tdm_gpureset_toggle_interrupts(adev, dm->cached_dc_state, true);\n\n\t\tdc_release_state(dm->cached_dc_state);\n\t\tdm->cached_dc_state = NULL;\n\n\t\tamdgpu_dm_irq_resume_late(adev);\n\n\t\tmutex_unlock(&dm->dc_lock);\n\n\t\treturn 0;\n\t}\n\t/* Recreate dc_state - DC invalidates it when setting power state to S3. */\n\tdc_release_state(dm_state->context);\n\tdm_state->context = dc_create_state(dm->dc);\n\t/* TODO: Remove dc_state->dccg, use dc->dccg directly. */\n\tdc_resource_state_construct(dm->dc, dm_state->context);\n\n\t/* Before powering on DC we need to re-initialize DMUB. */\n\tr = dm_dmub_hw_init(adev);\n\tif (r)\n\t\tDRM_ERROR(\"DMUB interface failed to initialize: status=%d\\n\", r);\n\n\t/* power on hardware */\n\tdc_set_power_state(dm->dc, DC_ACPI_CM_POWER_STATE_D0);\n\n\t/* program HPD filter */\n\tdc_resume(dm->dc);\n\n\t/*\n\t * early enable HPD Rx IRQ, should be done before set mode as short\n\t * pulse interrupts are used for MST\n\t */\n\tamdgpu_dm_irq_resume_early(adev);\n\n\t/* On resume we need to rewrite the MSTM control bits to enable MST*/\n\ts3_handle_mst(ddev, false);\n\n\t/* Do detection*/\n\tdrm_connector_list_iter_begin(ddev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter) {\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\t/*\n\t\t * this is the case when traversing through already created\n\t\t * MST connectors, should be skipped\n\t\t */\n\t\tif (aconnector->mst_port)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&aconnector->hpd_lock);\n\t\tif (!dc_link_detect_sink(aconnector->dc_link, &new_connection_type))\n\t\t\tDRM_ERROR(\"KMS: Failed to detect connector\\n\");\n\n\t\tif (aconnector->base.force && new_connection_type == dc_connection_none)\n\t\t\temulated_link_detect(aconnector->dc_link);\n\t\telse\n\t\t\tdc_link_detect(aconnector->dc_link, DETECT_REASON_HPD);\n\n\t\tif (aconnector->fake_enable && aconnector->dc_link->local_sink)\n\t\t\taconnector->fake_enable = false;\n\n\t\tif (aconnector->dc_sink)\n\t\t\tdc_sink_release(aconnector->dc_sink);\n\t\taconnector->dc_sink = NULL;\n\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\t\tmutex_unlock(&aconnector->hpd_lock);\n\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\t/* Force mode set in atomic commit */\n\tfor_each_new_crtc_in_state(dm->cached_state, crtc, new_crtc_state, i)\n\t\tnew_crtc_state->active_changed = true;\n\n\t/*\n\t * atomic_check is expected to create the dc states. We need to release\n\t * them here, since they were duplicated as part of the suspend\n\t * procedure.\n\t */\n\tfor_each_new_crtc_in_state(dm->cached_state, crtc, new_crtc_state, i) {\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tif (dm_new_crtc_state->stream) {\n\t\t\tWARN_ON(kref_read(&dm_new_crtc_state->stream->refcount) > 1);\n\t\t\tdc_stream_release(dm_new_crtc_state->stream);\n\t\t\tdm_new_crtc_state->stream = NULL;\n\t\t}\n\t}\n\n\tfor_each_new_plane_in_state(dm->cached_state, plane, new_plane_state, i) {\n\t\tdm_new_plane_state = to_dm_plane_state(new_plane_state);\n\t\tif (dm_new_plane_state->dc_state) {\n\t\t\tWARN_ON(kref_read(&dm_new_plane_state->dc_state->refcount) > 1);\n\t\t\tdc_plane_state_release(dm_new_plane_state->dc_state);\n\t\t\tdm_new_plane_state->dc_state = NULL;\n\t\t}\n\t}\n\n\tdrm_atomic_helper_resume(ddev, dm->cached_state);\n\n\tdm->cached_state = NULL;\n\n\tamdgpu_dm_irq_resume_late(adev);\n\n\tamdgpu_dm_smu_write_watermarks_table(adev);\n\n\treturn 0;\n}\n\n/**\n * DOC: DM Lifecycle\n *\n * DM (and consequently DC) is registered in the amdgpu base driver as a IP\n * block. When CONFIG_DRM_AMD_DC is enabled, the DM device IP block is added to\n * the base driver's device list to be initialized and torn down accordingly.\n *\n * The functions to do so are provided as hooks in &struct amd_ip_funcs.\n */\n\nstatic const struct amd_ip_funcs amdgpu_dm_funcs = {\n\t.name = \"dm\",\n\t.early_init = dm_early_init,\n\t.late_init = dm_late_init,\n\t.sw_init = dm_sw_init,\n\t.sw_fini = dm_sw_fini,\n\t.hw_init = dm_hw_init,\n\t.hw_fini = dm_hw_fini,\n\t.suspend = dm_suspend,\n\t.resume = dm_resume,\n\t.is_idle = dm_is_idle,\n\t.wait_for_idle = dm_wait_for_idle,\n\t.check_soft_reset = dm_check_soft_reset,\n\t.soft_reset = dm_soft_reset,\n\t.set_clockgating_state = dm_set_clockgating_state,\n\t.set_powergating_state = dm_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version dm_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_DCE,\n\t.major = 1,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &amdgpu_dm_funcs,\n};\n\n\n/**\n * DOC: atomic\n *\n * *WIP*\n */\n\nstatic const struct drm_mode_config_funcs amdgpu_dm_mode_funcs = {\n\t.fb_create = amdgpu_display_user_framebuffer_create,\n\t.get_format_info = amd_get_format_info,\n\t.output_poll_changed = drm_fb_helper_output_poll_changed,\n\t.atomic_check = amdgpu_dm_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic struct drm_mode_config_helper_funcs amdgpu_dm_mode_config_helperfuncs = {\n\t.atomic_commit_tail = amdgpu_dm_atomic_commit_tail\n};\n\nstatic void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)\n{\n\tu32 max_cll, min_cll, max, min, q, r;\n\tstruct amdgpu_dm_backlight_caps *caps;\n\tstruct amdgpu_display_manager *dm;\n\tstruct drm_connector *conn_base;\n\tstruct amdgpu_device *adev;\n\tstruct dc_link *link = NULL;\n\tstatic const u8 pre_computed_values[] = {\n\t\t50, 51, 52, 53, 55, 56, 57, 58, 59, 61, 62, 63, 65, 66, 68, 69,\n\t\t71, 72, 74, 75, 77, 79, 81, 82, 84, 86, 88, 90, 92, 94, 96, 98};\n\n\tif (!aconnector || !aconnector->dc_link)\n\t\treturn;\n\n\tlink = aconnector->dc_link;\n\tif (link->connector_signal != SIGNAL_TYPE_EDP)\n\t\treturn;\n\n\tconn_base = &aconnector->base;\n\tadev = drm_to_adev(conn_base->dev);\n\tdm = &adev->dm;\n\tcaps = &dm->backlight_caps;\n\tcaps->ext_caps = &aconnector->dc_link->dpcd_sink_ext_caps;\n\tcaps->aux_support = false;\n\tmax_cll = conn_base->hdr_sink_metadata.hdmi_type1.max_cll;\n\tmin_cll = conn_base->hdr_sink_metadata.hdmi_type1.min_cll;\n\n\tif (caps->ext_caps->bits.oled == 1 ||\n\t    caps->ext_caps->bits.sdr_aux_backlight_control == 1 ||\n\t    caps->ext_caps->bits.hdr_aux_backlight_control == 1)\n\t\tcaps->aux_support = true;\n\n\t/* From the specification (CTA-861-G), for calculating the maximum\n\t * luminance we need to use:\n\t *\tLuminance = 50*2**(CV/32)\n\t * Where CV is a one-byte value.\n\t * For calculating this expression we may need float point precision;\n\t * to avoid this complexity level, we take advantage that CV is divided\n\t * by a constant. From the Euclids division algorithm, we know that CV\n\t * can be written as: CV = 32*q + r. Next, we replace CV in the\n\t * Luminance expression and get 50*(2**q)*(2**(r/32)), hence we just\n\t * need to pre-compute the value of r/32. For pre-computing the values\n\t * We just used the following Ruby line:\n\t *\t(0...32).each {|cv| puts (50*2**(cv/32.0)).round}\n\t * The results of the above expressions can be verified at\n\t * pre_computed_values.\n\t */\n\tq = max_cll >> 5;\n\tr = max_cll % 32;\n\tmax = (1 << q) * pre_computed_values[r];\n\n\t// min luminance: maxLum * (CV/255)^2 / 100\n\tq = DIV_ROUND_CLOSEST(min_cll, 255);\n\tmin = max * DIV_ROUND_CLOSEST((q * q), 100);\n\n\tcaps->aux_max_input_signal = max;\n\tcaps->aux_min_input_signal = min;\n}\n\nvoid amdgpu_dm_update_connector_after_detect(\n\t\tstruct amdgpu_dm_connector *aconnector)\n{\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct dc_sink *sink;\n\n\t/* MST handled by drm_mst framework */\n\tif (aconnector->mst_mgr.mst_state == true)\n\t\treturn;\n\n\tsink = aconnector->dc_link->local_sink;\n\tif (sink)\n\t\tdc_sink_retain(sink);\n\n\t/*\n\t * Edid mgmt connector gets first update only in mode_valid hook and then\n\t * the connector sink is set to either fake or physical sink depends on link status.\n\t * Skip if already done during boot.\n\t */\n\tif (aconnector->base.force != DRM_FORCE_UNSPECIFIED\n\t\t\t&& aconnector->dc_em_sink) {\n\n\t\t/*\n\t\t * For S3 resume with headless use eml_sink to fake stream\n\t\t * because on resume connector->sink is set to NULL\n\t\t */\n\t\tmutex_lock(&dev->mode_config.mutex);\n\n\t\tif (sink) {\n\t\t\tif (aconnector->dc_sink) {\n\t\t\t\tamdgpu_dm_update_freesync_caps(connector, NULL);\n\t\t\t\t/*\n\t\t\t\t * retain and release below are used to\n\t\t\t\t * bump up refcount for sink because the link doesn't point\n\t\t\t\t * to it anymore after disconnect, so on next crtc to connector\n\t\t\t\t * reshuffle by UMD we will get into unwanted dc_sink release\n\t\t\t\t */\n\t\t\t\tdc_sink_release(aconnector->dc_sink);\n\t\t\t}\n\t\t\taconnector->dc_sink = sink;\n\t\t\tdc_sink_retain(aconnector->dc_sink);\n\t\t\tamdgpu_dm_update_freesync_caps(connector,\n\t\t\t\t\taconnector->edid);\n\t\t} else {\n\t\t\tamdgpu_dm_update_freesync_caps(connector, NULL);\n\t\t\tif (!aconnector->dc_sink) {\n\t\t\t\taconnector->dc_sink = aconnector->dc_em_sink;\n\t\t\t\tdc_sink_retain(aconnector->dc_sink);\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&dev->mode_config.mutex);\n\n\t\tif (sink)\n\t\t\tdc_sink_release(sink);\n\t\treturn;\n\t}\n\n\t/*\n\t * TODO: temporary guard to look for proper fix\n\t * if this sink is MST sink, we should not do anything\n\t */\n\tif (sink && sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\tdc_sink_release(sink);\n\t\treturn;\n\t}\n\n\tif (aconnector->dc_sink == sink) {\n\t\t/*\n\t\t * We got a DP short pulse (Link Loss, DP CTS, etc...).\n\t\t * Do nothing!!\n\t\t */\n\t\tDRM_DEBUG_DRIVER(\"DCHPD: connector_id=%d: dc_sink didn't change.\\n\",\n\t\t\t\taconnector->connector_id);\n\t\tif (sink)\n\t\t\tdc_sink_release(sink);\n\t\treturn;\n\t}\n\n\tDRM_DEBUG_DRIVER(\"DCHPD: connector_id=%d: Old sink=%p New sink=%p\\n\",\n\t\taconnector->connector_id, aconnector->dc_sink, sink);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\t/*\n\t * 1. Update status of the drm connector\n\t * 2. Send an event and let userspace tell us what to do\n\t */\n\tif (sink) {\n\t\t/*\n\t\t * TODO: check if we still need the S3 mode update workaround.\n\t\t * If yes, put it here.\n\t\t */\n\t\tif (aconnector->dc_sink)\n\t\t\tamdgpu_dm_update_freesync_caps(connector, NULL);\n\n\t\taconnector->dc_sink = sink;\n\t\tdc_sink_retain(aconnector->dc_sink);\n\t\tif (sink->dc_edid.length == 0) {\n\t\t\taconnector->edid = NULL;\n\t\t\tif (aconnector->dc_link->aux_mode) {\n\t\t\t\tdrm_dp_cec_unset_edid(\n\t\t\t\t\t&aconnector->dm_dp_aux.aux);\n\t\t\t}\n\t\t} else {\n\t\t\taconnector->edid =\n\t\t\t\t(struct edid *)sink->dc_edid.raw_edid;\n\n\t\t\tdrm_connector_update_edid_property(connector,\n\t\t\t\t\t\t\t   aconnector->edid);\n\t\t\tdrm_add_edid_modes(connector, aconnector->edid);\n\n\t\t\tif (aconnector->dc_link->aux_mode)\n\t\t\t\tdrm_dp_cec_set_edid(&aconnector->dm_dp_aux.aux,\n\t\t\t\t\t\t    aconnector->edid);\n\t\t}\n\n\t\tamdgpu_dm_update_freesync_caps(connector, aconnector->edid);\n\t\tupdate_connector_ext_caps(aconnector);\n\t} else {\n\t\tdrm_dp_cec_unset_edid(&aconnector->dm_dp_aux.aux);\n\t\tamdgpu_dm_update_freesync_caps(connector, NULL);\n\t\tdrm_connector_update_edid_property(connector, NULL);\n\t\taconnector->num_modes = 0;\n\t\tdc_sink_release(aconnector->dc_sink);\n\t\taconnector->dc_sink = NULL;\n\t\taconnector->edid = NULL;\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\t\t/* Set CP to DESIRED if it was ENABLED, so we can re-enable it again on hotplug */\n\t\tif (connector->state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED)\n\t\t\tconnector->state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n#endif\n\t}\n\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tupdate_subconnector_property(aconnector);\n\n\tif (sink)\n\t\tdc_sink_release(sink);\n}\n\nstatic void handle_hpd_irq(void *param)\n{\n\tstruct amdgpu_dm_connector *aconnector = (struct amdgpu_dm_connector *)param;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dm_connector_state *dm_con_state = to_dm_connector_state(connector->state);\n#endif\n\n\t/*\n\t * In case of failure or MST no need to update connector status or notify the OS\n\t * since (for MST case) MST does this in its own context.\n\t */\n\tmutex_lock(&aconnector->hpd_lock);\n\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tif (adev->dm.hdcp_workqueue) {\n\t\thdcp_reset_display(adev->dm.hdcp_workqueue, aconnector->dc_link->link_index);\n\t\tdm_con_state->update_hdcp = true;\n\t}\n#endif\n\tif (aconnector->fake_enable)\n\t\taconnector->fake_enable = false;\n\n\tif (!dc_link_detect_sink(aconnector->dc_link, &new_connection_type))\n\t\tDRM_ERROR(\"KMS: Failed to detect connector\\n\");\n\n\tif (aconnector->base.force && new_connection_type == dc_connection_none) {\n\t\temulated_link_detect(aconnector->dc_link);\n\n\n\t\tdrm_modeset_lock_all(dev);\n\t\tdm_restore_drm_connector_state(dev, connector);\n\t\tdrm_modeset_unlock_all(dev);\n\n\t\tif (aconnector->base.force == DRM_FORCE_UNSPECIFIED)\n\t\t\tdrm_kms_helper_hotplug_event(dev);\n\n\t} else if (dc_link_detect(aconnector->dc_link, DETECT_REASON_HPD)) {\n\t\tif (new_connection_type == dc_connection_none &&\n\t\t    aconnector->dc_link->type == dc_connection_none)\n\t\t\tdm_set_dpms_off(aconnector->dc_link);\n\n\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\n\t\tdrm_modeset_lock_all(dev);\n\t\tdm_restore_drm_connector_state(dev, connector);\n\t\tdrm_modeset_unlock_all(dev);\n\n\t\tif (aconnector->base.force == DRM_FORCE_UNSPECIFIED)\n\t\t\tdrm_kms_helper_hotplug_event(dev);\n\t}\n\tmutex_unlock(&aconnector->hpd_lock);\n\n}\n\nstatic void dm_handle_hpd_rx_irq(struct amdgpu_dm_connector *aconnector)\n{\n\tuint8_t esi[DP_PSR_ERROR_STATUS - DP_SINK_COUNT_ESI] = { 0 };\n\tuint8_t dret;\n\tbool new_irq_handled = false;\n\tint dpcd_addr;\n\tint dpcd_bytes_to_read;\n\n\tconst int max_process_count = 30;\n\tint process_count = 0;\n\n\tconst struct dc_link_status *link_status = dc_link_get_status(aconnector->dc_link);\n\n\tif (link_status->dpcd_caps->dpcd_rev.raw < 0x12) {\n\t\tdpcd_bytes_to_read = DP_LANE0_1_STATUS - DP_SINK_COUNT;\n\t\t/* DPCD 0x200 - 0x201 for downstream IRQ */\n\t\tdpcd_addr = DP_SINK_COUNT;\n\t} else {\n\t\tdpcd_bytes_to_read = DP_PSR_ERROR_STATUS - DP_SINK_COUNT_ESI;\n\t\t/* DPCD 0x2002 - 0x2005 for downstream IRQ */\n\t\tdpcd_addr = DP_SINK_COUNT_ESI;\n\t}\n\n\tdret = drm_dp_dpcd_read(\n\t\t&aconnector->dm_dp_aux.aux,\n\t\tdpcd_addr,\n\t\tesi,\n\t\tdpcd_bytes_to_read);\n\n\twhile (dret == dpcd_bytes_to_read &&\n\t\tprocess_count < max_process_count) {\n\t\tuint8_t retry;\n\t\tdret = 0;\n\n\t\tprocess_count++;\n\n\t\tDRM_DEBUG_DRIVER(\"ESI %02x %02x %02x\\n\", esi[0], esi[1], esi[2]);\n\t\t/* handle HPD short pulse irq */\n\t\tif (aconnector->mst_mgr.mst_state)\n\t\t\tdrm_dp_mst_hpd_irq(\n\t\t\t\t&aconnector->mst_mgr,\n\t\t\t\tesi,\n\t\t\t\t&new_irq_handled);\n\n\t\tif (new_irq_handled) {\n\t\t\t/* ACK at DPCD to notify down stream */\n\t\t\tconst int ack_dpcd_bytes_to_write =\n\t\t\t\tdpcd_bytes_to_read - 1;\n\n\t\t\tfor (retry = 0; retry < 3; retry++) {\n\t\t\t\tuint8_t wret;\n\n\t\t\t\twret = drm_dp_dpcd_write(\n\t\t\t\t\t&aconnector->dm_dp_aux.aux,\n\t\t\t\t\tdpcd_addr + 1,\n\t\t\t\t\t&esi[1],\n\t\t\t\t\tack_dpcd_bytes_to_write);\n\t\t\t\tif (wret == ack_dpcd_bytes_to_write)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* check if there is new irq to be handled */\n\t\t\tdret = drm_dp_dpcd_read(\n\t\t\t\t&aconnector->dm_dp_aux.aux,\n\t\t\t\tdpcd_addr,\n\t\t\t\tesi,\n\t\t\t\tdpcd_bytes_to_read);\n\n\t\t\tnew_irq_handled = false;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (process_count == max_process_count)\n\t\tDRM_DEBUG_DRIVER(\"Loop exceeded max iterations\\n\");\n}\n\nstatic void handle_hpd_rx_irq(void *param)\n{\n\tstruct amdgpu_dm_connector *aconnector = (struct amdgpu_dm_connector *)param;\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct drm_device *dev = connector->dev;\n\tstruct dc_link *dc_link = aconnector->dc_link;\n\tbool is_mst_root_connector = aconnector->mst_mgr.mst_state;\n\tbool result = false;\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tunion hpd_irq_data hpd_irq_data;\n\n\tmemset(&hpd_irq_data, 0, sizeof(hpd_irq_data));\n\n\t/*\n\t * TODO:Temporary add mutex to protect hpd interrupt not have a gpio\n\t * conflict, after implement i2c helper, this mutex should be\n\t * retired.\n\t */\n\tif (dc_link->type != dc_connection_mst_branch)\n\t\tmutex_lock(&aconnector->hpd_lock);\n\n\tread_hpd_rx_irq_data(dc_link, &hpd_irq_data);\n\n\tif ((dc_link->cur_link_settings.lane_count != LANE_COUNT_UNKNOWN) ||\n\t\t(dc_link->type == dc_connection_mst_branch)) {\n\t\tif (hpd_irq_data.bytes.device_service_irq.bits.UP_REQ_MSG_RDY) {\n\t\t\tresult = true;\n\t\t\tdm_handle_hpd_rx_irq(aconnector);\n\t\t\tgoto out;\n\t\t} else if (hpd_irq_data.bytes.device_service_irq.bits.DOWN_REP_MSG_RDY) {\n\t\t\tresult = false;\n\t\t\tdm_handle_hpd_rx_irq(aconnector);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmutex_lock(&adev->dm.dc_lock);\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tresult = dc_link_handle_hpd_rx_irq(dc_link, &hpd_irq_data, NULL);\n#else\n\tresult = dc_link_handle_hpd_rx_irq(dc_link, NULL, NULL);\n#endif\n\tmutex_unlock(&adev->dm.dc_lock);\n\nout:\n\tif (result && !is_mst_root_connector) {\n\t\t/* Downstream Port status changed. */\n\t\tif (!dc_link_detect_sink(dc_link, &new_connection_type))\n\t\t\tDRM_ERROR(\"KMS: Failed to detect connector\\n\");\n\n\t\tif (aconnector->base.force && new_connection_type == dc_connection_none) {\n\t\t\temulated_link_detect(dc_link);\n\n\t\t\tif (aconnector->fake_enable)\n\t\t\t\taconnector->fake_enable = false;\n\n\t\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\n\n\t\t\tdrm_modeset_lock_all(dev);\n\t\t\tdm_restore_drm_connector_state(dev, connector);\n\t\t\tdrm_modeset_unlock_all(dev);\n\n\t\t\tdrm_kms_helper_hotplug_event(dev);\n\t\t} else if (dc_link_detect(dc_link, DETECT_REASON_HPDRX)) {\n\n\t\t\tif (aconnector->fake_enable)\n\t\t\t\taconnector->fake_enable = false;\n\n\t\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\n\n\t\t\tdrm_modeset_lock_all(dev);\n\t\t\tdm_restore_drm_connector_state(dev, connector);\n\t\t\tdrm_modeset_unlock_all(dev);\n\n\t\t\tdrm_kms_helper_hotplug_event(dev);\n\t\t}\n\t}\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tif (hpd_irq_data.bytes.device_service_irq.bits.CP_IRQ) {\n\t\tif (adev->dm.hdcp_workqueue)\n\t\t\thdcp_handle_cpirq(adev->dm.hdcp_workqueue,  aconnector->base.index);\n\t}\n#endif\n\n\tif (dc_link->type != dc_connection_mst_branch) {\n\t\tdrm_dp_cec_irq(&aconnector->dm_dp_aux.aux);\n\t\tmutex_unlock(&aconnector->hpd_lock);\n\t}\n}\n\nstatic void register_hpd_handlers(struct amdgpu_device *adev)\n{\n\tstruct drm_device *dev = adev_to_drm(adev);\n\tstruct drm_connector *connector;\n\tstruct amdgpu_dm_connector *aconnector;\n\tconst struct dc_link *dc_link;\n\tstruct dc_interrupt_params int_params = {0};\n\n\tint_params.requested_polarity = INTERRUPT_POLARITY_DEFAULT;\n\tint_params.current_polarity = INTERRUPT_POLARITY_DEFAULT;\n\n\tlist_for_each_entry(connector,\n\t\t\t&dev->mode_config.connector_list, head)\t{\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\tdc_link = aconnector->dc_link;\n\n\t\tif (DC_IRQ_SOURCE_INVALID != dc_link->irq_source_hpd) {\n\t\t\tint_params.int_context = INTERRUPT_LOW_IRQ_CONTEXT;\n\t\t\tint_params.irq_source = dc_link->irq_source_hpd;\n\n\t\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\t\thandle_hpd_irq,\n\t\t\t\t\t(void *) aconnector);\n\t\t}\n\n\t\tif (DC_IRQ_SOURCE_INVALID != dc_link->irq_source_hpd_rx) {\n\n\t\t\t/* Also register for DP short pulse (hpd_rx). */\n\t\t\tint_params.int_context = INTERRUPT_LOW_IRQ_CONTEXT;\n\t\t\tint_params.irq_source =\tdc_link->irq_source_hpd_rx;\n\n\t\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\t\thandle_hpd_rx_irq,\n\t\t\t\t\t(void *) aconnector);\n\t\t}\n\t}\n}\n\n#if defined(CONFIG_DRM_AMD_DC_SI)\n/* Register IRQ sources and initialize IRQ callbacks */\nstatic int dce60_register_irq_handlers(struct amdgpu_device *adev)\n{\n\tstruct dc *dc = adev->dm.dc;\n\tstruct common_irq_params *c_irq_params;\n\tstruct dc_interrupt_params int_params = {0};\n\tint r;\n\tint i;\n\tunsigned client_id = AMDGPU_IRQ_CLIENTID_LEGACY;\n\n\tint_params.requested_polarity = INTERRUPT_POLARITY_DEFAULT;\n\tint_params.current_polarity = INTERRUPT_POLARITY_DEFAULT;\n\n\t/*\n\t * Actions of amdgpu_irq_add_id():\n\t * 1. Register a set() function with base driver.\n\t *    Base driver will call set() function to enable/disable an\n\t *    interrupt in DC hardware.\n\t * 2. Register amdgpu_dm_irq_handler().\n\t *    Base driver will call amdgpu_dm_irq_handler() for ALL interrupts\n\t *    coming from DC hardware.\n\t *    amdgpu_dm_irq_handler() will re-direct the interrupt to DC\n\t *    for acknowledging and handling. */\n\n\t/* Use VBLANK interrupt */\n\tfor (i = 0; i < adev->mode_info.num_crtc; i++) {\n\t\tr = amdgpu_irq_add_id(adev, client_id, i+1 , &adev->crtc_irq);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add crtc irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i+1 , 0);\n\n\t\tc_irq_params = &adev->dm.vblank_params[int_params.irq_source - DC_IRQ_SOURCE_VBLANK1];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_crtc_high_irq, c_irq_params);\n\t}\n\n\t/* Use GRPH_PFLIP interrupt */\n\tfor (i = VISLANDS30_IV_SRCID_D1_GRPH_PFLIP;\n\t\t\ti <= VISLANDS30_IV_SRCID_D6_GRPH_PFLIP; i += 2) {\n\t\tr = amdgpu_irq_add_id(adev, client_id, i, &adev->pageflip_irq);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add page flip irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.pflip_params[int_params.irq_source - DC_IRQ_SOURCE_PFLIP_FIRST];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_pflip_high_irq, c_irq_params);\n\n\t}\n\n\t/* HPD */\n\tr = amdgpu_irq_add_id(adev, client_id,\n\t\t\tVISLANDS30_IV_SRCID_HOTPLUG_DETECT_A, &adev->hpd_irq);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to add hpd irq id!\\n\");\n\t\treturn r;\n\t}\n\n\tregister_hpd_handlers(adev);\n\n\treturn 0;\n}\n#endif\n\n/* Register IRQ sources and initialize IRQ callbacks */\nstatic int dce110_register_irq_handlers(struct amdgpu_device *adev)\n{\n\tstruct dc *dc = adev->dm.dc;\n\tstruct common_irq_params *c_irq_params;\n\tstruct dc_interrupt_params int_params = {0};\n\tint r;\n\tint i;\n\tunsigned client_id = AMDGPU_IRQ_CLIENTID_LEGACY;\n\n\tif (adev->asic_type >= CHIP_VEGA10)\n\t\tclient_id = SOC15_IH_CLIENTID_DCE;\n\n\tint_params.requested_polarity = INTERRUPT_POLARITY_DEFAULT;\n\tint_params.current_polarity = INTERRUPT_POLARITY_DEFAULT;\n\n\t/*\n\t * Actions of amdgpu_irq_add_id():\n\t * 1. Register a set() function with base driver.\n\t *    Base driver will call set() function to enable/disable an\n\t *    interrupt in DC hardware.\n\t * 2. Register amdgpu_dm_irq_handler().\n\t *    Base driver will call amdgpu_dm_irq_handler() for ALL interrupts\n\t *    coming from DC hardware.\n\t *    amdgpu_dm_irq_handler() will re-direct the interrupt to DC\n\t *    for acknowledging and handling. */\n\n\t/* Use VBLANK interrupt */\n\tfor (i = VISLANDS30_IV_SRCID_D1_VERTICAL_INTERRUPT0; i <= VISLANDS30_IV_SRCID_D6_VERTICAL_INTERRUPT0; i++) {\n\t\tr = amdgpu_irq_add_id(adev, client_id, i, &adev->crtc_irq);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add crtc irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.vblank_params[int_params.irq_source - DC_IRQ_SOURCE_VBLANK1];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_crtc_high_irq, c_irq_params);\n\t}\n\n\t/* Use VUPDATE interrupt */\n\tfor (i = VISLANDS30_IV_SRCID_D1_V_UPDATE_INT; i <= VISLANDS30_IV_SRCID_D6_V_UPDATE_INT; i += 2) {\n\t\tr = amdgpu_irq_add_id(adev, client_id, i, &adev->vupdate_irq);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add vupdate irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.vupdate_params[int_params.irq_source - DC_IRQ_SOURCE_VUPDATE1];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_vupdate_high_irq, c_irq_params);\n\t}\n\n\t/* Use GRPH_PFLIP interrupt */\n\tfor (i = VISLANDS30_IV_SRCID_D1_GRPH_PFLIP;\n\t\t\ti <= VISLANDS30_IV_SRCID_D6_GRPH_PFLIP; i += 2) {\n\t\tr = amdgpu_irq_add_id(adev, client_id, i, &adev->pageflip_irq);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add page flip irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.pflip_params[int_params.irq_source - DC_IRQ_SOURCE_PFLIP_FIRST];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_pflip_high_irq, c_irq_params);\n\n\t}\n\n\t/* HPD */\n\tr = amdgpu_irq_add_id(adev, client_id,\n\t\t\tVISLANDS30_IV_SRCID_HOTPLUG_DETECT_A, &adev->hpd_irq);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to add hpd irq id!\\n\");\n\t\treturn r;\n\t}\n\n\tregister_hpd_handlers(adev);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n/* Register IRQ sources and initialize IRQ callbacks */\nstatic int dcn10_register_irq_handlers(struct amdgpu_device *adev)\n{\n\tstruct dc *dc = adev->dm.dc;\n\tstruct common_irq_params *c_irq_params;\n\tstruct dc_interrupt_params int_params = {0};\n\tint r;\n\tint i;\n\n\tint_params.requested_polarity = INTERRUPT_POLARITY_DEFAULT;\n\tint_params.current_polarity = INTERRUPT_POLARITY_DEFAULT;\n\n\t/*\n\t * Actions of amdgpu_irq_add_id():\n\t * 1. Register a set() function with base driver.\n\t *    Base driver will call set() function to enable/disable an\n\t *    interrupt in DC hardware.\n\t * 2. Register amdgpu_dm_irq_handler().\n\t *    Base driver will call amdgpu_dm_irq_handler() for ALL interrupts\n\t *    coming from DC hardware.\n\t *    amdgpu_dm_irq_handler() will re-direct the interrupt to DC\n\t *    for acknowledging and handling.\n\t */\n\n\t/* Use VSTARTUP interrupt */\n\tfor (i = DCN_1_0__SRCID__DC_D1_OTG_VSTARTUP;\n\t\t\ti <= DCN_1_0__SRCID__DC_D1_OTG_VSTARTUP + adev->mode_info.num_crtc - 1;\n\t\t\ti++) {\n\t\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_DCE, i, &adev->crtc_irq);\n\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add crtc irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.vblank_params[int_params.irq_source - DC_IRQ_SOURCE_VBLANK1];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(\n\t\t\tadev, &int_params, dm_crtc_high_irq, c_irq_params);\n\t}\n\n\t/* Use VUPDATE_NO_LOCK interrupt on DCN, which seems to correspond to\n\t * the regular VUPDATE interrupt on DCE. We want DC_IRQ_SOURCE_VUPDATEx\n\t * to trigger at end of each vblank, regardless of state of the lock,\n\t * matching DCE behaviour.\n\t */\n\tfor (i = DCN_1_0__SRCID__OTG0_IHC_V_UPDATE_NO_LOCK_INTERRUPT;\n\t     i <= DCN_1_0__SRCID__OTG0_IHC_V_UPDATE_NO_LOCK_INTERRUPT + adev->mode_info.num_crtc - 1;\n\t     i++) {\n\t\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_DCE, i, &adev->vupdate_irq);\n\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add vupdate irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.vupdate_params[int_params.irq_source - DC_IRQ_SOURCE_VUPDATE1];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_vupdate_high_irq, c_irq_params);\n\t}\n\n\t/* Use GRPH_PFLIP interrupt */\n\tfor (i = DCN_1_0__SRCID__HUBP0_FLIP_INTERRUPT;\n\t\t\ti <= DCN_1_0__SRCID__HUBP0_FLIP_INTERRUPT + adev->mode_info.num_crtc - 1;\n\t\t\ti++) {\n\t\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_DCE, i, &adev->pageflip_irq);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to add page flip irq id!\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tint_params.int_context = INTERRUPT_HIGH_IRQ_CONTEXT;\n\t\tint_params.irq_source =\n\t\t\tdc_interrupt_to_irq_source(dc, i, 0);\n\n\t\tc_irq_params = &adev->dm.pflip_params[int_params.irq_source - DC_IRQ_SOURCE_PFLIP_FIRST];\n\n\t\tc_irq_params->adev = adev;\n\t\tc_irq_params->irq_src = int_params.irq_source;\n\n\t\tamdgpu_dm_irq_register_interrupt(adev, &int_params,\n\t\t\t\tdm_pflip_high_irq, c_irq_params);\n\n\t}\n\n\t/* HPD */\n\tr = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_DCE, DCN_1_0__SRCID__DC_HPD1_INT,\n\t\t\t&adev->hpd_irq);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to add hpd irq id!\\n\");\n\t\treturn r;\n\t}\n\n\tregister_hpd_handlers(adev);\n\n\treturn 0;\n}\n#endif\n\n/*\n * Acquires the lock for the atomic state object and returns\n * the new atomic state.\n *\n * This should only be called during atomic check.\n */\nstatic int dm_atomic_get_state(struct drm_atomic_state *state,\n\t\t\t       struct dm_atomic_state **dm_state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct drm_private_state *priv_state;\n\n\tif (*dm_state)\n\t\treturn 0;\n\n\tpriv_state = drm_atomic_get_private_obj_state(state, &dm->atomic_obj);\n\tif (IS_ERR(priv_state))\n\t\treturn PTR_ERR(priv_state);\n\n\t*dm_state = to_dm_atomic_state(priv_state);\n\n\treturn 0;\n}\n\nstatic struct dm_atomic_state *\ndm_atomic_get_new_state(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct drm_private_obj *obj;\n\tstruct drm_private_state *new_obj_state;\n\tint i;\n\n\tfor_each_new_private_obj_in_state(state, obj, new_obj_state, i) {\n\t\tif (obj->funcs == dm->atomic_obj.funcs)\n\t\t\treturn to_dm_atomic_state(new_obj_state);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct drm_private_state *\ndm_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct dm_atomic_state *old_state, *new_state;\n\n\tnew_state = kzalloc(sizeof(*new_state), GFP_KERNEL);\n\tif (!new_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &new_state->base);\n\n\told_state = to_dm_atomic_state(obj->state);\n\n\tif (old_state && old_state->context)\n\t\tnew_state->context = dc_copy_state(old_state->context);\n\n\tif (!new_state->context) {\n\t\tkfree(new_state);\n\t\treturn NULL;\n\t}\n\n\treturn &new_state->base;\n}\n\nstatic void dm_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t    struct drm_private_state *state)\n{\n\tstruct dm_atomic_state *dm_state = to_dm_atomic_state(state);\n\n\tif (dm_state && dm_state->context)\n\t\tdc_release_state(dm_state->context);\n\n\tkfree(dm_state);\n}\n\nstatic struct drm_private_state_funcs dm_atomic_state_funcs = {\n\t.atomic_duplicate_state = dm_atomic_duplicate_state,\n\t.atomic_destroy_state = dm_atomic_destroy_state,\n};\n\nstatic int amdgpu_dm_mode_config_init(struct amdgpu_device *adev)\n{\n\tstruct dm_atomic_state *state;\n\tint r;\n\n\tadev->mode_info.mode_config_initialized = true;\n\n\tadev_to_drm(adev)->mode_config.funcs = (void *)&amdgpu_dm_mode_funcs;\n\tadev_to_drm(adev)->mode_config.helper_private = &amdgpu_dm_mode_config_helperfuncs;\n\n\tadev_to_drm(adev)->mode_config.max_width = 16384;\n\tadev_to_drm(adev)->mode_config.max_height = 16384;\n\n\tadev_to_drm(adev)->mode_config.preferred_depth = 24;\n\tadev_to_drm(adev)->mode_config.prefer_shadow = 1;\n\t/* indicates support for immediate flip */\n\tadev_to_drm(adev)->mode_config.async_page_flip = true;\n\n\tadev_to_drm(adev)->mode_config.fb_base = adev->gmc.aper_base;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->context = dc_create_state(adev->dm.dc);\n\tif (!state->context) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\n\tdc_resource_state_copy_construct_current(adev->dm.dc, state->context);\n\n\tdrm_atomic_private_obj_init(adev_to_drm(adev),\n\t\t\t\t    &adev->dm.atomic_obj,\n\t\t\t\t    &state->base,\n\t\t\t\t    &dm_atomic_state_funcs);\n\n\tr = amdgpu_display_modeset_create_props(adev);\n\tif (r) {\n\t\tdc_release_state(state->context);\n\t\tkfree(state);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_dm_audio_init(adev);\n\tif (r) {\n\t\tdc_release_state(state->context);\n\t\tkfree(state);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n#define AMDGPU_DM_DEFAULT_MIN_BACKLIGHT 12\n#define AMDGPU_DM_DEFAULT_MAX_BACKLIGHT 255\n#define AUX_BL_DEFAULT_TRANSITION_TIME_MS 50\n\n#if defined(CONFIG_BACKLIGHT_CLASS_DEVICE) ||\\\n\tdefined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE)\n\nstatic void amdgpu_dm_update_backlight_caps(struct amdgpu_display_manager *dm)\n{\n#if defined(CONFIG_ACPI)\n\tstruct amdgpu_dm_backlight_caps caps;\n\n\tmemset(&caps, 0, sizeof(caps));\n\n\tif (dm->backlight_caps.caps_valid)\n\t\treturn;\n\n\tamdgpu_acpi_get_backlight_caps(dm->adev, &caps);\n\tif (caps.caps_valid) {\n\t\tdm->backlight_caps.caps_valid = true;\n\t\tif (caps.aux_support)\n\t\t\treturn;\n\t\tdm->backlight_caps.min_input_signal = caps.min_input_signal;\n\t\tdm->backlight_caps.max_input_signal = caps.max_input_signal;\n\t} else {\n\t\tdm->backlight_caps.min_input_signal =\n\t\t\t\tAMDGPU_DM_DEFAULT_MIN_BACKLIGHT;\n\t\tdm->backlight_caps.max_input_signal =\n\t\t\t\tAMDGPU_DM_DEFAULT_MAX_BACKLIGHT;\n\t}\n#else\n\tif (dm->backlight_caps.aux_support)\n\t\treturn;\n\n\tdm->backlight_caps.min_input_signal = AMDGPU_DM_DEFAULT_MIN_BACKLIGHT;\n\tdm->backlight_caps.max_input_signal = AMDGPU_DM_DEFAULT_MAX_BACKLIGHT;\n#endif\n}\n\nstatic int set_backlight_via_aux(struct dc_link *link, uint32_t brightness)\n{\n\tbool rc;\n\n\tif (!link)\n\t\treturn 1;\n\n\trc = dc_link_set_backlight_level_nits(link, true, brightness,\n\t\t\t\t\t      AUX_BL_DEFAULT_TRANSITION_TIME_MS);\n\n\treturn rc ? 0 : 1;\n}\n\nstatic int get_brightness_range(const struct amdgpu_dm_backlight_caps *caps,\n\t\t\t\tunsigned *min, unsigned *max)\n{\n\tif (!caps)\n\t\treturn 0;\n\n\tif (caps->aux_support) {\n\t\t// Firmware limits are in nits, DC API wants millinits.\n\t\t*max = 1000 * caps->aux_max_input_signal;\n\t\t*min = 1000 * caps->aux_min_input_signal;\n\t} else {\n\t\t// Firmware limits are 8-bit, PWM control is 16-bit.\n\t\t*max = 0x101 * caps->max_input_signal;\n\t\t*min = 0x101 * caps->min_input_signal;\n\t}\n\treturn 1;\n}\n\nstatic u32 convert_brightness_from_user(const struct amdgpu_dm_backlight_caps *caps,\n\t\t\t\t\tuint32_t brightness)\n{\n\tunsigned min, max;\n\n\tif (!get_brightness_range(caps, &min, &max))\n\t\treturn brightness;\n\n\t// Rescale 0..255 to min..max\n\treturn min + DIV_ROUND_CLOSEST((max - min) * brightness,\n\t\t\t\t       AMDGPU_MAX_BL_LEVEL);\n}\n\nstatic u32 convert_brightness_to_user(const struct amdgpu_dm_backlight_caps *caps,\n\t\t\t\t      uint32_t brightness)\n{\n\tunsigned min, max;\n\n\tif (!get_brightness_range(caps, &min, &max))\n\t\treturn brightness;\n\n\tif (brightness < min)\n\t\treturn 0;\n\t// Rescale min..max to 0..255\n\treturn DIV_ROUND_CLOSEST(AMDGPU_MAX_BL_LEVEL * (brightness - min),\n\t\t\t\t max - min);\n}\n\nstatic int amdgpu_dm_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct amdgpu_display_manager *dm = bl_get_data(bd);\n\tstruct amdgpu_dm_backlight_caps caps;\n\tstruct dc_link *link = NULL;\n\tu32 brightness;\n\tbool rc;\n\n\tamdgpu_dm_update_backlight_caps(dm);\n\tcaps = dm->backlight_caps;\n\n\tlink = (struct dc_link *)dm->backlight_link;\n\n\tbrightness = convert_brightness_from_user(&caps, bd->props.brightness);\n\t// Change brightness based on AUX property\n\tif (caps.aux_support)\n\t\treturn set_backlight_via_aux(link, brightness);\n\n\trc = dc_link_set_backlight_level(dm->backlight_link, brightness, 0);\n\n\treturn rc ? 0 : 1;\n}\n\nstatic int amdgpu_dm_backlight_get_brightness(struct backlight_device *bd)\n{\n\tstruct amdgpu_display_manager *dm = bl_get_data(bd);\n\tint ret = dc_link_get_backlight_level(dm->backlight_link);\n\n\tif (ret == DC_ERROR_UNEXPECTED)\n\t\treturn bd->props.brightness;\n\treturn convert_brightness_to_user(&dm->backlight_caps, ret);\n}\n\nstatic const struct backlight_ops amdgpu_dm_backlight_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.get_brightness = amdgpu_dm_backlight_get_brightness,\n\t.update_status\t= amdgpu_dm_backlight_update_status,\n};\n\nstatic void\namdgpu_dm_register_backlight_device(struct amdgpu_display_manager *dm)\n{\n\tchar bl_name[16];\n\tstruct backlight_properties props = { 0 };\n\n\tamdgpu_dm_update_backlight_caps(dm);\n\n\tprops.max_brightness = AMDGPU_MAX_BL_LEVEL;\n\tprops.brightness = AMDGPU_MAX_BL_LEVEL;\n\tprops.type = BACKLIGHT_RAW;\n\n\tsnprintf(bl_name, sizeof(bl_name), \"amdgpu_bl%d\",\n\t\t adev_to_drm(dm->adev)->primary->index);\n\n\tdm->backlight_dev = backlight_device_register(bl_name,\n\t\t\t\t\t\t      adev_to_drm(dm->adev)->dev,\n\t\t\t\t\t\t      dm,\n\t\t\t\t\t\t      &amdgpu_dm_backlight_ops,\n\t\t\t\t\t\t      &props);\n\n\tif (IS_ERR(dm->backlight_dev))\n\t\tDRM_ERROR(\"DM: Backlight registration failed!\\n\");\n\telse\n\t\tDRM_DEBUG_DRIVER(\"DM: Registered Backlight device: %s\\n\", bl_name);\n}\n\n#endif\n\nstatic int initialize_plane(struct amdgpu_display_manager *dm,\n\t\t\t    struct amdgpu_mode_info *mode_info, int plane_id,\n\t\t\t    enum drm_plane_type plane_type,\n\t\t\t    const struct dc_plane_cap *plane_cap)\n{\n\tstruct drm_plane *plane;\n\tunsigned long possible_crtcs;\n\tint ret = 0;\n\n\tplane = kzalloc(sizeof(struct drm_plane), GFP_KERNEL);\n\tif (!plane) {\n\t\tDRM_ERROR(\"KMS: Failed to allocate plane\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplane->type = plane_type;\n\n\t/*\n\t * HACK: IGT tests expect that the primary plane for a CRTC\n\t * can only have one possible CRTC. Only expose support for\n\t * any CRTC if they're not going to be used as a primary plane\n\t * for a CRTC - like overlay or underlay planes.\n\t */\n\tpossible_crtcs = 1 << plane_id;\n\tif (plane_id >= dm->dc->caps.max_streams)\n\t\tpossible_crtcs = 0xff;\n\n\tret = amdgpu_dm_plane_init(dm, plane, possible_crtcs, plane_cap);\n\n\tif (ret) {\n\t\tDRM_ERROR(\"KMS: Failed to initialize plane\\n\");\n\t\tkfree(plane);\n\t\treturn ret;\n\t}\n\n\tif (mode_info)\n\t\tmode_info->planes[plane_id] = plane;\n\n\treturn ret;\n}\n\n\nstatic void register_backlight_device(struct amdgpu_display_manager *dm,\n\t\t\t\t      struct dc_link *link)\n{\n#if defined(CONFIG_BACKLIGHT_CLASS_DEVICE) ||\\\n\tdefined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE)\n\n\tif ((link->connector_signal & (SIGNAL_TYPE_EDP | SIGNAL_TYPE_LVDS)) &&\n\t    link->type != dc_connection_none) {\n\t\t/*\n\t\t * Event if registration failed, we should continue with\n\t\t * DM initialization because not having a backlight control\n\t\t * is better then a black screen.\n\t\t */\n\t\tamdgpu_dm_register_backlight_device(dm);\n\n\t\tif (dm->backlight_dev)\n\t\t\tdm->backlight_link = link;\n\t}\n#endif\n}\n\n\n/*\n * In this architecture, the association\n * connector -> encoder -> crtc\n * id not really requried. The crtc and connector will hold the\n * display_index as an abstraction to use with DAL component\n *\n * Returns 0 on success\n */\nstatic int amdgpu_dm_initialize_drm_device(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tint32_t i;\n\tstruct amdgpu_dm_connector *aconnector = NULL;\n\tstruct amdgpu_encoder *aencoder = NULL;\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tuint32_t link_cnt;\n\tint32_t primary_planes;\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n\tconst struct dc_plane_cap *plane;\n\n\tdm->display_indexes_num = dm->dc->caps.max_streams;\n\t/* Update the actual used number of crtc */\n\tadev->mode_info.num_crtc = adev->dm.display_indexes_num;\n\n\tlink_cnt = dm->dc->caps.max_links;\n\tif (amdgpu_dm_mode_config_init(dm->adev)) {\n\t\tDRM_ERROR(\"DM: Failed to initialize mode config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* There is one primary plane per CRTC */\n\tprimary_planes = dm->dc->caps.max_streams;\n\tASSERT(primary_planes <= AMDGPU_MAX_PLANES);\n\n\t/*\n\t * Initialize primary planes, implicit planes for legacy IOCTLS.\n\t * Order is reversed to match iteration order in atomic check.\n\t */\n\tfor (i = (primary_planes - 1); i >= 0; i--) {\n\t\tplane = &dm->dc->caps.planes[i];\n\n\t\tif (initialize_plane(dm, mode_info, i,\n\t\t\t\t     DRM_PLANE_TYPE_PRIMARY, plane)) {\n\t\t\tDRM_ERROR(\"KMS: Failed to initialize primary plane\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Initialize overlay planes, index starting after primary planes.\n\t * These planes have a higher DRM index than the primary planes since\n\t * they should be considered as having a higher z-order.\n\t * Order is reversed to match iteration order in atomic check.\n\t *\n\t * Only support DCN for now, and only expose one so we don't encourage\n\t * userspace to use up all the pipes.\n\t */\n\tfor (i = 0; i < dm->dc->caps.max_planes; ++i) {\n\t\tstruct dc_plane_cap *plane = &dm->dc->caps.planes[i];\n\n\t\tif (plane->type != DC_PLANE_TYPE_DCN_UNIVERSAL)\n\t\t\tcontinue;\n\n\t\tif (!plane->blends_with_above || !plane->blends_with_below)\n\t\t\tcontinue;\n\n\t\tif (!plane->pixel_format_support.argb8888)\n\t\t\tcontinue;\n\n\t\tif (initialize_plane(dm, NULL, primary_planes + i,\n\t\t\t\t     DRM_PLANE_TYPE_OVERLAY, plane)) {\n\t\t\tDRM_ERROR(\"KMS: Failed to initialize overlay plane\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* Only create one overlay plane. */\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < dm->dc->caps.max_streams; i++)\n\t\tif (amdgpu_dm_crtc_init(dm, mode_info->planes[i], i)) {\n\t\t\tDRM_ERROR(\"KMS: Failed to initialize crtc\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t/* loops over all connectors on the board */\n\tfor (i = 0; i < link_cnt; i++) {\n\t\tstruct dc_link *link = NULL;\n\n\t\tif (i > AMDGPU_DM_MAX_DISPLAY_INDEX) {\n\t\t\tDRM_ERROR(\n\t\t\t\t\"KMS: Cannot support more than %d display indexes\\n\",\n\t\t\t\t\tAMDGPU_DM_MAX_DISPLAY_INDEX);\n\t\t\tcontinue;\n\t\t}\n\n\t\taconnector = kzalloc(sizeof(*aconnector), GFP_KERNEL);\n\t\tif (!aconnector)\n\t\t\tgoto fail;\n\n\t\taencoder = kzalloc(sizeof(*aencoder), GFP_KERNEL);\n\t\tif (!aencoder)\n\t\t\tgoto fail;\n\n\t\tif (amdgpu_dm_encoder_init(dm->ddev, aencoder, i)) {\n\t\t\tDRM_ERROR(\"KMS: Failed to initialize encoder\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (amdgpu_dm_connector_init(dm, aconnector, i, aencoder)) {\n\t\t\tDRM_ERROR(\"KMS: Failed to initialize connector\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlink = dc_get_link_at_index(dm->dc, i);\n\n\t\tif (!dc_link_detect_sink(link, &new_connection_type))\n\t\t\tDRM_ERROR(\"KMS: Failed to detect connector\\n\");\n\n\t\tif (aconnector->base.force && new_connection_type == dc_connection_none) {\n\t\t\temulated_link_detect(link);\n\t\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\n\t\t} else if (dc_link_detect(link, DETECT_REASON_BOOT)) {\n\t\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\t\t\tregister_backlight_device(dm, link);\n\t\t\tif (amdgpu_dc_feature_mask & DC_PSR_MASK)\n\t\t\t\tamdgpu_dm_set_psr_caps(link);\n\t\t}\n\n\n\t}\n\n\t/* Software is initialized. Now we can register interrupt handlers. */\n\tswitch (adev->asic_type) {\n#if defined(CONFIG_DRM_AMD_DC_SI)\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\tcase CHIP_OLAND:\n\t\tif (dce60_register_irq_handlers(dm->adev)) {\n\t\t\tDRM_ERROR(\"DM: Failed to initialize IRQ\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n#endif\n\tcase CHIP_BONAIRE:\n\tcase CHIP_HAWAII:\n\tcase CHIP_KAVERI:\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\tcase CHIP_TONGA:\n\tcase CHIP_FIJI:\n\tcase CHIP_CARRIZO:\n\tcase CHIP_STONEY:\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS10:\n\tcase CHIP_POLARIS12:\n\tcase CHIP_VEGAM:\n\tcase CHIP_VEGA10:\n\tcase CHIP_VEGA12:\n\tcase CHIP_VEGA20:\n\t\tif (dce110_register_irq_handlers(dm->adev)) {\n\t\t\tDRM_ERROR(\"DM: Failed to initialize IRQ\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tcase CHIP_RAVEN:\n\tcase CHIP_NAVI12:\n\tcase CHIP_NAVI10:\n\tcase CHIP_NAVI14:\n\tcase CHIP_RENOIR:\n\tcase CHIP_SIENNA_CICHLID:\n\tcase CHIP_NAVY_FLOUNDER:\n\tcase CHIP_DIMGREY_CAVEFISH:\n\tcase CHIP_VANGOGH:\n\t\tif (dcn10_register_irq_handlers(dm->adev)) {\n\t\t\tDRM_ERROR(\"DM: Failed to initialize IRQ\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported ASIC type: 0x%X\\n\", adev->asic_type);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tkfree(aencoder);\n\tkfree(aconnector);\n\n\treturn -EINVAL;\n}\n\nstatic void amdgpu_dm_destroy_drm_device(struct amdgpu_display_manager *dm)\n{\n\tdrm_mode_config_cleanup(dm->ddev);\n\tdrm_atomic_private_obj_fini(&dm->atomic_obj);\n\treturn;\n}\n\n/******************************************************************************\n * amdgpu_display_funcs functions\n *****************************************************************************/\n\n/*\n * dm_bandwidth_update - program display watermarks\n *\n * @adev: amdgpu_device pointer\n *\n * Calculate and program the display watermarks and line buffer allocation.\n */\nstatic void dm_bandwidth_update(struct amdgpu_device *adev)\n{\n\t/* TODO: implement later */\n}\n\nstatic const struct amdgpu_display_funcs dm_display_funcs = {\n\t.bandwidth_update = dm_bandwidth_update, /* called unconditionally */\n\t.vblank_get_counter = dm_vblank_get_counter,/* called unconditionally */\n\t.backlight_set_level = NULL, /* never called for DC */\n\t.backlight_get_level = NULL, /* never called for DC */\n\t.hpd_sense = NULL,/* called unconditionally */\n\t.hpd_set_polarity = NULL, /* called unconditionally */\n\t.hpd_get_gpio_reg = NULL, /* VBIOS parsing. DAL does it. */\n\t.page_flip_get_scanoutpos =\n\t\tdm_crtc_get_scanoutpos,/* called unconditionally */\n\t.add_encoder = NULL, /* VBIOS parsing. DAL does it. */\n\t.add_connector = NULL, /* VBIOS parsing. DAL does it. */\n};\n\n#if defined(CONFIG_DEBUG_KERNEL_DC)\n\nstatic ssize_t s3_debug_store(struct device *device,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf,\n\t\t\t      size_t count)\n{\n\tint ret;\n\tint s3_state;\n\tstruct drm_device *drm_dev = dev_get_drvdata(device);\n\tstruct amdgpu_device *adev = drm_to_adev(drm_dev);\n\n\tret = kstrtoint(buf, 0, &s3_state);\n\n\tif (ret == 0) {\n\t\tif (s3_state) {\n\t\t\tdm_resume(adev);\n\t\t\tdrm_kms_helper_hotplug_event(adev_to_drm(adev));\n\t\t} else\n\t\t\tdm_suspend(adev);\n\t}\n\n\treturn ret == 0 ? count : 0;\n}\n\nDEVICE_ATTR_WO(s3_debug);\n\n#endif\n\nstatic int dm_early_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tswitch (adev->asic_type) {\n#if defined(CONFIG_DRM_AMD_DC_SI)\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\t\tadev->mode_info.num_crtc = 6;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 6;\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\tadev->mode_info.num_crtc = 2;\n\t\tadev->mode_info.num_hpd = 2;\n\t\tadev->mode_info.num_dig = 2;\n\t\tbreak;\n#endif\n\tcase CHIP_BONAIRE:\n\tcase CHIP_HAWAII:\n\t\tadev->mode_info.num_crtc = 6;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 6;\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tadev->mode_info.num_crtc = 4;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 7;\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\t\tadev->mode_info.num_crtc = 2;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 6;\n\t\tbreak;\n\tcase CHIP_FIJI:\n\tcase CHIP_TONGA:\n\t\tadev->mode_info.num_crtc = 6;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 7;\n\t\tbreak;\n\tcase CHIP_CARRIZO:\n\t\tadev->mode_info.num_crtc = 3;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 9;\n\t\tbreak;\n\tcase CHIP_STONEY:\n\t\tadev->mode_info.num_crtc = 2;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 9;\n\t\tbreak;\n\tcase CHIP_POLARIS11:\n\tcase CHIP_POLARIS12:\n\t\tadev->mode_info.num_crtc = 5;\n\t\tadev->mode_info.num_hpd = 5;\n\t\tadev->mode_info.num_dig = 5;\n\t\tbreak;\n\tcase CHIP_POLARIS10:\n\tcase CHIP_VEGAM:\n\t\tadev->mode_info.num_crtc = 6;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 6;\n\t\tbreak;\n\tcase CHIP_VEGA10:\n\tcase CHIP_VEGA12:\n\tcase CHIP_VEGA20:\n\t\tadev->mode_info.num_crtc = 6;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 6;\n\t\tbreak;\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tcase CHIP_RAVEN:\n\tcase CHIP_RENOIR:\n\tcase CHIP_VANGOGH:\n\t\tadev->mode_info.num_crtc = 4;\n\t\tadev->mode_info.num_hpd = 4;\n\t\tadev->mode_info.num_dig = 4;\n\t\tbreak;\n\tcase CHIP_NAVI10:\n\tcase CHIP_NAVI12:\n\tcase CHIP_SIENNA_CICHLID:\n\tcase CHIP_NAVY_FLOUNDER:\n\t\tadev->mode_info.num_crtc = 6;\n\t\tadev->mode_info.num_hpd = 6;\n\t\tadev->mode_info.num_dig = 6;\n\t\tbreak;\n\tcase CHIP_NAVI14:\n\tcase CHIP_DIMGREY_CAVEFISH:\n\t\tadev->mode_info.num_crtc = 5;\n\t\tadev->mode_info.num_hpd = 5;\n\t\tadev->mode_info.num_dig = 5;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported ASIC type: 0x%X\\n\", adev->asic_type);\n\t\treturn -EINVAL;\n\t}\n\n\tamdgpu_dm_set_irq_funcs(adev);\n\n\tif (adev->mode_info.funcs == NULL)\n\t\tadev->mode_info.funcs = &dm_display_funcs;\n\n\t/*\n\t * Note: Do NOT change adev->audio_endpt_rreg and\n\t * adev->audio_endpt_wreg because they are initialised in\n\t * amdgpu_device_init()\n\t */\n#if defined(CONFIG_DEBUG_KERNEL_DC)\n\tdevice_create_file(\n\t\tadev_to_drm(adev)->dev,\n\t\t&dev_attr_s3_debug);\n#endif\n\n\treturn 0;\n}\n\nstatic bool modeset_required(struct drm_crtc_state *crtc_state,\n\t\t\t     struct dc_stream_state *new_stream,\n\t\t\t     struct dc_stream_state *old_stream)\n{\n\treturn crtc_state->active && drm_atomic_crtc_needs_modeset(crtc_state);\n}\n\nstatic bool modereset_required(struct drm_crtc_state *crtc_state)\n{\n\treturn !crtc_state->active && drm_atomic_crtc_needs_modeset(crtc_state);\n}\n\nstatic void amdgpu_dm_encoder_destroy(struct drm_encoder *encoder)\n{\n\tdrm_encoder_cleanup(encoder);\n\tkfree(encoder);\n}\n\nstatic const struct drm_encoder_funcs amdgpu_dm_encoder_funcs = {\n\t.destroy = amdgpu_dm_encoder_destroy,\n};\n\n\nstatic void get_min_max_dc_plane_scaling(struct drm_device *dev,\n\t\t\t\t\t struct drm_framebuffer *fb,\n\t\t\t\t\t int *min_downscale, int *max_upscale)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dc *dc = adev->dm.dc;\n\t/* Caps for all supported planes are the same on DCE and DCN 1 - 3 */\n\tstruct dc_plane_cap *plane_cap = &dc->caps.planes[0];\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_NV21:\n\t\t*max_upscale = plane_cap->max_upscale_factor.nv12;\n\t\t*min_downscale = plane_cap->max_downscale_factor.nv12;\n\t\tbreak;\n\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\t*max_upscale = plane_cap->max_upscale_factor.fp16;\n\t\t*min_downscale = plane_cap->max_downscale_factor.fp16;\n\t\tbreak;\n\n\tdefault:\n\t\t*max_upscale = plane_cap->max_upscale_factor.argb8888;\n\t\t*min_downscale = plane_cap->max_downscale_factor.argb8888;\n\t\tbreak;\n\t}\n\n\t/*\n\t * A factor of 1 in the plane_cap means to not allow scaling, ie. use a\n\t * scaling factor of 1.0 == 1000 units.\n\t */\n\tif (*max_upscale == 1)\n\t\t*max_upscale = 1000;\n\n\tif (*min_downscale == 1)\n\t\t*min_downscale = 1000;\n}\n\n\nstatic int fill_dc_scaling_info(const struct drm_plane_state *state,\n\t\t\t\tstruct dc_scaling_info *scaling_info)\n{\n\tint scale_w, scale_h, min_downscale, max_upscale;\n\n\tmemset(scaling_info, 0, sizeof(*scaling_info));\n\n\t/* Source is fixed 16.16 but we ignore mantissa for now... */\n\tscaling_info->src_rect.x = state->src_x >> 16;\n\tscaling_info->src_rect.y = state->src_y >> 16;\n\n\tscaling_info->src_rect.width = state->src_w >> 16;\n\tif (scaling_info->src_rect.width == 0)\n\t\treturn -EINVAL;\n\n\tscaling_info->src_rect.height = state->src_h >> 16;\n\tif (scaling_info->src_rect.height == 0)\n\t\treturn -EINVAL;\n\n\tscaling_info->dst_rect.x = state->crtc_x;\n\tscaling_info->dst_rect.y = state->crtc_y;\n\n\tif (state->crtc_w == 0)\n\t\treturn -EINVAL;\n\n\tscaling_info->dst_rect.width = state->crtc_w;\n\n\tif (state->crtc_h == 0)\n\t\treturn -EINVAL;\n\n\tscaling_info->dst_rect.height = state->crtc_h;\n\n\t/* DRM doesn't specify clipping on destination output. */\n\tscaling_info->clip_rect = scaling_info->dst_rect;\n\n\t/* Validate scaling per-format with DC plane caps */\n\tif (state->plane && state->plane->dev && state->fb) {\n\t\tget_min_max_dc_plane_scaling(state->plane->dev, state->fb,\n\t\t\t\t\t     &min_downscale, &max_upscale);\n\t} else {\n\t\tmin_downscale = 250;\n\t\tmax_upscale = 16000;\n\t}\n\n\tscale_w = scaling_info->dst_rect.width * 1000 /\n\t\t  scaling_info->src_rect.width;\n\n\tif (scale_w < min_downscale || scale_w > max_upscale)\n\t\treturn -EINVAL;\n\n\tscale_h = scaling_info->dst_rect.height * 1000 /\n\t\t  scaling_info->src_rect.height;\n\n\tif (scale_h < min_downscale || scale_h > max_upscale)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The \"scaling_quality\" can be ignored for now, quality = 0 has DC\n\t * assume reasonable defaults based on the format.\n\t */\n\n\treturn 0;\n}\n\nstatic void\nfill_gfx8_tiling_info_from_flags(union dc_tiling_info *tiling_info,\n\t\t\t\t uint64_t tiling_flags)\n{\n\t/* Fill GFX8 params */\n\tif (AMDGPU_TILING_GET(tiling_flags, ARRAY_MODE) == DC_ARRAY_2D_TILED_THIN1) {\n\t\tunsigned int bankw, bankh, mtaspect, tile_split, num_banks;\n\n\t\tbankw = AMDGPU_TILING_GET(tiling_flags, BANK_WIDTH);\n\t\tbankh = AMDGPU_TILING_GET(tiling_flags, BANK_HEIGHT);\n\t\tmtaspect = AMDGPU_TILING_GET(tiling_flags, MACRO_TILE_ASPECT);\n\t\ttile_split = AMDGPU_TILING_GET(tiling_flags, TILE_SPLIT);\n\t\tnum_banks = AMDGPU_TILING_GET(tiling_flags, NUM_BANKS);\n\n\t\t/* XXX fix me for VI */\n\t\ttiling_info->gfx8.num_banks = num_banks;\n\t\ttiling_info->gfx8.array_mode =\n\t\t\t\tDC_ARRAY_2D_TILED_THIN1;\n\t\ttiling_info->gfx8.tile_split = tile_split;\n\t\ttiling_info->gfx8.bank_width = bankw;\n\t\ttiling_info->gfx8.bank_height = bankh;\n\t\ttiling_info->gfx8.tile_aspect = mtaspect;\n\t\ttiling_info->gfx8.tile_mode =\n\t\t\t\tDC_ADDR_SURF_MICRO_TILING_DISPLAY;\n\t} else if (AMDGPU_TILING_GET(tiling_flags, ARRAY_MODE)\n\t\t\t== DC_ARRAY_1D_TILED_THIN1) {\n\t\ttiling_info->gfx8.array_mode = DC_ARRAY_1D_TILED_THIN1;\n\t}\n\n\ttiling_info->gfx8.pipe_config =\n\t\t\tAMDGPU_TILING_GET(tiling_flags, PIPE_CONFIG);\n}\n\nstatic void\nfill_gfx9_tiling_info_from_device(const struct amdgpu_device *adev,\n\t\t\t\t  union dc_tiling_info *tiling_info)\n{\n\ttiling_info->gfx9.num_pipes =\n\t\tadev->gfx.config.gb_addr_config_fields.num_pipes;\n\ttiling_info->gfx9.num_banks =\n\t\tadev->gfx.config.gb_addr_config_fields.num_banks;\n\ttiling_info->gfx9.pipe_interleave =\n\t\tadev->gfx.config.gb_addr_config_fields.pipe_interleave_size;\n\ttiling_info->gfx9.num_shader_engines =\n\t\tadev->gfx.config.gb_addr_config_fields.num_se;\n\ttiling_info->gfx9.max_compressed_frags =\n\t\tadev->gfx.config.gb_addr_config_fields.max_compress_frags;\n\ttiling_info->gfx9.num_rb_per_se =\n\t\tadev->gfx.config.gb_addr_config_fields.num_rb_per_se;\n\ttiling_info->gfx9.shaderEnable = 1;\n\tif (adev->asic_type == CHIP_SIENNA_CICHLID ||\n\t    adev->asic_type == CHIP_NAVY_FLOUNDER ||\n\t    adev->asic_type == CHIP_DIMGREY_CAVEFISH ||\n\t    adev->asic_type == CHIP_VANGOGH)\n\t\ttiling_info->gfx9.num_pkrs = adev->gfx.config.gb_addr_config_fields.num_pkrs;\n}\n\nstatic int\nvalidate_dcc(struct amdgpu_device *adev,\n\t     const enum surface_pixel_format format,\n\t     const enum dc_rotation_angle rotation,\n\t     const union dc_tiling_info *tiling_info,\n\t     const struct dc_plane_dcc_param *dcc,\n\t     const struct dc_plane_address *address,\n\t     const struct plane_size *plane_size)\n{\n\tstruct dc *dc = adev->dm.dc;\n\tstruct dc_dcc_surface_param input;\n\tstruct dc_surface_dcc_cap output;\n\n\tmemset(&input, 0, sizeof(input));\n\tmemset(&output, 0, sizeof(output));\n\n\tif (!dcc->enable)\n\t\treturn 0;\n\n\tif (format >= SURFACE_PIXEL_FORMAT_VIDEO_BEGIN ||\n\t    !dc->cap_funcs.get_dcc_compression_cap)\n\t\treturn -EINVAL;\n\n\tinput.format = format;\n\tinput.surface_size.width = plane_size->surface_size.width;\n\tinput.surface_size.height = plane_size->surface_size.height;\n\tinput.swizzle_mode = tiling_info->gfx9.swizzle;\n\n\tif (rotation == ROTATION_ANGLE_0 || rotation == ROTATION_ANGLE_180)\n\t\tinput.scan = SCAN_DIRECTION_HORIZONTAL;\n\telse if (rotation == ROTATION_ANGLE_90 || rotation == ROTATION_ANGLE_270)\n\t\tinput.scan = SCAN_DIRECTION_VERTICAL;\n\n\tif (!dc->cap_funcs.get_dcc_compression_cap(dc, &input, &output))\n\t\treturn -EINVAL;\n\n\tif (!output.capable)\n\t\treturn -EINVAL;\n\n\tif (dcc->independent_64b_blks == 0 &&\n\t    output.grph.rgb.independent_64b_blks != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic bool\nmodifier_has_dcc(uint64_t modifier)\n{\n\treturn IS_AMD_FMT_MOD(modifier) && AMD_FMT_MOD_GET(DCC, modifier);\n}\n\nstatic unsigned\nmodifier_gfx9_swizzle_mode(uint64_t modifier)\n{\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn 0;\n\n\treturn AMD_FMT_MOD_GET(TILE, modifier);\n}\n\nstatic const struct drm_format_info *\namd_get_format_info(const struct drm_mode_fb_cmd2 *cmd)\n{\n\treturn amdgpu_lookup_format_info(cmd->pixel_format, cmd->modifier[0]);\n}\n\nstatic void\nfill_gfx9_tiling_info_from_modifier(const struct amdgpu_device *adev,\n\t\t\t\t    union dc_tiling_info *tiling_info,\n\t\t\t\t    uint64_t modifier)\n{\n\tunsigned int mod_bank_xor_bits = AMD_FMT_MOD_GET(BANK_XOR_BITS, modifier);\n\tunsigned int mod_pipe_xor_bits = AMD_FMT_MOD_GET(PIPE_XOR_BITS, modifier);\n\tunsigned int pkrs_log2 = AMD_FMT_MOD_GET(PACKERS, modifier);\n\tunsigned int pipes_log2 = min(4u, mod_pipe_xor_bits);\n\n\tfill_gfx9_tiling_info_from_device(adev, tiling_info);\n\n\tif (!IS_AMD_FMT_MOD(modifier))\n\t\treturn;\n\n\ttiling_info->gfx9.num_pipes = 1u << pipes_log2;\n\ttiling_info->gfx9.num_shader_engines = 1u << (mod_pipe_xor_bits - pipes_log2);\n\n\tif (adev->family >= AMDGPU_FAMILY_NV) {\n\t\ttiling_info->gfx9.num_pkrs = 1u << pkrs_log2;\n\t} else {\n\t\ttiling_info->gfx9.num_banks = 1u << mod_bank_xor_bits;\n\n\t\t/* for DCC we know it isn't rb aligned, so rb_per_se doesn't matter. */\n\t}\n}\n\nenum dm_micro_swizzle {\n\tMICRO_SWIZZLE_Z = 0,\n\tMICRO_SWIZZLE_S = 1,\n\tMICRO_SWIZZLE_D = 2,\n\tMICRO_SWIZZLE_R = 3\n};\n\nstatic bool dm_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t  uint32_t format,\n\t\t\t\t\t  uint64_t modifier)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(plane->dev);\n\tconst struct drm_format_info *info = drm_format_info(format);\n\n\tenum dm_micro_swizzle microtile = modifier_gfx9_swizzle_mode(modifier) & 3;\n\n\tif (!info)\n\t\treturn false;\n\n\t/*\n\t * We always have to allow this modifier, because core DRM still\n\t * checks LINEAR support if userspace does not provide modifers.\n\t */\n\tif (modifier == DRM_FORMAT_MOD_LINEAR)\n\t\treturn true;\n\n\t/*\n\t * The arbitrary tiling support for multiplane formats has not been hooked\n\t * up.\n\t */\n\tif (info->num_planes > 1)\n\t\treturn false;\n\n\t/*\n\t * For D swizzle the canonical modifier depends on the bpp, so check\n\t * it here.\n\t */\n\tif (AMD_FMT_MOD_GET(TILE_VERSION, modifier) == AMD_FMT_MOD_TILE_VER_GFX9 &&\n\t    adev->family >= AMDGPU_FAMILY_NV) {\n\t\tif (microtile == MICRO_SWIZZLE_D && info->cpp[0] == 4)\n\t\t\treturn false;\n\t}\n\n\tif (adev->family >= AMDGPU_FAMILY_RV && microtile == MICRO_SWIZZLE_D &&\n\t    info->cpp[0] < 8)\n\t\treturn false;\n\n\tif (modifier_has_dcc(modifier)) {\n\t\t/* Per radeonsi comments 16/64 bpp are more complicated. */\n\t\tif (info->cpp[0] != 4)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nadd_modifier(uint64_t **mods, uint64_t *size, uint64_t *cap, uint64_t mod)\n{\n\tif (!*mods)\n\t\treturn;\n\n\tif (*cap - *size < 1) {\n\t\tuint64_t new_cap = *cap * 2;\n\t\tuint64_t *new_mods = kmalloc(new_cap * sizeof(uint64_t), GFP_KERNEL);\n\n\t\tif (!new_mods) {\n\t\t\tkfree(*mods);\n\t\t\t*mods = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tmemcpy(new_mods, *mods, sizeof(uint64_t) * *size);\n\t\tkfree(*mods);\n\t\t*mods = new_mods;\n\t\t*cap = new_cap;\n\t}\n\n\t(*mods)[*size] = mod;\n\t*size += 1;\n}\n\nstatic void\nadd_gfx9_modifiers(const struct amdgpu_device *adev,\n\t\t   uint64_t **mods, uint64_t *size, uint64_t *capacity)\n{\n\tint pipes = ilog2(adev->gfx.config.gb_addr_config_fields.num_pipes);\n\tint pipe_xor_bits = min(8, pipes +\n\t\t\t\tilog2(adev->gfx.config.gb_addr_config_fields.num_se));\n\tint bank_xor_bits = min(8 - pipe_xor_bits,\n\t\t\t\tilog2(adev->gfx.config.gb_addr_config_fields.num_banks));\n\tint rb = ilog2(adev->gfx.config.gb_addr_config_fields.num_se) +\n\t\t ilog2(adev->gfx.config.gb_addr_config_fields.num_rb_per_se);\n\n\n\tif (adev->family == AMDGPU_FAMILY_RV) {\n\t\t/* Raven2 and later */\n\t\tbool has_constant_encode = adev->asic_type > CHIP_RAVEN || adev->external_rev_id >= 0x81;\n\n\t\t/*\n\t\t * No _D DCC swizzles yet because we only allow 32bpp, which\n\t\t * doesn't support _D on DCN\n\t\t */\n\n\t\tif (has_constant_encode) {\n\t\t\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |\n\t\t\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t\t\t    AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1));\n\t\t}\n\n\t\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |\n\t\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t\t    AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits) |\n\t\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 0));\n\n\t\tif (has_constant_encode) {\n\t\t\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |\n\t\t\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t\t\t    AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_RETILE, 1) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B) |\n\n\t\t\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1) |\n\t\t\t\t    AMD_FMT_MOD_SET(RB, rb) |\n\t\t\t\t    AMD_FMT_MOD_SET(PIPE, pipes));\n\t\t}\n\n\t\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |\n\t\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t\t    AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits) |\n\t\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_RETILE, 1) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B) |\n\t\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 0) |\n\t\t\t    AMD_FMT_MOD_SET(RB, rb) |\n\t\t\t    AMD_FMT_MOD_SET(PIPE, pipes));\n\t}\n\n\t/*\n\t * Only supported for 64bpp on Raven, will be filtered on format in\n\t * dm_plane_format_mod_supported.\n\t */\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits));\n\n\tif (adev->family == AMDGPU_FAMILY_RV) {\n\t\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |\n\t\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t\t    AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits));\n\t}\n\n\t/*\n\t * Only supported for 64bpp on Raven, will be filtered on format in\n\t * dm_plane_format_mod_supported.\n\t */\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));\n\n\tif (adev->family == AMDGPU_FAMILY_RV) {\n\t\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S) |\n\t\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));\n\t}\n}\n\nstatic void\nadd_gfx10_1_modifiers(const struct amdgpu_device *adev,\n\t\t      uint64_t **mods, uint64_t *size, uint64_t *capacity)\n{\n\tint pipe_xor_bits = ilog2(adev->gfx.config.gb_addr_config_fields.num_pipes);\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_RETILE, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits));\n\n\n\t/* Only supported for 64bpp, will be filtered in dm_plane_format_mod_supported */\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));\n}\n\nstatic void\nadd_gfx10_3_modifiers(const struct amdgpu_device *adev,\n\t\t      uint64_t **mods, uint64_t *size, uint64_t *capacity)\n{\n\tint pipe_xor_bits = ilog2(adev->gfx.config.gb_addr_config_fields.num_pipes);\n\tint pkrs = ilog2(adev->gfx.config.gb_addr_config_fields.num_pkrs);\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(PACKERS, pkrs) |\n\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_128B, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_128B));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(PACKERS, pkrs) |\n\t\t    AMD_FMT_MOD_SET(DCC, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_RETILE, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_INDEPENDENT_128B, 1) |\n\t\t    AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_128B));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(PACKERS, pkrs));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS) |\n\t\t    AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |\n\t\t    AMD_FMT_MOD_SET(PACKERS, pkrs));\n\n\t/* Only supported for 64bpp, will be filtered in dm_plane_format_mod_supported */\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));\n\n\tadd_modifier(mods, size, capacity, AMD_FMT_MOD |\n\t\t    AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S) |\n\t\t    AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));\n}\n\nstatic int\nget_plane_modifiers(const struct amdgpu_device *adev, unsigned int plane_type, uint64_t **mods)\n{\n\tuint64_t size = 0, capacity = 128;\n\t*mods = NULL;\n\n\t/* We have not hooked up any pre-GFX9 modifiers. */\n\tif (adev->family < AMDGPU_FAMILY_AI)\n\t\treturn 0;\n\n\t*mods = kmalloc(capacity * sizeof(uint64_t), GFP_KERNEL);\n\n\tif (plane_type == DRM_PLANE_TYPE_CURSOR) {\n\t\tadd_modifier(mods, &size, &capacity, DRM_FORMAT_MOD_LINEAR);\n\t\tadd_modifier(mods, &size, &capacity, DRM_FORMAT_MOD_INVALID);\n\t\treturn *mods ? 0 : -ENOMEM;\n\t}\n\n\tswitch (adev->family) {\n\tcase AMDGPU_FAMILY_AI:\n\tcase AMDGPU_FAMILY_RV:\n\t\tadd_gfx9_modifiers(adev, mods, &size, &capacity);\n\t\tbreak;\n\tcase AMDGPU_FAMILY_NV:\n\tcase AMDGPU_FAMILY_VGH:\n\t\tif (adev->asic_type >= CHIP_SIENNA_CICHLID)\n\t\t\tadd_gfx10_3_modifiers(adev, mods, &size, &capacity);\n\t\telse\n\t\t\tadd_gfx10_1_modifiers(adev, mods, &size, &capacity);\n\t\tbreak;\n\t}\n\n\tadd_modifier(mods, &size, &capacity, DRM_FORMAT_MOD_LINEAR);\n\n\t/* INVALID marks the end of the list. */\n\tadd_modifier(mods, &size, &capacity, DRM_FORMAT_MOD_INVALID);\n\n\tif (!*mods)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int\nfill_gfx9_plane_attributes_from_modifiers(struct amdgpu_device *adev,\n\t\t\t\t\t  const struct amdgpu_framebuffer *afb,\n\t\t\t\t\t  const enum surface_pixel_format format,\n\t\t\t\t\t  const enum dc_rotation_angle rotation,\n\t\t\t\t\t  const struct plane_size *plane_size,\n\t\t\t\t\t  union dc_tiling_info *tiling_info,\n\t\t\t\t\t  struct dc_plane_dcc_param *dcc,\n\t\t\t\t\t  struct dc_plane_address *address,\n\t\t\t\t\t  const bool force_disable_dcc)\n{\n\tconst uint64_t modifier = afb->base.modifier;\n\tint ret;\n\n\tfill_gfx9_tiling_info_from_modifier(adev, tiling_info, modifier);\n\ttiling_info->gfx9.swizzle = modifier_gfx9_swizzle_mode(modifier);\n\n\tif (modifier_has_dcc(modifier) && !force_disable_dcc) {\n\t\tuint64_t dcc_address = afb->address + afb->base.offsets[1];\n\n\t\tdcc->enable = 1;\n\t\tdcc->meta_pitch = afb->base.pitches[1];\n\t\tdcc->independent_64b_blks = AMD_FMT_MOD_GET(DCC_INDEPENDENT_64B, modifier);\n\n\t\taddress->grph.meta_addr.low_part = lower_32_bits(dcc_address);\n\t\taddress->grph.meta_addr.high_part = upper_32_bits(dcc_address);\n\t}\n\n\tret = validate_dcc(adev, format, rotation, tiling_info, dcc, address, plane_size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nfill_plane_buffer_attributes(struct amdgpu_device *adev,\n\t\t\t     const struct amdgpu_framebuffer *afb,\n\t\t\t     const enum surface_pixel_format format,\n\t\t\t     const enum dc_rotation_angle rotation,\n\t\t\t     const uint64_t tiling_flags,\n\t\t\t     union dc_tiling_info *tiling_info,\n\t\t\t     struct plane_size *plane_size,\n\t\t\t     struct dc_plane_dcc_param *dcc,\n\t\t\t     struct dc_plane_address *address,\n\t\t\t     bool tmz_surface,\n\t\t\t     bool force_disable_dcc)\n{\n\tconst struct drm_framebuffer *fb = &afb->base;\n\tint ret;\n\n\tmemset(tiling_info, 0, sizeof(*tiling_info));\n\tmemset(plane_size, 0, sizeof(*plane_size));\n\tmemset(dcc, 0, sizeof(*dcc));\n\tmemset(address, 0, sizeof(*address));\n\n\taddress->tmz_surface = tmz_surface;\n\n\tif (format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN) {\n\t\tuint64_t addr = afb->address + fb->offsets[0];\n\n\t\tplane_size->surface_size.x = 0;\n\t\tplane_size->surface_size.y = 0;\n\t\tplane_size->surface_size.width = fb->width;\n\t\tplane_size->surface_size.height = fb->height;\n\t\tplane_size->surface_pitch =\n\t\t\tfb->pitches[0] / fb->format->cpp[0];\n\n\t\taddress->type = PLN_ADDR_TYPE_GRAPHICS;\n\t\taddress->grph.addr.low_part = lower_32_bits(addr);\n\t\taddress->grph.addr.high_part = upper_32_bits(addr);\n\t} else if (format < SURFACE_PIXEL_FORMAT_INVALID) {\n\t\tuint64_t luma_addr = afb->address + fb->offsets[0];\n\t\tuint64_t chroma_addr = afb->address + fb->offsets[1];\n\n\t\tplane_size->surface_size.x = 0;\n\t\tplane_size->surface_size.y = 0;\n\t\tplane_size->surface_size.width = fb->width;\n\t\tplane_size->surface_size.height = fb->height;\n\t\tplane_size->surface_pitch =\n\t\t\tfb->pitches[0] / fb->format->cpp[0];\n\n\t\tplane_size->chroma_size.x = 0;\n\t\tplane_size->chroma_size.y = 0;\n\t\t/* TODO: set these based on surface format */\n\t\tplane_size->chroma_size.width = fb->width / 2;\n\t\tplane_size->chroma_size.height = fb->height / 2;\n\n\t\tplane_size->chroma_pitch =\n\t\t\tfb->pitches[1] / fb->format->cpp[1];\n\n\t\taddress->type = PLN_ADDR_TYPE_VIDEO_PROGRESSIVE;\n\t\taddress->video_progressive.luma_addr.low_part =\n\t\t\tlower_32_bits(luma_addr);\n\t\taddress->video_progressive.luma_addr.high_part =\n\t\t\tupper_32_bits(luma_addr);\n\t\taddress->video_progressive.chroma_addr.low_part =\n\t\t\tlower_32_bits(chroma_addr);\n\t\taddress->video_progressive.chroma_addr.high_part =\n\t\t\tupper_32_bits(chroma_addr);\n\t}\n\n\tif (adev->family >= AMDGPU_FAMILY_AI) {\n\t\tret = fill_gfx9_plane_attributes_from_modifiers(adev, afb, format,\n\t\t\t\t\t\t\t\trotation, plane_size,\n\t\t\t\t\t\t\t\ttiling_info, dcc,\n\t\t\t\t\t\t\t\taddress,\n\t\t\t\t\t\t\t\tforce_disable_dcc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tfill_gfx8_tiling_info_from_flags(tiling_info, tiling_flags);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nfill_blending_from_plane_state(const struct drm_plane_state *plane_state,\n\t\t\t       bool *per_pixel_alpha, bool *global_alpha,\n\t\t\t       int *global_alpha_value)\n{\n\t*per_pixel_alpha = false;\n\t*global_alpha = false;\n\t*global_alpha_value = 0xff;\n\n\tif (plane_state->plane->type != DRM_PLANE_TYPE_OVERLAY)\n\t\treturn;\n\n\tif (plane_state->pixel_blend_mode == DRM_MODE_BLEND_PREMULTI) {\n\t\tstatic const uint32_t alpha_formats[] = {\n\t\t\tDRM_FORMAT_ARGB8888,\n\t\t\tDRM_FORMAT_RGBA8888,\n\t\t\tDRM_FORMAT_ABGR8888,\n\t\t};\n\t\tuint32_t format = plane_state->fb->format->format;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(alpha_formats); ++i) {\n\t\t\tif (format == alpha_formats[i]) {\n\t\t\t\t*per_pixel_alpha = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (plane_state->alpha < 0xffff) {\n\t\t*global_alpha = true;\n\t\t*global_alpha_value = plane_state->alpha >> 8;\n\t}\n}\n\nstatic int\nfill_plane_color_attributes(const struct drm_plane_state *plane_state,\n\t\t\t    const enum surface_pixel_format format,\n\t\t\t    enum dc_color_space *color_space)\n{\n\tbool full_range;\n\n\t*color_space = COLOR_SPACE_SRGB;\n\n\t/* DRM color properties only affect non-RGB formats. */\n\tif (format < SURFACE_PIXEL_FORMAT_VIDEO_BEGIN)\n\t\treturn 0;\n\n\tfull_range = (plane_state->color_range == DRM_COLOR_YCBCR_FULL_RANGE);\n\n\tswitch (plane_state->color_encoding) {\n\tcase DRM_COLOR_YCBCR_BT601:\n\t\tif (full_range)\n\t\t\t*color_space = COLOR_SPACE_YCBCR601;\n\t\telse\n\t\t\t*color_space = COLOR_SPACE_YCBCR601_LIMITED;\n\t\tbreak;\n\n\tcase DRM_COLOR_YCBCR_BT709:\n\t\tif (full_range)\n\t\t\t*color_space = COLOR_SPACE_YCBCR709;\n\t\telse\n\t\t\t*color_space = COLOR_SPACE_YCBCR709_LIMITED;\n\t\tbreak;\n\n\tcase DRM_COLOR_YCBCR_BT2020:\n\t\tif (full_range)\n\t\t\t*color_space = COLOR_SPACE_2020_YCBCR;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfill_dc_plane_info_and_addr(struct amdgpu_device *adev,\n\t\t\t    const struct drm_plane_state *plane_state,\n\t\t\t    const uint64_t tiling_flags,\n\t\t\t    struct dc_plane_info *plane_info,\n\t\t\t    struct dc_plane_address *address,\n\t\t\t    bool tmz_surface,\n\t\t\t    bool force_disable_dcc)\n{\n\tconst struct drm_framebuffer *fb = plane_state->fb;\n\tconst struct amdgpu_framebuffer *afb =\n\t\tto_amdgpu_framebuffer(plane_state->fb);\n\tstruct drm_format_name_buf format_name;\n\tint ret;\n\n\tmemset(plane_info, 0, sizeof(*plane_info));\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tplane_info->format =\n\t\t\tSURFACE_PIXEL_FORMAT_GRPH_PALETA_256_COLORS;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB2101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR2101010;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR8888;\n\t\tbreak;\n\tcase DRM_FORMAT_NV21:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCbCr;\n\t\tbreak;\n\tcase DRM_FORMAT_NV12:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_VIDEO_420_YCrCb;\n\t\tbreak;\n\tcase DRM_FORMAT_P010:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_VIDEO_420_10bpc_YCrCb;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_ARGB16161616F;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\tplane_info->format = SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\n\t\t\t\"Unsupported screen format %s\\n\",\n\t\t\tdrm_get_format_name(fb->format->format, &format_name));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (plane_state->rotation & DRM_MODE_ROTATE_MASK) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tplane_info->rotation = ROTATION_ANGLE_0;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tplane_info->rotation = ROTATION_ANGLE_90;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tplane_info->rotation = ROTATION_ANGLE_180;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tplane_info->rotation = ROTATION_ANGLE_270;\n\t\tbreak;\n\tdefault:\n\t\tplane_info->rotation = ROTATION_ANGLE_0;\n\t\tbreak;\n\t}\n\n\tplane_info->visible = true;\n\tplane_info->stereo_format = PLANE_STEREO_FORMAT_NONE;\n\n\tplane_info->layer_index = 0;\n\n\tret = fill_plane_color_attributes(plane_state, plane_info->format,\n\t\t\t\t\t  &plane_info->color_space);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fill_plane_buffer_attributes(adev, afb, plane_info->format,\n\t\t\t\t\t   plane_info->rotation, tiling_flags,\n\t\t\t\t\t   &plane_info->tiling_info,\n\t\t\t\t\t   &plane_info->plane_size,\n\t\t\t\t\t   &plane_info->dcc, address, tmz_surface,\n\t\t\t\t\t   force_disable_dcc);\n\tif (ret)\n\t\treturn ret;\n\n\tfill_blending_from_plane_state(\n\t\tplane_state, &plane_info->per_pixel_alpha,\n\t\t&plane_info->global_alpha, &plane_info->global_alpha_value);\n\n\treturn 0;\n}\n\nstatic int fill_dc_plane_attributes(struct amdgpu_device *adev,\n\t\t\t\t    struct dc_plane_state *dc_plane_state,\n\t\t\t\t    struct drm_plane_state *plane_state,\n\t\t\t\t    struct drm_crtc_state *crtc_state)\n{\n\tstruct dm_crtc_state *dm_crtc_state = to_dm_crtc_state(crtc_state);\n\tstruct amdgpu_framebuffer *afb = (struct amdgpu_framebuffer *)plane_state->fb;\n\tstruct dc_scaling_info scaling_info;\n\tstruct dc_plane_info plane_info;\n\tint ret;\n\tbool force_disable_dcc = false;\n\n\tret = fill_dc_scaling_info(plane_state, &scaling_info);\n\tif (ret)\n\t\treturn ret;\n\n\tdc_plane_state->src_rect = scaling_info.src_rect;\n\tdc_plane_state->dst_rect = scaling_info.dst_rect;\n\tdc_plane_state->clip_rect = scaling_info.clip_rect;\n\tdc_plane_state->scaling_quality = scaling_info.scaling_quality;\n\n\tforce_disable_dcc = adev->asic_type == CHIP_RAVEN && adev->in_suspend;\n\tret = fill_dc_plane_info_and_addr(adev, plane_state,\n\t\t\t\t\t  afb->tiling_flags,\n\t\t\t\t\t  &plane_info,\n\t\t\t\t\t  &dc_plane_state->address,\n\t\t\t\t\t  afb->tmz_surface,\n\t\t\t\t\t  force_disable_dcc);\n\tif (ret)\n\t\treturn ret;\n\n\tdc_plane_state->format = plane_info.format;\n\tdc_plane_state->color_space = plane_info.color_space;\n\tdc_plane_state->format = plane_info.format;\n\tdc_plane_state->plane_size = plane_info.plane_size;\n\tdc_plane_state->rotation = plane_info.rotation;\n\tdc_plane_state->horizontal_mirror = plane_info.horizontal_mirror;\n\tdc_plane_state->stereo_format = plane_info.stereo_format;\n\tdc_plane_state->tiling_info = plane_info.tiling_info;\n\tdc_plane_state->visible = plane_info.visible;\n\tdc_plane_state->per_pixel_alpha = plane_info.per_pixel_alpha;\n\tdc_plane_state->global_alpha = plane_info.global_alpha;\n\tdc_plane_state->global_alpha_value = plane_info.global_alpha_value;\n\tdc_plane_state->dcc = plane_info.dcc;\n\tdc_plane_state->layer_index = plane_info.layer_index; // Always returns 0\n\n\t/*\n\t * Always set input transfer function, since plane state is refreshed\n\t * every time.\n\t */\n\tret = amdgpu_dm_update_plane_color_mgmt(dm_crtc_state, dc_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void update_stream_scaling_settings(const struct drm_display_mode *mode,\n\t\t\t\t\t   const struct dm_connector_state *dm_state,\n\t\t\t\t\t   struct dc_stream_state *stream)\n{\n\tenum amdgpu_rmx_type rmx_type;\n\n\tstruct rect src = { 0 }; /* viewport in composition space*/\n\tstruct rect dst = { 0 }; /* stream addressable area */\n\n\t/* no mode. nothing to be done */\n\tif (!mode)\n\t\treturn;\n\n\t/* Full screen scaling by default */\n\tsrc.width = mode->hdisplay;\n\tsrc.height = mode->vdisplay;\n\tdst.width = stream->timing.h_addressable;\n\tdst.height = stream->timing.v_addressable;\n\n\tif (dm_state) {\n\t\trmx_type = dm_state->scaling;\n\t\tif (rmx_type == RMX_ASPECT || rmx_type == RMX_OFF) {\n\t\t\tif (src.width * dst.height <\n\t\t\t\t\tsrc.height * dst.width) {\n\t\t\t\t/* height needs less upscaling/more downscaling */\n\t\t\t\tdst.width = src.width *\n\t\t\t\t\t\tdst.height / src.height;\n\t\t\t} else {\n\t\t\t\t/* width needs less upscaling/more downscaling */\n\t\t\t\tdst.height = src.height *\n\t\t\t\t\t\tdst.width / src.width;\n\t\t\t}\n\t\t} else if (rmx_type == RMX_CENTER) {\n\t\t\tdst = src;\n\t\t}\n\n\t\tdst.x = (stream->timing.h_addressable - dst.width) / 2;\n\t\tdst.y = (stream->timing.v_addressable - dst.height) / 2;\n\n\t\tif (dm_state->underscan_enable) {\n\t\t\tdst.x += dm_state->underscan_hborder / 2;\n\t\t\tdst.y += dm_state->underscan_vborder / 2;\n\t\t\tdst.width -= dm_state->underscan_hborder;\n\t\t\tdst.height -= dm_state->underscan_vborder;\n\t\t}\n\t}\n\n\tstream->src = src;\n\tstream->dst = dst;\n\n\tDRM_DEBUG_DRIVER(\"Destination Rectangle x:%d  y:%d  width:%d  height:%d\\n\",\n\t\t\tdst.x, dst.y, dst.width, dst.height);\n\n}\n\nstatic enum dc_color_depth\nconvert_color_depth_from_display_info(const struct drm_connector *connector,\n\t\t\t\t      bool is_y420, int requested_bpc)\n{\n\tuint8_t bpc;\n\n\tif (is_y420) {\n\t\tbpc = 8;\n\n\t\t/* Cap display bpc based on HDMI 2.0 HF-VSDB */\n\t\tif (connector->display_info.hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_48)\n\t\t\tbpc = 16;\n\t\telse if (connector->display_info.hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_36)\n\t\t\tbpc = 12;\n\t\telse if (connector->display_info.hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30)\n\t\t\tbpc = 10;\n\t} else {\n\t\tbpc = (uint8_t)connector->display_info.bpc;\n\t\t/* Assume 8 bpc by default if no bpc is specified. */\n\t\tbpc = bpc ? bpc : 8;\n\t}\n\n\tif (requested_bpc > 0) {\n\t\t/*\n\t\t * Cap display bpc based on the user requested value.\n\t\t *\n\t\t * The value for state->max_bpc may not correctly updated\n\t\t * depending on when the connector gets added to the state\n\t\t * or if this was called outside of atomic check, so it\n\t\t * can't be used directly.\n\t\t */\n\t\tbpc = min_t(u8, bpc, requested_bpc);\n\n\t\t/* Round down to the nearest even number. */\n\t\tbpc = bpc - (bpc & 1);\n\t}\n\n\tswitch (bpc) {\n\tcase 0:\n\t\t/*\n\t\t * Temporary Work around, DRM doesn't parse color depth for\n\t\t * EDID revision before 1.4\n\t\t * TODO: Fix edid parsing\n\t\t */\n\t\treturn COLOR_DEPTH_888;\n\tcase 6:\n\t\treturn COLOR_DEPTH_666;\n\tcase 8:\n\t\treturn COLOR_DEPTH_888;\n\tcase 10:\n\t\treturn COLOR_DEPTH_101010;\n\tcase 12:\n\t\treturn COLOR_DEPTH_121212;\n\tcase 14:\n\t\treturn COLOR_DEPTH_141414;\n\tcase 16:\n\t\treturn COLOR_DEPTH_161616;\n\tdefault:\n\t\treturn COLOR_DEPTH_UNDEFINED;\n\t}\n}\n\nstatic enum dc_aspect_ratio\nget_aspect_ratio(const struct drm_display_mode *mode_in)\n{\n\t/* 1-1 mapping, since both enums follow the HDMI spec. */\n\treturn (enum dc_aspect_ratio) mode_in->picture_aspect_ratio;\n}\n\nstatic enum dc_color_space\nget_output_color_space(const struct dc_crtc_timing *dc_crtc_timing)\n{\n\tenum dc_color_space color_space = COLOR_SPACE_SRGB;\n\n\tswitch (dc_crtc_timing->pixel_encoding)\t{\n\tcase PIXEL_ENCODING_YCBCR422:\n\tcase PIXEL_ENCODING_YCBCR444:\n\tcase PIXEL_ENCODING_YCBCR420:\n\t{\n\t\t/*\n\t\t * 27030khz is the separation point between HDTV and SDTV\n\t\t * according to HDMI spec, we use YCbCr709 and YCbCr601\n\t\t * respectively\n\t\t */\n\t\tif (dc_crtc_timing->pix_clk_100hz > 270300) {\n\t\t\tif (dc_crtc_timing->flags.Y_ONLY)\n\t\t\t\tcolor_space =\n\t\t\t\t\tCOLOR_SPACE_YCBCR709_LIMITED;\n\t\t\telse\n\t\t\t\tcolor_space = COLOR_SPACE_YCBCR709;\n\t\t} else {\n\t\t\tif (dc_crtc_timing->flags.Y_ONLY)\n\t\t\t\tcolor_space =\n\t\t\t\t\tCOLOR_SPACE_YCBCR601_LIMITED;\n\t\t\telse\n\t\t\t\tcolor_space = COLOR_SPACE_YCBCR601;\n\t\t}\n\n\t}\n\tbreak;\n\tcase PIXEL_ENCODING_RGB:\n\t\tcolor_space = COLOR_SPACE_SRGB;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn color_space;\n}\n\nstatic bool adjust_colour_depth_from_display_info(\n\tstruct dc_crtc_timing *timing_out,\n\tconst struct drm_display_info *info)\n{\n\tenum dc_color_depth depth = timing_out->display_color_depth;\n\tint normalized_clk;\n\tdo {\n\t\tnormalized_clk = timing_out->pix_clk_100hz / 10;\n\t\t/* YCbCr 4:2:0 requires additional adjustment of 1/2 */\n\t\tif (timing_out->pixel_encoding == PIXEL_ENCODING_YCBCR420)\n\t\t\tnormalized_clk /= 2;\n\t\t/* Adjusting pix clock following on HDMI spec based on colour depth */\n\t\tswitch (depth) {\n\t\tcase COLOR_DEPTH_888:\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\tnormalized_clk = (normalized_clk * 30) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\tnormalized_clk = (normalized_clk * 36) / 24;\n\t\t\tbreak;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\tnormalized_clk = (normalized_clk * 48) / 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* The above depths are the only ones valid for HDMI. */\n\t\t\treturn false;\n\t\t}\n\t\tif (normalized_clk <= info->max_tmds_clock) {\n\t\t\ttiming_out->display_color_depth = depth;\n\t\t\treturn true;\n\t\t}\n\t} while (--depth > COLOR_DEPTH_666);\n\treturn false;\n}\n\nstatic void fill_stream_properties_from_drm_display_mode(\n\tstruct dc_stream_state *stream,\n\tconst struct drm_display_mode *mode_in,\n\tconst struct drm_connector *connector,\n\tconst struct drm_connector_state *connector_state,\n\tconst struct dc_stream_state *old_stream,\n\tint requested_bpc)\n{\n\tstruct dc_crtc_timing *timing_out = &stream->timing;\n\tconst struct drm_display_info *info = &connector->display_info;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct hdmi_vendor_infoframe hv_frame;\n\tstruct hdmi_avi_infoframe avi_frame;\n\n\tmemset(&hv_frame, 0, sizeof(hv_frame));\n\tmemset(&avi_frame, 0, sizeof(avi_frame));\n\n\ttiming_out->h_border_left = 0;\n\ttiming_out->h_border_right = 0;\n\ttiming_out->v_border_top = 0;\n\ttiming_out->v_border_bottom = 0;\n\t/* TODO: un-hardcode */\n\tif (drm_mode_is_420_only(info, mode_in)\n\t\t\t&& stream->signal == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\ttiming_out->pixel_encoding = PIXEL_ENCODING_YCBCR420;\n\telse if (drm_mode_is_420_also(info, mode_in)\n\t\t\t&& aconnector->force_yuv420_output)\n\t\ttiming_out->pixel_encoding = PIXEL_ENCODING_YCBCR420;\n\telse if ((connector->display_info.color_formats & DRM_COLOR_FORMAT_YCRCB444)\n\t\t\t&& stream->signal == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\ttiming_out->pixel_encoding = PIXEL_ENCODING_YCBCR444;\n\telse\n\t\ttiming_out->pixel_encoding = PIXEL_ENCODING_RGB;\n\n\ttiming_out->timing_3d_format = TIMING_3D_FORMAT_NONE;\n\ttiming_out->display_color_depth = convert_color_depth_from_display_info(\n\t\tconnector,\n\t\t(timing_out->pixel_encoding == PIXEL_ENCODING_YCBCR420),\n\t\trequested_bpc);\n\ttiming_out->scan_type = SCANNING_TYPE_NODATA;\n\ttiming_out->hdmi_vic = 0;\n\n\tif(old_stream) {\n\t\ttiming_out->vic = old_stream->timing.vic;\n\t\ttiming_out->flags.HSYNC_POSITIVE_POLARITY = old_stream->timing.flags.HSYNC_POSITIVE_POLARITY;\n\t\ttiming_out->flags.VSYNC_POSITIVE_POLARITY = old_stream->timing.flags.VSYNC_POSITIVE_POLARITY;\n\t} else {\n\t\ttiming_out->vic = drm_match_cea_mode(mode_in);\n\t\tif (mode_in->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\ttiming_out->flags.HSYNC_POSITIVE_POLARITY = 1;\n\t\tif (mode_in->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\ttiming_out->flags.VSYNC_POSITIVE_POLARITY = 1;\n\t}\n\n\tif (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\tdrm_hdmi_avi_infoframe_from_display_mode(&avi_frame, (struct drm_connector *)connector, mode_in);\n\t\ttiming_out->vic = avi_frame.video_code;\n\t\tdrm_hdmi_vendor_infoframe_from_display_mode(&hv_frame, (struct drm_connector *)connector, mode_in);\n\t\ttiming_out->hdmi_vic = hv_frame.vic;\n\t}\n\n\ttiming_out->h_addressable = mode_in->crtc_hdisplay;\n\ttiming_out->h_total = mode_in->crtc_htotal;\n\ttiming_out->h_sync_width =\n\t\tmode_in->crtc_hsync_end - mode_in->crtc_hsync_start;\n\ttiming_out->h_front_porch =\n\t\tmode_in->crtc_hsync_start - mode_in->crtc_hdisplay;\n\ttiming_out->v_total = mode_in->crtc_vtotal;\n\ttiming_out->v_addressable = mode_in->crtc_vdisplay;\n\ttiming_out->v_front_porch =\n\t\tmode_in->crtc_vsync_start - mode_in->crtc_vdisplay;\n\ttiming_out->v_sync_width =\n\t\tmode_in->crtc_vsync_end - mode_in->crtc_vsync_start;\n\ttiming_out->pix_clk_100hz = mode_in->crtc_clock * 10;\n\ttiming_out->aspect_ratio = get_aspect_ratio(mode_in);\n\n\tstream->output_color_space = get_output_color_space(timing_out);\n\n\tstream->out_transfer_func->type = TF_TYPE_PREDEFINED;\n\tstream->out_transfer_func->tf = TRANSFER_FUNCTION_SRGB;\n\tif (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A) {\n\t\tif (!adjust_colour_depth_from_display_info(timing_out, info) &&\n\t\t    drm_mode_is_420_also(info, mode_in) &&\n\t\t    timing_out->pixel_encoding != PIXEL_ENCODING_YCBCR420) {\n\t\t\ttiming_out->pixel_encoding = PIXEL_ENCODING_YCBCR420;\n\t\t\tadjust_colour_depth_from_display_info(timing_out, info);\n\t\t}\n\t}\n}\n\nstatic void fill_audio_info(struct audio_info *audio_info,\n\t\t\t    const struct drm_connector *drm_connector,\n\t\t\t    const struct dc_sink *dc_sink)\n{\n\tint i = 0;\n\tint cea_revision = 0;\n\tconst struct dc_edid_caps *edid_caps = &dc_sink->edid_caps;\n\n\taudio_info->manufacture_id = edid_caps->manufacturer_id;\n\taudio_info->product_id = edid_caps->product_id;\n\n\tcea_revision = drm_connector->display_info.cea_rev;\n\n\tstrscpy(audio_info->display_name,\n\t\tedid_caps->display_name,\n\t\tAUDIO_INFO_DISPLAY_NAME_SIZE_IN_CHARS);\n\n\tif (cea_revision >= 3) {\n\t\taudio_info->mode_count = edid_caps->audio_mode_count;\n\n\t\tfor (i = 0; i < audio_info->mode_count; ++i) {\n\t\t\taudio_info->modes[i].format_code =\n\t\t\t\t\t(enum audio_format_code)\n\t\t\t\t\t(edid_caps->audio_modes[i].format_code);\n\t\t\taudio_info->modes[i].channel_count =\n\t\t\t\t\tedid_caps->audio_modes[i].channel_count;\n\t\t\taudio_info->modes[i].sample_rates.all =\n\t\t\t\t\tedid_caps->audio_modes[i].sample_rate;\n\t\t\taudio_info->modes[i].sample_size =\n\t\t\t\t\tedid_caps->audio_modes[i].sample_size;\n\t\t}\n\t}\n\n\taudio_info->flags.all = edid_caps->speaker_flags;\n\n\t/* TODO: We only check for the progressive mode, check for interlace mode too */\n\tif (drm_connector->latency_present[0]) {\n\t\taudio_info->video_latency = drm_connector->video_latency[0];\n\t\taudio_info->audio_latency = drm_connector->audio_latency[0];\n\t}\n\n\t/* TODO: For DP, video and audio latency should be calculated from DPCD caps */\n\n}\n\nstatic void\ncopy_crtc_timing_for_drm_display_mode(const struct drm_display_mode *src_mode,\n\t\t\t\t      struct drm_display_mode *dst_mode)\n{\n\tdst_mode->crtc_hdisplay = src_mode->crtc_hdisplay;\n\tdst_mode->crtc_vdisplay = src_mode->crtc_vdisplay;\n\tdst_mode->crtc_clock = src_mode->crtc_clock;\n\tdst_mode->crtc_hblank_start = src_mode->crtc_hblank_start;\n\tdst_mode->crtc_hblank_end = src_mode->crtc_hblank_end;\n\tdst_mode->crtc_hsync_start =  src_mode->crtc_hsync_start;\n\tdst_mode->crtc_hsync_end = src_mode->crtc_hsync_end;\n\tdst_mode->crtc_htotal = src_mode->crtc_htotal;\n\tdst_mode->crtc_hskew = src_mode->crtc_hskew;\n\tdst_mode->crtc_vblank_start = src_mode->crtc_vblank_start;\n\tdst_mode->crtc_vblank_end = src_mode->crtc_vblank_end;\n\tdst_mode->crtc_vsync_start = src_mode->crtc_vsync_start;\n\tdst_mode->crtc_vsync_end = src_mode->crtc_vsync_end;\n\tdst_mode->crtc_vtotal = src_mode->crtc_vtotal;\n}\n\nstatic void\ndecide_crtc_timing_for_drm_display_mode(struct drm_display_mode *drm_mode,\n\t\t\t\t\tconst struct drm_display_mode *native_mode,\n\t\t\t\t\tbool scale_enabled)\n{\n\tif (scale_enabled) {\n\t\tcopy_crtc_timing_for_drm_display_mode(native_mode, drm_mode);\n\t} else if (native_mode->clock == drm_mode->clock &&\n\t\t\tnative_mode->htotal == drm_mode->htotal &&\n\t\t\tnative_mode->vtotal == drm_mode->vtotal) {\n\t\tcopy_crtc_timing_for_drm_display_mode(native_mode, drm_mode);\n\t} else {\n\t\t/* no scaling nor amdgpu inserted, no need to patch */\n\t}\n}\n\nstatic struct dc_sink *\ncreate_fake_sink(struct amdgpu_dm_connector *aconnector)\n{\n\tstruct dc_sink_init_data sink_init_data = { 0 };\n\tstruct dc_sink *sink = NULL;\n\tsink_init_data.link = aconnector->dc_link;\n\tsink_init_data.sink_signal = aconnector->dc_link->connector_signal;\n\n\tsink = dc_sink_create(&sink_init_data);\n\tif (!sink) {\n\t\tDRM_ERROR(\"Failed to create sink!\\n\");\n\t\treturn NULL;\n\t}\n\tsink->sink_signal = SIGNAL_TYPE_VIRTUAL;\n\n\treturn sink;\n}\n\nstatic void set_multisync_trigger_params(\n\t\tstruct dc_stream_state *stream)\n{\n\tif (stream->triggered_crtc_reset.enabled) {\n\t\tstream->triggered_crtc_reset.event = CRTC_EVENT_VSYNC_RISING;\n\t\tstream->triggered_crtc_reset.delay = TRIGGER_DELAY_NEXT_LINE;\n\t}\n}\n\nstatic void set_master_stream(struct dc_stream_state *stream_set[],\n\t\t\t      int stream_count)\n{\n\tint j, highest_rfr = 0, master_stream = 0;\n\n\tfor (j = 0;  j < stream_count; j++) {\n\t\tif (stream_set[j] && stream_set[j]->triggered_crtc_reset.enabled) {\n\t\t\tint refresh_rate = 0;\n\n\t\t\trefresh_rate = (stream_set[j]->timing.pix_clk_100hz*100)/\n\t\t\t\t(stream_set[j]->timing.h_total*stream_set[j]->timing.v_total);\n\t\t\tif (refresh_rate > highest_rfr) {\n\t\t\t\thighest_rfr = refresh_rate;\n\t\t\t\tmaster_stream = j;\n\t\t\t}\n\t\t}\n\t}\n\tfor (j = 0;  j < stream_count; j++) {\n\t\tif (stream_set[j])\n\t\t\tstream_set[j]->triggered_crtc_reset.event_source = stream_set[master_stream];\n\t}\n}\n\nstatic void dm_enable_per_frame_crtc_master_sync(struct dc_state *context)\n{\n\tint i = 0;\n\n\tif (context->stream_count < 2)\n\t\treturn;\n\tfor (i = 0; i < context->stream_count ; i++) {\n\t\tif (!context->streams[i])\n\t\t\tcontinue;\n\t\t/*\n\t\t * TODO: add a function to read AMD VSDB bits and set\n\t\t * crtc_sync_master.multi_sync_enabled flag\n\t\t * For now it's set to false\n\t\t */\n\t\tset_multisync_trigger_params(context->streams[i]);\n\t}\n\tset_master_stream(context->streams, context->stream_count);\n}\n\nstatic struct dc_stream_state *\ncreate_stream_for_sink(struct amdgpu_dm_connector *aconnector,\n\t\t       const struct drm_display_mode *drm_mode,\n\t\t       const struct dm_connector_state *dm_state,\n\t\t       const struct dc_stream_state *old_stream,\n\t\t       int requested_bpc)\n{\n\tstruct drm_display_mode *preferred_mode = NULL;\n\tstruct drm_connector *drm_connector;\n\tconst struct drm_connector_state *con_state =\n\t\tdm_state ? &dm_state->base : NULL;\n\tstruct dc_stream_state *stream = NULL;\n\tstruct drm_display_mode mode = *drm_mode;\n\tbool native_mode_found = false;\n\tbool scale = dm_state ? (dm_state->scaling != RMX_OFF) : false;\n\tint mode_refresh;\n\tint preferred_refresh = 0;\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tstruct dsc_dec_dpcd_caps dsc_caps;\n\tuint32_t link_bandwidth_kbps;\n#endif\n\tstruct dc_sink *sink = NULL;\n\tif (aconnector == NULL) {\n\t\tDRM_ERROR(\"aconnector is NULL!\\n\");\n\t\treturn stream;\n\t}\n\n\tdrm_connector = &aconnector->base;\n\n\tif (!aconnector->dc_sink) {\n\t\tsink = create_fake_sink(aconnector);\n\t\tif (!sink)\n\t\t\treturn stream;\n\t} else {\n\t\tsink = aconnector->dc_sink;\n\t\tdc_sink_retain(sink);\n\t}\n\n\tstream = dc_create_stream_for_sink(sink);\n\n\tif (stream == NULL) {\n\t\tDRM_ERROR(\"Failed to create stream for sink!\\n\");\n\t\tgoto finish;\n\t}\n\n\tstream->dm_stream_context = aconnector;\n\n\tstream->timing.flags.LTE_340MCSC_SCRAMBLE =\n\t\tdrm_connector->display_info.hdmi.scdc.scrambling.low_rates;\n\n\tlist_for_each_entry(preferred_mode, &aconnector->base.modes, head) {\n\t\t/* Search for preferred mode */\n\t\tif (preferred_mode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tnative_mode_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!native_mode_found)\n\t\tpreferred_mode = list_first_entry_or_null(\n\t\t\t\t&aconnector->base.modes,\n\t\t\t\tstruct drm_display_mode,\n\t\t\t\thead);\n\n\tmode_refresh = drm_mode_vrefresh(&mode);\n\n\tif (preferred_mode == NULL) {\n\t\t/*\n\t\t * This may not be an error, the use case is when we have no\n\t\t * usermode calls to reset and set mode upon hotplug. In this\n\t\t * case, we call set mode ourselves to restore the previous mode\n\t\t * and the modelist may not be filled in in time.\n\t\t */\n\t\tDRM_DEBUG_DRIVER(\"No preferred mode found\\n\");\n\t} else {\n\t\tdecide_crtc_timing_for_drm_display_mode(\n\t\t\t\t&mode, preferred_mode,\n\t\t\t\tdm_state ? (dm_state->scaling != RMX_OFF) : false);\n\t\tpreferred_refresh = drm_mode_vrefresh(preferred_mode);\n\t}\n\n\tif (!dm_state)\n\t\tdrm_mode_set_crtcinfo(&mode, 0);\n\n\t/*\n\t* If scaling is enabled and refresh rate didn't change\n\t* we copy the vic and polarities of the old timings\n\t*/\n\tif (!scale || mode_refresh != preferred_refresh)\n\t\tfill_stream_properties_from_drm_display_mode(stream,\n\t\t\t&mode, &aconnector->base, con_state, NULL, requested_bpc);\n\telse\n\t\tfill_stream_properties_from_drm_display_mode(stream,\n\t\t\t&mode, &aconnector->base, con_state, old_stream, requested_bpc);\n\n\tstream->timing.flags.DSC = 0;\n\n\tif (aconnector->dc_link && sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT) {\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\t\tdc_dsc_parse_dsc_dpcd(aconnector->dc_link->ctx->dc,\n\t\t\t\t      aconnector->dc_link->dpcd_caps.dsc_caps.dsc_basic_caps.raw,\n\t\t\t\t      aconnector->dc_link->dpcd_caps.dsc_caps.dsc_branch_decoder_caps.raw,\n\t\t\t\t      &dsc_caps);\n\t\tlink_bandwidth_kbps = dc_link_bandwidth_kbps(aconnector->dc_link,\n\t\t\t\t\t\t\t     dc_link_get_link_cap(aconnector->dc_link));\n\n\t\tif (aconnector->dsc_settings.dsc_force_enable != DSC_CLK_FORCE_DISABLE && dsc_caps.is_dsc_supported) {\n\t\t\t/* Set DSC policy according to dsc_clock_en */\n\t\t\tdc_dsc_policy_set_enable_dsc_when_not_needed(\n\t\t\t\taconnector->dsc_settings.dsc_force_enable == DSC_CLK_FORCE_ENABLE);\n\n\t\t\tif (dc_dsc_compute_config(aconnector->dc_link->ctx->dc->res_pool->dscs[0],\n\t\t\t\t\t\t  &dsc_caps,\n\t\t\t\t\t\t  aconnector->dc_link->ctx->dc->debug.dsc_min_slice_height_override,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  link_bandwidth_kbps,\n\t\t\t\t\t\t  &stream->timing,\n\t\t\t\t\t\t  &stream->timing.dsc_cfg))\n\t\t\t\tstream->timing.flags.DSC = 1;\n\t\t\t/* Overwrite the stream flag if DSC is enabled through debugfs */\n\t\t\tif (aconnector->dsc_settings.dsc_force_enable == DSC_CLK_FORCE_ENABLE)\n\t\t\t\tstream->timing.flags.DSC = 1;\n\n\t\t\tif (stream->timing.flags.DSC && aconnector->dsc_settings.dsc_num_slices_h)\n\t\t\t\tstream->timing.dsc_cfg.num_slices_h = aconnector->dsc_settings.dsc_num_slices_h;\n\n\t\t\tif (stream->timing.flags.DSC && aconnector->dsc_settings.dsc_num_slices_v)\n\t\t\t\tstream->timing.dsc_cfg.num_slices_v = aconnector->dsc_settings.dsc_num_slices_v;\n\n\t\t\tif (stream->timing.flags.DSC && aconnector->dsc_settings.dsc_bits_per_pixel)\n\t\t\t\tstream->timing.dsc_cfg.bits_per_pixel = aconnector->dsc_settings.dsc_bits_per_pixel;\n\t\t}\n#endif\n\t}\n\n\tupdate_stream_scaling_settings(&mode, dm_state, stream);\n\n\tfill_audio_info(\n\t\t&stream->audio_info,\n\t\tdrm_connector,\n\t\tsink);\n\n\tupdate_stream_signal(stream, sink);\n\n\tif (stream->signal == SIGNAL_TYPE_HDMI_TYPE_A)\n\t\tmod_build_hf_vsif_infopacket(stream, &stream->vsp_infopacket);\n\n\tif (stream->link->psr_settings.psr_feature_enabled) {\n\t\t//\n\t\t// should decide stream support vsc sdp colorimetry capability\n\t\t// before building vsc info packet\n\t\t//\n\t\tstream->use_vsc_sdp_for_colorimetry = false;\n\t\tif (aconnector->dc_sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\t\tstream->use_vsc_sdp_for_colorimetry =\n\t\t\t\taconnector->dc_sink->is_vsc_sdp_colorimetry_supported;\n\t\t} else {\n\t\t\tif (stream->link->dpcd_caps.dprx_feature.bits.VSC_SDP_COLORIMETRY_SUPPORTED)\n\t\t\t\tstream->use_vsc_sdp_for_colorimetry = true;\n\t\t}\n\t\tmod_build_vsc_infopacket(stream, &stream->vsc_infopacket);\n\t}\nfinish:\n\tdc_sink_release(sink);\n\n\treturn stream;\n}\n\nstatic void amdgpu_dm_crtc_destroy(struct drm_crtc *crtc)\n{\n\tdrm_crtc_cleanup(crtc);\n\tkfree(crtc);\n}\n\nstatic void dm_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_crtc_state *state)\n{\n\tstruct dm_crtc_state *cur = to_dm_crtc_state(state);\n\n\t/* TODO Destroy dc_stream objects are stream object is flattened */\n\tif (cur->stream)\n\t\tdc_stream_release(cur->stream);\n\n\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\n\n\tkfree(state);\n}\n\nstatic void dm_crtc_reset_state(struct drm_crtc *crtc)\n{\n\tstruct dm_crtc_state *state;\n\n\tif (crtc->state)\n\t\tdm_crtc_destroy_state(crtc, crtc->state);\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (WARN_ON(!state))\n\t\treturn;\n\n\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *\ndm_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct dm_crtc_state *state, *cur;\n\n\tcur = to_dm_crtc_state(crtc->state);\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tif (cur->stream) {\n\t\tstate->stream = cur->stream;\n\t\tdc_stream_retain(state->stream);\n\t}\n\n\tstate->active_planes = cur->active_planes;\n\tstate->vrr_infopacket = cur->vrr_infopacket;\n\tstate->abm_level = cur->abm_level;\n\tstate->vrr_supported = cur->vrr_supported;\n\tstate->freesync_config = cur->freesync_config;\n\tstate->crc_src = cur->crc_src;\n\tstate->cm_has_degamma = cur->cm_has_degamma;\n\tstate->cm_is_degamma_srgb = cur->cm_is_degamma_srgb;\n\n\t/* TODO Duplicate dc_stream after objects are stream object is flattened */\n\n\treturn &state->base;\n}\n\nstatic inline int dm_set_vupdate_irq(struct drm_crtc *crtc, bool enable)\n{\n\tenum dc_irq_source irq_source;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tint rc;\n\n\tirq_source = IRQ_TYPE_VUPDATE + acrtc->otg_inst;\n\n\trc = dc_interrupt_set(adev->dm.dc, irq_source, enable) ? 0 : -EBUSY;\n\n\tDRM_DEBUG_DRIVER(\"crtc %d - vupdate irq %sabling: r=%d\\n\",\n\t\t\t acrtc->crtc_id, enable ? \"en\" : \"dis\", rc);\n\treturn rc;\n}\n\nstatic inline int dm_set_vblank(struct drm_crtc *crtc, bool enable)\n{\n\tenum dc_irq_source irq_source;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tstruct dm_crtc_state *acrtc_state = to_dm_crtc_state(crtc->state);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tint rc = 0;\n\n\tif (enable) {\n\t\t/* vblank irq on -> Only need vupdate irq in vrr mode */\n\t\tif (amdgpu_dm_vrr_active(acrtc_state))\n\t\t\trc = dm_set_vupdate_irq(crtc, true);\n\t} else {\n\t\t/* vblank irq off -> vupdate irq off */\n\t\trc = dm_set_vupdate_irq(crtc, false);\n\t}\n\n\tif (rc)\n\t\treturn rc;\n\n\tirq_source = IRQ_TYPE_VBLANK + acrtc->otg_inst;\n\n\tif (!dc_interrupt_set(adev->dm.dc, irq_source, enable))\n\t\treturn -EBUSY;\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tif (amdgpu_in_reset(adev))\n\t\treturn 0;\n\n\tmutex_lock(&dm->dc_lock);\n\n\tif (enable)\n\t\tdm->active_vblank_irq_count++;\n\telse\n\t\tdm->active_vblank_irq_count--;\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tdc_allow_idle_optimizations(\n\t\tadev->dm.dc, dm->active_vblank_irq_count == 0 ? true : false);\n\n\tDRM_DEBUG_DRIVER(\"Allow idle optimizations (MALL): %d\\n\", dm->active_vblank_irq_count == 0);\n#endif\n\n\tmutex_unlock(&dm->dc_lock);\n\n#endif\n\treturn 0;\n}\n\nstatic int dm_enable_vblank(struct drm_crtc *crtc)\n{\n\treturn dm_set_vblank(crtc, true);\n}\n\nstatic void dm_disable_vblank(struct drm_crtc *crtc)\n{\n\tdm_set_vblank(crtc, false);\n}\n\n/* Implemented only the options currently availible for the driver */\nstatic const struct drm_crtc_funcs amdgpu_dm_crtc_funcs = {\n\t.reset = dm_crtc_reset_state,\n\t.destroy = amdgpu_dm_crtc_destroy,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = dm_crtc_duplicate_state,\n\t.atomic_destroy_state = dm_crtc_destroy_state,\n\t.set_crc_source = amdgpu_dm_crtc_set_crc_source,\n\t.verify_crc_source = amdgpu_dm_crtc_verify_crc_source,\n\t.get_crc_sources = amdgpu_dm_crtc_get_crc_sources,\n\t.get_vblank_counter = amdgpu_get_vblank_counter_kms,\n\t.enable_vblank = dm_enable_vblank,\n\t.disable_vblank = dm_disable_vblank,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n};\n\nstatic enum drm_connector_status\namdgpu_dm_connector_detect(struct drm_connector *connector, bool force)\n{\n\tbool connected;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\n\t/*\n\t * Notes:\n\t * 1. This interface is NOT called in context of HPD irq.\n\t * 2. This interface *is called* in context of user-mode ioctl. Which\n\t * makes it a bad place for *any* MST-related activity.\n\t */\n\n\tif (aconnector->base.force == DRM_FORCE_UNSPECIFIED &&\n\t    !aconnector->fake_enable)\n\t\tconnected = (aconnector->dc_sink != NULL);\n\telse\n\t\tconnected = (aconnector->base.force == DRM_FORCE_ON);\n\n\tupdate_subconnector_property(aconnector);\n\n\treturn (connected ? connector_status_connected :\n\t\t\tconnector_status_disconnected);\n}\n\nint amdgpu_dm_connector_atomic_set_property(struct drm_connector *connector,\n\t\t\t\t\t    struct drm_connector_state *connector_state,\n\t\t\t\t\t    struct drm_property *property,\n\t\t\t\t\t    uint64_t val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dm_connector_state *dm_old_state =\n\t\tto_dm_connector_state(connector->state);\n\tstruct dm_connector_state *dm_new_state =\n\t\tto_dm_connector_state(connector_state);\n\n\tint ret = -EINVAL;\n\n\tif (property == dev->mode_config.scaling_mode_property) {\n\t\tenum amdgpu_rmx_type rmx_type;\n\n\t\tswitch (val) {\n\t\tcase DRM_MODE_SCALE_CENTER:\n\t\t\trmx_type = RMX_CENTER;\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_ASPECT:\n\t\t\trmx_type = RMX_ASPECT;\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\t\trmx_type = RMX_FULL;\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_NONE:\n\t\tdefault:\n\t\t\trmx_type = RMX_OFF;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dm_old_state->scaling == rmx_type)\n\t\t\treturn 0;\n\n\t\tdm_new_state->scaling = rmx_type;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.underscan_hborder_property) {\n\t\tdm_new_state->underscan_hborder = val;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.underscan_vborder_property) {\n\t\tdm_new_state->underscan_vborder = val;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.underscan_property) {\n\t\tdm_new_state->underscan_enable = val;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.abm_level_property) {\n\t\tdm_new_state->abm_level = val;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dm_connector_atomic_get_property(struct drm_connector *connector,\n\t\t\t\t\t    const struct drm_connector_state *state,\n\t\t\t\t\t    struct drm_property *property,\n\t\t\t\t\t    uint64_t *val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dm_connector_state *dm_state =\n\t\tto_dm_connector_state(state);\n\tint ret = -EINVAL;\n\n\tif (property == dev->mode_config.scaling_mode_property) {\n\t\tswitch (dm_state->scaling) {\n\t\tcase RMX_CENTER:\n\t\t\t*val = DRM_MODE_SCALE_CENTER;\n\t\t\tbreak;\n\t\tcase RMX_ASPECT:\n\t\t\t*val = DRM_MODE_SCALE_ASPECT;\n\t\t\tbreak;\n\t\tcase RMX_FULL:\n\t\t\t*val = DRM_MODE_SCALE_FULLSCREEN;\n\t\t\tbreak;\n\t\tcase RMX_OFF:\n\t\tdefault:\n\t\t\t*val = DRM_MODE_SCALE_NONE;\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t} else if (property == adev->mode_info.underscan_hborder_property) {\n\t\t*val = dm_state->underscan_hborder;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.underscan_vborder_property) {\n\t\t*val = dm_state->underscan_vborder;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.underscan_property) {\n\t\t*val = dm_state->underscan_enable;\n\t\tret = 0;\n\t} else if (property == adev->mode_info.abm_level_property) {\n\t\t*val = dm_state->abm_level;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void amdgpu_dm_connector_unregister(struct drm_connector *connector)\n{\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector = to_amdgpu_dm_connector(connector);\n\n\tdrm_dp_aux_unregister(&amdgpu_dm_connector->dm_dp_aux.aux);\n}\n\nstatic void amdgpu_dm_connector_destroy(struct drm_connector *connector)\n{\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tconst struct dc_link *link = aconnector->dc_link;\n\tstruct amdgpu_device *adev = drm_to_adev(connector->dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\n\t/*\n\t * Call only if mst_mgr was iniitalized before since it's not done\n\t * for all connector types.\n\t */\n\tif (aconnector->mst_mgr.dev)\n\t\tdrm_dp_mst_topology_mgr_destroy(&aconnector->mst_mgr);\n\n#if defined(CONFIG_BACKLIGHT_CLASS_DEVICE) ||\\\n\tdefined(CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE)\n\n\tif ((link->connector_signal & (SIGNAL_TYPE_EDP | SIGNAL_TYPE_LVDS)) &&\n\t    link->type != dc_connection_none &&\n\t    dm->backlight_dev) {\n\t\tbacklight_device_unregister(dm->backlight_dev);\n\t\tdm->backlight_dev = NULL;\n\t}\n#endif\n\n\tif (aconnector->dc_em_sink)\n\t\tdc_sink_release(aconnector->dc_em_sink);\n\taconnector->dc_em_sink = NULL;\n\tif (aconnector->dc_sink)\n\t\tdc_sink_release(aconnector->dc_sink);\n\taconnector->dc_sink = NULL;\n\n\tdrm_dp_cec_unregister_connector(&aconnector->dm_dp_aux.aux);\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\tif (aconnector->i2c) {\n\t\ti2c_del_adapter(&aconnector->i2c->base);\n\t\tkfree(aconnector->i2c);\n\t}\n\tkfree(aconnector->dm_dp_aux.aux.name);\n\n\tkfree(connector);\n}\n\nvoid amdgpu_dm_connector_funcs_reset(struct drm_connector *connector)\n{\n\tstruct dm_connector_state *state =\n\t\tto_dm_connector_state(connector->state);\n\n\tif (connector->state)\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\n\tkfree(state);\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\n\tif (state) {\n\t\tstate->scaling = RMX_OFF;\n\t\tstate->underscan_enable = false;\n\t\tstate->underscan_hborder = 0;\n\t\tstate->underscan_vborder = 0;\n\t\tstate->base.max_requested_bpc = 8;\n\t\tstate->vcpi_slots = 0;\n\t\tstate->pbn = 0;\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\t\tstate->abm_level = amdgpu_dm_abm_level;\n\n\t\t__drm_atomic_helper_connector_reset(connector, &state->base);\n\t}\n}\n\nstruct drm_connector_state *\namdgpu_dm_connector_atomic_duplicate_state(struct drm_connector *connector)\n{\n\tstruct dm_connector_state *state =\n\t\tto_dm_connector_state(connector->state);\n\n\tstruct dm_connector_state *new_state =\n\t\t\tkmemdup(state, sizeof(*state), GFP_KERNEL);\n\n\tif (!new_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &new_state->base);\n\n\tnew_state->freesync_capable = state->freesync_capable;\n\tnew_state->abm_level = state->abm_level;\n\tnew_state->scaling = state->scaling;\n\tnew_state->underscan_enable = state->underscan_enable;\n\tnew_state->underscan_hborder = state->underscan_hborder;\n\tnew_state->underscan_vborder = state->underscan_vborder;\n\tnew_state->vcpi_slots = state->vcpi_slots;\n\tnew_state->pbn = state->pbn;\n\treturn &new_state->base;\n}\n\nstatic int\namdgpu_dm_connector_late_register(struct drm_connector *connector)\n{\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector =\n\t\tto_amdgpu_dm_connector(connector);\n\tint r;\n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {\n\t\tamdgpu_dm_connector->dm_dp_aux.aux.dev = connector->kdev;\n\t\tr = drm_dp_aux_register(&amdgpu_dm_connector->dm_dp_aux.aux);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n#if defined(CONFIG_DEBUG_FS)\n\tconnector_debugfs_init(amdgpu_dm_connector);\n#endif\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_funcs amdgpu_dm_connector_funcs = {\n\t.reset = amdgpu_dm_connector_funcs_reset,\n\t.detect = amdgpu_dm_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = amdgpu_dm_connector_destroy,\n\t.atomic_duplicate_state = amdgpu_dm_connector_atomic_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.atomic_set_property = amdgpu_dm_connector_atomic_set_property,\n\t.atomic_get_property = amdgpu_dm_connector_atomic_get_property,\n\t.late_register = amdgpu_dm_connector_late_register,\n\t.early_unregister = amdgpu_dm_connector_unregister\n};\n\nstatic int get_modes(struct drm_connector *connector)\n{\n\treturn amdgpu_dm_connector_get_modes(connector);\n}\n\nstatic void create_eml_sink(struct amdgpu_dm_connector *aconnector)\n{\n\tstruct dc_sink_init_data init_params = {\n\t\t\t.link = aconnector->dc_link,\n\t\t\t.sink_signal = SIGNAL_TYPE_VIRTUAL\n\t};\n\tstruct edid *edid;\n\n\tif (!aconnector->base.edid_blob_ptr) {\n\t\tDRM_ERROR(\"No EDID firmware found on connector: %s ,forcing to OFF!\\n\",\n\t\t\t\taconnector->base.name);\n\n\t\taconnector->base.force = DRM_FORCE_OFF;\n\t\taconnector->base.override_edid = false;\n\t\treturn;\n\t}\n\n\tedid = (struct edid *) aconnector->base.edid_blob_ptr->data;\n\n\taconnector->edid = edid;\n\n\taconnector->dc_em_sink = dc_link_add_remote_sink(\n\t\taconnector->dc_link,\n\t\t(uint8_t *)edid,\n\t\t(edid->extensions + 1) * EDID_LENGTH,\n\t\t&init_params);\n\n\tif (aconnector->base.force == DRM_FORCE_ON) {\n\t\taconnector->dc_sink = aconnector->dc_link->local_sink ?\n\t\taconnector->dc_link->local_sink :\n\t\taconnector->dc_em_sink;\n\t\tdc_sink_retain(aconnector->dc_sink);\n\t}\n}\n\nstatic void handle_edid_mgmt(struct amdgpu_dm_connector *aconnector)\n{\n\tstruct dc_link *link = (struct dc_link *)aconnector->dc_link;\n\n\t/*\n\t * In case of headless boot with force on for DP managed connector\n\t * Those settings have to be != 0 to get initial modeset\n\t */\n\tif (link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT) {\n\t\tlink->verified_link_cap.lane_count = LANE_COUNT_FOUR;\n\t\tlink->verified_link_cap.link_rate = LINK_RATE_HIGH2;\n\t}\n\n\n\taconnector->base.override_edid = true;\n\tcreate_eml_sink(aconnector);\n}\n\nstatic struct dc_stream_state *\ncreate_validate_stream_for_sink(struct amdgpu_dm_connector *aconnector,\n\t\t\t\tconst struct drm_display_mode *drm_mode,\n\t\t\t\tconst struct dm_connector_state *dm_state,\n\t\t\t\tconst struct dc_stream_state *old_stream)\n{\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct amdgpu_device *adev = drm_to_adev(connector->dev);\n\tstruct dc_stream_state *stream;\n\tconst struct drm_connector_state *drm_state = dm_state ? &dm_state->base : NULL;\n\tint requested_bpc = drm_state ? drm_state->max_requested_bpc : 8;\n\tenum dc_status dc_result = DC_OK;\n\n\tdo {\n\t\tstream = create_stream_for_sink(aconnector, drm_mode,\n\t\t\t\t\t\tdm_state, old_stream,\n\t\t\t\t\t\trequested_bpc);\n\t\tif (stream == NULL) {\n\t\t\tDRM_ERROR(\"Failed to create stream for sink!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdc_result = dc_validate_stream(adev->dm.dc, stream);\n\n\t\tif (dc_result != DC_OK) {\n\t\t\tDRM_DEBUG_KMS(\"Mode %dx%d (clk %d) failed DC validation with error %d (%s)\\n\",\n\t\t\t\t      drm_mode->hdisplay,\n\t\t\t\t      drm_mode->vdisplay,\n\t\t\t\t      drm_mode->clock,\n\t\t\t\t      dc_result,\n\t\t\t\t      dc_status_to_str(dc_result));\n\n\t\t\tdc_stream_release(stream);\n\t\t\tstream = NULL;\n\t\t\trequested_bpc -= 2; /* lower bpc to retry validation */\n\t\t}\n\n\t} while (stream == NULL && requested_bpc >= 6);\n\n\treturn stream;\n}\n\nenum drm_mode_status amdgpu_dm_connector_mode_valid(struct drm_connector *connector,\n\t\t\t\t   struct drm_display_mode *mode)\n{\n\tint result = MODE_ERROR;\n\tstruct dc_sink *dc_sink;\n\t/* TODO: Unhardcode stream count */\n\tstruct dc_stream_state *stream;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\n\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE) ||\n\t\t\t(mode->flags & DRM_MODE_FLAG_DBLSCAN))\n\t\treturn result;\n\n\t/*\n\t * Only run this the first time mode_valid is called to initilialize\n\t * EDID mgmt\n\t */\n\tif (aconnector->base.force != DRM_FORCE_UNSPECIFIED &&\n\t\t!aconnector->dc_em_sink)\n\t\thandle_edid_mgmt(aconnector);\n\n\tdc_sink = to_amdgpu_dm_connector(connector)->dc_sink;\n\n\tif (dc_sink == NULL && aconnector->base.force != DRM_FORCE_ON_DIGITAL &&\n\t\t\t\taconnector->base.force != DRM_FORCE_ON) {\n\t\tDRM_ERROR(\"dc_sink is NULL!\\n\");\n\t\tgoto fail;\n\t}\n\n\tstream = create_validate_stream_for_sink(aconnector, mode, NULL, NULL);\n\tif (stream) {\n\t\tdc_stream_release(stream);\n\t\tresult = MODE_OK;\n\t}\n\nfail:\n\t/* TODO: error handling*/\n\treturn result;\n}\n\nstatic int fill_hdr_info_packet(const struct drm_connector_state *state,\n\t\t\t\tstruct dc_info_packet *out)\n{\n\tstruct hdmi_drm_infoframe frame;\n\tunsigned char buf[30]; /* 26 + 4 */\n\tssize_t len;\n\tint ret, i;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (!state->hdr_output_metadata)\n\t\treturn 0;\n\n\tret = drm_hdmi_infoframe_set_hdr_metadata(&frame, state);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = hdmi_drm_infoframe_pack_only(&frame, buf, sizeof(buf));\n\tif (len < 0)\n\t\treturn (int)len;\n\n\t/* Static metadata is a fixed 26 bytes + 4 byte header. */\n\tif (len != 30)\n\t\treturn -EINVAL;\n\n\t/* Prepare the infopacket for DC. */\n\tswitch (state->connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tout->hb0 = 0x87; /* type */\n\t\tout->hb1 = 0x01; /* version */\n\t\tout->hb2 = 0x1A; /* length */\n\t\tout->sb[0] = buf[3]; /* checksum */\n\t\ti = 1;\n\t\tbreak;\n\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tout->hb0 = 0x00; /* sdp id, zero */\n\t\tout->hb1 = 0x87; /* type */\n\t\tout->hb2 = 0x1D; /* payload len - 1 */\n\t\tout->hb3 = (0x13 << 2); /* sdp version */\n\t\tout->sb[0] = 0x01; /* version */\n\t\tout->sb[1] = 0x1A; /* length */\n\t\ti = 2;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&out->sb[i], &buf[4], 26);\n\tout->valid = true;\n\n\tprint_hex_dump(KERN_DEBUG, \"HDR SB:\", DUMP_PREFIX_NONE, 16, 1, out->sb,\n\t\t       sizeof(out->sb), false);\n\n\treturn 0;\n}\n\nstatic bool\nis_hdr_metadata_different(const struct drm_connector_state *old_state,\n\t\t\t  const struct drm_connector_state *new_state)\n{\n\tstruct drm_property_blob *old_blob = old_state->hdr_output_metadata;\n\tstruct drm_property_blob *new_blob = new_state->hdr_output_metadata;\n\n\tif (old_blob != new_blob) {\n\t\tif (old_blob && new_blob &&\n\t\t    old_blob->length == new_blob->length)\n\t\t\treturn memcmp(old_blob->data, new_blob->data,\n\t\t\t\t      old_blob->length);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\namdgpu_dm_connector_atomic_check(struct drm_connector *conn,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *new_con_state =\n\t\tdrm_atomic_get_new_connector_state(state, conn);\n\tstruct drm_connector_state *old_con_state =\n\t\tdrm_atomic_get_old_connector_state(state, conn);\n\tstruct drm_crtc *crtc = new_con_state->crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tint ret;\n\n\ttrace_amdgpu_dm_connector_atomic_check(new_con_state);\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tif (is_hdr_metadata_different(old_con_state, new_con_state)) {\n\t\tstruct dc_info_packet hdr_infopacket;\n\n\t\tret = fill_hdr_info_packet(new_con_state, &hdr_infopacket);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnew_crtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(new_crtc_state))\n\t\t\treturn PTR_ERR(new_crtc_state);\n\n\t\t/*\n\t\t * DC considers the stream backends changed if the\n\t\t * static metadata changes. Forcing the modeset also\n\t\t * gives a simple way for userspace to switch from\n\t\t * 8bpc to 10bpc when setting the metadata to enter\n\t\t * or exit HDR.\n\t\t *\n\t\t * Changing the static metadata after it's been\n\t\t * set is permissible, however. So only force a\n\t\t * modeset if we're entering or exiting HDR.\n\t\t */\n\t\tnew_crtc_state->mode_changed =\n\t\t\t!old_con_state->hdr_output_metadata ||\n\t\t\t!new_con_state->hdr_output_metadata;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs\namdgpu_dm_connector_helper_funcs = {\n\t/*\n\t * If hotplugging a second bigger display in FB Con mode, bigger resolution\n\t * modes will be filtered by drm_mode_validate_size(), and those modes\n\t * are missing after user start lightdm. So we need to renew modes list.\n\t * in get_modes call back, not just return the modes count\n\t */\n\t.get_modes = get_modes,\n\t.mode_valid = amdgpu_dm_connector_mode_valid,\n\t.atomic_check = amdgpu_dm_connector_atomic_check,\n};\n\nstatic void dm_crtc_helper_disable(struct drm_crtc *crtc)\n{\n}\n\nstatic int count_crtc_active_planes(struct drm_crtc_state *new_crtc_state)\n{\n\tstruct drm_atomic_state *state = new_crtc_state->state;\n\tstruct drm_plane *plane;\n\tint num_active = 0;\n\n\tdrm_for_each_plane_mask(plane, state->dev, new_crtc_state->plane_mask) {\n\t\tstruct drm_plane_state *new_plane_state;\n\n\t\t/* Cursor planes are \"fake\". */\n\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcontinue;\n\n\t\tnew_plane_state = drm_atomic_get_new_plane_state(state, plane);\n\n\t\tif (!new_plane_state) {\n\t\t\t/*\n\t\t\t * The plane is enable on the CRTC and hasn't changed\n\t\t\t * state. This means that it previously passed\n\t\t\t * validation and is therefore enabled.\n\t\t\t */\n\t\t\tnum_active += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We need a framebuffer to be considered enabled. */\n\t\tnum_active += (new_plane_state->fb != NULL);\n\t}\n\n\treturn num_active;\n}\n\nstatic void dm_update_crtc_active_planes(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_crtc_state *new_crtc_state)\n{\n\tstruct dm_crtc_state *dm_new_crtc_state =\n\t\tto_dm_crtc_state(new_crtc_state);\n\n\tdm_new_crtc_state->active_planes = 0;\n\n\tif (!dm_new_crtc_state->stream)\n\t\treturn;\n\n\tdm_new_crtc_state->active_planes =\n\t\tcount_crtc_active_planes(new_crtc_state);\n}\n\nstatic int dm_crtc_helper_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct amdgpu_device *adev = drm_to_adev(crtc->dev);\n\tstruct dc *dc = adev->dm.dc;\n\tstruct dm_crtc_state *dm_crtc_state = to_dm_crtc_state(crtc_state);\n\tint ret = -EINVAL;\n\n\ttrace_amdgpu_dm_crtc_atomic_check(crtc_state);\n\n\tdm_update_crtc_active_planes(crtc, crtc_state);\n\n\tif (unlikely(!dm_crtc_state->stream &&\n\t\t     modeset_required(crtc_state, NULL, dm_crtc_state->stream))) {\n\t\tWARN_ON(1);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * We require the primary plane to be enabled whenever the CRTC is, otherwise\n\t * drm_mode_cursor_universal may end up trying to enable the cursor plane while all other\n\t * planes are disabled, which is not supported by the hardware. And there is legacy\n\t * userspace which stops using the HW cursor altogether in response to the resulting EINVAL.\n\t */\n\tif (crtc_state->enable &&\n\t    !(crtc_state->plane_mask & drm_plane_mask(crtc->primary))) {\n\t\tDRM_DEBUG_ATOMIC(\"Can't enable a CRTC without enabling the primary plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* In some use cases, like reset, no stream is attached */\n\tif (!dm_crtc_state->stream)\n\t\treturn 0;\n\n\tif (dc_validate_stream(dc, dm_crtc_state->stream) == DC_OK)\n\t\treturn 0;\n\n\tDRM_DEBUG_ATOMIC(\"Failed DC stream validation\\n\");\n\treturn ret;\n}\n\nstatic bool dm_crtc_helper_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\treturn true;\n}\n\nstatic const struct drm_crtc_helper_funcs amdgpu_dm_crtc_helper_funcs = {\n\t.disable = dm_crtc_helper_disable,\n\t.atomic_check = dm_crtc_helper_atomic_check,\n\t.mode_fixup = dm_crtc_helper_mode_fixup,\n\t.get_scanout_position = amdgpu_crtc_get_scanout_position,\n};\n\nstatic void dm_encoder_helper_disable(struct drm_encoder *encoder)\n{\n\n}\n\nstatic int convert_dc_color_depth_into_bpc (enum dc_color_depth display_color_depth)\n{\n\tswitch (display_color_depth) {\n\t\tcase COLOR_DEPTH_666:\n\t\t\treturn 6;\n\t\tcase COLOR_DEPTH_888:\n\t\t\treturn 8;\n\t\tcase COLOR_DEPTH_101010:\n\t\t\treturn 10;\n\t\tcase COLOR_DEPTH_121212:\n\t\t\treturn 12;\n\t\tcase COLOR_DEPTH_141414:\n\t\t\treturn 14;\n\t\tcase COLOR_DEPTH_161616:\n\t\t\treturn 16;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\treturn 0;\n}\n\nstatic int dm_encoder_helper_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct drm_atomic_state *state = crtc_state->state;\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct dm_connector_state *dm_new_connector_state = to_dm_connector_state(conn_state);\n\tconst struct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\tstruct drm_dp_mst_topology_mgr *mst_mgr;\n\tstruct drm_dp_mst_port *mst_port;\n\tenum dc_color_depth color_depth;\n\tint clock, bpp = 0;\n\tbool is_y420 = false;\n\n\tif (!aconnector->port || !aconnector->dc_sink)\n\t\treturn 0;\n\n\tmst_port = aconnector->port;\n\tmst_mgr = &aconnector->mst_port->mst_mgr;\n\n\tif (!crtc_state->connectors_changed && !crtc_state->mode_changed)\n\t\treturn 0;\n\n\tif (!state->duplicated) {\n\t\tint max_bpc = conn_state->max_requested_bpc;\n\t\tis_y420 = drm_mode_is_420_also(&connector->display_info, adjusted_mode) &&\n\t\t\t\taconnector->force_yuv420_output;\n\t\tcolor_depth = convert_color_depth_from_display_info(connector,\n\t\t\t\t\t\t\t\t    is_y420,\n\t\t\t\t\t\t\t\t    max_bpc);\n\t\tbpp = convert_dc_color_depth_into_bpc(color_depth) * 3;\n\t\tclock = adjusted_mode->clock;\n\t\tdm_new_connector_state->pbn = drm_dp_calc_pbn_mode(clock, bpp, false);\n\t}\n\tdm_new_connector_state->vcpi_slots = drm_dp_atomic_find_vcpi_slots(state,\n\t\t\t\t\t\t\t\t\t   mst_mgr,\n\t\t\t\t\t\t\t\t\t   mst_port,\n\t\t\t\t\t\t\t\t\t   dm_new_connector_state->pbn,\n\t\t\t\t\t\t\t\t\t   dm_mst_get_pbn_divider(aconnector->dc_link));\n\tif (dm_new_connector_state->vcpi_slots < 0) {\n\t\tDRM_DEBUG_ATOMIC(\"failed finding vcpi slots: %d\\n\", (int)dm_new_connector_state->vcpi_slots);\n\t\treturn dm_new_connector_state->vcpi_slots;\n\t}\n\treturn 0;\n}\n\nconst struct drm_encoder_helper_funcs amdgpu_dm_encoder_helper_funcs = {\n\t.disable = dm_encoder_helper_disable,\n\t.atomic_check = dm_encoder_helper_atomic_check\n};\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\nstatic int dm_update_mst_vcpi_slots_for_dsc(struct drm_atomic_state *state,\n\t\t\t\t\t    struct dc_state *dc_state)\n{\n\tstruct dc_stream_state *stream = NULL;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_con_state, *old_con_state;\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct dm_connector_state *dm_conn_state;\n\tint i, j, clock, bpp;\n\tint vcpi, pbn_div, pbn = 0;\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\tif (!aconnector->port)\n\t\t\tcontinue;\n\n\t\tif (!new_con_state || !new_con_state->crtc)\n\t\t\tcontinue;\n\n\t\tdm_conn_state = to_dm_connector_state(new_con_state);\n\n\t\tfor (j = 0; j < dc_state->stream_count; j++) {\n\t\t\tstream = dc_state->streams[j];\n\t\t\tif (!stream)\n\t\t\t\tcontinue;\n\n\t\t\tif ((struct amdgpu_dm_connector*)stream->dm_stream_context == aconnector)\n\t\t\t\tbreak;\n\n\t\t\tstream = NULL;\n\t\t}\n\n\t\tif (!stream)\n\t\t\tcontinue;\n\n\t\tif (stream->timing.flags.DSC != 1) {\n\t\t\tdrm_dp_mst_atomic_enable_dsc(state,\n\t\t\t\t\t\t     aconnector->port,\n\t\t\t\t\t\t     dm_conn_state->pbn,\n\t\t\t\t\t\t     0,\n\t\t\t\t\t\t     false);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpbn_div = dm_mst_get_pbn_divider(stream->link);\n\t\tbpp = stream->timing.dsc_cfg.bits_per_pixel;\n\t\tclock = stream->timing.pix_clk_100hz / 10;\n\t\tpbn = drm_dp_calc_pbn_mode(clock, bpp, true);\n\t\tvcpi = drm_dp_mst_atomic_enable_dsc(state,\n\t\t\t\t\t\t    aconnector->port,\n\t\t\t\t\t\t    pbn, pbn_div,\n\t\t\t\t\t\t    true);\n\t\tif (vcpi < 0)\n\t\t\treturn vcpi;\n\n\t\tdm_conn_state->pbn = pbn;\n\t\tdm_conn_state->vcpi_slots = vcpi;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void dm_drm_plane_reset(struct drm_plane *plane)\n{\n\tstruct dm_plane_state *amdgpu_state = NULL;\n\n\tif (plane->state)\n\t\tplane->funcs->atomic_destroy_state(plane, plane->state);\n\n\tamdgpu_state = kzalloc(sizeof(*amdgpu_state), GFP_KERNEL);\n\tWARN_ON(amdgpu_state == NULL);\n\n\tif (amdgpu_state)\n\t\t__drm_atomic_helper_plane_reset(plane, &amdgpu_state->base);\n}\n\nstatic struct drm_plane_state *\ndm_drm_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct dm_plane_state *dm_plane_state, *old_dm_plane_state;\n\n\told_dm_plane_state = to_dm_plane_state(plane->state);\n\tdm_plane_state = kzalloc(sizeof(*dm_plane_state), GFP_KERNEL);\n\tif (!dm_plane_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &dm_plane_state->base);\n\n\tif (old_dm_plane_state->dc_state) {\n\t\tdm_plane_state->dc_state = old_dm_plane_state->dc_state;\n\t\tdc_plane_state_retain(dm_plane_state->dc_state);\n\t}\n\n\treturn &dm_plane_state->base;\n}\n\nstatic void dm_drm_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\tstruct drm_plane_state *state)\n{\n\tstruct dm_plane_state *dm_plane_state = to_dm_plane_state(state);\n\n\tif (dm_plane_state->dc_state)\n\t\tdc_plane_state_release(dm_plane_state->dc_state);\n\n\tdrm_atomic_helper_plane_destroy_state(plane, state);\n}\n\nstatic const struct drm_plane_funcs dm_plane_funcs = {\n\t.update_plane\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t= drm_atomic_helper_disable_plane,\n\t.destroy\t= drm_primary_helper_destroy,\n\t.reset = dm_drm_plane_reset,\n\t.atomic_duplicate_state = dm_drm_plane_duplicate_state,\n\t.atomic_destroy_state = dm_drm_plane_destroy_state,\n\t.format_mod_supported = dm_plane_format_mod_supported,\n};\n\nstatic int dm_plane_helper_prepare_fb(struct drm_plane *plane,\n\t\t\t\t      struct drm_plane_state *new_state)\n{\n\tstruct amdgpu_framebuffer *afb;\n\tstruct drm_gem_object *obj;\n\tstruct amdgpu_device *adev;\n\tstruct amdgpu_bo *rbo;\n\tstruct dm_plane_state *dm_plane_state_new, *dm_plane_state_old;\n\tstruct list_head list;\n\tstruct ttm_validate_buffer tv;\n\tstruct ww_acquire_ctx ticket;\n\tuint32_t domain;\n\tint r;\n\n\tif (!new_state->fb) {\n\t\tDRM_DEBUG_DRIVER(\"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\tafb = to_amdgpu_framebuffer(new_state->fb);\n\tobj = new_state->fb->obj[0];\n\trbo = gem_to_amdgpu_bo(obj);\n\tadev = amdgpu_ttm_adev(rbo->tbo.bdev);\n\tINIT_LIST_HEAD(&list);\n\n\ttv.bo = &rbo->tbo;\n\ttv.num_shared = 1;\n\tlist_add(&tv.head, &list);\n\n\tr = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);\n\tif (r) {\n\t\tdev_err(adev->dev, \"fail to reserve bo (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\tif (plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\tdomain = amdgpu_display_supported_domains(adev, rbo->flags);\n\telse\n\t\tdomain = AMDGPU_GEM_DOMAIN_VRAM;\n\n\tr = amdgpu_bo_pin(rbo, domain);\n\tif (unlikely(r != 0)) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"Failed to pin framebuffer with error %d\\n\", r);\n\t\tttm_eu_backoff_reservation(&ticket, &list);\n\t\treturn r;\n\t}\n\n\tr = amdgpu_ttm_alloc_gart(&rbo->tbo);\n\tif (unlikely(r != 0)) {\n\t\tamdgpu_bo_unpin(rbo);\n\t\tttm_eu_backoff_reservation(&ticket, &list);\n\t\tDRM_ERROR(\"%p bind failed\\n\", rbo);\n\t\treturn r;\n\t}\n\n\tttm_eu_backoff_reservation(&ticket, &list);\n\n\tafb->address = amdgpu_bo_gpu_offset(rbo);\n\n\tamdgpu_bo_ref(rbo);\n\n\t/**\n\t * We don't do surface updates on planes that have been newly created,\n\t * but we also don't have the afb->address during atomic check.\n\t *\n\t * Fill in buffer attributes depending on the address here, but only on\n\t * newly created planes since they're not being used by DC yet and this\n\t * won't modify global state.\n\t */\n\tdm_plane_state_old = to_dm_plane_state(plane->state);\n\tdm_plane_state_new = to_dm_plane_state(new_state);\n\n\tif (dm_plane_state_new->dc_state &&\n\t    dm_plane_state_old->dc_state != dm_plane_state_new->dc_state) {\n\t\tstruct dc_plane_state *plane_state =\n\t\t\tdm_plane_state_new->dc_state;\n\t\tbool force_disable_dcc = !plane_state->dcc.enable;\n\n\t\tfill_plane_buffer_attributes(\n\t\t\tadev, afb, plane_state->format, plane_state->rotation,\n\t\t\tafb->tiling_flags,\n\t\t\t&plane_state->tiling_info, &plane_state->plane_size,\n\t\t\t&plane_state->dcc, &plane_state->address,\n\t\t\tafb->tmz_surface, force_disable_dcc);\n\t}\n\n\treturn 0;\n}\n\nstatic void dm_plane_helper_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t       struct drm_plane_state *old_state)\n{\n\tstruct amdgpu_bo *rbo;\n\tint r;\n\n\tif (!old_state->fb)\n\t\treturn;\n\n\trbo = gem_to_amdgpu_bo(old_state->fb->obj[0]);\n\tr = amdgpu_bo_reserve(rbo, false);\n\tif (unlikely(r)) {\n\t\tDRM_ERROR(\"failed to reserve rbo before unpin\\n\");\n\t\treturn;\n\t}\n\n\tamdgpu_bo_unpin(rbo);\n\tamdgpu_bo_unreserve(rbo);\n\tamdgpu_bo_unref(&rbo);\n}\n\nstatic int dm_plane_helper_check_state(struct drm_plane_state *state,\n\t\t\t\t       struct drm_crtc_state *new_crtc_state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tint min_downscale, max_upscale;\n\tint min_scale = 0;\n\tint max_scale = INT_MAX;\n\n\t/* Plane enabled? Get min/max allowed scaling factors from plane caps. */\n\tif (fb && state->crtc) {\n\t\tget_min_max_dc_plane_scaling(state->crtc->dev, fb,\n\t\t\t\t\t     &min_downscale, &max_upscale);\n\t\t/*\n\t\t * Convert to drm convention: 16.16 fixed point, instead of dc's\n\t\t * 1.0 == 1000. Also drm scaling is src/dst instead of dc's\n\t\t * dst/src, so min_scale = 1.0 / max_upscale, etc.\n\t\t */\n\t\tmin_scale = (1000 << 16) / max_upscale;\n\t\tmax_scale = (1000 << 16) / min_downscale;\n\t}\n\n\treturn drm_atomic_helper_check_plane_state(\n\t\tstate, new_crtc_state, min_scale, max_scale, true, true);\n}\n\nstatic int dm_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *state)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(plane->dev);\n\tstruct dc *dc = adev->dm.dc;\n\tstruct dm_plane_state *dm_plane_state;\n\tstruct dc_scaling_info scaling_info;\n\tstruct drm_crtc_state *new_crtc_state;\n\tint ret;\n\n\ttrace_amdgpu_dm_plane_atomic_check(state);\n\n\tdm_plane_state = to_dm_plane_state(state);\n\n\tif (!dm_plane_state->dc_state)\n\t\treturn 0;\n\n\tnew_crtc_state =\n\t\tdrm_atomic_get_new_crtc_state(state->state, state->crtc);\n\tif (!new_crtc_state)\n\t\treturn -EINVAL;\n\n\tret = dm_plane_helper_check_state(state, new_crtc_state);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fill_dc_scaling_info(state, &scaling_info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dc_validate_plane(dc, dm_plane_state->dc_state) == DC_OK)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int dm_plane_atomic_async_check(struct drm_plane *plane,\n\t\t\t\t       struct drm_plane_state *new_plane_state)\n{\n\t/* Only support async updates on cursor planes. */\n\tif (plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void dm_plane_atomic_async_update(struct drm_plane *plane,\n\t\t\t\t\t struct drm_plane_state *new_state)\n{\n\tstruct drm_plane_state *old_state =\n\t\tdrm_atomic_get_old_plane_state(new_state->state, plane);\n\n\ttrace_amdgpu_dm_atomic_update_cursor(new_state);\n\n\tswap(plane->state->fb, new_state->fb);\n\n\tplane->state->src_x = new_state->src_x;\n\tplane->state->src_y = new_state->src_y;\n\tplane->state->src_w = new_state->src_w;\n\tplane->state->src_h = new_state->src_h;\n\tplane->state->crtc_x = new_state->crtc_x;\n\tplane->state->crtc_y = new_state->crtc_y;\n\tplane->state->crtc_w = new_state->crtc_w;\n\tplane->state->crtc_h = new_state->crtc_h;\n\n\thandle_cursor_update(plane, old_state);\n}\n\nstatic const struct drm_plane_helper_funcs dm_plane_helper_funcs = {\n\t.prepare_fb = dm_plane_helper_prepare_fb,\n\t.cleanup_fb = dm_plane_helper_cleanup_fb,\n\t.atomic_check = dm_plane_atomic_check,\n\t.atomic_async_check = dm_plane_atomic_async_check,\n\t.atomic_async_update = dm_plane_atomic_async_update\n};\n\n/*\n * TODO: these are currently initialized to rgb formats only.\n * For future use cases we should either initialize them dynamically based on\n * plane capabilities, or initialize this array to all formats, so internal drm\n * check will succeed, and let DC implement proper check\n */\nstatic const uint32_t rgb_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_RGB565,\n};\n\nstatic const uint32_t overlay_formats[] = {\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_RGB565\n};\n\nstatic const u32 cursor_formats[] = {\n\tDRM_FORMAT_ARGB8888\n};\n\nstatic int get_plane_formats(const struct drm_plane *plane,\n\t\t\t     const struct dc_plane_cap *plane_cap,\n\t\t\t     uint32_t *formats, int max_formats)\n{\n\tint i, num_formats = 0;\n\n\t/*\n\t * TODO: Query support for each group of formats directly from\n\t * DC plane caps. This will require adding more formats to the\n\t * caps list.\n\t */\n\n\tswitch (plane->type) {\n\tcase DRM_PLANE_TYPE_PRIMARY:\n\t\tfor (i = 0; i < ARRAY_SIZE(rgb_formats); ++i) {\n\t\t\tif (num_formats >= max_formats)\n\t\t\t\tbreak;\n\n\t\t\tformats[num_formats++] = rgb_formats[i];\n\t\t}\n\n\t\tif (plane_cap && plane_cap->pixel_format_support.nv12)\n\t\t\tformats[num_formats++] = DRM_FORMAT_NV12;\n\t\tif (plane_cap && plane_cap->pixel_format_support.p010)\n\t\t\tformats[num_formats++] = DRM_FORMAT_P010;\n\t\tif (plane_cap && plane_cap->pixel_format_support.fp16) {\n\t\t\tformats[num_formats++] = DRM_FORMAT_XRGB16161616F;\n\t\t\tformats[num_formats++] = DRM_FORMAT_ARGB16161616F;\n\t\t\tformats[num_formats++] = DRM_FORMAT_XBGR16161616F;\n\t\t\tformats[num_formats++] = DRM_FORMAT_ABGR16161616F;\n\t\t}\n\t\tbreak;\n\n\tcase DRM_PLANE_TYPE_OVERLAY:\n\t\tfor (i = 0; i < ARRAY_SIZE(overlay_formats); ++i) {\n\t\t\tif (num_formats >= max_formats)\n\t\t\t\tbreak;\n\n\t\t\tformats[num_formats++] = overlay_formats[i];\n\t\t}\n\t\tbreak;\n\n\tcase DRM_PLANE_TYPE_CURSOR:\n\t\tfor (i = 0; i < ARRAY_SIZE(cursor_formats); ++i) {\n\t\t\tif (num_formats >= max_formats)\n\t\t\t\tbreak;\n\n\t\t\tformats[num_formats++] = cursor_formats[i];\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn num_formats;\n}\n\nstatic int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,\n\t\t\t\tstruct drm_plane *plane,\n\t\t\t\tunsigned long possible_crtcs,\n\t\t\t\tconst struct dc_plane_cap *plane_cap)\n{\n\tuint32_t formats[32];\n\tint num_formats;\n\tint res = -EPERM;\n\tunsigned int supported_rotations;\n\tuint64_t *modifiers = NULL;\n\n\tnum_formats = get_plane_formats(plane, plane_cap, formats,\n\t\t\t\t\tARRAY_SIZE(formats));\n\n\tres = get_plane_modifiers(dm->adev, plane->type, &modifiers);\n\tif (res)\n\t\treturn res;\n\n\tres = drm_universal_plane_init(adev_to_drm(dm->adev), plane, possible_crtcs,\n\t\t\t\t       &dm_plane_funcs, formats, num_formats,\n\t\t\t\t       modifiers, plane->type, NULL);\n\tkfree(modifiers);\n\tif (res)\n\t\treturn res;\n\n\tif (plane->type == DRM_PLANE_TYPE_OVERLAY &&\n\t    plane_cap && plane_cap->per_pixel_alpha) {\n\t\tunsigned int blend_caps = BIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\t\t  BIT(DRM_MODE_BLEND_PREMULTI);\n\n\t\tdrm_plane_create_alpha_property(plane);\n\t\tdrm_plane_create_blend_mode_property(plane, blend_caps);\n\t}\n\n\tif (plane->type == DRM_PLANE_TYPE_PRIMARY &&\n\t    plane_cap &&\n\t    (plane_cap->pixel_format_support.nv12 ||\n\t     plane_cap->pixel_format_support.p010)) {\n\t\t/* This only affects YUV formats. */\n\t\tdrm_plane_create_color_properties(\n\t\t\tplane,\n\t\t\tBIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\tBIT(DRM_COLOR_YCBCR_BT709) |\n\t\t\tBIT(DRM_COLOR_YCBCR_BT2020),\n\t\t\tBIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\tBIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\tDRM_COLOR_YCBCR_BT709, DRM_COLOR_YCBCR_LIMITED_RANGE);\n\t}\n\n\tsupported_rotations =\n\t\tDRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_90 |\n\t\tDRM_MODE_ROTATE_180 | DRM_MODE_ROTATE_270;\n\n\tif (dm->adev->asic_type >= CHIP_BONAIRE &&\n\t    plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\tdrm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t   supported_rotations);\n\n\tdrm_plane_helper_add(plane, &dm_plane_helper_funcs);\n\n\t/* Create (reset) the plane state */\n\tif (plane->funcs->reset)\n\t\tplane->funcs->reset(plane);\n\n\treturn 0;\n}\n\nstatic int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       uint32_t crtc_index)\n{\n\tstruct amdgpu_crtc *acrtc = NULL;\n\tstruct drm_plane *cursor_plane;\n\n\tint res = -ENOMEM;\n\n\tcursor_plane = kzalloc(sizeof(*cursor_plane), GFP_KERNEL);\n\tif (!cursor_plane)\n\t\tgoto fail;\n\n\tcursor_plane->type = DRM_PLANE_TYPE_CURSOR;\n\tres = amdgpu_dm_plane_init(dm, cursor_plane, 0, NULL);\n\n\tacrtc = kzalloc(sizeof(struct amdgpu_crtc), GFP_KERNEL);\n\tif (!acrtc)\n\t\tgoto fail;\n\n\tres = drm_crtc_init_with_planes(\n\t\t\tdm->ddev,\n\t\t\t&acrtc->base,\n\t\t\tplane,\n\t\t\tcursor_plane,\n\t\t\t&amdgpu_dm_crtc_funcs, NULL);\n\n\tif (res)\n\t\tgoto fail;\n\n\tdrm_crtc_helper_add(&acrtc->base, &amdgpu_dm_crtc_helper_funcs);\n\n\t/* Create (reset) the plane state */\n\tif (acrtc->base.funcs->reset)\n\t\tacrtc->base.funcs->reset(&acrtc->base);\n\n\tacrtc->max_cursor_width = dm->adev->dm.dc->caps.max_cursor_size;\n\tacrtc->max_cursor_height = dm->adev->dm.dc->caps.max_cursor_size;\n\n\tacrtc->crtc_id = crtc_index;\n\tacrtc->base.enabled = false;\n\tacrtc->otg_inst = -1;\n\n\tdm->adev->mode_info.crtcs[crtc_index] = acrtc;\n\tdrm_crtc_enable_color_mgmt(&acrtc->base, MAX_COLOR_LUT_ENTRIES,\n\t\t\t\t   true, MAX_COLOR_LUT_ENTRIES);\n\tdrm_mode_crtc_set_gamma_size(&acrtc->base, MAX_COLOR_LEGACY_LUT_ENTRIES);\n\n\treturn 0;\n\nfail:\n\tkfree(acrtc);\n\tkfree(cursor_plane);\n\treturn res;\n}\n\n\nstatic int to_drm_connector_type(enum signal_type st)\n{\n\tswitch (st) {\n\tcase SIGNAL_TYPE_HDMI_TYPE_A:\n\t\treturn DRM_MODE_CONNECTOR_HDMIA;\n\tcase SIGNAL_TYPE_EDP:\n\t\treturn DRM_MODE_CONNECTOR_eDP;\n\tcase SIGNAL_TYPE_LVDS:\n\t\treturn DRM_MODE_CONNECTOR_LVDS;\n\tcase SIGNAL_TYPE_RGB:\n\t\treturn DRM_MODE_CONNECTOR_VGA;\n\tcase SIGNAL_TYPE_DISPLAY_PORT:\n\tcase SIGNAL_TYPE_DISPLAY_PORT_MST:\n\t\treturn DRM_MODE_CONNECTOR_DisplayPort;\n\tcase SIGNAL_TYPE_DVI_DUAL_LINK:\n\tcase SIGNAL_TYPE_DVI_SINGLE_LINK:\n\t\treturn DRM_MODE_CONNECTOR_DVID;\n\tcase SIGNAL_TYPE_VIRTUAL:\n\t\treturn DRM_MODE_CONNECTOR_VIRTUAL;\n\n\tdefault:\n\t\treturn DRM_MODE_CONNECTOR_Unknown;\n\t}\n}\n\nstatic struct drm_encoder *amdgpu_dm_connector_to_encoder(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\n\t/* There is only one encoder per connector */\n\tdrm_connector_for_each_possible_encoder(connector, encoder)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic void amdgpu_dm_get_native_mode(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tstruct amdgpu_encoder *amdgpu_encoder;\n\n\tencoder = amdgpu_dm_connector_to_encoder(connector);\n\n\tif (encoder == NULL)\n\t\treturn;\n\n\tamdgpu_encoder = to_amdgpu_encoder(encoder);\n\n\tamdgpu_encoder->native_mode.clock = 0;\n\n\tif (!list_empty(&connector->probed_modes)) {\n\t\tstruct drm_display_mode *preferred_mode = NULL;\n\n\t\tlist_for_each_entry(preferred_mode,\n\t\t\t\t    &connector->probed_modes,\n\t\t\t\t    head) {\n\t\t\tif (preferred_mode->type & DRM_MODE_TYPE_PREFERRED)\n\t\t\t\tamdgpu_encoder->native_mode = *preferred_mode;\n\n\t\t\tbreak;\n\t\t}\n\n\t}\n}\n\nstatic struct drm_display_mode *\namdgpu_dm_create_common_mode(struct drm_encoder *encoder,\n\t\t\t     char *name,\n\t\t\t     int hdisplay, int vdisplay)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\n\tmode = drm_mode_duplicate(dev, native_mode);\n\n\tif (mode == NULL)\n\t\treturn NULL;\n\n\tmode->hdisplay = hdisplay;\n\tmode->vdisplay = vdisplay;\n\tmode->type &= ~DRM_MODE_TYPE_PREFERRED;\n\tstrscpy(mode->name, name, DRM_DISPLAY_MODE_LEN);\n\n\treturn mode;\n\n}\n\nstatic void amdgpu_dm_connector_add_common_modes(struct drm_encoder *encoder,\n\t\t\t\t\t\t struct drm_connector *connector)\n{\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector =\n\t\t\t\tto_amdgpu_dm_connector(connector);\n\tint i;\n\tint n;\n\tstruct mode_size {\n\t\tchar name[DRM_DISPLAY_MODE_LEN];\n\t\tint w;\n\t\tint h;\n\t} common_modes[] = {\n\t\t{  \"640x480\",  640,  480},\n\t\t{  \"800x600\",  800,  600},\n\t\t{ \"1024x768\", 1024,  768},\n\t\t{ \"1280x720\", 1280,  720},\n\t\t{ \"1280x800\", 1280,  800},\n\t\t{\"1280x1024\", 1280, 1024},\n\t\t{ \"1440x900\", 1440,  900},\n\t\t{\"1680x1050\", 1680, 1050},\n\t\t{\"1600x1200\", 1600, 1200},\n\t\t{\"1920x1080\", 1920, 1080},\n\t\t{\"1920x1200\", 1920, 1200}\n\t};\n\n\tn = ARRAY_SIZE(common_modes);\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct drm_display_mode *curmode = NULL;\n\t\tbool mode_existed = false;\n\n\t\tif (common_modes[i].w > native_mode->hdisplay ||\n\t\t    common_modes[i].h > native_mode->vdisplay ||\n\t\t   (common_modes[i].w == native_mode->hdisplay &&\n\t\t    common_modes[i].h == native_mode->vdisplay))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(curmode, &connector->probed_modes, head) {\n\t\t\tif (common_modes[i].w == curmode->hdisplay &&\n\t\t\t    common_modes[i].h == curmode->vdisplay) {\n\t\t\t\tmode_existed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mode_existed)\n\t\t\tcontinue;\n\n\t\tmode = amdgpu_dm_create_common_mode(encoder,\n\t\t\t\tcommon_modes[i].name, common_modes[i].w,\n\t\t\t\tcommon_modes[i].h);\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tamdgpu_dm_connector->num_modes++;\n\t}\n}\n\nstatic void amdgpu_dm_connector_ddc_get_modes(struct drm_connector *connector,\n\t\t\t\t\t      struct edid *edid)\n{\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector =\n\t\t\tto_amdgpu_dm_connector(connector);\n\n\tif (edid) {\n\t\t/* empty probed_modes */\n\t\tINIT_LIST_HEAD(&connector->probed_modes);\n\t\tamdgpu_dm_connector->num_modes =\n\t\t\t\tdrm_add_edid_modes(connector, edid);\n\n\t\t/* sorting the probed modes before calling function\n\t\t * amdgpu_dm_get_native_mode() since EDID can have\n\t\t * more than one preferred mode. The modes that are\n\t\t * later in the probed mode list could be of higher\n\t\t * and preferred resolution. For example, 3840x2160\n\t\t * resolution in base EDID preferred timing and 4096x2160\n\t\t * preferred resolution in DID extension block later.\n\t\t */\n\t\tdrm_mode_sort(&connector->probed_modes);\n\t\tamdgpu_dm_get_native_mode(connector);\n\t} else {\n\t\tamdgpu_dm_connector->num_modes = 0;\n\t}\n}\n\nstatic int amdgpu_dm_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector =\n\t\t\tto_amdgpu_dm_connector(connector);\n\tstruct drm_encoder *encoder;\n\tstruct edid *edid = amdgpu_dm_connector->edid;\n\n\tencoder = amdgpu_dm_connector_to_encoder(connector);\n\n\tif (!drm_edid_is_valid(edid)) {\n\t\tamdgpu_dm_connector->num_modes =\n\t\t\t\tdrm_add_modes_noedid(connector, 640, 480);\n\t} else {\n\t\tamdgpu_dm_connector_ddc_get_modes(connector, edid);\n\t\tamdgpu_dm_connector_add_common_modes(encoder, connector);\n\t}\n\tamdgpu_dm_fbc_init(connector);\n\n\treturn amdgpu_dm_connector->num_modes;\n}\n\nvoid amdgpu_dm_connector_init_helper(struct amdgpu_display_manager *dm,\n\t\t\t\t     struct amdgpu_dm_connector *aconnector,\n\t\t\t\t     int connector_type,\n\t\t\t\t     struct dc_link *link,\n\t\t\t\t     int link_index)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dm->ddev);\n\n\t/*\n\t * Some of the properties below require access to state, like bpc.\n\t * Allocate some default initial connector state with our reset helper.\n\t */\n\tif (aconnector->base.funcs->reset)\n\t\taconnector->base.funcs->reset(&aconnector->base);\n\n\taconnector->connector_id = link_index;\n\taconnector->dc_link = link;\n\taconnector->base.interlace_allowed = false;\n\taconnector->base.doublescan_allowed = false;\n\taconnector->base.stereo_allowed = false;\n\taconnector->base.dpms = DRM_MODE_DPMS_OFF;\n\taconnector->hpd.hpd = AMDGPU_HPD_NONE; /* not used */\n\taconnector->audio_inst = -1;\n\tmutex_init(&aconnector->hpd_lock);\n\n\t/*\n\t * configure support HPD hot plug connector_>polled default value is 0\n\t * which means HPD hot plug not supported\n\t */\n\tswitch (connector_type) {\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\taconnector->base.polled = DRM_CONNECTOR_POLL_HPD;\n\t\taconnector->base.ycbcr_420_allowed =\n\t\t\tlink->link_enc->features.hdmi_ycbcr420_supported ? true : false;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\taconnector->base.polled = DRM_CONNECTOR_POLL_HPD;\n\t\taconnector->base.ycbcr_420_allowed =\n\t\t\tlink->link_enc->features.dp_ycbcr420_supported ? true : false;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVID:\n\t\taconnector->base.polled = DRM_CONNECTOR_POLL_HPD;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdrm_object_attach_property(&aconnector->base.base,\n\t\t\t\tdm->ddev->mode_config.scaling_mode_property,\n\t\t\t\tDRM_MODE_SCALE_NONE);\n\n\tdrm_object_attach_property(&aconnector->base.base,\n\t\t\t\tadev->mode_info.underscan_property,\n\t\t\t\tUNDERSCAN_OFF);\n\tdrm_object_attach_property(&aconnector->base.base,\n\t\t\t\tadev->mode_info.underscan_hborder_property,\n\t\t\t\t0);\n\tdrm_object_attach_property(&aconnector->base.base,\n\t\t\t\tadev->mode_info.underscan_vborder_property,\n\t\t\t\t0);\n\n\tif (!aconnector->mst_port)\n\t\tdrm_connector_attach_max_bpc_property(&aconnector->base, 8, 16);\n\n\t/* This defaults to the max in the range, but we want 8bpc for non-edp. */\n\taconnector->base.state->max_bpc = (connector_type == DRM_MODE_CONNECTOR_eDP) ? 16 : 8;\n\taconnector->base.state->max_requested_bpc = aconnector->base.state->max_bpc;\n\n\tif (connector_type == DRM_MODE_CONNECTOR_eDP &&\n\t    (dc_is_dmcu_initialized(adev->dm.dc) || adev->dm.dc->ctx->dmub_srv)) {\n\t\tdrm_object_attach_property(&aconnector->base.base,\n\t\t\t\tadev->mode_info.abm_level_property, 0);\n\t}\n\n\tif (connector_type == DRM_MODE_CONNECTOR_HDMIA ||\n\t    connector_type == DRM_MODE_CONNECTOR_DisplayPort ||\n\t    connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\tdrm_object_attach_property(\n\t\t\t&aconnector->base.base,\n\t\t\tdm->ddev->mode_config.hdr_output_metadata_property, 0);\n\n\t\tif (!aconnector->mst_port)\n\t\t\tdrm_connector_attach_vrr_capable_property(&aconnector->base);\n\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\t\tif (adev->dm.hdcp_workqueue)\n\t\t\tdrm_connector_attach_content_protection_property(&aconnector->base, true);\n#endif\n\t}\n}\n\nstatic int amdgpu_dm_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t      struct i2c_msg *msgs, int num)\n{\n\tstruct amdgpu_i2c_adapter *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct ddc_service *ddc_service = i2c->ddc_service;\n\tstruct i2c_command cmd;\n\tint i;\n\tint result = -EIO;\n\n\tcmd.payloads = kcalloc(num, sizeof(struct i2c_payload), GFP_KERNEL);\n\n\tif (!cmd.payloads)\n\t\treturn result;\n\n\tcmd.number_of_payloads = num;\n\tcmd.engine = I2C_COMMAND_ENGINE_DEFAULT;\n\tcmd.speed = 100;\n\n\tfor (i = 0; i < num; i++) {\n\t\tcmd.payloads[i].write = !(msgs[i].flags & I2C_M_RD);\n\t\tcmd.payloads[i].address = msgs[i].addr;\n\t\tcmd.payloads[i].length = msgs[i].len;\n\t\tcmd.payloads[i].data = msgs[i].buf;\n\t}\n\n\tif (dc_submit_i2c(\n\t\t\tddc_service->ctx->dc,\n\t\t\tddc_service->ddc_pin->hw_info.ddc_channel,\n\t\t\t&cmd))\n\t\tresult = num;\n\n\tkfree(cmd.payloads);\n\treturn result;\n}\n\nstatic u32 amdgpu_dm_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm amdgpu_dm_i2c_algo = {\n\t.master_xfer = amdgpu_dm_i2c_xfer,\n\t.functionality = amdgpu_dm_i2c_func,\n};\n\nstatic struct amdgpu_i2c_adapter *\ncreate_i2c(struct ddc_service *ddc_service,\n\t   int link_index,\n\t   int *res)\n{\n\tstruct amdgpu_device *adev = ddc_service->ctx->driver_context;\n\tstruct amdgpu_i2c_adapter *i2c;\n\n\ti2c = kzalloc(sizeof(struct amdgpu_i2c_adapter), GFP_KERNEL);\n\tif (!i2c)\n\t\treturn NULL;\n\ti2c->base.owner = THIS_MODULE;\n\ti2c->base.class = I2C_CLASS_DDC;\n\ti2c->base.dev.parent = &adev->pdev->dev;\n\ti2c->base.algo = &amdgpu_dm_i2c_algo;\n\tsnprintf(i2c->base.name, sizeof(i2c->base.name), \"AMDGPU DM i2c hw bus %d\", link_index);\n\ti2c_set_adapdata(&i2c->base, i2c);\n\ti2c->ddc_service = ddc_service;\n\ti2c->ddc_service->ddc_pin->hw_info.ddc_channel = link_index;\n\n\treturn i2c;\n}\n\n\n/*\n * Note: this function assumes that dc_link_detect() was called for the\n * dc_link which will be represented by this aconnector.\n */\nstatic int amdgpu_dm_connector_init(struct amdgpu_display_manager *dm,\n\t\t\t\t    struct amdgpu_dm_connector *aconnector,\n\t\t\t\t    uint32_t link_index,\n\t\t\t\t    struct amdgpu_encoder *aencoder)\n{\n\tint res = 0;\n\tint connector_type;\n\tstruct dc *dc = dm->dc;\n\tstruct dc_link *link = dc_get_link_at_index(dc, link_index);\n\tstruct amdgpu_i2c_adapter *i2c;\n\n\tlink->priv = aconnector;\n\n\tDRM_DEBUG_DRIVER(\"%s()\\n\", __func__);\n\n\ti2c = create_i2c(link->ddc, link->link_index, &res);\n\tif (!i2c) {\n\t\tDRM_ERROR(\"Failed to create i2c adapter data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\taconnector->i2c = i2c;\n\tres = i2c_add_adapter(&i2c->base);\n\n\tif (res) {\n\t\tDRM_ERROR(\"Failed to register hw i2c %d\\n\", link->link_index);\n\t\tgoto out_free;\n\t}\n\n\tconnector_type = to_drm_connector_type(link->connector_signal);\n\n\tres = drm_connector_init_with_ddc(\n\t\t\tdm->ddev,\n\t\t\t&aconnector->base,\n\t\t\t&amdgpu_dm_connector_funcs,\n\t\t\tconnector_type,\n\t\t\t&i2c->base);\n\n\tif (res) {\n\t\tDRM_ERROR(\"connector_init failed\\n\");\n\t\taconnector->connector_id = -1;\n\t\tgoto out_free;\n\t}\n\n\tdrm_connector_helper_add(\n\t\t\t&aconnector->base,\n\t\t\t&amdgpu_dm_connector_helper_funcs);\n\n\tamdgpu_dm_connector_init_helper(\n\t\tdm,\n\t\taconnector,\n\t\tconnector_type,\n\t\tlink,\n\t\tlink_index);\n\n\tdrm_connector_attach_encoder(\n\t\t&aconnector->base, &aencoder->base);\n\n\tif (connector_type == DRM_MODE_CONNECTOR_DisplayPort\n\t\t|| connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\tamdgpu_dm_initialize_dp_connector(dm, aconnector, link->link_index);\n\nout_free:\n\tif (res) {\n\t\tkfree(i2c);\n\t\taconnector->i2c = NULL;\n\t}\n\treturn res;\n}\n\nint amdgpu_dm_get_encoder_crtc_mask(struct amdgpu_device *adev)\n{\n\tswitch (adev->mode_info.num_crtc) {\n\tcase 1:\n\t\treturn 0x1;\n\tcase 2:\n\t\treturn 0x3;\n\tcase 3:\n\t\treturn 0x7;\n\tcase 4:\n\t\treturn 0xf;\n\tcase 5:\n\t\treturn 0x1f;\n\tcase 6:\n\tdefault:\n\t\treturn 0x3f;\n\t}\n}\n\nstatic int amdgpu_dm_encoder_init(struct drm_device *dev,\n\t\t\t\t  struct amdgpu_encoder *aencoder,\n\t\t\t\t  uint32_t link_index)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\n\tint res = drm_encoder_init(dev,\n\t\t\t\t   &aencoder->base,\n\t\t\t\t   &amdgpu_dm_encoder_funcs,\n\t\t\t\t   DRM_MODE_ENCODER_TMDS,\n\t\t\t\t   NULL);\n\n\taencoder->base.possible_crtcs = amdgpu_dm_get_encoder_crtc_mask(adev);\n\n\tif (!res)\n\t\taencoder->encoder_id = link_index;\n\telse\n\t\taencoder->encoder_id = -1;\n\n\tdrm_encoder_helper_add(&aencoder->base, &amdgpu_dm_encoder_helper_funcs);\n\n\treturn res;\n}\n\nstatic void manage_dm_interrupts(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_crtc *acrtc,\n\t\t\t\t bool enable)\n{\n\t/*\n\t * We have no guarantee that the frontend index maps to the same\n\t * backend index - some even map to more than one.\n\t *\n\t * TODO: Use a different interrupt or check DC itself for the mapping.\n\t */\n\tint irq_type =\n\t\tamdgpu_display_crtc_idx_to_irq_type(\n\t\t\tadev,\n\t\t\tacrtc->crtc_id);\n\n\tif (enable) {\n\t\tdrm_crtc_vblank_on(&acrtc->base);\n\t\tamdgpu_irq_get(\n\t\t\tadev,\n\t\t\t&adev->pageflip_irq,\n\t\t\tirq_type);\n\t} else {\n\n\t\tamdgpu_irq_put(\n\t\t\tadev,\n\t\t\t&adev->pageflip_irq,\n\t\t\tirq_type);\n\t\tdrm_crtc_vblank_off(&acrtc->base);\n\t}\n}\n\nstatic void dm_update_pflip_irq_state(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_crtc *acrtc)\n{\n\tint irq_type =\n\t\tamdgpu_display_crtc_idx_to_irq_type(adev, acrtc->crtc_id);\n\n\t/**\n\t * This reads the current state for the IRQ and force reapplies\n\t * the setting to hardware.\n\t */\n\tamdgpu_irq_update(adev, &adev->pageflip_irq, irq_type);\n}\n\nstatic bool\nis_scaling_state_different(const struct dm_connector_state *dm_state,\n\t\t\t   const struct dm_connector_state *old_dm_state)\n{\n\tif (dm_state->scaling != old_dm_state->scaling)\n\t\treturn true;\n\tif (!dm_state->underscan_enable && old_dm_state->underscan_enable) {\n\t\tif (old_dm_state->underscan_hborder != 0 && old_dm_state->underscan_vborder != 0)\n\t\t\treturn true;\n\t} else  if (dm_state->underscan_enable && !old_dm_state->underscan_enable) {\n\t\tif (dm_state->underscan_hborder != 0 && dm_state->underscan_vborder != 0)\n\t\t\treturn true;\n\t} else if (dm_state->underscan_hborder != old_dm_state->underscan_hborder ||\n\t\t   dm_state->underscan_vborder != old_dm_state->underscan_vborder)\n\t\treturn true;\n\treturn false;\n}\n\n#ifdef CONFIG_DRM_AMD_DC_HDCP\nstatic bool is_content_protection_different(struct drm_connector_state *state,\n\t\t\t\t\t    const struct drm_connector_state *old_state,\n\t\t\t\t\t    const struct drm_connector *connector, struct hdcp_workqueue *hdcp_w)\n{\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct dm_connector_state *dm_con_state = to_dm_connector_state(connector->state);\n\n\t/* Handle: Type0/1 change */\n\tif (old_state->hdcp_content_type != state->hdcp_content_type &&\n\t    state->content_protection != DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\tstate->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\treturn true;\n\t}\n\n\t/* CP is being re enabled, ignore this\n\t *\n\t * Handles:\tENABLED -> DESIRED\n\t */\n\tif (old_state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED &&\n\t    state->content_protection == DRM_MODE_CONTENT_PROTECTION_DESIRED) {\n\t\tstate->content_protection = DRM_MODE_CONTENT_PROTECTION_ENABLED;\n\t\treturn false;\n\t}\n\n\t/* S3 resume case, since old state will always be 0 (UNDESIRED) and the restored state will be ENABLED\n\t *\n\t * Handles:\tUNDESIRED -> ENABLED\n\t */\n\tif (old_state->content_protection == DRM_MODE_CONTENT_PROTECTION_UNDESIRED &&\n\t    state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED)\n\t\tstate->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\n\t/* Check if something is connected/enabled, otherwise we start hdcp but nothing is connected/enabled\n\t * hot-plug, headless s3, dpms\n\t *\n\t * Handles:\tDESIRED -> DESIRED (Special case)\n\t */\n\tif (dm_con_state->update_hdcp && state->content_protection == DRM_MODE_CONTENT_PROTECTION_DESIRED &&\n\t    connector->dpms == DRM_MODE_DPMS_ON && aconnector->dc_sink != NULL) {\n\t\tdm_con_state->update_hdcp = false;\n\t\treturn true;\n\t}\n\n\t/*\n\t * Handles:\tUNDESIRED -> UNDESIRED\n\t *\t\tDESIRED -> DESIRED\n\t *\t\tENABLED -> ENABLED\n\t */\n\tif (old_state->content_protection == state->content_protection)\n\t\treturn false;\n\n\t/*\n\t * Handles:\tUNDESIRED -> DESIRED\n\t *\t\tDESIRED -> UNDESIRED\n\t *\t\tENABLED -> UNDESIRED\n\t */\n\tif (state->content_protection != DRM_MODE_CONTENT_PROTECTION_ENABLED)\n\t\treturn true;\n\n\t/*\n\t * Handles:\tDESIRED -> ENABLED\n\t */\n\treturn false;\n}\n\n#endif\nstatic void remove_stream(struct amdgpu_device *adev,\n\t\t\t  struct amdgpu_crtc *acrtc,\n\t\t\t  struct dc_stream_state *stream)\n{\n\t/* this is the update mode case */\n\n\tacrtc->otg_inst = -1;\n\tacrtc->enabled = false;\n}\n\nstatic int get_cursor_position(struct drm_plane *plane, struct drm_crtc *crtc,\n\t\t\t       struct dc_cursor_position *position)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tint x, y;\n\tint xorigin = 0, yorigin = 0;\n\n\tposition->enable = false;\n\tposition->x = 0;\n\tposition->y = 0;\n\n\tif (!crtc || !plane->state->fb)\n\t\treturn 0;\n\n\tif ((plane->state->crtc_w > amdgpu_crtc->max_cursor_width) ||\n\t    (plane->state->crtc_h > amdgpu_crtc->max_cursor_height)) {\n\t\tDRM_ERROR(\"%s: bad cursor width or height %d x %d\\n\",\n\t\t\t  __func__,\n\t\t\t  plane->state->crtc_w,\n\t\t\t  plane->state->crtc_h);\n\t\treturn -EINVAL;\n\t}\n\n\tx = plane->state->crtc_x;\n\ty = plane->state->crtc_y;\n\n\tif (x <= -amdgpu_crtc->max_cursor_width ||\n\t    y <= -amdgpu_crtc->max_cursor_height)\n\t\treturn 0;\n\n\tif (x < 0) {\n\t\txorigin = min(-x, amdgpu_crtc->max_cursor_width - 1);\n\t\tx = 0;\n\t}\n\tif (y < 0) {\n\t\tyorigin = min(-y, amdgpu_crtc->max_cursor_height - 1);\n\t\ty = 0;\n\t}\n\tposition->enable = true;\n\tposition->translate_by_source = true;\n\tposition->x = x;\n\tposition->y = y;\n\tposition->x_hotspot = xorigin;\n\tposition->y_hotspot = yorigin;\n\n\treturn 0;\n}\n\nstatic void handle_cursor_update(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *old_plane_state)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(plane->dev);\n\tstruct amdgpu_framebuffer *afb = to_amdgpu_framebuffer(plane->state->fb);\n\tstruct drm_crtc *crtc = afb ? plane->state->crtc : old_plane_state->crtc;\n\tstruct dm_crtc_state *crtc_state = crtc ? to_dm_crtc_state(crtc->state) : NULL;\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tuint64_t address = afb ? afb->address : 0;\n\tstruct dc_cursor_position position;\n\tstruct dc_cursor_attributes attributes;\n\tint ret;\n\n\tif (!plane->state->fb && !old_plane_state->fb)\n\t\treturn;\n\n\tDRM_DEBUG_DRIVER(\"%s: crtc_id=%d with size %d to %d\\n\",\n\t\t\t __func__,\n\t\t\t amdgpu_crtc->crtc_id,\n\t\t\t plane->state->crtc_w,\n\t\t\t plane->state->crtc_h);\n\n\tret = get_cursor_position(plane, crtc, &position);\n\tif (ret)\n\t\treturn;\n\n\tif (!position.enable) {\n\t\t/* turn off cursor */\n\t\tif (crtc_state && crtc_state->stream) {\n\t\t\tmutex_lock(&adev->dm.dc_lock);\n\t\t\tdc_stream_set_cursor_position(crtc_state->stream,\n\t\t\t\t\t\t      &position);\n\t\t\tmutex_unlock(&adev->dm.dc_lock);\n\t\t}\n\t\treturn;\n\t}\n\n\tamdgpu_crtc->cursor_width = plane->state->crtc_w;\n\tamdgpu_crtc->cursor_height = plane->state->crtc_h;\n\n\tmemset(&attributes, 0, sizeof(attributes));\n\tattributes.address.high_part = upper_32_bits(address);\n\tattributes.address.low_part  = lower_32_bits(address);\n\tattributes.width             = plane->state->crtc_w;\n\tattributes.height            = plane->state->crtc_h;\n\tattributes.color_format      = CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA;\n\tattributes.rotation_angle    = 0;\n\tattributes.attribute_flags.value = 0;\n\n\tattributes.pitch = afb->base.pitches[0] / afb->base.format->cpp[0];\n\n\tif (crtc_state->stream) {\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\tif (!dc_stream_set_cursor_attributes(crtc_state->stream,\n\t\t\t\t\t\t\t &attributes))\n\t\t\tDRM_ERROR(\"DC failed to set cursor attributes\\n\");\n\n\t\tif (!dc_stream_set_cursor_position(crtc_state->stream,\n\t\t\t\t\t\t   &position))\n\t\t\tDRM_ERROR(\"DC failed to set cursor position\\n\");\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t}\n}\n\nstatic void prepare_flip_isr(struct amdgpu_crtc *acrtc)\n{\n\n\tassert_spin_locked(&acrtc->base.dev->event_lock);\n\tWARN_ON(acrtc->event);\n\n\tacrtc->event = acrtc->base.state->event;\n\n\t/* Set the flip status */\n\tacrtc->pflip_status = AMDGPU_FLIP_SUBMITTED;\n\n\t/* Mark this event as consumed */\n\tacrtc->base.state->event = NULL;\n\n\tDRM_DEBUG_DRIVER(\"crtc:%d, pflip_stat:AMDGPU_FLIP_SUBMITTED\\n\",\n\t\t\t\t\t\t acrtc->crtc_id);\n}\n\nstatic void update_freesync_state_on_stream(\n\tstruct amdgpu_display_manager *dm,\n\tstruct dm_crtc_state *new_crtc_state,\n\tstruct dc_stream_state *new_stream,\n\tstruct dc_plane_state *surface,\n\tu32 flip_timestamp_in_us)\n{\n\tstruct mod_vrr_params vrr_params;\n\tstruct dc_info_packet vrr_infopacket = {0};\n\tstruct amdgpu_device *adev = dm->adev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(new_crtc_state->base.crtc);\n\tunsigned long flags;\n\n\tif (!new_stream)\n\t\treturn;\n\n\t/*\n\t * TODO: Determine why min/max totals and vrefresh can be 0 here.\n\t * For now it's sufficient to just guard against these conditions.\n\t */\n\n\tif (!new_stream->timing.h_total || !new_stream->timing.v_total)\n\t\treturn;\n\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n        vrr_params = acrtc->dm_irq_params.vrr_params;\n\n\tif (surface) {\n\t\tmod_freesync_handle_preflip(\n\t\t\tdm->freesync_module,\n\t\t\tsurface,\n\t\t\tnew_stream,\n\t\t\tflip_timestamp_in_us,\n\t\t\t&vrr_params);\n\n\t\tif (adev->family < AMDGPU_FAMILY_AI &&\n\t\t    amdgpu_dm_vrr_active(new_crtc_state)) {\n\t\t\tmod_freesync_handle_v_update(dm->freesync_module,\n\t\t\t\t\t\t     new_stream, &vrr_params);\n\n\t\t\t/* Need to call this before the frame ends. */\n\t\t\tdc_stream_adjust_vmin_vmax(dm->dc,\n\t\t\t\t\t\t   new_crtc_state->stream,\n\t\t\t\t\t\t   &vrr_params.adjust);\n\t\t}\n\t}\n\n\tmod_freesync_build_vrr_infopacket(\n\t\tdm->freesync_module,\n\t\tnew_stream,\n\t\t&vrr_params,\n\t\tPACKET_TYPE_VRR,\n\t\tTRANSFER_FUNC_UNKNOWN,\n\t\t&vrr_infopacket);\n\n\tnew_crtc_state->freesync_timing_changed |=\n\t\t(memcmp(&acrtc->dm_irq_params.vrr_params.adjust,\n\t\t\t&vrr_params.adjust,\n\t\t\tsizeof(vrr_params.adjust)) != 0);\n\n\tnew_crtc_state->freesync_vrr_info_changed |=\n\t\t(memcmp(&new_crtc_state->vrr_infopacket,\n\t\t\t&vrr_infopacket,\n\t\t\tsizeof(vrr_infopacket)) != 0);\n\n\tacrtc->dm_irq_params.vrr_params = vrr_params;\n\tnew_crtc_state->vrr_infopacket = vrr_infopacket;\n\n\tnew_stream->adjust = acrtc->dm_irq_params.vrr_params.adjust;\n\tnew_stream->vrr_infopacket = vrr_infopacket;\n\n\tif (new_crtc_state->freesync_vrr_info_changed)\n\t\tDRM_DEBUG_KMS(\"VRR packet update: crtc=%u enabled=%d state=%d\",\n\t\t\t      new_crtc_state->base.crtc->base.id,\n\t\t\t      (int)new_crtc_state->base.vrr_enabled,\n\t\t\t      (int)vrr_params.state);\n\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n}\n\nstatic void update_stream_irq_parameters(\n\tstruct amdgpu_display_manager *dm,\n\tstruct dm_crtc_state *new_crtc_state)\n{\n\tstruct dc_stream_state *new_stream = new_crtc_state->stream;\n\tstruct mod_vrr_params vrr_params;\n\tstruct mod_freesync_config config = new_crtc_state->freesync_config;\n\tstruct amdgpu_device *adev = dm->adev;\n\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(new_crtc_state->base.crtc);\n\tunsigned long flags;\n\n\tif (!new_stream)\n\t\treturn;\n\n\t/*\n\t * TODO: Determine why min/max totals and vrefresh can be 0 here.\n\t * For now it's sufficient to just guard against these conditions.\n\t */\n\tif (!new_stream->timing.h_total || !new_stream->timing.v_total)\n\t\treturn;\n\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\tvrr_params = acrtc->dm_irq_params.vrr_params;\n\n\tif (new_crtc_state->vrr_supported &&\n\t    config.min_refresh_in_uhz &&\n\t    config.max_refresh_in_uhz) {\n\t\tconfig.state = new_crtc_state->base.vrr_enabled ?\n\t\t\tVRR_STATE_ACTIVE_VARIABLE :\n\t\t\tVRR_STATE_INACTIVE;\n\t} else {\n\t\tconfig.state = VRR_STATE_UNSUPPORTED;\n\t}\n\n\tmod_freesync_build_vrr_params(dm->freesync_module,\n\t\t\t\t      new_stream,\n\t\t\t\t      &config, &vrr_params);\n\n\tnew_crtc_state->freesync_timing_changed |=\n\t\t(memcmp(&acrtc->dm_irq_params.vrr_params.adjust,\n\t\t\t&vrr_params.adjust, sizeof(vrr_params.adjust)) != 0);\n\n\tnew_crtc_state->freesync_config = config;\n\t/* Copy state for access from DM IRQ handler */\n\tacrtc->dm_irq_params.freesync_config = config;\n\tacrtc->dm_irq_params.active_planes = new_crtc_state->active_planes;\n\tacrtc->dm_irq_params.vrr_params = vrr_params;\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n}\n\nstatic void amdgpu_dm_handle_vrr_transition(struct dm_crtc_state *old_state,\n\t\t\t\t\t    struct dm_crtc_state *new_state)\n{\n\tbool old_vrr_active = amdgpu_dm_vrr_active(old_state);\n\tbool new_vrr_active = amdgpu_dm_vrr_active(new_state);\n\n\tif (!old_vrr_active && new_vrr_active) {\n\t\t/* Transition VRR inactive -> active:\n\t\t * While VRR is active, we must not disable vblank irq, as a\n\t\t * reenable after disable would compute bogus vblank/pflip\n\t\t * timestamps if it likely happened inside display front-porch.\n\t\t *\n\t\t * We also need vupdate irq for the actual core vblank handling\n\t\t * at end of vblank.\n\t\t */\n\t\tdm_set_vupdate_irq(new_state->base.crtc, true);\n\t\tdrm_crtc_vblank_get(new_state->base.crtc);\n\t\tDRM_DEBUG_DRIVER(\"%s: crtc=%u VRR off->on: Get vblank ref\\n\",\n\t\t\t\t __func__, new_state->base.crtc->base.id);\n\t} else if (old_vrr_active && !new_vrr_active) {\n\t\t/* Transition VRR active -> inactive:\n\t\t * Allow vblank irq disable again for fixed refresh rate.\n\t\t */\n\t\tdm_set_vupdate_irq(new_state->base.crtc, false);\n\t\tdrm_crtc_vblank_put(new_state->base.crtc);\n\t\tDRM_DEBUG_DRIVER(\"%s: crtc=%u VRR on->off: Drop vblank ref\\n\",\n\t\t\t\t __func__, new_state->base.crtc->base.id);\n\t}\n}\n\nstatic void amdgpu_dm_commit_cursors(struct drm_atomic_state *state)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tint i;\n\n\t/*\n\t * TODO: Make this per-stream so we don't issue redundant updates for\n\t * commits with multiple streams.\n\t */\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state,\n\t\t\t\t       new_plane_state, i)\n\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\thandle_cursor_update(plane, old_plane_state);\n}\n\nstatic void amdgpu_dm_commit_planes(struct drm_atomic_state *state,\n\t\t\t\t    struct dc_state *dc_state,\n\t\t\t\t    struct drm_device *dev,\n\t\t\t\t    struct amdgpu_display_manager *dm,\n\t\t\t\t    struct drm_crtc *pcrtc,\n\t\t\t\t    bool wait_for_vblank)\n{\n\tuint32_t i;\n\tuint64_t timestamp_ns;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tstruct amdgpu_crtc *acrtc_attach = to_amdgpu_crtc(pcrtc);\n\tstruct drm_crtc_state *new_pcrtc_state =\n\t\t\tdrm_atomic_get_new_crtc_state(state, pcrtc);\n\tstruct dm_crtc_state *acrtc_state = to_dm_crtc_state(new_pcrtc_state);\n\tstruct dm_crtc_state *dm_old_crtc_state =\n\t\t\tto_dm_crtc_state(drm_atomic_get_old_crtc_state(state, pcrtc));\n\tint planes_count = 0, vpos, hpos;\n\tlong r;\n\tunsigned long flags;\n\tstruct amdgpu_bo *abo;\n\tuint32_t target_vblank, last_flip_vblank;\n\tbool vrr_active = amdgpu_dm_vrr_active(acrtc_state);\n\tbool pflip_present = false;\n\tstruct {\n\t\tstruct dc_surface_update surface_updates[MAX_SURFACES];\n\t\tstruct dc_plane_info plane_infos[MAX_SURFACES];\n\t\tstruct dc_scaling_info scaling_infos[MAX_SURFACES];\n\t\tstruct dc_flip_addrs flip_addrs[MAX_SURFACES];\n\t\tstruct dc_stream_update stream_update;\n\t} *bundle;\n\n\tbundle = kzalloc(sizeof(*bundle), GFP_KERNEL);\n\n\tif (!bundle) {\n\t\tdm_error(\"Failed to allocate update bundle\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Disable the cursor first if we're disabling all the planes.\n\t * It'll remain on the screen after the planes are re-enabled\n\t * if we don't.\n\t */\n\tif (acrtc_state->active_planes == 0)\n\t\tamdgpu_dm_commit_cursors(state);\n\n\t/* update planes when needed */\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tstruct drm_crtc *crtc = new_plane_state->crtc;\n\t\tstruct drm_crtc_state *new_crtc_state;\n\t\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\t\tstruct amdgpu_framebuffer *afb = (struct amdgpu_framebuffer *)fb;\n\t\tbool plane_needs_flip;\n\t\tstruct dc_plane_state *dc_plane;\n\t\tstruct dm_plane_state *dm_new_plane_state = to_dm_plane_state(new_plane_state);\n\n\t\t/* Cursor plane is handled after stream updates */\n\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcontinue;\n\n\t\tif (!fb || !crtc || pcrtc != crtc)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t\tif (!new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tdc_plane = dm_new_plane_state->dc_state;\n\n\t\tbundle->surface_updates[planes_count].surface = dc_plane;\n\t\tif (new_pcrtc_state->color_mgmt_changed) {\n\t\t\tbundle->surface_updates[planes_count].gamma = dc_plane->gamma_correction;\n\t\t\tbundle->surface_updates[planes_count].in_transfer_func = dc_plane->in_transfer_func;\n\t\t\tbundle->surface_updates[planes_count].gamut_remap_matrix = &dc_plane->gamut_remap_matrix;\n\t\t}\n\n\t\tfill_dc_scaling_info(new_plane_state,\n\t\t\t\t     &bundle->scaling_infos[planes_count]);\n\n\t\tbundle->surface_updates[planes_count].scaling_info =\n\t\t\t&bundle->scaling_infos[planes_count];\n\n\t\tplane_needs_flip = old_plane_state->fb && new_plane_state->fb;\n\n\t\tpflip_present = pflip_present || plane_needs_flip;\n\n\t\tif (!plane_needs_flip) {\n\t\t\tplanes_count += 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tabo = gem_to_amdgpu_bo(fb->obj[0]);\n\n\t\t/*\n\t\t * Wait for all fences on this FB. Do limited wait to avoid\n\t\t * deadlock during GPU reset when this fence will not signal\n\t\t * but we hold reservation lock for the BO.\n\t\t */\n\t\tr = dma_resv_wait_timeout_rcu(abo->tbo.base.resv, true,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tmsecs_to_jiffies(5000));\n\t\tif (unlikely(r <= 0))\n\t\t\tDRM_ERROR(\"Waiting for fences timed out!\");\n\n\t\tfill_dc_plane_info_and_addr(\n\t\t\tdm->adev, new_plane_state,\n\t\t\tafb->tiling_flags,\n\t\t\t&bundle->plane_infos[planes_count],\n\t\t\t&bundle->flip_addrs[planes_count].address,\n\t\t\tafb->tmz_surface, false);\n\n\t\tDRM_DEBUG_DRIVER(\"plane: id=%d dcc_en=%d\\n\",\n\t\t\t\t new_plane_state->plane->index,\n\t\t\t\t bundle->plane_infos[planes_count].dcc.enable);\n\n\t\tbundle->surface_updates[planes_count].plane_info =\n\t\t\t&bundle->plane_infos[planes_count];\n\n\t\t/*\n\t\t * Only allow immediate flips for fast updates that don't\n\t\t * change FB pitch, DCC state, rotation or mirroing.\n\t\t */\n\t\tbundle->flip_addrs[planes_count].flip_immediate =\n\t\t\tcrtc->state->async_flip &&\n\t\t\tacrtc_state->update_type == UPDATE_TYPE_FAST;\n\n\t\ttimestamp_ns = ktime_get_ns();\n\t\tbundle->flip_addrs[planes_count].flip_timestamp_in_us = div_u64(timestamp_ns, 1000);\n\t\tbundle->surface_updates[planes_count].flip_addr = &bundle->flip_addrs[planes_count];\n\t\tbundle->surface_updates[planes_count].surface = dc_plane;\n\n\t\tif (!bundle->surface_updates[planes_count].surface) {\n\t\t\tDRM_ERROR(\"No surface for CRTC: id=%d\\n\",\n\t\t\t\t\tacrtc_attach->crtc_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (plane == pcrtc->primary)\n\t\t\tupdate_freesync_state_on_stream(\n\t\t\t\tdm,\n\t\t\t\tacrtc_state,\n\t\t\t\tacrtc_state->stream,\n\t\t\t\tdc_plane,\n\t\t\t\tbundle->flip_addrs[planes_count].flip_timestamp_in_us);\n\n\t\tDRM_DEBUG_DRIVER(\"%s Flipping to hi: 0x%x, low: 0x%x\\n\",\n\t\t\t\t __func__,\n\t\t\t\t bundle->flip_addrs[planes_count].address.grph.addr.high_part,\n\t\t\t\t bundle->flip_addrs[planes_count].address.grph.addr.low_part);\n\n\t\tplanes_count += 1;\n\n\t}\n\n\tif (pflip_present) {\n\t\tif (!vrr_active) {\n\t\t\t/* Use old throttling in non-vrr fixed refresh rate mode\n\t\t\t * to keep flip scheduling based on target vblank counts\n\t\t\t * working in a backwards compatible way, e.g., for\n\t\t\t * clients using the GLX_OML_sync_control extension or\n\t\t\t * DRI3/Present extension with defined target_msc.\n\t\t\t */\n\t\t\tlast_flip_vblank = amdgpu_get_vblank_counter_kms(pcrtc);\n\t\t}\n\t\telse {\n\t\t\t/* For variable refresh rate mode only:\n\t\t\t * Get vblank of last completed flip to avoid > 1 vrr\n\t\t\t * flips per video frame by use of throttling, but allow\n\t\t\t * flip programming anywhere in the possibly large\n\t\t\t * variable vrr vblank interval for fine-grained flip\n\t\t\t * timing control and more opportunity to avoid stutter\n\t\t\t * on late submission of flips.\n\t\t\t */\n\t\t\tspin_lock_irqsave(&pcrtc->dev->event_lock, flags);\n\t\t\tlast_flip_vblank = acrtc_attach->dm_irq_params.last_flip_vblank;\n\t\t\tspin_unlock_irqrestore(&pcrtc->dev->event_lock, flags);\n\t\t}\n\n\t\ttarget_vblank = last_flip_vblank + wait_for_vblank;\n\n\t\t/*\n\t\t * Wait until we're out of the vertical blank period before the one\n\t\t * targeted by the flip\n\t\t */\n\t\twhile ((acrtc_attach->enabled &&\n\t\t\t(amdgpu_display_get_crtc_scanoutpos(dm->ddev, acrtc_attach->crtc_id,\n\t\t\t\t\t\t\t    0, &vpos, &hpos, NULL,\n\t\t\t\t\t\t\t    NULL, &pcrtc->hwmode)\n\t\t\t & (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_IN_VBLANK)) ==\n\t\t\t(DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_IN_VBLANK) &&\n\t\t\t(int)(target_vblank -\n\t\t\t  amdgpu_get_vblank_counter_kms(pcrtc)) > 0)) {\n\t\t\tusleep_range(1000, 1100);\n\t\t}\n\n\t\t/**\n\t\t * Prepare the flip event for the pageflip interrupt to handle.\n\t\t *\n\t\t * This only works in the case where we've already turned on the\n\t\t * appropriate hardware blocks (eg. HUBP) so in the transition case\n\t\t * from 0 -> n planes we have to skip a hardware generated event\n\t\t * and rely on sending it from software.\n\t\t */\n\t\tif (acrtc_attach->base.state->event &&\n\t\t    acrtc_state->active_planes > 0) {\n\t\t\tdrm_crtc_vblank_get(pcrtc);\n\n\t\t\tspin_lock_irqsave(&pcrtc->dev->event_lock, flags);\n\n\t\t\tWARN_ON(acrtc_attach->pflip_status != AMDGPU_FLIP_NONE);\n\t\t\tprepare_flip_isr(acrtc_attach);\n\n\t\t\tspin_unlock_irqrestore(&pcrtc->dev->event_lock, flags);\n\t\t}\n\n\t\tif (acrtc_state->stream) {\n\t\t\tif (acrtc_state->freesync_vrr_info_changed)\n\t\t\t\tbundle->stream_update.vrr_infopacket =\n\t\t\t\t\t&acrtc_state->stream->vrr_infopacket;\n\t\t}\n\t}\n\n\t/* Update the planes if changed or disable if we don't have any. */\n\tif ((planes_count || acrtc_state->active_planes == 0) &&\n\t\tacrtc_state->stream) {\n\t\tbundle->stream_update.stream = acrtc_state->stream;\n\t\tif (new_pcrtc_state->mode_changed) {\n\t\t\tbundle->stream_update.src = acrtc_state->stream->src;\n\t\t\tbundle->stream_update.dst = acrtc_state->stream->dst;\n\t\t}\n\n\t\tif (new_pcrtc_state->color_mgmt_changed) {\n\t\t\t/*\n\t\t\t * TODO: This isn't fully correct since we've actually\n\t\t\t * already modified the stream in place.\n\t\t\t */\n\t\t\tbundle->stream_update.gamut_remap =\n\t\t\t\t&acrtc_state->stream->gamut_remap_matrix;\n\t\t\tbundle->stream_update.output_csc_transform =\n\t\t\t\t&acrtc_state->stream->csc_color_matrix;\n\t\t\tbundle->stream_update.out_transfer_func =\n\t\t\t\tacrtc_state->stream->out_transfer_func;\n\t\t}\n\n\t\tacrtc_state->stream->abm_level = acrtc_state->abm_level;\n\t\tif (acrtc_state->abm_level != dm_old_crtc_state->abm_level)\n\t\t\tbundle->stream_update.abm_level = &acrtc_state->abm_level;\n\n\t\t/*\n\t\t * If FreeSync state on the stream has changed then we need to\n\t\t * re-adjust the min/max bounds now that DC doesn't handle this\n\t\t * as part of commit.\n\t\t */\n\t\tif (amdgpu_dm_vrr_active(dm_old_crtc_state) !=\n\t\t    amdgpu_dm_vrr_active(acrtc_state)) {\n\t\t\tspin_lock_irqsave(&pcrtc->dev->event_lock, flags);\n\t\t\tdc_stream_adjust_vmin_vmax(\n\t\t\t\tdm->dc, acrtc_state->stream,\n\t\t\t\t&acrtc_attach->dm_irq_params.vrr_params.adjust);\n\t\t\tspin_unlock_irqrestore(&pcrtc->dev->event_lock, flags);\n\t\t}\n\t\tmutex_lock(&dm->dc_lock);\n\t\tif ((acrtc_state->update_type > UPDATE_TYPE_FAST) &&\n\t\t\t\tacrtc_state->stream->link->psr_settings.psr_allow_active)\n\t\t\tamdgpu_dm_psr_disable(acrtc_state->stream);\n\n\t\tdc_commit_updates_for_stream(dm->dc,\n\t\t\t\t\t\t     bundle->surface_updates,\n\t\t\t\t\t\t     planes_count,\n\t\t\t\t\t\t     acrtc_state->stream,\n\t\t\t\t\t\t     &bundle->stream_update,\n\t\t\t\t\t\t     dc_state);\n\n\t\t/**\n\t\t * Enable or disable the interrupts on the backend.\n\t\t *\n\t\t * Most pipes are put into power gating when unused.\n\t\t *\n\t\t * When power gating is enabled on a pipe we lose the\n\t\t * interrupt enablement state when power gating is disabled.\n\t\t *\n\t\t * So we need to update the IRQ control state in hardware\n\t\t * whenever the pipe turns on (since it could be previously\n\t\t * power gated) or off (since some pipes can't be power gated\n\t\t * on some ASICs).\n\t\t */\n\t\tif (dm_old_crtc_state->active_planes != acrtc_state->active_planes)\n\t\t\tdm_update_pflip_irq_state(drm_to_adev(dev),\n\t\t\t\t\t\t  acrtc_attach);\n\n\t\tif ((acrtc_state->update_type > UPDATE_TYPE_FAST) &&\n\t\t\t\tacrtc_state->stream->link->psr_settings.psr_version != DC_PSR_VERSION_UNSUPPORTED &&\n\t\t\t\t!acrtc_state->stream->link->psr_settings.psr_feature_enabled)\n\t\t\tamdgpu_dm_link_setup_psr(acrtc_state->stream);\n\t\telse if ((acrtc_state->update_type == UPDATE_TYPE_FAST) &&\n\t\t\t\tacrtc_state->stream->link->psr_settings.psr_feature_enabled &&\n\t\t\t\t!acrtc_state->stream->link->psr_settings.psr_allow_active) {\n\t\t\tamdgpu_dm_psr_enable(acrtc_state->stream);\n\t\t}\n\n\t\tmutex_unlock(&dm->dc_lock);\n\t}\n\n\t/*\n\t * Update cursor state *after* programming all the planes.\n\t * This avoids redundant programming in the case where we're going\n\t * to be disabling a single plane - those pipes are being disabled.\n\t */\n\tif (acrtc_state->active_planes)\n\t\tamdgpu_dm_commit_cursors(state);\n\ncleanup:\n\tkfree(bundle);\n}\n\nstatic void amdgpu_dm_commit_audio(struct drm_device *dev,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_con_state, *new_con_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct dm_crtc_state *new_dm_crtc_state;\n\tconst struct dc_stream_status *status;\n\tint i, inst;\n\n\t/* Notify device removals. */\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tif (old_con_state->crtc != new_con_state->crtc) {\n\t\t\t/* CRTC changes require notification. */\n\t\t\tgoto notify;\n\t\t}\n\n\t\tif (!new_con_state->crtc)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(\n\t\t\tstate, new_con_state->crtc);\n\n\t\tif (!new_crtc_state)\n\t\t\tcontinue;\n\n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\tnotify:\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\tmutex_lock(&adev->dm.audio_lock);\n\t\tinst = aconnector->audio_inst;\n\t\taconnector->audio_inst = -1;\n\t\tmutex_unlock(&adev->dm.audio_lock);\n\n\t\tamdgpu_dm_audio_eld_notify(adev, inst);\n\t}\n\n\t/* Notify audio device additions. */\n\tfor_each_new_connector_in_state(state, connector, new_con_state, i) {\n\t\tif (!new_con_state->crtc)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(\n\t\t\tstate, new_con_state->crtc);\n\n\t\tif (!new_crtc_state)\n\t\t\tcontinue;\n\n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tnew_dm_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tif (!new_dm_crtc_state->stream)\n\t\t\tcontinue;\n\n\t\tstatus = dc_stream_get_status(new_dm_crtc_state->stream);\n\t\tif (!status)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\tmutex_lock(&adev->dm.audio_lock);\n\t\tinst = status->audio_inst;\n\t\taconnector->audio_inst = inst;\n\t\tmutex_unlock(&adev->dm.audio_lock);\n\n\t\tamdgpu_dm_audio_eld_notify(adev, inst);\n\t}\n}\n\n/*\n * amdgpu_dm_crtc_copy_transient_flags - copy mirrored flags from DRM to DC\n * @crtc_state: the DRM CRTC state\n * @stream_state: the DC stream state.\n *\n * Copy the mirrored transient state flags from DRM, to DC. It is used to bring\n * a dc_stream_state's flags in sync with a drm_crtc_state's flags.\n */\nstatic void amdgpu_dm_crtc_copy_transient_flags(struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\tstruct dc_stream_state *stream_state)\n{\n\tstream_state->mode_changed = drm_atomic_crtc_needs_modeset(crtc_state);\n}\n\n/**\n * amdgpu_dm_atomic_commit_tail() - AMDgpu DM's commit tail implementation.\n * @state: The atomic state to commit\n *\n * This will tell DC to commit the constructed DC state from atomic_check,\n * programming the hardware. Any failures here implies a hardware failure, since\n * atomic check should have filtered anything non-kosher.\n */\nstatic void amdgpu_dm_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct dm_atomic_state *dm_state;\n\tstruct dc_state *dc_state = NULL, *dc_state_temp = NULL;\n\tuint32_t i, j;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tunsigned long flags;\n\tbool wait_for_vblank = true;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_con_state, *new_con_state;\n\tstruct dm_crtc_state *dm_old_crtc_state, *dm_new_crtc_state;\n\tint crtc_disable_count = 0;\n\tbool mode_set_reset_required = false;\n\n\ttrace_amdgpu_dm_atomic_commit_tail_begin(state);\n\n\tdrm_atomic_helper_update_legacy_modeset_state(dev, state);\n\n\tdm_state = dm_atomic_get_new_state(state);\n\tif (dm_state && dm_state->context) {\n\t\tdc_state = dm_state->context;\n\t} else {\n\t\t/* No state changes, retain current state. */\n\t\tdc_state_temp = dc_create_state(dm->dc);\n\t\tASSERT(dc_state_temp);\n\t\tdc_state = dc_state_temp;\n\t\tdc_resource_state_copy_construct_current(dm->dc, dc_state);\n\t}\n\n\tfor_each_oldnew_crtc_in_state (state, crtc, old_crtc_state,\n\t\t\t\t       new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tif (old_crtc_state->active &&\n\t\t    (!new_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\tmanage_dm_interrupts(adev, acrtc, false);\n\t\t\tdc_stream_release(dm_old_crtc_state->stream);\n\t\t}\n\t}\n\n\tdrm_atomic_helper_calc_timestamping_constants(state);\n\n\t/* update changed items */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tDRM_DEBUG_DRIVER(\n\t\t\t\"amdgpu_crtc id:%d crtc_state_flags: enable:%d, active:%d, \"\n\t\t\t\"planes_changed:%d, mode_changed:%d,active_changed:%d,\"\n\t\t\t\"connectors_changed:%d\\n\",\n\t\t\tacrtc->crtc_id,\n\t\t\tnew_crtc_state->enable,\n\t\t\tnew_crtc_state->active,\n\t\t\tnew_crtc_state->planes_changed,\n\t\t\tnew_crtc_state->mode_changed,\n\t\t\tnew_crtc_state->active_changed,\n\t\t\tnew_crtc_state->connectors_changed);\n\n\t\t/* Disable cursor if disabling crtc */\n\t\tif (old_crtc_state->active && !new_crtc_state->active) {\n\t\t\tstruct dc_cursor_position position;\n\n\t\t\tmemset(&position, 0, sizeof(position));\n\t\t\tmutex_lock(&dm->dc_lock);\n\t\t\tdc_stream_set_cursor_position(dm_old_crtc_state->stream, &position);\n\t\t\tmutex_unlock(&dm->dc_lock);\n\t\t}\n\n\t\t/* Copy all transient state flags into dc state */\n\t\tif (dm_new_crtc_state->stream) {\n\t\t\tamdgpu_dm_crtc_copy_transient_flags(&dm_new_crtc_state->base,\n\t\t\t\t\t\t\t    dm_new_crtc_state->stream);\n\t\t}\n\n\t\t/* handles headless hotplug case, updating new_state and\n\t\t * aconnector as needed\n\t\t */\n\n\t\tif (modeset_required(new_crtc_state, dm_new_crtc_state->stream, dm_old_crtc_state->stream)) {\n\n\t\t\tDRM_DEBUG_DRIVER(\"Atomic commit: SET crtc id %d: [%p]\\n\", acrtc->crtc_id, acrtc);\n\n\t\t\tif (!dm_new_crtc_state->stream) {\n\t\t\t\t/*\n\t\t\t\t * this could happen because of issues with\n\t\t\t\t * userspace notifications delivery.\n\t\t\t\t * In this case userspace tries to set mode on\n\t\t\t\t * display which is disconnected in fact.\n\t\t\t\t * dc_sink is NULL in this case on aconnector.\n\t\t\t\t * We expect reset mode will come soon.\n\t\t\t\t *\n\t\t\t\t * This can also happen when unplug is done\n\t\t\t\t * during resume sequence ended\n\t\t\t\t *\n\t\t\t\t * In this case, we want to pretend we still\n\t\t\t\t * have a sink to keep the pipe running so that\n\t\t\t\t * hw state is consistent with the sw state\n\t\t\t\t */\n\t\t\t\tDRM_DEBUG_DRIVER(\"%s: Failed to create new stream for crtc %d\\n\",\n\t\t\t\t\t\t__func__, acrtc->base.base.id);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dm_old_crtc_state->stream)\n\t\t\t\tremove_stream(adev, acrtc, dm_old_crtc_state->stream);\n\n\t\t\tpm_runtime_get_noresume(dev->dev);\n\n\t\t\tacrtc->enabled = true;\n\t\t\tacrtc->hw_mode = new_crtc_state->mode;\n\t\t\tcrtc->hwmode = new_crtc_state->mode;\n\t\t\tmode_set_reset_required = true;\n\t\t} else if (modereset_required(new_crtc_state)) {\n\t\t\tDRM_DEBUG_DRIVER(\"Atomic commit: RESET. crtc id %d:[%p]\\n\", acrtc->crtc_id, acrtc);\n\t\t\t/* i.e. reset mode */\n\t\t\tif (dm_old_crtc_state->stream)\n\t\t\t\tremove_stream(adev, acrtc, dm_old_crtc_state->stream);\n\t\t\tmode_set_reset_required = true;\n\t\t}\n\t} /* for_each_crtc_in_state() */\n\n\tif (dc_state) {\n\t\t/* if there mode set or reset, disable eDP PSR */\n\t\tif (mode_set_reset_required)\n\t\t\tamdgpu_dm_psr_disable_all(dm);\n\n\t\tdm_enable_per_frame_crtc_master_sync(dc_state);\n\t\tmutex_lock(&dm->dc_lock);\n\t\tWARN_ON(!dc_commit_state(dm->dc, dc_state));\n\t\tmutex_unlock(&dm->dc_lock);\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state->stream != NULL) {\n\t\t\tconst struct dc_stream_status *status =\n\t\t\t\t\tdc_stream_get_status(dm_new_crtc_state->stream);\n\n\t\t\tif (!status)\n\t\t\t\tstatus = dc_stream_get_status_from_state(dc_state,\n\t\t\t\t\t\t\t\t\t dm_new_crtc_state->stream);\n\t\t\tif (!status)\n\t\t\t\tDC_ERR(\"got no status for stream %p on acrtc%p\\n\", dm_new_crtc_state->stream, acrtc);\n\t\t\telse\n\t\t\t\tacrtc->otg_inst = status->primary_otg_inst;\n\t\t}\n\t}\n#ifdef CONFIG_DRM_AMD_DC_HDCP\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\n\t\tnew_crtc_state = NULL;\n\n\t\tif (acrtc)\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state && dm_new_crtc_state->stream == NULL &&\n\t\t    connector->state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\t\thdcp_reset_display(adev->dm.hdcp_workqueue, aconnector->dc_link->link_index);\n\t\t\tnew_con_state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\t\tdm_new_con_state->update_hdcp = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_content_protection_different(new_con_state, old_con_state, connector, adev->dm.hdcp_workqueue))\n\t\t\thdcp_update_display(\n\t\t\t\tadev->dm.hdcp_workqueue, aconnector->dc_link->link_index, aconnector,\n\t\t\t\tnew_con_state->hdcp_content_type,\n\t\t\t\tnew_con_state->content_protection == DRM_MODE_CONTENT_PROTECTION_DESIRED ? true\n\t\t\t\t\t\t\t\t\t\t\t\t\t : false);\n\t}\n#endif\n\n\t/* Handle connector state changes */\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct dc_surface_update dummy_updates[MAX_SURFACES];\n\t\tstruct dc_stream_update stream_update;\n\t\tstruct dc_info_packet hdr_packet;\n\t\tstruct dc_stream_status *status = NULL;\n\t\tbool abm_changed, hdr_changed, scaling_changed;\n\n\t\tmemset(&dummy_updates, 0, sizeof(dummy_updates));\n\t\tmemset(&stream_update, 0, sizeof(stream_update));\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\t/* Skip any modesets/resets */\n\t\tif (!acrtc || drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tscaling_changed = is_scaling_state_different(dm_new_con_state,\n\t\t\t\t\t\t\t     dm_old_con_state);\n\n\t\tabm_changed = dm_new_crtc_state->abm_level !=\n\t\t\t      dm_old_crtc_state->abm_level;\n\n\t\thdr_changed =\n\t\t\tis_hdr_metadata_different(old_con_state, new_con_state);\n\n\t\tif (!scaling_changed && !abm_changed && !hdr_changed)\n\t\t\tcontinue;\n\n\t\tstream_update.stream = dm_new_crtc_state->stream;\n\t\tif (scaling_changed) {\n\t\t\tupdate_stream_scaling_settings(&dm_new_con_state->base.crtc->mode,\n\t\t\t\t\tdm_new_con_state, dm_new_crtc_state->stream);\n\n\t\t\tstream_update.src = dm_new_crtc_state->stream->src;\n\t\t\tstream_update.dst = dm_new_crtc_state->stream->dst;\n\t\t}\n\n\t\tif (abm_changed) {\n\t\t\tdm_new_crtc_state->stream->abm_level = dm_new_crtc_state->abm_level;\n\n\t\t\tstream_update.abm_level = &dm_new_crtc_state->abm_level;\n\t\t}\n\n\t\tif (hdr_changed) {\n\t\t\tfill_hdr_info_packet(new_con_state, &hdr_packet);\n\t\t\tstream_update.hdr_static_metadata = &hdr_packet;\n\t\t}\n\n\t\tstatus = dc_stream_get_status(dm_new_crtc_state->stream);\n\t\tWARN_ON(!status);\n\t\tWARN_ON(!status->plane_count);\n\n\t\t/*\n\t\t * TODO: DC refuses to perform stream updates without a dc_surface_update.\n\t\t * Here we create an empty update on each plane.\n\t\t * To fix this, DC should permit updating only stream properties.\n\t\t */\n\t\tfor (j = 0; j < status->plane_count; j++)\n\t\t\tdummy_updates[j].surface = status->plane_states[0];\n\n\n\t\tmutex_lock(&dm->dc_lock);\n\t\tdc_commit_updates_for_stream(dm->dc,\n\t\t\t\t\t\t     dummy_updates,\n\t\t\t\t\t\t     status->plane_count,\n\t\t\t\t\t\t     dm_new_crtc_state->stream,\n\t\t\t\t\t\t     &stream_update,\n\t\t\t\t\t\t     dc_state);\n\t\tmutex_unlock(&dm->dc_lock);\n\t}\n\n\t/* Count number of newly disabled CRTCs for dropping PM refs later. */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t      new_crtc_state, i) {\n\t\tif (old_crtc_state->active && !new_crtc_state->active)\n\t\t\tcrtc_disable_count++;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\t/* For freesync config update on crtc state and params for irq */\n\t\tupdate_stream_irq_parameters(dm, dm_new_crtc_state);\n\n\t\t/* Handle vrr on->off / off->on transitions */\n\t\tamdgpu_dm_handle_vrr_transition(dm_old_crtc_state,\n\t\t\t\t\t\tdm_new_crtc_state);\n\t}\n\n\t/**\n\t * Enable interrupts for CRTCs that are newly enabled or went through\n\t * a modeset. It was intentionally deferred until after the front end\n\t * state was modified to wait until the OTG was on and so the IRQ\n\t * handlers didn't access stale or invalid state.\n\t */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (new_crtc_state->active &&\n\t\t    (!old_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\tdc_stream_retain(dm_new_crtc_state->stream);\n\t\t\tacrtc->dm_irq_params.stream = dm_new_crtc_state->stream;\n\t\t\tmanage_dm_interrupts(adev, acrtc, true);\n\n#ifdef CONFIG_DEBUG_FS\n\t\t\t/**\n\t\t\t * Frontend may have changed so reapply the CRC capture\n\t\t\t * settings for the stream.\n\t\t\t */\n\t\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\t\tif (amdgpu_dm_is_valid_crc_source(dm_new_crtc_state->crc_src)) {\n\t\t\t\tamdgpu_dm_crtc_configure_crc_source(\n\t\t\t\t\tcrtc, dm_new_crtc_state,\n\t\t\t\t\tdm_new_crtc_state->crc_src);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, j)\n\t\tif (new_crtc_state->async_flip)\n\t\t\twait_for_vblank = false;\n\n\t/* update planes when needed per crtc*/\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, j) {\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state->stream)\n\t\t\tamdgpu_dm_commit_planes(state, dc_state, dev,\n\t\t\t\t\t\tdm, crtc, wait_for_vblank);\n\t}\n\n\t/* Update audio instances for each connector. */\n\tamdgpu_dm_commit_audio(dev, state);\n\n\t/*\n\t * send vblank event on all events not handled in flip and\n\t * mark consumed event for drm_atomic_helper_commit_hw_done\n\t */\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\n\t\tif (new_crtc_state->event)\n\t\t\tdrm_send_event_locked(dev, &new_crtc_state->event->base);\n\n\t\tnew_crtc_state->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\n\t/* Signal HW programming completion */\n\tdrm_atomic_helper_commit_hw_done(state);\n\n\tif (wait_for_vblank)\n\t\tdrm_atomic_helper_wait_for_flip_done(dev, state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, state);\n\n\t/* return the stolen vga memory back to VRAM */\n\tif (!adev->mman.keep_stolen_vga_memory)\n\t\tamdgpu_bo_free_kernel(&adev->mman.stolen_vga_memory, NULL, NULL);\n\tamdgpu_bo_free_kernel(&adev->mman.stolen_extended_memory, NULL, NULL);\n\n\t/*\n\t * Finally, drop a runtime PM reference for each newly disabled CRTC,\n\t * so we can put the GPU into runtime suspend if we're not driving any\n\t * displays anymore\n\t */\n\tfor (i = 0; i < crtc_disable_count; i++)\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\tpm_runtime_mark_last_busy(dev->dev);\n\n\tif (dc_state_temp)\n\t\tdc_release_state(dc_state_temp);\n}\n\n\nstatic int dm_force_atomic_commit(struct drm_connector *connector)\n{\n\tint ret = 0;\n\tstruct drm_device *ddev = connector->dev;\n\tstruct drm_atomic_state *state = drm_atomic_state_alloc(ddev);\n\tstruct amdgpu_crtc *disconnected_acrtc = to_amdgpu_crtc(connector->encoder->crtc);\n\tstruct drm_plane *plane = disconnected_acrtc->base.primary;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane_state *plane_state;\n\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ddev->mode_config.acquire_ctx;\n\n\t/* Construct an atomic state to restore previous display setting */\n\n\t/*\n\t * Attach connectors to drm_atomic_state\n\t */\n\tconn_state = drm_atomic_get_connector_state(state, connector);\n\n\tret = PTR_ERR_OR_ZERO(conn_state);\n\tif (ret)\n\t\tgoto err;\n\n\t/* Attach crtc to drm_atomic_state*/\n\tcrtc_state = drm_atomic_get_crtc_state(state, &disconnected_acrtc->base);\n\n\tret = PTR_ERR_OR_ZERO(crtc_state);\n\tif (ret)\n\t\tgoto err;\n\n\t/* force a restore */\n\tcrtc_state->mode_changed = true;\n\n\t/* Attach plane to drm_atomic_state */\n\tplane_state = drm_atomic_get_plane_state(state, plane);\n\n\tret = PTR_ERR_OR_ZERO(plane_state);\n\tif (ret)\n\t\tgoto err;\n\n\n\t/* Call commit internally with the state we just constructed */\n\tret = drm_atomic_commit(state);\n\tif (!ret)\n\t\treturn 0;\n\nerr:\n\tDRM_ERROR(\"Restoring old state failed with %i\\n\", ret);\n\tdrm_atomic_state_put(state);\n\n\treturn ret;\n}\n\n/*\n * This function handles all cases when set mode does not come upon hotplug.\n * This includes when a display is unplugged then plugged back into the\n * same port and when running without usermode desktop manager supprot\n */\nvoid dm_restore_drm_connector_state(struct drm_device *dev,\n\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\tstruct amdgpu_crtc *disconnected_acrtc;\n\tstruct dm_crtc_state *acrtc_state;\n\n\tif (!aconnector->dc_sink || !connector->state || !connector->encoder)\n\t\treturn;\n\n\tdisconnected_acrtc = to_amdgpu_crtc(connector->encoder->crtc);\n\tif (!disconnected_acrtc)\n\t\treturn;\n\n\tacrtc_state = to_dm_crtc_state(disconnected_acrtc->base.state);\n\tif (!acrtc_state->stream)\n\t\treturn;\n\n\t/*\n\t * If the previous sink is not released and different from the current,\n\t * we deduce we are in a state where we can not rely on usermode call\n\t * to turn on the display, so we do it here\n\t */\n\tif (acrtc_state->stream->sink != aconnector->dc_sink)\n\t\tdm_force_atomic_commit(&aconnector->base);\n}\n\n/*\n * Grabs all modesetting locks to serialize against any blocking commits,\n * Waits for completion of all non blocking commits.\n */\nstatic int do_aquire_global_lock(struct drm_device *dev,\n\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_commit *commit;\n\tlong ret;\n\n\t/*\n\t * Adding all modeset locks to aquire_ctx will\n\t * ensure that when the framework release it the\n\t * extra locks we are locking here will get released to\n\t */\n\tret = drm_modeset_lock_all_ctx(dev, state->acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tspin_lock(&crtc->commit_lock);\n\t\tcommit = list_first_entry_or_null(&crtc->commit_list,\n\t\t\t\tstruct drm_crtc_commit, commit_entry);\n\t\tif (commit)\n\t\t\tdrm_crtc_commit_get(commit);\n\t\tspin_unlock(&crtc->commit_lock);\n\n\t\tif (!commit)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Make sure all pending HW programming completed and\n\t\t * page flips done\n\t\t */\n\t\tret = wait_for_completion_interruptible_timeout(&commit->hw_done, 10*HZ);\n\n\t\tif (ret > 0)\n\t\t\tret = wait_for_completion_interruptible_timeout(\n\t\t\t\t\t&commit->flip_done, 10*HZ);\n\n\t\tif (ret == 0)\n\t\t\tDRM_ERROR(\"[CRTC:%d:%s] hw_done or flip_done \"\n\t\t\t\t  \"timed out\\n\", crtc->base.id, crtc->name);\n\n\t\tdrm_crtc_commit_put(commit);\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void get_freesync_config_for_crtc(\n\tstruct dm_crtc_state *new_crtc_state,\n\tstruct dm_connector_state *new_con_state)\n{\n\tstruct mod_freesync_config config = {0};\n\tstruct amdgpu_dm_connector *aconnector =\n\t\t\tto_amdgpu_dm_connector(new_con_state->base.connector);\n\tstruct drm_display_mode *mode = &new_crtc_state->base.mode;\n\tint vrefresh = drm_mode_vrefresh(mode);\n\n\tnew_crtc_state->vrr_supported = new_con_state->freesync_capable &&\n\t\t\t\t\tvrefresh >= aconnector->min_vfreq &&\n\t\t\t\t\tvrefresh <= aconnector->max_vfreq;\n\n\tif (new_crtc_state->vrr_supported) {\n\t\tnew_crtc_state->stream->ignore_msa_timing_param = true;\n\t\tconfig.state = new_crtc_state->base.vrr_enabled ?\n\t\t\t\tVRR_STATE_ACTIVE_VARIABLE :\n\t\t\t\tVRR_STATE_INACTIVE;\n\t\tconfig.min_refresh_in_uhz =\n\t\t\t\taconnector->min_vfreq * 1000000;\n\t\tconfig.max_refresh_in_uhz =\n\t\t\t\taconnector->max_vfreq * 1000000;\n\t\tconfig.vsif_supported = true;\n\t\tconfig.btr = true;\n\t}\n\n\tnew_crtc_state->freesync_config = config;\n}\n\nstatic void reset_freesync_config_for_crtc(\n\tstruct dm_crtc_state *new_crtc_state)\n{\n\tnew_crtc_state->vrr_supported = false;\n\n\tmemset(&new_crtc_state->vrr_infopacket, 0,\n\t       sizeof(new_crtc_state->vrr_infopacket));\n}\n\nstatic int dm_update_crtc_state(struct amdgpu_display_manager *dm,\n\t\t\t\tstruct drm_atomic_state *state,\n\t\t\t\tstruct drm_crtc *crtc,\n\t\t\t\tstruct drm_crtc_state *old_crtc_state,\n\t\t\t\tstruct drm_crtc_state *new_crtc_state,\n\t\t\t\tbool enable,\n\t\t\t\tbool *lock_and_validation_needed)\n{\n\tstruct dm_atomic_state *dm_state = NULL;\n\tstruct dm_crtc_state *dm_old_crtc_state, *dm_new_crtc_state;\n\tstruct dc_stream_state *new_stream;\n\tint ret = 0;\n\n\t/*\n\t * TODO Move this code into dm_crtc_atomic_check once we get rid of dc_validation_set\n\t * update changed items\n\t */\n\tstruct amdgpu_crtc *acrtc = NULL;\n\tstruct amdgpu_dm_connector *aconnector = NULL;\n\tstruct drm_connector_state *drm_new_conn_state = NULL, *drm_old_conn_state = NULL;\n\tstruct dm_connector_state *dm_new_conn_state = NULL, *dm_old_conn_state = NULL;\n\n\tnew_stream = NULL;\n\n\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\tacrtc = to_amdgpu_crtc(crtc);\n\taconnector = amdgpu_dm_find_first_crtc_matching_connector(state, crtc);\n\n\t/* TODO This hack should go away */\n\tif (aconnector && enable) {\n\t\t/* Make sure fake sink is created in plug-in scenario */\n\t\tdrm_new_conn_state = drm_atomic_get_new_connector_state(state,\n\t\t\t\t\t\t\t    &aconnector->base);\n\t\tdrm_old_conn_state = drm_atomic_get_old_connector_state(state,\n\t\t\t\t\t\t\t    &aconnector->base);\n\n\t\tif (IS_ERR(drm_new_conn_state)) {\n\t\t\tret = PTR_ERR_OR_ZERO(drm_new_conn_state);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdm_new_conn_state = to_dm_connector_state(drm_new_conn_state);\n\t\tdm_old_conn_state = to_dm_connector_state(drm_old_conn_state);\n\n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tgoto skip_modeset;\n\n\t\tnew_stream = create_validate_stream_for_sink(aconnector,\n\t\t\t\t\t\t\t     &new_crtc_state->mode,\n\t\t\t\t\t\t\t     dm_new_conn_state,\n\t\t\t\t\t\t\t     dm_old_crtc_state->stream);\n\n\t\t/*\n\t\t * we can have no stream on ACTION_SET if a display\n\t\t * was disconnected during S3, in this case it is not an\n\t\t * error, the OS will be updated after detection, and\n\t\t * will do the right thing on next atomic commit\n\t\t */\n\n\t\tif (!new_stream) {\n\t\t\tDRM_DEBUG_DRIVER(\"%s: Failed to create new stream for crtc %d\\n\",\n\t\t\t\t\t__func__, acrtc->base.base.id);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * TODO: Check VSDB bits to decide whether this should\n\t\t * be enabled or not.\n\t\t */\n\t\tnew_stream->triggered_crtc_reset.enabled =\n\t\t\tdm->force_timing_sync;\n\n\t\tdm_new_crtc_state->abm_level = dm_new_conn_state->abm_level;\n\n\t\tret = fill_hdr_info_packet(drm_new_conn_state,\n\t\t\t\t\t   &new_stream->hdr_static_metadata);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t/*\n\t\t * If we already removed the old stream from the context\n\t\t * (and set the new stream to NULL) then we can't reuse\n\t\t * the old stream even if the stream and scaling are unchanged.\n\t\t * We'll hit the BUG_ON and black screen.\n\t\t *\n\t\t * TODO: Refactor this function to allow this check to work\n\t\t * in all conditions.\n\t\t */\n\t\tif (dm_new_crtc_state->stream &&\n\t\t    dc_is_stream_unchanged(new_stream, dm_old_crtc_state->stream) &&\n\t\t    dc_is_stream_scaling_unchanged(new_stream, dm_old_crtc_state->stream)) {\n\t\t\tnew_crtc_state->mode_changed = false;\n\t\t\tDRM_DEBUG_DRIVER(\"Mode change not required, setting mode_changed to %d\",\n\t\t\t\t\t new_crtc_state->mode_changed);\n\t\t}\n\t}\n\n\t/* mode_changed flag may get updated above, need to check again */\n\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\tgoto skip_modeset;\n\n\tDRM_DEBUG_DRIVER(\n\t\t\"amdgpu_crtc id:%d crtc_state_flags: enable:%d, active:%d, \"\n\t\t\"planes_changed:%d, mode_changed:%d,active_changed:%d,\"\n\t\t\"connectors_changed:%d\\n\",\n\t\tacrtc->crtc_id,\n\t\tnew_crtc_state->enable,\n\t\tnew_crtc_state->active,\n\t\tnew_crtc_state->planes_changed,\n\t\tnew_crtc_state->mode_changed,\n\t\tnew_crtc_state->active_changed,\n\t\tnew_crtc_state->connectors_changed);\n\n\t/* Remove stream for any changed/disabled CRTC */\n\tif (!enable) {\n\n\t\tif (!dm_old_crtc_state->stream)\n\t\t\tgoto skip_modeset;\n\n\t\tret = dm_atomic_get_state(state, &dm_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tDRM_DEBUG_DRIVER(\"Disabling DRM crtc: %d\\n\",\n\t\t\t\tcrtc->base.id);\n\n\t\t/* i.e. reset mode */\n\t\tif (dc_remove_stream_from_ctx(\n\t\t\t\tdm->dc,\n\t\t\t\tdm_state->context,\n\t\t\t\tdm_old_crtc_state->stream) != DC_OK) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdc_stream_release(dm_old_crtc_state->stream);\n\t\tdm_new_crtc_state->stream = NULL;\n\n\t\treset_freesync_config_for_crtc(dm_new_crtc_state);\n\n\t\t*lock_and_validation_needed = true;\n\n\t} else {/* Add stream for any updated/enabled CRTC */\n\t\t/*\n\t\t * Quick fix to prevent NULL pointer on new_stream when\n\t\t * added MST connectors not found in existing crtc_state in the chained mode\n\t\t * TODO: need to dig out the root cause of that\n\t\t */\n\t\tif (!aconnector || (!aconnector->dc_sink && aconnector->mst_port))\n\t\t\tgoto skip_modeset;\n\n\t\tif (modereset_required(new_crtc_state))\n\t\t\tgoto skip_modeset;\n\n\t\tif (modeset_required(new_crtc_state, new_stream,\n\t\t\t\t     dm_old_crtc_state->stream)) {\n\n\t\t\tWARN_ON(dm_new_crtc_state->stream);\n\n\t\t\tret = dm_atomic_get_state(state, &dm_state);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\n\t\t\tdm_new_crtc_state->stream = new_stream;\n\n\t\t\tdc_stream_retain(new_stream);\n\n\t\t\tDRM_DEBUG_DRIVER(\"Enabling DRM crtc: %d\\n\",\n\t\t\t\t\t\tcrtc->base.id);\n\n\t\t\tif (dc_add_stream_to_ctx(\n\t\t\t\t\tdm->dc,\n\t\t\t\t\tdm_state->context,\n\t\t\t\t\tdm_new_crtc_state->stream) != DC_OK) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t*lock_and_validation_needed = true;\n\t\t}\n\t}\n\nskip_modeset:\n\t/* Release extra reference */\n\tif (new_stream)\n\t\t dc_stream_release(new_stream);\n\n\t/*\n\t * We want to do dc stream updates that do not require a\n\t * full modeset below.\n\t */\n\tif (!(enable && aconnector && new_crtc_state->active))\n\t\treturn 0;\n\t/*\n\t * Given above conditions, the dc state cannot be NULL because:\n\t * 1. We're in the process of enabling CRTCs (just been added\n\t *    to the dc context, or already is on the context)\n\t * 2. Has a valid connector attached, and\n\t * 3. Is currently active and enabled.\n\t * => The dc stream state currently exists.\n\t */\n\tBUG_ON(dm_new_crtc_state->stream == NULL);\n\n\t/* Scaling or underscan settings */\n\tif (is_scaling_state_different(dm_old_conn_state, dm_new_conn_state))\n\t\tupdate_stream_scaling_settings(\n\t\t\t&new_crtc_state->mode, dm_new_conn_state, dm_new_crtc_state->stream);\n\n\t/* ABM settings */\n\tdm_new_crtc_state->abm_level = dm_new_conn_state->abm_level;\n\n\t/*\n\t * Color management settings. We also update color properties\n\t * when a modeset is needed, to ensure it gets reprogrammed.\n\t */\n\tif (dm_new_crtc_state->base.color_mgmt_changed ||\n\t    drm_atomic_crtc_needs_modeset(new_crtc_state)) {\n\t\tret = amdgpu_dm_update_crtc_color_mgmt(dm_new_crtc_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t/* Update Freesync settings. */\n\tget_freesync_config_for_crtc(dm_new_crtc_state,\n\t\t\t\t     dm_new_conn_state);\n\n\treturn ret;\n\nfail:\n\tif (new_stream)\n\t\tdc_stream_release(new_stream);\n\treturn ret;\n}\n\nstatic bool should_reset_plane(struct drm_atomic_state *state,\n\t\t\t       struct drm_plane *plane,\n\t\t\t       struct drm_plane_state *old_plane_state,\n\t\t\t       struct drm_plane_state *new_plane_state)\n{\n\tstruct drm_plane *other;\n\tstruct drm_plane_state *old_other_state, *new_other_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tint i;\n\n\t/*\n\t * TODO: Remove this hack once the checks below are sufficient\n\t * enough to determine when we need to reset all the planes on\n\t * the stream.\n\t */\n\tif (state->allow_modeset)\n\t\treturn true;\n\n\t/* Exit early if we know that we're adding or removing the plane. */\n\tif (old_plane_state->crtc != new_plane_state->crtc)\n\t\treturn true;\n\n\t/* old crtc == new_crtc == NULL, plane not in context. */\n\tif (!new_plane_state->crtc)\n\t\treturn false;\n\n\tnew_crtc_state =\n\t\tdrm_atomic_get_new_crtc_state(state, new_plane_state->crtc);\n\n\tif (!new_crtc_state)\n\t\treturn true;\n\n\t/* CRTC Degamma changes currently require us to recreate planes. */\n\tif (new_crtc_state->color_mgmt_changed)\n\t\treturn true;\n\n\tif (drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\treturn true;\n\n\t/*\n\t * If there are any new primary or overlay planes being added or\n\t * removed then the z-order can potentially change. To ensure\n\t * correct z-order and pipe acquisition the current DC architecture\n\t * requires us to remove and recreate all existing planes.\n\t *\n\t * TODO: Come up with a more elegant solution for this.\n\t */\n\tfor_each_oldnew_plane_in_state(state, other, old_other_state, new_other_state, i) {\n\t\tstruct amdgpu_framebuffer *old_afb, *new_afb;\n\t\tif (other->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\tcontinue;\n\n\t\tif (old_other_state->crtc != new_plane_state->crtc &&\n\t\t    new_other_state->crtc != new_plane_state->crtc)\n\t\t\tcontinue;\n\n\t\tif (old_other_state->crtc != new_other_state->crtc)\n\t\t\treturn true;\n\n\t\t/* Src/dst size and scaling updates. */\n\t\tif (old_other_state->src_w != new_other_state->src_w ||\n\t\t    old_other_state->src_h != new_other_state->src_h ||\n\t\t    old_other_state->crtc_w != new_other_state->crtc_w ||\n\t\t    old_other_state->crtc_h != new_other_state->crtc_h)\n\t\t\treturn true;\n\n\t\t/* Rotation / mirroring updates. */\n\t\tif (old_other_state->rotation != new_other_state->rotation)\n\t\t\treturn true;\n\n\t\t/* Blending updates. */\n\t\tif (old_other_state->pixel_blend_mode !=\n\t\t    new_other_state->pixel_blend_mode)\n\t\t\treturn true;\n\n\t\t/* Alpha updates. */\n\t\tif (old_other_state->alpha != new_other_state->alpha)\n\t\t\treturn true;\n\n\t\t/* Colorspace changes. */\n\t\tif (old_other_state->color_range != new_other_state->color_range ||\n\t\t    old_other_state->color_encoding != new_other_state->color_encoding)\n\t\t\treturn true;\n\n\t\t/* Framebuffer checks fall at the end. */\n\t\tif (!old_other_state->fb || !new_other_state->fb)\n\t\t\tcontinue;\n\n\t\t/* Pixel format changes can require bandwidth updates. */\n\t\tif (old_other_state->fb->format != new_other_state->fb->format)\n\t\t\treturn true;\n\n\t\told_afb = (struct amdgpu_framebuffer *)old_other_state->fb;\n\t\tnew_afb = (struct amdgpu_framebuffer *)new_other_state->fb;\n\n\t\t/* Tiling and DCC changes also require bandwidth updates. */\n\t\tif (old_afb->tiling_flags != new_afb->tiling_flags ||\n\t\t    old_afb->base.modifier != new_afb->base.modifier)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int dm_check_cursor_fb(struct amdgpu_crtc *new_acrtc,\n\t\t\t      struct drm_plane_state *new_plane_state,\n\t\t\t      struct drm_framebuffer *fb)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(new_acrtc->base.dev);\n\tstruct amdgpu_framebuffer *afb = to_amdgpu_framebuffer(fb);\n\tunsigned int pitch;\n\tbool linear;\n\n\tif (fb->width > new_acrtc->max_cursor_width ||\n\t    fb->height > new_acrtc->max_cursor_height) {\n\t\tDRM_DEBUG_ATOMIC(\"Bad cursor FB size %dx%d\\n\",\n\t\t\t\t new_plane_state->fb->width,\n\t\t\t\t new_plane_state->fb->height);\n\t\treturn -EINVAL;\n\t}\n\tif (new_plane_state->src_w != fb->width << 16 ||\n\t    new_plane_state->src_h != fb->height << 16) {\n\t\tDRM_DEBUG_ATOMIC(\"Cropping not supported for cursor plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Pitch in pixels */\n\tpitch = fb->pitches[0] / fb->format->cpp[0];\n\n\tif (fb->width != pitch) {\n\t\tDRM_DEBUG_ATOMIC(\"Cursor FB width %d doesn't match pitch %d\",\n\t\t\t\t fb->width, pitch);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (pitch) {\n\tcase 64:\n\tcase 128:\n\tcase 256:\n\t\t/* FB pitch is supported by cursor plane */\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_ATOMIC(\"Bad cursor FB pitch %d px\\n\", pitch);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Core DRM takes care of checking FB modifiers, so we only need to\n\t * check tiling flags when the FB doesn't have a modifier. */\n\tif (!(fb->flags & DRM_MODE_FB_MODIFIERS)) {\n\t\tif (adev->family < AMDGPU_FAMILY_AI) {\n\t\t\tlinear = AMDGPU_TILING_GET(afb->tiling_flags, ARRAY_MODE) != DC_ARRAY_2D_TILED_THIN1 &&\n\t\t\t         AMDGPU_TILING_GET(afb->tiling_flags, ARRAY_MODE) != DC_ARRAY_1D_TILED_THIN1 &&\n\t\t\t\t AMDGPU_TILING_GET(afb->tiling_flags, MICRO_TILE_MODE) == 0;\n\t\t} else {\n\t\t\tlinear = AMDGPU_TILING_GET(afb->tiling_flags, SWIZZLE_MODE) == 0;\n\t\t}\n\t\tif (!linear) {\n\t\t\tDRM_DEBUG_ATOMIC(\"Cursor FB not linear\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dm_update_plane_state(struct dc *dc,\n\t\t\t\t struct drm_atomic_state *state,\n\t\t\t\t struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *old_plane_state,\n\t\t\t\t struct drm_plane_state *new_plane_state,\n\t\t\t\t bool enable,\n\t\t\t\t bool *lock_and_validation_needed)\n{\n\n\tstruct dm_atomic_state *dm_state = NULL;\n\tstruct drm_crtc *new_plane_crtc, *old_plane_crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct dm_crtc_state *dm_new_crtc_state, *dm_old_crtc_state;\n\tstruct dm_plane_state *dm_new_plane_state, *dm_old_plane_state;\n\tstruct amdgpu_crtc *new_acrtc;\n\tbool needs_reset;\n\tint ret = 0;\n\n\n\tnew_plane_crtc = new_plane_state->crtc;\n\told_plane_crtc = old_plane_state->crtc;\n\tdm_new_plane_state = to_dm_plane_state(new_plane_state);\n\tdm_old_plane_state = to_dm_plane_state(old_plane_state);\n\n\tif (plane->type == DRM_PLANE_TYPE_CURSOR) {\n\t\tif (!enable || !new_plane_crtc ||\n\t\t\tdrm_atomic_plane_disabling(plane->state, new_plane_state))\n\t\t\treturn 0;\n\n\t\tnew_acrtc = to_amdgpu_crtc(new_plane_crtc);\n\n\t\tif (new_plane_state->src_x != 0 || new_plane_state->src_y != 0) {\n\t\t\tDRM_DEBUG_ATOMIC(\"Cropping not supported for cursor plane\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (new_plane_state->fb) {\n\t\t\tret = dm_check_cursor_fb(new_acrtc, new_plane_state,\n\t\t\t\t\t\t new_plane_state->fb);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tneeds_reset = should_reset_plane(state, plane, old_plane_state,\n\t\t\t\t\t new_plane_state);\n\n\t/* Remove any changed/removed planes */\n\tif (!enable) {\n\t\tif (!needs_reset)\n\t\t\treturn 0;\n\n\t\tif (!old_plane_crtc)\n\t\t\treturn 0;\n\n\t\told_crtc_state = drm_atomic_get_old_crtc_state(\n\t\t\t\tstate, old_plane_crtc);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tif (!dm_old_crtc_state->stream)\n\t\t\treturn 0;\n\n\t\tDRM_DEBUG_ATOMIC(\"Disabling DRM plane: %d on DRM crtc %d\\n\",\n\t\t\t\tplane->base.id, old_plane_crtc->base.id);\n\n\t\tret = dm_atomic_get_state(state, &dm_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!dc_remove_plane_from_context(\n\t\t\t\tdc,\n\t\t\t\tdm_old_crtc_state->stream,\n\t\t\t\tdm_old_plane_state->dc_state,\n\t\t\t\tdm_state->context)) {\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\n\t\tdc_plane_state_release(dm_old_plane_state->dc_state);\n\t\tdm_new_plane_state->dc_state = NULL;\n\n\t\t*lock_and_validation_needed = true;\n\n\t} else { /* Add new planes */\n\t\tstruct dc_plane_state *dc_new_plane_state;\n\n\t\tif (drm_atomic_plane_disabling(plane->state, new_plane_state))\n\t\t\treturn 0;\n\n\t\tif (!new_plane_crtc)\n\t\t\treturn 0;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_plane_crtc);\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (!dm_new_crtc_state->stream)\n\t\t\treturn 0;\n\n\t\tif (!needs_reset)\n\t\t\treturn 0;\n\n\t\tret = dm_plane_helper_check_state(new_plane_state, new_crtc_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON(dm_new_plane_state->dc_state);\n\n\t\tdc_new_plane_state = dc_create_plane_state(dc);\n\t\tif (!dc_new_plane_state)\n\t\t\treturn -ENOMEM;\n\n\t\tDRM_DEBUG_DRIVER(\"Enabling DRM plane: %d on DRM crtc %d\\n\",\n\t\t\t\tplane->base.id, new_plane_crtc->base.id);\n\n\t\tret = fill_dc_plane_attributes(\n\t\t\tdrm_to_adev(new_plane_crtc->dev),\n\t\t\tdc_new_plane_state,\n\t\t\tnew_plane_state,\n\t\t\tnew_crtc_state);\n\t\tif (ret) {\n\t\t\tdc_plane_state_release(dc_new_plane_state);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = dm_atomic_get_state(state, &dm_state);\n\t\tif (ret) {\n\t\t\tdc_plane_state_release(dc_new_plane_state);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Any atomic check errors that occur after this will\n\t\t * not need a release. The plane state will be attached\n\t\t * to the stream, and therefore part of the atomic\n\t\t * state. It'll be released when the atomic state is\n\t\t * cleaned.\n\t\t */\n\t\tif (!dc_add_plane_to_context(\n\t\t\t\tdc,\n\t\t\t\tdm_new_crtc_state->stream,\n\t\t\t\tdc_new_plane_state,\n\t\t\t\tdm_state->context)) {\n\n\t\t\tdc_plane_state_release(dc_new_plane_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdm_new_plane_state->dc_state = dc_new_plane_state;\n\n\t\t/* Tell DC to do a full surface update every time there\n\t\t * is a plane change. Inefficient, but works for now.\n\t\t */\n\t\tdm_new_plane_state->dc_state->update_flags.bits.full_update = 1;\n\n\t\t*lock_and_validation_needed = true;\n\t}\n\n\n\treturn ret;\n}\n\nstatic int dm_check_crtc_cursor(struct drm_atomic_state *state,\n\t\t\t\tstruct drm_crtc *crtc,\n\t\t\t\tstruct drm_crtc_state *new_crtc_state)\n{\n\tstruct drm_plane_state *new_cursor_state, *new_primary_state;\n\tint cursor_scale_w, cursor_scale_h, primary_scale_w, primary_scale_h;\n\n\t/* On DCE and DCN there is no dedicated hardware cursor plane. We get a\n\t * cursor per pipe but it's going to inherit the scaling and\n\t * positioning from the underlying pipe. Check the cursor plane's\n\t * blending properties match the primary plane's. */\n\n\tnew_cursor_state = drm_atomic_get_new_plane_state(state, crtc->cursor);\n\tnew_primary_state = drm_atomic_get_new_plane_state(state, crtc->primary);\n\tif (!new_cursor_state || !new_primary_state || !new_cursor_state->fb) {\n\t\treturn 0;\n\t}\n\n\tcursor_scale_w = new_cursor_state->crtc_w * 1000 /\n\t\t\t (new_cursor_state->src_w >> 16);\n\tcursor_scale_h = new_cursor_state->crtc_h * 1000 /\n\t\t\t (new_cursor_state->src_h >> 16);\n\n\tprimary_scale_w = new_primary_state->crtc_w * 1000 /\n\t\t\t (new_primary_state->src_w >> 16);\n\tprimary_scale_h = new_primary_state->crtc_h * 1000 /\n\t\t\t (new_primary_state->src_h >> 16);\n\n\tif (cursor_scale_w != primary_scale_w ||\n\t    cursor_scale_h != primary_scale_h) {\n\t\tDRM_DEBUG_ATOMIC(\"Cursor plane scaling doesn't match primary plane\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\nstatic int add_affected_mst_dsc_crtcs(struct drm_atomic_state *state, struct drm_crtc *crtc)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\tstruct amdgpu_dm_connector *aconnector = NULL;\n\tint i;\n\tfor_each_new_connector_in_state(state, connector, conn_state, i) {\n\t\tif (conn_state->crtc != crtc)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\tif (!aconnector->port || !aconnector->mst_port)\n\t\t\taconnector = NULL;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (!aconnector)\n\t\treturn 0;\n\n\treturn drm_dp_mst_add_affected_dsc_crtcs(state, &aconnector->mst_port->mst_mgr);\n}\n#endif\n\n/**\n * amdgpu_dm_atomic_check() - Atomic check implementation for AMDgpu DM.\n * @dev: The DRM device\n * @state: The atomic state to commit\n *\n * Validate that the given atomic state is programmable by DC into hardware.\n * This involves constructing a &struct dc_state reflecting the new hardware\n * state we wish to commit, then querying DC to see if it is programmable. It's\n * important not to modify the existing DC state. Otherwise, atomic_check\n * may unexpectedly commit hardware changes.\n *\n * When validating the DC state, it's important that the right locks are\n * acquired. For full updates case which removes/adds/updates streams on one\n * CRTC while flipping on another CRTC, acquiring global lock will guarantee\n * that any such full update commit will wait for completion of any outstanding\n * flip using DRMs synchronization events.\n *\n * Note that DM adds the affected connectors for all CRTCs in state, when that\n * might not seem necessary. This is because DC stream creation requires the\n * DC sink, which is tied to the DRM connector state. Cleaning this up should\n * be possible but non-trivial - a possible TODO item.\n *\n * Return: -Error code if validation failed.\n */\nstatic int amdgpu_dm_atomic_check(struct drm_device *dev,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dm_atomic_state *dm_state = NULL;\n\tstruct dc *dc = adev->dm.dc;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_con_state, *new_con_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tenum dc_status status;\n\tint ret, i;\n\tbool lock_and_validation_needed = false;\n\tstruct dm_crtc_state *dm_old_crtc_state;\n\n\ttrace_amdgpu_dm_atomic_check_begin(state);\n\n\tret = drm_atomic_helper_check_modeset(dev, state);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Check connector changes */\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\n\t\t/* Skip connectors that are disabled or part of modeset already. */\n\t\tif (!old_con_state->crtc && !new_con_state->crtc)\n\t\t\tcontinue;\n\n\t\tif (!new_con_state->crtc)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_crtc_state(state, new_con_state->crtc);\n\t\tif (IS_ERR(new_crtc_state)) {\n\t\t\tret = PTR_ERR(new_crtc_state);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (dm_old_con_state->abm_level !=\n\t\t    dm_new_con_state->abm_level)\n\t\t\tnew_crtc_state->connectors_changed = true;\n\t}\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\tif (adev->asic_type >= CHIP_NAVI10) {\n\t\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\t\tif (drm_atomic_crtc_needs_modeset(new_crtc_state)) {\n\t\t\t\tret = add_affected_mst_dsc_crtcs(state, crtc);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state) &&\n\t\t    !new_crtc_state->color_mgmt_changed &&\n\t\t    old_crtc_state->vrr_enabled == new_crtc_state->vrr_enabled &&\n\t\t\tdm_old_crtc_state->dsc_force_changed == false)\n\t\t\tcontinue;\n\n\t\tif (!new_crtc_state->enable)\n\t\t\tcontinue;\n\n\t\tret = drm_atomic_add_affected_connectors(state, crtc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (dm_old_crtc_state->dsc_force_changed)\n\t\t\tnew_crtc_state->mode_changed = true;\n\t}\n\n\t/*\n\t * Add all primary and overlay planes on the CRTC to the state\n\t * whenever a plane is enabled to maintain correct z-ordering\n\t * and to enable fast surface updates.\n\t */\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tbool modified = false;\n\n\t\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\t\tcontinue;\n\n\t\t\tif (new_plane_state->crtc == crtc ||\n\t\t\t    old_plane_state->crtc == crtc) {\n\t\t\t\tmodified = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!modified)\n\t\t\tcontinue;\n\n\t\tdrm_for_each_plane_mask(plane, state->dev, crtc->state->plane_mask) {\n\t\t\tif (plane->type == DRM_PLANE_TYPE_CURSOR)\n\t\t\t\tcontinue;\n\n\t\t\tnew_plane_state =\n\t\t\t\tdrm_atomic_get_plane_state(state, plane);\n\n\t\t\tif (IS_ERR(new_plane_state)) {\n\t\t\t\tret = PTR_ERR(new_plane_state);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Remove exiting planes if they are modified */\n\tfor_each_oldnew_plane_in_state_reverse(state, plane, old_plane_state, new_plane_state, i) {\n\t\tret = dm_update_plane_state(dc, state, plane,\n\t\t\t\t\t    old_plane_state,\n\t\t\t\t\t    new_plane_state,\n\t\t\t\t\t    false,\n\t\t\t\t\t    &lock_and_validation_needed);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t/* Disable all crtcs which require disable */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tret = dm_update_crtc_state(&adev->dm, state, crtc,\n\t\t\t\t\t   old_crtc_state,\n\t\t\t\t\t   new_crtc_state,\n\t\t\t\t\t   false,\n\t\t\t\t\t   &lock_and_validation_needed);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t/* Enable all crtcs which require enable */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tret = dm_update_crtc_state(&adev->dm, state, crtc,\n\t\t\t\t\t   old_crtc_state,\n\t\t\t\t\t   new_crtc_state,\n\t\t\t\t\t   true,\n\t\t\t\t\t   &lock_and_validation_needed);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t/* Add new/modified planes */\n\tfor_each_oldnew_plane_in_state_reverse(state, plane, old_plane_state, new_plane_state, i) {\n\t\tret = dm_update_plane_state(dc, state, plane,\n\t\t\t\t\t    old_plane_state,\n\t\t\t\t\t    new_plane_state,\n\t\t\t\t\t    true,\n\t\t\t\t\t    &lock_and_validation_needed);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t/* Run this here since we want to validate the streams we created */\n\tret = drm_atomic_helper_check_planes(dev, state);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* Check cursor planes scaling */\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tret = dm_check_crtc_cursor(state, crtc, new_crtc_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tif (state->legacy_cursor_update) {\n\t\t/*\n\t\t * This is a fast cursor update coming from the plane update\n\t\t * helper, check if it can be done asynchronously for better\n\t\t * performance.\n\t\t */\n\t\tstate->async_update =\n\t\t\t!drm_atomic_helper_async_check(dev, state);\n\n\t\t/*\n\t\t * Skip the remaining global validation if this is an async\n\t\t * update. Cursor updates can be done without affecting\n\t\t * state or bandwidth calcs and this avoids the performance\n\t\t * penalty of locking the private state object and\n\t\t * allocating a new dc_state.\n\t\t */\n\t\tif (state->async_update)\n\t\t\treturn 0;\n\t}\n\n\t/* Check scaling and underscan changes*/\n\t/* TODO Removed scaling changes validation due to inability to commit\n\t * new stream into context w\\o causing full reset. Need to\n\t * decide how to handle.\n\t */\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\n\t\t/* Skip any modesets/resets */\n\t\tif (!acrtc || drm_atomic_crtc_needs_modeset(\n\t\t\t\tdrm_atomic_get_new_crtc_state(state, &acrtc->base)))\n\t\t\tcontinue;\n\n\t\t/* Skip any thing not scale or underscan changes */\n\t\tif (!is_scaling_state_different(dm_new_con_state, dm_old_con_state))\n\t\t\tcontinue;\n\n\t\tlock_and_validation_needed = true;\n\t}\n\n\t/**\n\t * Streams and planes are reset when there are changes that affect\n\t * bandwidth. Anything that affects bandwidth needs to go through\n\t * DC global validation to ensure that the configuration can be applied\n\t * to hardware.\n\t *\n\t * We have to currently stall out here in atomic_check for outstanding\n\t * commits to finish in this case because our IRQ handlers reference\n\t * DRM state directly - we can end up disabling interrupts too early\n\t * if we don't.\n\t *\n\t * TODO: Remove this stall and drop DM state private objects.\n\t */\n\tif (lock_and_validation_needed) {\n\t\tret = dm_atomic_get_state(state, &dm_state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = do_aquire_global_lock(dev, state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n#if defined(CONFIG_DRM_AMD_DC_DCN)\n\t\tif (!compute_mst_dsc_configs_for_state(state, dm_state->context))\n\t\t\tgoto fail;\n\n\t\tret = dm_update_mst_vcpi_slots_for_dsc(state, dm_state->context);\n\t\tif (ret)\n\t\t\tgoto fail;\n#endif\n\n\t\t/*\n\t\t * Perform validation of MST topology in the state:\n\t\t * We need to perform MST atomic check before calling\n\t\t * dc_validate_global_state(), or there is a chance\n\t\t * to get stuck in an infinite loop and hang eventually.\n\t\t */\n\t\tret = drm_dp_mst_atomic_check(state);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tstatus = dc_validate_global_state(dc, dm_state->context, false);\n\t\tif (status != DC_OK) {\n\t\t\tDC_LOG_WARNING(\"DC global validation failure: %s (%d)\",\n\t\t\t\t       dc_status_to_str(status), status);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The commit is a fast update. Fast updates shouldn't change\n\t\t * the DC context, affect global validation, and can have their\n\t\t * commit work done in parallel with other commits not touching\n\t\t * the same resource. If we have a new DC context as part of\n\t\t * the DM atomic state from validation we need to free it and\n\t\t * retain the existing one instead.\n\t\t *\n\t\t * Furthermore, since the DM atomic state only contains the DC\n\t\t * context and can safely be annulled, we can free the state\n\t\t * and clear the associated private object now to free\n\t\t * some memory and avoid a possible use-after-free later.\n\t\t */\n\n\t\tfor (i = 0; i < state->num_private_objs; i++) {\n\t\t\tstruct drm_private_obj *obj = state->private_objs[i].ptr;\n\n\t\t\tif (obj->funcs == adev->dm.atomic_obj.funcs) {\n\t\t\t\tint j = state->num_private_objs-1;\n\n\t\t\t\tdm_atomic_destroy_state(obj,\n\t\t\t\t\t\tstate->private_objs[i].state);\n\n\t\t\t\t/* If i is not at the end of the array then the\n\t\t\t\t * last element needs to be moved to where i was\n\t\t\t\t * before the array can safely be truncated.\n\t\t\t\t */\n\t\t\t\tif (i != j)\n\t\t\t\t\tstate->private_objs[i] =\n\t\t\t\t\t\tstate->private_objs[j];\n\n\t\t\t\tstate->private_objs[j].ptr = NULL;\n\t\t\t\tstate->private_objs[j].state = NULL;\n\t\t\t\tstate->private_objs[j].old_state = NULL;\n\t\t\t\tstate->private_objs[j].new_state = NULL;\n\n\t\t\t\tstate->num_private_objs = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Store the overall update type for use later in atomic check. */\n\tfor_each_new_crtc_in_state (state, crtc, new_crtc_state, i) {\n\t\tstruct dm_crtc_state *dm_new_crtc_state =\n\t\t\tto_dm_crtc_state(new_crtc_state);\n\n\t\tdm_new_crtc_state->update_type = lock_and_validation_needed ?\n\t\t\t\t\t\t\t UPDATE_TYPE_FULL :\n\t\t\t\t\t\t\t UPDATE_TYPE_FAST;\n\t}\n\n\t/* Must be success */\n\tWARN_ON(ret);\n\n\ttrace_amdgpu_dm_atomic_check_finish(state, ret);\n\n\treturn ret;\n\nfail:\n\tif (ret == -EDEADLK)\n\t\tDRM_DEBUG_DRIVER(\"Atomic check stopped to avoid deadlock.\\n\");\n\telse if (ret == -EINTR || ret == -EAGAIN || ret == -ERESTARTSYS)\n\t\tDRM_DEBUG_DRIVER(\"Atomic check stopped due to signal.\\n\");\n\telse\n\t\tDRM_DEBUG_DRIVER(\"Atomic check failed with err: %d \\n\", ret);\n\n\ttrace_amdgpu_dm_atomic_check_finish(state, ret);\n\n\treturn ret;\n}\n\nstatic bool is_dp_capable_without_timing_msa(struct dc *dc,\n\t\t\t\t\t     struct amdgpu_dm_connector *amdgpu_dm_connector)\n{\n\tuint8_t dpcd_data;\n\tbool capable = false;\n\n\tif (amdgpu_dm_connector->dc_link &&\n\t\tdm_helpers_dp_read_dpcd(\n\t\t\t\tNULL,\n\t\t\t\tamdgpu_dm_connector->dc_link,\n\t\t\t\tDP_DOWN_STREAM_PORT_COUNT,\n\t\t\t\t&dpcd_data,\n\t\t\t\tsizeof(dpcd_data))) {\n\t\tcapable = (dpcd_data & DP_MSA_TIMING_PAR_IGNORED) ? true:false;\n\t}\n\n\treturn capable;\n}\nvoid amdgpu_dm_update_freesync_caps(struct drm_connector *connector,\n\t\t\t\t\tstruct edid *edid)\n{\n\tint i;\n\tbool edid_check_required;\n\tstruct detailed_timing *timing;\n\tstruct detailed_non_pixel *data;\n\tstruct detailed_data_monitor_range *range;\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector =\n\t\t\tto_amdgpu_dm_connector(connector);\n\tstruct dm_connector_state *dm_con_state = NULL;\n\n\tstruct drm_device *dev = connector->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tbool freesync_capable = false;\n\n\tif (!connector->state) {\n\t\tDRM_ERROR(\"%s - Connector has no state\", __func__);\n\t\tgoto update;\n\t}\n\n\tif (!edid) {\n\t\tdm_con_state = to_dm_connector_state(connector->state);\n\n\t\tamdgpu_dm_connector->min_vfreq = 0;\n\t\tamdgpu_dm_connector->max_vfreq = 0;\n\t\tamdgpu_dm_connector->pixel_clock_mhz = 0;\n\n\t\tgoto update;\n\t}\n\n\tdm_con_state = to_dm_connector_state(connector->state);\n\n\tedid_check_required = false;\n\tif (!amdgpu_dm_connector->dc_sink) {\n\t\tDRM_ERROR(\"dc_sink NULL, could not add free_sync module.\\n\");\n\t\tgoto update;\n\t}\n\tif (!adev->dm.freesync_module)\n\t\tgoto update;\n\t/*\n\t * if edid non zero restrict freesync only for dp and edp\n\t */\n\tif (edid) {\n\t\tif (amdgpu_dm_connector->dc_sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT\n\t\t\t|| amdgpu_dm_connector->dc_sink->sink_signal == SIGNAL_TYPE_EDP) {\n\t\t\tedid_check_required = is_dp_capable_without_timing_msa(\n\t\t\t\t\t\tadev->dm.dc,\n\t\t\t\t\t\tamdgpu_dm_connector);\n\t\t}\n\t}\n\tif (edid_check_required == true && (edid->version > 1 ||\n\t   (edid->version == 1 && edid->revision > 1))) {\n\t\tfor (i = 0; i < 4; i++) {\n\n\t\t\ttiming\t= &edid->detailed_timings[i];\n\t\t\tdata\t= &timing->data.other_data;\n\t\t\trange\t= &data->data.range;\n\t\t\t/*\n\t\t\t * Check if monitor has continuous frequency mode\n\t\t\t */\n\t\t\tif (data->type != EDID_DETAIL_MONITOR_RANGE)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Check for flag range limits only. If flag == 1 then\n\t\t\t * no additional timing information provided.\n\t\t\t * Default GTF, GTF Secondary curve and CVT are not\n\t\t\t * supported\n\t\t\t */\n\t\t\tif (range->flags != 1)\n\t\t\t\tcontinue;\n\n\t\t\tamdgpu_dm_connector->min_vfreq = range->min_vfreq;\n\t\t\tamdgpu_dm_connector->max_vfreq = range->max_vfreq;\n\t\t\tamdgpu_dm_connector->pixel_clock_mhz =\n\t\t\t\trange->pixel_clock_mhz * 10;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (amdgpu_dm_connector->max_vfreq -\n\t\t    amdgpu_dm_connector->min_vfreq > 10) {\n\n\t\t\tfreesync_capable = true;\n\t\t}\n\t}\n\nupdate:\n\tif (dm_con_state)\n\t\tdm_con_state->freesync_capable = freesync_capable;\n\n\tif (connector->vrr_capable_property)\n\t\tdrm_connector_set_vrr_capable_property(connector,\n\t\t\t\t\t\t       freesync_capable);\n}\n\nstatic void amdgpu_dm_set_psr_caps(struct dc_link *link)\n{\n\tuint8_t dpcd_data[EDP_PSR_RECEIVER_CAP_SIZE];\n\n\tif (!(link->connector_signal & SIGNAL_TYPE_EDP))\n\t\treturn;\n\tif (link->type == dc_connection_none)\n\t\treturn;\n\tif (dm_helpers_dp_read_dpcd(NULL, link, DP_PSR_SUPPORT,\n\t\t\t\t\tdpcd_data, sizeof(dpcd_data))) {\n\t\tlink->dpcd_caps.psr_caps.psr_version = dpcd_data[0];\n\n\t\tif (dpcd_data[0] == 0) {\n\t\t\tlink->psr_settings.psr_version = DC_PSR_VERSION_UNSUPPORTED;\n\t\t\tlink->psr_settings.psr_feature_enabled = false;\n\t\t} else {\n\t\t\tlink->psr_settings.psr_version = DC_PSR_VERSION_1;\n\t\t\tlink->psr_settings.psr_feature_enabled = true;\n\t\t}\n\n\t\tDRM_INFO(\"PSR support:%d\\n\", link->psr_settings.psr_feature_enabled);\n\t}\n}\n\n/*\n * amdgpu_dm_link_setup_psr() - configure psr link\n * @stream: stream state\n *\n * Return: true if success\n */\nstatic bool amdgpu_dm_link_setup_psr(struct dc_stream_state *stream)\n{\n\tstruct dc_link *link = NULL;\n\tstruct psr_config psr_config = {0};\n\tstruct psr_context psr_context = {0};\n\tbool ret = false;\n\n\tif (stream == NULL)\n\t\treturn false;\n\n\tlink = stream->link;\n\n\tpsr_config.psr_version = link->dpcd_caps.psr_caps.psr_version;\n\n\tif (psr_config.psr_version > 0) {\n\t\tpsr_config.psr_exit_link_training_required = 0x1;\n\t\tpsr_config.psr_frame_capture_indication_req = 0;\n\t\tpsr_config.psr_rfb_setup_time = 0x37;\n\t\tpsr_config.psr_sdp_transmit_line_num_deadline = 0x20;\n\t\tpsr_config.allow_smu_optimizations = 0x0;\n\n\t\tret = dc_link_setup_psr(link, stream, &psr_config, &psr_context);\n\n\t}\n\tDRM_DEBUG_DRIVER(\"PSR link: %d\\n\",\tlink->psr_settings.psr_feature_enabled);\n\n\treturn ret;\n}\n\n/*\n * amdgpu_dm_psr_enable() - enable psr f/w\n * @stream: stream state\n *\n * Return: true if success\n */\nbool amdgpu_dm_psr_enable(struct dc_stream_state *stream)\n{\n\tstruct dc_link *link = stream->link;\n\tunsigned int vsync_rate_hz = 0;\n\tstruct dc_static_screen_params params = {0};\n\t/* Calculate number of static frames before generating interrupt to\n\t * enter PSR.\n\t */\n\t// Init fail safe of 2 frames static\n\tunsigned int num_frames_static = 2;\n\n\tDRM_DEBUG_DRIVER(\"Enabling psr...\\n\");\n\n\tvsync_rate_hz = div64_u64(div64_u64((\n\t\t\tstream->timing.pix_clk_100hz * 100),\n\t\t\tstream->timing.v_total),\n\t\t\tstream->timing.h_total);\n\n\t/* Round up\n\t * Calculate number of frames such that at least 30 ms of time has\n\t * passed.\n\t */\n\tif (vsync_rate_hz != 0) {\n\t\tunsigned int frame_time_microsec = 1000000 / vsync_rate_hz;\n\t\tnum_frames_static = (30000 / frame_time_microsec) + 1;\n\t}\n\n\tparams.triggers.cursor_update = true;\n\tparams.triggers.overlay_update = true;\n\tparams.triggers.surface_update = true;\n\tparams.num_frames = num_frames_static;\n\n\tdc_stream_set_static_screen_params(link->ctx->dc,\n\t\t\t\t\t   &stream, 1,\n\t\t\t\t\t   &params);\n\n\treturn dc_link_set_psr_allow_active(link, true, false, false);\n}\n\n/*\n * amdgpu_dm_psr_disable() - disable psr f/w\n * @stream:  stream state\n *\n * Return: true if success\n */\nstatic bool amdgpu_dm_psr_disable(struct dc_stream_state *stream)\n{\n\n\tDRM_DEBUG_DRIVER(\"Disabling psr...\\n\");\n\n\treturn dc_link_set_psr_allow_active(stream->link, false, true, false);\n}\n\n/*\n * amdgpu_dm_psr_disable() - disable psr f/w\n * if psr is enabled on any stream\n *\n * Return: true if success\n */\nstatic bool amdgpu_dm_psr_disable_all(struct amdgpu_display_manager *dm)\n{\n\tDRM_DEBUG_DRIVER(\"Disabling psr if psr is enabled on any stream\\n\");\n\treturn dc_set_psr_allow_active(dm->dc, false);\n}\n\nvoid amdgpu_dm_trigger_timing_sync(struct drm_device *dev)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct dc *dc = adev->dm.dc;\n\tint i;\n\n\tmutex_lock(&adev->dm.dc_lock);\n\tif (dc->current_state) {\n\t\tfor (i = 0; i < dc->current_state->stream_count; ++i)\n\t\t\tdc->current_state->streams[i]\n\t\t\t\t->triggered_crtc_reset.enabled =\n\t\t\t\tadev->dm.force_timing_sync;\n\n\t\tdm_enable_per_frame_crtc_master_sync(dc->current_state);\n\t\tdc_trigger_sync(dc, dc->current_state);\n\t}\n\tmutex_unlock(&adev->dm.dc_lock);\n}\n\nvoid dm_write_reg_func(const struct dc_context *ctx, uint32_t address,\n\t\t       uint32_t value, const char *func_name)\n{\n#ifdef DM_CHECK_ADDR_0\n\tif (address == 0) {\n\t\tDC_ERR(\"invalid register write. address = 0\");\n\t\treturn;\n\t}\n#endif\n\tcgs_write_register(ctx->cgs_device, address, value);\n\ttrace_amdgpu_dc_wreg(&ctx->perf_trace->write_count, address, value);\n}\n\nuint32_t dm_read_reg_func(const struct dc_context *ctx, uint32_t address,\n\t\t\t  const char *func_name)\n{\n\tuint32_t value;\n#ifdef DM_CHECK_ADDR_0\n\tif (address == 0) {\n\t\tDC_ERR(\"invalid register read; address = 0\\n\");\n\t\treturn 0;\n\t}\n#endif\n\n\tif (ctx->dmub_srv &&\n\t    ctx->dmub_srv->reg_helper_offload.gather_in_progress &&\n\t    !ctx->dmub_srv->reg_helper_offload.should_burst_write) {\n\t\tASSERT(false);\n\t\treturn 0;\n\t}\n\n\tvalue = cgs_read_register(ctx->cgs_device, address);\n\n\ttrace_amdgpu_dc_rreg(&ctx->perf_trace->read_count, address, value);\n\n\treturn value;\n}\n"}}, "reports": [{"events": [{"location": {"col": 16, "file": 0, "line": 8238}, "message": "WARNING: conversion to bool not needed here"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c", "reportHash": "4d3fcef98406f7edd24191cbd19b6645", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 57, "file": 0, "line": 5413}, "message": "WARNING: conversion to bool not needed here"}], "macros": [], "notes": [], "path": "/src/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c", "reportHash": "1f85f9c791df2d1d3ed7cd1c39071660", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
