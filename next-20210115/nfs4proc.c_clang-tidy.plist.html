<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/nfs/nfs4proc.c", "content": "/*\n *  fs/nfs/nfs4proc.c\n *\n *  Client-side procedure declarations for NFSv4.\n *\n *  Copyright (c) 2002 The Regents of the University of Michigan.\n *  All rights reserved.\n *\n *  Kendrick Smith <kmsmith@umich.edu>\n *  Andy Adamson   <andros@umich.edu>\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the University nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED\n *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/xattr.h>\n#include <linux/utsname.h>\n#include <linux/freezer.h>\n#include <linux/iversion.h>\n\n#include \"nfs4_fs.h\"\n#include \"delegation.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"callback.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"sysfs.h\"\n#include \"nfs4idmap.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"nfs42.h\"\n\n#include \"nfs4trace.h\"\n\n#ifdef CONFIG_NFS_V4_2\n#include \"nfs42.h\"\n#endif /* CONFIG_NFS_V4_2 */\n\n#define NFSDBG_FACILITY\t\tNFSDBG_PROC\n\n#define NFS4_BITMASK_SZ\t\t3\n\n#define NFS4_POLL_RETRY_MIN\t(HZ/10)\n#define NFS4_POLL_RETRY_MAX\t(15*HZ)\n\n/* file attributes which can be mapped to nfs attributes */\n#define NFS4_VALID_ATTRS (ATTR_MODE \\\n\t| ATTR_UID \\\n\t| ATTR_GID \\\n\t| ATTR_SIZE \\\n\t| ATTR_ATIME \\\n\t| ATTR_MTIME \\\n\t| ATTR_CTIME \\\n\t| ATTR_ATIME_SET \\\n\t| ATTR_MTIME_SET)\n\nstruct nfs4_opendata;\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data);\nstatic int nfs4_do_fsinfo(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fattr *fattr, struct nfs4_label *label, struct inode *inode);\nstatic int nfs4_do_setattr(struct inode *inode, const struct cred *cred,\n\t\t\t    struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t    struct nfs_open_context *ctx, struct nfs4_label *ilabel,\n\t\t\t    struct nfs4_label *olabel);\n#ifdef CONFIG_NFS_V4_1\nstatic struct rpc_task *_nfs41_proc_sequence(struct nfs_client *clp,\n\t\tconst struct cred *cred,\n\t\tstruct nfs4_slot *slot,\n\t\tbool is_privileged);\nstatic int nfs41_test_stateid(struct nfs_server *, nfs4_stateid *,\n\t\tconst struct cred *);\nstatic int nfs41_free_stateid(struct nfs_server *, const nfs4_stateid *,\n\t\tconst struct cred *, bool);\n#endif\nstatic void nfs4_bitmask_adjust(__u32 *bitmask, struct inode *inode,\n\t\tstruct nfs_server *server,\n\t\tstruct nfs4_label *label);\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic inline struct nfs4_label *\nnfs4_label_init_security(struct inode *dir, struct dentry *dentry,\n\tstruct iattr *sattr, struct nfs4_label *label)\n{\n\tint err;\n\n\tif (label == NULL)\n\t\treturn NULL;\n\n\tif (nfs_server_capable(dir, NFS_CAP_SECURITY_LABEL) == 0)\n\t\treturn NULL;\n\n\terr = security_dentry_init_security(dentry, sattr->ia_mode,\n\t\t\t\t&dentry->d_name, (void **)&label->label, &label->len);\n\tif (err == 0)\n\t\treturn label;\n\n\treturn NULL;\n}\nstatic inline void\nnfs4_label_release_security(struct nfs4_label *label)\n{\n\tif (label)\n\t\tsecurity_release_secctx(label->label, label->len);\n}\nstatic inline u32 *nfs4_bitmask(struct nfs_server *server, struct nfs4_label *label)\n{\n\tif (label)\n\t\treturn server->attr_bitmask;\n\n\treturn server->attr_bitmask_nl;\n}\n#else\nstatic inline struct nfs4_label *\nnfs4_label_init_security(struct inode *dir, struct dentry *dentry,\n\tstruct iattr *sattr, struct nfs4_label *l)\n{ return NULL; }\nstatic inline void\nnfs4_label_release_security(struct nfs4_label *label)\n{ return; }\nstatic inline u32 *\nnfs4_bitmask(struct nfs_server *server, struct nfs4_label *label)\n{ return server->attr_bitmask; }\n#endif\n\n/* Prevent leaks of NFSv4 errors into userland */\nstatic int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\tcase -NFS4ERR_LAYOUTTRYLATER:\n\tcase -NFS4ERR_RECALLCONFLICT:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\tcase -NFS4ERR_WRONG_CRED:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tcase -NFS4ERR_FILE_OPEN:\n\t\treturn -EBUSY;\n\tcase -NFS4ERR_NOT_SAME:\n\t\treturn -ENOTSYNC;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}\n\n/*\n * This is our standard bitmap for GETATTR requests.\n */\nconst u32 nfs4_fattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID,\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\tFATTR4_WORD2_SECURITY_LABEL\n#endif\n};\n\nstatic const u32 nfs4_pnfs_open_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID,\n\tFATTR4_WORD1_MODE\n\t| FATTR4_WORD1_NUMLINKS\n\t| FATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY,\n\tFATTR4_WORD2_MDSTHRESHOLD\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t| FATTR4_WORD2_SECURITY_LABEL\n#endif\n};\n\nstatic const u32 nfs4_open_noattr_bitmap[3] = {\n\tFATTR4_WORD0_TYPE\n\t| FATTR4_WORD0_FILEID,\n};\n\nconst u32 nfs4_statfs_bitmap[3] = {\n\tFATTR4_WORD0_FILES_AVAIL\n\t| FATTR4_WORD0_FILES_FREE\n\t| FATTR4_WORD0_FILES_TOTAL,\n\tFATTR4_WORD1_SPACE_AVAIL\n\t| FATTR4_WORD1_SPACE_FREE\n\t| FATTR4_WORD1_SPACE_TOTAL\n};\n\nconst u32 nfs4_pathconf_bitmap[3] = {\n\tFATTR4_WORD0_MAXLINK\n\t| FATTR4_WORD0_MAXNAME,\n\t0\n};\n\nconst u32 nfs4_fsinfo_bitmap[3] = { FATTR4_WORD0_MAXFILESIZE\n\t\t\t| FATTR4_WORD0_MAXREAD\n\t\t\t| FATTR4_WORD0_MAXWRITE\n\t\t\t| FATTR4_WORD0_LEASE_TIME,\n\t\t\tFATTR4_WORD1_TIME_DELTA\n\t\t\t| FATTR4_WORD1_FS_LAYOUT_TYPES,\n\t\t\tFATTR4_WORD2_LAYOUT_BLKSIZE\n\t\t\t| FATTR4_WORD2_CLONE_BLKSIZE\n\t\t\t| FATTR4_WORD2_XATTR_SUPPORT\n};\n\nconst u32 nfs4_fs_locations_bitmap[3] = {\n\tFATTR4_WORD0_CHANGE\n\t| FATTR4_WORD0_SIZE\n\t| FATTR4_WORD0_FSID\n\t| FATTR4_WORD0_FILEID\n\t| FATTR4_WORD0_FS_LOCATIONS,\n\tFATTR4_WORD1_OWNER\n\t| FATTR4_WORD1_OWNER_GROUP\n\t| FATTR4_WORD1_RAWDEV\n\t| FATTR4_WORD1_SPACE_USED\n\t| FATTR4_WORD1_TIME_ACCESS\n\t| FATTR4_WORD1_TIME_METADATA\n\t| FATTR4_WORD1_TIME_MODIFY\n\t| FATTR4_WORD1_MOUNTED_ON_FILEID,\n};\n\nstatic void nfs4_bitmap_copy_adjust(__u32 *dst, const __u32 *src,\n\t\tstruct inode *inode)\n{\n\tunsigned long cache_validity;\n\n\tmemcpy(dst, src, NFS4_BITMASK_SZ*sizeof(*dst));\n\tif (!inode || !nfs4_have_delegation(inode, FMODE_READ))\n\t\treturn;\n\n\tcache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\tif (!(cache_validity & NFS_INO_REVAL_FORCED))\n\t\tcache_validity &= ~(NFS_INO_INVALID_CHANGE\n\t\t\t\t| NFS_INO_INVALID_SIZE);\n\n\tif (!(cache_validity & NFS_INO_INVALID_SIZE))\n\t\tdst[0] &= ~FATTR4_WORD0_SIZE;\n\n\tif (!(cache_validity & NFS_INO_INVALID_CHANGE))\n\t\tdst[0] &= ~FATTR4_WORD0_CHANGE;\n}\n\nstatic void nfs4_bitmap_copy_adjust_setattr(__u32 *dst,\n\t\tconst __u32 *src, struct inode *inode)\n{\n\tnfs4_bitmap_copy_adjust(dst, src, inode);\n}\n\nstatic void nfs4_setup_readdir(u64 cookie, __be32 *verifier, struct dentry *dentry,\n\t\tstruct nfs4_readdir_arg *readdir)\n{\n\tunsigned int attrs = FATTR4_WORD0_FILEID | FATTR4_WORD0_TYPE;\n\t__be32 *start, *p;\n\n\tif (cookie > 2) {\n\t\treaddir->cookie = cookie;\n\t\tmemcpy(&readdir->verifier, verifier, sizeof(readdir->verifier));\n\t\treturn;\n\t}\n\n\treaddir->cookie = 0;\n\tmemset(&readdir->verifier, 0, sizeof(readdir->verifier));\n\tif (cookie == 2)\n\t\treturn;\n\t\n\t/*\n\t * NFSv4 servers do not return entries for '.' and '..'\n\t * Therefore, we fake these entries here.  We let '.'\n\t * have cookie 0 and '..' have cookie 1.  Note that\n\t * when talking to the server, we always send cookie 0\n\t * instead of 1 or 2.\n\t */\n\tstart = p = kmap_atomic(*readdir->pages);\n\t\n\tif (cookie == 0) {\n\t\t*p++ = xdr_one;                                  /* next */\n\t\t*p++ = xdr_zero;                   /* cookie, first word */\n\t\t*p++ = xdr_one;                   /* cookie, second word */\n\t\t*p++ = xdr_one;                             /* entry len */\n\t\tmemcpy(p, \".\\0\\0\\0\", 4);                        /* entry */\n\t\tp++;\n\t\t*p++ = xdr_one;                         /* bitmap length */\n\t\t*p++ = htonl(attrs);                           /* bitmap */\n\t\t*p++ = htonl(12);             /* attribute buffer length */\n\t\t*p++ = htonl(NF4DIR);\n\t\tp = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry)));\n\t}\n\t\n\t*p++ = xdr_one;                                  /* next */\n\t*p++ = xdr_zero;                   /* cookie, first word */\n\t*p++ = xdr_two;                   /* cookie, second word */\n\t*p++ = xdr_two;                             /* entry len */\n\tmemcpy(p, \"..\\0\\0\", 4);                         /* entry */\n\tp++;\n\t*p++ = xdr_one;                         /* bitmap length */\n\t*p++ = htonl(attrs);                           /* bitmap */\n\t*p++ = htonl(12);             /* attribute buffer length */\n\t*p++ = htonl(NF4DIR);\n\tp = xdr_encode_hyper(p, NFS_FILEID(d_inode(dentry->d_parent)));\n\n\treaddir->pgbase = (char *)p - (char *)start;\n\treaddir->count -= readdir->pgbase;\n\tkunmap_atomic(start);\n}\n\nstatic void nfs4_test_and_free_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tconst struct nfs4_minor_version_ops *ops = server->nfs_client->cl_mvops;\n\n\tops->test_and_free_expired(server, stateid, cred);\n}\n\nstatic void __nfs4_free_revoked_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tstateid->type = NFS4_REVOKED_STATEID_TYPE;\n\tnfs4_test_and_free_stateid(server, stateid, cred);\n}\n\nstatic void nfs4_free_revoked_stateid(struct nfs_server *server,\n\t\tconst nfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tnfs4_stateid tmp;\n\n\tnfs4_stateid_copy(&tmp, stateid);\n\t__nfs4_free_revoked_stateid(server, &tmp, cred);\n}\n\nstatic long nfs4_update_delay(long *timeout)\n{\n\tlong ret;\n\tif (!timeout)\n\t\treturn NFS4_POLL_RETRY_MAX;\n\tif (*timeout <= 0)\n\t\t*timeout = NFS4_POLL_RETRY_MIN;\n\tif (*timeout > NFS4_POLL_RETRY_MAX)\n\t\t*timeout = NFS4_POLL_RETRY_MAX;\n\tret = *timeout;\n\t*timeout <<= 1;\n\treturn ret;\n}\n\nstatic int nfs4_delay_killable(long *timeout)\n{\n\tmight_sleep();\n\n\tfreezable_schedule_timeout_killable_unsafe(\n\t\tnfs4_update_delay(timeout));\n\tif (!__fatal_signal_pending(current))\n\t\treturn 0;\n\treturn -EINTR;\n}\n\nstatic int nfs4_delay_interruptible(long *timeout)\n{\n\tmight_sleep();\n\n\tfreezable_schedule_timeout_interruptible_unsafe(nfs4_update_delay(timeout));\n\tif (!signal_pending(current))\n\t\treturn 0;\n\treturn __fatal_signal_pending(current) ? -EINTR :-ERESTARTSYS;\n}\n\nstatic int nfs4_delay(long *timeout, bool interruptible)\n{\n\tif (interruptible)\n\t\treturn nfs4_delay_interruptible(timeout);\n\treturn nfs4_delay_killable(timeout);\n}\n\nstatic const nfs4_stateid *\nnfs4_recoverable_stateid(const nfs4_stateid *stateid)\n{\n\tif (!stateid)\n\t\treturn NULL;\n\tswitch (stateid->type) {\n\tcase NFS4_OPEN_STATEID_TYPE:\n\tcase NFS4_LOCK_STATEID_TYPE:\n\tcase NFS4_DELEGATION_STATEID_TYPE:\n\t\treturn stateid;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n/* This is the error handling routine for processes that are allowed\n * to sleep.\n */\nstatic int nfs4_do_handle_exception(struct nfs_server *server,\n\t\tint errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_state *state = exception->state;\n\tconst nfs4_stateid *stateid;\n\tstruct inode *inode = exception->inode;\n\tint ret = errorcode;\n\n\texception->delay = 0;\n\texception->recovering = 0;\n\texception->retry = 0;\n\n\tstateid = nfs4_recoverable_stateid(exception->stateid);\n\tif (stateid == NULL && state != NULL)\n\t\tstateid = nfs4_recoverable_stateid(&state->stateid);\n\n\tswitch(errorcode) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase -NFS4ERR_BADHANDLE:\n\t\tcase -ESTALE:\n\t\t\tif (inode != NULL && S_ISREG(inode->i_mode))\n\t\t\t\tpnfs_destroy_layout(NFS_I(inode));\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_PARTNER_NO_AUTH:\n\t\t\tif (inode != NULL && stateid != NULL) {\n\t\t\t\tnfs_inode_find_state_and_recover(inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tgoto wait_on_recovery;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (inode) {\n\t\t\t\tint err;\n\n\t\t\t\terr = nfs_async_inode_return_delegation(inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tgoto wait_on_recovery;\n\t\t\t\tif (stateid != NULL && stateid->type == NFS4_DELEGATION_STATEID_TYPE) {\n\t\t\t\t\texception->retry = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (state == NULL)\n\t\t\t\tbreak;\n\t\t\tret = nfs4_schedule_stateid_recovery(server, state);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\tret = nfs4_schedule_migration_recovery(server);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tgoto wait_on_recovery;\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tnfs4_schedule_lease_moved_recovery(clp);\n\t\t\tgoto wait_on_recovery;\n#if defined(CONFIG_NFS_V4_1)\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\t\t/* Handled in nfs41_sequence_process() */\n\t\t\tgoto wait_on_recovery;\n#endif /* defined(CONFIG_NFS_V4_1) */\n\t\tcase -NFS4ERR_FILE_OPEN:\n\t\t\tif (exception->timeout > HZ) {\n\t\t\t\t/* We have retried a decent amount, time to\n\t\t\t\t * fail\n\t\t\t\t */\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs_inc_server_stats(server, NFSIOS_DELAY);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_LAYOUTTRYLATER:\n\t\tcase -NFS4ERR_RECALLCONFLICT:\n\t\t\texception->delay = 1;\n\t\t\treturn 0;\n\n\t\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\texception->retry = 1;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADOWNER:\n\t\t\t/* The following works around a Linux server bug! */\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\tif (server->caps & NFS_CAP_UIDGID_NOMAP) {\n\t\t\t\tserver->caps &= ~NFS_CAP_UIDGID_NOMAP;\n\t\t\t\texception->retry = 1;\n\t\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\t\"does not accept raw \"\n\t\t\t\t\t\t\"uid/gids. \"\n\t\t\t\t\t\t\"Reenabling the idmapper.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t}\n\t/* We failed to handle the error */\n\treturn nfs4_map_errors(ret);\nwait_on_recovery:\n\texception->recovering = 1;\n\treturn 0;\n}\n\n/* This is the error handling routine for processes that are allowed\n * to sleep.\n */\nint nfs4_handle_exception(struct nfs_server *server, int errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tint ret;\n\n\tret = nfs4_do_handle_exception(server, errorcode, exception);\n\tif (exception->delay) {\n\t\tret = nfs4_delay(&exception->timeout,\n\t\t\t\texception->interruptible);\n\t\tgoto out_retry;\n\t}\n\tif (exception->recovering) {\n\t\tret = nfs4_wait_clnt_recover(clp);\n\t\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\t\treturn -EIO;\n\t\tgoto out_retry;\n\t}\n\treturn ret;\nout_retry:\n\tif (ret == 0)\n\t\texception->retry = 1;\n\treturn ret;\n}\n\nstatic int\nnfs4_async_handle_exception(struct rpc_task *task, struct nfs_server *server,\n\t\tint errorcode, struct nfs4_exception *exception)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tint ret;\n\n\tret = nfs4_do_handle_exception(server, errorcode, exception);\n\tif (exception->delay) {\n\t\trpc_delay(task, nfs4_update_delay(&exception->timeout));\n\t\tgoto out_retry;\n\t}\n\tif (exception->recovering) {\n\t\trpc_sleep_on(&clp->cl_rpcwaitq, task, NULL);\n\t\tif (test_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) == 0)\n\t\t\trpc_wake_up_queued_task(&clp->cl_rpcwaitq, task);\n\t\tgoto out_retry;\n\t}\n\tif (test_bit(NFS_MIG_FAILED, &server->mig_status))\n\t\tret = -EIO;\n\treturn ret;\nout_retry:\n\tif (ret == 0) {\n\t\texception->retry = 1;\n\t\t/*\n\t\t * For NFS4ERR_MOVED, the client transport will need to\n\t\t * be recomputed after migration recovery has completed.\n\t\t */\n\t\tif (errorcode == -NFS4ERR_MOVED)\n\t\t\trpc_task_release_transport(task);\n\t}\n\treturn ret;\n}\n\nint\nnfs4_async_handle_error(struct rpc_task *task, struct nfs_server *server,\n\t\t\tstruct nfs4_state *state, long *timeout)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t};\n\n\tif (task->tk_status >= 0)\n\t\treturn 0;\n\tif (timeout)\n\t\texception.timeout = *timeout;\n\ttask->tk_status = nfs4_async_handle_exception(task, server,\n\t\t\ttask->tk_status,\n\t\t\t&exception);\n\tif (exception.delay && timeout)\n\t\t*timeout = exception.timeout;\n\tif (exception.retry)\n\t\treturn -EAGAIN;\n\treturn 0;\n}\n\n/*\n * Return 'true' if 'clp' is using an rpc_client that is integrity protected\n * or 'false' otherwise.\n */\nstatic bool _nfs4_is_integrity_protected(struct nfs_client *clp)\n{\n\trpc_authflavor_t flavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\treturn (flavor == RPC_AUTH_GSS_KRB5I) || (flavor == RPC_AUTH_GSS_KRB5P);\n}\n\nstatic void do_renew_lease(struct nfs_client *clp, unsigned long timestamp)\n{\n\tspin_lock(&clp->cl_lock);\n\tif (time_before(clp->cl_last_renewal,timestamp))\n\t\tclp->cl_last_renewal = timestamp;\n\tspin_unlock(&clp->cl_lock);\n}\n\nstatic void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_has_session(clp))\n\t\tdo_renew_lease(clp, timestamp);\n}\n\nstruct nfs4_call_sync_data {\n\tconst struct nfs_server *seq_server;\n\tstruct nfs4_sequence_args *seq_args;\n\tstruct nfs4_sequence_res *seq_res;\n};\n\nvoid nfs4_init_sequence(struct nfs4_sequence_args *args,\n\t\t\tstruct nfs4_sequence_res *res, int cache_reply,\n\t\t\tint privileged)\n{\n\targs->sa_slot = NULL;\n\targs->sa_cache_this = cache_reply;\n\targs->sa_privileged = privileged;\n\n\tres->sr_slot = NULL;\n}\n\nstatic void nfs40_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs4_slot_table *tbl;\n\n\ttbl = slot->table;\n\tspin_lock(&tbl->slot_tbl_lock);\n\tif (!nfs41_wake_and_assign_slot(tbl, slot))\n\t\tnfs4_free_slot(tbl, slot);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\tres->sr_slot = NULL;\n}\n\nstatic int nfs40_sequence_done(struct rpc_task *task,\n\t\t\t       struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot != NULL)\n\t\tnfs40_sequence_free_slot(res);\n\treturn 1;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\nstatic void nfs41_release_slot(struct nfs4_slot *slot)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot_table *tbl;\n\tbool send_new_highest_used_slotid = false;\n\n\tif (!slot)\n\t\treturn;\n\ttbl = slot->table;\n\tsession = tbl->session;\n\n\t/* Bump the slot sequence number */\n\tif (slot->seq_done)\n\t\tslot->seq_nr++;\n\tslot->seq_done = 0;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/* Be nice to the server: try to ensure that the last transmitted\n\t * value for highest_user_slotid <= target_highest_slotid\n\t */\n\tif (tbl->highest_used_slotid > tbl->target_highest_slotid)\n\t\tsend_new_highest_used_slotid = true;\n\n\tif (nfs41_wake_and_assign_slot(tbl, slot)) {\n\t\tsend_new_highest_used_slotid = false;\n\t\tgoto out_unlock;\n\t}\n\tnfs4_free_slot(tbl, slot);\n\n\tif (tbl->highest_used_slotid != NFS4_NO_SLOT)\n\t\tsend_new_highest_used_slotid = false;\nout_unlock:\n\tspin_unlock(&tbl->slot_tbl_lock);\n\tif (send_new_highest_used_slotid)\n\t\tnfs41_notify_server(session->clp);\n\tif (waitqueue_active(&tbl->slot_waitq))\n\t\twake_up_all(&tbl->slot_waitq);\n}\n\nstatic void nfs41_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tnfs41_release_slot(res->sr_slot);\n\tres->sr_slot = NULL;\n}\n\nstatic void nfs4_slot_sequence_record_sent(struct nfs4_slot *slot,\n\t\tu32 seqnr)\n{\n\tif ((s32)(seqnr - slot->seq_nr_highest_sent) > 0)\n\t\tslot->seq_nr_highest_sent = seqnr;\n}\nstatic void nfs4_slot_sequence_acked(struct nfs4_slot *slot,\n\t\tu32 seqnr)\n{\n\tslot->seq_nr_highest_sent = seqnr;\n\tslot->seq_nr_last_acked = seqnr;\n}\n\nstatic void nfs4_probe_sequence(struct nfs_client *client, const struct cred *cred,\n\t\t\t\tstruct nfs4_slot *slot)\n{\n\tstruct rpc_task *task = _nfs41_proc_sequence(client, cred, slot, true);\n\tif (!IS_ERR(task))\n\t\trpc_put_task_async(task);\n}\n\nstatic int nfs41_sequence_process(struct rpc_task *task,\n\t\tstruct nfs4_sequence_res *res)\n{\n\tstruct nfs4_session *session;\n\tstruct nfs4_slot *slot = res->sr_slot;\n\tstruct nfs_client *clp;\n\tint status;\n\tint ret = 1;\n\n\tif (slot == NULL)\n\t\tgoto out_noaction;\n\t/* don't increment the sequence number if the task wasn't sent */\n\tif (!RPC_WAS_SENT(task) || slot->seq_done)\n\t\tgoto out;\n\n\tsession = slot->table->session;\n\tclp = session->clp;\n\n\ttrace_nfs4_sequence_done(session, res);\n\n\tstatus = res->sr_status;\n\tif (task->tk_status == -NFS4ERR_DEADSESSION)\n\t\tstatus = -NFS4ERR_DEADSESSION;\n\n\t/* Check the SEQUENCE operation status */\n\tswitch (status) {\n\tcase 0:\n\t\t/* Mark this sequence number as having been acked */\n\t\tnfs4_slot_sequence_acked(slot, slot->seq_nr);\n\t\t/* Update the slot's sequence and clientid lease timer */\n\t\tslot->seq_done = 1;\n\t\tdo_renew_lease(clp, res->sr_timestamp);\n\t\t/* Check sequence flags */\n\t\tnfs41_handle_sequence_flag_errors(clp, res->sr_status_flags,\n\t\t\t\t!!slot->privileged);\n\t\tnfs41_update_target_slotid(slot->table, slot, res);\n\t\tbreak;\n\tcase 1:\n\t\t/*\n\t\t * sr_status remains 1 if an RPC level error occurred.\n\t\t * The server may or may not have processed the sequence\n\t\t * operation..\n\t\t */\n\t\tnfs4_slot_sequence_record_sent(slot, slot->seq_nr);\n\t\tslot->seq_done = 1;\n\t\tgoto out;\n\tcase -NFS4ERR_DELAY:\n\t\t/* The server detected a resend of the RPC call and\n\t\t * returned NFS4ERR_DELAY as per Section 2.10.6.2\n\t\t * of RFC5661.\n\t\t */\n\t\tdprintk(\"%s: slot=%u seq=%u: Operation in progress\\n\",\n\t\t\t__func__,\n\t\t\tslot->slot_nr,\n\t\t\tslot->seq_nr);\n\t\tnfs4_slot_sequence_acked(slot, slot->seq_nr);\n\t\tgoto out_retry;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\tcase -NFS4ERR_SEQ_FALSE_RETRY:\n\t\t/*\n\t\t * The server thinks we tried to replay a request.\n\t\t * Retry the call after bumping the sequence ID.\n\t\t */\n\t\tnfs4_slot_sequence_acked(slot, slot->seq_nr);\n\t\tgoto retry_new_seq;\n\tcase -NFS4ERR_BADSLOT:\n\t\t/*\n\t\t * The slot id we used was probably retired. Try again\n\t\t * using a different slot id.\n\t\t */\n\t\tif (slot->slot_nr < slot->table->target_highest_slotid)\n\t\t\tgoto session_recover;\n\t\tgoto retry_nowait;\n\tcase -NFS4ERR_SEQ_MISORDERED:\n\t\tnfs4_slot_sequence_record_sent(slot, slot->seq_nr);\n\t\t/*\n\t\t * Were one or more calls using this slot interrupted?\n\t\t * If the server never received the request, then our\n\t\t * transmitted slot sequence number may be too high. However,\n\t\t * if the server did receive the request then it might\n\t\t * accidentally give us a reply with a mismatched operation.\n\t\t * We can sort this out by sending a lone sequence operation\n\t\t * to the server on the same slot.\n\t\t */\n\t\tif ((s32)(slot->seq_nr - slot->seq_nr_last_acked) > 1) {\n\t\t\tslot->seq_nr--;\n\t\t\tif (task->tk_msg.rpc_proc != &nfs4_procedures[NFSPROC4_CLNT_SEQUENCE]) {\n\t\t\t\tnfs4_probe_sequence(clp, task->tk_msg.rpc_cred, slot);\n\t\t\t\tres->sr_slot = NULL;\n\t\t\t}\n\t\t\tgoto retry_nowait;\n\t\t}\n\t\t/*\n\t\t * RFC5661:\n\t\t * A retry might be sent while the original request is\n\t\t * still in progress on the replier. The replier SHOULD\n\t\t * deal with the issue by returning NFS4ERR_DELAY as the\n\t\t * reply to SEQUENCE or CB_SEQUENCE operation, but\n\t\t * implementations MAY return NFS4ERR_SEQ_MISORDERED.\n\t\t *\n\t\t * Restart the search after a delay.\n\t\t */\n\t\tslot->seq_nr = slot->seq_nr_highest_sent;\n\t\tgoto out_retry;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tgoto session_recover;\n\tdefault:\n\t\t/* Just update the slot sequence no. */\n\t\tslot->seq_done = 1;\n\t}\nout:\n\t/* The session may be reset by one of the error handlers. */\n\tdprintk(\"%s: Error %d free the slot \\n\", __func__, res->sr_status);\nout_noaction:\n\treturn ret;\nsession_recover:\n\tnfs4_schedule_session_recovery(session, status);\n\tdprintk(\"%s ERROR: %d Reset session\\n\", __func__, status);\n\tnfs41_sequence_free_slot(res);\n\tgoto out;\nretry_new_seq:\n\t++slot->seq_nr;\nretry_nowait:\n\tif (rpc_restart_call_prepare(task)) {\n\t\tnfs41_sequence_free_slot(res);\n\t\ttask->tk_status = 0;\n\t\tret = 0;\n\t}\n\tgoto out;\nout_retry:\n\tif (!rpc_restart_call(task))\n\t\tgoto out;\n\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\treturn 0;\n}\n\nint nfs41_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tif (!nfs41_sequence_process(task, res))\n\t\treturn 0;\n\tif (res->sr_slot != NULL)\n\t\tnfs41_sequence_free_slot(res);\n\treturn 1;\n\n}\nEXPORT_SYMBOL_GPL(nfs41_sequence_done);\n\nstatic int nfs4_sequence_process(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot == NULL)\n\t\treturn 1;\n\tif (res->sr_slot->table->session != NULL)\n\t\treturn nfs41_sequence_process(task, res);\n\treturn nfs40_sequence_done(task, res);\n}\n\nstatic void nfs4_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot != NULL) {\n\t\tif (res->sr_slot->table->session != NULL)\n\t\t\tnfs41_sequence_free_slot(res);\n\t\telse\n\t\t\tnfs40_sequence_free_slot(res);\n\t}\n}\n\nint nfs4_sequence_done(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot == NULL)\n\t\treturn 1;\n\tif (!res->sr_slot->table->session)\n\t\treturn nfs40_sequence_done(task, res);\n\treturn nfs41_sequence_done(task, res);\n}\nEXPORT_SYMBOL_GPL(nfs4_sequence_done);\n\nstatic void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tnfs4_setup_sequence(data->seq_server->nfs_client,\n\t\t\t    data->seq_args, data->seq_res, task);\n}\n\nstatic void nfs41_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\n\tnfs41_sequence_done(task, data->seq_res);\n}\n\nstatic const struct rpc_call_ops nfs41_call_sync_ops = {\n\t.rpc_call_prepare = nfs41_call_sync_prepare,\n\t.rpc_call_done = nfs41_call_sync_done,\n};\n\n#else\t/* !CONFIG_NFS_V4_1 */\n\nstatic int nfs4_sequence_process(struct rpc_task *task, struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}\n\nstatic void nfs4_sequence_free_slot(struct nfs4_sequence_res *res)\n{\n\tif (res->sr_slot != NULL)\n\t\tnfs40_sequence_free_slot(res);\n}\n\nint nfs4_sequence_done(struct rpc_task *task,\n\t\t       struct nfs4_sequence_res *res)\n{\n\treturn nfs40_sequence_done(task, res);\n}\nEXPORT_SYMBOL_GPL(nfs4_sequence_done);\n\n#endif\t/* !CONFIG_NFS_V4_1 */\n\nstatic void nfs41_sequence_res_init(struct nfs4_sequence_res *res)\n{\n\tres->sr_timestamp = jiffies;\n\tres->sr_status_flags = 0;\n\tres->sr_status = 1;\n}\n\nstatic\nvoid nfs4_sequence_attach_slot(struct nfs4_sequence_args *args,\n\t\tstruct nfs4_sequence_res *res,\n\t\tstruct nfs4_slot *slot)\n{\n\tif (!slot)\n\t\treturn;\n\tslot->privileged = args->sa_privileged ? 1 : 0;\n\targs->sa_slot = slot;\n\n\tres->sr_slot = slot;\n}\n\nint nfs4_setup_sequence(struct nfs_client *client,\n\t\t\tstruct nfs4_sequence_args *args,\n\t\t\tstruct nfs4_sequence_res *res,\n\t\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_session *session = nfs4_get_session(client);\n\tstruct nfs4_slot_table *tbl  = client->cl_slot_tbl;\n\tstruct nfs4_slot *slot;\n\n\t/* slot already allocated? */\n\tif (res->sr_slot != NULL)\n\t\tgoto out_start;\n\n\tif (session)\n\t\ttbl = &session->fc_slot_table;\n\n\tspin_lock(&tbl->slot_tbl_lock);\n\t/* The state manager will wait until the slot table is empty */\n\tif (nfs4_slot_tbl_draining(tbl) && !args->sa_privileged)\n\t\tgoto out_sleep;\n\n\tslot = nfs4_alloc_slot(tbl);\n\tif (IS_ERR(slot)) {\n\t\tif (slot == ERR_PTR(-ENOMEM))\n\t\t\tgoto out_sleep_timeout;\n\t\tgoto out_sleep;\n\t}\n\tspin_unlock(&tbl->slot_tbl_lock);\n\n\tnfs4_sequence_attach_slot(args, res, slot);\n\n\ttrace_nfs4_setup_sequence(session, args);\nout_start:\n\tnfs41_sequence_res_init(res);\n\trpc_call_start(task);\n\treturn 0;\nout_sleep_timeout:\n\t/* Try again in 1/4 second */\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority_timeout(&tbl->slot_tbl_waitq, task,\n\t\t\t\tjiffies + (HZ >> 2), RPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on_timeout(&tbl->slot_tbl_waitq, task,\n\t\t\t\tNULL, jiffies + (HZ >> 2));\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\nout_sleep:\n\tif (args->sa_privileged)\n\t\trpc_sleep_on_priority(&tbl->slot_tbl_waitq, task,\n\t\t\t\tRPC_PRIORITY_PRIVILEGED);\n\telse\n\t\trpc_sleep_on(&tbl->slot_tbl_waitq, task, NULL);\n\tspin_unlock(&tbl->slot_tbl_lock);\n\treturn -EAGAIN;\n}\nEXPORT_SYMBOL_GPL(nfs4_setup_sequence);\n\nstatic void nfs40_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\tnfs4_setup_sequence(data->seq_server->nfs_client,\n\t\t\t\tdata->seq_args, data->seq_res, task);\n}\n\nstatic void nfs40_call_sync_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_call_sync_data *data = calldata;\n\tnfs4_sequence_done(task, data->seq_res);\n}\n\nstatic const struct rpc_call_ops nfs40_call_sync_ops = {\n\t.rpc_call_prepare = nfs40_call_sync_prepare,\n\t.rpc_call_done = nfs40_call_sync_done,\n};\n\nstatic int nfs4_call_sync_custom(struct rpc_task_setup *task_setup)\n{\n\tint ret;\n\tstruct rpc_task *task;\n\n\ttask = rpc_run_task(task_setup);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\tret = task->tk_status;\n\trpc_put_task(task);\n\treturn ret;\n}\n\nstatic int nfs4_do_call_sync(struct rpc_clnt *clnt,\n\t\t\t     struct nfs_server *server,\n\t\t\t     struct rpc_message *msg,\n\t\t\t     struct nfs4_sequence_args *args,\n\t\t\t     struct nfs4_sequence_res *res,\n\t\t\t     unsigned short task_flags)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = args,\n\t\t.seq_res = res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = msg,\n\t\t.callback_ops = clp->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = task_flags,\n\t};\n\n\treturn nfs4_call_sync_custom(&task_setup);\n}\n\nstatic int nfs4_call_sync_sequence(struct rpc_clnt *clnt,\n\t\t\t\t   struct nfs_server *server,\n\t\t\t\t   struct rpc_message *msg,\n\t\t\t\t   struct nfs4_sequence_args *args,\n\t\t\t\t   struct nfs4_sequence_res *res)\n{\n\treturn nfs4_do_call_sync(clnt, server, msg, args, res, 0);\n}\n\n\nint nfs4_call_sync(struct rpc_clnt *clnt,\n\t\t   struct nfs_server *server,\n\t\t   struct rpc_message *msg,\n\t\t   struct nfs4_sequence_args *args,\n\t\t   struct nfs4_sequence_res *res,\n\t\t   int cache_reply)\n{\n\tnfs4_init_sequence(args, res, cache_reply, 0);\n\treturn nfs4_call_sync_sequence(clnt, server, msg, args, res);\n}\n\nstatic void\nnfs4_inc_nlink_locked(struct inode *inode)\n{\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_OTHER;\n\tinc_nlink(inode);\n}\n\nstatic void\nnfs4_dec_nlink_locked(struct inode *inode)\n{\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_OTHER;\n\tdrop_nlink(inode);\n}\n\nstatic void\nnfs4_update_changeattr_locked(struct inode *inode,\n\t\tstruct nfs4_change_info *cinfo,\n\t\tunsigned long timestamp, unsigned long cache_validity)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tnfsi->cache_validity |= NFS_INO_INVALID_CTIME\n\t\t| NFS_INO_INVALID_MTIME\n\t\t| cache_validity;\n\n\tif (cinfo->atomic && cinfo->before == inode_peek_iversion_raw(inode)) {\n\t\tnfsi->cache_validity &= ~NFS_INO_REVAL_PAGECACHE;\n\t\tnfsi->attrtimeo_timestamp = jiffies;\n\t} else {\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tnfsi->cache_validity |= NFS_INO_INVALID_DATA;\n\t\t\tnfs_force_lookup_revalidate(inode);\n\t\t} else {\n\t\t\tif (!NFS_PROTO(inode)->have_delegation(inode,\n\t\t\t\t\t\t\t       FMODE_READ))\n\t\t\t\tnfsi->cache_validity |= NFS_INO_REVAL_PAGECACHE;\n\t\t}\n\n\t\tif (cinfo->before != inode_peek_iversion_raw(inode))\n\t\t\tnfsi->cache_validity |= NFS_INO_INVALID_ACCESS |\n\t\t\t\t\t\tNFS_INO_INVALID_ACL |\n\t\t\t\t\t\tNFS_INO_INVALID_XATTR;\n\t}\n\tinode_set_iversion_raw(inode, cinfo->after);\n\tnfsi->read_cache_jiffies = timestamp;\n\tnfsi->attr_gencount = nfs_inc_attr_generation_counter();\n\tnfsi->cache_validity &= ~NFS_INO_INVALID_CHANGE;\n\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\tnfs_fscache_invalidate(inode);\n}\n\nvoid\nnfs4_update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo,\n\t\tunsigned long timestamp, unsigned long cache_validity)\n{\n\tspin_lock(&dir->i_lock);\n\tnfs4_update_changeattr_locked(dir, cinfo, timestamp, cache_validity);\n\tspin_unlock(&dir->i_lock);\n}\n\nstruct nfs4_open_createattrs {\n\tstruct nfs4_label *label;\n\tstruct iattr *sattr;\n\tconst __u32 verf[2];\n};\n\nstatic bool nfs4_clear_cap_atomic_open_v1(struct nfs_server *server,\n\t\tint err, struct nfs4_exception *exception)\n{\n\tif (err != -EINVAL)\n\t\treturn false;\n\tif (!(server->caps & NFS_CAP_ATOMIC_OPEN_V1))\n\t\treturn false;\n\tserver->caps &= ~NFS_CAP_ATOMIC_OPEN_V1;\n\texception->retry = 1;\n\treturn true;\n}\n\nstatic fmode_t _nfs4_ctx_to_accessmode(const struct nfs_open_context *ctx)\n{\n\t return ctx->mode & (FMODE_READ|FMODE_WRITE|FMODE_EXEC);\n}\n\nstatic fmode_t _nfs4_ctx_to_openmode(const struct nfs_open_context *ctx)\n{\n\tfmode_t ret = ctx->mode & (FMODE_READ|FMODE_WRITE);\n\n\treturn (ctx->mode & FMODE_EXEC) ? FMODE_READ | ret : ret;\n}\n\nstatic u32\nnfs4_map_atomic_open_share(struct nfs_server *server,\n\t\tfmode_t fmode, int openflags)\n{\n\tu32 res = 0;\n\n\tswitch (fmode & (FMODE_READ | FMODE_WRITE)) {\n\tcase FMODE_READ:\n\t\tres = NFS4_SHARE_ACCESS_READ;\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\tres = NFS4_SHARE_ACCESS_WRITE;\n\t\tbreak;\n\tcase FMODE_READ|FMODE_WRITE:\n\t\tres = NFS4_SHARE_ACCESS_BOTH;\n\t}\n\tif (!(server->caps & NFS_CAP_ATOMIC_OPEN_V1))\n\t\tgoto out;\n\t/* Want no delegation if we're using O_DIRECT */\n\tif (openflags & O_DIRECT)\n\t\tres |= NFS4_SHARE_WANT_NO_DELEG;\nout:\n\treturn res;\n}\n\nstatic enum open_claim_type4\nnfs4_map_atomic_open_claim(struct nfs_server *server,\n\t\tenum open_claim_type4 claim)\n{\n\tif (server->caps & NFS_CAP_ATOMIC_OPEN_V1)\n\t\treturn claim;\n\tswitch (claim) {\n\tdefault:\n\t\treturn claim;\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\treturn NFS4_OPEN_CLAIM_NULL;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\treturn NFS4_OPEN_CLAIM_DELEGATE_CUR;\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\treturn NFS4_OPEN_CLAIM_DELEGATE_PREV;\n\t}\n}\n\nstatic void nfs4_init_opendata_res(struct nfs4_opendata *p)\n{\n\tp->o_res.f_attr = &p->f_attr;\n\tp->o_res.f_label = p->f_label;\n\tp->o_res.seqid = p->o_arg.seqid;\n\tp->c_res.seqid = p->c_arg.seqid;\n\tp->o_res.server = p->o_arg.server;\n\tp->o_res.access_request = p->o_arg.access;\n\tnfs_fattr_init(&p->f_attr);\n\tnfs_fattr_init_names(&p->f_attr, &p->owner_name, &p->group_name);\n}\n\nstatic struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,\n\t\tstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\n\t\tconst struct nfs4_open_createattrs *c,\n\t\tenum open_claim_type4 claim,\n\t\tgfp_t gfp_mask)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = d_inode(parent);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_label *label = (c != NULL) ? c->label : NULL;\n\tstruct nfs4_opendata *p;\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\tgoto err;\n\n\tp->f_label = nfs4_label_alloc(server, gfp_mask);\n\tif (IS_ERR(p->f_label))\n\t\tgoto err_free_p;\n\n\tp->a_label = nfs4_label_alloc(server, gfp_mask);\n\tif (IS_ERR(p->a_label))\n\t\tgoto err_free_f;\n\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->o_arg.seqid = alloc_seqid(&sp->so_seqid, gfp_mask);\n\tif (IS_ERR(p->o_arg.seqid))\n\t\tgoto err_free_label;\n\tnfs_sb_active(dentry->d_sb);\n\tp->dentry = dget(dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\tp->o_arg.claim = nfs4_map_atomic_open_claim(server, claim);\n\tp->o_arg.share_access = nfs4_map_atomic_open_share(server,\n\t\t\tfmode, flags);\n\tif (flags & O_CREAT) {\n\t\tp->o_arg.umask = current_umask();\n\t\tp->o_arg.label = nfs4_label_copy(p->a_label, label);\n\t\tif (c->sattr != NULL && c->sattr->ia_valid != 0) {\n\t\t\tp->o_arg.u.attrs = &p->attrs;\n\t\t\tmemcpy(&p->attrs, c->sattr, sizeof(p->attrs));\n\n\t\t\tmemcpy(p->o_arg.u.verifier.data, c->verf,\n\t\t\t\t\tsizeof(p->o_arg.u.verifier.data));\n\t\t}\n\t}\n\t/* don't put an ACCESS op in OPEN compound if O_EXCL, because ACCESS\n\t * will return permission denied for all bits until close */\n\tif (!(flags & O_EXCL)) {\n\t\t/* ask server to check for all possible rights as results\n\t\t * are cached */\n\t\tswitch (p->o_arg.claim) {\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\tp->o_arg.access = NFS4_ACCESS_READ |\n\t\t\t\tNFS4_ACCESS_MODIFY |\n\t\t\t\tNFS4_ACCESS_EXTEND |\n\t\t\t\tNFS4_ACCESS_EXECUTE;\n#ifdef CONFIG_NFS_V4_2\n\t\t\tif (server->caps & NFS_CAP_XATTR)\n\t\t\t\tp->o_arg.access |= NFS4_ACCESS_XAREAD |\n\t\t\t\t    NFS4_ACCESS_XAWRITE |\n\t\t\t\t    NFS4_ACCESS_XALIST;\n#endif\n\t\t}\n\t}\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id.create_time = ktime_to_ns(sp->so_seqid.create_time);\n\tp->o_arg.id.uniquifier = sp->so_seqid.owner_id;\n\tp->o_arg.name = &dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = nfs4_bitmask(server, label);\n\tp->o_arg.open_bitmap = &nfs4_fattr_bitmap[0];\n\tswitch (p->o_arg.claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tp->o_arg.fh = NFS_FH(dir);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tp->o_arg.fh = NFS_FH(d_inode(dentry));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\n\nerr_free_label:\n\tnfs4_label_free(p->a_label);\nerr_free_f:\n\tnfs4_label_free(p->f_label);\nerr_free_p:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}\n\nstatic void nfs4_opendata_free(struct kref *kref)\n{\n\tstruct nfs4_opendata *p = container_of(kref,\n\t\t\tstruct nfs4_opendata, kref);\n\tstruct super_block *sb = p->dentry->d_sb;\n\n\tnfs4_lgopen_release(p->lgp);\n\tnfs_free_seqid(p->o_arg.seqid);\n\tnfs4_sequence_free_slot(&p->o_res.seq_res);\n\tif (p->state != NULL)\n\t\tnfs4_put_open_state(p->state);\n\tnfs4_put_state_owner(p->owner);\n\n\tnfs4_label_free(p->a_label);\n\tnfs4_label_free(p->f_label);\n\n\tdput(p->dir);\n\tdput(p->dentry);\n\tnfs_sb_deactive(sb);\n\tnfs_fattr_free_names(&p->f_attr);\n\tkfree(p->f_attr.mdsthreshold);\n\tkfree(p);\n}\n\nstatic void nfs4_opendata_put(struct nfs4_opendata *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, nfs4_opendata_free);\n}\n\nstatic bool nfs4_mode_match_open_stateid(struct nfs4_state *state,\n\t\tfmode_t fmode)\n{\n\tswitch(fmode & (FMODE_READ|FMODE_WRITE)) {\n\tcase FMODE_READ|FMODE_WRITE:\n\t\treturn state->n_rdwr != 0;\n\tcase FMODE_WRITE:\n\t\treturn state->n_wronly != 0;\n\tcase FMODE_READ:\n\t\treturn state->n_rdonly != 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nstatic int can_open_cached(struct nfs4_state *state, fmode_t mode,\n\t\tint open_mode, enum open_claim_type4 claim)\n{\n\tint ret = 0;\n\n\tif (open_mode & (O_EXCL|O_TRUNC))\n\t\tgoto out;\n\tswitch (claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tgoto out;\n\tdefault:\n\t\tbreak;\n\t}\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdonly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_wronly != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0\n\t\t\t\t&& state->n_rdwr != 0;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode,\n\t\tenum open_claim_type4 claim)\n{\n\tif (delegation == NULL)\n\t\treturn 0;\n\tif ((delegation->type & fmode) != fmode)\n\t\treturn 0;\n\tswitch (claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tif (!test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}\n\nstatic void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)\n{\n\tswitch (fmode) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | fmode);\n}\n\n#ifdef CONFIG_NFS_V4_1\nstatic bool nfs_open_stateid_recover_openmode(struct nfs4_state *state)\n{\n\tif (state->n_rdonly && !test_bit(NFS_O_RDONLY_STATE, &state->flags))\n\t\treturn true;\n\tif (state->n_wronly && !test_bit(NFS_O_WRONLY_STATE, &state->flags))\n\t\treturn true;\n\tif (state->n_rdwr && !test_bit(NFS_O_RDWR_STATE, &state->flags))\n\t\treturn true;\n\treturn false;\n}\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic void nfs_state_log_update_open_stateid(struct nfs4_state *state)\n{\n\tif (test_and_clear_bit(NFS_STATE_CHANGE_WAIT, &state->flags))\n\t\twake_up_all(&state->waitq);\n}\n\nstatic void nfs_test_and_clear_all_open_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = state->owner->so_server->nfs_client;\n\tbool need_recover = false;\n\n\tif (test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags) && state->n_rdonly)\n\t\tneed_recover = true;\n\tif (test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags) && state->n_wronly)\n\t\tneed_recover = true;\n\tif (test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags) && state->n_rdwr)\n\t\tneed_recover = true;\n\tif (need_recover)\n\t\tnfs4_state_mark_reclaim_nograce(clp, state);\n}\n\n/*\n * Check for whether or not the caller may update the open stateid\n * to the value passed in by stateid.\n *\n * Note: This function relies heavily on the server implementing\n * RFC7530 Section 9.1.4.2, and RFC5661 Section 8.2.2\n * correctly.\n * i.e. The stateid seqids have to be initialised to 1, and\n * are then incremented on every state transition.\n */\nstatic bool nfs_stateid_is_sequential(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\tif (test_bit(NFS_OPEN_STATE, &state->flags)) {\n\t\t/* The common case - we're updating to a new sequence number */\n\t\tif (nfs4_stateid_match_other(stateid, &state->open_stateid) &&\n\t\t\tnfs4_stateid_is_next(&state->open_stateid, stateid)) {\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t/* This is the first OPEN in this generation */\n\t\tif (stateid->seqid == cpu_to_be32(1))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void nfs_resync_open_stateid_locked(struct nfs4_state *state)\n{\n\tif (!(state->n_wronly || state->n_rdonly || state->n_rdwr))\n\t\treturn;\n\tif (state->n_wronly)\n\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tif (state->n_rdonly)\n\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tif (state->n_rdwr)\n\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\tset_bit(NFS_OPEN_STATE, &state->flags);\n}\n\nstatic void nfs_clear_open_stateid_locked(struct nfs4_state *state,\n\t\tnfs4_stateid *stateid, fmode_t fmode)\n{\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tswitch (fmode & (FMODE_READ|FMODE_WRITE)) {\n\tcase FMODE_WRITE:\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase FMODE_READ:\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase 0:\n\t\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tclear_bit(NFS_OPEN_STATE, &state->flags);\n\t}\n\tif (stateid == NULL)\n\t\treturn;\n\t/* Handle OPEN+OPEN_DOWNGRADE races */\n\tif (nfs4_stateid_match_other(stateid, &state->open_stateid) &&\n\t    !nfs4_stateid_is_newer(stateid, &state->open_stateid)) {\n\t\tnfs_resync_open_stateid_locked(state);\n\t\tgoto out;\n\t}\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tnfs4_stateid_copy(&state->stateid, stateid);\n\tnfs4_stateid_copy(&state->open_stateid, stateid);\n\ttrace_nfs4_open_stateid_update(state->inode, stateid, 0);\nout:\n\tnfs_state_log_update_open_stateid(state);\n}\n\nstatic void nfs_clear_open_stateid(struct nfs4_state *state,\n\tnfs4_stateid *arg_stateid,\n\tnfs4_stateid *stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\t/* Ignore, if the CLOSE argment doesn't match the current stateid */\n\tif (nfs4_state_match_open_stateid_other(state, arg_stateid))\n\t\tnfs_clear_open_stateid_locked(state, stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags))\n\t\tnfs4_schedule_state_manager(state->owner->so_server->nfs_client);\n}\n\nstatic void nfs_set_open_stateid_locked(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid, nfs4_stateid *freeme)\n\t__must_hold(&state->owner->so_lock)\n\t__must_hold(&state->seqlock)\n\t__must_hold(RCU)\n\n{\n\tDEFINE_WAIT(wait);\n\tint status = 0;\n\tfor (;;) {\n\n\t\tif (nfs_stateid_is_sequential(state, stateid))\n\t\t\tbreak;\n\n\t\tif (status)\n\t\t\tbreak;\n\t\t/* Rely on seqids for serialisation with NFSv4.0 */\n\t\tif (!nfs4_has_session(NFS_SERVER(state->inode)->nfs_client))\n\t\t\tbreak;\n\n\t\tset_bit(NFS_STATE_CHANGE_WAIT, &state->flags);\n\t\tprepare_to_wait(&state->waitq, &wait, TASK_KILLABLE);\n\t\t/*\n\t\t * Ensure we process the state changes in the same order\n\t\t * in which the server processed them by delaying the\n\t\t * update of the stateid until we are in sequence.\n\t\t */\n\t\twrite_sequnlock(&state->seqlock);\n\t\tspin_unlock(&state->owner->so_lock);\n\t\trcu_read_unlock();\n\t\ttrace_nfs4_open_stateid_update_wait(state->inode, stateid, 0);\n\n\t\tif (!signal_pending(current)) {\n\t\t\tif (schedule_timeout(5*HZ) == 0)\n\t\t\t\tstatus = -EAGAIN;\n\t\t\telse\n\t\t\t\tstatus = 0;\n\t\t} else\n\t\t\tstatus = -EINTR;\n\t\tfinish_wait(&state->waitq, &wait);\n\t\trcu_read_lock();\n\t\tspin_lock(&state->owner->so_lock);\n\t\twrite_seqlock(&state->seqlock);\n\t}\n\n\tif (test_bit(NFS_OPEN_STATE, &state->flags) &&\n\t    !nfs4_stateid_match_other(stateid, &state->open_stateid)) {\n\t\tnfs4_stateid_copy(freeme, &state->open_stateid);\n\t\tnfs_test_and_clear_all_open_stateid(state);\n\t}\n\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tnfs4_stateid_copy(&state->stateid, stateid);\n\tnfs4_stateid_copy(&state->open_stateid, stateid);\n\ttrace_nfs4_open_stateid_update(state->inode, stateid, status);\n\tnfs_state_log_update_open_stateid(state);\n}\n\nstatic void nfs_state_set_open_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *open_stateid,\n\t\tfmode_t fmode,\n\t\tnfs4_stateid *freeme)\n{\n\t/*\n\t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, open_stateid, freeme);\n\tswitch (fmode) {\n\tcase FMODE_READ:\n\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase FMODE_WRITE:\n\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\tbreak;\n\tcase FMODE_READ|FMODE_WRITE:\n\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n\tset_bit(NFS_OPEN_STATE, &state->flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void nfs_state_clear_open_state_flags(struct nfs4_state *state)\n{\n\tclear_bit(NFS_O_RDWR_STATE, &state->flags);\n\tclear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\tclear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tclear_bit(NFS_OPEN_STATE, &state->flags);\n}\n\nstatic void nfs_state_set_delegation(struct nfs4_state *state,\n\t\tconst nfs4_stateid *deleg_stateid,\n\t\tfmode_t fmode)\n{\n\t/*\n\t * Protect the call to nfs4_state_set_mode_locked and\n\t * serialise the stateid update\n\t */\n\twrite_seqlock(&state->seqlock);\n\tnfs4_stateid_copy(&state->stateid, deleg_stateid);\n\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nstatic void nfs_state_clear_delegation(struct nfs4_state *state)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\twrite_sequnlock(&state->seqlock);\n}\n\nint update_open_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *open_stateid,\n\t\tconst nfs4_stateid *delegation,\n\t\tfmode_t fmode)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tnfs4_stateid freeme = { };\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tspin_lock(&state->owner->so_lock);\n\tif (open_stateid != NULL) {\n\t\tnfs_state_set_open_stateid(state, open_stateid, fmode, &freeme);\n\t\tret = 1;\n\t}\n\n\tdeleg_cur = nfs4_get_valid_delegation(state->inode);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (rcu_dereference(nfsi->delegation) != deleg_cur ||\n\t   test_bit(NFS_DELEGATION_RETURNING, &deleg_cur->flags) ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (!nfs4_stateid_match_other(&deleg_cur->stateid, delegation))\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\tnfs_state_set_delegation(state, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\tif (ret)\n\t\tupdate_open_stateflags(state, fmode);\n\tspin_unlock(&state->owner->so_lock);\n\trcu_read_unlock();\n\n\tif (test_bit(NFS_STATE_RECLAIM_NOGRACE, &state->flags))\n\t\tnfs4_schedule_state_manager(clp);\n\tif (freeme.type != 0)\n\t\tnfs4_test_and_free_stateid(server, &freeme,\n\t\t\t\tstate->owner->so_cred);\n\n\treturn ret;\n}\n\nstatic bool nfs4_update_lock_stateid(struct nfs4_lock_state *lsp,\n\t\tconst nfs4_stateid *stateid)\n{\n\tstruct nfs4_state *state = lsp->ls_state;\n\tbool ret = false;\n\n\tspin_lock(&state->state_lock);\n\tif (!nfs4_stateid_match_other(stateid, &lsp->ls_stateid))\n\t\tgoto out_noupdate;\n\tif (!nfs4_stateid_is_newer(stateid, &lsp->ls_stateid))\n\t\tgoto out_noupdate;\n\tnfs4_stateid_copy(&lsp->ls_stateid, stateid);\n\tret = true;\nout_noupdate:\n\tspin_unlock(&state->state_lock);\n\treturn ret;\n}\n\nstatic void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n{\n\tstruct nfs_delegation *delegation;\n\n\tfmode &= FMODE_READ|FMODE_WRITE;\n\trcu_read_lock();\n\tdelegation = nfs4_get_valid_delegation(inode);\n\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs4_inode_return_delegation(inode);\n}\n\nstatic struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags;\n\tfmode_t fmode = opendata->o_arg.fmode;\n\tenum open_claim_type4 claim = opendata->o_arg.claim;\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\n\tfor (;;) {\n\t\tspin_lock(&state->owner->so_lock);\n\t\tif (can_open_cached(state, fmode, open_mode, claim)) {\n\t\t\tupdate_open_stateflags(state, fmode);\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\tgoto out_return_state;\n\t\t}\n\t\tspin_unlock(&state->owner->so_lock);\n\t\trcu_read_lock();\n\t\tdelegation = nfs4_get_valid_delegation(state->inode);\n\t\tif (!can_open_delegated(delegation, fmode, claim)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\t/* Save the delegation */\n\t\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\t\trcu_read_unlock();\n\t\tnfs_release_seqid(opendata->o_arg.seqid);\n\t\tif (!opendata->is_recover) {\n\t\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tret = -EAGAIN;\n\n\t\t/* Try to update the stateid using the delegation */\n\t\tif (update_open_stateid(state, NULL, &stateid, fmode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\trefcount_inc(&state->count);\n\treturn state;\n}\n\nstatic void\nnfs4_opendata_check_deleg(struct nfs4_opendata *data, struct nfs4_state *state)\n{\n\tstruct nfs_client *clp = NFS_SERVER(state->inode)->nfs_client;\n\tstruct nfs_delegation *delegation;\n\tint delegation_flags = 0;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation)\n\t\tdelegation_flags = delegation->flags;\n\trcu_read_unlock();\n\tswitch (data->o_arg.claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tpr_err_ratelimited(\"NFS: Broken NFSv4 server %s is \"\n\t\t\t\t   \"returning a delegation for \"\n\t\t\t\t   \"OPEN(CLAIM_DELEGATE_CUR)\\n\",\n\t\t\t\t   clp->cl_hostname);\n\t\treturn;\n\t}\n\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\tdata->owner->so_cred,\n\t\t\t\tdata->o_res.delegation_type,\n\t\t\t\t&data->o_res.delegation,\n\t\t\t\tdata->o_res.pagemod_limit);\n\telse\n\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\tdata->owner->so_cred,\n\t\t\t\tdata->o_res.delegation_type,\n\t\t\t\t&data->o_res.delegation,\n\t\t\t\tdata->o_res.pagemod_limit);\n\n\tif (data->o_res.do_recall)\n\t\tnfs_async_inode_return_delegation(state->inode,\n\t\t\t\t\t\t  &data->o_res.delegation);\n}\n\n/*\n * Check the inode attributes against the CLAIM_PREVIOUS returned attributes\n * and update the nfs4_state.\n */\nstatic struct nfs4_state *\n_nfs4_opendata_reclaim_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode = data->state->inode;\n\tstruct nfs4_state *state = data->state;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tif (data->rpc_status)\n\t\t\treturn ERR_PTR(data->rpc_status);\n\t\t/* cached opens have already been processed */\n\t\tgoto update;\n\t}\n\n\tret = nfs_refresh_inode(inode, &data->f_attr);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\nupdate:\n\tif (!update_open_stateid(state, &data->o_res.stateid,\n\t\t\t\tNULL, data->o_arg.fmode))\n\t\treturn ERR_PTR(-EAGAIN);\n\trefcount_inc(&state->count);\n\n\treturn state;\n}\n\nstatic struct inode *\nnfs4_opendata_get_inode(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\n\tswitch (data->o_arg.claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh,\n\t\t\t\t&data->f_attr, data->f_label);\n\t\tbreak;\n\tdefault:\n\t\tinode = d_inode(data->dentry);\n\t\tihold(inode);\n\t\tnfs_refresh_inode(inode, &data->f_attr);\n\t}\n\treturn inode;\n}\n\nstatic struct nfs4_state *\nnfs4_opendata_find_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct nfs4_state *state;\n\tstruct inode *inode;\n\n\tinode = nfs4_opendata_get_inode(data);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (data->state != NULL && data->state->inode == inode) {\n\t\tstate = data->state;\n\t\trefcount_inc(&state->count);\n\t} else\n\t\tstate = nfs4_get_open_state(inode, data->owner);\n\tiput(inode);\n\tif (state == NULL)\n\t\tstate = ERR_PTR(-ENOMEM);\n\treturn state;\n}\n\nstatic struct nfs4_state *\n_nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct nfs4_state *state;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\ttrace_nfs4_cached_open(data->state);\n\t\tgoto out;\n\t}\n\n\tstate = nfs4_opendata_find_nfs4_state(data);\n\tif (IS_ERR(state))\n\t\tgoto out;\n\n\tif (data->o_res.delegation_type != 0)\n\t\tnfs4_opendata_check_deleg(data, state);\n\tif (!update_open_stateid(state, &data->o_res.stateid,\n\t\t\t\tNULL, data->o_arg.fmode)) {\n\t\tnfs4_put_open_state(state);\n\t\tstate = ERR_PTR(-EAGAIN);\n\t}\nout:\n\tnfs_release_seqid(data->o_arg.seqid);\n\treturn state;\n}\n\nstatic struct nfs4_state *\nnfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct nfs4_state *ret;\n\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\tret =_nfs4_opendata_reclaim_to_nfs4_state(data);\n\telse\n\t\tret = _nfs4_opendata_to_nfs4_state(data);\n\tnfs4_sequence_free_slot(&data->o_res.seq_res);\n\treturn ret;\n}\n\nstatic struct nfs_open_context *\nnfs4_state_find_open_context_mode(struct nfs4_state *state, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_open_context *ctx;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &nfsi->open_files, list) {\n\t\tif (ctx->state != state)\n\t\t\tcontinue;\n\t\tif ((ctx->mode & mode) != mode)\n\t\t\tcontinue;\n\t\tif (!get_nfs_open_context(ctx))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\t\treturn ctx;\n\t}\n\trcu_read_unlock();\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct nfs_open_context *\nnfs4_state_find_open_context(struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\n\tctx = nfs4_state_find_open_context_mode(state, FMODE_READ|FMODE_WRITE);\n\tif (!IS_ERR(ctx))\n\t\treturn ctx;\n\tctx = nfs4_state_find_open_context_mode(state, FMODE_WRITE);\n\tif (!IS_ERR(ctx))\n\t\treturn ctx;\n\treturn nfs4_state_find_open_context_mode(state, FMODE_READ);\n}\n\nstatic struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx,\n\t\tstruct nfs4_state *state, enum open_claim_type4 claim)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(ctx->dentry, state->owner, 0, 0,\n\t\t\tNULL, claim, GFP_NOFS);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\trefcount_inc(&state->count);\n\treturn opendata;\n}\n\nstatic int nfs4_open_recover_helper(struct nfs4_opendata *opendata,\n\t\tfmode_t fmode)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\tif (!nfs4_mode_match_open_stateid(opendata->state, fmode))\n\t\treturn 0;\n\topendata->o_arg.open_flags = 0;\n\topendata->o_arg.fmode = fmode;\n\topendata->o_arg.share_access = nfs4_map_atomic_open_share(\n\t\t\tNFS_SB(opendata->dentry->d_sb),\n\t\t\tfmode, 0);\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_recover_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tif (newstate != opendata->state)\n\t\tret = -ESTALE;\n\tnfs4_close_state(newstate, fmode);\n\treturn ret;\n}\n\nstatic int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tint ret;\n\n\t/* memory barrier prior to reading state->n_* */\n\tsmp_rmb();\n\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = nfs4_open_recover_helper(opendata, FMODE_READ);\n\tif (ret != 0)\n\t\treturn ret;\n\t/*\n\t * We may have performed cached opens for all three recoveries.\n\t * Check if we need to update the current stateid.\n\t */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    !nfs4_stateid_match(&state->stateid, &state->open_stateid)) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tnfs4_stateid_copy(&state->stateid, &state->open_stateid);\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_RECLAIM:\n * \treclaim state on the server after a reboot.\n */\nstatic int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tfmode_t delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state,\n\t\t\tNFS4_OPEN_CLAIM_PREVIOUS);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}\n\nstatic int nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_do_open_reclaim(ctx, state);\n\t\ttrace_nfs4_open_reclaim(ctx, 0, err);\n\t\tif (nfs4_clear_cap_atomic_open_v1(server, err, &exception))\n\t\t\tcontinue;\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_open_reclaim(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn -EAGAIN;\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tnfs_state_clear_open_state_flags(state);\n\tret = nfs4_do_open_reclaim(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic int nfs4_handle_delegation_recall_error(struct nfs_server *server, struct nfs4_state *state, const nfs4_stateid *stateid, struct file_lock *fl, int err)\n{\n\tswitch (err) {\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\tcase 0:\n\t\tcase -ENOENT:\n\t\tcase -EAGAIN:\n\t\tcase -ESTALE:\n\t\tcase -ETIMEDOUT:\n\t\t\tbreak;\n\t\tcase -NFS4ERR_BADSESSION:\n\t\tcase -NFS4ERR_BADSLOT:\n\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\tnfs4_schedule_migration_recovery(server);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_LEASE_MOVED:\n\t\t\tnfs4_schedule_lease_moved_recovery(server->nfs_client);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\tstateid);\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\treturn -EAGAIN;\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -NFS4ERR_GRACE:\n\t\t\tssleep(1);\n\t\t\treturn -EAGAIN;\n\t\tcase -ENOMEM:\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tif (fl) {\n\t\t\t\tstruct nfs4_lock_state *lsp = fl->fl_u.nfs4_fl.owner;\n\t\t\t\tif (lsp)\n\t\t\t\t\tset_bit(NFS_LOCK_LOST, &lsp->ls_flags);\n\t\t\t}\n\t\t\treturn 0;\n\t}\n\treturn err;\n}\n\nint nfs4_open_delegation_recall(struct nfs_open_context *ctx,\n\t\tstruct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_opendata *opendata;\n\tint err = 0;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state,\n\t\t\tNFS4_OPEN_CLAIM_DELEG_CUR_FH);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tnfs4_stateid_copy(&opendata->o_arg.u.delegation, stateid);\n\tif (!test_bit(NFS_O_RDWR_STATE, &state->flags)) {\n\t\terr = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (!test_bit(NFS_O_WRONLY_STATE, &state->flags)) {\n\t\terr = nfs4_open_recover_helper(opendata, FMODE_WRITE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (!test_bit(NFS_O_RDONLY_STATE, &state->flags)) {\n\t\terr = nfs4_open_recover_helper(opendata, FMODE_READ);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tnfs_state_clear_delegation(state);\nout:\n\tnfs4_opendata_put(opendata);\n\treturn nfs4_handle_delegation_recall_error(server, state, stateid, NULL, err);\n}\n\nstatic void nfs4_open_confirm_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tnfs4_setup_sequence(data->o_arg.server->nfs_client,\n\t\t\t   &data->c_arg.seq_args, &data->c_res.seq_res, task);\n}\n\nstatic void nfs4_open_confirm_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tnfs40_sequence_done(task, &data->c_res.seq_res);\n\n\tdata->rpc_status = task->tk_status;\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->o_res.stateid, &data->c_res.stateid);\n\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tdata->rpc_done = true;\n\t}\n}\n\nstatic void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (!data->cancelled)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_confirm_ops = {\n\t.rpc_call_prepare = nfs4_open_confirm_prepare,\n\t.rpc_call_done = nfs4_open_confirm_done,\n\t.rpc_release = nfs4_open_confirm_release,\n};\n\n/*\n * Note: On error, nfs4_proc_open_confirm will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open_confirm(struct nfs4_opendata *data)\n{\n\tstruct nfs_server *server = NFS_SERVER(d_inode(data->dir));\n\tstruct rpc_task *task;\n\tstruct  rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_CONFIRM],\n\t\t.rpc_argp = &data->c_arg,\n\t\t.rpc_resp = &data->c_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_confirm_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint status;\n\n\tnfs4_init_sequence(&data->c_arg.seq_args, &data->c_res.seq_res, 1,\n\t\t\t\tdata->is_recover);\n\tkref_get(&data->kref);\n\tdata->rpc_done = false;\n\tdata->rpc_status = 0;\n\tdata->timestamp = jiffies;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = true;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tstruct nfs_client *clp = sp->so_server->nfs_client;\n\tenum open_claim_type4 claim = data->o_arg.claim;\n\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\tgoto out_wait;\n\t/*\n\t * Check if we still need to send an OPEN call, or if we can use\n\t * a delegation instead.\n\t */\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\n\t\tif (can_open_cached(data->state, data->o_arg.fmode,\n\t\t\t\t\tdata->o_arg.open_flags, claim))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = nfs4_get_valid_delegation(data->state->inode);\n\t\tif (can_open_delegated(delegation, data->o_arg.fmode, claim))\n\t\t\tgoto unlock_no_action;\n\t\trcu_read_unlock();\n\t}\n\t/* Update client id. */\n\tdata->o_arg.clientid = clp->cl_clientid;\n\tswitch (claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tdata->o_arg.open_bitmap = &nfs4_open_noattr_bitmap[0];\n\t\tfallthrough;\n\tcase NFS4_OPEN_CLAIM_FH:\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->o_arg.server->nfs_client,\n\t\t\t\t&data->o_arg.seq_args,\n\t\t\t\t&data->o_res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(data->o_arg.seqid);\n\n\t/* Set the create mode (note dependency on the session type) */\n\tdata->o_arg.createmode = NFS4_CREATE_UNCHECKED;\n\tif (data->o_arg.open_flags & O_EXCL) {\n\t\tdata->o_arg.createmode = NFS4_CREATE_EXCLUSIVE;\n\t\tif (nfs4_has_persistent_session(clp))\n\t\t\tdata->o_arg.createmode = NFS4_CREATE_GUARDED;\n\t\telse if (clp->cl_mvops->minor_version > 0)\n\t\t\tdata->o_arg.createmode = NFS4_CREATE_EXCLUSIVE4_1;\n\t}\n\treturn;\nunlock_no_action:\n\ttrace_nfs4_cached_open(data->state);\n\trcu_read_unlock();\nout_no_action:\n\ttask->tk_action = NULL;\nout_wait:\n\tnfs4_sequence_done(task, &data->o_res.seq_res);\n}\n\nstatic void nfs4_open_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\n\tdata->rpc_status = task->tk_status;\n\n\tif (!nfs4_sequence_process(task, &data->o_res.seq_res))\n\t\treturn;\n\n\tif (task->tk_status == 0) {\n\t\tif (data->o_res.f_attr->valid & NFS_ATTR_FATTR_TYPE) {\n\t\t\tswitch (data->o_res.f_attr->mode & S_IFMT) {\n\t\t\tcase S_IFREG:\n\t\t\t\tbreak;\n\t\t\tcase S_IFLNK:\n\t\t\t\tdata->rpc_status = -ELOOP;\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\tdata->rpc_status = -EISDIR;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata->rpc_status = -ENOTDIR;\n\t\t\t}\n\t\t}\n\t\trenew_lease(data->o_res.server, data->timestamp);\n\t\tif (!(data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM))\n\t\t\tnfs_confirm_seqid(&data->owner->so_seqid, 0);\n\t}\n\tdata->rpc_done = true;\n}\n\nstatic void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (!data->cancelled)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\t/* In case we need an open_confirm, no cleanup! */\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}\n\nstatic const struct rpc_call_ops nfs4_open_ops = {\n\t.rpc_call_prepare = nfs4_open_prepare,\n\t.rpc_call_done = nfs4_open_done,\n\t.rpc_release = nfs4_open_release,\n};\n\nstatic int nfs4_run_open_task(struct nfs4_opendata *data,\n\t\t\t      struct nfs_open_context *ctx)\n{\n\tstruct inode *dir = d_inode(data->dir);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN],\n\t\t.rpc_argp = o_arg,\n\t\t.rpc_resp = o_res,\n\t\t.rpc_cred = data->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_open_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint status;\n\n\tkref_get(&data->kref);\n\tdata->rpc_done = false;\n\tdata->rpc_status = 0;\n\tdata->cancelled = false;\n\tdata->is_recover = false;\n\tif (!ctx) {\n\t\tnfs4_init_sequence(&o_arg->seq_args, &o_res->seq_res, 1, 1);\n\t\tdata->is_recover = true;\n\t\ttask_setup_data.flags |= RPC_TASK_TIMEOUT;\n\t} else {\n\t\tnfs4_init_sequence(&o_arg->seq_args, &o_res->seq_res, 1, 0);\n\t\tpnfs_lgopen_prepare(data, ctx);\n\t}\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0) {\n\t\tdata->cancelled = true;\n\t\tsmp_wmb();\n\t} else\n\t\tstatus = data->rpc_status;\n\trpc_put_task(task);\n\n\treturn status;\n}\n\nstatic int _nfs4_recover_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = d_inode(data->dir);\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\n\tstatus = nfs4_run_open_task(data, NULL);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tnfs_fattr_map_and_free_names(NFS_SERVER(dir), &data->f_attr);\n\n\tif (o_res->rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\n\treturn status;\n}\n\n/*\n * Additional permission checks in order to distinguish between an\n * open for read, and an open for execute. This works around the\n * fact that NFSv4 OPEN treats read and execute permissions as being\n * the same.\n * Note that in the non-execute case, we want to turn off permission\n * checking if we just created a new file (POSIX open() semantics).\n */\nstatic int nfs4_opendata_access(const struct cred *cred,\n\t\t\t\tstruct nfs4_opendata *opendata,\n\t\t\t\tstruct nfs4_state *state, fmode_t fmode,\n\t\t\t\tint openflags)\n{\n\tstruct nfs_access_entry cache;\n\tu32 mask, flags;\n\n\t/* access call failed or for some reason the server doesn't\n\t * support any access modes -- defer access call until later */\n\tif (opendata->o_res.access_supported == 0)\n\t\treturn 0;\n\n\tmask = 0;\n\t/*\n\t * Use openflags to check for exec, because fmode won't\n\t * always have FMODE_EXEC set when file open for exec.\n\t */\n\tif (openflags & __FMODE_EXEC) {\n\t\t/* ONLY check for exec rights */\n\t\tif (S_ISDIR(state->inode->i_mode))\n\t\t\tmask = NFS4_ACCESS_LOOKUP;\n\t\telse\n\t\t\tmask = NFS4_ACCESS_EXECUTE;\n\t} else if ((fmode & FMODE_READ) && !opendata->file_created)\n\t\tmask = NFS4_ACCESS_READ;\n\n\tcache.cred = cred;\n\tnfs_access_set_mask(&cache, opendata->o_res.access_result);\n\tnfs_access_add_cache(state->inode, &cache);\n\n\tflags = NFS4_ACCESS_READ | NFS4_ACCESS_EXECUTE | NFS4_ACCESS_LOOKUP;\n\tif ((mask & ~cache.mask & flags) == 0)\n\t\treturn 0;\n\n\treturn -EACCES;\n}\n\n/*\n * Note: On error, nfs4_proc_open will free the struct nfs4_opendata\n */\nstatic int _nfs4_proc_open(struct nfs4_opendata *data,\n\t\t\t   struct nfs_open_context *ctx)\n{\n\tstruct inode *dir = d_inode(data->dir);\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\n\tstatus = nfs4_run_open_task(data, ctx);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\n\tif (o_arg->open_flags & O_CREAT) {\n\t\tif (o_arg->open_flags & O_EXCL)\n\t\t\tdata->file_created = true;\n\t\telse if (o_res->cinfo.before != o_res->cinfo.after)\n\t\t\tdata->file_created = true;\n\t\tif (data->file_created ||\n\t\t    inode_peek_iversion_raw(dir) != o_res->cinfo.after)\n\t\t\tnfs4_update_changeattr(dir, &o_res->cinfo,\n\t\t\t\t\to_res->f_attr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_DATA);\n\t}\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR)) {\n\t\tnfs4_sequence_free_slot(&o_res->seq_res);\n\t\tnfs4_proc_getattr(server, &o_res->fh, o_res->f_attr,\n\t\t\t\to_res->f_label, NULL);\n\t}\n\treturn 0;\n}\n\n/*\n * OPEN_EXPIRED:\n * \treclaim state on the server after a network partition.\n * \tAssumes caller holds the appropriate lock\n */\nstatic int _nfs4_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\tint ret;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state,\n\t\t\tNFS4_OPEN_CLAIM_FH);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\tret = nfs4_open_recover(opendata, state);\n\tif (ret == -ESTALE)\n\t\td_drop(ctx->dentry);\n\tnfs4_opendata_put(opendata);\n\treturn ret;\n}\n\nstatic int nfs4_do_open_expired(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_open_expired(ctx, state);\n\t\ttrace_nfs4_open_expired(ctx, 0, err);\n\t\tif (nfs4_clear_cap_atomic_open_v1(server, err, &exception))\n\t\t\tcontinue;\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tstruct nfs_open_context *ctx;\n\tint ret;\n\n\tctx = nfs4_state_find_open_context(state);\n\tif (IS_ERR(ctx))\n\t\treturn -EAGAIN;\n\tret = nfs4_do_open_expired(ctx, state);\n\tput_nfs_open_context(ctx);\n\treturn ret;\n}\n\nstatic void nfs_finish_clear_delegation_stateid(struct nfs4_state *state,\n\t\tconst nfs4_stateid *stateid)\n{\n\tnfs_remove_bad_delegation(state->inode, stateid);\n\tnfs_state_clear_delegation(state);\n}\n\nstatic void nfs40_clear_delegation_stateid(struct nfs4_state *state)\n{\n\tif (rcu_access_pointer(NFS_I(state->inode)->delegation) != NULL)\n\t\tnfs_finish_clear_delegation_stateid(state, NULL);\n}\n\nstatic int nfs40_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\t/* NFSv4.0 doesn't allow for delegation recovery on open expire */\n\tnfs40_clear_delegation_stateid(state);\n\tnfs_state_clear_open_state_flags(state);\n\treturn nfs4_open_expired(sp, state);\n}\n\nstatic int nfs40_test_and_free_expired_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\treturn -NFS4ERR_BAD_STATEID;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int nfs41_test_and_free_expired_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tint status;\n\n\tswitch (stateid->type) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_INVALID_STATEID_TYPE:\n\tcase NFS4_SPECIAL_STATEID_TYPE:\n\t\treturn -NFS4ERR_BAD_STATEID;\n\tcase NFS4_REVOKED_STATEID_TYPE:\n\t\tgoto out_free;\n\t}\n\n\tstatus = nfs41_test_stateid(server, stateid, cred);\n\tswitch (status) {\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_DELEG_REVOKED:\n\t\tbreak;\n\tdefault:\n\t\treturn status;\n\t}\nout_free:\n\t/* Ack the revoked state to the server */\n\tnfs41_free_stateid(server, stateid, cred, true);\n\treturn -NFS4ERR_EXPIRED;\n}\n\nstatic int nfs41_check_delegation_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid stateid;\n\tstruct nfs_delegation *delegation;\n\tconst struct cred *cred = NULL;\n\tint status, ret = NFS_OK;\n\n\t/* Get the delegation credential for use by test/free_stateid */\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation == NULL) {\n\t\trcu_read_unlock();\n\t\tnfs_state_clear_delegation(state);\n\t\treturn NFS_OK;\n\t}\n\n\tspin_lock(&delegation->lock);\n\tnfs4_stateid_copy(&stateid, &delegation->stateid);\n\n\tif (!test_and_clear_bit(NFS_DELEGATION_TEST_EXPIRED,\n\t\t\t\t&delegation->flags)) {\n\t\tspin_unlock(&delegation->lock);\n\t\trcu_read_unlock();\n\t\treturn NFS_OK;\n\t}\n\n\tif (delegation->cred)\n\t\tcred = get_cred(delegation->cred);\n\tspin_unlock(&delegation->lock);\n\trcu_read_unlock();\n\tstatus = nfs41_test_and_free_expired_stateid(server, &stateid, cred);\n\ttrace_nfs4_test_delegation_stateid(state, NULL, status);\n\tif (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID)\n\t\tnfs_finish_clear_delegation_stateid(state, &stateid);\n\telse\n\t\tret = status;\n\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void nfs41_delegation_recover_stateid(struct nfs4_state *state)\n{\n\tnfs4_stateid tmp;\n\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) &&\n\t    nfs4_copy_delegation_stateid(state->inode, state->state,\n\t\t\t\t&tmp, NULL) &&\n\t    nfs4_stateid_match_other(&state->stateid, &tmp))\n\t\tnfs_state_set_delegation(state, &tmp, state->state);\n\telse\n\t\tnfs_state_clear_delegation(state);\n}\n\n/**\n * nfs41_check_expired_locks - possibly free a lock stateid\n *\n * @state: NFSv4 state for an inode\n *\n * Returns NFS_OK if recovery for this stateid is now finished.\n * Otherwise a negative NFS4ERR value is returned.\n */\nstatic int nfs41_check_expired_locks(struct nfs4_state *state)\n{\n\tint status, ret = NFS_OK;\n\tstruct nfs4_lock_state *lsp, *prev = NULL;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\n\tif (!test_bit(LK_STATE_IN_USE, &state->flags))\n\t\tgoto out;\n\n\tspin_lock(&state->state_lock);\n\tlist_for_each_entry(lsp, &state->lock_states, ls_locks) {\n\t\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags)) {\n\t\t\tconst struct cred *cred = lsp->ls_state->owner->so_cred;\n\n\t\t\trefcount_inc(&lsp->ls_count);\n\t\t\tspin_unlock(&state->state_lock);\n\n\t\t\tnfs4_put_lock_state(prev);\n\t\t\tprev = lsp;\n\n\t\t\tstatus = nfs41_test_and_free_expired_stateid(server,\n\t\t\t\t\t&lsp->ls_stateid,\n\t\t\t\t\tcred);\n\t\t\ttrace_nfs4_test_lock_stateid(state, lsp, status);\n\t\t\tif (status == -NFS4ERR_EXPIRED ||\n\t\t\t    status == -NFS4ERR_BAD_STATEID) {\n\t\t\t\tclear_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t\t\tlsp->ls_stateid.type = NFS4_INVALID_STATEID_TYPE;\n\t\t\t\tif (!recover_lost_locks)\n\t\t\t\t\tset_bit(NFS_LOCK_LOST, &lsp->ls_flags);\n\t\t\t} else if (status != NFS_OK) {\n\t\t\t\tret = status;\n\t\t\t\tnfs4_put_lock_state(prev);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tspin_lock(&state->state_lock);\n\t\t}\n\t}\n\tspin_unlock(&state->state_lock);\n\tnfs4_put_lock_state(prev);\nout:\n\treturn ret;\n}\n\n/**\n * nfs41_check_open_stateid - possibly free an open stateid\n *\n * @state: NFSv4 state for an inode\n *\n * Returns NFS_OK if recovery for this stateid is now finished.\n * Otherwise a negative NFS4ERR value is returned.\n */\nstatic int nfs41_check_open_stateid(struct nfs4_state *state)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tnfs4_stateid *stateid = &state->open_stateid;\n\tconst struct cred *cred = state->owner->so_cred;\n\tint status;\n\n\tif (test_bit(NFS_OPEN_STATE, &state->flags) == 0)\n\t\treturn -NFS4ERR_BAD_STATEID;\n\tstatus = nfs41_test_and_free_expired_stateid(server, stateid, cred);\n\ttrace_nfs4_test_open_stateid(state, NULL, status);\n\tif (status == -NFS4ERR_EXPIRED || status == -NFS4ERR_BAD_STATEID) {\n\t\tnfs_state_clear_open_state_flags(state);\n\t\tstateid->type = NFS4_INVALID_STATEID_TYPE;\n\t\treturn status;\n\t}\n\tif (nfs_open_stateid_recover_openmode(state))\n\t\treturn -NFS4ERR_OPENMODE;\n\treturn NFS_OK;\n}\n\nstatic int nfs41_open_expired(struct nfs4_state_owner *sp, struct nfs4_state *state)\n{\n\tint status;\n\n\tstatus = nfs41_check_delegation_stateid(state);\n\tif (status != NFS_OK)\n\t\treturn status;\n\tnfs41_delegation_recover_stateid(state);\n\n\tstatus = nfs41_check_expired_locks(state);\n\tif (status != NFS_OK)\n\t\treturn status;\n\tstatus = nfs41_check_open_stateid(state);\n\tif (status != NFS_OK)\n\t\tstatus = nfs4_open_expired(sp, state);\n\treturn status;\n}\n#endif\n\n/*\n * on an EXCLUSIVE create, the server should send back a bitmask with FATTR4-*\n * fields corresponding to attributes that were used to store the verifier.\n * Make sure we clobber those fields in the later setattr call\n */\nstatic unsigned nfs4_exclusive_attrset(struct nfs4_opendata *opendata,\n\t\t\t\tstruct iattr *sattr, struct nfs4_label **label)\n{\n\tconst __u32 *bitmask = opendata->o_arg.server->exclcreat_bitmask;\n\t__u32 attrset[3];\n\tunsigned ret;\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(attrset); i++) {\n\t\tattrset[i] = opendata->o_res.attrset[i];\n\t\tif (opendata->o_arg.createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tattrset[i] &= ~bitmask[i];\n\t}\n\n\tret = (opendata->o_arg.createmode == NFS4_CREATE_EXCLUSIVE) ?\n\t\tsattr->ia_valid : 0;\n\n\tif ((attrset[1] & (FATTR4_WORD1_TIME_ACCESS|FATTR4_WORD1_TIME_ACCESS_SET))) {\n\t\tif (sattr->ia_valid & ATTR_ATIME_SET)\n\t\t\tret |= ATTR_ATIME_SET;\n\t\telse\n\t\t\tret |= ATTR_ATIME;\n\t}\n\n\tif ((attrset[1] & (FATTR4_WORD1_TIME_MODIFY|FATTR4_WORD1_TIME_MODIFY_SET))) {\n\t\tif (sattr->ia_valid & ATTR_MTIME_SET)\n\t\t\tret |= ATTR_MTIME_SET;\n\t\telse\n\t\t\tret |= ATTR_MTIME;\n\t}\n\n\tif (!(attrset[2] & FATTR4_WORD2_SECURITY_LABEL))\n\t\t*label = NULL;\n\treturn ret;\n}\n\nstatic int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,\n\t\tint flags, struct nfs_open_context *ctx)\n{\n\tstruct nfs4_state_owner *sp = opendata->owner;\n\tstruct nfs_server *server = sp->so_server;\n\tstruct dentry *dentry;\n\tstruct nfs4_state *state;\n\tfmode_t acc_mode = _nfs4_ctx_to_accessmode(ctx);\n\tstruct inode *dir = d_inode(opendata->dir);\n\tunsigned long dir_verifier;\n\tunsigned int seq;\n\tint ret;\n\n\tseq = raw_seqcount_begin(&sp->so_reclaim_seqcount);\n\tdir_verifier = nfs_save_change_attribute(dir);\n\n\tret = _nfs4_proc_open(opendata, ctx);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tstate = _nfs4_opendata_to_nfs4_state(opendata);\n\tret = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto out;\n\tctx->state = state;\n\tif (server->caps & NFS_CAP_POSIX_LOCK)\n\t\tset_bit(NFS_STATE_POSIX_LOCKS, &state->flags);\n\tif (opendata->o_res.rflags & NFS4_OPEN_RESULT_MAY_NOTIFY_LOCK)\n\t\tset_bit(NFS_STATE_MAY_NOTIFY_LOCK, &state->flags);\n\n\tdentry = opendata->dentry;\n\tif (d_really_is_negative(dentry)) {\n\t\tstruct dentry *alias;\n\t\td_drop(dentry);\n\t\talias = d_exact_alias(dentry, state->inode);\n\t\tif (!alias)\n\t\t\talias = d_splice_alias(igrab(state->inode), dentry);\n\t\t/* d_splice_alias() can't fail here - it's a non-directory */\n\t\tif (alias) {\n\t\t\tdput(ctx->dentry);\n\t\t\tctx->dentry = dentry = alias;\n\t\t}\n\t}\n\n\tswitch(opendata->o_arg.claim) {\n\tdefault:\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tif (!opendata->rpc_done)\n\t\t\tbreak;\n\t\tif (opendata->o_res.delegation_type != 0)\n\t\t\tdir_verifier = nfs_save_change_attribute(dir);\n\t\tnfs_set_verifier(dentry, dir_verifier);\n\t}\n\n\t/* Parse layoutget results before we check for access */\n\tpnfs_parse_lgopen(state->inode, opendata->lgp, ctx);\n\n\tret = nfs4_opendata_access(sp->so_cred, opendata, state,\n\t\t\tacc_mode, flags);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (d_inode(dentry) == state->inode) {\n\t\tnfs_inode_attach_open_context(ctx);\n\t\tif (read_seqcount_retry(&sp->so_reclaim_seqcount, seq))\n\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t}\n\nout:\n\tif (!opendata->cancelled)\n\t\tnfs4_sequence_free_slot(&opendata->o_res.seq_res);\n\treturn ret;\n}\n\n/*\n * Returns a referenced nfs4_state\n */\nstatic int _nfs4_do_open(struct inode *dir,\n\t\t\tstruct nfs_open_context *ctx,\n\t\t\tint flags,\n\t\t\tconst struct nfs4_open_createattrs *c,\n\t\t\tint *opened)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tstruct dentry *dentry = ctx->dentry;\n\tconst struct cred *cred = ctx->cred;\n\tstruct nfs4_threshold **ctx_th = &ctx->mdsthreshold;\n\tfmode_t fmode = _nfs4_ctx_to_openmode(ctx);\n\tenum open_claim_type4 claim = NFS4_OPEN_CLAIM_NULL;\n\tstruct iattr *sattr = c->sattr;\n\tstruct nfs4_label *label = c->label;\n\tstruct nfs4_label *olabel = NULL;\n\tint status;\n\n\t/* Protect against reboot recovery conflicts */\n\tstatus = -ENOMEM;\n\tsp = nfs4_get_state_owner(server, cred, GFP_KERNEL);\n\tif (sp == NULL) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_client_recover_expired_lease(server->nfs_client);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (d_really_is_positive(dentry))\n\t\tnfs4_return_incompatible_delegation(d_inode(dentry), fmode);\n\tstatus = -ENOMEM;\n\tif (d_really_is_positive(dentry))\n\t\tclaim = NFS4_OPEN_CLAIM_FH;\n\topendata = nfs4_opendata_alloc(dentry, sp, fmode, flags,\n\t\t\tc, claim, GFP_KERNEL);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\n\tif (label) {\n\t\tolabel = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(olabel)) {\n\t\t\tstatus = PTR_ERR(olabel);\n\t\t\tgoto err_opendata_put;\n\t\t}\n\t}\n\n\tif (server->attr_bitmask[2] & FATTR4_WORD2_MDSTHRESHOLD) {\n\t\tif (!opendata->f_attr.mdsthreshold) {\n\t\t\topendata->f_attr.mdsthreshold = pnfs_mdsthreshold_alloc();\n\t\t\tif (!opendata->f_attr.mdsthreshold)\n\t\t\t\tgoto err_free_label;\n\t\t}\n\t\topendata->o_arg.open_bitmap = &nfs4_pnfs_open_bitmap[0];\n\t}\n\tif (d_really_is_positive(dentry))\n\t\topendata->state = nfs4_get_open_state(d_inode(dentry), sp);\n\n\tstatus = _nfs4_open_and_get_state(opendata, flags, ctx);\n\tif (status != 0)\n\t\tgoto err_free_label;\n\tstate = ctx->state;\n\n\tif ((opendata->o_arg.open_flags & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) &&\n\t    (opendata->o_arg.createmode != NFS4_CREATE_GUARDED)) {\n\t\tunsigned attrs = nfs4_exclusive_attrset(opendata, sattr, &label);\n\t\t/*\n\t\t * send create attributes which was not set by open\n\t\t * with an extra setattr.\n\t\t */\n\t\tif (attrs || label) {\n\t\t\tunsigned ia_old = sattr->ia_valid;\n\n\t\t\tsattr->ia_valid = attrs;\n\t\t\tnfs_fattr_init(opendata->o_res.f_attr);\n\t\t\tstatus = nfs4_do_setattr(state->inode, cred,\n\t\t\t\t\topendata->o_res.f_attr, sattr,\n\t\t\t\t\tctx, label, olabel);\n\t\t\tif (status == 0) {\n\t\t\t\tnfs_setattr_update_inode(state->inode, sattr,\n\t\t\t\t\t\topendata->o_res.f_attr);\n\t\t\t\tnfs_setsecurity(state->inode, opendata->o_res.f_attr, olabel);\n\t\t\t}\n\t\t\tsattr->ia_valid = ia_old;\n\t\t}\n\t}\n\tif (opened && opendata->file_created)\n\t\t*opened = 1;\n\n\tif (pnfs_use_threshold(ctx_th, opendata->f_attr.mdsthreshold, server)) {\n\t\t*ctx_th = opendata->f_attr.mdsthreshold;\n\t\topendata->f_attr.mdsthreshold = NULL;\n\t}\n\n\tnfs4_label_free(olabel);\n\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\treturn 0;\nerr_free_label:\n\tnfs4_label_free(olabel);\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\treturn status;\n}\n\n\nstatic struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct nfs_open_context *ctx,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct nfs4_label *label,\n\t\t\t\t\tint *opened)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_state *res;\n\tstruct nfs4_open_createattrs c = {\n\t\t.label = label,\n\t\t.sattr = sattr,\n\t\t.verf = {\n\t\t\t[0] = (__u32)jiffies,\n\t\t\t[1] = (__u32)current->pid,\n\t\t},\n\t};\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, ctx, flags, &c, opened);\n\t\tres = ctx->state;\n\t\ttrace_nfs4_open_file(ctx, flags, status);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\t/* NOTE: BAD_SEQID means the server and client disagree about the\n\t\t * book-keeping w.r.t. state-changing operations\n\t\t * (OPEN/CLOSE/LOCK/LOCKU...)\n\t\t * It is actually a sign of a bug on the client or on the server.\n\t\t *\n\t\t * If we receive a BAD_SEQID error in the particular case of\n\t\t * doing an OPEN, we assume that nfs_increment_open_seqid() will\n\t\t * have unhashed the old state_owner for us, and that we can\n\t\t * therefore safely retry using a new one. We should still warn\n\t\t * the user though...\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * BAD_STATEID on OPEN means that the server cancelled our\n\t\t * state before it received the OPEN_CONFIRM.\n\t\t * Recover by retrying the request as per the discussion\n\t\t * on Page 181 of RFC3530.\n\t\t */\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_EXPIRED) {\n\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\t/* We must have found a delegation */\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nfs4_clear_cap_atomic_open_v1(server, status, &exception))\n\t\t\tcontinue;\n\t\tres = ERR_PTR(nfs4_handle_exception(server,\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}\n\nstatic int _nfs4_do_setattr(struct inode *inode,\n\t\t\t    struct nfs_setattrargs *arg,\n\t\t\t    struct nfs_setattrres *res,\n\t\t\t    const struct cred *cred,\n\t\t\t    struct nfs_open_context *ctx)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= arg,\n\t\t.rpc_resp\t= res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tconst struct cred *delegation_cred = NULL;\n\tunsigned long timestamp = jiffies;\n\tbool truncate;\n\tint status;\n\n\tnfs_fattr_init(res->fattr);\n\n\t/* Servers should only apply open mode checks for file size changes */\n\ttruncate = (arg->iap->ia_valid & ATTR_SIZE) ? true : false;\n\tif (!truncate) {\n\t\tnfs4_inode_make_writeable(inode);\n\t\tgoto zero_stateid;\n\t}\n\n\tif (nfs4_copy_delegation_stateid(inode, FMODE_WRITE, &arg->stateid, &delegation_cred)) {\n\t\t/* Use that stateid */\n\t} else if (ctx != NULL && ctx->state) {\n\t\tstruct nfs_lock_context *l_ctx;\n\t\tif (!nfs4_valid_open_stateid(ctx->state))\n\t\t\treturn -EBADF;\n\t\tl_ctx = nfs_get_lock_context(ctx);\n\t\tif (IS_ERR(l_ctx))\n\t\t\treturn PTR_ERR(l_ctx);\n\t\tstatus = nfs4_select_rw_stateid(ctx->state, FMODE_WRITE, l_ctx,\n\t\t\t\t\t\t&arg->stateid, &delegation_cred);\n\t\tnfs_put_lock_context(l_ctx);\n\t\tif (status == -EIO)\n\t\t\treturn -EBADF;\n\t\telse if (status == -EAGAIN)\n\t\t\tgoto zero_stateid;\n\t} else {\nzero_stateid:\n\t\tnfs4_stateid_copy(&arg->stateid, &zero_stateid);\n\t}\n\tif (delegation_cred)\n\t\tmsg.rpc_cred = delegation_cred;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg->seq_args, &res->seq_res, 1);\n\n\tput_cred(delegation_cred);\n\tif (status == 0 && ctx != NULL)\n\t\trenew_lease(server, timestamp);\n\ttrace_nfs4_setattr(inode, &arg->stateid, status);\n\treturn status;\n}\n\nstatic int nfs4_do_setattr(struct inode *inode, const struct cred *cred,\n\t\t\t   struct nfs_fattr *fattr, struct iattr *sattr,\n\t\t\t   struct nfs_open_context *ctx, struct nfs4_label *ilabel,\n\t\t\t   struct nfs4_label *olabel)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\t__u32 bitmask[NFS4_BITMASK_SZ];\n\tstruct nfs4_state *state = ctx ? ctx->state : NULL;\n\tstruct nfs_setattrargs\targ = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.iap\t\t= sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask = bitmask,\n\t\t.label\t\t= ilabel,\n\t};\n\tstruct nfs_setattrres  res = {\n\t\t.fattr\t\t= fattr,\n\t\t.label\t\t= olabel,\n\t\t.server\t\t= server,\n\t};\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = inode,\n\t\t.stateid = &arg.stateid,\n\t};\n\tint err;\n\n\tdo {\n\t\tnfs4_bitmap_copy_adjust_setattr(bitmask,\n\t\t\t\tnfs4_bitmask(server, olabel),\n\t\t\t\tinode);\n\n\t\terr = _nfs4_do_setattr(inode, &arg, &res, cred, ctx);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_OPENMODE:\n\t\t\tif (!(sattr->ia_valid & ATTR_SIZE)) {\n\t\t\t\tpr_warn_once(\"NFSv4: server %s is incorrectly \"\n\t\t\t\t\t\t\"applying open mode checks to \"\n\t\t\t\t\t\t\"a SETATTR that is not \"\n\t\t\t\t\t\t\"changing file size.\\n\",\n\t\t\t\t\t\tserver->nfs_client->cl_hostname);\n\t\t\t}\n\t\t\tif (state && !(state->state & FMODE_WRITE)) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tif (sattr->ia_valid & ATTR_OPEN)\n\t\t\t\t\terr = -EACCES;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic bool\nnfs4_wait_on_layoutreturn(struct inode *inode, struct rpc_task *task)\n{\n\tif (inode == NULL || !nfs_have_layout(inode))\n\t\treturn false;\n\n\treturn pnfs_wait_on_layoutreturn(inode, task);\n}\n\n/*\n * Update the seqid of an open stateid\n */\nstatic void nfs4_sync_open_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state)\n{\n\t__be32 seqid_open;\n\tu32 dst_seqid;\n\tint seq;\n\n\tfor (;;) {\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tbreak;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (!nfs4_state_match_open_stateid_other(state, dst)) {\n\t\t\tnfs4_stateid_copy(dst, &state->open_stateid);\n\t\t\tif (read_seqretry(&state->seqlock, seq))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tseqid_open = state->open_stateid.seqid;\n\t\tif (read_seqretry(&state->seqlock, seq))\n\t\t\tcontinue;\n\n\t\tdst_seqid = be32_to_cpu(dst->seqid);\n\t\tif ((s32)(dst_seqid - be32_to_cpu(seqid_open)) < 0)\n\t\t\tdst->seqid = seqid_open;\n\t\tbreak;\n\t}\n}\n\n/*\n * Update the seqid of an open stateid after receiving\n * NFS4ERR_OLD_STATEID\n */\nstatic bool nfs4_refresh_open_old_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_state *state)\n{\n\t__be32 seqid_open;\n\tu32 dst_seqid;\n\tbool ret;\n\tint seq, status = -EAGAIN;\n\tDEFINE_WAIT(wait);\n\n\tfor (;;) {\n\t\tret = false;\n\t\tif (!nfs4_valid_open_stateid(state))\n\t\t\tbreak;\n\t\tseq = read_seqbegin(&state->seqlock);\n\t\tif (!nfs4_state_match_open_stateid_other(state, dst)) {\n\t\t\tif (read_seqretry(&state->seqlock, seq))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\twrite_seqlock(&state->seqlock);\n\t\tseqid_open = state->open_stateid.seqid;\n\n\t\tdst_seqid = be32_to_cpu(dst->seqid);\n\n\t\t/* Did another OPEN bump the state's seqid?  try again: */\n\t\tif ((s32)(be32_to_cpu(seqid_open) - dst_seqid) > 0) {\n\t\t\tdst->seqid = seqid_open;\n\t\t\twrite_sequnlock(&state->seqlock);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* server says we're behind but we haven't seen the update yet */\n\t\tset_bit(NFS_STATE_CHANGE_WAIT, &state->flags);\n\t\tprepare_to_wait(&state->waitq, &wait, TASK_KILLABLE);\n\t\twrite_sequnlock(&state->seqlock);\n\t\ttrace_nfs4_close_stateid_update_wait(state->inode, dst, 0);\n\n\t\tif (signal_pending(current))\n\t\t\tstatus = -EINTR;\n\t\telse\n\t\t\tif (schedule_timeout(5*HZ) != 0)\n\t\t\t\tstatus = 0;\n\n\t\tfinish_wait(&state->waitq, &wait);\n\n\t\tif (!status)\n\t\t\tcontinue;\n\t\tif (status == -EINTR)\n\t\t\tbreak;\n\n\t\t/* we slept the whole 5 seconds, we must have lost a seqid */\n\t\tdst->seqid = cpu_to_be32(dst_seqid + 1);\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstruct nfs4_closedata {\n\tstruct inode *inode;\n\tstruct nfs4_state *state;\n\tstruct nfs_closeargs arg;\n\tstruct nfs_closeres res;\n\tstruct {\n\t\tstruct nfs4_layoutreturn_args arg;\n\t\tstruct nfs4_layoutreturn_res res;\n\t\tstruct nfs4_xdr_opaque_data ld_private;\n\t\tu32 roc_barrier;\n\t\tbool roc;\n\t} lr;\n\tstruct nfs_fattr fattr;\n\tunsigned long timestamp;\n};\n\nstatic void nfs4_free_closedata(void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state_owner *sp = calldata->state->owner;\n\tstruct super_block *sb = calldata->state->inode->i_sb;\n\n\tif (calldata->lr.roc)\n\t\tpnfs_roc_release(&calldata->lr.arg, &calldata->lr.res,\n\t\t\t\tcalldata->res.lr_ret);\n\tnfs4_put_open_state(calldata->state);\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_state_owner(sp);\n\tnfs_sb_deactive(sb);\n\tkfree(calldata);\n}\n\nstatic void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\tnfs4_stateid *res_stateid = NULL;\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = calldata->inode,\n\t\t.stateid = &calldata->arg.stateid,\n\t};\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n\ttrace_nfs4_close(state, &calldata->arg, &calldata->res, task->tk_status);\n\n\t/* Handle Layoutreturn errors */\n\tif (pnfs_roc_done(task, &calldata->arg.lr_args, &calldata->res.lr_res,\n\t\t\t  &calldata->res.lr_ret) == -EAGAIN)\n\t\tgoto out_restart;\n\n\t/* hmm. we are done with the inode, and in the process of freeing\n\t * the state_owner. we keep this around to process errors\n\t */\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tres_stateid = &calldata->res.stateid;\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_ACCESS:\n\t\t\tif (calldata->arg.bitmask != NULL) {\n\t\t\t\tcalldata->arg.bitmask = NULL;\n\t\t\t\tcalldata->res.fattr = NULL;\n\t\t\t\tgoto out_restart;\n\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\t/* Did we race with OPEN? */\n\t\t\tif (nfs4_refresh_open_old_stateid(&calldata->arg.stateid,\n\t\t\t\t\t\tstate))\n\t\t\t\tgoto out_restart;\n\t\t\tgoto out_release;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tnfs4_free_revoked_stateid(server,\n\t\t\t\t\t&calldata->arg.stateid,\n\t\t\t\t\ttask->tk_msg.rpc_cred);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tif (calldata->arg.fmode == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\t\tserver, task->tk_status, &exception);\n\t\t\tif (exception.retry)\n\t\t\t\tgoto out_restart;\n\t}\n\tnfs_clear_open_stateid(state, &calldata->arg.stateid,\n\t\t\tres_stateid, calldata->arg.fmode);\nout_release:\n\ttask->tk_status = 0;\n\tnfs_release_seqid(calldata->arg.seqid);\n\tnfs_refresh_inode(calldata->inode, &calldata->fattr);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, task->tk_status);\n\treturn;\nout_restart:\n\ttask->tk_status = 0;\n\trpc_restart_call_prepare(task);\n\tgoto out_release;\n}\n\nstatic void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct inode *inode = calldata->inode;\n\tstruct pnfs_layout_hdr *lo;\n\tbool is_rdonly, is_wronly, is_rdwr;\n\tint call_close = 0;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\tgoto out_wait;\n\n\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\tspin_lock(&state->owner->so_lock);\n\tis_rdwr = test_bit(NFS_O_RDWR_STATE, &state->flags);\n\tis_rdonly = test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\tis_wronly = test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t/* Calculate the change in open mode */\n\tcalldata->arg.fmode = 0;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0)\n\t\t\tcall_close |= is_rdonly;\n\t\telse if (is_rdonly)\n\t\t\tcalldata->arg.fmode |= FMODE_READ;\n\t\tif (state->n_wronly == 0)\n\t\t\tcall_close |= is_wronly;\n\t\telse if (is_wronly)\n\t\t\tcalldata->arg.fmode |= FMODE_WRITE;\n\t\tif (calldata->arg.fmode != (FMODE_READ|FMODE_WRITE))\n\t\t\tcall_close |= is_rdwr;\n\t} else if (is_rdwr)\n\t\tcalldata->arg.fmode |= FMODE_READ|FMODE_WRITE;\n\n\tnfs4_sync_open_stateid(&calldata->arg.stateid, state);\n\tif (!nfs4_valid_open_stateid(state))\n\t\tcall_close = 0;\n\tspin_unlock(&state->owner->so_lock);\n\n\tif (!call_close) {\n\t\t/* Note: exit _without_ calling nfs4_close_done */\n\t\tgoto out_no_action;\n\t}\n\n\tif (!calldata->lr.roc && nfs4_wait_on_layoutreturn(inode, task)) {\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\t\tgoto out_wait;\n\t}\n\n\tlo = calldata->arg.lr_args ? calldata->arg.lr_args->layout : NULL;\n\tif (lo && !pnfs_layout_is_valid(lo)) {\n\t\tcalldata->arg.lr_args = NULL;\n\t\tcalldata->res.lr_res = NULL;\n\t}\n\n\tif (calldata->arg.fmode == 0)\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE];\n\n\tif (calldata->arg.fmode == 0 || calldata->arg.fmode == FMODE_READ) {\n\t\t/* Close-to-open cache consistency revalidation */\n\t\tif (!nfs4_have_delegation(inode, FMODE_READ)) {\n\t\t\tcalldata->arg.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\n\t\t\tnfs4_bitmask_adjust(calldata->arg.bitmask, inode, NFS_SERVER(inode), NULL);\n\t\t} else\n\t\t\tcalldata->arg.bitmask = NULL;\n\t}\n\n\tcalldata->arg.share_access =\n\t\tnfs4_map_atomic_open_share(NFS_SERVER(inode),\n\t\t\t\tcalldata->arg.fmode, 0);\n\n\tif (calldata->res.fattr == NULL)\n\t\tcalldata->arg.bitmask = NULL;\n\telse if (calldata->arg.bitmask == NULL)\n\t\tcalldata->res.fattr = NULL;\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(NFS_SERVER(inode)->nfs_client,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\tdprintk(\"%s: done!\\n\", __func__);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\nout_wait:\n\tnfs4_sequence_done(task, &calldata->res.seq_res);\n}\n\nstatic const struct rpc_call_ops nfs4_close_ops = {\n\t.rpc_call_prepare = nfs4_close_prepare,\n\t.rpc_call_done = nfs4_close_done,\n\t.rpc_release = nfs4_free_closedata,\n};\n\n/* \n * It is possible for data to be read/written from a mem-mapped file \n * after the sys_close call (which hits the vfs layer as a flush).\n * This means that we can't safely call nfsv4 close on a file until \n * the inode is cleared. This in turn means that we are not good\n * NFSv4 citizens - we do not indicate to the server to update the file's \n * share state even when we are done with one of the three share \n * stateid's in the inode.\n *\n * NOTE: Caller must be holding the sp->so_owner semaphore!\n */\nint nfs4_do_close(struct nfs4_state *state, gfp_t gfp_mask, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint status = -ENOMEM;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_CLEANUP,\n\t\t&task_setup_data.rpc_client, &msg);\n\n\tcalldata = kzalloc(sizeof(*calldata), gfp_mask);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tnfs4_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 1, 0);\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tif (!nfs4_copy_open_stateid(&calldata->arg.stateid, state))\n\t\tgoto out_free_calldata;\n\t/* Serialization for the sequence id */\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tcalldata->arg.seqid = alloc_seqid(&state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(calldata->arg.seqid))\n\t\tgoto out_free_calldata;\n\tnfs_fattr_init(&calldata->fattr);\n\tcalldata->arg.fmode = 0;\n\tcalldata->lr.arg.ld_private = &calldata->lr.ld_private;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->res.lr_ret = -NFS4ERR_NOMATCHING_LAYOUT;\n\tcalldata->lr.roc = pnfs_roc(state->inode,\n\t\t\t&calldata->lr.arg, &calldata->lr.res, msg.rpc_cred);\n\tif (calldata->lr.roc) {\n\t\tcalldata->arg.lr_args = &calldata->lr.arg;\n\t\tcalldata->res.lr_res = &calldata->lr.res;\n\t}\n\tnfs_sb_active(calldata->inode->i_sb);\n\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}\n\nstatic struct inode *\nnfs4_atomic_open(struct inode *dir, struct nfs_open_context *ctx,\n\t\tint open_flags, struct iattr *attr, int *opened)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_label l = {0, 0, 0, NULL}, *label = NULL;\n\n\tlabel = nfs4_label_init_security(dir, ctx->dentry, attr, &l);\n\n\t/* Protect against concurrent sillydeletes */\n\tstate = nfs4_do_open(dir, ctx, open_flags, attr, label, opened);\n\n\tnfs4_label_release_security(label);\n\n\tif (IS_ERR(state))\n\t\treturn ERR_CAST(state);\n\treturn state->inode;\n}\n\nstatic void nfs4_close_context(struct nfs_open_context *ctx, int is_sync)\n{\n\tif (ctx->state == NULL)\n\t\treturn;\n\tif (is_sync)\n\t\tnfs4_close_sync(ctx->state, _nfs4_ctx_to_openmode(ctx));\n\telse\n\t\tnfs4_close_state(ctx->state, _nfs4_ctx_to_openmode(ctx));\n}\n\n#define FATTR4_WORD1_NFS40_MASK (2*FATTR4_WORD1_MOUNTED_ON_FILEID - 1UL)\n#define FATTR4_WORD2_NFS41_MASK (2*FATTR4_WORD2_SUPPATTR_EXCLCREAT - 1UL)\n#define FATTR4_WORD2_NFS42_MASK (2*FATTR4_WORD2_XATTR_SUPPORT - 1UL)\n\nstatic int _nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tu32 bitmask[3] = {}, minorversion = server->nfs_client->cl_minorversion;\n\tstruct nfs4_server_caps_arg args = {\n\t\t.fhandle = fhandle,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_server_caps_res res = {};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SERVER_CAPS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\tint i;\n\n\tbitmask[0] = FATTR4_WORD0_SUPPORTED_ATTRS |\n\t\t     FATTR4_WORD0_FH_EXPIRE_TYPE |\n\t\t     FATTR4_WORD0_LINK_SUPPORT |\n\t\t     FATTR4_WORD0_SYMLINK_SUPPORT |\n\t\t     FATTR4_WORD0_ACLSUPPORT;\n\tif (minorversion)\n\t\tbitmask[2] = FATTR4_WORD2_SUPPATTR_EXCLCREAT;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status == 0) {\n\t\t/* Sanity check the server answers */\n\t\tswitch (minorversion) {\n\t\tcase 0:\n\t\t\tres.attr_bitmask[1] &= FATTR4_WORD1_NFS40_MASK;\n\t\t\tres.attr_bitmask[2] = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS41_MASK;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tres.attr_bitmask[2] &= FATTR4_WORD2_NFS42_MASK;\n\t\t}\n\t\tmemcpy(server->attr_bitmask, res.attr_bitmask, sizeof(server->attr_bitmask));\n\t\tserver->caps &= ~(NFS_CAP_ACLS|NFS_CAP_HARDLINKS|\n\t\t\t\tNFS_CAP_SYMLINKS|NFS_CAP_FILEID|\n\t\t\t\tNFS_CAP_MODE|NFS_CAP_NLINK|NFS_CAP_OWNER|\n\t\t\t\tNFS_CAP_OWNER_GROUP|NFS_CAP_ATIME|\n\t\t\t\tNFS_CAP_CTIME|NFS_CAP_MTIME|\n\t\t\t\tNFS_CAP_SECURITY_LABEL);\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_ACL &&\n\t\t\t\tres.acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)\n\t\t\tserver->caps |= NFS_CAP_ACLS;\n\t\tif (res.has_links != 0)\n\t\t\tserver->caps |= NFS_CAP_HARDLINKS;\n\t\tif (res.has_symlinks != 0)\n\t\t\tserver->caps |= NFS_CAP_SYMLINKS;\n\t\tif (res.attr_bitmask[0] & FATTR4_WORD0_FILEID)\n\t\t\tserver->caps |= NFS_CAP_FILEID;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_MODE)\n\t\t\tserver->caps |= NFS_CAP_MODE;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_NUMLINKS)\n\t\t\tserver->caps |= NFS_CAP_NLINK;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER)\n\t\t\tserver->caps |= NFS_CAP_OWNER;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_OWNER_GROUP)\n\t\t\tserver->caps |= NFS_CAP_OWNER_GROUP;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_ACCESS)\n\t\t\tserver->caps |= NFS_CAP_ATIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_METADATA)\n\t\t\tserver->caps |= NFS_CAP_CTIME;\n\t\tif (res.attr_bitmask[1] & FATTR4_WORD1_TIME_MODIFY)\n\t\t\tserver->caps |= NFS_CAP_MTIME;\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t\tif (res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL)\n\t\t\tserver->caps |= NFS_CAP_SECURITY_LABEL;\n#endif\n\t\tmemcpy(server->attr_bitmask_nl, res.attr_bitmask,\n\t\t\t\tsizeof(server->attr_bitmask));\n\t\tserver->attr_bitmask_nl[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\n\t\tmemcpy(server->cache_consistency_bitmask, res.attr_bitmask, sizeof(server->cache_consistency_bitmask));\n\t\tserver->cache_consistency_bitmask[0] &= FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE;\n\t\tserver->cache_consistency_bitmask[1] &= FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY;\n\t\tserver->cache_consistency_bitmask[2] = 0;\n\n\t\t/* Avoid a regression due to buggy server */\n\t\tfor (i = 0; i < ARRAY_SIZE(res.exclcreat_bitmask); i++)\n\t\t\tres.exclcreat_bitmask[i] &= res.attr_bitmask[i];\n\t\tmemcpy(server->exclcreat_bitmask, res.exclcreat_bitmask,\n\t\t\tsizeof(server->exclcreat_bitmask));\n\n\t\tserver->acl_bitmask = res.acl_bitmask;\n\t\tserver->fh_expire_type = res.fh_expire_type;\n\t}\n\n\treturn status;\n}\n\nint nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_server_capabilities(server, fhandle),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tu32 bitmask[3];\n\tstruct nfs4_lookup_root_arg args = {\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = info->fattr,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP_ROOT],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tbitmask[0] = nfs4_fattr_bitmap[0];\n\tbitmask[1] = nfs4_fattr_bitmap[1];\n\t/*\n\t * Process the label in the upcoming getfattr\n\t */\n\tbitmask[2] = nfs4_fattr_bitmap[2] & ~FATTR4_WORD2_SECURITY_LABEL;\n\n\tnfs_fattr_init(info->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_lookup_root(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *info)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_lookup_root(server, fhandle, info);\n\t\ttrace_nfs4_lookup_root(server, fhandle, info->fattr, err);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fsinfo *info, rpc_authflavor_t flavor)\n{\n\tstruct rpc_auth_create_args auth_args = {\n\t\t.pseudoflavor = flavor,\n\t};\n\tstruct rpc_auth *auth;\n\n\tauth = rpcauth_create(&auth_args, server->client);\n\tif (IS_ERR(auth))\n\t\treturn -EACCES;\n\treturn nfs4_lookup_root(server, fhandle, info);\n}\n\n/*\n * Retry pseudoroot lookup with various security flavors.  We do this when:\n *\n *   NFSv4.0: the PUTROOTFH operation returns NFS4ERR_WRONGSEC\n *   NFSv4.1: the server does not support the SECINFO_NO_NAME operation\n *\n * Returns zero on success, or a negative NFS4ERR value, or a\n * negative errno value.\n */\nstatic int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\t/* Per 3530bis 15.33.5 */\n\tstatic const rpc_authflavor_t flav_array[] = {\n\t\tRPC_AUTH_GSS_KRB5P,\n\t\tRPC_AUTH_GSS_KRB5I,\n\t\tRPC_AUTH_GSS_KRB5,\n\t\tRPC_AUTH_UNIX,\t\t\t/* courtesy */\n\t\tRPC_AUTH_NULL,\n\t};\n\tint status = -EPERM;\n\tsize_t i;\n\n\tif (server->auth_info.flavor_len > 0) {\n\t\t/* try each flavor specified by user */\n\t\tfor (i = 0; i < server->auth_info.flavor_len; i++) {\n\t\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info,\n\t\t\t\t\t\tserver->auth_info.flavors[i]);\n\t\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* no flavors specified by user, try default list */\n\t\tfor (i = 0; i < ARRAY_SIZE(flav_array); i++) {\n\t\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info,\n\t\t\t\t\t\t      flav_array[i]);\n\t\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * -EACCES could mean that the user doesn't have correct permissions\n\t * to access the mount.  It could also mean that we tried to mount\n\t * with a gss auth flavor, but rpc.gssd isn't running.  Either way,\n\t * existing mount programs don't handle -EACCES very well so it should\n\t * be mapped to -EPERM instead.\n\t */\n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}\n\n/**\n * nfs4_proc_get_rootfh - get file handle for server's pseudoroot\n * @server: initialized nfs_server handle\n * @fhandle: we fill in the pseudo-fs root file handle\n * @info: we fill in an FSINFO struct\n * @auth_probe: probe the auth flavours\n *\n * Returns zero on success, or a negative errno.\n */\nint nfs4_proc_get_rootfh(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t struct nfs_fsinfo *info,\n\t\t\t bool auth_probe)\n{\n\tint status = 0;\n\n\tif (!auth_probe)\n\t\tstatus = nfs4_lookup_root(server, fhandle, info);\n\n\tif (auth_probe || status == NFS4ERR_WRONGSEC)\n\t\tstatus = server->nfs_client->cl_mvops->find_root_sec(server,\n\t\t\t\tfhandle, info);\n\n\tif (status == 0)\n\t\tstatus = nfs4_server_capabilities(server, fhandle);\n\tif (status == 0)\n\t\tstatus = nfs4_do_fsinfo(server, fhandle, info);\n\n\treturn nfs4_map_errors(status);\n}\n\nstatic int nfs4_proc_get_root(struct nfs_server *server, struct nfs_fh *mntfh,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint error;\n\tstruct nfs_fattr *fattr = info->fattr;\n\tstruct nfs4_label *label = fattr->label;\n\n\terror = nfs4_server_capabilities(server, mntfh);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getcaps error = %d\\n\", -error);\n\t\treturn error;\n\t}\n\n\terror = nfs4_proc_getattr(server, mntfh, fattr, label, NULL);\n\tif (error < 0) {\n\t\tdprintk(\"nfs4_get_root: getattr error = %d\\n\", -error);\n\t\tgoto out;\n\t}\n\n\tif (fattr->valid & NFS_ATTR_FATTR_FSID &&\n\t    !nfs_fsid_equal(&server->fsid, &fattr->fsid))\n\t\tmemcpy(&server->fsid, &fattr->fsid, sizeof(server->fsid));\n\nout:\n\treturn error;\n}\n\n/*\n * Get locations and (maybe) other attributes of a referral.\n * Note that we'll actually follow the referral later when\n * we detect fsid mismatch in inode revalidation\n */\nstatic int nfs4_get_referral(struct rpc_clnt *client, struct inode *dir,\n\t\t\t     const struct qstr *name, struct nfs_fattr *fattr,\n\t\t\t     struct nfs_fh *fhandle)\n{\n\tint status = -ENOMEM;\n\tstruct page *page = NULL;\n\tstruct nfs4_fs_locations *locations = NULL;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\tlocations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (locations == NULL)\n\t\tgoto out;\n\n\tstatus = nfs4_proc_fs_locations(client, dir, name, locations, page);\n\tif (status != 0)\n\t\tgoto out;\n\n\t/*\n\t * If the fsid didn't change, this is a migration event, not a\n\t * referral.  Cause us to drop into the exception handler, which\n\t * will kick off migration recovery.\n\t */\n\tif (nfs_fsid_equal(&NFS_SERVER(dir)->fsid, &locations->fattr.fsid)) {\n\t\tdprintk(\"%s: server did not return a different fsid for\"\n\t\t\t\" a referral at %s\\n\", __func__, name->name);\n\t\tstatus = -NFS4ERR_MOVED;\n\t\tgoto out;\n\t}\n\t/* Fixup attributes for the nfs_lookup() call to nfs_fhget() */\n\tnfs_fixup_referral_attributes(&locations->fattr);\n\n\t/* replace the lookup nfs_fattr with the locations nfs_fattr */\n\tmemcpy(fattr, &locations->fattr, sizeof(struct nfs_fattr));\n\tmemset(fhandle, 0, sizeof(struct nfs_fh));\nout:\n\tif (page)\n\t\t__free_page(page);\n\tkfree(locations);\n\treturn status;\n}\n\nstatic int _nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr, struct nfs4_label *label,\n\t\t\t\tstruct inode *inode)\n{\n\t__u32 bitmask[NFS4_BITMASK_SZ];\n\tstruct nfs4_getattr_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr = fattr,\n\t\t.label = label,\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned short task_flags = 0;\n\n\t/* Is this is an attribute revalidation, subject to softreval? */\n\tif (inode && (server->flags & NFS_MOUNT_SOFTREVAL))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\tnfs4_bitmap_copy_adjust(bitmask, nfs4_bitmask(server, label), inode);\n\n\tnfs_fattr_init(fattr);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\treturn nfs4_do_call_sync(server->client, server, &msg,\n\t\t\t&args.seq_args, &res.seq_res, task_flags);\n}\n\nint nfs4_proc_getattr(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fattr *fattr, struct nfs4_label *label,\n\t\t\t\tstruct inode *inode)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_getattr(server, fhandle, fattr, label, inode);\n\t\ttrace_nfs4_getattr(server, fhandle, fattr, err);\n\t\terr = nfs4_handle_exception(server, err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/* \n * The file is not closed if it is opened due to the a request to change\n * the size of the file. The open call will not be needed once the\n * VFS layer lookup-intents are implemented.\n *\n * Close is called when the inode is destroyed.\n * If we haven't opened the file for O_WRONLY, we\n * need to in the size_change case to obtain a stateid.\n *\n * Got race?\n * Because OPEN is always done by name in nfsv4, it is\n * possible that we opened a different file by the same\n * name.  We can recognize this race condition, but we\n * can't do anything about it besides returning an error.\n *\n * This will be fixed with VFS changes (lookup-intent).\n */\nstatic int\nnfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct cred *cred = NULL;\n\tstruct nfs_open_context *ctx = NULL;\n\tstruct nfs4_label *label = NULL;\n\tint status;\n\n\tif (pnfs_ld_layoutret_on_setattr(inode) &&\n\t    sattr->ia_valid & ATTR_SIZE &&\n\t    sattr->ia_size < i_size_read(inode))\n\t\tpnfs_commit_and_return_layout(inode);\n\n\tnfs_fattr_init(fattr);\n\t\n\t/* Deal with open(O_TRUNC) */\n\tif (sattr->ia_valid & ATTR_OPEN)\n\t\tsattr->ia_valid &= ~(ATTR_MTIME|ATTR_CTIME);\n\n\t/* Optimization: if the end result is no change, don't RPC */\n\tif ((sattr->ia_valid & ~(ATTR_FILE|ATTR_OPEN)) == 0)\n\t\treturn 0;\n\n\t/* Search for an existing open(O_WRITE) file */\n\tif (sattr->ia_valid & ATTR_FILE) {\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx)\n\t\t\tcred = ctx->cred;\n\t}\n\n\tlabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(label))\n\t\treturn PTR_ERR(label);\n\n\t/* Return any delegations if we're going to change ACLs */\n\tif ((sattr->ia_valid & (ATTR_MODE|ATTR_UID|ATTR_GID)) != 0)\n\t\tnfs4_inode_make_writeable(inode);\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, ctx, NULL, label);\n\tif (status == 0) {\n\t\tnfs_setattr_update_inode(inode, sattr, fattr);\n\t\tnfs_setsecurity(inode, fattr, label);\n\t}\n\tnfs4_label_free(label);\n\treturn status;\n}\n\nstatic int _nfs4_proc_lookup(struct rpc_clnt *clnt, struct inode *dir,\n\t\tstruct dentry *dentry, struct nfs_fh *fhandle,\n\t\tstruct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tint\t\t       status;\n\tstruct nfs4_lookup_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = &dentry->d_name,\n\t};\n\tstruct nfs4_lookup_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.label = label,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned short task_flags = 0;\n\n\t/* Is this is an attribute revalidation, subject to softreval? */\n\tif (nfs_lookup_is_soft_revalidate(dentry))\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\targs.bitmask = nfs4_bitmask(server, label);\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookup %pd2\\n\", dentry);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\tstatus = nfs4_do_call_sync(clnt, server, &msg,\n\t\t\t&args.seq_args, &res.seq_res, task_flags);\n\tdprintk(\"NFS reply lookup: %d\\n\", status);\n\treturn status;\n}\n\nstatic void nfs_fixup_secinfo_attributes(struct nfs_fattr *fattr)\n{\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_MOUNTPOINT;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int nfs4_proc_lookup_common(struct rpc_clnt **clnt, struct inode *dir,\n\t\t\t\t   struct dentry *dentry, struct nfs_fh *fhandle,\n\t\t\t\t   struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct rpc_clnt *client = *clnt;\n\tconst struct qstr *name = &dentry->d_name;\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookup(client, dir, dentry, fhandle, fattr, label);\n\t\ttrace_nfs4_lookup(dir, name, err);\n\t\tswitch (err) {\n\t\tcase -NFS4ERR_BADNAME:\n\t\t\terr = -ENOENT;\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_MOVED:\n\t\t\terr = nfs4_get_referral(client, dir, name, fattr, fhandle);\n\t\t\tif (err == -NFS4ERR_MOVED)\n\t\t\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err, &exception);\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\t\terr = -EPERM;\n\t\t\tif (client != *clnt)\n\t\t\t\tgoto out;\n\t\t\tclient = nfs4_negotiate_security(client, dir, name);\n\t\t\tif (IS_ERR(client))\n\t\t\t\treturn PTR_ERR(client);\n\n\t\t\texception.retry = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err, &exception);\n\t\t}\n\t} while (exception.retry);\n\nout:\n\tif (err == 0)\n\t\t*clnt = client;\n\telse if (client != *clnt)\n\t\trpc_shutdown_client(client);\n\n\treturn err;\n}\n\nstatic int nfs4_proc_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr,\n\t\t\t    struct nfs4_label *label)\n{\n\tint status;\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, dentry, fhandle, fattr, label);\n\tif (client != NFS_CLIENT(dir)) {\n\t\trpc_shutdown_client(client);\n\t\tnfs_fixup_secinfo_attributes(fattr);\n\t}\n\treturn status;\n}\n\nstruct rpc_clnt *\nnfs4_proc_lookup_mountpoint(struct inode *dir, struct dentry *dentry,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\tint status;\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, dentry, fhandle, fattr, NULL);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\treturn (client == NFS_CLIENT(dir)) ? rpc_clone_client(client) : client;\n}\n\nstatic int _nfs4_proc_lookupp(struct inode *inode,\n\t\tstruct nfs_fh *fhandle, struct nfs_fattr *fattr,\n\t\tstruct nfs4_label *label)\n{\n\tstruct rpc_clnt *clnt = NFS_CLIENT(inode);\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint\t\t       status;\n\tstruct nfs4_lookupp_arg args = {\n\t\t.bitmask = server->attr_bitmask,\n\t\t.fh = NFS_FH(inode),\n\t};\n\tstruct nfs4_lookupp_res res = {\n\t\t.server = server,\n\t\t.fattr = fattr,\n\t\t.label = label,\n\t\t.fh = fhandle,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOOKUPP],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned short task_flags = 0;\n\n\tif (NFS_SERVER(inode)->flags & NFS_MOUNT_SOFTREVAL)\n\t\ttask_flags |= RPC_TASK_TIMEOUT;\n\n\targs.bitmask = nfs4_bitmask(server, label);\n\n\tnfs_fattr_init(fattr);\n\n\tdprintk(\"NFS call  lookupp ino=0x%lx\\n\", inode->i_ino);\n\tstatus = nfs4_call_sync(clnt, server, &msg, &args.seq_args,\n\t\t\t\t&res.seq_res, task_flags);\n\tdprintk(\"NFS reply lookupp: %d\\n\", status);\n\treturn status;\n}\n\nstatic int nfs4_proc_lookupp(struct inode *inode, struct nfs_fh *fhandle,\n\t\t\t     struct nfs_fattr *fattr, struct nfs4_label *label)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_lookupp(inode, fhandle, fattr, label);\n\t\ttrace_nfs4_lookupp(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.access = entry->mask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint status = 0;\n\n\tif (!nfs4_have_delegation(inode, FMODE_READ)) {\n\t\tres.fattr = nfs_alloc_fattr();\n\t\tif (res.fattr == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.bitmask = server->cache_consistency_bitmask;\n\t}\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (!status) {\n\t\tnfs_access_set_mask(entry, res.access);\n\t\tif (res.fattr)\n\t\t\tnfs_refresh_inode(inode, res.fattr);\n\t}\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_access(inode, entry);\n\t\ttrace_nfs4_access(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * TODO: For the time being, we don't try to get any attributes\n * along with any of the zero-copy operations READ, READDIR,\n * READLINK, WRITE.\n *\n * In the case of the first three, we want to put the GETATTR\n * after the read-type operation -- this is because it is hard\n * to predict the length of a GETATTR response in v4, and thus\n * align the READ data correctly.  This means that the GETATTR\n * may end up partially falling into the page cache, and we should\n * shift it into the 'tail' of the xdr_buf before processing.\n * To do this efficiently, we need to know the total length\n * of data received, which doesn't seem to be available outside\n * of the RPC layer.\n *\n * In the case of WRITE, we also want to put the GETATTR after\n * the operation -- in this case because we want to make sure\n * we get the post-operation mtime and size.\n *\n * Both of these changes to the XDR layer would in fact be quite\n * minor, but I decided to leave them for a subsequent patch.\n */\nstatic int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct nfs4_readlink_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_readlink(inode, page, pgbase, pglen);\n\t\ttrace_nfs4_readlink(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * This is just for mknod.  open(O_CREAT) will always do ->open_context().\n */\nstatic int\nnfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\t int flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_label l, *ilabel = NULL;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tint status = 0;\n\n\tctx = alloc_nfs_open_context(dentry, FMODE_READ, NULL);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tilabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\tsattr->ia_mode &= ~current_umask();\n\tstate = nfs4_do_open(dir, ctx, flags, sattr, ilabel, NULL);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out;\n\t}\nout:\n\tnfs4_label_release_security(ilabel);\n\tput_nfs_open_context(ctx);\n\treturn status;\n}\n\nstatic int\n_nfs4_proc_remove(struct inode *dir, const struct qstr *name, u32 ftype)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.name = *name,\n\t};\n\tstruct nfs_removeres res = {\n\t\t.server = server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned long timestamp = jiffies;\n\tint status;\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 1);\n\tif (status == 0) {\n\t\tspin_lock(&dir->i_lock);\n\t\tnfs4_update_changeattr_locked(dir, &res.cinfo, timestamp,\n\t\t\t\t\t      NFS_INO_INVALID_DATA);\n\t\t/* Removing a directory decrements nlink in the parent */\n\t\tif (ftype == NF4DIR && dir->i_nlink > 2)\n\t\t\tnfs4_dec_nlink_locked(dir);\n\t\tspin_unlock(&dir->i_lock);\n\t}\n\treturn status;\n}\n\nstatic int nfs4_proc_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct inode *inode = d_inode(dentry);\n\tint err;\n\n\tif (inode) {\n\t\tif (inode->i_nlink == 1)\n\t\t\tnfs4_inode_return_delegation(inode);\n\t\telse\n\t\t\tnfs4_inode_make_writeable(inode);\n\t}\n\tdo {\n\t\terr = _nfs4_proc_remove(dir, &dentry->d_name, NF4REG);\n\t\ttrace_nfs4_remove(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_rmdir(struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_remove(dir, name, NF4DIR);\n\t\ttrace_nfs4_remove(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic void nfs4_proc_unlink_setup(struct rpc_message *msg,\n\t\tstruct dentry *dentry,\n\t\tstruct inode *inode)\n{\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\tres->server = NFS_SB(dentry->d_sb);\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n\tnfs4_init_sequence(&args->seq_args, &res->seq_res, 1, 0);\n\n\tnfs_fattr_init(res->dir_attr);\n\n\tif (inode)\n\t\tnfs4_inode_return_delegation(inode);\n}\n\nstatic void nfs4_proc_unlink_rpc_prepare(struct rpc_task *task, struct nfs_unlinkdata *data)\n{\n\tnfs4_setup_sequence(NFS_SB(data->dentry->d_sb)->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs4_proc_unlink_done(struct rpc_task *task, struct inode *dir)\n{\n\tstruct nfs_unlinkdata *data = task->tk_calldata;\n\tstruct nfs_removeres *res = &data->res;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL,\n\t\t\t\t    &data->timeout) == -EAGAIN)\n\t\treturn 0;\n\tif (task->tk_status == 0)\n\t\tnfs4_update_changeattr(dir, &res->cinfo,\n\t\t\t\tres->dir_attr->time_start,\n\t\t\t\tNFS_INO_INVALID_DATA);\n\treturn 1;\n}\n\nstatic void nfs4_proc_rename_setup(struct rpc_message *msg,\n\t\tstruct dentry *old_dentry,\n\t\tstruct dentry *new_dentry)\n{\n\tstruct nfs_renameargs *arg = msg->rpc_argp;\n\tstruct nfs_renameres *res = msg->rpc_resp;\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\n\tif (old_inode)\n\t\tnfs4_inode_make_writeable(old_inode);\n\tif (new_inode)\n\t\tnfs4_inode_return_delegation(new_inode);\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RENAME];\n\tres->server = NFS_SB(old_dentry->d_sb);\n\tnfs4_init_sequence(&arg->seq_args, &res->seq_res, 1, 0);\n}\n\nstatic void nfs4_proc_rename_rpc_prepare(struct rpc_task *task, struct nfs_renamedata *data)\n{\n\tnfs4_setup_sequence(NFS_SERVER(data->old_dir)->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs4_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t\t\t struct inode *new_dir)\n{\n\tstruct nfs_renamedata *data = task->tk_calldata;\n\tstruct nfs_renameres *res = &data->res;\n\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL, &data->timeout) == -EAGAIN)\n\t\treturn 0;\n\n\tif (task->tk_status == 0) {\n\t\tif (new_dir != old_dir) {\n\t\t\t/* Note: If we moved a directory, nlink will change */\n\t\t\tnfs4_update_changeattr(old_dir, &res->old_cinfo,\n\t\t\t\t\tres->old_fattr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_OTHER |\n\t\t\t\t\t    NFS_INO_INVALID_DATA);\n\t\t\tnfs4_update_changeattr(new_dir, &res->new_cinfo,\n\t\t\t\t\tres->new_fattr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_OTHER |\n\t\t\t\t\t    NFS_INO_INVALID_DATA);\n\t\t} else\n\t\t\tnfs4_update_changeattr(old_dir, &res->old_cinfo,\n\t\t\t\t\tres->old_fattr->time_start,\n\t\t\t\t\tNFS_INO_INVALID_DATA);\n\t}\n\treturn 1;\n}\n\nstatic int _nfs4_proc_link(struct inode *inode, struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\t__u32 bitmask[NFS4_BITMASK_SZ];\n\tstruct nfs4_link_arg arg = {\n\t\t.fh     = NFS_FH(inode),\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_link_res res = {\n\t\t.server = server,\n\t\t.label = NULL,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LINK],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t};\n\tint status = -ENOMEM;\n\n\tres.fattr = nfs_alloc_fattr();\n\tif (res.fattr == NULL)\n\t\tgoto out;\n\n\tres.label = nfs4_label_alloc(server, GFP_KERNEL);\n\tif (IS_ERR(res.label)) {\n\t\tstatus = PTR_ERR(res.label);\n\t\tgoto out;\n\t}\n\n\tnfs4_inode_make_writeable(inode);\n\tnfs4_bitmap_copy_adjust_setattr(bitmask, nfs4_bitmask(server, res.label), inode);\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (!status) {\n\t\tnfs4_update_changeattr(dir, &res.cinfo, res.fattr->time_start,\n\t\t\t\t       NFS_INO_INVALID_DATA);\n\t\tstatus = nfs_post_op_update_inode(inode, res.fattr);\n\t\tif (!status)\n\t\t\tnfs_setsecurity(inode, res.fattr, res.label);\n\t}\n\n\n\tnfs4_label_free(res.label);\n\nout:\n\tnfs_free_fattr(res.fattr);\n\treturn status;\n}\n\nstatic int nfs4_proc_link(struct inode *inode, struct inode *dir, const struct qstr *name)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode),\n\t\t\t\t_nfs4_proc_link(inode, dir, name),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs4_createdata {\n\tstruct rpc_message msg;\n\tstruct nfs4_create_arg arg;\n\tstruct nfs4_create_res res;\n\tstruct nfs_fh fh;\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_label *label;\n};\n\nstatic struct nfs4_createdata *nfs4_alloc_createdata(struct inode *dir,\n\t\tconst struct qstr *name, struct iattr *sattr, u32 ftype)\n{\n\tstruct nfs4_createdata *data;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (data != NULL) {\n\t\tstruct nfs_server *server = NFS_SERVER(dir);\n\n\t\tdata->label = nfs4_label_alloc(server, GFP_KERNEL);\n\t\tif (IS_ERR(data->label))\n\t\t\tgoto out_free;\n\n\t\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE];\n\t\tdata->msg.rpc_argp = &data->arg;\n\t\tdata->msg.rpc_resp = &data->res;\n\t\tdata->arg.dir_fh = NFS_FH(dir);\n\t\tdata->arg.server = server;\n\t\tdata->arg.name = name;\n\t\tdata->arg.attrs = sattr;\n\t\tdata->arg.ftype = ftype;\n\t\tdata->arg.bitmask = nfs4_bitmask(server, data->label);\n\t\tdata->arg.umask = current_umask();\n\t\tdata->res.server = server;\n\t\tdata->res.fh = &data->fh;\n\t\tdata->res.fattr = &data->fattr;\n\t\tdata->res.label = data->label;\n\t\tnfs_fattr_init(data->res.fattr);\n\t}\n\treturn data;\nout_free:\n\tkfree(data);\n\treturn NULL;\n}\n\nstatic int nfs4_do_create(struct inode *dir, struct dentry *dentry, struct nfs4_createdata *data)\n{\n\tint status = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &data->msg,\n\t\t\t\t    &data->arg.seq_args, &data->res.seq_res, 1);\n\tif (status == 0) {\n\t\tspin_lock(&dir->i_lock);\n\t\tnfs4_update_changeattr_locked(dir, &data->res.dir_cinfo,\n\t\t\t\tdata->res.fattr->time_start,\n\t\t\t\tNFS_INO_INVALID_DATA);\n\t\t/* Creating a directory bumps nlink in the parent */\n\t\tif (data->arg.ftype == NF4DIR)\n\t\t\tnfs4_inc_nlink_locked(dir);\n\t\tspin_unlock(&dir->i_lock);\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr, data->res.label);\n\t}\n\treturn status;\n}\n\nstatic void nfs4_free_createdata(struct nfs4_createdata *data)\n{\n\tnfs4_label_free(data->label);\n\tkfree(data);\n}\n\nstatic int _nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr,\n\t\tstruct nfs4_label *label)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENAMETOOLONG;\n\n\tif (len > NFS4_MAXPATHLEN)\n\t\tgoto out;\n\n\tstatus = -ENOMEM;\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4LNK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SYMLINK];\n\tdata->arg.u.symlink.pages = &page;\n\tdata->arg.u.symlink.len = len;\n\tdata->arg.label = label;\n\t\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_symlink(struct inode *dir, struct dentry *dentry,\n\t\tstruct page *page, unsigned int len, struct iattr *sattr)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_label l, *label = NULL;\n\tint err;\n\n\tlabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tdo {\n\t\terr = _nfs4_proc_symlink(dir, dentry, page, len, sattr, label);\n\t\ttrace_nfs4_symlink(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tnfs4_label_release_security(label);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, struct nfs4_label *label)\n{\n\tstruct nfs4_createdata *data;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4DIR);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tdata->arg.label = label;\n\tstatus = nfs4_do_create(dir, dentry, data);\n\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_label l, *label = NULL;\n\tint err;\n\n\tlabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = _nfs4_proc_mkdir(dir, dentry, sattr, label);\n\t\ttrace_nfs4_mkdir(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\tnfs4_label_release_security(label);\n\n\treturn err;\n}\n\nstatic int _nfs4_proc_readdir(struct nfs_readdir_arg *nr_arg,\n\t\t\t      struct nfs_readdir_res *nr_res)\n{\n\tstruct inode\t\t*dir = d_inode(nr_arg->dentry);\n\tstruct nfs_server\t*server = NFS_SERVER(dir);\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = nr_arg->pages,\n\t\t.pgbase = 0,\n\t\t.count = nr_arg->page_len,\n\t\t.plus = nr_arg->plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = nr_arg->cred,\n\t};\n\tint\t\t\tstatus;\n\n\tdprintk(\"%s: dentry = %pd2, cookie = %llu\\n\", __func__,\n\t\tnr_arg->dentry, (unsigned long long)nr_arg->cookie);\n\tif (!(server->caps & NFS_CAP_SECURITY_LABEL))\n\t\targs.bitmask = server->attr_bitmask_nl;\n\telse\n\t\targs.bitmask = server->attr_bitmask;\n\n\tnfs4_setup_readdir(nr_arg->cookie, nr_arg->verf, nr_arg->dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args,\n\t\t\t&res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(nr_res->verf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\n\tnfs_invalidate_atime(dir);\n\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int nfs4_proc_readdir(struct nfs_readdir_arg *arg,\n\t\t\t     struct nfs_readdir_res *res)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_readdir(arg, res);\n\t\ttrace_nfs4_readdir(d_inode(arg->dentry), err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(d_inode(arg->dentry)),\n\t\t\t\t\t    err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, struct nfs4_label *label, dev_t rdev)\n{\n\tstruct nfs4_createdata *data;\n\tint mode = sattr->ia_mode;\n\tint status = -ENOMEM;\n\n\tdata = nfs4_alloc_createdata(dir, &dentry->d_name, sattr, NF4SOCK);\n\tif (data == NULL)\n\t\tgoto out;\n\n\tif (S_ISFIFO(mode))\n\t\tdata->arg.ftype = NF4FIFO;\n\telse if (S_ISBLK(mode)) {\n\t\tdata->arg.ftype = NF4BLK;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t}\n\telse if (S_ISCHR(mode)) {\n\t\tdata->arg.ftype = NF4CHR;\n\t\tdata->arg.u.device.specdata1 = MAJOR(rdev);\n\t\tdata->arg.u.device.specdata2 = MINOR(rdev);\n\t} else if (!S_ISSOCK(mode)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tdata->arg.label = label;\n\tstatus = nfs4_do_create(dir, dentry, data);\nout_free:\n\tnfs4_free_createdata(data);\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_mknod(struct inode *dir, struct dentry *dentry,\n\t\tstruct iattr *sattr, dev_t rdev)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tstruct nfs4_label l, *label = NULL;\n\tint err;\n\n\tlabel = nfs4_label_init_security(dir, dentry, sattr, &l);\n\n\tif (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))\n\t\tsattr->ia_mode &= ~current_umask();\n\tdo {\n\t\terr = _nfs4_proc_mknod(dir, dentry, sattr, label, rdev);\n\t\ttrace_nfs4_mknod(dir, &dentry->d_name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tnfs4_label_release_security(label);\n\n\treturn err;\n}\n\nstatic int _nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_statfs_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_statfs_res res = {\n\t\t.fsstat = fsstat,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_STATFS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tnfs_fattr_init(fsstat->fattr);\n\treturn  nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_statfs(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsstat *fsstat)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_statfs(server, fhandle, fsstat),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_fsinfo_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_fsinfo_res res = {\n\t\t.fsinfo = fsinfo,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_do_fsinfo(server, fhandle, fsinfo);\n\t\ttrace_nfs4_fsinfo(server, fhandle, fsinfo->fattr, err);\n\t\tif (err == 0) {\n\t\t\tnfs4_set_lease_period(server->nfs_client, fsinfo->lease_time * HZ);\n\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\t/* block layout checks this! */\n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo);\n\t}\n\n\treturn error;\n}\n\nstatic int _nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_pathconf_arg args = {\n\t\t.fh = fhandle,\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_pathconf_res res = {\n\t\t.pathconf = pathconf,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_PATHCONF],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\t/* None of the pathconf attributes are mandatory to implement */\n\tif ((args.bitmask[0] & nfs4_pathconf_bitmap[0]) == 0) {\n\t\tmemset(pathconf, 0, sizeof(*pathconf));\n\t\treturn 0;\n\t}\n\n\tnfs_fattr_init(pathconf->fattr);\n\treturn nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n}\n\nstatic int nfs4_proc_pathconf(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\tstruct nfs_pathconf *pathconf)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_proc_pathconf(server, fhandle, pathconf),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nint nfs4_set_rw_stateid(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\treturn nfs4_select_rw_stateid(ctx->state, fmode, l_ctx, stateid, NULL);\n}\nEXPORT_SYMBOL_GPL(nfs4_set_rw_stateid);\n\nstatic bool nfs4_stateid_is_current(nfs4_stateid *stateid,\n\t\tconst struct nfs_open_context *ctx,\n\t\tconst struct nfs_lock_context *l_ctx,\n\t\tfmode_t fmode)\n{\n\tnfs4_stateid _current_stateid;\n\n\t/* If the current stateid represents a lost lock, then exit */\n\tif (nfs4_set_rw_stateid(&_current_stateid, ctx, l_ctx, fmode) == -EIO)\n\t\treturn true;\n\treturn nfs4_stateid_match(stateid, &_current_stateid);\n}\n\nstatic bool nfs4_error_stateid_expired(int err)\n{\n\tswitch (err) {\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_OLD_STATEID:\n\tcase -NFS4ERR_OPENMODE:\n\tcase -NFS4ERR_EXPIRED:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int nfs4_read_done_cb(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_server *server = NFS_SERVER(hdr->inode);\n\n\ttrace_nfs4_read(hdr, task->tk_status);\n\tif (task->tk_status < 0) {\n\t\tstruct nfs4_exception exception = {\n\t\t\t.inode = hdr->inode,\n\t\t\t.state = hdr->args.context->state,\n\t\t\t.stateid = &hdr->args.stateid,\n\t\t};\n\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\tserver, task->tk_status, &exception);\n\t\tif (exception.retry) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (task->tk_status > 0)\n\t\trenew_lease(server, hdr->timestamp);\n\treturn 0;\n}\n\nstatic bool nfs4_read_stateid_changed(struct rpc_task *task,\n\t\tstruct nfs_pgio_args *args)\n{\n\n\tif (!nfs4_error_stateid_expired(task->tk_status) ||\n\t\tnfs4_stateid_is_current(&args->stateid,\n\t\t\t\targs->context,\n\t\t\t\targs->lock_context,\n\t\t\t\tFMODE_READ))\n\t\treturn false;\n\trpc_restart_call_prepare(task);\n\treturn true;\n}\n\nstatic bool nfs4_read_plus_not_supported(struct rpc_task *task,\n\t\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_server *server = NFS_SERVER(hdr->inode);\n\tstruct rpc_message *msg = &task->tk_msg;\n\n\tif (msg->rpc_proc == &nfs4_procedures[NFSPROC4_CLNT_READ_PLUS] &&\n\t    server->caps & NFS_CAP_READ_PLUS && task->tk_status == -ENOTSUPP) {\n\t\tserver->caps &= ~NFS_CAP_READ_PLUS;\n\t\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\t\trpc_restart_call_prepare(task);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int nfs4_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &hdr->res.seq_res))\n\t\treturn -EAGAIN;\n\tif (nfs4_read_stateid_changed(task, &hdr->args))\n\t\treturn -EAGAIN;\n\tif (nfs4_read_plus_not_supported(task, hdr))\n\t\treturn -EAGAIN;\n\tif (task->tk_status > 0)\n\t\tnfs_invalidate_atime(hdr->inode);\n\treturn hdr->pgio_done_cb ? hdr->pgio_done_cb(task, hdr) :\n\t\t\t\t    nfs4_read_done_cb(task, hdr);\n}\n\n#if defined CONFIG_NFS_V4_2 && defined CONFIG_NFS_V4_2_READ_PLUS\nstatic void nfs42_read_plus_support(struct nfs_pgio_header *hdr,\n\t\t\t\t    struct rpc_message *msg)\n{\n\t/* Note: We don't use READ_PLUS with pNFS yet */\n\tif (nfs_server_capable(hdr->inode, NFS_CAP_READ_PLUS) && !hdr->ds_clp)\n\t\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ_PLUS];\n}\n#else\nstatic void nfs42_read_plus_support(struct nfs_pgio_header *hdr,\n\t\t\t\t    struct rpc_message *msg)\n{\n}\n#endif /* CONFIG_NFS_V4_2 */\n\nstatic void nfs4_proc_read_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t struct rpc_message *msg)\n{\n\thdr->timestamp   = jiffies;\n\tif (!hdr->pgio_done_cb)\n\t\thdr->pgio_done_cb = nfs4_read_done_cb;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\tnfs42_read_plus_support(hdr, msg);\n\tnfs4_init_sequence(&hdr->args.seq_args, &hdr->res.seq_res, 0, 0);\n}\n\nstatic int nfs4_proc_pgio_rpc_prepare(struct rpc_task *task,\n\t\t\t\t      struct nfs_pgio_header *hdr)\n{\n\tif (nfs4_setup_sequence(NFS_SERVER(hdr->inode)->nfs_client,\n\t\t\t&hdr->args.seq_args,\n\t\t\t&hdr->res.seq_res,\n\t\t\ttask))\n\t\treturn 0;\n\tif (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,\n\t\t\t\thdr->args.lock_context,\n\t\t\t\thdr->rw_mode) == -EIO)\n\t\treturn -EIO;\n\tif (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int nfs4_write_done_cb(struct rpc_task *task,\n\t\t\t      struct nfs_pgio_header *hdr)\n{\n\tstruct inode *inode = hdr->inode;\n\n\ttrace_nfs4_write(hdr, task->tk_status);\n\tif (task->tk_status < 0) {\n\t\tstruct nfs4_exception exception = {\n\t\t\t.inode = hdr->inode,\n\t\t\t.state = hdr->args.context->state,\n\t\t\t.stateid = &hdr->args.stateid,\n\t\t};\n\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\tNFS_SERVER(inode), task->tk_status,\n\t\t\t\t&exception);\n\t\tif (exception.retry) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tif (task->tk_status >= 0) {\n\t\trenew_lease(NFS_SERVER(inode), hdr->timestamp);\n\t\tnfs_writeback_update_inode(hdr);\n\t}\n\treturn 0;\n}\n\nstatic bool nfs4_write_stateid_changed(struct rpc_task *task,\n\t\tstruct nfs_pgio_args *args)\n{\n\n\tif (!nfs4_error_stateid_expired(task->tk_status) ||\n\t\tnfs4_stateid_is_current(&args->stateid,\n\t\t\t\targs->context,\n\t\t\t\targs->lock_context,\n\t\t\t\tFMODE_WRITE))\n\t\treturn false;\n\trpc_restart_call_prepare(task);\n\treturn true;\n}\n\nstatic int nfs4_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)\n{\n\tif (!nfs4_sequence_done(task, &hdr->res.seq_res))\n\t\treturn -EAGAIN;\n\tif (nfs4_write_stateid_changed(task, &hdr->args))\n\t\treturn -EAGAIN;\n\treturn hdr->pgio_done_cb ? hdr->pgio_done_cb(task, hdr) :\n\t\tnfs4_write_done_cb(task, hdr);\n}\n\nstatic\nbool nfs4_write_need_cache_consistency_data(struct nfs_pgio_header *hdr)\n{\n\t/* Don't request attributes for pNFS or O_DIRECT writes */\n\tif (hdr->ds_clp != NULL || hdr->dreq != NULL)\n\t\treturn false;\n\t/* Otherwise, request attributes if and only if we don't hold\n\t * a delegation\n\t */\n\treturn nfs4_have_delegation(hdr->inode, FMODE_READ) == 0;\n}\n\nstatic void nfs4_bitmask_adjust(__u32 *bitmask, struct inode *inode,\n\t\t\t\tstruct nfs_server *server,\n\t\t\t\tstruct nfs4_label *label)\n{\n\n\tunsigned long cache_validity = READ_ONCE(NFS_I(inode)->cache_validity);\n\n\tif ((cache_validity & NFS_INO_INVALID_DATA) ||\n\t\t(cache_validity & NFS_INO_REVAL_PAGECACHE) ||\n\t\t(cache_validity & NFS_INO_REVAL_FORCED) ||\n\t\t(cache_validity & NFS_INO_INVALID_OTHER))\n\t\tnfs4_bitmap_copy_adjust(bitmask, nfs4_bitmask(server, label), inode);\n\n\tif (cache_validity & NFS_INO_INVALID_ATIME)\n\t\tbitmask[1] |= FATTR4_WORD1_TIME_ACCESS;\n\tif (cache_validity & NFS_INO_INVALID_ACCESS)\n\t\tbitmask[0] |= FATTR4_WORD1_MODE | FATTR4_WORD1_OWNER |\n\t\t\t\tFATTR4_WORD1_OWNER_GROUP;\n\tif (cache_validity & NFS_INO_INVALID_ACL)\n\t\tbitmask[0] |= FATTR4_WORD0_ACL;\n\tif (cache_validity & NFS_INO_INVALID_LABEL)\n\t\tbitmask[2] |= FATTR4_WORD2_SECURITY_LABEL;\n\tif (cache_validity & NFS_INO_INVALID_CTIME)\n\t\tbitmask[0] |= FATTR4_WORD0_CHANGE;\n\tif (cache_validity & NFS_INO_INVALID_MTIME)\n\t\tbitmask[1] |= FATTR4_WORD1_TIME_MODIFY;\n\tif (cache_validity & NFS_INO_INVALID_SIZE)\n\t\tbitmask[0] |= FATTR4_WORD0_SIZE;\n\tif (cache_validity & NFS_INO_INVALID_BLOCKS)\n\t\tbitmask[1] |= FATTR4_WORD1_SPACE_USED;\n}\n\nstatic void nfs4_proc_write_setup(struct nfs_pgio_header *hdr,\n\t\t\t\t  struct rpc_message *msg,\n\t\t\t\t  struct rpc_clnt **clnt)\n{\n\tstruct nfs_server *server = NFS_SERVER(hdr->inode);\n\n\tif (!nfs4_write_need_cache_consistency_data(hdr)) {\n\t\thdr->args.bitmask = NULL;\n\t\thdr->res.fattr = NULL;\n\t} else {\n\t\thdr->args.bitmask = server->cache_consistency_bitmask;\n\t\tnfs4_bitmask_adjust(hdr->args.bitmask, hdr->inode, server, NULL);\n\t}\n\n\tif (!hdr->pgio_done_cb)\n\t\thdr->pgio_done_cb = nfs4_write_done_cb;\n\thdr->res.server = server;\n\thdr->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n\tnfs4_init_sequence(&hdr->args.seq_args, &hdr->res.seq_res, 0, 0);\n\tnfs4_state_protect_write(server->nfs_client, clnt, msg, hdr);\n}\n\nstatic void nfs4_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tnfs4_setup_sequence(NFS_SERVER(data->inode)->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs4_commit_done_cb(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tstruct inode *inode = data->inode;\n\n\ttrace_nfs4_commit(data, task->tk_status);\n\tif (nfs4_async_handle_error(task, NFS_SERVER(inode),\n\t\t\t\t    NULL, NULL) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic int nfs4_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->commit_done_cb(task, data);\n}\n\nstatic void nfs4_proc_commit_setup(struct nfs_commit_data *data, struct rpc_message *msg,\n\t\t\t\t   struct rpc_clnt **clnt)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->inode);\n\n\tif (data->commit_done_cb == NULL)\n\t\tdata->commit_done_cb = nfs4_commit_done_cb;\n\tdata->res.server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT];\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, 0);\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_COMMIT, clnt, msg);\n}\n\nstatic int _nfs4_proc_commit(struct file *dst, struct nfs_commitargs *args,\n\t\t\t\tstruct nfs_commitres *res)\n{\n\tstruct inode *dst_inode = file_inode(dst);\n\tstruct nfs_server *server = NFS_SERVER(dst_inode);\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COMMIT],\n\t\t.rpc_argp = args,\n\t\t.rpc_resp = res,\n\t};\n\n\targs->fh = NFS_FH(dst_inode);\n\treturn nfs4_call_sync(server->client, server, &msg,\n\t\t\t&args->seq_args, &res->seq_res, 1);\n}\n\nint nfs4_proc_commit(struct file *dst, __u64 offset, __u32 count, struct nfs_commitres *res)\n{\n\tstruct nfs_commitargs args = {\n\t\t.offset = offset,\n\t\t.count = count,\n\t};\n\tstruct nfs_server *dst_server = NFS_SERVER(file_inode(dst));\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_proc_commit(dst, &args, res);\n\t\tstatus = nfs4_handle_exception(dst_server, status, &exception);\n\t} while (exception.retry);\n\n\treturn status;\n}\n\nstruct nfs4_renewdata {\n\tstruct nfs_client\t*client;\n\tunsigned long\t\ttimestamp;\n};\n\n/*\n * nfs4_proc_async_renew(): This is not one of the nfs_rpc_ops; it is a special\n * standalone procedure for queueing an asynchronous RENEW.\n */\nstatic void nfs4_renew_release(void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\n\tif (refcount_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(data);\n}\n\nstatic void nfs4_renew_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_renewdata *data = calldata;\n\tstruct nfs_client *clp = data->client;\n\tunsigned long timestamp = data->timestamp;\n\n\ttrace_nfs4_renew_async(clp, task->tk_status);\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\tbreak;\n\tcase -NFS4ERR_LEASE_MOVED:\n\t\tnfs4_schedule_lease_moved_recovery(clp);\n\t\tbreak;\n\tdefault:\n\t\t/* Unless we're shutting down, schedule state recovery! */\n\t\tif (test_bit(NFS_CS_RENEWD, &clp->cl_res_state) == 0)\n\t\t\treturn;\n\t\tif (task->tk_status != NFS4ERR_CB_PATH_DOWN) {\n\t\t\tnfs4_schedule_lease_recovery(clp);\n\t\t\treturn;\n\t\t}\n\t\tnfs4_schedule_path_down_recovery(clp);\n\t}\n\tdo_renew_lease(clp, timestamp);\n}\n\nstatic const struct rpc_call_ops nfs4_renew_ops = {\n\t.rpc_call_done = nfs4_renew_done,\n\t.rpc_release = nfs4_renew_release,\n};\n\nstatic int nfs4_proc_async_renew(struct nfs_client *clp, const struct cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct nfs4_renewdata *data;\n\n\tif (renew_flags == 0)\n\t\treturn 0;\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\treturn -EIO;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL) {\n\t\tnfs_put_client(clp);\n\t\treturn -ENOMEM;\n\t}\n\tdata->client = clp;\n\tdata->timestamp = jiffies;\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT,\n\t\t\t&nfs4_renew_ops, data);\n}\n\nstatic int nfs4_proc_renew(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status < 0)\n\t\treturn status;\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n\nstatic inline int nfs4_server_supports_acls(struct nfs_server *server)\n{\n\treturn server->caps & NFS_CAP_ACLS;\n}\n\n/* Assuming that XATTR_SIZE_MAX is a multiple of PAGE_SIZE, and that\n * it's OK to put sizeof(void) * (XATTR_SIZE_MAX/PAGE_SIZE) bytes on\n * the stack.\n */\n#define NFS4ACL_MAXPAGES DIV_ROUND_UP(XATTR_SIZE_MAX, PAGE_SIZE)\n\nint nfs4_buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\tstruct page **pages)\n{\n\tstruct page *newpage, **spages;\n\tint rc = 0;\n\tsize_t len;\n\tspages = pages;\n\n\tdo {\n\t\tlen = min_t(size_t, PAGE_SIZE, buflen);\n\t\tnewpage = alloc_page(GFP_KERNEL);\n\n\t\tif (newpage == NULL)\n\t\t\tgoto unwind;\n\t\tmemcpy(page_address(newpage), buf, len);\n\t\tbuf += len;\n\t\tbuflen -= len;\n\t\t*pages++ = newpage;\n\t\trc++;\n\t} while (buflen != 0);\n\n\treturn rc;\n\nunwind:\n\tfor(; rc > 0; rc--)\n\t\t__free_page(spages[rc-1]);\n\treturn -ENOMEM;\n}\n\nstruct nfs4_cached_acl {\n\tint cached;\n\tsize_t len;\n\tchar data[];\n};\n\nstatic void nfs4_set_cached_acl(struct inode *inode, struct nfs4_cached_acl *acl)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tspin_lock(&inode->i_lock);\n\tkfree(nfsi->nfs4_acl);\n\tnfsi->nfs4_acl = acl;\n\tspin_unlock(&inode->i_lock);\n}\n\nstatic void nfs4_zap_acl_attr(struct inode *inode)\n{\n\tnfs4_set_cached_acl(inode, NULL);\n}\n\nstatic inline ssize_t nfs4_read_cached_acl(struct inode *inode, char *buf, size_t buflen)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs4_cached_acl *acl;\n\tint ret = -ENOENT;\n\n\tspin_lock(&inode->i_lock);\n\tacl = nfsi->nfs4_acl;\n\tif (acl == NULL)\n\t\tgoto out;\n\tif (buf == NULL) /* user is just asking for length */\n\t\tgoto out_len;\n\tif (acl->cached == 0)\n\t\tgoto out;\n\tret = -ERANGE; /* see getxattr(2) man page */\n\tif (acl->len > buflen)\n\t\tgoto out;\n\tmemcpy(buf, acl->data, acl->len);\nout_len:\n\tret = acl->len;\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}\n\nstatic void nfs4_write_cached_acl(struct inode *inode, struct page **pages, size_t pgbase, size_t acl_len)\n{\n\tstruct nfs4_cached_acl *acl;\n\tsize_t buflen = sizeof(*acl) + acl_len;\n\n\tif (buflen <= PAGE_SIZE) {\n\t\tacl = kmalloc(buflen, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\t_copy_from_pages(acl->data, pages, pgbase, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->len = acl_len;\nout:\n\tnfs4_set_cached_acl(inode, acl);\n}\n\n/*\n * The getxattr API returns the required buffer length when called with a\n * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating\n * the required buf.  On a NULL buf, we send a page of data to the server\n * guessing that the ACL request can be serviced by a page. If so, we cache\n * up to the page of ACL data, and the 2nd call to getxattr is serviced by\n * the cache. If not so, we throw away the page, and cache the required\n * length. The next getxattr call will then produce another round trip to\n * the server, this time with the input buf of the required size.\n */\nstatic ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page **pages;\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages;\n\tint ret = -ENOMEM, i;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tif (buflen == 0)\n\t\tbuflen = server->rsize;\n\n\tnpages = DIV_ROUND_UP(buflen, PAGE_SIZE) + 1;\n\tpages = kmalloc_array(npages, sizeof(struct page *), GFP_NOFS);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\targs.acl_pages = pages;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\n\targs.acl_len = npages * PAGE_SIZE;\n\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\tkfree(pages);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tssize_t ret;\n\tdo {\n\t\tret = __nfs4_get_acl_uncached(inode, buf, buflen);\n\t\ttrace_nfs4_get_acl(inode, ret);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\t\tret = nfs4_handle_exception(NFS_SERVER(inode), ret, &exception);\n\t} while (exception.retry);\n\treturn ret;\n}\n\nstatic ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n\t\t * but no cached acl data, just the acl length */\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}\n\nstatic int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_setaclargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.acl_pages\t= pages,\n\t\t.acl_len\t= buflen,\n\t};\n\tstruct nfs_setaclres res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETACL],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret, i;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\ti = nfs4_buf_to_pages_noslab(buf, buflen, arg.acl_pages);\n\tif (i < 0)\n\t\treturn i;\n\tnfs4_inode_make_writeable(inode);\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\n\t/*\n\t * Free each page after tx, so the only ref left is\n\t * held by the network stack\n\t */\n\tfor (; i > 0; i--)\n\t\tput_page(pages[i-1]);\n\n\t/*\n\t * Acl update can result in inode attribute update.\n\t * so mark the attribute cache invalid.\n\t */\n\tspin_lock(&inode->i_lock);\n\tNFS_I(inode)->cache_validity |= NFS_INO_INVALID_CHANGE\n\t\t| NFS_INO_INVALID_CTIME\n\t\t| NFS_INO_REVAL_FORCED;\n\tspin_unlock(&inode->i_lock);\n\tnfs_access_zap_cache(inode);\n\tnfs_zap_acl_cache(inode);\n\treturn ret;\n}\n\nstatic int nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = __nfs4_proc_set_acl(inode, buf, buflen);\n\t\ttrace_nfs4_set_acl(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\nstatic int _nfs4_get_security_label(struct inode *inode, void *buf,\n\t\t\t\t\tsize_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_label label = {0, 0, buflen, buf};\n\n\tu32 bitmask[3] = { 0, 0, FATTR4_WORD2_SECURITY_LABEL };\n\tstruct nfs4_getattr_arg arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.bitmask\t= bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr\t\t= &fattr,\n\t\t.label\t\t= &label,\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint ret;\n\n\tnfs_fattr_init(&fattr);\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (!(fattr.valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL))\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\nstatic int nfs4_get_security_label(struct inode *inode, void *buf,\n\t\t\t\t\tsize_t buflen)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL))\n\t\treturn -EOPNOTSUPP;\n\n\tdo {\n\t\terr = _nfs4_get_security_label(inode, buf, buflen);\n\t\ttrace_nfs4_get_security_label(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_do_set_security_label(struct inode *inode,\n\t\tstruct nfs4_label *ilabel,\n\t\tstruct nfs_fattr *fattr,\n\t\tstruct nfs4_label *olabel)\n{\n\n\tstruct iattr sattr = {0};\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst u32 bitmask[3] = { 0, 0, FATTR4_WORD2_SECURITY_LABEL };\n\tstruct nfs_setattrargs arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.iap\t\t= &sattr,\n\t\t.server\t\t= server,\n\t\t.bitmask\t= bitmask,\n\t\t.label\t\t= ilabel,\n\t};\n\tstruct nfs_setattrres res = {\n\t\t.fattr\t\t= fattr,\n\t\t.label\t\t= olabel,\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_SETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint status;\n\n\tnfs4_stateid_copy(&arg.stateid, &zero_stateid);\n\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tif (status)\n\t\tdprintk(\"%s failed: %d\\n\", __func__, status);\n\n\treturn status;\n}\n\nstatic int nfs4_do_set_security_label(struct inode *inode,\n\t\tstruct nfs4_label *ilabel,\n\t\tstruct nfs_fattr *fattr,\n\t\tstruct nfs4_label *olabel)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_do_set_security_label(inode, ilabel,\n\t\t\t\tfattr, olabel);\n\t\ttrace_nfs4_set_security_label(inode, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int\nnfs4_set_security_label(struct inode *inode, const void *buf, size_t buflen)\n{\n\tstruct nfs4_label ilabel, *olabel = NULL;\n\tstruct nfs_fattr fattr;\n\tint status;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL))\n\t\treturn -EOPNOTSUPP;\n\n\tnfs_fattr_init(&fattr);\n\n\tilabel.pi = 0;\n\tilabel.lfs = 0;\n\tilabel.label = (char *)buf;\n\tilabel.len = buflen;\n\n\tolabel = nfs4_label_alloc(NFS_SERVER(inode), GFP_KERNEL);\n\tif (IS_ERR(olabel)) {\n\t\tstatus = -PTR_ERR(olabel);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_do_set_security_label(inode, &ilabel, &fattr, olabel);\n\tif (status == 0)\n\t\tnfs_setsecurity(inode, &fattr, olabel);\n\n\tnfs4_label_free(olabel);\nout:\n\treturn status;\n}\n#endif\t/* CONFIG_NFS_V4_SECURITY_LABEL */\n\n\nstatic void nfs4_init_boot_verifier(const struct nfs_client *clp,\n\t\t\t\t    nfs4_verifier *bootverf)\n{\n\t__be32 verf[2];\n\n\tif (test_bit(NFS4CLNT_PURGE_STATE, &clp->cl_state)) {\n\t\t/* An impossible timestamp guarantees this value\n\t\t * will never match a generated boot time. */\n\t\tverf[0] = cpu_to_be32(U32_MAX);\n\t\tverf[1] = cpu_to_be32(U32_MAX);\n\t} else {\n\t\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\t\tu64 ns = ktime_to_ns(nn->boot_time);\n\n\t\tverf[0] = cpu_to_be32(ns >> 32);\n\t\tverf[1] = cpu_to_be32(ns);\n\t}\n\tmemcpy(bootverf->data, verf, sizeof(bootverf->data));\n}\n\nstatic size_t\nnfs4_get_uniquifier(struct nfs_client *clp, char *buf, size_t buflen)\n{\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\tstruct nfs_netns_client *nn_clp = nn->nfs_client;\n\tconst char *id;\n\n\tbuf[0] = '\\0';\n\n\tif (nn_clp) {\n\t\trcu_read_lock();\n\t\tid = rcu_dereference(nn_clp->identifier);\n\t\tif (id)\n\t\t\tstrscpy(buf, id, buflen);\n\t\trcu_read_unlock();\n\t}\n\n\tif (nfs4_client_id_uniquifier[0] != '\\0' && buf[0] == '\\0')\n\t\tstrscpy(buf, nfs4_client_id_uniquifier, buflen);\n\n\treturn strlen(buf);\n}\n\nstatic int\nnfs4_init_nonuniform_client_string(struct nfs_client *clp)\n{\n\tchar buf[NFS4_CLIENT_ID_UNIQ_LEN];\n\tsize_t buflen;\n\tsize_t len;\n\tchar *str;\n\n\tif (clp->cl_owner_id != NULL)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tlen = 14 +\n\t\tstrlen(clp->cl_rpcclient->cl_nodename) +\n\t\t1 +\n\t\tstrlen(rpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR)) +\n\t\t1;\n\trcu_read_unlock();\n\n\tbuflen = nfs4_get_uniquifier(clp, buf, sizeof(buf));\n\tif (buflen)\n\t\tlen += buflen + 1;\n\n\tif (len > NFS4_OPAQUE_LIMIT + 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Since this string is allocated at mount time, and held until the\n\t * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying\n\t * about a memory-reclaim deadlock.\n\t */\n\tstr = kmalloc(len, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tif (buflen)\n\t\tscnprintf(str, len, \"Linux NFSv4.0 %s/%s/%s\",\n\t\t\t  clp->cl_rpcclient->cl_nodename, buf,\n\t\t\t  rpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t   RPC_DISPLAY_ADDR));\n\telse\n\t\tscnprintf(str, len, \"Linux NFSv4.0 %s/%s\",\n\t\t\t  clp->cl_rpcclient->cl_nodename,\n\t\t\t  rpc_peeraddr2str(clp->cl_rpcclient,\n\t\t\t\t\t   RPC_DISPLAY_ADDR));\n\trcu_read_unlock();\n\n\tclp->cl_owner_id = str;\n\treturn 0;\n}\n\nstatic int\nnfs4_init_uniform_client_string(struct nfs_client *clp)\n{\n\tchar buf[NFS4_CLIENT_ID_UNIQ_LEN];\n\tsize_t buflen;\n\tsize_t len;\n\tchar *str;\n\n\tif (clp->cl_owner_id != NULL)\n\t\treturn 0;\n\n\tlen = 10 + 10 + 1 + 10 + 1 +\n\t\tstrlen(clp->cl_rpcclient->cl_nodename) + 1;\n\n\tbuflen = nfs4_get_uniquifier(clp, buf, sizeof(buf));\n\tif (buflen)\n\t\tlen += buflen + 1;\n\n\tif (len > NFS4_OPAQUE_LIMIT + 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Since this string is allocated at mount time, and held until the\n\t * nfs_client is destroyed, we can use GFP_KERNEL here w/o worrying\n\t * about a memory-reclaim deadlock.\n\t */\n\tstr = kmalloc(len, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\tif (buflen)\n\t\tscnprintf(str, len, \"Linux NFSv%u.%u %s/%s\",\n\t\t\t  clp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t  buf, clp->cl_rpcclient->cl_nodename);\n\telse\n\t\tscnprintf(str, len, \"Linux NFSv%u.%u %s\",\n\t\t\t  clp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t  clp->cl_rpcclient->cl_nodename);\n\tclp->cl_owner_id = str;\n\treturn 0;\n}\n\n/*\n * nfs4_callback_up_net() starts only \"tcp\" and \"tcp6\" callback\n * services.  Advertise one based on the address family of the\n * clientaddr.\n */\nstatic unsigned int\nnfs4_init_callback_netid(const struct nfs_client *clp, char *buf, size_t len)\n{\n\tif (strchr(clp->cl_ipaddr, ':') != NULL)\n\t\treturn scnprintf(buf, len, \"tcp6\");\n\telse\n\t\treturn scnprintf(buf, len, \"tcp\");\n}\n\nstatic void nfs4_setclientid_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_setclientid *sc = calldata;\n\n\tif (task->tk_status == 0)\n\t\tsc->sc_cred = get_rpccred(task->tk_rqstp->rq_cred);\n}\n\nstatic const struct rpc_call_ops nfs4_setclientid_ops = {\n\t.rpc_call_done = nfs4_setclientid_done,\n};\n\n/**\n * nfs4_proc_setclientid - Negotiate client ID\n * @clp: state data structure\n * @program: RPC program for NFSv4 callback service\n * @port: IP port number for NFS4 callback service\n * @cred: credential to use for this call\n * @res: where to place the result\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n */\nint nfs4_proc_setclientid(struct nfs_client *clp, u32 program,\n\t\tunsigned short port, const struct cred *cred,\n\t\tstruct nfs4_setclientid_res *res)\n{\n\tnfs4_verifier sc_verifier;\n\tstruct nfs4_setclientid setclientid = {\n\t\t.sc_verifier = &sc_verifier,\n\t\t.sc_prog = program,\n\t\t.sc_clnt = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID],\n\t\t.rpc_argp = &setclientid,\n\t\t.rpc_resp = res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_setclientid_ops,\n\t\t.callback_data = &setclientid,\n\t\t.flags = RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\t/* nfs_client_id4 */\n\tnfs4_init_boot_verifier(clp, &sc_verifier);\n\n\tif (test_bit(NFS_CS_MIGRATION, &clp->cl_flags))\n\t\tstatus = nfs4_init_uniform_client_string(clp);\n\telse\n\t\tstatus = nfs4_init_nonuniform_client_string(clp);\n\n\tif (status)\n\t\tgoto out;\n\n\t/* cb_client4 */\n\tsetclientid.sc_netid_len =\n\t\t\t\tnfs4_init_callback_netid(clp,\n\t\t\t\t\t\tsetclientid.sc_netid,\n\t\t\t\t\t\tsizeof(setclientid.sc_netid));\n\tsetclientid.sc_uaddr_len = scnprintf(setclientid.sc_uaddr,\n\t\t\t\tsizeof(setclientid.sc_uaddr), \"%s.%u.%u\",\n\t\t\t\tclp->cl_ipaddr, port >> 8, port & 255);\n\n\tdprintk(\"NFS call  setclientid auth=%s, '%s'\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_owner_id);\n\n\tstatus = nfs4_call_sync_custom(&task_setup_data);\n\tif (setclientid.sc_cred) {\n\t\tkfree(clp->cl_acceptor);\n\t\tclp->cl_acceptor = rpcauth_stringify_acceptor(setclientid.sc_cred);\n\t\tput_rpccred(setclientid.sc_cred);\n\t}\n\n\tif (status == 0)\n\t\tdo_renew_lease(clp, now);\nout:\n\ttrace_nfs4_setclientid(clp, status);\n\tdprintk(\"NFS reply setclientid: %d\\n\", status);\n\treturn status;\n}\n\n/**\n * nfs4_proc_setclientid_confirm - Confirm client ID\n * @clp: state data structure\n * @arg: result of a previous SETCLIENTID\n * @cred: credential to use for this call\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n */\nint nfs4_proc_setclientid_confirm(struct nfs_client *clp,\n\t\tstruct nfs4_setclientid_res *arg,\n\t\tconst struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SETCLIENTID_CONFIRM],\n\t\t.rpc_argp = arg,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tdprintk(\"NFS call  setclientid_confirm auth=%s, (client ID %llx)\\n\",\n\t\tclp->cl_rpcclient->cl_auth->au_ops->au_name,\n\t\tclp->cl_clientid);\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_setclientid_confirm(clp, status);\n\tdprintk(\"NFS reply setclientid_confirm: %d\\n\", status);\n\treturn status;\n}\n\nstruct nfs4_delegreturndata {\n\tstruct nfs4_delegreturnargs args;\n\tstruct nfs4_delegreturnres res;\n\tstruct nfs_fh fh;\n\tnfs4_stateid stateid;\n\tunsigned long timestamp;\n\tstruct {\n\t\tstruct nfs4_layoutreturn_args arg;\n\t\tstruct nfs4_layoutreturn_res res;\n\t\tstruct nfs4_xdr_opaque_data ld_private;\n\t\tu32 roc_barrier;\n\t\tbool roc;\n\t} lr;\n\tstruct nfs_fattr fattr;\n\tint rpc_status;\n\tstruct inode *inode;\n};\n\nstatic void nfs4_delegreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\tstruct nfs4_exception exception = {\n\t\t.inode = data->inode,\n\t\t.stateid = &data->stateid,\n\t};\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\ttrace_nfs4_delegreturn_exit(&data->args, &data->res, task->tk_status);\n\n\t/* Handle Layoutreturn errors */\n\tif (pnfs_roc_done(task, &data->args.lr_args, &data->res.lr_res,\n\t\t\t  &data->res.lr_ret) == -EAGAIN)\n\t\tgoto out_restart;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(data->res.server, data->timestamp);\n\t\tbreak;\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_free_revoked_stateid(data->res.server,\n\t\t\t\tdata->args.stateid,\n\t\t\t\ttask->tk_msg.rpc_cred);\n\t\tfallthrough;\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -ETIMEDOUT:\n\t\ttask->tk_status = 0;\n\t\tbreak;\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tif (!nfs4_refresh_delegation_stateid(&data->stateid, data->inode))\n\t\t\tnfs4_stateid_seqid_inc(&data->stateid);\n\t\tif (data->args.bitmask) {\n\t\t\tdata->args.bitmask = NULL;\n\t\t\tdata->res.fattr = NULL;\n\t\t}\n\t\tgoto out_restart;\n\tcase -NFS4ERR_ACCESS:\n\t\tif (data->args.bitmask) {\n\t\t\tdata->args.bitmask = NULL;\n\t\t\tdata->res.fattr = NULL;\n\t\t\tgoto out_restart;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\tdata->res.server, task->tk_status,\n\t\t\t\t&exception);\n\t\tif (exception.retry)\n\t\t\tgoto out_restart;\n\t}\n\tnfs_delegation_mark_returned(data->inode, data->args.stateid);\n\tdata->rpc_status = task->tk_status;\n\treturn;\nout_restart:\n\ttask->tk_status = 0;\n\trpc_restart_call_prepare(task);\n}\n\nstatic void nfs4_delegreturn_release(void *calldata)\n{\n\tstruct nfs4_delegreturndata *data = calldata;\n\tstruct inode *inode = data->inode;\n\n\tif (data->lr.roc)\n\t\tpnfs_roc_release(&data->lr.arg, &data->lr.res,\n\t\t\t\t data->res.lr_ret);\n\tif (inode) {\n\t\tnfs_post_op_update_inode_force_wcc(inode, &data->fattr);\n\t\tnfs_iput_and_deactive(inode);\n\t}\n\tkfree(calldata);\n}\n\nstatic void nfs4_delegreturn_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_delegreturndata *d_data;\n\tstruct pnfs_layout_hdr *lo;\n\n\td_data = (struct nfs4_delegreturndata *)data;\n\n\tif (!d_data->lr.roc && nfs4_wait_on_layoutreturn(d_data->inode, task)) {\n\t\tnfs4_sequence_done(task, &d_data->res.seq_res);\n\t\treturn;\n\t}\n\n\tlo = d_data->args.lr_args ? d_data->args.lr_args->layout : NULL;\n\tif (lo && !pnfs_layout_is_valid(lo)) {\n\t\td_data->args.lr_args = NULL;\n\t\td_data->res.lr_res = NULL;\n\t}\n\n\tnfs4_setup_sequence(d_data->res.server->nfs_client,\n\t\t\t&d_data->args.seq_args,\n\t\t\t&d_data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic const struct rpc_call_ops nfs4_delegreturn_ops = {\n\t.rpc_call_prepare = nfs4_delegreturn_prepare,\n\t.rpc_call_done = nfs4_delegreturn_done,\n\t.rpc_release = nfs4_delegreturn_release,\n};\n\nstatic int _nfs4_proc_delegreturn(struct inode *inode, const struct cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_TIMEOUT,\n\t};\n\tint status = 0;\n\n\tdata = kzalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, 0);\n\n\tnfs4_state_protect(server->nfs_client,\n\t\t\tNFS_SP4_MACH_CRED_CLEANUP,\n\t\t\t&task_setup_data.rpc_client, &msg);\n\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tdata->args.bitmask = server->cache_consistency_bitmask;\n\tnfs4_bitmask_adjust(data->args.bitmask, inode, server, NULL);\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tnfs4_stateid_copy(&data->stateid, stateid);\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tdata->res.lr_ret = -NFS4ERR_NOMATCHING_LAYOUT;\n\tdata->lr.arg.ld_private = &data->lr.ld_private;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\tdata->inode = nfs_igrab_and_active(inode);\n\tif (data->inode || issync) {\n\t\tdata->lr.roc = pnfs_roc(inode, &data->lr.arg, &data->lr.res,\n\t\t\t\t\tcred);\n\t\tif (data->lr.roc) {\n\t\t\tdata->args.lr_args = &data->lr.arg;\n\t\t\tdata->res.lr_res = &data->lr.res;\n\t\t}\n\t}\n\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n\nint nfs4_proc_delegreturn(struct inode *inode, const struct cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_delegreturn(inode, cred, stateid, issync);\n\t\ttrace_nfs4_delegreturn(inode, stateid, err);\n\t\tswitch (err) {\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase 0:\n\t\t\t\treturn 0;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_lockt_args arg = {\n\t\t.fh = NFS_FH(inode),\n\t\t.fl = request,\n\t};\n\tstruct nfs_lockt_res res = {\n\t\t.denied = request,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_LOCKT],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= state->owner->so_cred,\n\t};\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\targ.lock_owner.clientid = clp->cl_clientid;\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\tgoto out;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\targ.lock_owner.id = lsp->ls_seqid.owner_id;\n\targ.lock_owner.s_dev = server->s_dev;\n\tstatus = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 1);\n\tswitch (status) {\n\t\tcase 0:\n\t\t\trequest->fl_type = F_UNLCK;\n\t\t\tbreak;\n\t\tcase -NFS4ERR_DENIED:\n\t\t\tstatus = 0;\n\t}\n\trequest->fl_ops->fl_release_private(request);\n\trequest->fl_ops = NULL;\nout:\n\treturn status;\n}\n\nstatic int nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_getlk(state, cmd, request);\n\t\ttrace_nfs4_get_lock(request, state, cmd, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * Update the seqid of a lock stateid after receiving\n * NFS4ERR_OLD_STATEID\n */\nstatic bool nfs4_refresh_lock_old_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_state *state = lsp->ls_state;\n\tbool ret = false;\n\n\tspin_lock(&state->state_lock);\n\tif (!nfs4_stateid_match_other(dst, &lsp->ls_stateid))\n\t\tgoto out;\n\tif (!nfs4_stateid_is_newer(&lsp->ls_stateid, dst))\n\t\tnfs4_stateid_seqid_inc(dst);\n\telse\n\t\tdst->seqid = lsp->ls_stateid.seqid;\n\tret = true;\nout:\n\tspin_unlock(&state->state_lock);\n\treturn ret;\n}\n\nstatic bool nfs4_sync_lock_stateid(nfs4_stateid *dst,\n\t\tstruct nfs4_lock_state *lsp)\n{\n\tstruct nfs4_state *state = lsp->ls_state;\n\tbool ret;\n\n\tspin_lock(&state->state_lock);\n\tret = !nfs4_stateid_match_other(dst, &lsp->ls_stateid);\n\tnfs4_stateid_copy(dst, &lsp->ls_stateid);\n\tspin_unlock(&state->state_lock);\n\treturn ret;\n}\n\nstruct nfs4_unlockdata {\n\tstruct nfs_locku_args arg;\n\tstruct nfs_locku_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock fl;\n\tstruct nfs_server *server;\n\tunsigned long timestamp;\n};\n\nstatic struct nfs4_unlockdata *nfs4_alloc_unlockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *p;\n\tstruct nfs4_state *state = lsp->ls_state;\n\tstruct inode *inode = state->inode;\n\n\tp = kzalloc(sizeof(*p), GFP_NOFS);\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.seqid = seqid;\n\tp->res.seqid = seqid;\n\tp->lsp = lsp;\n\t/* Ensure we don't close file until we're done freeing locks! */\n\tp->ctx = get_nfs_open_context(ctx);\n\tp->l_ctx = nfs_get_lock_context(ctx);\n\tlocks_init_lock(&p->fl);\n\tlocks_copy_lock(&p->fl, fl);\n\tp->server = NFS_SERVER(inode);\n\tspin_lock(&state->state_lock);\n\tnfs4_stateid_copy(&p->arg.stateid, &lsp->ls_stateid);\n\tspin_unlock(&state->state_lock);\n\treturn p;\n}\n\nstatic void nfs4_locku_release_calldata(void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tnfs_free_seqid(calldata->arg.seqid);\n\tnfs4_put_lock_state(calldata->lsp);\n\tnfs_put_lock_context(calldata->l_ctx);\n\tput_nfs_open_context(calldata->ctx);\n\tkfree(calldata);\n}\n\nstatic void nfs4_locku_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\tstruct nfs4_exception exception = {\n\t\t.inode = calldata->lsp->ls_state->inode,\n\t\t.stateid = &calldata->arg.stateid,\n\t};\n\n\tif (!nfs4_sequence_done(task, &calldata->res.seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\trenew_lease(calldata->server, calldata->timestamp);\n\t\t\tlocks_lock_inode_wait(calldata->lsp->ls_state->inode, &calldata->fl);\n\t\t\tif (nfs4_update_lock_stateid(calldata->lsp,\n\t\t\t\t\t&calldata->res.stateid))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tnfs4_free_revoked_stateid(calldata->server,\n\t\t\t\t\t&calldata->arg.stateid,\n\t\t\t\t\ttask->tk_msg.rpc_cred);\n\t\t\tfallthrough;\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tif (nfs4_sync_lock_stateid(&calldata->arg.stateid,\n\t\t\t\t\t\tcalldata->lsp))\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\t\tif (nfs4_refresh_lock_old_stateid(&calldata->arg.stateid,\n\t\t\t\t\t\tcalldata->lsp))\n\t\t\t\trpc_restart_call_prepare(task);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttask->tk_status = nfs4_async_handle_exception(task,\n\t\t\t\t\tcalldata->server, task->tk_status,\n\t\t\t\t\t&exception);\n\t\t\tif (exception.retry)\n\t\t\t\trpc_restart_call_prepare(task);\n\t}\n\tnfs_release_seqid(calldata->arg.seqid);\n}\n\nstatic void nfs4_locku_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_unlockdata *calldata = data;\n\n\tif (test_bit(NFS_CONTEXT_UNLOCK, &calldata->l_ctx->open_context->flags) &&\n\t\tnfs_async_iocounter_wait(task, calldata->l_ctx))\n\t\treturn;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\tgoto out_wait;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &calldata->lsp->ls_flags) == 0) {\n\t\t/* Note: exit _without_ running nfs4_locku_done */\n\t\tgoto out_no_action;\n\t}\n\tcalldata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(calldata->server->nfs_client,\n\t\t\t\t&calldata->arg.seq_args,\n\t\t\t\t&calldata->res.seq_res,\n\t\t\t\ttask) != 0)\n\t\tnfs_release_seqid(calldata->arg.seqid);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\nout_wait:\n\tnfs4_sequence_done(task, &calldata->res.seq_res);\n}\n\nstatic const struct rpc_call_ops nfs4_locku_ops = {\n\t.rpc_call_prepare = nfs4_locku_prepare,\n\t.rpc_call_done = nfs4_locku_done,\n\t.rpc_release = nfs4_locku_release_calldata,\n};\n\nstatic struct rpc_task *nfs4_do_unlck(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx,\n\t\tstruct nfs4_lock_state *lsp,\n\t\tstruct nfs_seqid *seqid)\n{\n\tstruct nfs4_unlockdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCKU],\n\t\t.rpc_cred = ctx->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(lsp->ls_state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_locku_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\n\tnfs4_state_protect(NFS_SERVER(lsp->ls_state->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_CLEANUP, &task_setup_data.rpc_client, &msg);\n\n\t/* Ensure this is an unlock - when canceling a lock, the\n\t * canceled lock is passed in, and it won't be an unlock.\n\t */\n\tfl->fl_type = F_UNLCK;\n\tif (fl->fl_flags & FL_CLOSE)\n\t\tset_bit(NFS_CONTEXT_UNLOCK, &ctx->flags);\n\n\tdata = nfs4_alloc_unlockdata(fl, ctx, lsp, seqid);\n\tif (data == NULL) {\n\t\tnfs_free_seqid(seqid);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnfs4_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1, 0);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstatic int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct inode *inode = state->inode;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_seqid *seqid;\n\tstruct nfs4_lock_state *lsp;\n\tstruct rpc_task *task;\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\tint status = 0;\n\tunsigned char fl_flags = request->fl_flags;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\t/* Unlock _before_ we do the RPC call */\n\trequest->fl_flags |= FL_EXISTS;\n\t/* Exclude nfs_delegation_claim_locks() */\n\tmutex_lock(&sp->so_delegreturn_mutex);\n\t/* Exclude nfs4_reclaim_open_stateid() - note nesting! */\n\tdown_read(&nfsi->rwsem);\n\tif (locks_lock_inode_wait(inode, request) == -ENOENT) {\n\t\tup_read(&nfsi->rwsem);\n\t\tmutex_unlock(&sp->so_delegreturn_mutex);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tmutex_unlock(&sp->so_delegreturn_mutex);\n\tif (status != 0)\n\t\tgoto out;\n\t/* Is this a delegated lock? */\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) == 0)\n\t\tgoto out;\n\talloc_seqid = NFS_SERVER(inode)->nfs_client->cl_mvops->alloc_seqid;\n\tseqid = alloc_seqid(&lsp->ls_seqid, GFP_KERNEL);\n\tstatus = -ENOMEM;\n\tif (IS_ERR(seqid))\n\t\tgoto out;\n\ttask = nfs4_do_unlck(request, nfs_file_open_context(request->fl_file), lsp, seqid);\n\tstatus = PTR_ERR(task);\n\tif (IS_ERR(task))\n\t\tgoto out;\n\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\nout:\n\trequest->fl_flags = fl_flags;\n\ttrace_nfs4_unlock(request, state, F_SETLK, status);\n\treturn status;\n}\n\nstruct nfs4_lockdata {\n\tstruct nfs_lock_args arg;\n\tstruct nfs_lock_res res;\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_open_context *ctx;\n\tstruct file_lock fl;\n\tunsigned long timestamp;\n\tint rpc_status;\n\tint cancelled;\n\tstruct nfs_server *server;\n};\n\nstatic struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_seqid *(*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.open_seqid))\n\t\tgoto out_free;\n\talloc_seqid = server->nfs_client->cl_mvops->alloc_seqid;\n\tp->arg.lock_seqid = alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (IS_ERR(p->arg.lock_seqid))\n\t\tgoto out_free_seqid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_seqid.owner_id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tp->ctx = get_nfs_open_context(ctx);\n\tlocks_init_lock(&p->fl);\n\tlocks_copy_lock(&p->fl, fl);\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n\nstatic void nfs4_lock_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_state *state = data->lsp->ls_state;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (nfs_wait_on_sequence(data->arg.lock_seqid, task) != 0)\n\t\tgoto out_wait;\n\t/* Do we need to do an open_to_lock_owner? */\n\tif (!test_bit(NFS_LOCK_INITIALIZED, &data->lsp->ls_flags)) {\n\t\tif (nfs_wait_on_sequence(data->arg.open_seqid, task) != 0) {\n\t\t\tgoto out_release_lock_seqid;\n\t\t}\n\t\tnfs4_stateid_copy(&data->arg.open_stateid,\n\t\t\t\t&state->open_stateid);\n\t\tdata->arg.new_lock_owner = 1;\n\t\tdata->res.open_seqid = data->arg.open_seqid;\n\t} else {\n\t\tdata->arg.new_lock_owner = 0;\n\t\tnfs4_stateid_copy(&data->arg.lock_stateid,\n\t\t\t\t&data->lsp->ls_stateid);\n\t}\n\tif (!nfs4_valid_open_stateid(state)) {\n\t\tdata->rpc_status = -EBADF;\n\t\ttask->tk_action = NULL;\n\t\tgoto out_release_open_seqid;\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->server->nfs_client,\n\t\t\t\t&data->arg.seq_args,\n\t\t\t\t&data->res.seq_res,\n\t\t\t\ttask) == 0)\n\t\treturn;\nout_release_open_seqid:\n\tnfs_release_seqid(data->arg.open_seqid);\nout_release_lock_seqid:\n\tnfs_release_seqid(data->arg.lock_seqid);\nout_wait:\n\tnfs4_sequence_done(task, &data->res.seq_res);\n\tdprintk(\"%s: done!, ret = %d\\n\", __func__, data->rpc_status);\n}\n\nstatic void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tstruct nfs4_lock_state *lsp = data->lsp;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tdata->rpc_status = task->tk_status;\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(NFS_SERVER(d_inode(data->ctx->dentry)),\n\t\t\t\tdata->timestamp);\n\t\tif (data->arg.new_lock && !data->cancelled) {\n\t\t\tdata->fl.fl_flags &= ~(FL_SLEEP | FL_ACCESS);\n\t\t\tif (locks_lock_inode_wait(lsp->ls_state->inode, &data->fl) < 0)\n\t\t\t\tgoto out_restart;\n\t\t}\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tnfs_confirm_seqid(&lsp->ls_seqid, 0);\n\t\t\tnfs4_stateid_copy(&lsp->ls_stateid, &data->res.stateid);\n\t\t\tset_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags);\n\t\t} else if (!nfs4_update_lock_stateid(lsp, &data->res.stateid))\n\t\t\tgoto out_restart;\n\t\tbreak;\n\tcase -NFS4ERR_BAD_STATEID:\n\tcase -NFS4ERR_OLD_STATEID:\n\tcase -NFS4ERR_STALE_STATEID:\n\tcase -NFS4ERR_EXPIRED:\n\t\tif (data->arg.new_lock_owner != 0) {\n\t\t\tif (!nfs4_stateid_match(&data->arg.open_stateid,\n\t\t\t\t\t\t&lsp->ls_state->open_stateid))\n\t\t\t\tgoto out_restart;\n\t\t} else if (!nfs4_stateid_match(&data->arg.lock_stateid,\n\t\t\t\t\t\t&lsp->ls_stateid))\n\t\t\t\tgoto out_restart;\n\t}\nout_done:\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n\treturn;\nout_restart:\n\tif (!data->cancelled)\n\t\trpc_restart_call_prepare(task);\n\tgoto out_done;\n}\n\nstatic void nfs4_lock_release(void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tnfs_free_seqid(data->arg.open_seqid);\n\tif (data->cancelled && data->rpc_status == 0) {\n\t\tstruct rpc_task *task;\n\t\ttask = nfs4_do_unlck(&data->fl, data->ctx, data->lsp,\n\t\t\t\tdata->arg.lock_seqid);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task_async(task);\n\t\tdprintk(\"%s: cancelling lock!\\n\", __func__);\n\t} else\n\t\tnfs_free_seqid(data->arg.lock_seqid);\n\tnfs4_put_lock_state(data->lsp);\n\tput_nfs_open_context(data->ctx);\n\tkfree(data);\n\tdprintk(\"%s: done!\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_lock_ops = {\n\t.rpc_call_prepare = nfs4_lock_prepare,\n\t.rpc_call_done = nfs4_lock_done,\n\t.rpc_release = nfs4_lock_release,\n};\n\nstatic void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t}\n}\n\nstatic int _nfs4_do_setlk(struct nfs4_state *state, int cmd, struct file_lock *fl, int recovery_type)\n{\n\tstruct nfs4_lockdata *data;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LOCK],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_CLIENT(state->inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_lock_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tint ret;\n\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tdata = nfs4_alloc_lockdata(fl, nfs_file_open_context(fl->fl_file),\n\t\t\tfl->fl_u.nfs4_fl.owner,\n\t\t\trecovery_type == NFS_LOCK_NEW ? GFP_KERNEL : GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tif (IS_SETLKW(cmd))\n\t\tdata->arg.block = 1;\n\tnfs4_init_sequence(&data->arg.seq_args, &data->res.seq_res, 1,\n\t\t\t\trecovery_type > NFS_LOCK_NEW);\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\ttask_setup_data.callback_data = data;\n\tif (recovery_type > NFS_LOCK_NEW) {\n\t\tif (recovery_type == NFS_LOCK_RECLAIM)\n\t\t\tdata->arg.reclaim = NFS_LOCK_RECLAIM;\n\t} else\n\t\tdata->arg.new_lock = 1;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tret = rpc_wait_for_completion_task(task);\n\tif (ret == 0) {\n\t\tret = data->rpc_status;\n\t\tif (ret)\n\t\t\tnfs4_handle_setlk_error(data->server, data->lsp,\n\t\t\t\t\tdata->arg.new_lock_owner, ret);\n\t} else\n\t\tdata->cancelled = true;\n\ttrace_nfs4_set_lock(fl, state, &data->res.stateid, cmd, ret);\n\trpc_put_task(task);\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\t/* Cache the lock if possible... */\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_RECLAIM);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstatic int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\terr = nfs4_set_lock_state(state, request);\n\tif (err != 0)\n\t\treturn err;\n\tif (!recover_lost_locks) {\n\t\tset_bit(NFS_LOCK_LOST, &request->fl_u.nfs4_fl.owner->ls_flags);\n\t\treturn 0;\n\t}\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_EXPIRED);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out;\n\t\tcase -NFS4ERR_GRACE:\n\t\tcase -NFS4ERR_DELAY:\n\t\t\tnfs4_handle_exception(server, err, &exception);\n\t\t\terr = 0;\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\n#if defined(CONFIG_NFS_V4_1)\nstatic int nfs41_lock_expired(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs4_lock_state *lsp;\n\tint status;\n\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\treturn status;\n\tlsp = request->fl_u.nfs4_fl.owner;\n\tif (test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) ||\n\t    test_bit(NFS_LOCK_LOST, &lsp->ls_flags))\n\t\treturn 0;\n\treturn nfs4_lock_expired(state, request);\n}\n#endif\n\nstatic int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs4_state_owner *sp = state->owner;\n\tunsigned char fl_flags = request->fl_flags;\n\tint status;\n\n\trequest->fl_flags |= FL_ACCESS;\n\tstatus = locks_lock_inode_wait(state->inode, request);\n\tif (status < 0)\n\t\tgoto out;\n\tmutex_lock(&sp->so_delegreturn_mutex);\n\tdown_read(&nfsi->rwsem);\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags)) {\n\t\t/* Yes: cache locks! */\n\t\t/* ...but avoid races with delegation recall... */\n\t\trequest->fl_flags = fl_flags & ~FL_SLEEP;\n\t\tstatus = locks_lock_inode_wait(state->inode, request);\n\t\tup_read(&nfsi->rwsem);\n\t\tmutex_unlock(&sp->so_delegreturn_mutex);\n\t\tgoto out;\n\t}\n\tup_read(&nfsi->rwsem);\n\tmutex_unlock(&sp->so_delegreturn_mutex);\n\tstatus = _nfs4_do_setlk(state, cmd, request, NFS_LOCK_NEW);\nout:\n\trequest->fl_flags = fl_flags;\n\treturn status;\n}\n\nstatic int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = state->inode,\n\t\t.interruptible = true,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_setlk(state, cmd, request);\n\t\tif (err == -NFS4ERR_DENIED)\n\t\t\terr = -EAGAIN;\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\terr, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#define NFS4_LOCK_MINTIMEOUT (1 * HZ)\n#define NFS4_LOCK_MAXTIMEOUT (30 * HZ)\n\nstatic int\nnfs4_retry_setlk_simple(struct nfs4_state *state, int cmd,\n\t\t\tstruct file_lock *request)\n{\n\tint\t\tstatus = -ERESTARTSYS;\n\tunsigned long\ttimeout = NFS4_LOCK_MINTIMEOUT;\n\n\twhile(!signalled()) {\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n\t\t\tbreak;\n\t\tfreezable_schedule_timeout_interruptible(timeout);\n\t\ttimeout *= 2;\n\t\ttimeout = min_t(unsigned long, NFS4_LOCK_MAXTIMEOUT, timeout);\n\t\tstatus = -ERESTARTSYS;\n\t}\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\nstruct nfs4_lock_waiter {\n\tstruct task_struct\t*task;\n\tstruct inode\t\t*inode;\n\tstruct nfs_lowner\t*owner;\n};\n\nstatic int\nnfs4_wake_lock_waiter(wait_queue_entry_t *wait, unsigned int mode, int flags, void *key)\n{\n\tint ret;\n\tstruct nfs4_lock_waiter\t*waiter\t= wait->private;\n\n\t/* NULL key means to wake up everyone */\n\tif (key) {\n\t\tstruct cb_notify_lock_args\t*cbnl = key;\n\t\tstruct nfs_lowner\t\t*lowner = &cbnl->cbnl_owner,\n\t\t\t\t\t\t*wowner = waiter->owner;\n\n\t\t/* Only wake if the callback was for the same owner. */\n\t\tif (lowner->id != wowner->id || lowner->s_dev != wowner->s_dev)\n\t\t\treturn 0;\n\n\t\t/* Make sure it's for the right inode */\n\t\tif (nfs_compare_fh(NFS_FH(waiter->inode), &cbnl->cbnl_fh))\n\t\t\treturn 0;\n\t}\n\n\t/* override \"private\" so we can use default_wake_function */\n\twait->private = waiter->task;\n\tret = woken_wake_function(wait, mode, flags, key);\n\tif (ret)\n\t\tlist_del_init(&wait->entry);\n\twait->private = waiter;\n\treturn ret;\n}\n\nstatic int\nnfs4_retry_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tint status = -ERESTARTSYS;\n\tstruct nfs4_lock_state *lsp = request->fl_u.nfs4_fl.owner;\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\twait_queue_head_t *q = &clp->cl_lock_waitq;\n\tstruct nfs_lowner owner = { .clientid = clp->cl_clientid,\n\t\t\t\t    .id = lsp->ls_seqid.owner_id,\n\t\t\t\t    .s_dev = server->s_dev };\n\tstruct nfs4_lock_waiter waiter = { .task  = current,\n\t\t\t\t\t   .inode = state->inode,\n\t\t\t\t\t   .owner = &owner};\n\twait_queue_entry_t wait;\n\n\t/* Don't bother with waitqueue if we don't expect a callback */\n\tif (!test_bit(NFS_STATE_MAY_NOTIFY_LOCK, &state->flags))\n\t\treturn nfs4_retry_setlk_simple(state, cmd, request);\n\n\tinit_wait(&wait);\n\twait.private = &waiter;\n\twait.func = nfs4_wake_lock_waiter;\n\n\twhile(!signalled()) {\n\t\tadd_wait_queue(q, &wait);\n\t\tstatus = nfs4_proc_setlk(state, cmd, request);\n\t\tif ((status != -EAGAIN) || IS_SETLK(cmd)) {\n\t\t\tfinish_wait(q, &wait);\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = -ERESTARTSYS;\n\t\tfreezer_do_not_count();\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, NFS4_LOCK_MAXTIMEOUT);\n\t\tfreezer_count();\n\t\tfinish_wait(q, &wait);\n\t}\n\n\treturn status;\n}\n#else /* !CONFIG_NFS_V4_1 */\nstatic inline int\nnfs4_retry_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\treturn nfs4_retry_setlk_simple(state, cmd, request);\n}\n#endif\n\nstatic int\nnfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct nfs4_state *state;\n\tint status;\n\n\t/* verify open state */\n\tctx = nfs_file_open_context(filp);\n\tstate = ctx->state;\n\n\tif (IS_GETLK(cmd)) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n\t\treturn 0;\n\t}\n\n\tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n\t\treturn -EINVAL;\n\n\tif (request->fl_type == F_UNLCK) {\n\t\tif (state != NULL)\n\t\t\treturn nfs4_proc_unlck(state, cmd, request);\n\t\treturn 0;\n\t}\n\n\tif (state == NULL)\n\t\treturn -ENOLCK;\n\n\tif ((request->fl_flags & FL_POSIX) &&\n\t    !test_bit(NFS_STATE_POSIX_LOCKS, &state->flags))\n\t\treturn -ENOLCK;\n\n\t/*\n\t * Don't rely on the VFS having checked the file open mode,\n\t * since it won't do this for flock() locks.\n\t */\n\tswitch (request->fl_type) {\n\tcase F_RDLCK:\n\t\tif (!(filp->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\t\tbreak;\n\tcase F_WRLCK:\n\t\tif (!(filp->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\t}\n\n\tstatus = nfs4_set_lock_state(state, request);\n\tif (status != 0)\n\t\treturn status;\n\n\treturn nfs4_retry_setlk(state, cmd, request);\n}\n\nint nfs4_lock_delegation_recall(struct file_lock *fl, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\treturn err;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tssleep(1);\n\t} while (err == -NFS4ERR_DELAY);\n\treturn nfs4_handle_delegation_recall_error(server, state, stateid, fl, err);\n}\n\nstruct nfs_release_lockowner_data {\n\tstruct nfs4_lock_state *lsp;\n\tstruct nfs_server *server;\n\tstruct nfs_release_lockowner_args args;\n\tstruct nfs_release_lockowner_res res;\n\tunsigned long timestamp;\n};\n\nstatic void nfs4_release_lockowner_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tstruct nfs_server *server = data->server;\n\tnfs4_setup_sequence(server->nfs_client, &data->args.seq_args,\n\t\t\t   &data->res.seq_res, task);\n\tdata->args.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tdata->timestamp = jiffies;\n}\n\nstatic void nfs4_release_lockowner_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tstruct nfs_server *server = data->server;\n\n\tnfs40_sequence_done(task, &data->res.seq_res);\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\trenew_lease(server, data->timestamp);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_CLIENTID:\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\tbreak;\n\tcase -NFS4ERR_LEASE_MOVED:\n\tcase -NFS4ERR_DELAY:\n\t\tif (nfs4_async_handle_error(task, server,\n\t\t\t\t\t    NULL, NULL) == -EAGAIN)\n\t\t\trpc_restart_call_prepare(task);\n\t}\n}\n\nstatic void nfs4_release_lockowner_release(void *calldata)\n{\n\tstruct nfs_release_lockowner_data *data = calldata;\n\tnfs4_free_lock_state(data->server, data->lsp);\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_release_lockowner_ops = {\n\t.rpc_call_prepare = nfs4_release_lockowner_prepare,\n\t.rpc_call_done = nfs4_release_lockowner_done,\n\t.rpc_release = nfs4_release_lockowner_release,\n};\n\nstatic void\nnfs4_release_lockowner(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tstruct nfs_release_lockowner_data *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RELEASE_LOCKOWNER],\n\t};\n\n\tif (server->nfs_client->cl_mvops->minor_version != 0)\n\t\treturn;\n\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\treturn;\n\tdata->lsp = lsp;\n\tdata->server = server;\n\tdata->args.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tdata->args.lock_owner.id = lsp->ls_seqid.owner_id;\n\tdata->args.lock_owner.s_dev = server->s_dev;\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0, 0);\n\trpc_call_async(server->client, &msg, 0, &nfs4_release_lockowner_ops, data);\n}\n\n#define XATTR_NAME_NFSV4_ACL \"system.nfs4_acl\"\n\nstatic int nfs4_xattr_set_nfs4_acl(const struct xattr_handler *handler,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *key, const void *buf,\n\t\t\t\t   size_t buflen, int flags)\n{\n\treturn nfs4_proc_set_acl(inode, buf, buflen);\n}\n\nstatic int nfs4_xattr_get_nfs4_acl(const struct xattr_handler *handler,\n\t\t\t\t   struct dentry *unused, struct inode *inode,\n\t\t\t\t   const char *key, void *buf, size_t buflen)\n{\n\treturn nfs4_proc_get_acl(inode, buf, buflen);\n}\n\nstatic bool nfs4_xattr_list_nfs4_acl(struct dentry *dentry)\n{\n\treturn nfs4_server_supports_acls(NFS_SERVER(d_inode(dentry)));\n}\n\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\nstatic int nfs4_xattr_set_nfs4_label(const struct xattr_handler *handler,\n\t\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t\t     const char *key, const void *buf,\n\t\t\t\t     size_t buflen, int flags)\n{\n\tif (security_ismaclabel(key))\n\t\treturn nfs4_set_security_label(inode, buf, buflen);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nfs4_xattr_get_nfs4_label(const struct xattr_handler *handler,\n\t\t\t\t     struct dentry *unused, struct inode *inode,\n\t\t\t\t     const char *key, void *buf, size_t buflen)\n{\n\tif (security_ismaclabel(key))\n\t\treturn nfs4_get_security_label(inode, buf, buflen);\n\treturn -EOPNOTSUPP;\n}\n\nstatic ssize_t\nnfs4_listxattr_nfs4_label(struct inode *inode, char *list, size_t list_len)\n{\n\tint len = 0;\n\n\tif (nfs_server_capable(inode, NFS_CAP_SECURITY_LABEL)) {\n\t\tlen = security_inode_listsecurity(inode, list, list_len);\n\t\tif (len >= 0 && list_len && len > list_len)\n\t\t\treturn -ERANGE;\n\t}\n\treturn len;\n}\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_label_handler = {\n\t.prefix = XATTR_SECURITY_PREFIX,\n\t.get\t= nfs4_xattr_get_nfs4_label,\n\t.set\t= nfs4_xattr_set_nfs4_label,\n};\n\n#else\n\nstatic ssize_t\nnfs4_listxattr_nfs4_label(struct inode *inode, char *list, size_t list_len)\n{\n\treturn 0;\n}\n\n#endif\n\n#ifdef CONFIG_NFS_V4_2\nstatic int nfs4_xattr_set_nfs4_user(const struct xattr_handler *handler,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, const void *buf,\n\t\t\t\t    size_t buflen, int flags)\n{\n\tstruct nfs_access_entry cache;\n\tint ret;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * There is no mapping from the MAY_* flags to the NFS_ACCESS_XA*\n\t * flags right now. Handling of xattr operations use the normal\n\t * file read/write permissions.\n\t *\n\t * Just in case the server has other ideas (which RFC 8276 allows),\n\t * do a cached access check for the XA* flags to possibly avoid\n\t * doing an RPC and getting EACCES back.\n\t */\n\tif (!nfs_access_get_cached(inode, current_cred(), &cache, true)) {\n\t\tif (!(cache.mask & NFS_ACCESS_XAWRITE))\n\t\t\treturn -EACCES;\n\t}\n\n\tif (buf == NULL) {\n\t\tret = nfs42_proc_removexattr(inode, key);\n\t\tif (!ret)\n\t\t\tnfs4_xattr_cache_remove(inode, key);\n\t} else {\n\t\tret = nfs42_proc_setxattr(inode, key, buf, buflen, flags);\n\t\tif (!ret)\n\t\t\tnfs4_xattr_cache_add(inode, key, buf, NULL, buflen);\n\t}\n\n\treturn ret;\n}\n\nstatic int nfs4_xattr_get_nfs4_user(const struct xattr_handler *handler,\n\t\t\t\t    struct dentry *unused, struct inode *inode,\n\t\t\t\t    const char *key, void *buf, size_t buflen)\n{\n\tstruct nfs_access_entry cache;\n\tssize_t ret;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!nfs_access_get_cached(inode, current_cred(), &cache, true)) {\n\t\tif (!(cache.mask & NFS_ACCESS_XAREAD))\n\t\t\treturn -EACCES;\n\t}\n\n\tret = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfs4_xattr_cache_get(inode, key, buf, buflen);\n\tif (ret >= 0 || (ret < 0 && ret != -ENOENT))\n\t\treturn ret;\n\n\tret = nfs42_proc_getxattr(inode, key, buf, buflen);\n\n\treturn ret;\n}\n\nstatic ssize_t\nnfs4_listxattr_nfs4_user(struct inode *inode, char *list, size_t list_len)\n{\n\tu64 cookie;\n\tbool eof;\n\tssize_t ret, size;\n\tchar *buf;\n\tsize_t buflen;\n\tstruct nfs_access_entry cache;\n\n\tif (!nfs_server_capable(inode, NFS_CAP_XATTR))\n\t\treturn 0;\n\n\tif (!nfs_access_get_cached(inode, current_cred(), &cache, true)) {\n\t\tif (!(cache.mask & NFS_ACCESS_XALIST))\n\t\t\treturn 0;\n\t}\n\n\tret = nfs_revalidate_inode(NFS_SERVER(inode), inode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nfs4_xattr_cache_list(inode, list, list_len);\n\tif (ret >= 0 || (ret < 0 && ret != -ENOENT))\n\t\treturn ret;\n\n\tcookie = 0;\n\teof = false;\n\tbuflen = list_len ? list_len : XATTR_LIST_MAX;\n\tbuf = list_len ? list : NULL;\n\tsize = 0;\n\n\twhile (!eof) {\n\t\tret = nfs42_proc_listxattrs(inode, buf, buflen,\n\t\t    &cookie, &eof);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (list_len) {\n\t\t\tbuf += ret;\n\t\t\tbuflen -= ret;\n\t\t}\n\t\tsize += ret;\n\t}\n\n\tif (list_len)\n\t\tnfs4_xattr_cache_set_list(inode, list, size);\n\n\treturn size;\n}\n\n#else\n\nstatic ssize_t\nnfs4_listxattr_nfs4_user(struct inode *inode, char *list, size_t list_len)\n{\n\treturn 0;\n}\n#endif /* CONFIG_NFS_V4_2 */\n\n/*\n * nfs_fhget will use either the mounted_on_fileid or the fileid\n */\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr)\n{\n\tif (!(((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) ||\n\t       (fattr->valid & NFS_ATTR_FATTR_FILEID)) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_FSID) &&\n\t      (fattr->valid & NFS_ATTR_FATTR_V4_LOCATIONS)))\n\t\treturn;\n\n\tfattr->valid |= NFS_ATTR_FATTR_TYPE | NFS_ATTR_FATTR_MODE |\n\t\tNFS_ATTR_FATTR_NLINK | NFS_ATTR_FATTR_V4_REFERRAL;\n\tfattr->mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\tfattr->nlink = 2;\n}\n\nstatic int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t\t   const struct qstr *name,\n\t\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t\t   struct page *page)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tu32 bitmask[3];\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name = name,\n\t\t.page = page,\n\t\t.bitmask = bitmask,\n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations = fs_locations,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\n\tdprintk(\"%s: start\\n\", __func__);\n\n\tbitmask[0] = nfs4_fattr_bitmap[0] | FATTR4_WORD0_FS_LOCATIONS;\n\tbitmask[1] = nfs4_fattr_bitmap[1];\n\n\t/* Ask for the fileid of the absent filesystem if mounted_on_fileid\n\t * is not supported */\n\tif (NFS_SERVER(dir)->attr_bitmask[1] & FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\tbitmask[0] &= ~FATTR4_WORD0_FILEID;\n\telse\n\t\tbitmask[1] &= ~FATTR4_WORD1_MOUNTED_ON_FILEID;\n\n\tnfs_fattr_init(&fs_locations->fattr);\n\tfs_locations->server = server;\n\tfs_locations->nlocations = 0;\n\tstatus = nfs4_call_sync(client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"%s: returned status = %d\\n\", __func__, status);\n\treturn status;\n}\n\nint nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n/*\n * This operation also signals the server that this client is\n * performing migration recovery.  The server can stop returning\n * NFS4ERR_LEASE_MOVED to this client.  A RENEW operation is\n * appended to this compound to identify the client ID which is\n * performing recovery.\n */\nstatic int _nfs40_proc_get_locations(struct inode *inode,\n\t\t\t\t     struct nfs4_fs_locations *locations,\n\t\t\t\t     struct page *page, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_clnt *clnt = server->client;\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.clientid\t= server->nfs_client->cl_clientid,\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.page\t\t= page,\n\t\t.bitmask\t= bitmask,\n\t\t.migration\t= 1,\t\t/* skip LOOKUP */\n\t\t.renew\t\t= 1,\t\t/* append RENEW */\n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations\t= locations,\n\t\t.migration\t= 1,\n\t\t.renew\t\t= 1,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tnfs_fattr_init(&locations->fattr);\n\tlocations->server = server;\n\tlocations->nlocations = 0;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tif (status)\n\t\treturn status;\n\n\trenew_lease(server, now);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n/*\n * This operation also signals the server that this client is\n * performing migration recovery.  The server can stop asserting\n * SEQ4_STATUS_LEASE_MOVED for this client.  The client ID\n * performing this operation is identified in the SEQUENCE\n * operation in this compound.\n *\n * When the client supports GETATTR(fs_locations_info), it can\n * be plumbed in here.\n */\nstatic int _nfs41_proc_get_locations(struct inode *inode,\n\t\t\t\t     struct nfs4_fs_locations *locations,\n\t\t\t\t     struct page *page, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_clnt *clnt = server->client;\n\tu32 bitmask[2] = {\n\t\t[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,\n\t};\n\tstruct nfs4_fs_locations_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.page\t\t= page,\n\t\t.bitmask\t= bitmask,\n\t\t.migration\t= 1,\t\t/* skip LOOKUP */\n\t};\n\tstruct nfs4_fs_locations_res res = {\n\t\t.fs_locations\t= locations,\n\t\t.migration\t= 1,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FS_LOCATIONS],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint status;\n\n\tnfs_fattr_init(&locations->fattr);\n\tlocations->server = server;\n\tlocations->nlocations = 0;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tif (status == NFS4_OK &&\n\t    res.seq_res.sr_status_flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tstatus = -NFS4ERR_LEASE_MOVED;\n\treturn status;\n}\n\n#endif\t/* CONFIG_NFS_V4_1 */\n\n/**\n * nfs4_proc_get_locations - discover locations for a migrated FSID\n * @inode: inode on FSID that is migrating\n * @locations: result of query\n * @page: buffer\n * @cred: credential to use for this operation\n *\n * Returns NFS4_OK on success, a negative NFS4ERR status code if the\n * operation failed, or a negative errno if a local error occurred.\n *\n * On success, \"locations\" is filled in, but if the server has\n * no locations information, NFS_ATTR_FATTR_V4_LOCATIONS is not\n * asserted.\n *\n * -NFS4ERR_LEASE_MOVED is returned if the server still has leases\n * from this client that require migration recovery.\n */\nint nfs4_proc_get_locations(struct inode *inode,\n\t\t\t    struct nfs4_fs_locations *locations,\n\t\t\t    struct page *page, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->get_locations(inode, locations, page, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}\n\n/*\n * This operation also signals the server that this client is\n * performing \"lease moved\" recovery.  The server can stop\n * returning NFS4ERR_LEASE_MOVED to this client.  A RENEW operation\n * is appended to this compound to identify the client ID which is\n * performing recovery.\n */\nstatic int _nfs40_proc_fsid_present(struct inode *inode, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = NFS_SERVER(inode)->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct nfs4_fsid_present_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.clientid\t= clp->cl_clientid,\n\t\t.renew\t\t= 1,\t\t/* append RENEW */\n\t};\n\tstruct nfs4_fsid_present_res res = {\n\t\t.renew\t\t= 1,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FSID_PRESENT],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tres.fh = nfs_alloc_fhandle();\n\tif (res.fh == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tnfs_free_fhandle(res.fh);\n\tif (status)\n\t\treturn status;\n\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n/*\n * This operation also signals the server that this client is\n * performing \"lease moved\" recovery.  The server can stop asserting\n * SEQ4_STATUS_LEASE_MOVED for this client.  The client ID performing\n * this operation is identified in the SEQUENCE operation in this\n * compound.\n */\nstatic int _nfs41_proc_fsid_present(struct inode *inode, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct nfs4_fsid_present_arg args = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t};\n\tstruct nfs4_fsid_present_res res = {\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_FSID_PRESENT],\n\t\t.rpc_argp\t= &args,\n\t\t.rpc_resp\t= &res,\n\t\t.rpc_cred\t= cred,\n\t};\n\tint status;\n\n\tres.fh = nfs_alloc_fhandle();\n\tif (res.fh == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(clnt, server, &msg,\n\t\t\t\t\t\t&args.seq_args, &res.seq_res);\n\tnfs_free_fhandle(res.fh);\n\tif (status == NFS4_OK &&\n\t    res.seq_res.sr_status_flags & SEQ4_STATUS_LEASE_MOVED)\n\t\tstatus = -NFS4ERR_LEASE_MOVED;\n\treturn status;\n}\n\n#endif\t/* CONFIG_NFS_V4_1 */\n\n/**\n * nfs4_proc_fsid_present - Is this FSID present or absent on server?\n * @inode: inode on FSID to check\n * @cred: credential to use for this operation\n *\n * Server indicates whether the FSID is present, moved, or not\n * recognized.  This operation is necessary to clear a LEASE_MOVED\n * condition for this client ID.\n *\n * Returns NFS4_OK if the FSID is present on this server,\n * -NFS4ERR_MOVED if the FSID is no longer present, a negative\n *  NFS4ERR code if some error occurred on the server, or a\n *  negative errno if a local failure occurred.\n */\nint nfs4_proc_fsid_present(struct inode *inode, const struct cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->fsid_present(inode, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}\n\n/*\n * If 'use_integrity' is true and the state managment nfs_client\n * cl_rpcclient is using krb5i/p, use the integrity protected cl_rpcclient\n * and the machine credential as per RFC3530bis and RFC5661 Security\n * Considerations sections. Otherwise, just use the user cred with the\n * filesystem's rpc_client.\n */\nstatic int _nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors, bool use_integrity)\n{\n\tint status;\n\tstruct rpc_clnt *clnt = NFS_SERVER(dir)->client;\n\tstruct nfs_client *clp = NFS_SERVER(dir)->nfs_client;\n\tstruct nfs4_secinfo_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors     = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = NFS_SERVER(dir),\n\t\t.seq_args = &args.seq_args,\n\t\t.seq_res = &res.seq_res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = clp->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tconst struct cred *cred = NULL;\n\n\tif (use_integrity) {\n\t\tclnt = clp->cl_rpcclient;\n\t\ttask_setup.rpc_client = clnt;\n\n\t\tcred = nfs4_get_clid_cred(clp);\n\t\tmsg.rpc_cred = cred;\n\t}\n\n\tdprintk(\"NFS call  secinfo %s\\n\", name->name);\n\n\tnfs4_state_protect(clp, NFS_SP4_MACH_CRED_SECINFO, &clnt, &msg);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\tstatus = nfs4_call_sync_custom(&task_setup);\n\n\tdprintk(\"NFS reply  secinfo: %d\\n\", status);\n\n\tput_cred(cred);\n\treturn status;\n}\n\nint nfs4_proc_secinfo(struct inode *dir, const struct qstr *name,\n\t\t      struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = -NFS4ERR_WRONGSEC;\n\n\t\t/* try to use integrity protection with machine cred */\n\t\tif (_nfs4_is_integrity_protected(NFS_SERVER(dir)->nfs_client))\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, true);\n\n\t\t/*\n\t\t * if unable to use integrity protection, or SECINFO with\n\t\t * integrity protection returns NFS4ERR_WRONGSEC (which is\n\t\t * disallowed by spec, but exists in deployed servers) use\n\t\t * the current filesystem's rpc_client and the user cred.\n\t\t */\n\t\tif (err == -NFS4ERR_WRONGSEC)\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, false);\n\n\t\ttrace_nfs4_secinfo(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Check the exchange flags returned by the server for invalid flags, having\n * both PNFS and NON_PNFS flags set, and not having one of NON_PNFS, PNFS, or\n * DS flags set.\n */\nstatic int nfs4_check_cl_exchange_flags(u32 flags, u32 version)\n{\n\tif (version >= 2 && (flags & ~EXCHGID4_2_FLAG_MASK_R))\n\t\tgoto out_inval;\n\telse if (version < 2 && (flags & ~EXCHGID4_FLAG_MASK_R))\n\t\tgoto out_inval;\n\tif ((flags & EXCHGID4_FLAG_USE_PNFS_MDS) &&\n\t    (flags & EXCHGID4_FLAG_USE_NON_PNFS))\n\t\tgoto out_inval;\n\tif (!(flags & (EXCHGID4_FLAG_MASK_PNFS)))\n\t\tgoto out_inval;\n\treturn NFS_OK;\nout_inval:\n\treturn -NFS4ERR_INVAL;\n}\n\nstatic bool\nnfs41_same_server_scope(struct nfs41_server_scope *a,\n\t\t\tstruct nfs41_server_scope *b)\n{\n\tif (a->server_scope_sz != b->server_scope_sz)\n\t\treturn false;\n\treturn memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;\n}\n\nstatic void\nnfs4_bind_one_conn_to_session_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_bind_conn_to_session_args *args = task->tk_msg.rpc_argp;\n\tstruct nfs41_bind_conn_to_session_res *res = task->tk_msg.rpc_resp;\n\tstruct nfs_client *clp = args->client;\n\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tnfs4_schedule_session_recovery(clp->cl_session,\n\t\t\t\ttask->tk_status);\n\t}\n\tif (args->dir == NFS4_CDFC4_FORE_OR_BOTH &&\n\t\t\tres->dir != NFS4_CDFS4_BOTH) {\n\t\trpc_task_close_connection(task);\n\t\tif (args->retries++ < MAX_BIND_CONN_TO_SESSION_RETRIES)\n\t\t\trpc_restart_call(task);\n\t}\n}\n\nstatic const struct rpc_call_ops nfs4_bind_one_conn_to_session_ops = {\n\t.rpc_call_done =  nfs4_bind_one_conn_to_session_done,\n};\n\n/*\n * nfs4_proc_bind_one_conn_to_session()\n *\n * The 4.1 client currently uses the same TCP connection for the\n * fore and backchannel.\n */\nstatic\nint nfs4_proc_bind_one_conn_to_session(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tstruct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tint status;\n\tstruct nfs41_bind_conn_to_session_args args = {\n\t\t.client = clp,\n\t\t.dir = NFS4_CDFC4_FORE_OR_BOTH,\n\t\t.retries = 0,\n\t};\n\tstruct nfs41_bind_conn_to_session_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc =\n\t\t\t&nfs4_procedures[NFSPROC4_CLNT_BIND_CONN_TO_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_xprt = xprt,\n\t\t.callback_ops = &nfs4_bind_one_conn_to_session_ops,\n\t\t.rpc_message = &msg,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\tstruct rpc_task *task;\n\n\tnfs4_copy_sessionid(&args.sessionid, &clp->cl_session->sess_id);\n\tif (!(clp->cl_session->flags & SESSION4_BACK_CHAN))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\t/* Do not set the backchannel flag unless this is clnt->cl_xprt */\n\tif (xprt != rcu_access_pointer(clnt->cl_xprt))\n\t\targs.dir = NFS4_CDFC4_FORE;\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (!IS_ERR(task)) {\n\t\tstatus = task->tk_status;\n\t\trpc_put_task(task);\n\t} else\n\t\tstatus = PTR_ERR(task);\n\ttrace_nfs4_bind_conn_to_session(clp, status);\n\tif (status == 0) {\n\t\tif (memcmp(res.sessionid.data,\n\t\t    clp->cl_session->sess_id.data, NFS4_MAX_SESSIONID_LEN)) {\n\t\t\tdprintk(\"NFS: %s: Session ID mismatch\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((res.dir & args.dir) != res.dir || res.dir == 0) {\n\t\t\tdprintk(\"NFS: %s: Unexpected direction from server\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (res.use_conn_in_rdma_mode != args.use_conn_in_rdma_mode) {\n\t\t\tdprintk(\"NFS: %s: Server returned RDMA mode = true\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstruct rpc_bind_conn_calldata {\n\tstruct nfs_client *clp;\n\tconst struct cred *cred;\n};\n\nstatic int\nnfs4_proc_bind_conn_to_session_callback(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tvoid *calldata)\n{\n\tstruct rpc_bind_conn_calldata *p = calldata;\n\n\treturn nfs4_proc_bind_one_conn_to_session(clnt, xprt, p->clp, p->cred);\n}\n\nint nfs4_proc_bind_conn_to_session(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct rpc_bind_conn_calldata data = {\n\t\t.clp = clp,\n\t\t.cred = cred,\n\t};\n\treturn rpc_clnt_iterate_for_each_xprt(clp->cl_rpcclient,\n\t\t\tnfs4_proc_bind_conn_to_session_callback, &data);\n}\n\n/*\n * Minimum set of SP4_MACH_CRED operations from RFC 5661 in the enforce map\n * and operations we'd like to see to enable certain features in the allow map\n */\nstatic const struct nfs41_state_protection nfs4_sp4_mach_cred_request = {\n\t.how = SP4_MACH_CRED,\n\t.enforce.u.words = {\n\t\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t\t      1 << (OP_EXCHANGE_ID - 32) |\n\t\t      1 << (OP_CREATE_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_CLIENTID - 32)\n\t},\n\t.allow.u.words = {\n\t\t[0] = 1 << (OP_CLOSE) |\n\t\t      1 << (OP_OPEN_DOWNGRADE) |\n\t\t      1 << (OP_LOCKU) |\n\t\t      1 << (OP_DELEGRETURN) |\n\t\t      1 << (OP_COMMIT),\n\t\t[1] = 1 << (OP_SECINFO - 32) |\n\t\t      1 << (OP_SECINFO_NO_NAME - 32) |\n\t\t      1 << (OP_LAYOUTRETURN - 32) |\n\t\t      1 << (OP_TEST_STATEID - 32) |\n\t\t      1 << (OP_FREE_STATEID - 32) |\n\t\t      1 << (OP_WRITE - 32)\n\t}\n};\n\n/*\n * Select the state protection mode for client `clp' given the server results\n * from exchange_id in `sp'.\n *\n * Returns 0 on success, negative errno otherwise.\n */\nstatic int nfs4_sp4_select_mode(struct nfs_client *clp,\n\t\t\t\t struct nfs41_state_protection *sp)\n{\n\tstatic const u32 supported_enforce[NFS4_OP_MAP_NUM_WORDS] = {\n\t\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t\t      1 << (OP_EXCHANGE_ID - 32) |\n\t\t      1 << (OP_CREATE_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_SESSION - 32) |\n\t\t      1 << (OP_DESTROY_CLIENTID - 32)\n\t};\n\tunsigned long flags = 0;\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (sp->how == SP4_MACH_CRED) {\n\t\t/* Print state protect result */\n\t\tdfprintk(MOUNT, \"Server SP4_MACH_CRED support:\\n\");\n\t\tfor (i = 0; i <= LAST_NFS4_OP; i++) {\n\t\t\tif (test_bit(i, sp->enforce.u.longs))\n\t\t\t\tdfprintk(MOUNT, \"  enforce op %d\\n\", i);\n\t\t\tif (test_bit(i, sp->allow.u.longs))\n\t\t\t\tdfprintk(MOUNT, \"  allow op %d\\n\", i);\n\t\t}\n\n\t\t/* make sure nothing is on enforce list that isn't supported */\n\t\tfor (i = 0; i < NFS4_OP_MAP_NUM_WORDS; i++) {\n\t\t\tif (sp->enforce.u.words[i] & ~supported_enforce[i]) {\n\t\t\t\tdfprintk(MOUNT, \"sp4_mach_cred: disabled\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Minimal mode - state operations are allowed to use machine\n\t\t * credential.  Note this already happens by default, so the\n\t\t * client doesn't have to do anything more than the negotiation.\n\t\t *\n\t\t * NOTE: we don't care if EXCHANGE_ID is in the list -\n\t\t *       we're already using the machine cred for exchange_id\n\t\t *       and will never use a different cred.\n\t\t */\n\t\tif (test_bit(OP_BIND_CONN_TO_SESSION, sp->enforce.u.longs) &&\n\t\t    test_bit(OP_CREATE_SESSION, sp->enforce.u.longs) &&\n\t\t    test_bit(OP_DESTROY_SESSION, sp->enforce.u.longs) &&\n\t\t    test_bit(OP_DESTROY_CLIENTID, sp->enforce.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"sp4_mach_cred:\\n\");\n\t\t\tdfprintk(MOUNT, \"  minimal mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_MINIMAL, &flags);\n\t\t} else {\n\t\t\tdfprintk(MOUNT, \"sp4_mach_cred: disabled\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (test_bit(OP_CLOSE, sp->allow.u.longs) &&\n\t\t    test_bit(OP_OPEN_DOWNGRADE, sp->allow.u.longs) &&\n\t\t    test_bit(OP_DELEGRETURN, sp->allow.u.longs) &&\n\t\t    test_bit(OP_LOCKU, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  cleanup mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_CLEANUP, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_LAYOUTRETURN, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  pnfs cleanup mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_PNFS_CLEANUP, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_SECINFO, sp->allow.u.longs) &&\n\t\t    test_bit(OP_SECINFO_NO_NAME, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  secinfo mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_SECINFO, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_TEST_STATEID, sp->allow.u.longs) &&\n\t\t    test_bit(OP_FREE_STATEID, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  stateid mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_STATEID, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_WRITE, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  write mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_WRITE, &flags);\n\t\t}\n\n\t\tif (test_bit(OP_COMMIT, sp->allow.u.longs)) {\n\t\t\tdfprintk(MOUNT, \"  commit mode enabled\\n\");\n\t\t\t__set_bit(NFS_SP4_MACH_CRED_COMMIT, &flags);\n\t\t}\n\t}\nout:\n\tclp->cl_sp4_flags = flags;\n\treturn ret;\n}\n\nstruct nfs41_exchange_id_data {\n\tstruct nfs41_exchange_id_res res;\n\tstruct nfs41_exchange_id_args args;\n};\n\nstatic void nfs4_exchange_id_release(void *data)\n{\n\tstruct nfs41_exchange_id_data *cdata =\n\t\t\t\t\t(struct nfs41_exchange_id_data *)data;\n\n\tnfs_put_client(cdata->args.client);\n\tkfree(cdata->res.impl_id);\n\tkfree(cdata->res.server_scope);\n\tkfree(cdata->res.server_owner);\n\tkfree(cdata);\n}\n\nstatic const struct rpc_call_ops nfs4_exchange_id_call_ops = {\n\t.rpc_release = nfs4_exchange_id_release,\n};\n\n/*\n * _nfs4_proc_exchange_id()\n *\n * Wrapper for EXCHANGE_ID operation.\n */\nstatic struct rpc_task *\nnfs4_run_exchange_id(struct nfs_client *clp, const struct cred *cred,\n\t\t\tu32 sp4_how, struct rpc_xprt *xprt)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_EXCHANGE_ID],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.callback_ops = &nfs4_exchange_id_call_ops,\n\t\t.rpc_message = &msg,\n\t\t.flags = RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tstruct nfs41_exchange_id_data *calldata;\n\tint status;\n\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\treturn ERR_PTR(-EIO);\n\n\tstatus = -ENOMEM;\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (!calldata)\n\t\tgoto out;\n\n\tnfs4_init_boot_verifier(clp, &calldata->args.verifier);\n\n\tstatus = nfs4_init_uniform_client_string(clp);\n\tif (status)\n\t\tgoto out_calldata;\n\n\tcalldata->res.server_owner = kzalloc(sizeof(struct nfs41_server_owner),\n\t\t\t\t\t\tGFP_NOFS);\n\tstatus = -ENOMEM;\n\tif (unlikely(calldata->res.server_owner == NULL))\n\t\tgoto out_calldata;\n\n\tcalldata->res.server_scope = kzalloc(sizeof(struct nfs41_server_scope),\n\t\t\t\t\tGFP_NOFS);\n\tif (unlikely(calldata->res.server_scope == NULL))\n\t\tgoto out_server_owner;\n\n\tcalldata->res.impl_id = kzalloc(sizeof(struct nfs41_impl_id), GFP_NOFS);\n\tif (unlikely(calldata->res.impl_id == NULL))\n\t\tgoto out_server_scope;\n\n\tswitch (sp4_how) {\n\tcase SP4_NONE:\n\t\tcalldata->args.state_protect.how = SP4_NONE;\n\t\tbreak;\n\n\tcase SP4_MACH_CRED:\n\t\tcalldata->args.state_protect = nfs4_sp4_mach_cred_request;\n\t\tbreak;\n\n\tdefault:\n\t\t/* unsupported! */\n\t\tWARN_ON_ONCE(1);\n\t\tstatus = -EINVAL;\n\t\tgoto out_impl_id;\n\t}\n\tif (xprt) {\n\t\ttask_setup_data.rpc_xprt = xprt;\n\t\ttask_setup_data.flags |= RPC_TASK_SOFTCONN;\n\t\tmemcpy(calldata->args.verifier.data, clp->cl_confirm.data,\n\t\t\t\tsizeof(calldata->args.verifier.data));\n\t}\n\tcalldata->args.client = clp;\n\tcalldata->args.flags = EXCHGID4_FLAG_SUPP_MOVED_REFER |\n\tEXCHGID4_FLAG_BIND_PRINC_STATEID;\n#ifdef CONFIG_NFS_V4_1_MIGRATION\n\tcalldata->args.flags |= EXCHGID4_FLAG_SUPP_MOVED_MIGR;\n#endif\n\tmsg.rpc_argp = &calldata->args;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\n\treturn rpc_run_task(&task_setup_data);\n\nout_impl_id:\n\tkfree(calldata->res.impl_id);\nout_server_scope:\n\tkfree(calldata->res.server_scope);\nout_server_owner:\n\tkfree(calldata->res.server_owner);\nout_calldata:\n\tkfree(calldata);\nout:\n\tnfs_put_client(clp);\n\treturn ERR_PTR(status);\n}\n\n/*\n * _nfs4_proc_exchange_id()\n *\n * Wrapper for EXCHANGE_ID operation.\n */\nstatic int _nfs4_proc_exchange_id(struct nfs_client *clp, const struct cred *cred,\n\t\t\tu32 sp4_how)\n{\n\tstruct rpc_task *task;\n\tstruct nfs41_exchange_id_args *argp;\n\tstruct nfs41_exchange_id_res *resp;\n\tunsigned long now = jiffies;\n\tint status;\n\n\ttask = nfs4_run_exchange_id(clp, cred, sp4_how, NULL);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\targp = task->tk_msg.rpc_argp;\n\tresp = task->tk_msg.rpc_resp;\n\tstatus = task->tk_status;\n\tif (status  != 0)\n\t\tgoto out;\n\n\tstatus = nfs4_check_cl_exchange_flags(resp->flags,\n\t\t\tclp->cl_mvops->minor_version);\n\tif (status  != 0)\n\t\tgoto out;\n\n\tstatus = nfs4_sp4_select_mode(clp, &resp->state_protect);\n\tif (status != 0)\n\t\tgoto out;\n\n\tdo_renew_lease(clp, now);\n\n\tclp->cl_clientid = resp->clientid;\n\tclp->cl_exchange_flags = resp->flags;\n\tclp->cl_seqid = resp->seqid;\n\t/* Client ID is not confirmed */\n\tif (!(resp->flags & EXCHGID4_FLAG_CONFIRMED_R))\n\t\tclear_bit(NFS4_SESSION_ESTABLISHED,\n\t\t\t  &clp->cl_session->session_state);\n\n\tif (clp->cl_serverscope != NULL &&\n\t    !nfs41_same_server_scope(clp->cl_serverscope,\n\t\t\t\tresp->server_scope)) {\n\t\tdprintk(\"%s: server_scope mismatch detected\\n\",\n\t\t\t__func__);\n\t\tset_bit(NFS4CLNT_SERVER_SCOPE_MISMATCH, &clp->cl_state);\n\t}\n\n\tswap(clp->cl_serverowner, resp->server_owner);\n\tswap(clp->cl_serverscope, resp->server_scope);\n\tswap(clp->cl_implid, resp->impl_id);\n\n\t/* Save the EXCHANGE_ID verifier session trunk tests */\n\tmemcpy(clp->cl_confirm.data, argp->verifier.data,\n\t       sizeof(clp->cl_confirm.data));\nout:\n\ttrace_nfs4_exchange_id(clp, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\n/*\n * nfs4_proc_exchange_id()\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status code.\n *\n * Since the clientid has expired, all compounds using sessions\n * associated with the stale clientid will be returning\n * NFS4ERR_BADSESSION in the sequence operation, and will therefore\n * be in some phase of session reset.\n *\n * Will attempt to negotiate SP4_MACH_CRED if krb5i / krb5p auth is used.\n */\nint nfs4_proc_exchange_id(struct nfs_client *clp, const struct cred *cred)\n{\n\trpc_authflavor_t authflavor = clp->cl_rpcclient->cl_auth->au_flavor;\n\tint status;\n\n\t/* try SP4_MACH_CRED if krb5i/p\t*/\n\tif (authflavor == RPC_AUTH_GSS_KRB5I ||\n\t    authflavor == RPC_AUTH_GSS_KRB5P) {\n\t\tstatus = _nfs4_proc_exchange_id(clp, cred, SP4_MACH_CRED);\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t/* try SP4_NONE */\n\treturn _nfs4_proc_exchange_id(clp, cred, SP4_NONE);\n}\n\n/**\n * nfs4_test_session_trunk\n *\n * This is an add_xprt_test() test function called from\n * rpc_clnt_setup_test_and_add_xprt.\n *\n * The rpc_xprt_switch is referrenced by rpc_clnt_setup_test_and_add_xprt\n * and is dereferrenced in nfs4_exchange_id_release\n *\n * Upon success, add the new transport to the rpc_clnt\n *\n * @clnt: struct rpc_clnt to get new transport\n * @xprt: the rpc_xprt to test\n * @data: call data for _nfs4_proc_exchange_id.\n */\nvoid nfs4_test_session_trunk(struct rpc_clnt *clnt, struct rpc_xprt *xprt,\n\t\t\t    void *data)\n{\n\tstruct nfs4_add_xprt_data *adata = (struct nfs4_add_xprt_data *)data;\n\tstruct rpc_task *task;\n\tint status;\n\n\tu32 sp4_how;\n\n\tdprintk(\"--> %s try %s\\n\", __func__,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\tsp4_how = (adata->clp->cl_sp4_flags == 0 ? SP4_NONE : SP4_MACH_CRED);\n\n\t/* Test connection for session trunking. Async exchange_id call */\n\ttask = nfs4_run_exchange_id(adata->clp, adata->cred, sp4_how, xprt);\n\tif (IS_ERR(task))\n\t\treturn;\n\n\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tstatus = nfs4_detect_session_trunking(adata->clp,\n\t\t\t\ttask->tk_msg.rpc_resp, xprt);\n\n\tif (status == 0)\n\t\trpc_clnt_xprt_switch_add_xprt(clnt, xprt);\n\n\trpc_put_task(task);\n}\nEXPORT_SYMBOL_GPL(nfs4_test_session_trunk);\n\nstatic int _nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_CLIENTID],\n\t\t.rpc_argp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_destroy_clientid(clp, status);\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server %s on \"\n\t\t\t\"DESTROY_CLIENTID.\", status, clp->cl_hostname);\n\treturn status;\n}\n\nstatic int nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tunsigned int loop;\n\tint ret;\n\n\tfor (loop = NFS4_MAX_LOOP_ON_RECOVER; loop != 0; loop--) {\n\t\tret = _nfs4_proc_destroy_clientid(clp, cred);\n\t\tswitch (ret) {\n\t\tcase -NFS4ERR_DELAY:\n\t\tcase -NFS4ERR_CLIENTID_BUSY:\n\t\t\tssleep(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tconst struct cred *cred;\n\tint ret = 0;\n\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_clid_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tput_cred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}\n\n#endif /* CONFIG_NFS_V4_1 */\n\nstruct nfs4_get_lease_time_data {\n\tstruct nfs4_get_lease_time_args *args;\n\tstruct nfs4_get_lease_time_res *res;\n\tstruct nfs_client *clp;\n};\n\nstatic void nfs4_get_lease_time_prepare(struct rpc_task *task,\n\t\t\t\t\tvoid *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\t/* just setup sequence, do not trigger session recovery\n\t   since we're invoked within one */\n\tnfs4_setup_sequence(data->clp,\n\t\t\t&data->args->la_seq_args,\n\t\t\t&data->res->lr_seq_res,\n\t\t\ttask);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\n/*\n * Called from nfs4_state_manager thread for session setup, so don't recover\n * from sequence operation or clientid errors.\n */\nstatic void nfs4_get_lease_time_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_get_lease_time_data *data =\n\t\t\t(struct nfs4_get_lease_time_data *)calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs4_sequence_done(task, &data->res->lr_seq_res))\n\t\treturn;\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_GRACE:\n\t\tdprintk(\"%s Retry: tk_status %d\\n\", __func__, task->tk_status);\n\t\trpc_delay(task, NFS4_POLL_RETRY_MIN);\n\t\ttask->tk_status = 0;\n\t\tfallthrough;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_get_lease_time_ops = {\n\t.rpc_call_prepare = nfs4_get_lease_time_prepare,\n\t.rpc_call_done = nfs4_get_lease_time_done,\n};\n\nint nfs4_proc_get_lease_time(struct nfs_client *clp, struct nfs_fsinfo *fsinfo)\n{\n\tstruct nfs4_get_lease_time_args args;\n\tstruct nfs4_get_lease_time_res res = {\n\t\t.lr_fsinfo = fsinfo,\n\t};\n\tstruct nfs4_get_lease_time_data data = {\n\t\t.args = &args,\n\t\t.res = &res,\n\t\t.clp = clp,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GET_LEASE_TIME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_get_lease_time_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_TIMEOUT,\n\t};\n\n\tnfs4_init_sequence(&args.la_seq_args, &res.lr_seq_res, 0, 1);\n\treturn nfs4_call_sync_custom(&task_setup);\n}\n\n#ifdef CONFIG_NFS_V4_1\n\n/*\n * Initialize the values to be used by the client in CREATE_SESSION\n * If nfs4_init_session set the fore channel request and response sizes,\n * use them.\n *\n * Set the back channel max_resp_sz_cached to zero to force the client to\n * always set csa_cachethis to FALSE because the current implementation\n * of the back channel DRC only supports caching the CB_SEQUENCE operation.\n */\nstatic void nfs4_init_channel_attrs(struct nfs41_create_session_args *args,\n\t\t\t\t    struct rpc_clnt *clnt)\n{\n\tunsigned int max_rqst_sz, max_resp_sz;\n\tunsigned int max_bc_payload = rpc_max_bc_payload(clnt);\n\tunsigned int max_bc_slots = rpc_num_bc_slots(clnt);\n\n\tmax_rqst_sz = NFS_MAX_FILE_IO_SIZE + nfs41_maxwrite_overhead;\n\tmax_resp_sz = NFS_MAX_FILE_IO_SIZE + nfs41_maxread_overhead;\n\n\t/* Fore channel attributes */\n\targs->fc_attrs.max_rqst_sz = max_rqst_sz;\n\targs->fc_attrs.max_resp_sz = max_resp_sz;\n\targs->fc_attrs.max_ops = NFS4_MAX_OPS;\n\targs->fc_attrs.max_reqs = max_session_slots;\n\n\tdprintk(\"%s: Fore Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->fc_attrs.max_rqst_sz, args->fc_attrs.max_resp_sz,\n\t\targs->fc_attrs.max_ops, args->fc_attrs.max_reqs);\n\n\t/* Back channel attributes */\n\targs->bc_attrs.max_rqst_sz = max_bc_payload;\n\targs->bc_attrs.max_resp_sz = max_bc_payload;\n\targs->bc_attrs.max_resp_sz_cached = 0;\n\targs->bc_attrs.max_ops = NFS4_MAX_BACK_CHANNEL_OPS;\n\targs->bc_attrs.max_reqs = max_t(unsigned short, max_session_cb_slots, 1);\n\tif (args->bc_attrs.max_reqs > max_bc_slots)\n\t\targs->bc_attrs.max_reqs = max_bc_slots;\n\n\tdprintk(\"%s: Back Channel : max_rqst_sz=%u max_resp_sz=%u \"\n\t\t\"max_resp_sz_cached=%u max_ops=%u max_reqs=%u\\n\",\n\t\t__func__,\n\t\targs->bc_attrs.max_rqst_sz, args->bc_attrs.max_resp_sz,\n\t\targs->bc_attrs.max_resp_sz_cached, args->bc_attrs.max_ops,\n\t\targs->bc_attrs.max_reqs);\n}\n\nstatic int nfs4_verify_fore_channel_attrs(struct nfs41_create_session_args *args,\n\t\tstruct nfs41_create_session_res *res)\n{\n\tstruct nfs4_channel_attrs *sent = &args->fc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &res->fc_attrs;\n\n\tif (rcvd->max_resp_sz > sent->max_resp_sz)\n\t\treturn -EINVAL;\n\t/*\n\t * Our requested max_ops is the minimum we need; we're not\n\t * prepared to break up compounds into smaller pieces than that.\n\t * So, no point even trying to continue if the server won't\n\t * cooperate:\n\t */\n\tif (rcvd->max_ops < sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs == 0)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs > NFS4_MAX_SLOT_TABLE)\n\t\trcvd->max_reqs = NFS4_MAX_SLOT_TABLE;\n\treturn 0;\n}\n\nstatic int nfs4_verify_back_channel_attrs(struct nfs41_create_session_args *args,\n\t\tstruct nfs41_create_session_res *res)\n{\n\tstruct nfs4_channel_attrs *sent = &args->bc_attrs;\n\tstruct nfs4_channel_attrs *rcvd = &res->bc_attrs;\n\n\tif (!(res->flags & SESSION4_BACK_CHAN))\n\t\tgoto out;\n\tif (rcvd->max_rqst_sz > sent->max_rqst_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz < sent->max_resp_sz)\n\t\treturn -EINVAL;\n\tif (rcvd->max_resp_sz_cached > sent->max_resp_sz_cached)\n\t\treturn -EINVAL;\n\tif (rcvd->max_ops > sent->max_ops)\n\t\treturn -EINVAL;\n\tif (rcvd->max_reqs > sent->max_reqs)\n\t\treturn -EINVAL;\nout:\n\treturn 0;\n}\n\nstatic int nfs4_verify_channel_attrs(struct nfs41_create_session_args *args,\n\t\t\t\t     struct nfs41_create_session_res *res)\n{\n\tint ret;\n\n\tret = nfs4_verify_fore_channel_attrs(args, res);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_verify_back_channel_attrs(args, res);\n}\n\nstatic void nfs4_update_session(struct nfs4_session *session,\n\t\tstruct nfs41_create_session_res *res)\n{\n\tnfs4_copy_sessionid(&session->sess_id, &res->sessionid);\n\t/* Mark client id and session as being confirmed */\n\tsession->clp->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\tset_bit(NFS4_SESSION_ESTABLISHED, &session->session_state);\n\tsession->flags = res->flags;\n\tmemcpy(&session->fc_attrs, &res->fc_attrs, sizeof(session->fc_attrs));\n\tif (res->flags & SESSION4_BACK_CHAN)\n\t\tmemcpy(&session->bc_attrs, &res->bc_attrs,\n\t\t\t\tsizeof(session->bc_attrs));\n}\n\nstatic int _nfs4_proc_create_session(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_session *session = clp->cl_session;\n\tstruct nfs41_create_session_args args = {\n\t\t.client = clp,\n\t\t.clientid = clp->cl_clientid,\n\t\t.seqid = clp->cl_seqid,\n\t\t.cb_program = NFS4_CALLBACK,\n\t};\n\tstruct nfs41_create_session_res res;\n\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CREATE_SESSION],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tnfs4_init_channel_attrs(&args, clp->cl_rpcclient);\n\targs.flags = (SESSION4_PERSIST | SESSION4_BACK_CHAN);\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_create_session(clp, status);\n\n\tswitch (status) {\n\tcase -NFS4ERR_STALE_CLIENTID:\n\tcase -NFS4ERR_DELAY:\n\tcase -ETIMEDOUT:\n\tcase -EACCES:\n\tcase -EAGAIN:\n\t\tgoto out;\n\t}\n\n\tclp->cl_seqid++;\n\tif (!status) {\n\t\t/* Verify the session's negotiated channel_attrs values */\n\t\tstatus = nfs4_verify_channel_attrs(&args, &res);\n\t\t/* Increment the clientid slot sequence id */\n\t\tif (status)\n\t\t\tgoto out;\n\t\tnfs4_update_session(session, &res);\n\t}\nout:\n\treturn status;\n}\n\n/*\n * Issues a CREATE_SESSION operation to the server.\n * It is the responsibility of the caller to verify the session is\n * expired before calling this routine.\n */\nint nfs4_proc_create_session(struct nfs_client *clp, const struct cred *cred)\n{\n\tint status;\n\tunsigned *ptr;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tdprintk(\"--> %s clp=%p session=%p\\n\", __func__, clp, session);\n\n\tstatus = _nfs4_proc_create_session(clp, cred);\n\tif (status)\n\t\tgoto out;\n\n\t/* Init or reset the session slot tables */\n\tstatus = nfs4_setup_session_slot_tables(session);\n\tdprintk(\"slot table setup returned %d\\n\", status);\n\tif (status)\n\t\tgoto out;\n\n\tptr = (unsigned *)&session->sess_id.data[0];\n\tdprintk(\"%s client>seqid %d sessionid %u:%u:%u:%u\\n\", __func__,\n\t\tclp->cl_seqid, ptr[0], ptr[1], ptr[2], ptr[3]);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}\n\n/*\n * Issue the over-the-wire RPC DESTROY_SESSION.\n * The caller must serialize access to this routine.\n */\nint nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tconst struct cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> nfs4_proc_destroy_session\\n\");\n\n\t/* session is still being setup */\n\tif (!test_and_clear_bit(NFS4_SESSION_ESTABLISHED, &session->session_state))\n\t\treturn 0;\n\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg,\n\t\t\t       RPC_TASK_TIMEOUT | RPC_TASK_NO_ROUND_ROBIN);\n\ttrace_nfs4_destroy_session(session->clp, status);\n\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\n\tdprintk(\"<-- nfs4_proc_destroy_session\\n\");\n\treturn status;\n}\n\n/*\n * Renew the cl_session lease.\n */\nstruct nfs4_sequence_data {\n\tstruct nfs_client *clp;\n\tstruct nfs4_sequence_args args;\n\tstruct nfs4_sequence_res res;\n};\n\nstatic void nfs41_sequence_release(void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (refcount_read(&clp->cl_count) > 1)\n\t\tnfs4_schedule_state_renewal(clp);\n\tnfs_put_client(clp);\n\tkfree(calldata);\n}\n\nstatic int nfs41_sequence_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\treturn -EAGAIN;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs41_sequence_call_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\n\tif (!nfs41_sequence_done(task, task->tk_msg.rpc_resp))\n\t\treturn;\n\n\ttrace_nfs4_sequence(clp, task->tk_status);\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"%s ERROR %d\\n\", __func__, task->tk_status);\n\t\tif (refcount_read(&clp->cl_count) == 1)\n\t\t\tgoto out;\n\n\t\tif (nfs41_sequence_handle_errors(task, clp) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n\tdprintk(\"%s rpc_cred %p\\n\", __func__, task->tk_msg.rpc_cred);\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs41_sequence_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_sequence_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_args *args;\n\tstruct nfs4_sequence_res *res;\n\n\targs = task->tk_msg.rpc_argp;\n\tres = task->tk_msg.rpc_resp;\n\n\tnfs4_setup_sequence(clp, args, res, task);\n}\n\nstatic const struct rpc_call_ops nfs41_sequence_ops = {\n\t.rpc_call_done = nfs41_sequence_call_done,\n\t.rpc_call_prepare = nfs41_sequence_prepare,\n\t.rpc_release = nfs41_sequence_release,\n};\n\nstatic struct rpc_task *_nfs41_proc_sequence(struct nfs_client *clp,\n\t\tconst struct cred *cred,\n\t\tstruct nfs4_slot *slot,\n\t\tbool is_privileged)\n{\n\tstruct nfs4_sequence_data *calldata;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEQUENCE],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs41_sequence_ops,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_TIMEOUT,\n\t};\n\tstruct rpc_task *ret;\n\n\tret = ERR_PTR(-EIO);\n\tif (!refcount_inc_not_zero(&clp->cl_count))\n\t\tgoto out_err;\n\n\tret = ERR_PTR(-ENOMEM);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL)\n\t\tgoto out_put_clp;\n\tnfs4_init_sequence(&calldata->args, &calldata->res, 0, is_privileged);\n\tnfs4_sequence_attach_slot(&calldata->args, &calldata->res, slot);\n\tmsg.rpc_argp = &calldata->args;\n\tmsg.rpc_resp = &calldata->res;\n\tcalldata->clp = clp;\n\ttask_setup_data.callback_data = calldata;\n\n\tret = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(ret))\n\t\tgoto out_err;\n\treturn ret;\nout_put_clp:\n\tnfs_put_client(clp);\nout_err:\n\tnfs41_release_slot(slot);\n\treturn ret;\n}\n\nstatic int nfs41_proc_async_sequence(struct nfs_client *clp, const struct cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_task *task;\n\tint ret = 0;\n\n\tif ((renew_flags & NFS4_RENEW_TIMEOUT) == 0)\n\t\treturn -EAGAIN;\n\ttask = _nfs41_proc_sequence(clp, cred, NULL, false);\n\tif (IS_ERR(task))\n\t\tret = PTR_ERR(task);\n\telse\n\t\trpc_put_task_async(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int nfs4_proc_sequence(struct nfs_client *clp, const struct cred *cred)\n{\n\tstruct rpc_task *task;\n\tint ret;\n\n\ttask = _nfs41_proc_sequence(clp, cred, NULL, true);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tret = rpc_wait_for_completion_task(task);\n\tif (!ret)\n\t\tret = task->tk_status;\n\trpc_put_task(task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstruct nfs4_reclaim_complete_data {\n\tstruct nfs_client *clp;\n\tstruct nfs41_reclaim_complete_args arg;\n\tstruct nfs41_reclaim_complete_res res;\n};\n\nstatic void nfs4_reclaim_complete_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\tnfs4_setup_sequence(calldata->clp,\n\t\t\t&calldata->arg.seq_args,\n\t\t\t&calldata->res.seq_res,\n\t\t\ttask);\n}\n\nstatic int nfs41_reclaim_complete_handle_errors(struct rpc_task *task, struct nfs_client *clp)\n{\n\tswitch(task->tk_status) {\n\tcase 0:\n\t\twake_up_all(&clp->cl_lock_waitq);\n\t\tfallthrough;\n\tcase -NFS4ERR_COMPLETE_ALREADY:\n\tcase -NFS4ERR_WRONG_CRED: /* What to do here? */\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, NFS4_POLL_RETRY_MAX);\n\t\tfallthrough;\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\treturn -EAGAIN;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\tbreak;\n\tdefault:\n\t\tnfs4_schedule_lease_recovery(clp);\n\t}\n\treturn 0;\n}\n\nstatic void nfs4_reclaim_complete_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\tstruct nfs_client *clp = calldata->clp;\n\tstruct nfs4_sequence_res *res = &calldata->res.seq_res;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!nfs41_sequence_done(task, res))\n\t\treturn;\n\n\ttrace_nfs4_reclaim_complete(clp, task->tk_status);\n\tif (nfs41_reclaim_complete_handle_errors(task, clp) == -EAGAIN) {\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs4_free_reclaim_complete_data(void *data)\n{\n\tstruct nfs4_reclaim_complete_data *calldata = data;\n\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs4_reclaim_complete_call_ops = {\n\t.rpc_call_prepare = nfs4_reclaim_complete_prepare,\n\t.rpc_call_done = nfs4_reclaim_complete_done,\n\t.rpc_release = nfs4_free_reclaim_complete_data,\n};\n\n/*\n * Issue a global reclaim complete.\n */\nstatic int nfs41_proc_reclaim_complete(struct nfs_client *clp,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_reclaim_complete_data *calldata;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RECLAIM_COMPLETE],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clp->cl_rpcclient,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_reclaim_complete_call_ops,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tcalldata = kzalloc(sizeof(*calldata), GFP_NOFS);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->clp = clp;\n\tcalldata->arg.one_fs = 0;\n\n\tnfs4_init_sequence(&calldata->arg.seq_args, &calldata->res.seq_res, 0, 1);\n\tmsg.rpc_argp = &calldata->arg;\n\tmsg.rpc_resp = &calldata->res;\n\ttask_setup_data.callback_data = calldata;\n\tstatus = nfs4_call_sync_custom(&task_setup_data);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic void\nnfs4_layoutget_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_setup_sequence(server->nfs_client, &lgp->args.seq_args,\n\t\t\t\t&lgp->res.seq_res, task);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic void nfs4_layoutget_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs41_sequence_process(task, &lgp->res.seq_res);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic int\nnfs4_layoutget_handle_exception(struct rpc_task *task,\n\t\tstruct nfs4_layoutget *lgp, struct nfs4_exception *exception)\n{\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct pnfs_layout_hdr *lo;\n\tint nfs4err = task->tk_status;\n\tint err, status = 0;\n\tLIST_HEAD(head);\n\n\tdprintk(\"--> %s tk_status => %d\\n\", __func__, -task->tk_status);\n\n\tnfs4_sequence_free_slot(&lgp->res.seq_res);\n\n\tswitch (nfs4err) {\n\tcase 0:\n\t\tgoto out;\n\n\t/*\n\t * NFS4ERR_LAYOUTUNAVAILABLE means we are not supposed to use pnfs\n\t * on the file. set tk_status to -ENODATA to tell upper layer to\n\t * retry go inband.\n\t */\n\tcase -NFS4ERR_LAYOUTUNAVAILABLE:\n\t\tstatus = -ENODATA;\n\t\tgoto out;\n\t/*\n\t * NFS4ERR_BADLAYOUT means the MDS cannot return a layout of\n\t * length lgp->args.minlength != 0 (see RFC5661 section 18.43.3).\n\t */\n\tcase -NFS4ERR_BADLAYOUT:\n\t\tstatus = -EOVERFLOW;\n\t\tgoto out;\n\t/*\n\t * NFS4ERR_LAYOUTTRYLATER is a conflict with another client\n\t * (or clients) writing to the same RAID stripe except when\n\t * the minlength argument is 0 (see RFC5661 section 18.43.3).\n\t *\n\t * Treat it like we would RECALLCONFLICT -- we retry for a little\n\t * while, and then eventually give up.\n\t */\n\tcase -NFS4ERR_LAYOUTTRYLATER:\n\t\tif (lgp->args.minlength == 0) {\n\t\t\tstatus = -EOVERFLOW;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = -EBUSY;\n\t\tbreak;\n\tcase -NFS4ERR_RECALLCONFLICT:\n\t\tstatus = -ERECALLCONFLICT;\n\t\tbreak;\n\tcase -NFS4ERR_DELEG_REVOKED:\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_EXPIRED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\texception->timeout = 0;\n\t\tspin_lock(&inode->i_lock);\n\t\tlo = NFS_I(inode)->layout;\n\t\t/* If the open stateid was bad, then recover it. */\n\t\tif (!lo || test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags) ||\n\t\t    !nfs4_stateid_match_other(&lgp->args.stateid, &lo->plh_stateid)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\texception->state = lgp->args.ctx->state;\n\t\t\texception->stateid = &lgp->args.stateid;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Mark the bad layout state as invalid, then retry\n\t\t */\n\t\tpnfs_mark_layout_stateid_invalid(lo, &head);\n\t\tspin_unlock(&inode->i_lock);\n\t\tnfs_commit_inode(inode, 0);\n\t\tpnfs_free_lseg_list(&head);\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terr = nfs4_handle_exception(server, nfs4err, exception);\n\tif (!status) {\n\t\tif (exception->retry)\n\t\t\tstatus = -EAGAIN;\n\t\telse\n\t\t\tstatus = err;\n\t}\nout:\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn status;\n}\n\nsize_t max_response_pages(struct nfs_server *server)\n{\n\tu32 max_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\n\treturn nfs_page_array_len(0, max_resp_sz);\n}\n\nstatic void nfs4_layoutget_release(void *calldata)\n{\n\tstruct nfs4_layoutget *lgp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_sequence_free_slot(&lgp->res.seq_res);\n\tpnfs_layoutget_free(lgp);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutget_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutget_prepare,\n\t.rpc_call_done = nfs4_layoutget_done,\n\t.rpc_release = nfs4_layoutget_release,\n};\n\nstruct pnfs_layout_segment *\nnfs4_proc_layoutget(struct nfs4_layoutget *lgp, long *timeout)\n{\n\tstruct inode *inode = lgp->args.inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t\t.rpc_cred = lgp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_CRED_NOREF,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tstruct nfs4_exception exception = {\n\t\t.inode = inode,\n\t\t.timeout = *timeout,\n\t};\n\tint status = 0;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\t/* nfs4_layoutget_release calls pnfs_put_layout_hdr */\n\tpnfs_get_layout_hdr(NFS_I(inode)->layout);\n\n\tnfs4_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0, 0);\n\n\ttask = rpc_run_task(&task_setup_data);\n\n\tstatus = rpc_wait_for_completion_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\n\tif (task->tk_status < 0) {\n\t\tstatus = nfs4_layoutget_handle_exception(task, lgp, &exception);\n\t\t*timeout = exception.timeout;\n\t} else if (lgp->res.layoutp->len == 0) {\n\t\tstatus = -EAGAIN;\n\t\t*timeout = nfs4_update_delay(&exception.timeout);\n\t} else\n\t\tlseg = pnfs_layout_process(lgp);\nout:\n\ttrace_nfs4_layoutget(lgp->args.ctx,\n\t\t\t&lgp->args.range,\n\t\t\t&lgp->res.range,\n\t\t\t&lgp->res.stateid,\n\t\t\tstatus);\n\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}\n\nstatic void\nnfs4_layoutreturn_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_setup_sequence(lrp->clp,\n\t\t\t&lrp->args.seq_args,\n\t\t\t&lrp->res.seq_res,\n\t\t\ttask);\n\tif (!pnfs_layout_is_valid(lrp->args.layout))\n\t\trpc_exit(task, 0);\n}\n\nstatic void nfs4_layoutreturn_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct nfs_server *server;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\n\tif (!nfs41_sequence_process(task, &lrp->res.seq_res))\n\t\treturn;\n\n\t/*\n\t * Was there an RPC level error? Assume the call succeeded,\n\t * and that we need to release the layout\n\t */\n\tif (task->tk_rpc_status != 0 && RPC_WAS_SENT(task)) {\n\t\tlrp->res.lrs_present = 0;\n\t\treturn;\n\t}\n\n\tserver = NFS_SERVER(lrp->args.inode);\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_OLD_STATEID:\n\t\tif (nfs4_layout_refresh_old_stateid(&lrp->args.stateid,\n\t\t\t\t\t&lrp->args.range,\n\t\t\t\t\tlrp->args.inode))\n\t\t\tgoto out_restart;\n\t\tfallthrough;\n\tdefault:\n\t\ttask->tk_status = 0;\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tcase -NFS4ERR_DELAY:\n\t\tif (nfs4_async_handle_error(task, server, NULL, NULL) != -EAGAIN)\n\t\t\tbreak;\n\t\tgoto out_restart;\n\t}\n\tdprintk(\"<-- %s\\n\", __func__);\n\treturn;\nout_restart:\n\ttask->tk_status = 0;\n\tnfs4_sequence_free_slot(&lrp->res.seq_res);\n\trpc_restart_call_prepare(task);\n}\n\nstatic void nfs4_layoutreturn_release(void *calldata)\n{\n\tstruct nfs4_layoutreturn *lrp = calldata;\n\tstruct pnfs_layout_hdr *lo = lrp->args.layout;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tpnfs_layoutreturn_free_lsegs(lo, &lrp->args.stateid, &lrp->args.range,\n\t\t\tlrp->res.lrs_present ? &lrp->res.stateid : NULL);\n\tnfs4_sequence_free_slot(&lrp->res.seq_res);\n\tif (lrp->ld_private.ops && lrp->ld_private.ops->free)\n\t\tlrp->ld_private.ops->free(&lrp->ld_private);\n\tpnfs_put_layout_hdr(lrp->args.layout);\n\tnfs_iput_and_deactive(lrp->inode);\n\tput_cred(lrp->cred);\n\tkfree(calldata);\n\tdprintk(\"<-- %s\\n\", __func__);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutreturn_call_ops = {\n\t.rpc_call_prepare = nfs4_layoutreturn_prepare,\n\t.rpc_call_done = nfs4_layoutreturn_done,\n\t.rpc_release = nfs4_layoutreturn_release,\n};\n\nint nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp, bool sync)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTRETURN],\n\t\t.rpc_argp = &lrp->args,\n\t\t.rpc_resp = &lrp->res,\n\t\t.rpc_cred = lrp->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = NFS_SERVER(lrp->args.inode)->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutreturn_call_ops,\n\t\t.callback_data = lrp,\n\t};\n\tint status = 0;\n\n\tnfs4_state_protect(NFS_SERVER(lrp->args.inode)->nfs_client,\n\t\t\tNFS_SP4_MACH_CRED_PNFS_CLEANUP,\n\t\t\t&task_setup_data.rpc_client, &msg);\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tif (!sync) {\n\t\tlrp->inode = nfs_igrab_and_active(lrp->args.inode);\n\t\tif (!lrp->inode) {\n\t\t\tnfs4_layoutreturn_release(lrp);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags |= RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&lrp->args.seq_args, &lrp->res.seq_res, 1, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutreturn(lrp->args.inode, &lrp->args.stateid, status);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic int\n_nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_getdeviceinfo_args args = {\n\t\t.pdev = pdev,\n\t\t.notify_types = NOTIFY_DEVICEID4_CHANGE |\n\t\t\tNOTIFY_DEVICEID4_DELETE,\n\t};\n\tstruct nfs4_getdeviceinfo_res res = {\n\t\t.pdev = pdev,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETDEVICEINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tstatus = nfs4_call_sync(server->client, server, &msg, &args.seq_args, &res.seq_res, 0);\n\tif (res.notification & ~args.notify_types)\n\t\tdprintk(\"%s: unsupported notification\\n\", __func__);\n\tif (res.notification != args.notify_types)\n\t\tpdev->nocache = 1;\n\n\ttrace_nfs4_getdeviceinfo(server, &pdev->dev_id, status);\n\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\n\treturn status;\n}\n\nint nfs4_proc_getdeviceinfo(struct nfs_server *server,\n\t\tstruct pnfs_device *pdev,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t\t_nfs4_proc_getdeviceinfo(server, pdev, cred),\n\t\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nfs4_proc_getdeviceinfo);\n\nstatic void nfs4_layoutcommit_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tnfs4_setup_sequence(server->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic void\nnfs4_layoutcommit_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\tstruct nfs_server *server = NFS_SERVER(data->args.inode);\n\n\tif (!nfs41_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\n\tswitch (task->tk_status) { /* Just ignore these failures */\n\tcase -NFS4ERR_DELEG_REVOKED: /* layout was recalled */\n\tcase -NFS4ERR_BADIOMODE:     /* no IOMODE_RW layout for range */\n\tcase -NFS4ERR_BADLAYOUT:     /* no layout */\n\tcase -NFS4ERR_GRACE:\t    /* loca_recalim always false */\n\t\ttask->tk_status = 0;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tif (nfs4_async_handle_error(task, server, NULL, NULL) == -EAGAIN) {\n\t\t\trpc_restart_call_prepare(task);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void nfs4_layoutcommit_release(void *calldata)\n{\n\tstruct nfs4_layoutcommit_data *data = calldata;\n\n\tpnfs_cleanup_layoutcommit(data);\n\tnfs_post_op_update_inode_force_wcc(data->args.inode,\n\t\t\t\t\t   data->res.fattr);\n\tput_cred(data->cred);\n\tnfs_iput_and_deactive(data->inode);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops nfs4_layoutcommit_ops = {\n\t.rpc_call_prepare = nfs4_layoutcommit_prepare,\n\t.rpc_call_done = nfs4_layoutcommit_done,\n\t.rpc_release = nfs4_layoutcommit_release,\n};\n\nint\nnfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = NFS_CLIENT(data->args.inode),\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutcommit_ops,\n\t\t.callback_data = data,\n\t};\n\tstruct rpc_task *task;\n\tint status = 0;\n\n\tdprintk(\"NFS: initiating layoutcommit call. sync %d \"\n\t\t\"lbw: %llu inode %lu\\n\", sync,\n\t\tdata->args.lastbytewritten,\n\t\tdata->args.inode->i_ino);\n\n\tif (!sync) {\n\t\tdata->inode = nfs_igrab_and_active(data->args.inode);\n\t\tif (data->inode == NULL) {\n\t\t\tnfs4_layoutcommit_release(data);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\ttask_setup_data.flags = RPC_TASK_ASYNC;\n\t}\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (sync)\n\t\tstatus = task->tk_status;\n\ttrace_nfs4_layoutcommit(data->args.inode, &data->args.stateid, status);\n\tdprintk(\"%s: status %d\\n\", __func__, status);\n\trpc_put_task(task);\n\treturn status;\n}\n\n/*\n * Use the state managment nfs_client cl_rpcclient, which uses krb5i (if\n * possible) as per RFC3530bis and RFC5661 Security Considerations sections\n */\nstatic int\n_nfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info,\n\t\t    struct nfs4_secinfo_flavors *flavors, bool use_integrity)\n{\n\tstruct nfs41_secinfo_no_name_args args = {\n\t\t.style = SECINFO_STYLE_CURRENT_FH,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO_NO_NAME],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct nfs4_call_sync_data data = {\n\t\t.seq_server = server,\n\t\t.seq_args = &args.seq_args,\n\t\t.seq_res = &res.seq_res,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = server->nfs_client->cl_mvops->call_sync_ops,\n\t\t.callback_data = &data,\n\t\t.flags = RPC_TASK_NO_ROUND_ROBIN,\n\t};\n\tconst struct cred *cred = NULL;\n\tint status;\n\n\tif (use_integrity) {\n\t\ttask_setup.rpc_client = server->nfs_client->cl_rpcclient;\n\n\t\tcred = nfs4_get_clid_cred(server->nfs_client);\n\t\tmsg.rpc_cred = cred;\n\t}\n\n\tdprintk(\"--> %s\\n\", __func__);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 0);\n\tstatus = nfs4_call_sync_custom(&task_setup);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\n\tput_cred(cred);\n\n\treturn status;\n}\n\nstatic int\nnfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t   struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\t/* first try using integrity protection */\n\t\terr = -NFS4ERR_WRONGSEC;\n\n\t\t/* try to use integrity protection with machine cred */\n\t\tif (_nfs4_is_integrity_protected(server->nfs_client))\n\t\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info,\n\t\t\t\t\t\t\t  flavors, true);\n\n\t\t/*\n\t\t * if unable to use integrity protection, or SECINFO with\n\t\t * integrity protection returns NFS4ERR_WRONGSEC (which is\n\t\t * disallowed by spec, but exists in deployed servers) use\n\t\t * the current filesystem's rpc_client and the user cred.\n\t\t */\n\t\tif (err == -NFS4ERR_WRONGSEC)\n\t\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info,\n\t\t\t\t\t\t\t  flavors, false);\n\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\tcase -ENOTSUPP:\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n\nstatic int\nnfs41_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t    struct nfs_fsinfo *info)\n{\n\tint err;\n\tstruct page *page;\n\trpc_authflavor_t flavor = RPC_AUTH_MAXFLAVOR;\n\tstruct nfs4_secinfo_flavors *flavors;\n\tstruct nfs4_secinfo4 *secinfo;\n\tint i;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tflavors = page_address(page);\n\terr = nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\n\t/*\n\t * Fall back on \"guess and check\" method if\n\t * the server doesn't support SECINFO_NO_NAME\n\t */\n\tif (err == -NFS4ERR_WRONGSEC || err == -ENOTSUPP) {\n\t\terr = nfs4_find_root_sec(server, fhandle, info);\n\t\tgoto out_freepage;\n\t}\n\tif (err)\n\t\tgoto out_freepage;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t&secinfo->flavor_info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tflavor = RPC_AUTH_MAXFLAVOR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!nfs_auth_info_match(&server->auth_info, flavor))\n\t\t\tflavor = RPC_AUTH_MAXFLAVOR;\n\n\t\tif (flavor != RPC_AUTH_MAXFLAVOR) {\n\t\t\terr = nfs4_lookup_root_sec(server, fhandle,\n\t\t\t\t\t\t   info, flavor);\n\t\t\tif (!err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flavor == RPC_AUTH_MAXFLAVOR)\n\t\terr = -EPERM;\n\nout_freepage:\n\tput_page(page);\n\tif (err == -EACCES)\n\t\treturn -EPERM;\nout:\n\treturn err;\n}\n\nstatic int _nfs41_test_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tint status;\n\tstruct nfs41_test_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_test_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_TEST_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_clnt *rpc_client = server->client;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_STATEID,\n\t\t&rpc_client, &msg);\n\n\tdprintk(\"NFS call  test_stateid %p\\n\", stateid);\n\tnfs4_init_sequence(&args.seq_args, &res.seq_res, 0, 1);\n\tstatus = nfs4_call_sync_sequence(rpc_client, server, &msg,\n\t\t\t&args.seq_args, &res.seq_res);\n\tif (status != NFS_OK) {\n\t\tdprintk(\"NFS reply test_stateid: failed, %d\\n\", status);\n\t\treturn status;\n\t}\n\tdprintk(\"NFS reply test_stateid: succeeded, %d\\n\", -res.status);\n\treturn -res.status;\n}\n\nstatic void nfs4_handle_delay_or_session_error(struct nfs_server *server,\n\t\tint err, struct nfs4_exception *exception)\n{\n\texception->retry = 0;\n\tswitch(err) {\n\tcase -NFS4ERR_DELAY:\n\tcase -NFS4ERR_RETRY_UNCACHED_REP:\n\t\tnfs4_handle_exception(server, err, exception);\n\t\tbreak;\n\tcase -NFS4ERR_BADSESSION:\n\tcase -NFS4ERR_BADSLOT:\n\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\tcase -NFS4ERR_DEADSESSION:\n\t\tnfs4_do_handle_exception(server, err, exception);\n\t}\n}\n\n/**\n * nfs41_test_stateid - perform a TEST_STATEID operation\n *\n * @server: server / transport on which to perform the operation\n * @stateid: state ID to test\n * @cred: credential\n *\n * Returns NFS_OK if the server recognizes that \"stateid\" is valid.\n * Otherwise a negative NFS4ERR value is returned if the operation\n * failed or the state ID is not currently valid.\n */\nstatic int nfs41_test_stateid(struct nfs_server *server,\n\t\tnfs4_stateid *stateid,\n\t\tconst struct cred *cred)\n{\n\tstruct nfs4_exception exception = {\n\t\t.interruptible = true,\n\t};\n\tint err;\n\tdo {\n\t\terr = _nfs41_test_stateid(server, stateid, cred);\n\t\tnfs4_handle_delay_or_session_error(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n\nstruct nfs_free_stateid_data {\n\tstruct nfs_server *server;\n\tstruct nfs41_free_stateid_args args;\n\tstruct nfs41_free_stateid_res res;\n};\n\nstatic void nfs41_free_stateid_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\tnfs4_setup_sequence(data->server->nfs_client,\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n\nstatic void nfs41_free_stateid_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_free_stateid_data *data = calldata;\n\n\tnfs41_sequence_done(task, &data->res.seq_res);\n\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\tif (nfs4_async_handle_error(task, data->server, NULL, NULL) == -EAGAIN)\n\t\t\trpc_restart_call_prepare(task);\n\t}\n}\n\nstatic void nfs41_free_stateid_release(void *calldata)\n{\n\tkfree(calldata);\n}\n\nstatic const struct rpc_call_ops nfs41_free_stateid_ops = {\n\t.rpc_call_prepare = nfs41_free_stateid_prepare,\n\t.rpc_call_done = nfs41_free_stateid_done,\n\t.rpc_release = nfs41_free_stateid_release,\n};\n\n/**\n * nfs41_free_stateid - perform a FREE_STATEID operation\n *\n * @server: server / transport on which to perform the operation\n * @stateid: state ID to release\n * @cred: credential\n * @privileged: set to true if this call needs to be privileged\n *\n * Note: this function is always asynchronous.\n */\nstatic int nfs41_free_stateid(struct nfs_server *server,\n\t\tconst nfs4_stateid *stateid,\n\t\tconst struct cred *cred,\n\t\tbool privileged)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs41_free_stateid_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct nfs_free_stateid_data *data;\n\tstruct rpc_task *task;\n\n\tnfs4_state_protect(server->nfs_client, NFS_SP4_MACH_CRED_STATEID,\n\t\t&task_setup.rpc_client, &msg);\n\n\tdprintk(\"NFS call  free_stateid %p\\n\", stateid);\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->server = server;\n\tnfs4_stateid_copy(&data->args.stateid, stateid);\n\n\ttask_setup.callback_data = data;\n\n\tmsg.rpc_argp = &data->args;\n\tmsg.rpc_resp = &data->res;\n\tnfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1, privileged);\n\ttask = rpc_run_task(&task_setup);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}\n\nstatic void\nnfs41_free_lock_state(struct nfs_server *server, struct nfs4_lock_state *lsp)\n{\n\tconst struct cred *cred = lsp->ls_state->owner->so_cred;\n\n\tnfs41_free_stateid(server, &lsp->ls_stateid, cred, false);\n\tnfs4_free_lock_state(server, lsp);\n}\n\nstatic bool nfs41_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\tif (s1->type != s2->type)\n\t\treturn false;\n\n\tif (memcmp(s1->other, s2->other, sizeof(s1->other)) != 0)\n\t\treturn false;\n\n\tif (s1->seqid == s2->seqid)\n\t\treturn true;\n\n\treturn s1->seqid == 0 || s2->seqid == 0;\n}\n\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic bool nfs4_match_stateid(const nfs4_stateid *s1,\n\t\tconst nfs4_stateid *s2)\n{\n\treturn nfs4_stateid_match(s1, s2);\n}\n\n\nstatic const struct nfs4_state_recovery_ops nfs40_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs4_init_clientid,\n\t.detect_trunking = nfs40_discover_server_trunking,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_reboot_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_REBOOT,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_REBOOT,\n\t.recover_open\t= nfs4_open_reclaim,\n\t.recover_lock\t= nfs4_lock_reclaim,\n\t.establish_clid = nfs41_init_clientid,\n\t.reclaim_complete = nfs41_proc_reclaim_complete,\n\t.detect_trunking = nfs41_discover_server_trunking,\n};\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_state_recovery_ops nfs40_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs40_open_expired,\n\t.recover_lock\t= nfs4_lock_expired,\n\t.establish_clid = nfs4_init_clientid,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_recovery_ops nfs41_nograce_recovery_ops = {\n\t.owner_flag_bit = NFS_OWNER_RECLAIM_NOGRACE,\n\t.state_flag_bit\t= NFS_STATE_RECLAIM_NOGRACE,\n\t.recover_open\t= nfs41_open_expired,\n\t.recover_lock\t= nfs41_lock_expired,\n\t.establish_clid = nfs41_init_clientid,\n};\n#endif /* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_state_maintenance_ops nfs40_state_renewal_ops = {\n\t.sched_state_renewal = nfs4_proc_async_renew,\n\t.get_state_renewal_cred = nfs4_get_renew_cred,\n\t.renew_lease = nfs4_proc_renew,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_state_maintenance_ops nfs41_state_renewal_ops = {\n\t.sched_state_renewal = nfs41_proc_async_sequence,\n\t.get_state_renewal_cred = nfs4_get_machine_cred,\n\t.renew_lease = nfs4_proc_sequence,\n};\n#endif\n\nstatic const struct nfs4_mig_recovery_ops nfs40_mig_recovery_ops = {\n\t.get_locations = _nfs40_proc_get_locations,\n\t.fsid_present = _nfs40_proc_fsid_present,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic const struct nfs4_mig_recovery_ops nfs41_mig_recovery_ops = {\n\t.get_locations = _nfs41_proc_get_locations,\n\t.fsid_present = _nfs41_proc_fsid_present,\n};\n#endif\t/* CONFIG_NFS_V4_1 */\n\nstatic const struct nfs4_minor_version_ops nfs_v4_0_minor_ops = {\n\t.minor_version = 0,\n\t.init_caps = NFS_CAP_READDIRPLUS\n\t\t| NFS_CAP_ATOMIC_OPEN\n\t\t| NFS_CAP_POSIX_LOCK,\n\t.init_client = nfs40_init_client,\n\t.shutdown_client = nfs40_shutdown_client,\n\t.match_stateid = nfs4_match_stateid,\n\t.find_root_sec = nfs4_find_root_sec,\n\t.free_lock_state = nfs4_release_lockowner,\n\t.test_and_free_expired = nfs40_test_and_free_expired_stateid,\n\t.alloc_seqid = nfs_alloc_seqid,\n\t.call_sync_ops = &nfs40_call_sync_ops,\n\t.reboot_recovery_ops = &nfs40_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs40_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs40_state_renewal_ops,\n\t.mig_recovery_ops = &nfs40_mig_recovery_ops,\n};\n\n#if defined(CONFIG_NFS_V4_1)\nstatic struct nfs_seqid *\nnfs_alloc_no_seqid(struct nfs_seqid_counter *arg1, gfp_t arg2)\n{\n\treturn NULL;\n}\n\nstatic const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = {\n\t.minor_version = 1,\n\t.init_caps = NFS_CAP_READDIRPLUS\n\t\t| NFS_CAP_ATOMIC_OPEN\n\t\t| NFS_CAP_POSIX_LOCK\n\t\t| NFS_CAP_STATEID_NFSV41\n\t\t| NFS_CAP_ATOMIC_OPEN_V1\n\t\t| NFS_CAP_LGOPEN,\n\t.init_client = nfs41_init_client,\n\t.shutdown_client = nfs41_shutdown_client,\n\t.match_stateid = nfs41_match_stateid,\n\t.find_root_sec = nfs41_find_root_sec,\n\t.free_lock_state = nfs41_free_lock_state,\n\t.test_and_free_expired = nfs41_test_and_free_expired_stateid,\n\t.alloc_seqid = nfs_alloc_no_seqid,\n\t.session_trunk = nfs4_test_session_trunk,\n\t.call_sync_ops = &nfs41_call_sync_ops,\n\t.reboot_recovery_ops = &nfs41_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs41_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs41_state_renewal_ops,\n\t.mig_recovery_ops = &nfs41_mig_recovery_ops,\n};\n#endif\n\n#if defined(CONFIG_NFS_V4_2)\nstatic const struct nfs4_minor_version_ops nfs_v4_2_minor_ops = {\n\t.minor_version = 2,\n\t.init_caps = NFS_CAP_READDIRPLUS\n\t\t| NFS_CAP_ATOMIC_OPEN\n\t\t| NFS_CAP_POSIX_LOCK\n\t\t| NFS_CAP_STATEID_NFSV41\n\t\t| NFS_CAP_ATOMIC_OPEN_V1\n\t\t| NFS_CAP_LGOPEN\n\t\t| NFS_CAP_ALLOCATE\n\t\t| NFS_CAP_COPY\n\t\t| NFS_CAP_OFFLOAD_CANCEL\n\t\t| NFS_CAP_COPY_NOTIFY\n\t\t| NFS_CAP_DEALLOCATE\n\t\t| NFS_CAP_SEEK\n\t\t| NFS_CAP_LAYOUTSTATS\n\t\t| NFS_CAP_CLONE\n\t\t| NFS_CAP_LAYOUTERROR\n\t\t| NFS_CAP_READ_PLUS,\n\t.init_client = nfs41_init_client,\n\t.shutdown_client = nfs41_shutdown_client,\n\t.match_stateid = nfs41_match_stateid,\n\t.find_root_sec = nfs41_find_root_sec,\n\t.free_lock_state = nfs41_free_lock_state,\n\t.call_sync_ops = &nfs41_call_sync_ops,\n\t.test_and_free_expired = nfs41_test_and_free_expired_stateid,\n\t.alloc_seqid = nfs_alloc_no_seqid,\n\t.session_trunk = nfs4_test_session_trunk,\n\t.reboot_recovery_ops = &nfs41_reboot_recovery_ops,\n\t.nograce_recovery_ops = &nfs41_nograce_recovery_ops,\n\t.state_renewal_ops = &nfs41_state_renewal_ops,\n\t.mig_recovery_ops = &nfs41_mig_recovery_ops,\n};\n#endif\n\nconst struct nfs4_minor_version_ops *nfs_v4_minor_ops[] = {\n\t[0] = &nfs_v4_0_minor_ops,\n#if defined(CONFIG_NFS_V4_1)\n\t[1] = &nfs_v4_1_minor_ops,\n#endif\n#if defined(CONFIG_NFS_V4_2)\n\t[2] = &nfs_v4_2_minor_ops,\n#endif\n};\n\nstatic ssize_t nfs4_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tssize_t error, error2, error3;\n\n\terror = generic_listxattr(dentry, list, size);\n\tif (error < 0)\n\t\treturn error;\n\tif (list) {\n\t\tlist += error;\n\t\tsize -= error;\n\t}\n\n\terror2 = nfs4_listxattr_nfs4_label(d_inode(dentry), list, size);\n\tif (error2 < 0)\n\t\treturn error2;\n\n\tif (list) {\n\t\tlist += error2;\n\t\tsize -= error2;\n\t}\n\n\terror3 = nfs4_listxattr_nfs4_user(d_inode(dentry), list, size);\n\tif (error3 < 0)\n\t\treturn error3;\n\n\treturn error + error2 + error3;\n}\n\nstatic const struct inode_operations nfs4_dir_inode_operations = {\n\t.create\t\t= nfs_create,\n\t.lookup\t\t= nfs_lookup,\n\t.atomic_open\t= nfs_atomic_open,\n\t.link\t\t= nfs_link,\n\t.unlink\t\t= nfs_unlink,\n\t.symlink\t= nfs_symlink,\n\t.mkdir\t\t= nfs_mkdir,\n\t.rmdir\t\t= nfs_rmdir,\n\t.mknod\t\t= nfs_mknod,\n\t.rename\t\t= nfs_rename,\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.listxattr\t= nfs4_listxattr,\n};\n\nstatic const struct inode_operations nfs4_file_inode_operations = {\n\t.permission\t= nfs_permission,\n\t.getattr\t= nfs_getattr,\n\t.setattr\t= nfs_setattr,\n\t.listxattr\t= nfs4_listxattr,\n};\n\nconst struct nfs_rpc_ops nfs_v4_clientops = {\n\t.version\t= 4,\t\t\t/* protocol version */\n\t.dentry_ops\t= &nfs4_dentry_operations,\n\t.dir_inode_ops\t= &nfs4_dir_inode_operations,\n\t.file_inode_ops\t= &nfs4_file_inode_operations,\n\t.file_ops\t= &nfs4_file_operations,\n\t.getroot\t= nfs4_proc_get_root,\n\t.submount\t= nfs4_submount,\n\t.try_get_tree\t= nfs4_try_get_tree,\n\t.getattr\t= nfs4_proc_getattr,\n\t.setattr\t= nfs4_proc_setattr,\n\t.lookup\t\t= nfs4_proc_lookup,\n\t.lookupp\t= nfs4_proc_lookupp,\n\t.access\t\t= nfs4_proc_access,\n\t.readlink\t= nfs4_proc_readlink,\n\t.create\t\t= nfs4_proc_create,\n\t.remove\t\t= nfs4_proc_remove,\n\t.unlink_setup\t= nfs4_proc_unlink_setup,\n\t.unlink_rpc_prepare = nfs4_proc_unlink_rpc_prepare,\n\t.unlink_done\t= nfs4_proc_unlink_done,\n\t.rename_setup\t= nfs4_proc_rename_setup,\n\t.rename_rpc_prepare = nfs4_proc_rename_rpc_prepare,\n\t.rename_done\t= nfs4_proc_rename_done,\n\t.link\t\t= nfs4_proc_link,\n\t.symlink\t= nfs4_proc_symlink,\n\t.mkdir\t\t= nfs4_proc_mkdir,\n\t.rmdir\t\t= nfs4_proc_rmdir,\n\t.readdir\t= nfs4_proc_readdir,\n\t.mknod\t\t= nfs4_proc_mknod,\n\t.statfs\t\t= nfs4_proc_statfs,\n\t.fsinfo\t\t= nfs4_proc_fsinfo,\n\t.pathconf\t= nfs4_proc_pathconf,\n\t.set_capabilities = nfs4_server_capabilities,\n\t.decode_dirent\t= nfs4_decode_dirent,\n\t.pgio_rpc_prepare = nfs4_proc_pgio_rpc_prepare,\n\t.read_setup\t= nfs4_proc_read_setup,\n\t.read_done\t= nfs4_read_done,\n\t.write_setup\t= nfs4_proc_write_setup,\n\t.write_done\t= nfs4_write_done,\n\t.commit_setup\t= nfs4_proc_commit_setup,\n\t.commit_rpc_prepare = nfs4_proc_commit_rpc_prepare,\n\t.commit_done\t= nfs4_commit_done,\n\t.lock\t\t= nfs4_proc_lock,\n\t.clear_acl_cache = nfs4_zap_acl_attr,\n\t.close_context  = nfs4_close_context,\n\t.open_context\t= nfs4_atomic_open,\n\t.have_delegation = nfs4_have_delegation,\n\t.alloc_client\t= nfs4_alloc_client,\n\t.init_client\t= nfs4_init_client,\n\t.free_client\t= nfs4_free_client,\n\t.create_server\t= nfs4_create_server,\n\t.clone_server\t= nfs_clone_server,\n};\n\nstatic const struct xattr_handler nfs4_xattr_nfs4_acl_handler = {\n\t.name\t= XATTR_NAME_NFSV4_ACL,\n\t.list\t= nfs4_xattr_list_nfs4_acl,\n\t.get\t= nfs4_xattr_get_nfs4_acl,\n\t.set\t= nfs4_xattr_set_nfs4_acl,\n};\n\n#ifdef CONFIG_NFS_V4_2\nstatic const struct xattr_handler nfs4_xattr_nfs4_user_handler = {\n\t.prefix\t= XATTR_USER_PREFIX,\n\t.get\t= nfs4_xattr_get_nfs4_user,\n\t.set\t= nfs4_xattr_set_nfs4_user,\n};\n#endif\n\nconst struct xattr_handler *nfs4_xattr_handlers[] = {\n\t&nfs4_xattr_nfs4_acl_handler,\n#ifdef CONFIG_NFS_V4_SECURITY_LABEL\n\t&nfs4_xattr_nfs4_label_handler,\n#endif\n#ifdef CONFIG_NFS_V4_2\n\t&nfs4_xattr_nfs4_user_handler,\n#endif\n\tNULL\n};\n\n/*\n * Local variables:\n *  c-basic-offset: 8\n * End:\n */\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 0, "line": 1805}, "message": "Value stored to 'delegation' is never read"}, {"location": {"col": 3, "file": 0, "line": 1805}, "message": "Value stored to 'delegation' is never read"}], "macros": [], "notes": [], "path": "/src/fs/nfs/nfs4proc.c", "reportHash": "b1991964af742410c112e5ef61864e06", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
