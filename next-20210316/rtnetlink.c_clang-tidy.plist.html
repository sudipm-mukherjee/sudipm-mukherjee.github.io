<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/include/linux/rtnetlink.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_RTNETLINK_H\n#define __LINUX_RTNETLINK_H\n\n\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/wait.h>\n#include <linux/refcount.h>\n#include <uapi/linux/rtnetlink.h>\n\nextern int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, u32 group, int echo);\nextern int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid);\nextern void rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid,\n\t\t\tu32 group, struct nlmsghdr *nlh, gfp_t flags);\nextern void rtnl_set_sk_err(struct net *net, u32 group, int error);\nextern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);\nextern int rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst,\n\t\t\t      u32 id, long expires, u32 error);\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned change, gfp_t flags);\nvoid rtmsg_ifinfo_newnet(int type, struct net_device *dev, unsigned int change,\n\t\t\t gfp_t flags, int *new_nsid, int new_ifindex);\nstruct sk_buff *rtmsg_ifinfo_build_skb(int type, struct net_device *dev,\n\t\t\t\t       unsigned change, u32 event,\n\t\t\t\t       gfp_t flags, int *new_nsid,\n\t\t\t\t       int new_ifindex);\nvoid rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev,\n\t\t       gfp_t flags);\n\n\n/* RTNL is used as a global lock for all changes to network configuration  */\nextern void rtnl_lock(void);\nextern void rtnl_unlock(void);\nextern int rtnl_trylock(void);\nextern int rtnl_is_locked(void);\nextern int rtnl_lock_killable(void);\nextern bool refcount_dec_and_rtnl_lock(refcount_t *r);\n\nextern wait_queue_head_t netdev_unregistering_wq;\nextern struct rw_semaphore pernet_ops_rwsem;\nextern struct rw_semaphore net_rwsem;\n\n#ifdef CONFIG_PROVE_LOCKING\nextern bool lockdep_rtnl_is_held(void);\n#else\nstatic inline bool lockdep_rtnl_is_held(void)\n{\n\treturn true;\n}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n\n/**\n * rcu_dereference_rtnl - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n *\n * Do an rcu_dereference(p), but check caller either holds rcu_read_lock()\n * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference()\n */\n#define rcu_dereference_rtnl(p)\t\t\t\t\t\\\n\trcu_dereference_check(p, lockdep_rtnl_is_held())\n\n/**\n * rcu_dereference_bh_rtnl - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereference\n *\n * Do an rcu_dereference_bh(p), but check caller either holds rcu_read_lock_bh()\n * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference_bh()\n */\n#define rcu_dereference_bh_rtnl(p)\t\t\t\t\\\n\trcu_dereference_bh_check(p, lockdep_rtnl_is_held())\n\n/**\n * rtnl_dereference - fetch RCU pointer when updates are prevented by RTNL\n * @p: The pointer to read, prior to dereferencing\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE(), because caller holds RTNL.\n */\n#define rtnl_dereference(p)\t\t\t\t\t\\\n\trcu_dereference_protected(p, lockdep_rtnl_is_held())\n\nstatic inline struct netdev_queue *dev_ingress_queue(struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->ingress_queue);\n}\n\nstatic inline struct netdev_queue *dev_ingress_queue_rcu(struct net_device *dev)\n{\n\treturn rcu_dereference(dev->ingress_queue);\n}\n\nstruct netdev_queue *dev_ingress_queue_create(struct net_device *dev);\n\n#ifdef CONFIG_NET_INGRESS\nvoid net_inc_ingress_queue(void);\nvoid net_dec_ingress_queue(void);\n#endif\n\n#ifdef CONFIG_NET_EGRESS\nvoid net_inc_egress_queue(void);\nvoid net_dec_egress_queue(void);\n#endif\n\nvoid rtnetlink_init(void);\nvoid __rtnl_unlock(void);\nvoid rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail);\n\n#define ASSERT_RTNL() \\\n\tWARN_ONCE(!rtnl_is_locked(), \\\n\t\t  \"RTNL: assertion failed at %s (%d)\\n\", __FILE__,  __LINE__)\n\nextern int ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     struct net_device *dev,\n\t\t\t     struct net_device *filter_dev,\n\t\t\t     int *idx);\nextern int ndo_dflt_fdb_add(struct ndmsg *ndm,\n\t\t\t    struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid,\n\t\t\t    u16 flags);\nextern int ndo_dflt_fdb_del(struct ndmsg *ndm,\n\t\t\t    struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid);\n\nextern int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t   struct net_device *dev, u16 mode,\n\t\t\t\t   u32 flags, u32 mask, int nlflags,\n\t\t\t\t   u32 filter_mask,\n\t\t\t\t   int (*vlan_fill)(struct sk_buff *skb,\n\t\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t\t    u32 filter_mask));\n#endif\t/* __LINUX_RTNETLINK_H */\n"}, "2": {"id": 2, "path": "/src/include/linux/rcupdate.h", "content": "/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Read-Copy Update mechanism for mutual exclusion\n *\n * Copyright IBM Corporation, 2001\n *\n * Author: Dipankar Sarma <dipankar@in.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@vnet.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n * Papers:\n * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf\n * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\t\thttp://lse.sourceforge.net/locking/rcupdate.html\n *\n */\n\n#ifndef __LINUX_RCUPDATE_H\n#define __LINUX_RCUPDATE_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/processor.h>\n#include <linux/cpumask.h>\n\n#define ULONG_CMP_GE(a, b)\t(ULONG_MAX / 2 >= (a) - (b))\n#define ULONG_CMP_LT(a, b)\t(ULONG_MAX / 2 < (a) - (b))\n#define ulong2long(a)\t\t(*(long *)(&(a)))\n#define USHORT_CMP_GE(a, b)\t(USHRT_MAX / 2 >= (unsigned short)((a) - (b)))\n#define USHORT_CMP_LT(a, b)\t(USHRT_MAX / 2 < (unsigned short)((a) - (b)))\n\n/* Exported common interfaces */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func);\nvoid rcu_barrier_tasks(void);\nvoid rcu_barrier_tasks_rude(void);\nvoid synchronize_rcu(void);\n\n#ifdef CONFIG_PREEMPT_RCU\n\nvoid __rcu_read_lock(void);\nvoid __rcu_read_unlock(void);\n\n/*\n * Defined as a macro as it is a very low level header included from\n * areas that don't even know about current.  This gives the rcu_read_lock()\n * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other\n * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.\n */\n#define rcu_preempt_depth() (current->rcu_read_lock_nesting)\n\n#else /* #ifdef CONFIG_PREEMPT_RCU */\n\n#ifdef CONFIG_TINY_RCU\n#define rcu_read_unlock_strict() do { } while (0)\n#else\nvoid rcu_read_unlock_strict(void);\n#endif\n\nstatic inline void __rcu_read_lock(void)\n{\n\tpreempt_disable();\n}\n\nstatic inline void __rcu_read_unlock(void)\n{\n\tpreempt_enable();\n\trcu_read_unlock_strict();\n}\n\nstatic inline int rcu_preempt_depth(void)\n{\n\treturn 0;\n}\n\n#endif /* #else #ifdef CONFIG_PREEMPT_RCU */\n\n/* Internal to kernel */\nvoid rcu_init(void);\nextern int rcu_scheduler_active __read_mostly;\nvoid rcu_sched_clock_irq(int user);\nvoid rcu_report_dead(unsigned int cpu);\nvoid rcutree_migrate_callbacks(int cpu);\n\n#ifdef CONFIG_TASKS_RCU_GENERIC\nvoid rcu_init_tasks_generic(void);\n#else\nstatic inline void rcu_init_tasks_generic(void) { }\n#endif\n\n#ifdef CONFIG_RCU_STALL_COMMON\nvoid rcu_sysrq_start(void);\nvoid rcu_sysrq_end(void);\n#else /* #ifdef CONFIG_RCU_STALL_COMMON */\nstatic inline void rcu_sysrq_start(void) { }\nstatic inline void rcu_sysrq_end(void) { }\n#endif /* #else #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nvoid rcu_user_enter(void);\nvoid rcu_user_exit(void);\n#else\nstatic inline void rcu_user_enter(void) { }\nstatic inline void rcu_user_exit(void) { }\n#endif /* CONFIG_NO_HZ_FULL */\n\n#ifdef CONFIG_RCU_NOCB_CPU\nvoid rcu_init_nohz(void);\nint rcu_nocb_cpu_offload(int cpu);\nint rcu_nocb_cpu_deoffload(int cpu);\nvoid rcu_nocb_flush_deferred_wakeup(void);\n#else /* #ifdef CONFIG_RCU_NOCB_CPU */\nstatic inline void rcu_init_nohz(void) { }\nstatic inline int rcu_nocb_cpu_offload(int cpu) { return -EINVAL; }\nstatic inline int rcu_nocb_cpu_deoffload(int cpu) { return 0; }\nstatic inline void rcu_nocb_flush_deferred_wakeup(void) { }\n#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */\n\n/**\n * RCU_NONIDLE - Indicate idle-loop code that needs RCU readers\n * @a: Code that RCU needs to pay attention to.\n *\n * RCU read-side critical sections are forbidden in the inner idle loop,\n * that is, between the rcu_idle_enter() and the rcu_idle_exit() -- RCU\n * will happily ignore any such read-side critical sections.  However,\n * things like powertop need tracepoints in the inner idle loop.\n *\n * This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())\n * will tell RCU that it needs to pay attention, invoke its argument\n * (in this example, calling the do_something_with_RCU() function),\n * and then tell RCU to go back to ignoring this CPU.  It is permissible\n * to nest RCU_NONIDLE() wrappers, but not indefinitely (but the limit is\n * on the order of a million or so, even on 32-bit systems).  It is\n * not legal to block within RCU_NONIDLE(), nor is it permissible to\n * transfer control either into or out of RCU_NONIDLE()'s statement.\n */\n#define RCU_NONIDLE(a) \\\n\tdo { \\\n\t\trcu_irq_enter_irqson(); \\\n\t\tdo { a; } while (0); \\\n\t\trcu_irq_exit_irqson(); \\\n\t} while (0)\n\n/*\n * Note a quasi-voluntary context switch for RCU-tasks's benefit.\n * This is a macro rather than an inline function to avoid #include hell.\n */\n#ifdef CONFIG_TASKS_RCU_GENERIC\n\n# ifdef CONFIG_TASKS_RCU\n# define rcu_tasks_classic_qs(t, preempt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(preempt) && READ_ONCE((t)->rcu_tasks_holdout))\t\\\n\t\t\tWRITE_ONCE((t)->rcu_tasks_holdout, false);\t\\\n\t} while (0)\nvoid call_rcu_tasks(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks(void);\n# else\n# define rcu_tasks_classic_qs(t, preempt) do { } while (0)\n# define call_rcu_tasks call_rcu\n# define synchronize_rcu_tasks synchronize_rcu\n# endif\n\n# ifdef CONFIG_TASKS_RCU_TRACE\n# define rcu_tasks_trace_qs(t)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!likely(READ_ONCE((t)->trc_reader_checked)) &&\t\\\n\t\t    !unlikely(READ_ONCE((t)->trc_reader_nesting))) {\t\\\n\t\t\tsmp_store_release(&(t)->trc_reader_checked, true); \\\n\t\t\tsmp_mb(); /* Readers partitioned by store. */\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n# else\n# define rcu_tasks_trace_qs(t) do { } while (0)\n# endif\n\n#define rcu_tasks_qs(t, preempt)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_tasks_classic_qs((t), (preempt));\t\t\t\t\\\n\trcu_tasks_trace_qs((t));\t\t\t\t\t\\\n} while (0)\n\n# ifdef CONFIG_TASKS_RUDE_RCU\nvoid call_rcu_tasks_rude(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks_rude(void);\n# endif\n\n#define rcu_note_voluntary_context_switch(t) rcu_tasks_qs(t, false)\nvoid exit_tasks_rcu_start(void);\nvoid exit_tasks_rcu_finish(void);\n#else /* #ifdef CONFIG_TASKS_RCU_GENERIC */\n#define rcu_tasks_qs(t, preempt) do { } while (0)\n#define rcu_note_voluntary_context_switch(t) do { } while (0)\n#define call_rcu_tasks call_rcu\n#define synchronize_rcu_tasks synchronize_rcu\nstatic inline void exit_tasks_rcu_start(void) { }\nstatic inline void exit_tasks_rcu_finish(void) { }\n#endif /* #else #ifdef CONFIG_TASKS_RCU_GENERIC */\n\n/**\n * cond_resched_tasks_rcu_qs - Report potential quiescent states to RCU\n *\n * This macro resembles cond_resched(), except that it is defined to\n * report potential quiescent states to RCU-tasks even if the cond_resched()\n * machinery were to be shut off, as some advocate for PREEMPTION kernels.\n */\n#define cond_resched_tasks_rcu_qs() \\\ndo { \\\n\trcu_tasks_qs(current, false); \\\n\tcond_resched(); \\\n} while (0)\n\n/*\n * Infrastructure to implement the synchronize_() primitives in\n * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.\n */\n\n#if defined(CONFIG_TREE_RCU)\n#include <linux/rcutree.h>\n#elif defined(CONFIG_TINY_RCU)\n#include <linux/rcutiny.h>\n#else\n#error \"Unknown RCU implementation specified to kernel configuration\"\n#endif\n\n/*\n * The init_rcu_head_on_stack() and destroy_rcu_head_on_stack() calls\n * are needed for dynamic initialization and destruction of rcu_head\n * on the stack, and init_rcu_head()/destroy_rcu_head() are needed for\n * dynamic initialization and destruction of statically allocated rcu_head\n * structures.  However, rcu_head structures allocated dynamically in the\n * heap don't need any initialization.\n */\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\nvoid init_rcu_head(struct rcu_head *head);\nvoid destroy_rcu_head(struct rcu_head *head);\nvoid init_rcu_head_on_stack(struct rcu_head *head);\nvoid destroy_rcu_head_on_stack(struct rcu_head *head);\n#else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\nstatic inline void init_rcu_head(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head(struct rcu_head *head) { }\nstatic inline void init_rcu_head_on_stack(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head_on_stack(struct rcu_head *head) { }\n#endif\t/* #else !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\n#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU)\nbool rcu_lockdep_current_cpu_online(void);\n#else /* #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\nstatic inline bool rcu_lockdep_current_cpu_online(void) { return true; }\n#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\n\nextern struct lockdep_map rcu_lock_map;\nextern struct lockdep_map rcu_bh_lock_map;\nextern struct lockdep_map rcu_sched_lock_map;\nextern struct lockdep_map rcu_callback_map;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nstatic inline void rcu_lock_acquire(struct lockdep_map *map)\n{\n\tlock_acquire(map, 0, 0, 2, 0, NULL, _THIS_IP_);\n}\n\nstatic inline void rcu_lock_release(struct lockdep_map *map)\n{\n\tlock_release(map, _THIS_IP_);\n}\n\nint debug_lockdep_rcu_enabled(void);\nint rcu_read_lock_held(void);\nint rcu_read_lock_bh_held(void);\nint rcu_read_lock_sched_held(void);\nint rcu_read_lock_any_held(void);\n\n#else /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n# define rcu_lock_acquire(a)\t\tdo { } while (0)\n# define rcu_lock_release(a)\t\tdo { } while (0)\n\nstatic inline int rcu_read_lock_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_bh_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_sched_held(void)\n{\n\treturn !preemptible();\n}\n\nstatic inline int rcu_read_lock_any_held(void)\n{\n\treturn !preemptible();\n}\n\n#endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n#ifdef CONFIG_PROVE_RCU\n\n/**\n * RCU_LOCKDEP_WARN - emit lockdep splat if specified condition is met\n * @c: condition to check\n * @s: informative message\n */\n#define RCU_LOCKDEP_WARN(c, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic bool __section(\".data.unlikely\") __warned;\t\\\n\t\tif (debug_lockdep_rcu_enabled() && !__warned && (c)) {\t\\\n\t\t\t__warned = true;\t\t\t\t\\\n\t\t\tlockdep_rcu_suspicious(__FILE__, __LINE__, s);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#if defined(CONFIG_PROVE_RCU) && !defined(CONFIG_PREEMPT_RCU)\nstatic inline void rcu_preempt_sleep_check(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_lock_map),\n\t\t\t \"Illegal context switch in RCU read-side critical section\");\n}\n#else /* #ifdef CONFIG_PROVE_RCU */\nstatic inline void rcu_preempt_sleep_check(void) { }\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n#define rcu_sleep_check()\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trcu_preempt_sleep_check();\t\t\t\t\\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-bh read-side critical section\"); \\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-sched read-side critical section\"); \\\n\t} while (0)\n\n#else /* #ifdef CONFIG_PROVE_RCU */\n\n#define RCU_LOCKDEP_WARN(c, s) do { } while (0 && (c))\n#define rcu_sleep_check() do { } while (0)\n\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Helper functions for rcu_dereference_check(), rcu_dereference_protected()\n * and rcu_assign_pointer().  Some of these could be folded into their\n * callers, but they are left separate in order to ease introduction of\n * multiple pointers markings to match different RCU implementations\n * (e.g., __srcu), should this make sense in the future.\n */\n\n#ifdef __CHECKER__\n#define rcu_check_sparse(p, space) \\\n\t((void)(((typeof(*p) space *)p) == p))\n#else /* #ifdef __CHECKER__ */\n#define rcu_check_sparse(p, space)\n#endif /* #else #ifdef __CHECKER__ */\n\n#define __rcu_access_pointer(p, space) \\\n({ \\\n\ttypeof(*p) *_________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(_________p1)); \\\n})\n#define __rcu_dereference_check(p, c, space) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(*p) *________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_check() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n#define __rcu_dereference_protected(p, c, space) \\\n({ \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_protected() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(p)); \\\n})\n#define rcu_dereference_raw(p) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(p) ________p1 = READ_ONCE(p); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n\n/**\n * RCU_INITIALIZER() - statically initialize an RCU-protected global variable\n * @v: The value to statically initialize with.\n */\n#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)\n\n/**\n * rcu_assign_pointer() - assign to RCU-protected pointer\n * @p: pointer to assign to\n * @v: value to assign (publish)\n *\n * Assigns the specified value to the specified RCU-protected\n * pointer, ensuring that any concurrent RCU readers will see\n * any prior initialization.\n *\n * Inserts memory barriers on architectures that require them\n * (which is most of them), and also prevents the compiler from\n * reordering the code that initializes the structure after the pointer\n * assignment.  More importantly, this call documents which pointers\n * will be dereferenced by RCU read-side code.\n *\n * In some special cases, you may use RCU_INIT_POINTER() instead\n * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due\n * to the fact that it does not constrain either the CPU or the compiler.\n * That said, using RCU_INIT_POINTER() when you should have used\n * rcu_assign_pointer() is a very bad thing that results in\n * impossible-to-diagnose memory corruption.  So please be careful.\n * See the RCU_INIT_POINTER() comment header for details.\n *\n * Note that rcu_assign_pointer() evaluates each of its arguments only\n * once, appearances notwithstanding.  One of the \"extra\" evaluations\n * is in typeof() and the other visible only to sparse (__CHECKER__),\n * neither of which actually execute the argument.  As with most cpp\n * macros, this execute-arguments-only-once property is important, so\n * please be careful when making changes to rcu_assign_pointer() and the\n * other macros that it invokes.\n */\n#define rcu_assign_pointer(p, v)\t\t\t\t\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tuintptr_t _r_a_p__v = (uintptr_t)(v);\t\t\t\t      \\\n\trcu_check_sparse(p, __rcu);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)\t      \\\n\t\tWRITE_ONCE((p), (typeof(p))(_r_a_p__v));\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t\tsmp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \\\n} while (0)\n\n/**\n * rcu_replace_pointer() - replace an RCU pointer, returning its old value\n * @rcu_ptr: RCU pointer, whose old value is returned\n * @ptr: regular pointer\n * @c: the lockdep conditions under which the dereference will take place\n *\n * Perform a replacement, where @rcu_ptr is an RCU-annotated\n * pointer and @c is the lockdep argument that is passed to the\n * rcu_dereference_protected() call used to read that pointer.  The old\n * value of @rcu_ptr is returned, and @rcu_ptr is set to @ptr.\n */\n#define rcu_replace_pointer(rcu_ptr, ptr, c)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c));\t\\\n\trcu_assign_pointer((rcu_ptr), (ptr));\t\t\t\t\\\n\t__tmp;\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * rcu_access_pointer() - fetch RCU pointer with no dereferencing\n * @p: The pointer to read\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * lockdep checks for being in an RCU read-side critical section.  This is\n * useful when the value of this pointer is accessed, but the pointer is\n * not dereferenced, for example, when testing an RCU-protected pointer\n * against NULL.  Although rcu_access_pointer() may also be used in cases\n * where update-side locks prevent the value of the pointer from changing,\n * you should instead use rcu_dereference_protected() for this use case.\n *\n * It is also permissible to use rcu_access_pointer() when read-side\n * access to the pointer was removed at least one grace period ago, as\n * is the case in the context of the RCU callback that is freeing up\n * the data, or after a synchronize_rcu() returns.  This can be useful\n * when tearing down multi-linked structures after a grace period\n * has elapsed.\n */\n#define rcu_access_pointer(p) __rcu_access_pointer((p), __rcu)\n\n/**\n * rcu_dereference_check() - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Do an rcu_dereference(), but check that the conditions under which the\n * dereference will take place are correct.  Typically the conditions\n * indicate the various locking conditions that should be held at that\n * point.  The check should return true if the conditions are satisfied.\n * An implicit check for being in an RCU read-side critical section\n * (rcu_read_lock()) is included.\n *\n * For example:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock));\n *\n * could be used to indicate to lockdep that foo->bar may only be dereferenced\n * if either rcu_read_lock() is held, or that the lock required to replace\n * the bar struct at foo->bar is held.\n *\n * Note that the list of conditions may also include indications of when a lock\n * need not be held, for example during initialisation or destruction of the\n * target struct:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock) ||\n *\t\t\t\t\t      atomic_read(&foo->usage) == 0);\n *\n * Inserts memory barriers on architectures that require them\n * (currently only the Alpha), prevents the compiler from refetching\n * (and from merging fetches), and, more importantly, documents exactly\n * which pointers are protected by RCU and checks that the pointer is\n * annotated as __rcu.\n */\n#define rcu_dereference_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_held(), __rcu)\n\n/**\n * rcu_dereference_bh_check() - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-bh counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_bh_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_bh_held(), __rcu)\n\n/**\n * rcu_dereference_sched_check() - rcu_dereference_sched with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-sched counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_sched_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_sched_held(), \\\n\t\t\t\t__rcu)\n\n/*\n * The tracing infrastructure traces RCU (we want that), but unfortunately\n * some of the RCU checks causes tracing to lock up the system.\n *\n * The no-tracing version of rcu_dereference_raw() must not call\n * rcu_read_lock_held().\n */\n#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), 1, __rcu)\n\n/**\n * rcu_dereference_protected() - fetch RCU pointer when updates prevented\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE().  This is useful in cases where update-side locks\n * prevent the value of the pointer from changing.  Please note that this\n * primitive does *not* prevent the compiler from repeating this reference\n * or combining it with other references, so it should not be used without\n * protection of appropriate locks.\n *\n * This function is only for update-side use.  Using this function\n * when protected only by rcu_read_lock() will result in infrequent\n * but very ugly failures.\n */\n#define rcu_dereference_protected(p, c) \\\n\t__rcu_dereference_protected((p), (c), __rcu)\n\n\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n\n/**\n * rcu_dereference_bh() - fetch an RCU-bh-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)\n\n/**\n * rcu_dereference_sched() - fetch RCU-sched-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)\n\n/**\n * rcu_pointer_handoff() - Hand off a pointer from RCU to other mechanism\n * @p: The pointer to hand off\n *\n * This is simply an identity function, but it documents where a pointer\n * is handed off from RCU to some other synchronization mechanism, for\n * example, reference counting or locking.  In C11, it would map to\n * kill_dependency().  It could be used as follows::\n *\n *\trcu_read_lock();\n *\tp = rcu_dereference(gp);\n *\tlong_lived = is_long_lived(p);\n *\tif (long_lived) {\n *\t\tif (!atomic_inc_not_zero(p->refcnt))\n *\t\t\tlong_lived = false;\n *\t\telse\n *\t\t\tp = rcu_pointer_handoff(p);\n *\t}\n *\trcu_read_unlock();\n */\n#define rcu_pointer_handoff(p) (p)\n\n/**\n * rcu_read_lock() - mark the beginning of an RCU read-side critical section\n *\n * When synchronize_rcu() is invoked on one CPU while other CPUs\n * are within RCU read-side critical sections, then the\n * synchronize_rcu() is guaranteed to block until after all the other\n * CPUs exit their critical sections.  Similarly, if call_rcu() is invoked\n * on one CPU while other CPUs are within RCU read-side critical\n * sections, invocation of the corresponding RCU callback is deferred\n * until after the all the other CPUs exit their critical sections.\n *\n * Note, however, that RCU callbacks are permitted to run concurrently\n * with new RCU read-side critical sections.  One way that this can happen\n * is via the following sequence of events: (1) CPU 0 enters an RCU\n * read-side critical section, (2) CPU 1 invokes call_rcu() to register\n * an RCU callback, (3) CPU 0 exits the RCU read-side critical section,\n * (4) CPU 2 enters a RCU read-side critical section, (5) the RCU\n * callback is invoked.  This is legal, because the RCU read-side critical\n * section that was running concurrently with the call_rcu() (and which\n * therefore might be referencing something that the corresponding RCU\n * callback would free up) has completed before the corresponding\n * RCU callback is invoked.\n *\n * RCU read-side critical sections may be nested.  Any deferred actions\n * will be deferred until the outermost RCU read-side critical section\n * completes.\n *\n * You can avoid reading and understanding the next paragraph by\n * following this rule: don't put anything in an rcu_read_lock() RCU\n * read-side critical section that would block in a !PREEMPTION kernel.\n * But if you want the full story, read on!\n *\n * In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),\n * it is illegal to block while in an RCU read-side critical section.\n * In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION\n * kernel builds, RCU read-side critical sections may be preempted,\n * but explicit blocking is illegal.  Finally, in preemptible RCU\n * implementations in real-time (with -rt patchset) kernel builds, RCU\n * read-side critical sections may be preempted and they may also block, but\n * only when acquiring spinlocks that are subject to priority inheritance.\n */\nstatic __always_inline void rcu_read_lock(void)\n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_lock_acquire(&rcu_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock() used illegally while idle\");\n}\n\n/*\n * So where is rcu_write_lock()?  It does not exist, as there is no\n * way for writers to lock out RCU readers.  This is a feature, not\n * a bug -- this property is what provides RCU's performance benefits.\n * Of course, writers must coordinate with each other.  The normal\n * spinlock primitives work well for this, but any other technique may be\n * used as well.  RCU does not care how the writers keep out of each\n * others' way, as long as they do so.\n */\n\n/**\n * rcu_read_unlock() - marks the end of an RCU read-side critical section.\n *\n * In most situations, rcu_read_unlock() is immune from deadlock.\n * However, in kernels built with CONFIG_RCU_BOOST, rcu_read_unlock()\n * is responsible for deboosting, which it does via rt_mutex_unlock().\n * Unfortunately, this function acquires the scheduler's runqueue and\n * priority-inheritance spinlocks.  This means that deadlock could result\n * if the caller of rcu_read_unlock() already holds one of these locks or\n * any lock that is ever acquired while holding them.\n *\n * That said, RCU readers are never priority boosted unless they were\n * preempted.  Therefore, one way to avoid deadlock is to make sure\n * that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with one of\n * rt_mutex_unlock()'s locks held.  Such preemption can be avoided in\n * a number of ways, for example, by invoking preempt_disable() before\n * critical section's outermost rcu_read_lock().\n *\n * Given that the set of locks acquired by rt_mutex_unlock() might change\n * at any time, a somewhat more future-proofed approach is to make sure\n * that that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with irqs disabled.\n * This approach relies on the fact that rt_mutex_unlock() currently only\n * acquires irq-disabled locks.\n *\n * The second of these two approaches is best in most situations,\n * however, the first approach can also be useful, at least to those\n * developers willing to keep abreast of the set of locks acquired by\n * rt_mutex_unlock().\n *\n * See rcu_read_lock() for more information.\n */\nstatic inline void rcu_read_unlock(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock() used illegally while idle\");\n\t__release(RCU);\n\t__rcu_read_unlock();\n\trcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */\n}\n\n/**\n * rcu_read_lock_bh() - mark the beginning of an RCU-bh critical section\n *\n * This is equivalent of rcu_read_lock(), but also disables softirqs.\n * Note that anything else that disables softirqs can also serve as\n * an RCU read-side critical section.\n *\n * Note that rcu_read_lock_bh() and the matching rcu_read_unlock_bh()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_bh() from one task if the matching rcu_read_lock_bh()\n * was invoked from some other task.\n */\nstatic inline void rcu_read_lock_bh(void)\n{\n\tlocal_bh_disable();\n\t__acquire(RCU_BH);\n\trcu_lock_acquire(&rcu_bh_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_bh() used illegally while idle\");\n}\n\n/**\n * rcu_read_unlock_bh() - marks the end of a softirq-only RCU critical section\n *\n * See rcu_read_lock_bh() for more information.\n */\nstatic inline void rcu_read_unlock_bh(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_bh() used illegally while idle\");\n\trcu_lock_release(&rcu_bh_lock_map);\n\t__release(RCU_BH);\n\tlocal_bh_enable();\n}\n\n/**\n * rcu_read_lock_sched() - mark the beginning of a RCU-sched critical section\n *\n * This is equivalent of rcu_read_lock(), but disables preemption.\n * Read-side critical sections can also be introduced by anything else\n * that disables preemption, including local_irq_disable() and friends.\n *\n * Note that rcu_read_lock_sched() and the matching rcu_read_unlock_sched()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_sched() from process context if the matching\n * rcu_read_lock_sched() was invoked from an NMI handler.\n */\nstatic inline void rcu_read_lock_sched(void)\n{\n\tpreempt_disable();\n\t__acquire(RCU_SCHED);\n\trcu_lock_acquire(&rcu_sched_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_sched() used illegally while idle\");\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_lock_sched_notrace(void)\n{\n\tpreempt_disable_notrace();\n\t__acquire(RCU_SCHED);\n}\n\n/**\n * rcu_read_unlock_sched() - marks the end of a RCU-classic critical section\n *\n * See rcu_read_lock_sched() for more information.\n */\nstatic inline void rcu_read_unlock_sched(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_sched() used illegally while idle\");\n\trcu_lock_release(&rcu_sched_lock_map);\n\t__release(RCU_SCHED);\n\tpreempt_enable();\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_unlock_sched_notrace(void)\n{\n\t__release(RCU_SCHED);\n\tpreempt_enable_notrace();\n}\n\n/**\n * RCU_INIT_POINTER() - initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * Initialize an RCU-protected pointer in special cases where readers\n * do not need ordering constraints on the CPU or the compiler.  These\n * special cases are:\n *\n * 1.\tThis use of RCU_INIT_POINTER() is NULLing out the pointer *or*\n * 2.\tThe caller has taken whatever steps are required to prevent\n *\tRCU readers from concurrently accessing this pointer *or*\n * 3.\tThe referenced data structure has already been exposed to\n *\treaders either at compile time or via rcu_assign_pointer() *and*\n *\n *\ta.\tYou have not made *any* reader-visible changes to\n *\t\tthis structure since then *or*\n *\tb.\tIt is OK for readers accessing this structure from its\n *\t\tnew location to see the old state of the structure.  (For\n *\t\texample, the changes were to statistical counters or to\n *\t\tother state where exact synchronization is not required.)\n *\n * Failure to follow these rules governing use of RCU_INIT_POINTER() will\n * result in impossible-to-diagnose memory corruption.  As in the structures\n * will look OK in crash dumps, but any concurrent RCU readers might\n * see pre-initialized values of the referenced data structure.  So\n * please be very careful how you use RCU_INIT_POINTER()!!!\n *\n * If you are creating an RCU-protected linked structure that is accessed\n * by a single external-to-structure RCU-protected pointer, then you may\n * use RCU_INIT_POINTER() to initialize the internal RCU-protected\n * pointers, but you must use rcu_assign_pointer() to initialize the\n * external-to-structure pointer *after* you have completely initialized\n * the reader-accessible portions of the linked structure.\n *\n * Note that unlike rcu_assign_pointer(), RCU_INIT_POINTER() provides no\n * ordering guarantees for either the CPU or the compiler.\n */\n#define RCU_INIT_POINTER(p, v) \\\n\tdo { \\\n\t\trcu_check_sparse(p, __rcu); \\\n\t\tWRITE_ONCE(p, RCU_INITIALIZER(v)); \\\n\t} while (0)\n\n/**\n * RCU_POINTER_INITIALIZER() - statically initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * GCC-style initialization for an RCU-protected pointer in a structure field.\n */\n#define RCU_POINTER_INITIALIZER(p, v) \\\n\t\t.p = RCU_INITIALIZER(v)\n\n/*\n * Does the specified offset indicate that the corresponding rcu_head\n * structure can be handled by kvfree_rcu()?\n */\n#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)\n\n/**\n * kfree_rcu() - kfree an object after a grace period.\n * @ptr: pointer to kfree for both single- and double-argument invocations.\n * @rhf: the name of the struct rcu_head within the type of @ptr,\n *       but only for double-argument invocations.\n *\n * Many rcu callbacks functions just call kfree() on the base structure.\n * These functions are trivial, but their size adds up, and furthermore\n * when they are used in a kernel module, that module must invoke the\n * high-latency rcu_barrier() function at module-unload time.\n *\n * The kfree_rcu() function handles this issue.  Rather than encoding a\n * function address in the embedded rcu_head structure, kfree_rcu() instead\n * encodes the offset of the rcu_head structure within the base structure.\n * Because the functions are not allowed in the low-order 4096 bytes of\n * kernel virtual memory, offsets up to 4095 bytes can be accommodated.\n * If the offset is larger than 4095 bytes, a compile-time error will\n * be generated in kvfree_rcu_arg_2(). If this error is triggered, you can\n * either fall back to use of call_rcu() or rearrange the structure to\n * position the rcu_head structure into the first 4096 bytes.\n *\n * Note that the allowable offset might decrease in the future, for example,\n * to allow something like kmem_cache_free_rcu().\n *\n * The BUILD_BUG_ON check must not involve any function calls, hence the\n * checks are done in macros here.\n */\n#define kfree_rcu(ptr, rhf...) kvfree_rcu(ptr, ## rhf)\n\n/**\n * kvfree_rcu() - kvfree an object after a grace period.\n *\n * This macro consists of one or two arguments and it is\n * based on whether an object is head-less or not. If it\n * has a head then a semantic stays the same as it used\n * to be before:\n *\n *     kvfree_rcu(ptr, rhf);\n *\n * where @ptr is a pointer to kvfree(), @rhf is the name\n * of the rcu_head structure within the type of @ptr.\n *\n * When it comes to head-less variant, only one argument\n * is passed and that is just a pointer which has to be\n * freed after a grace period. Therefore the semantic is\n *\n *     kvfree_rcu(ptr);\n *\n * where @ptr is a pointer to kvfree().\n *\n * Please note, head-less way of freeing is permitted to\n * use from a context that has to follow might_sleep()\n * annotation. Otherwise, please switch and embed the\n * rcu_head structure within the type of @ptr.\n */\n#define kvfree_rcu(...) KVFREE_GET_MACRO(__VA_ARGS__,\t\t\\\n\tkvfree_rcu_arg_2, kvfree_rcu_arg_1)(__VA_ARGS__)\n\n#define KVFREE_GET_MACRO(_1, _2, NAME, ...) NAME\n#define kvfree_rcu_arg_2(ptr, rhf)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof (ptr) ___p = (ptr);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (___p) {\t\t\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG_ON(!__is_kvfree_rcu_offset(offsetof(typeof(*(ptr)), rhf)));\t\\\n\t\tkvfree_call_rcu(&((___p)->rhf), (rcu_callback_t)(unsigned long)\t\t\\\n\t\t\t(offsetof(typeof(*(ptr)), rhf)));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define kvfree_rcu_arg_1(ptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) ___p = (ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\\\n\t\tkvfree_call_rcu(NULL, (rcu_callback_t) (___p));\t\\\n} while (0)\n\n/*\n * Place this after a lock-acquisition primitive to guarantee that\n * an UNLOCK+LOCK pair acts as a full barrier.  This guarantee applies\n * if the UNLOCK and LOCK are executed by the same CPU or if the\n * UNLOCK and LOCK operate on the same lock variable.\n */\n#ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE\n#define smp_mb__after_unlock_lock()\tsmp_mb()  /* Full ordering for lock. */\n#else /* #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n#define smp_mb__after_unlock_lock()\tdo { } while (0)\n#endif /* #else #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n\n\n/* Has the specified rcu_head structure been handed to call_rcu()? */\n\n/**\n * rcu_head_init - Initialize rcu_head for rcu_head_after_call_rcu()\n * @rhp: The rcu_head structure to initialize.\n *\n * If you intend to invoke rcu_head_after_call_rcu() to test whether a\n * given rcu_head structure has already been passed to call_rcu(), then\n * you must also invoke this rcu_head_init() function on it just after\n * allocating that structure.  Calls to this function must not race with\n * calls to call_rcu(), rcu_head_after_call_rcu(), or callback invocation.\n */\nstatic inline void rcu_head_init(struct rcu_head *rhp)\n{\n\trhp->func = (rcu_callback_t)~0L;\n}\n\n/**\n * rcu_head_after_call_rcu() - Has this rcu_head been passed to call_rcu()?\n * @rhp: The rcu_head structure to test.\n * @f: The function passed to call_rcu() along with @rhp.\n *\n * Returns @true if the @rhp has been passed to call_rcu() with @func,\n * and @false otherwise.  Emits a warning in any other case, including\n * the case where @rhp has already been invoked after a grace period.\n * Calls to this function must not race with callback invocation.  One way\n * to avoid such races is to enclose the call to rcu_head_after_call_rcu()\n * in an RCU read-side critical section that includes a read-side fetch\n * of the pointer to the structure containing @rhp.\n */\nstatic inline bool\nrcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)\n{\n\trcu_callback_t func = READ_ONCE(rhp->func);\n\n\tif (func == f)\n\t\treturn true;\n\tWARN_ON_ONCE(func != (rcu_callback_t)~0L);\n\treturn false;\n}\n\n/* kernel/ksysfs.c definitions */\nextern int rcu_expedited;\nextern int rcu_normal;\n\n#endif /* __LINUX_RCUPDATE_H */\n"}, "3": {"id": 3, "path": "/src/include/asm-generic/rwonce.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Prevent the compiler from merging or refetching reads or writes. The\n * compiler is also forbidden from reordering successive instances of\n * READ_ONCE and WRITE_ONCE, but only when the compiler is aware of some\n * particular ordering. One way to make the compiler aware of ordering is to\n * put the two invocations of READ_ONCE or WRITE_ONCE in different C\n * statements.\n *\n * These two macros will also work on aggregate data types like structs or\n * unions.\n *\n * Their two major use cases are: (1) Mediating communication between\n * process-level code and irq/NMI handlers, all running on the same CPU,\n * and (2) Ensuring that the compiler does not fold, spindle, or otherwise\n * mutilate accesses that either do not require ordering or that interact\n * with an explicit memory barrier or atomic instruction that provides the\n * required ordering.\n */\n#ifndef __ASM_GENERIC_RWONCE_H\n#define __ASM_GENERIC_RWONCE_H\n\n#ifndef __ASSEMBLY__\n\n#include <linux/compiler_types.h>\n#include <linux/kasan-checks.h>\n#include <linux/kcsan-checks.h>\n\n/*\n * Yes, this permits 64-bit accesses on 32-bit architectures. These will\n * actually be atomic in some cases (namely Armv7 + LPAE), but for others we\n * rely on the access being split into 2x32-bit accesses for a 32-bit quantity\n * (e.g. a virtual address) and a strong prevailing wind.\n */\n#define compiletime_assert_rwonce_type(t)\t\t\t\t\t\\\n\tcompiletime_assert(__native_word(t) || sizeof(t) == sizeof(long long),\t\\\n\t\t\"Unsupported access size for {READ,WRITE}_ONCE().\")\n\n/*\n * Use __READ_ONCE() instead of READ_ONCE() if you do not require any\n * atomicity. Note that this may result in tears!\n */\n#ifndef __READ_ONCE\n#define __READ_ONCE(x)\t(*(const volatile __unqual_scalar_typeof(x) *)&(x))\n#endif\n\n#define READ_ONCE(x)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert_rwonce_type(x);\t\t\t\t\\\n\t__READ_ONCE(x);\t\t\t\t\t\t\t\\\n})\n\n#define __WRITE_ONCE(x, val)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t*(volatile typeof(x) *)&(x) = (val);\t\t\t\t\\\n} while (0)\n\n#define WRITE_ONCE(x, val)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert_rwonce_type(x);\t\t\t\t\\\n\t__WRITE_ONCE(x, val);\t\t\t\t\t\t\\\n} while (0)\n\nstatic __no_sanitize_or_inline\nunsigned long __read_once_word_nocheck(const void *addr)\n{\n\treturn __READ_ONCE(*(unsigned long *)addr);\n}\n\n/*\n * Use READ_ONCE_NOCHECK() instead of READ_ONCE() if you need to load a\n * word from memory atomically but without telling KASAN/KCSAN. This is\n * usually used by unwinding code when walking the stack of a running process.\n */\n#define READ_ONCE_NOCHECK(x)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert(sizeof(x) == sizeof(unsigned long),\t\t\\\n\t\t\"Unsupported access size for READ_ONCE_NOCHECK().\");\t\\\n\t(typeof(x))__read_once_word_nocheck(&(x));\t\t\t\\\n})\n\nstatic __no_kasan_or_inline\nunsigned long read_word_at_a_time(const void *addr)\n{\n\tkasan_check_read(addr, 1);\n\treturn *(unsigned long *)addr;\n}\n\n#endif /* __ASSEMBLY__ */\n#endif\t/* __ASM_GENERIC_RWONCE_H */\n"}, "0": {"id": 0, "path": "/src/net/core/rtnetlink.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tRouting netlink socket interface: protocol independent part.\n *\n * Authors:\tAlexey Kuznetsov, <kuznet@ms2.inr.ac.ru>\n *\n *\tFixes:\n *\tVitaly E. Lavrov\t\tRTA_OK arithmetics was wrong.\n */\n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/capability.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/if_addr.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/bpf.h>\n\n#include <linux/uaccess.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/arp.h>\n#include <net/route.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/pkt_sched.h>\n#include <net/fib_rules.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n\n#define RTNL_MAX_TYPE\t\t50\n#define RTNL_SLAVE_MAX_TYPE\t40\n\nstruct rtnl_link {\n\trtnl_doit_func\t\tdoit;\n\trtnl_dumpit_func\tdumpit;\n\tstruct module\t\t*owner;\n\tunsigned int\t\tflags;\n\tstruct rcu_head\t\trcu;\n};\n\nstatic DEFINE_MUTEX(rtnl_mutex);\n\nvoid rtnl_lock(void)\n{\n\tmutex_lock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_lock);\n\nint rtnl_lock_killable(void)\n{\n\treturn mutex_lock_killable(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_lock_killable);\n\nstatic struct sk_buff *defer_kfree_skb_list;\nvoid rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail)\n{\n\tif (head && tail) {\n\t\ttail->next = defer_kfree_skb_list;\n\t\tdefer_kfree_skb_list = head;\n\t}\n}\nEXPORT_SYMBOL(rtnl_kfree_skbs);\n\nvoid __rtnl_unlock(void)\n{\n\tstruct sk_buff *head = defer_kfree_skb_list;\n\n\tdefer_kfree_skb_list = NULL;\n\n\tmutex_unlock(&rtnl_mutex);\n\n\twhile (head) {\n\t\tstruct sk_buff *next = head->next;\n\n\t\tkfree_skb(head);\n\t\tcond_resched();\n\t\thead = next;\n\t}\n}\n\nvoid rtnl_unlock(void)\n{\n\t/* This fellow will unlock it for us. */\n\tnetdev_run_todo();\n}\nEXPORT_SYMBOL(rtnl_unlock);\n\nint rtnl_trylock(void)\n{\n\treturn mutex_trylock(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_trylock);\n\nint rtnl_is_locked(void)\n{\n\treturn mutex_is_locked(&rtnl_mutex);\n}\nEXPORT_SYMBOL(rtnl_is_locked);\n\nbool refcount_dec_and_rtnl_lock(refcount_t *r)\n{\n\treturn refcount_dec_and_mutex_lock(r, &rtnl_mutex);\n}\nEXPORT_SYMBOL(refcount_dec_and_rtnl_lock);\n\n#ifdef CONFIG_PROVE_LOCKING\nbool lockdep_rtnl_is_held(void)\n{\n\treturn lockdep_is_held(&rtnl_mutex);\n}\nEXPORT_SYMBOL(lockdep_rtnl_is_held);\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n\nstatic struct rtnl_link __rcu *__rcu *rtnl_msg_handlers[RTNL_FAMILY_MAX + 1];\n\nstatic inline int rtm_msgindex(int msgtype)\n{\n\tint msgindex = msgtype - RTM_BASE;\n\n\t/*\n\t * msgindex < 0 implies someone tried to register a netlink\n\t * control code. msgindex >= RTM_NR_MSGTYPES may indicate that\n\t * the message type has not been added to linux/rtnetlink.h\n\t */\n\tBUG_ON(msgindex < 0 || msgindex >= RTM_NR_MSGTYPES);\n\n\treturn msgindex;\n}\n\nstatic struct rtnl_link *rtnl_get_link(int protocol, int msgtype)\n{\n\tstruct rtnl_link __rcu **tab;\n\n\tif (protocol >= ARRAY_SIZE(rtnl_msg_handlers))\n\t\tprotocol = PF_UNSPEC;\n\n\ttab = rcu_dereference_rtnl(rtnl_msg_handlers[protocol]);\n\tif (!tab)\n\t\ttab = rcu_dereference_rtnl(rtnl_msg_handlers[PF_UNSPEC]);\n\n\treturn rcu_dereference_rtnl(tab[msgtype]);\n}\n\nstatic int rtnl_register_internal(struct module *owner,\n\t\t\t\t  int protocol, int msgtype,\n\t\t\t\t  rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct rtnl_link *link, *old;\n\tstruct rtnl_link __rcu **tab;\n\tint msgindex;\n\tint ret = -ENOBUFS;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\trtnl_lock();\n\ttab = rtnl_dereference(rtnl_msg_handlers[protocol]);\n\tif (tab == NULL) {\n\t\ttab = kcalloc(RTM_NR_MSGTYPES, sizeof(void *), GFP_KERNEL);\n\t\tif (!tab)\n\t\t\tgoto unlock;\n\n\t\t/* ensures we see the 0 stores */\n\t\trcu_assign_pointer(rtnl_msg_handlers[protocol], tab);\n\t}\n\n\told = rtnl_dereference(tab[msgindex]);\n\tif (old) {\n\t\tlink = kmemdup(old, sizeof(*old), GFP_KERNEL);\n\t\tif (!link)\n\t\t\tgoto unlock;\n\t} else {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link)\n\t\t\tgoto unlock;\n\t}\n\n\tWARN_ON(link->owner && link->owner != owner);\n\tlink->owner = owner;\n\n\tWARN_ON(doit && link->doit && link->doit != doit);\n\tif (doit)\n\t\tlink->doit = doit;\n\tWARN_ON(dumpit && link->dumpit && link->dumpit != dumpit);\n\tif (dumpit)\n\t\tlink->dumpit = dumpit;\n\n\tlink->flags |= flags;\n\n\t/* publish protocol:msgtype */\n\trcu_assign_pointer(tab[msgindex], link);\n\tret = 0;\n\tif (old)\n\t\tkfree_rcu(old, rcu);\nunlock:\n\trtnl_unlock();\n\treturn ret;\n}\n\n/**\n * rtnl_register_module - Register a rtnetlink message type\n *\n * @owner: module registering the hook (THIS_MODULE)\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n * @doit: Function pointer called for each request message\n * @dumpit: Function pointer called for each dump request (NLM_F_DUMP) message\n * @flags: rtnl_link_flags to modifiy behaviour of doit/dumpit functions\n *\n * Like rtnl_register, but for use by removable modules.\n */\nint rtnl_register_module(struct module *owner,\n\t\t\t int protocol, int msgtype,\n\t\t\t rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t\t unsigned int flags)\n{\n\treturn rtnl_register_internal(owner, protocol, msgtype,\n\t\t\t\t      doit, dumpit, flags);\n}\nEXPORT_SYMBOL_GPL(rtnl_register_module);\n\n/**\n * rtnl_register - Register a rtnetlink message type\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n * @doit: Function pointer called for each request message\n * @dumpit: Function pointer called for each dump request (NLM_F_DUMP) message\n * @flags: rtnl_link_flags to modifiy behaviour of doit/dumpit functions\n *\n * Registers the specified function pointers (at least one of them has\n * to be non-NULL) to be called whenever a request message for the\n * specified protocol family and message type is received.\n *\n * The special protocol family PF_UNSPEC may be used to define fallback\n * function pointers for the case when no entry for the specific protocol\n * family exists.\n */\nvoid rtnl_register(int protocol, int msgtype,\n\t\t   rtnl_doit_func doit, rtnl_dumpit_func dumpit,\n\t\t   unsigned int flags)\n{\n\tint err;\n\n\terr = rtnl_register_internal(NULL, protocol, msgtype, doit, dumpit,\n\t\t\t\t     flags);\n\tif (err)\n\t\tpr_err(\"Unable to register rtnetlink message handler, \"\n\t\t       \"protocol = %d, message type = %d\\n\", protocol, msgtype);\n}\n\n/**\n * rtnl_unregister - Unregister a rtnetlink message type\n * @protocol: Protocol family or PF_UNSPEC\n * @msgtype: rtnetlink message type\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_unregister(int protocol, int msgtype)\n{\n\tstruct rtnl_link __rcu **tab;\n\tstruct rtnl_link *link;\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\tmsgindex = rtm_msgindex(msgtype);\n\n\trtnl_lock();\n\ttab = rtnl_dereference(rtnl_msg_handlers[protocol]);\n\tif (!tab) {\n\t\trtnl_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tlink = rtnl_dereference(tab[msgindex]);\n\trcu_assign_pointer(tab[msgindex], NULL);\n\trtnl_unlock();\n\n\tkfree_rcu(link, rcu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister);\n\n/**\n * rtnl_unregister_all - Unregister all rtnetlink message type of a protocol\n * @protocol : Protocol family or PF_UNSPEC\n *\n * Identical to calling rtnl_unregster() for all registered message types\n * of a certain protocol family.\n */\nvoid rtnl_unregister_all(int protocol)\n{\n\tstruct rtnl_link __rcu **tab;\n\tstruct rtnl_link *link;\n\tint msgindex;\n\n\tBUG_ON(protocol < 0 || protocol > RTNL_FAMILY_MAX);\n\n\trtnl_lock();\n\ttab = rtnl_dereference(rtnl_msg_handlers[protocol]);\n\tif (!tab) {\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\tRCU_INIT_POINTER(rtnl_msg_handlers[protocol], NULL);\n\tfor (msgindex = 0; msgindex < RTM_NR_MSGTYPES; msgindex++) {\n\t\tlink = rtnl_dereference(tab[msgindex]);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(tab[msgindex], NULL);\n\t\tkfree_rcu(link, rcu);\n\t}\n\trtnl_unlock();\n\n\tsynchronize_net();\n\n\tkfree(tab);\n}\nEXPORT_SYMBOL_GPL(rtnl_unregister_all);\n\nstatic LIST_HEAD(link_ops);\n\nstatic const struct rtnl_link_ops *rtnl_link_ops_get(const char *kind)\n{\n\tconst struct rtnl_link_ops *ops;\n\n\tlist_for_each_entry(ops, &link_ops, list) {\n\t\tif (!strcmp(ops->kind, kind))\n\t\t\treturn ops;\n\t}\n\treturn NULL;\n}\n\n/**\n * __rtnl_link_register - Register rtnl_link_ops with rtnetlink.\n * @ops: struct rtnl_link_ops * to register\n *\n * The caller must hold the rtnl_mutex. This function should be used\n * by drivers that create devices during module initialization. It\n * must be called before registering the devices.\n *\n * Returns 0 on success or a negative error code.\n */\nint __rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tif (rtnl_link_ops_get(ops->kind))\n\t\treturn -EEXIST;\n\n\t/* The check for setup is here because if ops\n\t * does not have that filled up, it is not possible\n\t * to use the ops for creating device. So do not\n\t * fill up dellink as well. That disables rtnl_dellink.\n\t */\n\tif (ops->setup && !ops->dellink)\n\t\tops->dellink = unregister_netdevice_queue;\n\n\tlist_add_tail(&ops->list, &link_ops);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_register);\n\n/**\n * rtnl_link_register - Register rtnl_link_ops with rtnetlink.\n * @ops: struct rtnl_link_ops * to register\n *\n * Returns 0 on success or a negative error code.\n */\nint rtnl_link_register(struct rtnl_link_ops *ops)\n{\n\tint err;\n\n\t/* Sanity-check max sizes to avoid stack buffer overflow. */\n\tif (WARN_ON(ops->maxtype > RTNL_MAX_TYPE ||\n\t\t    ops->slave_maxtype > RTNL_SLAVE_MAX_TYPE))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\terr = __rtnl_link_register(ops);\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtnl_link_register);\n\nstatic void __rtnl_kill_links(struct net *net, struct rtnl_link_ops *ops)\n{\n\tstruct net_device *dev;\n\tLIST_HEAD(list_kill);\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->rtnl_link_ops == ops)\n\t\t\tops->dellink(dev, &list_kill);\n\t}\n\tunregister_netdevice_many(&list_kill);\n}\n\n/**\n * __rtnl_link_unregister - Unregister rtnl_link_ops from rtnetlink.\n * @ops: struct rtnl_link_ops * to unregister\n *\n * The caller must hold the rtnl_mutex and guarantee net_namespace_list\n * integrity (hold pernet_ops_rwsem for writing to close the race\n * with setup_net() and cleanup_net()).\n */\nvoid __rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\tstruct net *net;\n\n\tfor_each_net(net) {\n\t\t__rtnl_kill_links(net, ops);\n\t}\n\tlist_del(&ops->list);\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_unregister);\n\n/* Return with the rtnl_lock held when there are no network\n * devices unregistering in any network namespace.\n */\nstatic void rtnl_lock_unregistering_all(void)\n{\n\tstruct net *net;\n\tbool unregistering;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(&netdev_unregistering_wq, &wait);\n\tfor (;;) {\n\t\tunregistering = false;\n\t\trtnl_lock();\n\t\t/* We held write locked pernet_ops_rwsem, and parallel\n\t\t * setup_net() and cleanup_net() are not possible.\n\t\t */\n\t\tfor_each_net(net) {\n\t\t\tif (net->dev_unreg_count > 0) {\n\t\t\t\tunregistering = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!unregistering)\n\t\t\tbreak;\n\t\t__rtnl_unlock();\n\n\t\twait_woken(&wait, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&netdev_unregistering_wq, &wait);\n}\n\n/**\n * rtnl_link_unregister - Unregister rtnl_link_ops from rtnetlink.\n * @ops: struct rtnl_link_ops * to unregister\n */\nvoid rtnl_link_unregister(struct rtnl_link_ops *ops)\n{\n\t/* Close the race with setup_net() and cleanup_net() */\n\tdown_write(&pernet_ops_rwsem);\n\trtnl_lock_unregistering_all();\n\t__rtnl_link_unregister(ops);\n\trtnl_unlock();\n\tup_write(&pernet_ops_rwsem);\n}\nEXPORT_SYMBOL_GPL(rtnl_link_unregister);\n\nstatic size_t rtnl_link_get_slave_info_data_size(const struct net_device *dev)\n{\n\tstruct net_device *master_dev;\n\tconst struct rtnl_link_ops *ops;\n\tsize_t size = 0;\n\n\trcu_read_lock();\n\n\tmaster_dev = netdev_master_upper_dev_get_rcu((struct net_device *)dev);\n\tif (!master_dev)\n\t\tgoto out;\n\n\tops = master_dev->rtnl_link_ops;\n\tif (!ops || !ops->get_slave_size)\n\t\tgoto out;\n\t/* IFLA_INFO_SLAVE_DATA + nested data */\n\tsize = nla_total_size(sizeof(struct nlattr)) +\n\t       ops->get_slave_size(master_dev, dev);\n\nout:\n\trcu_read_unlock();\n\treturn size;\n}\n\nstatic size_t rtnl_link_get_size(const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tsize_t size;\n\n\tif (!ops)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct nlattr)) + /* IFLA_LINKINFO */\n\t       nla_total_size(strlen(ops->kind) + 1);  /* IFLA_INFO_KIND */\n\n\tif (ops->get_size)\n\t\t/* IFLA_INFO_DATA + nested data */\n\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\tops->get_size(dev);\n\n\tif (ops->get_xstats_size)\n\t\t/* IFLA_INFO_XSTATS */\n\t\tsize += nla_total_size(ops->get_xstats_size(dev));\n\n\tsize += rtnl_link_get_slave_info_data_size(dev);\n\n\treturn size;\n}\n\nstatic LIST_HEAD(rtnl_af_ops);\n\nstatic const struct rtnl_af_ops *rtnl_af_lookup(const int family)\n{\n\tconst struct rtnl_af_ops *ops;\n\n\tlist_for_each_entry_rcu(ops, &rtnl_af_ops, list) {\n\t\tif (ops->family == family)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * rtnl_af_register - Register rtnl_af_ops with rtnetlink.\n * @ops: struct rtnl_af_ops * to register\n *\n * Returns 0 on success or a negative error code.\n */\nvoid rtnl_af_register(struct rtnl_af_ops *ops)\n{\n\trtnl_lock();\n\tlist_add_tail_rcu(&ops->list, &rtnl_af_ops);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(rtnl_af_register);\n\n/**\n * rtnl_af_unregister - Unregister rtnl_af_ops from rtnetlink.\n * @ops: struct rtnl_af_ops * to unregister\n */\nvoid rtnl_af_unregister(struct rtnl_af_ops *ops)\n{\n\trtnl_lock();\n\tlist_del_rcu(&ops->list);\n\trtnl_unlock();\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(rtnl_af_unregister);\n\nstatic size_t rtnl_link_get_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct rtnl_af_ops *af_ops;\n\tsize_t size;\n\n\t/* IFLA_AF_SPEC */\n\tsize = nla_total_size(sizeof(struct nlattr));\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\tif (af_ops->get_link_af_size) {\n\t\t\t/* AF_* + nested data */\n\t\t\tsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t\t\taf_ops->get_link_af_size(dev, ext_filter_mask);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn size;\n}\n\nstatic bool rtnl_have_link_slave_info(const struct net_device *dev)\n{\n\tstruct net_device *master_dev;\n\tbool ret = false;\n\n\trcu_read_lock();\n\n\tmaster_dev = netdev_master_upper_dev_get_rcu((struct net_device *)dev);\n\tif (master_dev && master_dev->rtnl_link_ops)\n\t\tret = true;\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int rtnl_link_slave_info_fill(struct sk_buff *skb,\n\t\t\t\t     const struct net_device *dev)\n{\n\tstruct net_device *master_dev;\n\tconst struct rtnl_link_ops *ops;\n\tstruct nlattr *slave_data;\n\tint err;\n\n\tmaster_dev = netdev_master_upper_dev_get((struct net_device *) dev);\n\tif (!master_dev)\n\t\treturn 0;\n\tops = master_dev->rtnl_link_ops;\n\tif (!ops)\n\t\treturn 0;\n\tif (nla_put_string(skb, IFLA_INFO_SLAVE_KIND, ops->kind) < 0)\n\t\treturn -EMSGSIZE;\n\tif (ops->fill_slave_info) {\n\t\tslave_data = nla_nest_start_noflag(skb, IFLA_INFO_SLAVE_DATA);\n\t\tif (!slave_data)\n\t\t\treturn -EMSGSIZE;\n\t\terr = ops->fill_slave_info(skb, master_dev, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_slave_data;\n\t\tnla_nest_end(skb, slave_data);\n\t}\n\treturn 0;\n\nerr_cancel_slave_data:\n\tnla_nest_cancel(skb, slave_data);\n\treturn err;\n}\n\nstatic int rtnl_link_info_fill(struct sk_buff *skb,\n\t\t\t       const struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\tstruct nlattr *data;\n\tint err;\n\n\tif (!ops)\n\t\treturn 0;\n\tif (nla_put_string(skb, IFLA_INFO_KIND, ops->kind) < 0)\n\t\treturn -EMSGSIZE;\n\tif (ops->fill_xstats) {\n\t\terr = ops->fill_xstats(skb, dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (ops->fill_info) {\n\t\tdata = nla_nest_start_noflag(skb, IFLA_INFO_DATA);\n\t\tif (data == NULL)\n\t\t\treturn -EMSGSIZE;\n\t\terr = ops->fill_info(skb, dev);\n\t\tif (err < 0)\n\t\t\tgoto err_cancel_data;\n\t\tnla_nest_end(skb, data);\n\t}\n\treturn 0;\n\nerr_cancel_data:\n\tnla_nest_cancel(skb, data);\n\treturn err;\n}\n\nstatic int rtnl_link_fill(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct nlattr *linkinfo;\n\tint err = -EMSGSIZE;\n\n\tlinkinfo = nla_nest_start_noflag(skb, IFLA_LINKINFO);\n\tif (linkinfo == NULL)\n\t\tgoto out;\n\n\terr = rtnl_link_info_fill(skb, dev);\n\tif (err < 0)\n\t\tgoto err_cancel_link;\n\n\terr = rtnl_link_slave_info_fill(skb, dev);\n\tif (err < 0)\n\t\tgoto err_cancel_link;\n\n\tnla_nest_end(skb, linkinfo);\n\treturn 0;\n\nerr_cancel_link:\n\tnla_nest_cancel(skb, linkinfo);\nout:\n\treturn err;\n}\n\nint rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned int group, int echo)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint err = 0;\n\n\tNETLINK_CB(skb).dst_group = group;\n\tif (echo)\n\t\trefcount_inc(&skb->users);\n\tnetlink_broadcast(rtnl, skb, pid, group, GFP_KERNEL);\n\tif (echo)\n\t\terr = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT);\n\treturn err;\n}\n\nint rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\treturn nlmsg_unicast(rtnl, skb, pid);\n}\nEXPORT_SYMBOL(rtnl_unicast);\n\nvoid rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,\n\t\t struct nlmsghdr *nlh, gfp_t flags)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint report = 0;\n\n\tif (nlh)\n\t\treport = nlmsg_report(nlh);\n\n\tnlmsg_notify(rtnl, skb, pid, group, report, flags);\n}\nEXPORT_SYMBOL(rtnl_notify);\n\nvoid rtnl_set_sk_err(struct net *net, u32 group, int error)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\tnetlink_set_err(rtnl, 0, group, error);\n}\nEXPORT_SYMBOL(rtnl_set_sk_err);\n\nint rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics)\n{\n\tstruct nlattr *mx;\n\tint i, valid = 0;\n\n\t/* nothing is dumped for dst_default_metrics, so just skip the loop */\n\tif (metrics == dst_default_metrics.metrics)\n\t\treturn 0;\n\n\tmx = nla_nest_start_noflag(skb, RTA_METRICS);\n\tif (mx == NULL)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < RTAX_MAX; i++) {\n\t\tif (metrics[i]) {\n\t\t\tif (i == RTAX_CC_ALGO - 1) {\n\t\t\t\tchar tmp[TCP_CA_NAME_MAX], *name;\n\n\t\t\t\tname = tcp_ca_get_name_by_key(metrics[i], tmp);\n\t\t\t\tif (!name)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (nla_put_string(skb, i + 1, name))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t} else if (i == RTAX_FEATURES - 1) {\n\t\t\t\tu32 user_features = metrics[i] & RTAX_FEATURE_MASK;\n\n\t\t\t\tif (!user_features)\n\t\t\t\t\tcontinue;\n\t\t\t\tBUILD_BUG_ON(RTAX_FEATURE_MASK & DST_FEATURE_MASK);\n\t\t\t\tif (nla_put_u32(skb, i + 1, user_features))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t} else {\n\t\t\t\tif (nla_put_u32(skb, i + 1, metrics[i]))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tvalid++;\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\tnla_nest_cancel(skb, mx);\n\t\treturn 0;\n\t}\n\n\treturn nla_nest_end(skb, mx);\n\nnla_put_failure:\n\tnla_nest_cancel(skb, mx);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(rtnetlink_put_metrics);\n\nint rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst, u32 id,\n\t\t       long expires, u32 error)\n{\n\tstruct rta_cacheinfo ci = {\n\t\t.rta_error = error,\n\t\t.rta_id =  id,\n\t};\n\n\tif (dst) {\n\t\tci.rta_lastuse = jiffies_delta_to_clock_t(jiffies - dst->lastuse);\n\t\tci.rta_used = dst->__use;\n\t\tci.rta_clntref = atomic_read(&dst->__refcnt);\n\t}\n\tif (expires) {\n\t\tunsigned long clock;\n\n\t\tclock = jiffies_to_clock_t(abs(expires));\n\t\tclock = min_t(unsigned long, clock, INT_MAX);\n\t\tci.rta_expires = (expires > 0) ? clock : -clock;\n\t}\n\treturn nla_put(skb, RTA_CACHEINFO, sizeof(ci), &ci);\n}\nEXPORT_SYMBOL_GPL(rtnl_put_cacheinfo);\n\nstatic void set_operstate(struct net_device *dev, unsigned char transition)\n{\n\tunsigned char operstate = dev->operstate;\n\n\tswitch (transition) {\n\tcase IF_OPER_UP:\n\t\tif ((operstate == IF_OPER_DORMANT ||\n\t\t     operstate == IF_OPER_TESTING ||\n\t\t     operstate == IF_OPER_UNKNOWN) &&\n\t\t    !netif_dormant(dev) && !netif_testing(dev))\n\t\t\toperstate = IF_OPER_UP;\n\t\tbreak;\n\n\tcase IF_OPER_TESTING:\n\t\tif (operstate == IF_OPER_UP ||\n\t\t    operstate == IF_OPER_UNKNOWN)\n\t\t\toperstate = IF_OPER_TESTING;\n\t\tbreak;\n\n\tcase IF_OPER_DORMANT:\n\t\tif (operstate == IF_OPER_UP ||\n\t\t    operstate == IF_OPER_UNKNOWN)\n\t\t\toperstate = IF_OPER_DORMANT;\n\t\tbreak;\n\t}\n\n\tif (dev->operstate != operstate) {\n\t\twrite_lock_bh(&dev_base_lock);\n\t\tdev->operstate = operstate;\n\t\twrite_unlock_bh(&dev_base_lock);\n\t\tnetdev_state_change(dev);\n\t}\n}\n\nstatic unsigned int rtnl_dev_get_flags(const struct net_device *dev)\n{\n\treturn (dev->flags & ~(IFF_PROMISC | IFF_ALLMULTI)) |\n\t       (dev->gflags & (IFF_PROMISC | IFF_ALLMULTI));\n}\n\nstatic unsigned int rtnl_dev_combine_flags(const struct net_device *dev,\n\t\t\t\t\t   const struct ifinfomsg *ifm)\n{\n\tunsigned int flags = ifm->ifi_flags;\n\n\t/* bugwards compatibility: ifi_change == 0 is treated as ~0 */\n\tif (ifm->ifi_change)\n\t\tflags = (flags & ifm->ifi_change) |\n\t\t\t(rtnl_dev_get_flags(dev) & ~ifm->ifi_change);\n\n\treturn flags;\n}\n\nstatic void copy_rtnl_link_stats(struct rtnl_link_stats *a,\n\t\t\t\t const struct rtnl_link_stats64 *b)\n{\n\ta->rx_packets = b->rx_packets;\n\ta->tx_packets = b->tx_packets;\n\ta->rx_bytes = b->rx_bytes;\n\ta->tx_bytes = b->tx_bytes;\n\ta->rx_errors = b->rx_errors;\n\ta->tx_errors = b->tx_errors;\n\ta->rx_dropped = b->rx_dropped;\n\ta->tx_dropped = b->tx_dropped;\n\n\ta->multicast = b->multicast;\n\ta->collisions = b->collisions;\n\n\ta->rx_length_errors = b->rx_length_errors;\n\ta->rx_over_errors = b->rx_over_errors;\n\ta->rx_crc_errors = b->rx_crc_errors;\n\ta->rx_frame_errors = b->rx_frame_errors;\n\ta->rx_fifo_errors = b->rx_fifo_errors;\n\ta->rx_missed_errors = b->rx_missed_errors;\n\n\ta->tx_aborted_errors = b->tx_aborted_errors;\n\ta->tx_carrier_errors = b->tx_carrier_errors;\n\ta->tx_fifo_errors = b->tx_fifo_errors;\n\ta->tx_heartbeat_errors = b->tx_heartbeat_errors;\n\ta->tx_window_errors = b->tx_window_errors;\n\n\ta->rx_compressed = b->rx_compressed;\n\ta->tx_compressed = b->tx_compressed;\n\n\ta->rx_nohandler = b->rx_nohandler;\n}\n\n/* All VF info */\nstatic inline int rtnl_vfinfo_size(const struct net_device *dev,\n\t\t\t\t   u32 ext_filter_mask)\n{\n\tif (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF)) {\n\t\tint num_vfs = dev_num_vf(dev->dev.parent);\n\t\tsize_t size = nla_total_size(0);\n\t\tsize += num_vfs *\n\t\t\t(nla_total_size(0) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_mac)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_broadcast)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_vlan)) +\n\t\t\t nla_total_size(0) + /* nest IFLA_VF_VLAN_LIST */\n\t\t\t nla_total_size(MAX_VLAN_LIST_LEN *\n\t\t\t\t\tsizeof(struct ifla_vf_vlan_info)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_spoofchk)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_tx_rate)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_rate)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_link_state)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_rss_query_en)) +\n\t\t\t nla_total_size(0) + /* nest IFLA_VF_STATS */\n\t\t\t /* IFLA_VF_STATS_RX_PACKETS */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_TX_PACKETS */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_RX_BYTES */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_TX_BYTES */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_BROADCAST */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_MULTICAST */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_RX_DROPPED */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t /* IFLA_VF_STATS_TX_DROPPED */\n\t\t\t nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t nla_total_size(sizeof(struct ifla_vf_trust)));\n\t\treturn size;\n\t} else\n\t\treturn 0;\n}\n\nstatic size_t rtnl_port_size(const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tsize_t port_size = nla_total_size(4)\t\t/* PORT_VF */\n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t/* PORT_PROFILE */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_INSTANCE_UUID */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_HOST_UUID */\n\t\t+ nla_total_size(1)\t\t\t/* PROT_VDP_REQUEST */\n\t\t+ nla_total_size(2);\t\t\t/* PORT_VDP_RESPONSE */\n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n\nstatic size_t rtnl_xdp_size(void)\n{\n\tsize_t xdp_size = nla_total_size(0) +\t/* nest IFLA_XDP */\n\t\t\t  nla_total_size(1) +\t/* XDP_ATTACHED */\n\t\t\t  nla_total_size(4) +\t/* XDP_PROG_ID (or 1st mode) */\n\t\t\t  nla_total_size(4);\t/* XDP_<mode>_PROG_ID */\n\n\treturn xdp_size;\n}\n\nstatic size_t rtnl_prop_list_size(const struct net_device *dev)\n{\n\tstruct netdev_name_node *name_node;\n\tsize_t size;\n\n\tif (list_empty(&dev->name_node->list))\n\t\treturn 0;\n\tsize = nla_total_size(0);\n\tlist_for_each_entry(name_node, &dev->name_node->list, list)\n\t\tsize += nla_total_size(ALTIFNAMSIZ);\n\treturn size;\n}\n\nstatic size_t rtnl_proto_down_size(const struct net_device *dev)\n{\n\tsize_t size = nla_total_size(1);\n\n\tif (dev->proto_down_reason)\n\t\tsize += nla_total_size(0) + nla_total_size(4);\n\n\treturn size;\n}\n\nstatic noinline size_t if_nlmsg_size(const struct net_device *dev,\n\t\t\t\t     u32 ext_filter_mask)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */\n\t       + nla_total_size(IFALIASZ) /* IFLA_IFALIAS */\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_QDISC */\n\t       + nla_total_size_64bit(sizeof(struct rtnl_link_ifmap))\n\t       + nla_total_size(sizeof(struct rtnl_link_stats))\n\t       + nla_total_size_64bit(sizeof(struct rtnl_link_stats64))\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_BROADCAST */\n\t       + nla_total_size(4) /* IFLA_TXQLEN */\n\t       + nla_total_size(4) /* IFLA_WEIGHT */\n\t       + nla_total_size(4) /* IFLA_MTU */\n\t       + nla_total_size(4) /* IFLA_LINK */\n\t       + nla_total_size(4) /* IFLA_MASTER */\n\t       + nla_total_size(1) /* IFLA_CARRIER */\n\t       + nla_total_size(4) /* IFLA_PROMISCUITY */\n\t       + nla_total_size(4) /* IFLA_NUM_TX_QUEUES */\n\t       + nla_total_size(4) /* IFLA_NUM_RX_QUEUES */\n\t       + nla_total_size(4) /* IFLA_GSO_MAX_SEGS */\n\t       + nla_total_size(4) /* IFLA_GSO_MAX_SIZE */\n\t       + nla_total_size(1) /* IFLA_OPERSTATE */\n\t       + nla_total_size(1) /* IFLA_LINKMODE */\n\t       + nla_total_size(4) /* IFLA_CARRIER_CHANGES */\n\t       + nla_total_size(4) /* IFLA_LINK_NETNSID */\n\t       + nla_total_size(4) /* IFLA_GROUP */\n\t       + nla_total_size(ext_filter_mask\n\t\t\t        & RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */\n\t       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */\n\t       + rtnl_port_size(dev, ext_filter_mask) /* IFLA_VF_PORTS + IFLA_PORT_SELF */\n\t       + rtnl_link_get_size(dev) /* IFLA_LINKINFO */\n\t       + rtnl_link_get_af_size(dev, ext_filter_mask) /* IFLA_AF_SPEC */\n\t       + nla_total_size(MAX_PHYS_ITEM_ID_LEN) /* IFLA_PHYS_PORT_ID */\n\t       + nla_total_size(MAX_PHYS_ITEM_ID_LEN) /* IFLA_PHYS_SWITCH_ID */\n\t       + nla_total_size(IFNAMSIZ) /* IFLA_PHYS_PORT_NAME */\n\t       + rtnl_xdp_size() /* IFLA_XDP */\n\t       + nla_total_size(4)  /* IFLA_EVENT */\n\t       + nla_total_size(4)  /* IFLA_NEW_NETNSID */\n\t       + nla_total_size(4)  /* IFLA_NEW_IFINDEX */\n\t       + rtnl_proto_down_size(dev)  /* proto down */\n\t       + nla_total_size(4)  /* IFLA_TARGET_NETNSID */\n\t       + nla_total_size(4)  /* IFLA_CARRIER_UP_COUNT */\n\t       + nla_total_size(4)  /* IFLA_CARRIER_DOWN_COUNT */\n\t       + nla_total_size(4)  /* IFLA_MIN_MTU */\n\t       + nla_total_size(4)  /* IFLA_MAX_MTU */\n\t       + rtnl_prop_list_size(dev)\n\t       + nla_total_size(MAX_ADDR_LEN) /* IFLA_PERM_ADDRESS */\n\t       + 0;\n}\n\nstatic int rtnl_vf_ports_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *vf_ports;\n\tstruct nlattr *vf_port;\n\tint vf;\n\tint err;\n\n\tvf_ports = nla_nest_start_noflag(skb, IFLA_VF_PORTS);\n\tif (!vf_ports)\n\t\treturn -EMSGSIZE;\n\n\tfor (vf = 0; vf < dev_num_vf(dev->dev.parent); vf++) {\n\t\tvf_port = nla_nest_start_noflag(skb, IFLA_VF_PORT);\n\t\tif (!vf_port)\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, IFLA_PORT_VF, vf))\n\t\t\tgoto nla_put_failure;\n\t\terr = dev->netdev_ops->ndo_get_vf_port(dev, vf, skb);\n\t\tif (err == -EMSGSIZE)\n\t\t\tgoto nla_put_failure;\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, vf_port);\n\t\t\tcontinue;\n\t\t}\n\t\tnla_nest_end(skb, vf_port);\n\t}\n\n\tnla_nest_end(skb, vf_ports);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, vf_ports);\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_port_self_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *port_self;\n\tint err;\n\n\tport_self = nla_nest_start_noflag(skb, IFLA_PORT_SELF);\n\tif (!port_self)\n\t\treturn -EMSGSIZE;\n\n\terr = dev->netdev_ops->ndo_get_vf_port(dev, PORT_SELF_VF, skb);\n\tif (err) {\n\t\tnla_nest_cancel(skb, port_self);\n\t\treturn (err == -EMSGSIZE) ? err : 0;\n\t}\n\n\tnla_nest_end(skb, port_self);\n\n\treturn 0;\n}\n\nstatic int rtnl_port_fill(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  u32 ext_filter_mask)\n{\n\tint err;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\n\terr = rtnl_port_self_fill(skb, dev);\n\tif (err)\n\t\treturn err;\n\n\tif (dev_num_vf(dev->dev.parent)) {\n\t\terr = rtnl_vf_ports_fill(skb, dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_phys_port_id_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tint err;\n\tstruct netdev_phys_item_id ppid;\n\n\terr = dev_get_phys_port_id(dev, &ppid);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (nla_put(skb, IFLA_PHYS_PORT_ID, ppid.id_len, ppid.id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int rtnl_phys_port_name_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tchar name[IFNAMSIZ];\n\tint err;\n\n\terr = dev_get_phys_port_name(dev, name, sizeof(name));\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (nla_put_string(skb, IFLA_PHYS_PORT_NAME, name))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int rtnl_phys_switch_id_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdev_phys_item_id ppid = { };\n\tint err;\n\n\terr = dev_get_port_parent_id(dev, &ppid, false);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tif (nla_put(skb, IFLA_PHYS_SWITCH_ID, ppid.id_len, ppid.id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int rtnl_fill_stats(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev)\n{\n\tstruct rtnl_link_stats64 *sp;\n\tstruct nlattr *attr;\n\n\tattr = nla_reserve_64bit(skb, IFLA_STATS64,\n\t\t\t\t sizeof(struct rtnl_link_stats64), IFLA_PAD);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tsp = nla_data(attr);\n\tdev_get_stats(dev, sp);\n\n\tattr = nla_reserve(skb, IFLA_STATS,\n\t\t\t   sizeof(struct rtnl_link_stats));\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tcopy_rtnl_link_stats(nla_data(attr), sp);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       int vfs_num,\n\t\t\t\t\t       struct nlattr *vfinfo)\n{\n\tstruct ifla_vf_rss_query_en vf_rss_query_en;\n\tstruct nlattr *vf, *vfstats, *vfvlanlist;\n\tstruct ifla_vf_link_state vf_linkstate;\n\tstruct ifla_vf_vlan_info vf_vlan_info;\n\tstruct ifla_vf_spoofchk vf_spoofchk;\n\tstruct ifla_vf_tx_rate vf_tx_rate;\n\tstruct ifla_vf_stats vf_stats;\n\tstruct ifla_vf_trust vf_trust;\n\tstruct ifla_vf_vlan vf_vlan;\n\tstruct ifla_vf_rate vf_rate;\n\tstruct ifla_vf_mac vf_mac;\n\tstruct ifla_vf_broadcast vf_broadcast;\n\tstruct ifla_vf_info ivi;\n\tstruct ifla_vf_guid node_guid;\n\tstruct ifla_vf_guid port_guid;\n\n\tmemset(&ivi, 0, sizeof(ivi));\n\n\t/* Not all SR-IOV capable drivers support the\n\t * spoofcheck and \"RSS query enable\" query.  Preset to\n\t * -1 so the user space tool can detect that the driver\n\t * didn't report anything.\n\t */\n\tivi.spoofchk = -1;\n\tivi.rss_query_en = -1;\n\tivi.trusted = -1;\n\t/* The default value for VF link state is \"auto\"\n\t * IFLA_VF_LINK_STATE_AUTO which equals zero\n\t */\n\tivi.linkstate = 0;\n\t/* VLAN Protocol by default is 802.1Q */\n\tivi.vlan_proto = htons(ETH_P_8021Q);\n\tif (dev->netdev_ops->ndo_get_vf_config(dev, vfs_num, &ivi))\n\t\treturn 0;\n\n\tmemset(&vf_vlan_info, 0, sizeof(vf_vlan_info));\n\tmemset(&node_guid, 0, sizeof(node_guid));\n\tmemset(&port_guid, 0, sizeof(port_guid));\n\n\tvf_mac.vf =\n\t\tvf_vlan.vf =\n\t\tvf_vlan_info.vf =\n\t\tvf_rate.vf =\n\t\tvf_tx_rate.vf =\n\t\tvf_spoofchk.vf =\n\t\tvf_linkstate.vf =\n\t\tvf_rss_query_en.vf =\n\t\tvf_trust.vf =\n\t\tnode_guid.vf =\n\t\tport_guid.vf = ivi.vf;\n\n\tmemcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));\n\tmemcpy(vf_broadcast.broadcast, dev->broadcast, dev->addr_len);\n\tvf_vlan.vlan = ivi.vlan;\n\tvf_vlan.qos = ivi.qos;\n\tvf_vlan_info.vlan = ivi.vlan;\n\tvf_vlan_info.qos = ivi.qos;\n\tvf_vlan_info.vlan_proto = ivi.vlan_proto;\n\tvf_tx_rate.rate = ivi.max_tx_rate;\n\tvf_rate.min_tx_rate = ivi.min_tx_rate;\n\tvf_rate.max_tx_rate = ivi.max_tx_rate;\n\tvf_spoofchk.setting = ivi.spoofchk;\n\tvf_linkstate.link_state = ivi.linkstate;\n\tvf_rss_query_en.setting = ivi.rss_query_en;\n\tvf_trust.setting = ivi.trusted;\n\tvf = nla_nest_start_noflag(skb, IFLA_VF_INFO);\n\tif (!vf)\n\t\tgoto nla_put_vfinfo_failure;\n\tif (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||\n\t    nla_put(skb, IFLA_VF_BROADCAST, sizeof(vf_broadcast), &vf_broadcast) ||\n\t    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||\n\t    nla_put(skb, IFLA_VF_RATE, sizeof(vf_rate),\n\t\t    &vf_rate) ||\n\t    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),\n\t\t    &vf_tx_rate) ||\n\t    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),\n\t\t    &vf_spoofchk) ||\n\t    nla_put(skb, IFLA_VF_LINK_STATE, sizeof(vf_linkstate),\n\t\t    &vf_linkstate) ||\n\t    nla_put(skb, IFLA_VF_RSS_QUERY_EN,\n\t\t    sizeof(vf_rss_query_en),\n\t\t    &vf_rss_query_en) ||\n\t    nla_put(skb, IFLA_VF_TRUST,\n\t\t    sizeof(vf_trust), &vf_trust))\n\t\tgoto nla_put_vf_failure;\n\n\tif (dev->netdev_ops->ndo_get_vf_guid &&\n\t    !dev->netdev_ops->ndo_get_vf_guid(dev, vfs_num, &node_guid,\n\t\t\t\t\t      &port_guid)) {\n\t\tif (nla_put(skb, IFLA_VF_IB_NODE_GUID, sizeof(node_guid),\n\t\t\t    &node_guid) ||\n\t\t    nla_put(skb, IFLA_VF_IB_PORT_GUID, sizeof(port_guid),\n\t\t\t    &port_guid))\n\t\t\tgoto nla_put_vf_failure;\n\t}\n\tvfvlanlist = nla_nest_start_noflag(skb, IFLA_VF_VLAN_LIST);\n\tif (!vfvlanlist)\n\t\tgoto nla_put_vf_failure;\n\tif (nla_put(skb, IFLA_VF_VLAN_INFO, sizeof(vf_vlan_info),\n\t\t    &vf_vlan_info)) {\n\t\tnla_nest_cancel(skb, vfvlanlist);\n\t\tgoto nla_put_vf_failure;\n\t}\n\tnla_nest_end(skb, vfvlanlist);\n\tmemset(&vf_stats, 0, sizeof(vf_stats));\n\tif (dev->netdev_ops->ndo_get_vf_stats)\n\t\tdev->netdev_ops->ndo_get_vf_stats(dev, vfs_num,\n\t\t\t\t\t\t&vf_stats);\n\tvfstats = nla_nest_start_noflag(skb, IFLA_VF_STATS);\n\tif (!vfstats)\n\t\tgoto nla_put_vf_failure;\n\tif (nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_PACKETS,\n\t\t\t      vf_stats.rx_packets, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_PACKETS,\n\t\t\t      vf_stats.tx_packets, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_BYTES,\n\t\t\t      vf_stats.rx_bytes, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_BYTES,\n\t\t\t      vf_stats.tx_bytes, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_BROADCAST,\n\t\t\t      vf_stats.broadcast, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_MULTICAST,\n\t\t\t      vf_stats.multicast, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_RX_DROPPED,\n\t\t\t      vf_stats.rx_dropped, IFLA_VF_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, IFLA_VF_STATS_TX_DROPPED,\n\t\t\t      vf_stats.tx_dropped, IFLA_VF_STATS_PAD)) {\n\t\tnla_nest_cancel(skb, vfstats);\n\t\tgoto nla_put_vf_failure;\n\t}\n\tnla_nest_end(skb, vfstats);\n\tnla_nest_end(skb, vf);\n\treturn 0;\n\nnla_put_vf_failure:\n\tnla_nest_cancel(skb, vf);\nnla_put_vfinfo_failure:\n\tnla_nest_cancel(skb, vfinfo);\n\treturn -EMSGSIZE;\n}\n\nstatic noinline_for_stack int rtnl_fill_vf(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   u32 ext_filter_mask)\n{\n\tstruct nlattr *vfinfo;\n\tint i, num_vfs;\n\n\tif (!dev->dev.parent || ((ext_filter_mask & RTEXT_FILTER_VF) == 0))\n\t\treturn 0;\n\n\tnum_vfs = dev_num_vf(dev->dev.parent);\n\tif (nla_put_u32(skb, IFLA_NUM_VF, num_vfs))\n\t\treturn -EMSGSIZE;\n\n\tif (!dev->netdev_ops->ndo_get_vf_config)\n\t\treturn 0;\n\n\tvfinfo = nla_nest_start_noflag(skb, IFLA_VFINFO_LIST);\n\tif (!vfinfo)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < num_vfs; i++) {\n\t\tif (rtnl_fill_vfinfo(skb, dev, i, vfinfo))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, vfinfo);\n\treturn 0;\n}\n\nstatic int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map;\n\n\tmemset(&map, 0, sizeof(map));\n\tmap.mem_start   = dev->mem_start;\n\tmap.mem_end     = dev->mem_end;\n\tmap.base_addr   = dev->base_addr;\n\tmap.irq         = dev->irq;\n\tmap.dma         = dev->dma;\n\tmap.port        = dev->if_port;\n\n\tif (nla_put_64bit(skb, IFLA_MAP, sizeof(map), &map, IFLA_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic u32 rtnl_xdp_prog_skb(struct net_device *dev)\n{\n\tconst struct bpf_prog *generic_xdp_prog;\n\n\tASSERT_RTNL();\n\n\tgeneric_xdp_prog = rtnl_dereference(dev->xdp_prog);\n\tif (!generic_xdp_prog)\n\t\treturn 0;\n\treturn generic_xdp_prog->aux->id;\n}\n\nstatic u32 rtnl_xdp_prog_drv(struct net_device *dev)\n{\n\treturn dev_xdp_prog_id(dev, XDP_MODE_DRV);\n}\n\nstatic u32 rtnl_xdp_prog_hw(struct net_device *dev)\n{\n\treturn dev_xdp_prog_id(dev, XDP_MODE_HW);\n}\n\nstatic int rtnl_xdp_report_one(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       u32 *prog_id, u8 *mode, u8 tgt_mode, u32 attr,\n\t\t\t       u32 (*get_prog_id)(struct net_device *dev))\n{\n\tu32 curr_id;\n\tint err;\n\n\tcurr_id = get_prog_id(dev);\n\tif (!curr_id)\n\t\treturn 0;\n\n\t*prog_id = curr_id;\n\terr = nla_put_u32(skb, attr, curr_id);\n\tif (err)\n\t\treturn err;\n\n\tif (*mode != XDP_ATTACHED_NONE)\n\t\t*mode = XDP_ATTACHED_MULTI;\n\telse\n\t\t*mode = tgt_mode;\n\n\treturn 0;\n}\n\nstatic int rtnl_xdp_fill(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct nlattr *xdp;\n\tu32 prog_id;\n\tint err;\n\tu8 mode;\n\n\txdp = nla_nest_start_noflag(skb, IFLA_XDP);\n\tif (!xdp)\n\t\treturn -EMSGSIZE;\n\n\tprog_id = 0;\n\tmode = XDP_ATTACHED_NONE;\n\terr = rtnl_xdp_report_one(skb, dev, &prog_id, &mode, XDP_ATTACHED_SKB,\n\t\t\t\t  IFLA_XDP_SKB_PROG_ID, rtnl_xdp_prog_skb);\n\tif (err)\n\t\tgoto err_cancel;\n\terr = rtnl_xdp_report_one(skb, dev, &prog_id, &mode, XDP_ATTACHED_DRV,\n\t\t\t\t  IFLA_XDP_DRV_PROG_ID, rtnl_xdp_prog_drv);\n\tif (err)\n\t\tgoto err_cancel;\n\terr = rtnl_xdp_report_one(skb, dev, &prog_id, &mode, XDP_ATTACHED_HW,\n\t\t\t\t  IFLA_XDP_HW_PROG_ID, rtnl_xdp_prog_hw);\n\tif (err)\n\t\tgoto err_cancel;\n\n\terr = nla_put_u8(skb, IFLA_XDP_ATTACHED, mode);\n\tif (err)\n\t\tgoto err_cancel;\n\n\tif (prog_id && mode != XDP_ATTACHED_MULTI) {\n\t\terr = nla_put_u32(skb, IFLA_XDP_PROG_ID, prog_id);\n\t\tif (err)\n\t\t\tgoto err_cancel;\n\t}\n\n\tnla_nest_end(skb, xdp);\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, xdp);\n\treturn err;\n}\n\nstatic u32 rtnl_get_event(unsigned long event)\n{\n\tu32 rtnl_event_type = IFLA_EVENT_NONE;\n\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\t\trtnl_event_type = IFLA_EVENT_REBOOT;\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\trtnl_event_type = IFLA_EVENT_FEATURES;\n\t\tbreak;\n\tcase NETDEV_BONDING_FAILOVER:\n\t\trtnl_event_type = IFLA_EVENT_BONDING_FAILOVER;\n\t\tbreak;\n\tcase NETDEV_NOTIFY_PEERS:\n\t\trtnl_event_type = IFLA_EVENT_NOTIFY_PEERS;\n\t\tbreak;\n\tcase NETDEV_RESEND_IGMP:\n\t\trtnl_event_type = IFLA_EVENT_IGMP_RESEND;\n\t\tbreak;\n\tcase NETDEV_CHANGEINFODATA:\n\t\trtnl_event_type = IFLA_EVENT_BONDING_OPTIONS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rtnl_event_type;\n}\n\nstatic int put_master_ifindex(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct net_device *upper_dev;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\tupper_dev = netdev_master_upper_dev_get_rcu(dev);\n\tif (upper_dev)\n\t\tret = nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex);\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int nla_put_iflink(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t  bool force)\n{\n\tint ifindex = dev_get_iflink(dev);\n\n\tif (force || dev->ifindex != ifindex)\n\t\treturn nla_put_u32(skb, IFLA_LINK, ifindex);\n\n\treturn 0;\n}\n\nstatic noinline_for_stack int nla_put_ifalias(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev)\n{\n\tchar buf[IFALIASZ];\n\tint ret;\n\n\tret = dev_get_alias(dev, buf, sizeof(buf));\n\treturn ret > 0 ? nla_put_string(skb, IFLA_IFALIAS, buf) : 0;\n}\n\nstatic int rtnl_fill_link_netnsid(struct sk_buff *skb,\n\t\t\t\t  const struct net_device *dev,\n\t\t\t\t  struct net *src_net, gfp_t gfp)\n{\n\tbool put_iflink = false;\n\n\tif (dev->rtnl_link_ops && dev->rtnl_link_ops->get_link_net) {\n\t\tstruct net *link_net = dev->rtnl_link_ops->get_link_net(dev);\n\n\t\tif (!net_eq(dev_net(dev), link_net)) {\n\t\t\tint id = peernet2id_alloc(src_net, link_net, gfp);\n\n\t\t\tif (nla_put_s32(skb, IFLA_LINK_NETNSID, id))\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\tput_iflink = true;\n\t\t}\n\t}\n\n\treturn nla_put_iflink(skb, dev, put_iflink);\n}\n\nstatic int rtnl_fill_link_af(struct sk_buff *skb,\n\t\t\t     const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tconst struct rtnl_af_ops *af_ops;\n\tstruct nlattr *af_spec;\n\n\taf_spec = nla_nest_start_noflag(skb, IFLA_AF_SPEC);\n\tif (!af_spec)\n\t\treturn -EMSGSIZE;\n\n\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\tstruct nlattr *af;\n\t\tint err;\n\n\t\tif (!af_ops->fill_link_af)\n\t\t\tcontinue;\n\n\t\taf = nla_nest_start_noflag(skb, af_ops->family);\n\t\tif (!af)\n\t\t\treturn -EMSGSIZE;\n\n\t\terr = af_ops->fill_link_af(skb, dev, ext_filter_mask);\n\t\t/*\n\t\t * Caller may return ENODATA to indicate that there\n\t\t * was no data to be dumped. This is not an error, it\n\t\t * means we should trim the attribute header and\n\t\t * continue.\n\t\t */\n\t\tif (err == -ENODATA)\n\t\t\tnla_nest_cancel(skb, af);\n\t\telse if (err < 0)\n\t\t\treturn -EMSGSIZE;\n\n\t\tnla_nest_end(skb, af);\n\t}\n\n\tnla_nest_end(skb, af_spec);\n\treturn 0;\n}\n\nstatic int rtnl_fill_alt_ifnames(struct sk_buff *skb,\n\t\t\t\t const struct net_device *dev)\n{\n\tstruct netdev_name_node *name_node;\n\tint count = 0;\n\n\tlist_for_each_entry(name_node, &dev->name_node->list, list) {\n\t\tif (nla_put_string(skb, IFLA_ALT_IFNAME, name_node->name))\n\t\t\treturn -EMSGSIZE;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nstatic int rtnl_fill_prop_list(struct sk_buff *skb,\n\t\t\t       const struct net_device *dev)\n{\n\tstruct nlattr *prop_list;\n\tint ret;\n\n\tprop_list = nla_nest_start(skb, IFLA_PROP_LIST);\n\tif (!prop_list)\n\t\treturn -EMSGSIZE;\n\n\tret = rtnl_fill_alt_ifnames(skb, dev);\n\tif (ret <= 0)\n\t\tgoto nest_cancel;\n\n\tnla_nest_end(skb, prop_list);\n\treturn 0;\n\nnest_cancel:\n\tnla_nest_cancel(skb, prop_list);\n\treturn ret;\n}\n\nstatic int rtnl_fill_proto_down(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev)\n{\n\tstruct nlattr *pr;\n\tu32 preason;\n\n\tif (nla_put_u8(skb, IFLA_PROTO_DOWN, dev->proto_down))\n\t\tgoto nla_put_failure;\n\n\tpreason = dev->proto_down_reason;\n\tif (!preason)\n\t\treturn 0;\n\n\tpr = nla_nest_start(skb, IFLA_PROTO_DOWN_REASON);\n\tif (!pr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, IFLA_PROTO_DOWN_REASON_VALUE, preason)) {\n\t\tnla_nest_cancel(skb, pr);\n\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, pr);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int rtnl_fill_ifinfo(struct sk_buff *skb,\n\t\t\t    struct net_device *dev, struct net *src_net,\n\t\t\t    int type, u32 pid, u32 seq, u32 change,\n\t\t\t    unsigned int flags, u32 ext_filter_mask,\n\t\t\t    u32 event, int *new_nsid, int new_ifindex,\n\t\t\t    int tgt_netnsid, gfp_t gfp)\n{\n\tstruct ifinfomsg *ifm;\n\tstruct nlmsghdr *nlh;\n\n\tASSERT_RTNL();\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_UNSPEC;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = change;\n\n\tif (tgt_netnsid >= 0 && nla_put_s32(skb, IFLA_TARGET_NETNSID, tgt_netnsid))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_TXQLEN, dev->tx_queue_len) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE,\n\t\t       netif_running(dev) ? dev->operstate : IF_OPER_DOWN) ||\n\t    nla_put_u8(skb, IFLA_LINKMODE, dev->link_mode) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u32(skb, IFLA_MIN_MTU, dev->min_mtu) ||\n\t    nla_put_u32(skb, IFLA_MAX_MTU, dev->max_mtu) ||\n\t    nla_put_u32(skb, IFLA_GROUP, dev->group) ||\n\t    nla_put_u32(skb, IFLA_PROMISCUITY, dev->promiscuity) ||\n\t    nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||\n\t    nla_put_u32(skb, IFLA_GSO_MAX_SEGS, dev->gso_max_segs) ||\n\t    nla_put_u32(skb, IFLA_GSO_MAX_SIZE, dev->gso_max_size) ||\n#ifdef CONFIG_RPS\n\t    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||\n#endif\n\t    put_master_ifindex(skb, dev) ||\n\t    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||\n\t    (dev->qdisc &&\n\t     nla_put_string(skb, IFLA_QDISC, dev->qdisc->ops->id)) ||\n\t    nla_put_ifalias(skb, dev) ||\n\t    nla_put_u32(skb, IFLA_CARRIER_CHANGES,\n\t\t\tatomic_read(&dev->carrier_up_count) +\n\t\t\tatomic_read(&dev->carrier_down_count)) ||\n\t    nla_put_u32(skb, IFLA_CARRIER_UP_COUNT,\n\t\t\tatomic_read(&dev->carrier_up_count)) ||\n\t    nla_put_u32(skb, IFLA_CARRIER_DOWN_COUNT,\n\t\t\tatomic_read(&dev->carrier_down_count)))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_proto_down(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (event != IFLA_EVENT_NONE) {\n\t\tif (nla_put_u32(skb, IFLA_EVENT, event))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_fill_link_ifmap(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->addr_len) {\n\t\tif (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||\n\t\t    nla_put(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_phys_port_id_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_phys_port_name_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_phys_switch_id_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_stats(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_fill_vf(skb, dev, ext_filter_mask))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_port_fill(skb, dev, ext_filter_mask))\n\t\tgoto nla_put_failure;\n\n\tif (rtnl_xdp_fill(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tif (dev->rtnl_link_ops || rtnl_have_link_slave_info(dev)) {\n\t\tif (rtnl_link_fill(skb, dev) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rtnl_fill_link_netnsid(skb, dev, src_net, gfp))\n\t\tgoto nla_put_failure;\n\n\tif (new_nsid &&\n\t    nla_put_s32(skb, IFLA_NEW_NETNSID, *new_nsid) < 0)\n\t\tgoto nla_put_failure;\n\tif (new_ifindex &&\n\t    nla_put_s32(skb, IFLA_NEW_IFINDEX, new_ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (memchr_inv(dev->perm_addr, '\\0', dev->addr_len) &&\n\t    nla_put(skb, IFLA_PERM_ADDRESS, dev->addr_len, dev->perm_addr))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\tif (rtnl_fill_link_af(skb, dev, ext_filter_mask))\n\t\tgoto nla_put_failure_rcu;\n\trcu_read_unlock();\n\n\tif (rtnl_fill_prop_list(skb, dev))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ifla_policy[IFLA_MAX+1] = {\n\t[IFLA_IFNAME]\t\t= { .type = NLA_STRING, .len = IFNAMSIZ-1 },\n\t[IFLA_ADDRESS]\t\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_BROADCAST]\t= { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_MAP]\t\t= { .len = sizeof(struct rtnl_link_ifmap) },\n\t[IFLA_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_MASTER]\t\t= { .type = NLA_U32 },\n\t[IFLA_CARRIER]\t\t= { .type = NLA_U8 },\n\t[IFLA_TXQLEN]\t\t= { .type = NLA_U32 },\n\t[IFLA_WEIGHT]\t\t= { .type = NLA_U32 },\n\t[IFLA_OPERSTATE]\t= { .type = NLA_U8 },\n\t[IFLA_LINKMODE]\t\t= { .type = NLA_U8 },\n\t[IFLA_LINKINFO]\t\t= { .type = NLA_NESTED },\n\t[IFLA_NET_NS_PID]\t= { .type = NLA_U32 },\n\t[IFLA_NET_NS_FD]\t= { .type = NLA_U32 },\n\t/* IFLA_IFALIAS is a string, but policy is set to NLA_BINARY to\n\t * allow 0-length string (needed to remove an alias).\n\t */\n\t[IFLA_IFALIAS]\t        = { .type = NLA_BINARY, .len = IFALIASZ - 1 },\n\t[IFLA_VFINFO_LIST]\t= {. type = NLA_NESTED },\n\t[IFLA_VF_PORTS]\t\t= { .type = NLA_NESTED },\n\t[IFLA_PORT_SELF]\t= { .type = NLA_NESTED },\n\t[IFLA_AF_SPEC]\t\t= { .type = NLA_NESTED },\n\t[IFLA_EXT_MASK]\t\t= { .type = NLA_U32 },\n\t[IFLA_PROMISCUITY]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_TX_QUEUES]\t= { .type = NLA_U32 },\n\t[IFLA_NUM_RX_QUEUES]\t= { .type = NLA_U32 },\n\t[IFLA_GSO_MAX_SEGS]\t= { .type = NLA_U32 },\n\t[IFLA_GSO_MAX_SIZE]\t= { .type = NLA_U32 },\n\t[IFLA_PHYS_PORT_ID]\t= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },\n\t[IFLA_CARRIER_CHANGES]\t= { .type = NLA_U32 },  /* ignored */\n\t[IFLA_PHYS_SWITCH_ID]\t= { .type = NLA_BINARY, .len = MAX_PHYS_ITEM_ID_LEN },\n\t[IFLA_LINK_NETNSID]\t= { .type = NLA_S32 },\n\t[IFLA_PROTO_DOWN]\t= { .type = NLA_U8 },\n\t[IFLA_XDP]\t\t= { .type = NLA_NESTED },\n\t[IFLA_EVENT]\t\t= { .type = NLA_U32 },\n\t[IFLA_GROUP]\t\t= { .type = NLA_U32 },\n\t[IFLA_TARGET_NETNSID]\t= { .type = NLA_S32 },\n\t[IFLA_CARRIER_UP_COUNT]\t= { .type = NLA_U32 },\n\t[IFLA_CARRIER_DOWN_COUNT] = { .type = NLA_U32 },\n\t[IFLA_MIN_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_MAX_MTU]\t\t= { .type = NLA_U32 },\n\t[IFLA_PROP_LIST]\t= { .type = NLA_NESTED },\n\t[IFLA_ALT_IFNAME]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = ALTIFNAMSIZ - 1 },\n\t[IFLA_PERM_ADDRESS]\t= { .type = NLA_REJECT },\n\t[IFLA_PROTO_DOWN_REASON] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {\n\t[IFLA_INFO_KIND]\t= { .type = NLA_STRING },\n\t[IFLA_INFO_DATA]\t= { .type = NLA_NESTED },\n\t[IFLA_INFO_SLAVE_KIND]\t= { .type = NLA_STRING },\n\t[IFLA_INFO_SLAVE_DATA]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {\n\t[IFLA_VF_MAC]\t\t= { .len = sizeof(struct ifla_vf_mac) },\n\t[IFLA_VF_BROADCAST]\t= { .type = NLA_REJECT },\n\t[IFLA_VF_VLAN]\t\t= { .len = sizeof(struct ifla_vf_vlan) },\n\t[IFLA_VF_VLAN_LIST]     = { .type = NLA_NESTED },\n\t[IFLA_VF_TX_RATE]\t= { .len = sizeof(struct ifla_vf_tx_rate) },\n\t[IFLA_VF_SPOOFCHK]\t= { .len = sizeof(struct ifla_vf_spoofchk) },\n\t[IFLA_VF_RATE]\t\t= { .len = sizeof(struct ifla_vf_rate) },\n\t[IFLA_VF_LINK_STATE]\t= { .len = sizeof(struct ifla_vf_link_state) },\n\t[IFLA_VF_RSS_QUERY_EN]\t= { .len = sizeof(struct ifla_vf_rss_query_en) },\n\t[IFLA_VF_STATS]\t\t= { .type = NLA_NESTED },\n\t[IFLA_VF_TRUST]\t\t= { .len = sizeof(struct ifla_vf_trust) },\n\t[IFLA_VF_IB_NODE_GUID]\t= { .len = sizeof(struct ifla_vf_guid) },\n\t[IFLA_VF_IB_PORT_GUID]\t= { .len = sizeof(struct ifla_vf_guid) },\n};\n\nstatic const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {\n\t[IFLA_PORT_VF]\t\t= { .type = NLA_U32 },\n\t[IFLA_PORT_PROFILE]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_PROFILE_MAX },\n\t[IFLA_PORT_INSTANCE_UUID] = { .type = NLA_BINARY,\n\t\t\t\t      .len = PORT_UUID_MAX },\n\t[IFLA_PORT_HOST_UUID]\t= { .type = NLA_STRING,\n\t\t\t\t    .len = PORT_UUID_MAX },\n\t[IFLA_PORT_REQUEST]\t= { .type = NLA_U8, },\n\t[IFLA_PORT_RESPONSE]\t= { .type = NLA_U16, },\n\n\t/* Unused, but we need to keep it here since user space could\n\t * fill it. It's also broken with regard to NLA_BINARY use in\n\t * combination with structs.\n\t */\n\t[IFLA_PORT_VSI_TYPE]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct ifla_port_vsi) },\n};\n\nstatic const struct nla_policy ifla_xdp_policy[IFLA_XDP_MAX + 1] = {\n\t[IFLA_XDP_UNSPEC]\t= { .strict_start_type = IFLA_XDP_EXPECTED_FD },\n\t[IFLA_XDP_FD]\t\t= { .type = NLA_S32 },\n\t[IFLA_XDP_EXPECTED_FD]\t= { .type = NLA_S32 },\n\t[IFLA_XDP_ATTACHED]\t= { .type = NLA_U8 },\n\t[IFLA_XDP_FLAGS]\t= { .type = NLA_U32 },\n\t[IFLA_XDP_PROG_ID]\t= { .type = NLA_U32 },\n};\n\nstatic const struct rtnl_link_ops *linkinfo_to_kind_ops(const struct nlattr *nla)\n{\n\tconst struct rtnl_link_ops *ops = NULL;\n\tstruct nlattr *linfo[IFLA_INFO_MAX + 1];\n\n\tif (nla_parse_nested_deprecated(linfo, IFLA_INFO_MAX, nla, ifla_info_policy, NULL) < 0)\n\t\treturn NULL;\n\n\tif (linfo[IFLA_INFO_KIND]) {\n\t\tchar kind[MODULE_NAME_LEN];\n\n\t\tnla_strscpy(kind, linfo[IFLA_INFO_KIND], sizeof(kind));\n\t\tops = rtnl_link_ops_get(kind);\n\t}\n\n\treturn ops;\n}\n\nstatic bool link_master_filtered(struct net_device *dev, int master_idx)\n{\n\tstruct net_device *master;\n\n\tif (!master_idx)\n\t\treturn false;\n\n\tmaster = netdev_master_upper_dev_get(dev);\n\tif (!master || master->ifindex != master_idx)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool link_kind_filtered(const struct net_device *dev,\n\t\t\t       const struct rtnl_link_ops *kind_ops)\n{\n\tif (kind_ops && dev->rtnl_link_ops != kind_ops)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool link_dump_filtered(struct net_device *dev,\n\t\t\t       int master_idx,\n\t\t\t       const struct rtnl_link_ops *kind_ops)\n{\n\tif (link_master_filtered(dev, master_idx) ||\n\t    link_kind_filtered(dev, kind_ops))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * rtnl_get_net_ns_capable - Get netns if sufficiently privileged.\n * @sk: netlink socket\n * @netnsid: network namespace identifier\n *\n * Returns the network namespace identified by netnsid on success or an error\n * pointer on failure.\n */\nstruct net *rtnl_get_net_ns_capable(struct sock *sk, int netnsid)\n{\n\tstruct net *net;\n\n\tnet = get_net_ns_by_id(sock_net(sk), netnsid);\n\tif (!net)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* For now, the caller is required to have CAP_NET_ADMIN in\n\t * the user namespace owning the target net ns.\n\t */\n\tif (!sk_ns_capable(sk, net->user_ns, CAP_NET_ADMIN)) {\n\t\tput_net(net);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\treturn net;\n}\nEXPORT_SYMBOL_GPL(rtnl_get_net_ns_capable);\n\nstatic int rtnl_valid_dump_ifinfo_req(const struct nlmsghdr *nlh,\n\t\t\t\t      bool strict_check, struct nlattr **tb,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint hdrlen;\n\n\tif (strict_check) {\n\t\tstruct ifinfomsg *ifm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid header for link dump\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tifm = nlmsg_data(nlh);\n\t\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t\t    ifm->ifi_change) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for link dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ifm->ifi_index) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter by device index not supported for link dumps\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb,\n\t\t\t\t\t\t     IFLA_MAX, ifla_policy,\n\t\t\t\t\t\t     extack);\n\t}\n\n\t/* A hack to preserve kernel<->userspace interface.\n\t * The correct header is ifinfomsg. It is consistent with rtnl_getlink.\n\t * However, before Linux v3.9 the code here assumed rtgenmsg and that's\n\t * what iproute2 < v3.9.0 used.\n\t * We can detect the old iproute2. Even including the IFLA_EXT_MASK\n\t * attribute, its netlink message is shorter than struct ifinfomsg.\n\t */\n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\treturn nlmsg_parse_deprecated(nlh, hdrlen, tb, IFLA_MAX, ifla_policy,\n\t\t\t\t      extack);\n}\n\nstatic int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tstruct net_device *dev;\n\tstruct hlist_head *head;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tconst struct rtnl_link_ops *kind_ops = NULL;\n\tunsigned int flags = NLM_F_MULTI;\n\tint master_idx = 0;\n\tint netnsid = -1;\n\tint err, i;\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\terr = rtnl_valid_dump_ifinfo_req(nlh, cb->strict_check, tb, extack);\n\tif (err < 0) {\n\t\tif (cb->strict_check)\n\t\t\treturn err;\n\n\t\tgoto walk_entries;\n\t}\n\n\tfor (i = 0; i <= IFLA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\t/* new attributes should only be added with strict checking */\n\t\tswitch (i) {\n\t\tcase IFLA_TARGET_NETNSID:\n\t\t\tnetnsid = nla_get_s32(tb[i]);\n\t\t\ttgt_net = rtnl_get_net_ns_capable(skb->sk, netnsid);\n\t\t\tif (IS_ERR(tgt_net)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid target network namespace id\");\n\t\t\t\treturn PTR_ERR(tgt_net);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IFLA_EXT_MASK:\n\t\t\text_filter_mask = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase IFLA_MASTER:\n\t\t\tmaster_idx = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase IFLA_LINKINFO:\n\t\t\tkind_ops = linkinfo_to_kind_ops(tb[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (cb->strict_check) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in link dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (master_idx || kind_ops)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\nwalk_entries:\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &tgt_net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\t\t\tif (link_dump_filtered(dev, master_idx, kind_ops))\n\t\t\t\tgoto cont;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\terr = rtnl_fill_ifinfo(skb, dev, net,\n\t\t\t\t\t       RTM_NEWLINK,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       nlh->nlmsg_seq, 0, flags,\n\t\t\t\t\t       ext_filter_mask, 0, NULL, 0,\n\t\t\t\t\t       netnsid, GFP_KERNEL);\n\n\t\t\tif (err < 0) {\n\t\t\t\tif (likely(skb->len))\n\t\t\t\t\tgoto out;\n\n\t\t\t\tgoto out_err;\n\t\t\t}\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\terr = skb->len;\nout_err:\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\tcb->seq = tgt_net->dev_base_seq;\n\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nint rtnl_nla_parse_ifla(struct nlattr **tb, const struct nlattr *head, int len,\n\t\t\tstruct netlink_ext_ack *exterr)\n{\n\treturn nla_parse_deprecated(tb, IFLA_MAX, head, len, ifla_policy,\n\t\t\t\t    exterr);\n}\nEXPORT_SYMBOL(rtnl_nla_parse_ifla);\n\nstruct net *rtnl_link_get_net(struct net *src_net, struct nlattr *tb[])\n{\n\tstruct net *net;\n\t/* Examine the link attributes and figure out which\n\t * network namespace we are talking about.\n\t */\n\tif (tb[IFLA_NET_NS_PID])\n\t\tnet = get_net_ns_by_pid(nla_get_u32(tb[IFLA_NET_NS_PID]));\n\telse if (tb[IFLA_NET_NS_FD])\n\t\tnet = get_net_ns_by_fd(nla_get_u32(tb[IFLA_NET_NS_FD]));\n\telse\n\t\tnet = get_net(src_net);\n\treturn net;\n}\nEXPORT_SYMBOL(rtnl_link_get_net);\n\n/* Figure out which network namespace we are talking about by\n * examining the link attributes in the following order:\n *\n * 1. IFLA_NET_NS_PID\n * 2. IFLA_NET_NS_FD\n * 3. IFLA_TARGET_NETNSID\n */\nstatic struct net *rtnl_link_get_net_by_nlattr(struct net *src_net,\n\t\t\t\t\t       struct nlattr *tb[])\n{\n\tstruct net *net;\n\n\tif (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD])\n\t\treturn rtnl_link_get_net(src_net, tb);\n\n\tif (!tb[IFLA_TARGET_NETNSID])\n\t\treturn get_net(src_net);\n\n\tnet = get_net_ns_by_id(src_net, nla_get_u32(tb[IFLA_TARGET_NETNSID]));\n\tif (!net)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn net;\n}\n\nstatic struct net *rtnl_link_get_net_capable(const struct sk_buff *skb,\n\t\t\t\t\t     struct net *src_net,\n\t\t\t\t\t     struct nlattr *tb[], int cap)\n{\n\tstruct net *net;\n\n\tnet = rtnl_link_get_net_by_nlattr(src_net, tb);\n\tif (IS_ERR(net))\n\t\treturn net;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, cap)) {\n\t\tput_net(net);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\treturn net;\n}\n\n/* Verify that rtnetlink requests do not pass additional properties\n * potentially referring to different network namespaces.\n */\nstatic int rtnl_ensure_unique_netns(struct nlattr *tb[],\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    bool netns_id_only)\n{\n\n\tif (netns_id_only) {\n\t\tif (!tb[IFLA_NET_NS_PID] && !tb[IFLA_NET_NS_FD])\n\t\t\treturn 0;\n\n\t\tNL_SET_ERR_MSG(extack, \"specified netns attribute not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (tb[IFLA_TARGET_NETNSID] && (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD]))\n\t\tgoto invalid_attr;\n\n\tif (tb[IFLA_NET_NS_PID] && (tb[IFLA_TARGET_NETNSID] || tb[IFLA_NET_NS_FD]))\n\t\tgoto invalid_attr;\n\n\tif (tb[IFLA_NET_NS_FD] && (tb[IFLA_TARGET_NETNSID] || tb[IFLA_NET_NS_PID]))\n\t\tgoto invalid_attr;\n\n\treturn 0;\n\ninvalid_attr:\n\tNL_SET_ERR_MSG(extack, \"multiple netns identifying attributes specified\");\n\treturn -EINVAL;\n}\n\nstatic int validate_linkmsg(struct net_device *dev, struct nlattr *tb[])\n{\n\tif (dev) {\n\t\tif (tb[IFLA_ADDRESS] &&\n\t\t    nla_len(tb[IFLA_ADDRESS]) < dev->addr_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[IFLA_BROADCAST] &&\n\t\t    nla_len(tb[IFLA_BROADCAST]) < dev->addr_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem, err;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\trcu_read_lock();\n\t\t\taf_ops = rtnl_af_lookup(nla_type(af));\n\t\t\tif (!af_ops) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\n\t\t\tif (!af_ops->set_link_af) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tif (af_ops->validate_link_af) {\n\t\t\t\terr = af_ops->validate_link_af(dev, af);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int handle_infiniband_guid(struct net_device *dev, struct ifla_vf_guid *ivt,\n\t\t\t\t  int guid_type)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\treturn ops->ndo_set_vf_guid(dev, ivt->vf, ivt->guid, guid_type);\n}\n\nstatic int handle_vf_guid(struct net_device *dev, struct ifla_vf_guid *ivt, int guid_type)\n{\n\tif (dev->type != ARPHRD_INFINIBAND)\n\t\treturn -EOPNOTSUPP;\n\n\treturn handle_infiniband_guid(dev, ivt, guid_type);\n}\n\nstatic int do_setvfinfo(struct net_device *dev, struct nlattr **tb)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint err = -EINVAL;\n\n\tif (tb[IFLA_VF_MAC]) {\n\t\tstruct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);\n\n\t\tif (ivm->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_mac)\n\t\t\terr = ops->ndo_set_vf_mac(dev, ivm->vf,\n\t\t\t\t\t\t  ivm->mac);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_VLAN]) {\n\t\tstruct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);\n\n\t\tif (ivv->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_vlan)\n\t\t\terr = ops->ndo_set_vf_vlan(dev, ivv->vf, ivv->vlan,\n\t\t\t\t\t\t   ivv->qos,\n\t\t\t\t\t\t   htons(ETH_P_8021Q));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_VLAN_LIST]) {\n\t\tstruct ifla_vf_vlan_info *ivvl[MAX_VLAN_LIST_LEN];\n\t\tstruct nlattr *attr;\n\t\tint rem, len = 0;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (!ops->ndo_set_vf_vlan)\n\t\t\treturn err;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VF_VLAN_LIST], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_VLAN_INFO ||\n\t\t\t    nla_len(attr) < NLA_HDRLEN) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (len >= MAX_VLAN_LIST_LEN)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tivvl[len] = nla_data(attr);\n\n\t\t\tlen++;\n\t\t}\n\t\tif (len == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (ivvl[0]->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = ops->ndo_set_vf_vlan(dev, ivvl[0]->vf, ivvl[0]->vlan,\n\t\t\t\t\t   ivvl[0]->qos, ivvl[0]->vlan_proto);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_TX_RATE]) {\n\t\tstruct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);\n\t\tstruct ifla_vf_info ivf;\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_get_vf_config)\n\t\t\terr = ops->ndo_get_vf_config(dev, ivt->vf, &ivf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_rate)\n\t\t\terr = ops->ndo_set_vf_rate(dev, ivt->vf,\n\t\t\t\t\t\t   ivf.min_tx_rate,\n\t\t\t\t\t\t   ivt->rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_RATE]) {\n\t\tstruct ifla_vf_rate *ivt = nla_data(tb[IFLA_VF_RATE]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_rate)\n\t\t\terr = ops->ndo_set_vf_rate(dev, ivt->vf,\n\t\t\t\t\t\t   ivt->min_tx_rate,\n\t\t\t\t\t\t   ivt->max_tx_rate);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_SPOOFCHK]) {\n\t\tstruct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);\n\n\t\tif (ivs->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_spoofchk)\n\t\t\terr = ops->ndo_set_vf_spoofchk(dev, ivs->vf,\n\t\t\t\t\t\t       ivs->setting);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_LINK_STATE]) {\n\t\tstruct ifla_vf_link_state *ivl = nla_data(tb[IFLA_VF_LINK_STATE]);\n\n\t\tif (ivl->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_link_state)\n\t\t\terr = ops->ndo_set_vf_link_state(dev, ivl->vf,\n\t\t\t\t\t\t\t ivl->link_state);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_RSS_QUERY_EN]) {\n\t\tstruct ifla_vf_rss_query_en *ivrssq_en;\n\n\t\terr = -EOPNOTSUPP;\n\t\tivrssq_en = nla_data(tb[IFLA_VF_RSS_QUERY_EN]);\n\t\tif (ivrssq_en->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (ops->ndo_set_vf_rss_query_en)\n\t\t\terr = ops->ndo_set_vf_rss_query_en(dev, ivrssq_en->vf,\n\t\t\t\t\t\t\t   ivrssq_en->setting);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_TRUST]) {\n\t\tstruct ifla_vf_trust *ivt = nla_data(tb[IFLA_VF_TRUST]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_trust)\n\t\t\terr = ops->ndo_set_vf_trust(dev, ivt->vf, ivt->setting);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_VF_IB_NODE_GUID]) {\n\t\tstruct ifla_vf_guid *ivt = nla_data(tb[IFLA_VF_IB_NODE_GUID]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (!ops->ndo_set_vf_guid)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn handle_vf_guid(dev, ivt, IFLA_VF_IB_NODE_GUID);\n\t}\n\n\tif (tb[IFLA_VF_IB_PORT_GUID]) {\n\t\tstruct ifla_vf_guid *ivt = nla_data(tb[IFLA_VF_IB_PORT_GUID]);\n\n\t\tif (ivt->vf >= INT_MAX)\n\t\t\treturn -EINVAL;\n\t\tif (!ops->ndo_set_vf_guid)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn handle_vf_guid(dev, ivt, IFLA_VF_IB_PORT_GUID);\n\t}\n\n\treturn err;\n}\n\nstatic int do_set_master(struct net_device *dev, int ifindex,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *upper_dev = netdev_master_upper_dev_get(dev);\n\tconst struct net_device_ops *ops;\n\tint err;\n\n\tif (upper_dev) {\n\t\tif (upper_dev->ifindex == ifindex)\n\t\t\treturn 0;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_del_slave) {\n\t\t\terr = ops->ndo_del_slave(upper_dev, dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (ifindex) {\n\t\tupper_dev = __dev_get_by_index(dev_net(dev), ifindex);\n\t\tif (!upper_dev)\n\t\t\treturn -EINVAL;\n\t\tops = upper_dev->netdev_ops;\n\t\tif (ops->ndo_add_slave) {\n\t\t\terr = ops->ndo_add_slave(upper_dev, dev, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct nla_policy ifla_proto_down_reason_policy[IFLA_PROTO_DOWN_REASON_VALUE + 1] = {\n\t[IFLA_PROTO_DOWN_REASON_MASK]\t= { .type = NLA_U32 },\n\t[IFLA_PROTO_DOWN_REASON_VALUE]\t= { .type = NLA_U32 },\n};\n\nstatic int do_set_proto_down(struct net_device *dev,\n\t\t\t     struct nlattr *nl_proto_down,\n\t\t\t     struct nlattr *nl_proto_down_reason,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *pdreason[IFLA_PROTO_DOWN_REASON_MAX + 1];\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tunsigned long mask = 0;\n\tu32 value;\n\tbool proto_down;\n\tint err;\n\n\tif (!ops->ndo_change_proto_down) {\n\t\tNL_SET_ERR_MSG(extack,  \"Protodown not supported by device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (nl_proto_down_reason) {\n\t\terr = nla_parse_nested_deprecated(pdreason,\n\t\t\t\t\t\t  IFLA_PROTO_DOWN_REASON_MAX,\n\t\t\t\t\t\t  nl_proto_down_reason,\n\t\t\t\t\t\t  ifla_proto_down_reason_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (!pdreason[IFLA_PROTO_DOWN_REASON_VALUE]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid protodown reason value\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvalue = nla_get_u32(pdreason[IFLA_PROTO_DOWN_REASON_VALUE]);\n\n\t\tif (pdreason[IFLA_PROTO_DOWN_REASON_MASK])\n\t\t\tmask = nla_get_u32(pdreason[IFLA_PROTO_DOWN_REASON_MASK]);\n\n\t\tdev_change_proto_down_reason(dev, mask, value);\n\t}\n\n\tif (nl_proto_down) {\n\t\tproto_down = nla_get_u8(nl_proto_down);\n\n\t\t/* Dont turn off protodown if there are active reasons */\n\t\tif (!proto_down && dev->proto_down_reason) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot clear protodown, active reasons\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\terr = dev_change_proto_down(dev,\n\t\t\t\t\t    proto_down);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n#define DO_SETLINK_MODIFIED\t0x01\n/* notify flag means notify + modified. */\n#define DO_SETLINK_NOTIFY\t0x03\nstatic int do_setlink(const struct sk_buff *skb,\n\t\t      struct net_device *dev, struct ifinfomsg *ifm,\n\t\t      struct netlink_ext_ack *extack,\n\t\t      struct nlattr **tb, char *ifname, int status)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint err;\n\n\terr = validate_linkmsg(dev, tb);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_NET_NS_PID] || tb[IFLA_NET_NS_FD] || tb[IFLA_TARGET_NETNSID]) {\n\t\tstruct net *net = rtnl_link_get_net_capable(skb, dev_net(dev),\n\t\t\t\t\t\t\t    tb, CAP_NET_ADMIN);\n\t\tif (IS_ERR(net)) {\n\t\t\terr = PTR_ERR(net);\n\t\t\tgoto errout;\n\t\t}\n\n\t\terr = dev_change_net_namespace(dev, net, ifname);\n\t\tput_net(net);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_MAP]) {\n\t\tstruct rtnl_link_ifmap *u_map;\n\t\tstruct ifmap k_map;\n\n\t\tif (!ops->ndo_set_config) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (!netif_device_present(dev)) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tu_map = nla_data(tb[IFLA_MAP]);\n\t\tk_map.mem_start = (unsigned long) u_map->mem_start;\n\t\tk_map.mem_end = (unsigned long) u_map->mem_end;\n\t\tk_map.base_addr = (unsigned short) u_map->base_addr;\n\t\tk_map.irq = (unsigned char) u_map->irq;\n\t\tk_map.dma = (unsigned char) u_map->dma;\n\t\tk_map.port = (unsigned char) u_map->port;\n\n\t\terr = ops->ndo_set_config(dev, &k_map);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tstruct sockaddr *sa;\n\t\tint len;\n\n\t\tlen = sizeof(sa_family_t) + max_t(size_t, dev->addr_len,\n\t\t\t\t\t\t  sizeof(*sa));\n\t\tsa = kmalloc(len, GFP_KERNEL);\n\t\tif (!sa) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\t\tsa->sa_family = dev->type;\n\t\tmemcpy(sa->sa_data, nla_data(tb[IFLA_ADDRESS]),\n\t\t       dev->addr_len);\n\t\terr = dev_set_mac_address_user(dev, sa, extack);\n\t\tkfree(sa);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_MTU]) {\n\t\terr = dev_set_mtu_ext(dev, nla_get_u32(tb[IFLA_MTU]), extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_GROUP]) {\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\t/*\n\t * Interface selected by interface index but interface\n\t * name provided implies that a name change has been\n\t * requested.\n\t */\n\tif (ifm->ifi_index > 0 && ifname[0]) {\n\t\terr = dev_change_name(dev, ifname);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_IFALIAS]) {\n\t\terr = dev_set_alias(dev, nla_data(tb[IFLA_IFALIAS]),\n\t\t\t\t    nla_len(tb[IFLA_IFALIAS]));\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_BROADCAST]) {\n\t\tnla_memcpy(dev->broadcast, tb[IFLA_BROADCAST], dev->addr_len);\n\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\t}\n\n\tif (ifm->ifi_flags || ifm->ifi_change) {\n\t\terr = dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm),\n\t\t\t\t       extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[IFLA_MASTER]) {\n\t\terr = do_set_master(dev, nla_get_u32(tb[IFLA_MASTER]), extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_CARRIER]) {\n\t\terr = dev_change_carrier(dev, nla_get_u8(tb[IFLA_CARRIER]));\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_TXQLEN]) {\n\t\tunsigned int value = nla_get_u32(tb[IFLA_TXQLEN]);\n\n\t\terr = dev_change_tx_queue_len(dev, value);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_MODIFIED;\n\t}\n\n\tif (tb[IFLA_GSO_MAX_SIZE]) {\n\t\tu32 max_size = nla_get_u32(tb[IFLA_GSO_MAX_SIZE]);\n\n\t\tif (max_size > GSO_MAX_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (dev->gso_max_size ^ max_size) {\n\t\t\tnetif_set_gso_max_size(dev, max_size);\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_GSO_MAX_SEGS]) {\n\t\tu32 max_segs = nla_get_u32(tb[IFLA_GSO_MAX_SEGS]);\n\n\t\tif (max_segs > GSO_MAX_SEGS) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (dev->gso_max_segs ^ max_segs) {\n\t\t\tdev->gso_max_segs = max_segs;\n\t\t\tstatus |= DO_SETLINK_MODIFIED;\n\t\t}\n\t}\n\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\n\tif (tb[IFLA_LINKMODE]) {\n\t\tunsigned char value = nla_get_u8(tb[IFLA_LINKMODE]);\n\n\t\twrite_lock_bh(&dev_base_lock);\n\t\tif (dev->link_mode ^ value)\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\tdev->link_mode = value;\n\t\twrite_unlock_bh(&dev_base_lock);\n\t}\n\n\tif (tb[IFLA_VFINFO_LIST]) {\n\t\tstruct nlattr *vfinfo[IFLA_VF_MAX + 1];\n\t\tstruct nlattr *attr;\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_INFO ||\n\t\t\t    nla_len(attr) < NLA_HDRLEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = nla_parse_nested_deprecated(vfinfo, IFLA_VF_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  ifla_vf_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\terr = do_setvfinfo(dev, vfinfo);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_VF_PORTS]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\t\tstruct nlattr *attr;\n\t\tint vf;\n\t\tint rem;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (!ops->ndo_set_vf_port)\n\t\t\tgoto errout;\n\n\t\tnla_for_each_nested(attr, tb[IFLA_VF_PORTS], rem) {\n\t\t\tif (nla_type(attr) != IFLA_VF_PORT ||\n\t\t\t    nla_len(attr) < NLA_HDRLEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\terr = nla_parse_nested_deprecated(port, IFLA_PORT_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  ifla_port_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tif (!port[IFLA_PORT_VF]) {\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tvf = nla_get_u32(port[IFLA_PORT_VF]);\n\t\t\terr = ops->ndo_set_vf_port(dev, vf, port);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_PORT_SELF]) {\n\t\tstruct nlattr *port[IFLA_PORT_MAX+1];\n\n\t\terr = nla_parse_nested_deprecated(port, IFLA_PORT_MAX,\n\t\t\t\t\t\t  tb[IFLA_PORT_SELF],\n\t\t\t\t\t\t  ifla_port_policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\terr = -EOPNOTSUPP;\n\t\tif (ops->ndo_set_vf_port)\n\t\t\terr = ops->ndo_set_vf_port(dev, PORT_SELF_VF, port);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_AF_SPEC]) {\n\t\tstruct nlattr *af;\n\t\tint rem;\n\n\t\tnla_for_each_nested(af, tb[IFLA_AF_SPEC], rem) {\n\t\t\tconst struct rtnl_af_ops *af_ops;\n\n\t\t\trcu_read_lock();\n\n\t\t\tBUG_ON(!(af_ops = rtnl_af_lookup(nla_type(af))));\n\n\t\t\terr = af_ops->set_link_af(dev, af);\n\t\t\tif (err < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto errout;\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\terr = 0;\n\n\tif (tb[IFLA_PROTO_DOWN] || tb[IFLA_PROTO_DOWN_REASON]) {\n\t\terr = do_set_proto_down(dev, tb[IFLA_PROTO_DOWN],\n\t\t\t\t\ttb[IFLA_PROTO_DOWN_REASON], extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t\tstatus |= DO_SETLINK_NOTIFY;\n\t}\n\n\tif (tb[IFLA_XDP]) {\n\t\tstruct nlattr *xdp[IFLA_XDP_MAX + 1];\n\t\tu32 xdp_flags = 0;\n\n\t\terr = nla_parse_nested_deprecated(xdp, IFLA_XDP_MAX,\n\t\t\t\t\t\t  tb[IFLA_XDP],\n\t\t\t\t\t\t  ifla_xdp_policy, NULL);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\n\t\tif (xdp[IFLA_XDP_ATTACHED] || xdp[IFLA_XDP_PROG_ID]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (xdp[IFLA_XDP_FLAGS]) {\n\t\t\txdp_flags = nla_get_u32(xdp[IFLA_XDP_FLAGS]);\n\t\t\tif (xdp_flags & ~XDP_FLAGS_MASK) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tif (hweight32(xdp_flags & XDP_FLAGS_MODES) > 1) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tif (xdp[IFLA_XDP_FD]) {\n\t\t\tint expected_fd = -1;\n\n\t\t\tif (xdp_flags & XDP_FLAGS_REPLACE) {\n\t\t\t\tif (!xdp[IFLA_XDP_EXPECTED_FD]) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto errout;\n\t\t\t\t}\n\t\t\t\texpected_fd =\n\t\t\t\t\tnla_get_s32(xdp[IFLA_XDP_EXPECTED_FD]);\n\t\t\t}\n\n\t\t\terr = dev_change_xdp_fd(dev, extack,\n\t\t\t\t\t\tnla_get_s32(xdp[IFLA_XDP_FD]),\n\t\t\t\t\t\texpected_fd,\n\t\t\t\t\t\txdp_flags);\n\t\t\tif (err)\n\t\t\t\tgoto errout;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\t}\n\nerrout:\n\tif (status & DO_SETLINK_MODIFIED) {\n\t\tif ((status & DO_SETLINK_NOTIFY) == DO_SETLINK_NOTIFY)\n\t\t\tnetdev_state_change(dev);\n\n\t\tif (err < 0)\n\t\t\tnet_warn_ratelimited(\"A link change request failed with some changes committed already. Interface %s may have been left with an inconsistent configuration, please check.\\n\",\n\t\t\t\t\t     dev->name);\n\t}\n\n\treturn err;\n}\n\nstatic struct net_device *rtnl_dev_get(struct net *net,\n\t\t\t\t       struct nlattr *ifname_attr,\n\t\t\t\t       struct nlattr *altifname_attr,\n\t\t\t\t       char *ifname)\n{\n\tchar buffer[ALTIFNAMSIZ];\n\n\tif (!ifname) {\n\t\tifname = buffer;\n\t\tif (ifname_attr)\n\t\t\tnla_strscpy(ifname, ifname_attr, IFNAMSIZ);\n\t\telse if (altifname_attr)\n\t\t\tnla_strscpy(ifname, altifname_attr, ALTIFNAMSIZ);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\treturn __dev_get_by_name(net, ifname);\n}\n\nstatic int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tint err;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tchar ifname[IFNAMSIZ];\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t     ifla_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, false);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, NULL, tb[IFLA_ALT_IFNAME], ifname);\n\telse\n\t\tgoto errout;\n\n\tif (dev == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\terr = do_setlink(skb, dev, ifm, extack, tb, ifname, 0);\nerrout:\n\treturn err;\n}\n\nstatic int rtnl_group_dellink(const struct net *net, int group)\n{\n\tstruct net_device *dev, *aux;\n\tLIST_HEAD(list_kill);\n\tbool found = false;\n\n\tif (!group)\n\t\treturn -EPERM;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\n\t\t\tfound = true;\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tif (!ops || !ops->dellink)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\tconst struct rtnl_link_ops *ops;\n\n\t\t\tops = dev->rtnl_link_ops;\n\t\t\tops->dellink(dev, &list_kill);\n\t\t}\n\t}\n\tunregister_netdevice_many(&list_kill);\n\n\treturn 0;\n}\n\nint rtnl_delete_link(struct net_device *dev)\n{\n\tconst struct rtnl_link_ops *ops;\n\tLIST_HEAD(list_kill);\n\n\tops = dev->rtnl_link_ops;\n\tif (!ops || !ops->dellink)\n\t\treturn -EOPNOTSUPP;\n\n\tops->dellink(dev, &list_kill);\n\tunregister_netdevice_many(&list_kill);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtnl_delete_link);\n\nstatic int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tstruct net_device *dev = NULL;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\tint netnsid = -1;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t     ifla_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_TARGET_NETNSID]) {\n\t\tnetnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);\n\t\ttgt_net = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(tgt_net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, tb[IFLA_IFNAME],\n\t\t\t\t   tb[IFLA_ALT_IFNAME], NULL);\n\telse if (tb[IFLA_GROUP])\n\t\terr = rtnl_group_dellink(tgt_net, nla_get_u32(tb[IFLA_GROUP]));\n\telse\n\t\tgoto out;\n\n\tif (!dev) {\n\t\tif (tb[IFLA_IFNAME] || ifm->ifi_index > 0)\n\t\t\terr = -ENODEV;\n\n\t\tgoto out;\n\t}\n\n\terr = rtnl_delete_link(dev);\n\nout:\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nint rtnl_configure_link(struct net_device *dev, const struct ifinfomsg *ifm)\n{\n\tunsigned int old_flags;\n\tint err;\n\n\told_flags = dev->flags;\n\tif (ifm && (ifm->ifi_flags || ifm->ifi_change)) {\n\t\terr = __dev_change_flags(dev, rtnl_dev_combine_flags(dev, ifm),\n\t\t\t\t\t NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (dev->rtnl_link_state == RTNL_LINK_INITIALIZED) {\n\t\t__dev_notify_flags(dev, old_flags, (old_flags ^ dev->flags));\n\t} else {\n\t\tdev->rtnl_link_state = RTNL_LINK_INITIALIZED;\n\t\t__dev_notify_flags(dev, old_flags, ~0U);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(rtnl_configure_link);\n\nstruct net_device *rtnl_create_link(struct net *net, const char *ifname,\n\t\t\t\t    unsigned char name_assign_type,\n\t\t\t\t    const struct rtnl_link_ops *ops,\n\t\t\t\t    struct nlattr *tb[],\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev;\n\tunsigned int num_tx_queues = 1;\n\tunsigned int num_rx_queues = 1;\n\n\tif (tb[IFLA_NUM_TX_QUEUES])\n\t\tnum_tx_queues = nla_get_u32(tb[IFLA_NUM_TX_QUEUES]);\n\telse if (ops->get_num_tx_queues)\n\t\tnum_tx_queues = ops->get_num_tx_queues();\n\n\tif (tb[IFLA_NUM_RX_QUEUES])\n\t\tnum_rx_queues = nla_get_u32(tb[IFLA_NUM_RX_QUEUES]);\n\telse if (ops->get_num_rx_queues)\n\t\tnum_rx_queues = ops->get_num_rx_queues();\n\n\tif (num_tx_queues < 1 || num_tx_queues > 4096) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid number of transmit queues\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (num_rx_queues < 1 || num_rx_queues > 4096) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid number of receive queues\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdev = alloc_netdev_mqs(ops->priv_size, ifname, name_assign_type,\n\t\t\t       ops->setup, num_tx_queues, num_rx_queues);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev_net_set(dev, net);\n\tdev->rtnl_link_ops = ops;\n\tdev->rtnl_link_state = RTNL_LINK_INITIALIZING;\n\n\tif (tb[IFLA_MTU]) {\n\t\tu32 mtu = nla_get_u32(tb[IFLA_MTU]);\n\t\tint err;\n\n\t\terr = dev_validate_mtu(dev, mtu, extack);\n\t\tif (err) {\n\t\t\tfree_netdev(dev);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tdev->mtu = mtu;\n\t}\n\tif (tb[IFLA_ADDRESS]) {\n\t\tmemcpy(dev->dev_addr, nla_data(tb[IFLA_ADDRESS]),\n\t\t\t\tnla_len(tb[IFLA_ADDRESS]));\n\t\tdev->addr_assign_type = NET_ADDR_SET;\n\t}\n\tif (tb[IFLA_BROADCAST])\n\t\tmemcpy(dev->broadcast, nla_data(tb[IFLA_BROADCAST]),\n\t\t\t\tnla_len(tb[IFLA_BROADCAST]));\n\tif (tb[IFLA_TXQLEN])\n\t\tdev->tx_queue_len = nla_get_u32(tb[IFLA_TXQLEN]);\n\tif (tb[IFLA_OPERSTATE])\n\t\tset_operstate(dev, nla_get_u8(tb[IFLA_OPERSTATE]));\n\tif (tb[IFLA_LINKMODE])\n\t\tdev->link_mode = nla_get_u8(tb[IFLA_LINKMODE]);\n\tif (tb[IFLA_GROUP])\n\t\tdev_set_group(dev, nla_get_u32(tb[IFLA_GROUP]));\n\tif (tb[IFLA_GSO_MAX_SIZE])\n\t\tnetif_set_gso_max_size(dev, nla_get_u32(tb[IFLA_GSO_MAX_SIZE]));\n\tif (tb[IFLA_GSO_MAX_SEGS])\n\t\tdev->gso_max_segs = nla_get_u32(tb[IFLA_GSO_MAX_SEGS]);\n\n\treturn dev;\n}\nEXPORT_SYMBOL(rtnl_create_link);\n\nstatic int rtnl_group_changelink(const struct sk_buff *skb,\n\t\tstruct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct netlink_ext_ack *extack,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev, *aux;\n\tint err;\n\n\tfor_each_netdev_safe(net, dev, aux) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(skb, dev, ifm, extack, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attr, struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *slave_attr[RTNL_SLAVE_MAX_TYPE + 1];\n\tunsigned char name_assign_type = NET_NAME_USER;\n\tstruct nlattr *linkinfo[IFLA_INFO_MAX + 1];\n\tconst struct rtnl_link_ops *m_ops = NULL;\n\tstruct net_device *master_dev = NULL;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct rtnl_link_ops *ops;\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct net *dest_net, *link_net;\n\tstruct nlattr **slave_data;\n\tchar kind[MODULE_NAME_LEN];\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr **data;\n\tint err;\n\n#ifdef CONFIG_MODULES\nreplay:\n#endif\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t     ifla_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, false);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tifname[0] = '\\0';\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, NULL, tb[IFLA_ALT_IFNAME], ifname);\n\telse\n\t\tdev = NULL;\n\n\tif (dev) {\n\t\tmaster_dev = netdev_master_upper_dev_get(dev);\n\t\tif (master_dev)\n\t\t\tm_ops = master_dev->rtnl_link_ops;\n\t}\n\n\terr = validate_linkmsg(dev, tb);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_LINKINFO]) {\n\t\terr = nla_parse_nested_deprecated(linkinfo, IFLA_INFO_MAX,\n\t\t\t\t\t\t  tb[IFLA_LINKINFO],\n\t\t\t\t\t\t  ifla_info_policy, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n\t\tmemset(linkinfo, 0, sizeof(linkinfo));\n\n\tif (linkinfo[IFLA_INFO_KIND]) {\n\t\tnla_strscpy(kind, linkinfo[IFLA_INFO_KIND], sizeof(kind));\n\t\tops = rtnl_link_ops_get(kind);\n\t} else {\n\t\tkind[0] = '\\0';\n\t\tops = NULL;\n\t}\n\n\tdata = NULL;\n\tif (ops) {\n\t\tif (ops->maxtype > RTNL_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (ops->maxtype && linkinfo[IFLA_INFO_DATA]) {\n\t\t\terr = nla_parse_nested_deprecated(attr, ops->maxtype,\n\t\t\t\t\t\t\t  linkinfo[IFLA_INFO_DATA],\n\t\t\t\t\t\t\t  ops->policy, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tdata = attr;\n\t\t}\n\t\tif (ops->validate) {\n\t\t\terr = ops->validate(tb, data, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tslave_data = NULL;\n\tif (m_ops) {\n\t\tif (m_ops->slave_maxtype > RTNL_SLAVE_MAX_TYPE)\n\t\t\treturn -EINVAL;\n\n\t\tif (m_ops->slave_maxtype &&\n\t\t    linkinfo[IFLA_INFO_SLAVE_DATA]) {\n\t\t\terr = nla_parse_nested_deprecated(slave_attr,\n\t\t\t\t\t\t\t  m_ops->slave_maxtype,\n\t\t\t\t\t\t\t  linkinfo[IFLA_INFO_SLAVE_DATA],\n\t\t\t\t\t\t\t  m_ops->slave_policy,\n\t\t\t\t\t\t\t  extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tslave_data = slave_attr;\n\t\t}\n\t}\n\n\tif (dev) {\n\t\tint status = 0;\n\n\t\tif (nlh->nlmsg_flags & NLM_F_EXCL)\n\t\t\treturn -EEXIST;\n\t\tif (nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (linkinfo[IFLA_INFO_DATA]) {\n\t\t\tif (!ops || ops != dev->rtnl_link_ops ||\n\t\t\t    !ops->changelink)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\terr = ops->changelink(dev, tb, data, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\n\t\tif (linkinfo[IFLA_INFO_SLAVE_DATA]) {\n\t\t\tif (!m_ops || !m_ops->slave_changelink)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\terr = m_ops->slave_changelink(master_dev, dev, tb,\n\t\t\t\t\t\t      slave_data, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tstatus |= DO_SETLINK_NOTIFY;\n\t\t}\n\n\t\treturn do_setlink(skb, dev, ifm, extack, tb, ifname, status);\n\t}\n\n\tif (!(nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\tif (ifm->ifi_index == 0 && tb[IFLA_GROUP])\n\t\t\treturn rtnl_group_changelink(skb, net,\n\t\t\t\t\t\tnla_get_u32(tb[IFLA_GROUP]),\n\t\t\t\t\t\tifm, extack, tb);\n\t\treturn -ENODEV;\n\t}\n\n\tif (tb[IFLA_MAP] || tb[IFLA_PROTINFO])\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ops) {\n#ifdef CONFIG_MODULES\n\t\tif (kind[0]) {\n\t\t\t__rtnl_unlock();\n\t\t\trequest_module(\"rtnl-link-%s\", kind);\n\t\t\trtnl_lock();\n\t\t\tops = rtnl_link_ops_get(kind);\n\t\t\tif (ops)\n\t\t\t\tgoto replay;\n\t\t}\n#endif\n\t\tNL_SET_ERR_MSG(extack, \"Unknown device type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ops->setup)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ifname[0]) {\n\t\tsnprintf(ifname, IFNAMSIZ, \"%s%%d\", ops->kind);\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tdest_net = rtnl_link_get_net_capable(skb, net, tb, CAP_NET_ADMIN);\n\tif (IS_ERR(dest_net))\n\t\treturn PTR_ERR(dest_net);\n\n\tif (tb[IFLA_LINK_NETNSID]) {\n\t\tint id = nla_get_s32(tb[IFLA_LINK_NETNSID]);\n\n\t\tlink_net = get_net_ns_by_id(dest_net, id);\n\t\tif (!link_net) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown network namespace id\");\n\t\t\terr =  -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = -EPERM;\n\t\tif (!netlink_ns_capable(skb, link_net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t} else {\n\t\tlink_net = NULL;\n\t}\n\n\tdev = rtnl_create_link(link_net ? : dest_net, ifname,\n\t\t\t       name_assign_type, ops, tb, extack);\n\tif (IS_ERR(dev)) {\n\t\terr = PTR_ERR(dev);\n\t\tgoto out;\n\t}\n\n\tdev->ifindex = ifm->ifi_index;\n\n\tif (ops->newlink)\n\t\terr = ops->newlink(link_net ? : net, dev, tb, data, extack);\n\telse\n\t\terr = register_netdevice(dev);\n\tif (err < 0) {\n\t\tfree_netdev(dev);\n\t\tgoto out;\n\t}\n\n\terr = rtnl_configure_link(dev, ifm);\n\tif (err < 0)\n\t\tgoto out_unregister;\n\tif (link_net) {\n\t\terr = dev_change_net_namespace(dev, dest_net, ifname);\n\t\tif (err < 0)\n\t\t\tgoto out_unregister;\n\t}\n\tif (tb[IFLA_MASTER]) {\n\t\terr = do_set_master(dev, nla_get_u32(tb[IFLA_MASTER]), extack);\n\t\tif (err)\n\t\t\tgoto out_unregister;\n\t}\nout:\n\tif (link_net)\n\t\tput_net(link_net);\n\tput_net(dest_net);\n\treturn err;\nout_unregister:\n\tif (ops->newlink) {\n\t\tLIST_HEAD(list_kill);\n\n\t\tops->dellink(dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t} else {\n\t\tunregister_netdevice(dev);\n\t}\n\tgoto out;\n}\n\nstatic int rtnl_newlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr **attr;\n\tint ret;\n\n\tattr = kmalloc_array(RTNL_MAX_TYPE + 1, sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tret = __rtnl_newlink(skb, nlh, attr, extack);\n\tkfree(attr);\n\treturn ret;\n}\n\nstatic int rtnl_valid_getlink_req(struct sk_buff *skb,\n\t\t\t\t  const struct nlmsghdr *nlh,\n\t\t\t\t  struct nlattr **tb,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ifinfomsg *ifm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for get link\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t\t      ifla_policy, extack);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t    ifm->ifi_change) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for get link request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb, IFLA_MAX,\n\t\t\t\t\t    ifla_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= IFLA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IFLA_IFNAME:\n\t\tcase IFLA_ALT_IFNAME:\n\t\tcase IFLA_EXT_MASK:\n\t\tcase IFLA_TARGET_NETNSID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in get link request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *nskb;\n\tint netnsid = -1;\n\tint err;\n\tu32 ext_filter_mask = 0;\n\n\terr = rtnl_valid_getlink_req(skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_TARGET_NETNSID]) {\n\t\tnetnsid = nla_get_s32(tb[IFLA_TARGET_NETNSID]);\n\t\ttgt_net = rtnl_get_net_ns_capable(NETLINK_CB(skb).sk, netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\tif (tb[IFLA_EXT_MASK])\n\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\n\terr = -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(tgt_net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(tgt_net, tb[IFLA_IFNAME],\n\t\t\t\t   tb[IFLA_ALT_IFNAME], NULL);\n\telse\n\t\tgoto out;\n\n\terr = -ENODEV;\n\tif (dev == NULL)\n\t\tgoto out;\n\n\terr = -ENOBUFS;\n\tnskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);\n\tif (nskb == NULL)\n\t\tgoto out;\n\n\terr = rtnl_fill_ifinfo(nskb, dev, net,\n\t\t\t       RTM_NEWLINK, NETLINK_CB(skb).portid,\n\t\t\t       nlh->nlmsg_seq, 0, 0, ext_filter_mask,\n\t\t\t       0, NULL, 0, netnsid, GFP_KERNEL);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\nout:\n\tif (netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nstatic int rtnl_alt_ifname(int cmd, struct net_device *dev, struct nlattr *attr,\n\t\t\t   bool *changed, struct netlink_ext_ack *extack)\n{\n\tchar *alt_ifname;\n\tint err;\n\n\terr = nla_validate(attr, attr->nla_len, IFLA_MAX, ifla_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\talt_ifname = nla_strdup(attr, GFP_KERNEL);\n\tif (!alt_ifname)\n\t\treturn -ENOMEM;\n\n\tif (cmd == RTM_NEWLINKPROP) {\n\t\terr = netdev_name_node_alt_create(dev, alt_ifname);\n\t\tif (!err)\n\t\t\talt_ifname = NULL;\n\t} else if (cmd == RTM_DELLINKPROP) {\n\t\terr = netdev_name_node_alt_destroy(dev, alt_ifname);\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t\terr = -EINVAL;\n\t}\n\n\tkfree(alt_ifname);\n\tif (!err)\n\t\t*changed = true;\n\treturn err;\n}\n\nstatic int rtnl_linkprop(int cmd, struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tbool changed = false;\n\tstruct nlattr *attr;\n\tint err, rem;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = rtnl_ensure_unique_netns(tb, extack, true);\n\tif (err)\n\t\treturn err;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])\n\t\tdev = rtnl_dev_get(net, tb[IFLA_IFNAME],\n\t\t\t\t   tb[IFLA_ALT_IFNAME], NULL);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!tb[IFLA_PROP_LIST])\n\t\treturn 0;\n\n\tnla_for_each_nested(attr, tb[IFLA_PROP_LIST], rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase IFLA_ALT_IFNAME:\n\t\t\terr = rtnl_alt_ifname(cmd, dev, attr, &changed, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (changed)\n\t\tnetdev_state_change(dev);\n\treturn 0;\n}\n\nstatic int rtnl_newlinkprop(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn rtnl_linkprop(RTM_NEWLINKPROP, skb, nlh, extack);\n}\n\nstatic int rtnl_dellinkprop(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn rtnl_linkprop(RTM_DELLINKPROP, skb, nlh, extack);\n}\n\nstatic u32 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tsize_t min_ifinfo_dump_size = 0;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tstruct net_device *dev;\n\tint hdrlen;\n\n\t/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */\n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\tif (nlmsg_parse_deprecated(nlh, hdrlen, tb, IFLA_MAX, ifla_policy, NULL) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t/*\n\t * traverse the list of net devices and compute the minimum\n\t * buffer size based upon the filter mask.\n\t */\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tmin_ifinfo_dump_size = max(min_ifinfo_dump_size,\n\t\t\t\t\t   if_nlmsg_size(dev, ext_filter_mask));\n\t}\n\trcu_read_unlock();\n\n\treturn nlmsg_total_size(min_ifinfo_dump_size);\n}\n\nstatic int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\tint type = cb->nlh->nlmsg_type - RTM_BASE;\n\tint ret = 0;\n\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tstruct rtnl_link __rcu **tab;\n\t\tstruct rtnl_link *link;\n\t\trtnl_dumpit_func dumpit;\n\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\n\t\tif (type < 0 || type >= RTM_NR_MSGTYPES)\n\t\t\tcontinue;\n\n\t\ttab = rcu_dereference_rtnl(rtnl_msg_handlers[idx]);\n\t\tif (!tab)\n\t\t\tcontinue;\n\n\t\tlink = rcu_dereference_rtnl(tab[type]);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tdumpit = link->dumpit;\n\t\tif (!dumpit)\n\t\t\tcontinue;\n\n\t\tif (idx > s_idx) {\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\t\tcb->prev_seq = 0;\n\t\t\tcb->seq = 0;\n\t\t}\n\t\tret = dumpit(skb, cb);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\n\treturn skb->len ? : ret;\n}\n\nstruct sk_buff *rtmsg_ifinfo_build_skb(int type, struct net_device *dev,\n\t\t\t\t       unsigned int change,\n\t\t\t\t       u32 event, gfp_t flags, int *new_nsid,\n\t\t\t\t       int new_ifindex)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tsize_t if_info_size;\n\n\tskb = nlmsg_new((if_info_size = if_nlmsg_size(dev, 0)), flags);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = rtnl_fill_ifinfo(skb, dev, dev_net(dev),\n\t\t\t       type, 0, 0, change, 0, 0, event,\n\t\t\t       new_nsid, new_ifindex, -1, flags);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\treturn skb;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn NULL;\n}\n\nvoid rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev, gfp_t flags)\n{\n\tstruct net *net = dev_net(dev);\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, flags);\n}\n\nstatic void rtmsg_ifinfo_event(int type, struct net_device *dev,\n\t\t\t       unsigned int change, u32 event,\n\t\t\t       gfp_t flags, int *new_nsid, int new_ifindex)\n{\n\tstruct sk_buff *skb;\n\n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\treturn;\n\n\tskb = rtmsg_ifinfo_build_skb(type, dev, change, event, flags, new_nsid,\n\t\t\t\t     new_ifindex);\n\tif (skb)\n\t\trtmsg_ifinfo_send(skb, dev, flags);\n}\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned int change,\n\t\t  gfp_t flags)\n{\n\trtmsg_ifinfo_event(type, dev, change, rtnl_get_event(0), flags,\n\t\t\t   NULL, 0);\n}\n\nvoid rtmsg_ifinfo_newnet(int type, struct net_device *dev, unsigned int change,\n\t\t\t gfp_t flags, int *new_nsid, int new_ifindex)\n{\n\trtmsg_ifinfo_event(type, dev, change, rtnl_get_event(0), flags,\n\t\t\t   new_nsid, new_ifindex);\n}\n\nstatic int nlmsg_populate_fdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   u8 *addr, u16 vid, u32 pid, u32 seq,\n\t\t\t\t   int type, unsigned int flags,\n\t\t\t\t   int nlflags, u16 ndm_state)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ndm), nlflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1\t = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags\t = flags;\n\tndm->ndm_type\t = 0;\n\tndm->ndm_ifindex = dev->ifindex;\n\tndm->ndm_state   = ndm_state;\n\n\tif (nla_put(skb, NDA_LLADDR, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\tif (vid)\n\t\tif (nla_put(skb, NDA_VLAN, sizeof(u16), &vid))\n\t\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t rtnl_fdb_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg)) +\n\t       nla_total_size(ETH_ALEN) +\t/* NDA_LLADDR */\n\t       nla_total_size(sizeof(u16)) +\t/* NDA_VLAN */\n\t       0;\n}\n\nstatic void rtnl_fdb_notify(struct net_device *dev, u8 *addr, u16 vid, int type,\n\t\t\t    u16 ndm_state)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rtnl_fdb_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nlmsg_populate_fdb_fill(skb, dev, addr, vid,\n\t\t\t\t      0, 0, type, NTF_SELF, 0, ndm_state);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\n/*\n * ndo_dflt_fdb_add - default netdevice operation to add an FDB entry\n */\nint ndo_dflt_fdb_add(struct ndmsg *ndm,\n\t\t     struct nlattr *tb[],\n\t\t     struct net_device *dev,\n\t\t     const unsigned char *addr, u16 vid,\n\t\t     u16 flags)\n{\n\tint err = -EINVAL;\n\n\t/* If aging addresses are supported device will need to\n\t * implement its own handler for this.\n\t */\n\tif (ndm->ndm_state && !(ndm->ndm_state & NUD_PERMANENT)) {\n\t\tpr_info(\"%s: FDB only supports static addresses\\n\", dev->name);\n\t\treturn err;\n\t}\n\n\tif (vid) {\n\t\tpr_info(\"%s: vlans aren't supported yet for dev_uc|mc_add()\\n\", dev->name);\n\t\treturn err;\n\t}\n\n\tif (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))\n\t\terr = dev_uc_add_excl(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_add_excl(dev, addr);\n\n\t/* Only return duplicate errors if NLM_F_EXCL is set */\n\tif (err == -EEXIST && !(flags & NLM_F_EXCL))\n\t\terr = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_add);\n\nstatic int fdb_vid_parse(struct nlattr *vlan_attr, u16 *p_vid,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tu16 vid = 0;\n\n\tif (vlan_attr) {\n\t\tif (nla_len(vlan_attr) != sizeof(u16)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"invalid vlan attribute size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvid = nla_get_u16(vlan_attr);\n\n\t\tif (!vid || vid >= VLAN_VID_MASK) {\n\t\t\tNL_SET_ERR_MSG(extack, \"invalid vlan id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t*p_vid = vid;\n\treturn 0;\n}\n\nstatic int rtnl_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\tu8 *addr;\n\tu16 vid;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ndm), tb, NDA_MAX, NULL,\n\t\t\t\t     extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid ifindex\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid address\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->type != ARPHRD_ETHER) {\n\t\tNL_SET_ERR_MSG(extack, \"FDB add only supported for Ethernet devices\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\n\terr = fdb_vid_parse(tb[NDA_VLAN], &vid, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\n\t/* Support fdb on master device the net/bridge default case */\n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    netif_is_bridge_port(dev)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\terr = ops->ndo_fdb_add(ndm, tb, dev, addr, vid,\n\t\t\t\t       nlh->nlmsg_flags, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t/* Embedded bridge, macvlan, and any other device support */\n\tif ((ndm->ndm_flags & NTF_SELF)) {\n\t\tif (dev->netdev_ops->ndo_fdb_add)\n\t\t\terr = dev->netdev_ops->ndo_fdb_add(ndm, tb, dev, addr,\n\t\t\t\t\t\t\t   vid,\n\t\t\t\t\t\t\t   nlh->nlmsg_flags,\n\t\t\t\t\t\t\t   extack);\n\t\telse\n\t\t\terr = ndo_dflt_fdb_add(ndm, tb, dev, addr, vid,\n\t\t\t\t\t       nlh->nlmsg_flags);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, vid, RTM_NEWNEIGH,\n\t\t\t\t\tndm->ndm_state);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\n/*\n * ndo_dflt_fdb_del - default netdevice operation to delete an FDB entry\n */\nint ndo_dflt_fdb_del(struct ndmsg *ndm,\n\t\t     struct nlattr *tb[],\n\t\t     struct net_device *dev,\n\t\t     const unsigned char *addr, u16 vid)\n{\n\tint err = -EINVAL;\n\n\t/* If aging addresses are supported device will need to\n\t * implement its own handler for this.\n\t */\n\tif (!(ndm->ndm_state & NUD_PERMANENT)) {\n\t\tpr_info(\"%s: FDB only supports static addresses\\n\", dev->name);\n\t\treturn err;\n\t}\n\n\tif (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))\n\t\terr = dev_uc_del(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_del(dev, addr);\n\n\treturn err;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_del);\n\nstatic int rtnl_fdb_del(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ndmsg *ndm;\n\tstruct nlattr *tb[NDA_MAX+1];\n\tstruct net_device *dev;\n\t__u8 *addr;\n\tint err;\n\tu16 vid;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ndm), tb, NDA_MAX, NULL,\n\t\t\t\t     extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_ifindex == 0) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid ifindex\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ndm->ndm_ifindex);\n\tif (dev == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!tb[NDA_LLADDR] || nla_len(tb[NDA_LLADDR]) != ETH_ALEN) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid address\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->type != ARPHRD_ETHER) {\n\t\tNL_SET_ERR_MSG(extack, \"FDB delete only supported for Ethernet devices\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = nla_data(tb[NDA_LLADDR]);\n\n\terr = fdb_vid_parse(tb[NDA_VLAN], &vid, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\n\t/* Support fdb on master device the net/bridge default case */\n\tif ((!ndm->ndm_flags || ndm->ndm_flags & NTF_MASTER) &&\n\t    netif_is_bridge_port(dev)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tconst struct net_device_ops *ops = br_dev->netdev_ops;\n\n\t\tif (ops->ndo_fdb_del)\n\t\t\terr = ops->ndo_fdb_del(ndm, tb, dev, addr, vid);\n\n\t\tif (err)\n\t\t\tgoto out;\n\t\telse\n\t\t\tndm->ndm_flags &= ~NTF_MASTER;\n\t}\n\n\t/* Embedded bridge, macvlan, and any other device support */\n\tif (ndm->ndm_flags & NTF_SELF) {\n\t\tif (dev->netdev_ops->ndo_fdb_del)\n\t\t\terr = dev->netdev_ops->ndo_fdb_del(ndm, tb, dev, addr,\n\t\t\t\t\t\t\t   vid);\n\t\telse\n\t\t\terr = ndo_dflt_fdb_del(ndm, tb, dev, addr, vid);\n\n\t\tif (!err) {\n\t\t\trtnl_fdb_notify(dev, addr, vid, RTM_DELNEIGH,\n\t\t\t\t\tndm->ndm_state);\n\t\t\tndm->ndm_flags &= ~NTF_SELF;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int nlmsg_populate_fdb(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      struct net_device *dev,\n\t\t\t      int *idx,\n\t\t\t      struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha;\n\tint err;\n\tu32 portid, seq;\n\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\n\tlist_for_each_entry(ha, &list->list, list) {\n\t\tif (*idx < cb->args[2])\n\t\t\tgoto skip;\n\n\t\terr = nlmsg_populate_fdb_fill(skb, dev, ha->addr, 0,\n\t\t\t\t\t      portid, seq,\n\t\t\t\t\t      RTM_NEWNEIGH, NTF_SELF,\n\t\t\t\t\t      NLM_F_MULTI, NUD_PERMANENT);\n\t\tif (err < 0)\n\t\t\treturn err;\nskip:\n\t\t*idx += 1;\n\t}\n\treturn 0;\n}\n\n/**\n * ndo_dflt_fdb_dump - default netdevice operation to dump an FDB table.\n * @skb: socket buffer to store message in\n * @cb: netlink callback\n * @dev: netdevice\n * @filter_dev: ignored\n * @idx: the number of FDB table entries dumped is added to *@idx\n *\n * Default netdevice operation to dump the existing unicast address list.\n * Returns number of addresses from list put in skb.\n */\nint ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t      struct netlink_callback *cb,\n\t\t      struct net_device *dev,\n\t\t      struct net_device *filter_dev,\n\t\t      int *idx)\n{\n\tint err;\n\n\tif (dev->type != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tnetif_addr_lock_bh(dev);\n\terr = nlmsg_populate_fdb(skb, cb, dev, idx, &dev->uc);\n\tif (err)\n\t\tgoto out;\n\terr = nlmsg_populate_fdb(skb, cb, dev, idx, &dev->mc);\nout:\n\tnetif_addr_unlock_bh(dev);\n\treturn err;\n}\nEXPORT_SYMBOL(ndo_dflt_fdb_dump);\n\nstatic int valid_fdb_dump_strict(const struct nlmsghdr *nlh,\n\t\t\t\t int *br_idx, int *brport_idx,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tstruct ndmsg *ndm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for fdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||\n\t    ndm->ndm_flags || ndm->ndm_type) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for fdb dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct ndmsg), tb,\n\t\t\t\t\t    NDA_MAX, NULL, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\t*brport_idx = ndm->ndm_ifindex;\n\tfor (i = 0; i <= NDA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NDA_IFINDEX:\n\t\t\tif (nla_len(tb[i]) != sizeof(u32)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid IFINDEX attribute in fdb dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*brport_idx = nla_get_u32(tb[NDA_IFINDEX]);\n\t\t\tbreak;\n\t\tcase NDA_MASTER:\n\t\t\tif (nla_len(tb[i]) != sizeof(u32)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid MASTER attribute in fdb dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*br_idx = nla_get_u32(tb[NDA_MASTER]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in fdb dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int valid_fdb_dump_legacy(const struct nlmsghdr *nlh,\n\t\t\t\t int *br_idx, int *brport_idx,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\n\t/* A hack to preserve kernel<->userspace interface.\n\t * Before Linux v4.12 this code accepted ndmsg since iproute2 v3.3.0.\n\t * However, ndmsg is shorter than ifinfomsg thus nlmsg_parse() bails.\n\t * So, check for ndmsg with an optional u32 attribute (not used here).\n\t * Fortunately these sizes don't conflict with the size of ifinfomsg\n\t * with an optional attribute.\n\t */\n\tif (nlmsg_len(nlh) != sizeof(struct ndmsg) &&\n\t    (nlmsg_len(nlh) != sizeof(struct ndmsg) +\n\t     nla_attr_size(sizeof(u32)))) {\n\t\tstruct ifinfomsg *ifm;\n\n\t\terr = nlmsg_parse_deprecated(nlh, sizeof(struct ifinfomsg),\n\t\t\t\t\t     tb, IFLA_MAX, ifla_policy,\n\t\t\t\t\t     extack);\n\t\tif (err < 0) {\n\t\t\treturn -EINVAL;\n\t\t} else if (err == 0) {\n\t\t\tif (tb[IFLA_MASTER])\n\t\t\t\t*br_idx = nla_get_u32(tb[IFLA_MASTER]);\n\t\t}\n\n\t\tifm = nlmsg_data(nlh);\n\t\t*brport_idx = ifm->ifi_index;\n\t}\n\treturn 0;\n}\n\nstatic int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net_device *br_dev = NULL;\n\tconst struct net_device_ops *ops = NULL;\n\tconst struct net_device_ops *cops = NULL;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct hlist_head *head;\n\tint brport_idx = 0;\n\tint br_idx = 0;\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tint err = 0;\n\tint fidx = 0;\n\n\tif (cb->strict_check)\n\t\terr = valid_fdb_dump_strict(cb->nlh, &br_idx, &brport_idx,\n\t\t\t\t\t    cb->extack);\n\telse\n\t\terr = valid_fdb_dump_legacy(cb->nlh, &br_idx, &brport_idx,\n\t\t\t\t\t    cb->extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (br_idx) {\n\t\tbr_dev = __dev_get_by_index(net, br_idx);\n\t\tif (!br_dev)\n\t\t\treturn -ENODEV;\n\n\t\tops = br_dev->netdev_ops;\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\n\t\t\tif (brport_idx && (dev->ifindex != brport_idx))\n\t\t\t\tcontinue;\n\n\t\t\tif (!br_idx) { /* user did not specify a specific bridge */\n\t\t\t\tif (netif_is_bridge_port(dev)) {\n\t\t\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\t\t\tcops = br_dev->netdev_ops;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dev != br_dev &&\n\t\t\t\t    !netif_is_bridge_port(dev))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (br_dev != netdev_master_upper_dev_get(dev) &&\n\t\t\t\t    !(dev->priv_flags & IFF_EBRIDGE))\n\t\t\t\t\tcontinue;\n\t\t\t\tcops = ops;\n\t\t\t}\n\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\n\t\t\tif (netif_is_bridge_port(dev)) {\n\t\t\t\tif (cops && cops->ndo_fdb_dump) {\n\t\t\t\t\terr = cops->ndo_fdb_dump(skb, cb,\n\t\t\t\t\t\t\t\tbr_dev, dev,\n\t\t\t\t\t\t\t\t&fidx);\n\t\t\t\t\tif (err == -EMSGSIZE)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dev->netdev_ops->ndo_fdb_dump)\n\t\t\t\terr = dev->netdev_ops->ndo_fdb_dump(skb, cb,\n\t\t\t\t\t\t\t\t    dev, NULL,\n\t\t\t\t\t\t\t\t    &fidx);\n\t\t\telse\n\t\t\t\terr = ndo_dflt_fdb_dump(skb, cb, dev, NULL,\n\t\t\t\t\t\t\t&fidx);\n\t\t\tif (err == -EMSGSIZE)\n\t\t\t\tgoto out;\n\n\t\t\tcops = NULL;\n\n\t\t\t/* reset fdb offset to 0 for rest of the interfaces */\n\t\t\tcb->args[2] = 0;\n\t\t\tfidx = 0;\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\tcb->args[2] = fidx;\n\n\treturn skb->len;\n}\n\nstatic int valid_fdb_get_strict(const struct nlmsghdr *nlh,\n\t\t\t\tstruct nlattr **tb, u8 *ndm_flags,\n\t\t\t\tint *br_idx, int *brport_idx, u8 **addr,\n\t\t\t\tu16 *vid, struct netlink_ext_ack *extack)\n{\n\tstruct ndmsg *ndm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ndm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tndm = nlmsg_data(nlh);\n\tif (ndm->ndm_pad1  || ndm->ndm_pad2  || ndm->ndm_state ||\n\t    ndm->ndm_type) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ndm->ndm_flags & ~(NTF_MASTER | NTF_SELF)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid flags in header for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct ndmsg), tb,\n\t\t\t\t\t    NDA_MAX, nda_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\t*ndm_flags = ndm->ndm_flags;\n\t*brport_idx = ndm->ndm_ifindex;\n\tfor (i = 0; i <= NDA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NDA_MASTER:\n\t\t\t*br_idx = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase NDA_LLADDR:\n\t\t\tif (nla_len(tb[i]) != ETH_ALEN) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid address in fdb get request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t*addr = nla_data(tb[i]);\n\t\t\tbreak;\n\t\tcase NDA_VLAN:\n\t\t\terr = fdb_vid_parse(tb[i], vid, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase NDA_VNI:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in fdb get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_fdb_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = NULL, *br_dev = NULL;\n\tconst struct net_device_ops *ops = NULL;\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NDA_MAX + 1];\n\tstruct sk_buff *skb;\n\tint brport_idx = 0;\n\tu8 ndm_flags = 0;\n\tint br_idx = 0;\n\tu8 *addr = NULL;\n\tu16 vid = 0;\n\tint err;\n\n\terr = valid_fdb_get_strict(nlh, tb, &ndm_flags, &br_idx,\n\t\t\t\t   &brport_idx, &addr, &vid, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!addr) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing lookup address for fdb get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (brport_idx) {\n\t\tdev = __dev_get_by_index(net, brport_idx);\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown device ifindex\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (br_idx) {\n\t\tif (dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Master and device are mutually exclusive\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbr_dev = __dev_get_by_index(net, br_idx);\n\t\tif (!br_dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid master ifindex\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tops = br_dev->netdev_ops;\n\t}\n\n\tif (dev) {\n\t\tif (!ndm_flags || (ndm_flags & NTF_MASTER)) {\n\t\t\tif (!netif_is_bridge_port(dev)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Device is not a bridge port\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\tif (!br_dev) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Master of device not found\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tops = br_dev->netdev_ops;\n\t\t} else {\n\t\t\tif (!(ndm_flags & NTF_SELF)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Missing NTF_SELF\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tops = dev->netdev_ops;\n\t\t}\n\t}\n\n\tif (!br_dev && !dev) {\n\t\tNL_SET_ERR_MSG(extack, \"No device specified\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!ops || !ops->ndo_fdb_get) {\n\t\tNL_SET_ERR_MSG(extack, \"Fdb get operation not supported by device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tif (br_dev)\n\t\tdev = br_dev;\n\terr = ops->ndo_fdb_get(skb, tb, dev, addr, vid,\n\t\t\t       NETLINK_CB(in_skb).portid,\n\t\t\t       nlh->nlmsg_seq, extack);\n\tif (err)\n\t\tgoto out;\n\n\treturn rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nout:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int brport_nla_put_flag(struct sk_buff *skb, u32 flags, u32 mask,\n\t\t\t       unsigned int attrnum, unsigned int flag)\n{\n\tif (mask & flag)\n\t\treturn nla_put_u8(skb, attrnum, !!(flags & flag));\n\treturn 0;\n}\n\nint ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t    struct net_device *dev, u16 mode,\n\t\t\t    u32 flags, u32 mask, int nlflags,\n\t\t\t    u32 filter_mask,\n\t\t\t    int (*vlan_fill)(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     u32 filter_mask))\n{\n\tstruct nlmsghdr *nlh;\n\tstruct ifinfomsg *ifm;\n\tstruct nlattr *br_afspec;\n\tstruct nlattr *protinfo;\n\tu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\n\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, pid, seq, RTM_NEWLINK, sizeof(*ifm), nlflags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifi_family = AF_BRIDGE;\n\tifm->__ifi_pad = 0;\n\tifm->ifi_type = dev->type;\n\tifm->ifi_index = dev->ifindex;\n\tifm->ifi_flags = dev_get_flags(dev);\n\tifm->ifi_change = 0;\n\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\n\t    (br_dev &&\n\t     nla_put_u32(skb, IFLA_MASTER, br_dev->ifindex)) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    (dev->ifindex != dev_get_iflink(dev) &&\n\t     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))))\n\t\tgoto nla_put_failure;\n\n\tbr_afspec = nla_nest_start_noflag(skb, IFLA_AF_SPEC);\n\tif (!br_afspec)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_BRIDGE_FLAGS, BRIDGE_FLAGS_SELF)) {\n\t\tnla_nest_cancel(skb, br_afspec);\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (mode != BRIDGE_MODE_UNDEF) {\n\t\tif (nla_put_u16(skb, IFLA_BRIDGE_MODE, mode)) {\n\t\t\tnla_nest_cancel(skb, br_afspec);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tif (vlan_fill) {\n\t\terr = vlan_fill(skb, dev, filter_mask);\n\t\tif (err) {\n\t\t\tnla_nest_cancel(skb, br_afspec);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\tnla_nest_end(skb, br_afspec);\n\n\tprotinfo = nla_nest_start(skb, IFLA_PROTINFO);\n\tif (!protinfo)\n\t\tgoto nla_put_failure;\n\n\tif (brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_MODE, BR_HAIRPIN_MODE) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_GUARD, BR_BPDU_GUARD) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_FAST_LEAVE,\n\t\t\t\tBR_MULTICAST_FAST_LEAVE) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_PROTECT, BR_ROOT_BLOCK) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_LEARNING, BR_LEARNING) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_LEARNING_SYNC, BR_LEARNING_SYNC) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_PROXYARP, BR_PROXYARP) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_MCAST_FLOOD, BR_MCAST_FLOOD) ||\n\t    brport_nla_put_flag(skb, flags, mask,\n\t\t\t\tIFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD)) {\n\t\tnla_nest_cancel(skb, protinfo);\n\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(skb, protinfo);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn err ? err : -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(ndo_dflt_bridge_getlink);\n\nstatic int valid_bridge_getlink_req(const struct nlmsghdr *nlh,\n\t\t\t\t    bool strict_check, u32 *filter_mask,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err, i;\n\n\tif (strict_check) {\n\t\tstruct ifinfomsg *ifm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid header for bridge link dump\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tifm = nlmsg_data(nlh);\n\t\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t\t    ifm->ifi_change || ifm->ifi_index) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for bridge link dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated_strict(nlh,\n\t\t\t\t\t\t    sizeof(struct ifinfomsg),\n\t\t\t\t\t\t    tb, IFLA_MAX, ifla_policy,\n\t\t\t\t\t\t    extack);\n\t} else {\n\t\terr = nlmsg_parse_deprecated(nlh, sizeof(struct ifinfomsg),\n\t\t\t\t\t     tb, IFLA_MAX, ifla_policy,\n\t\t\t\t\t     extack);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\t/* new attributes should only be added with strict checking */\n\tfor (i = 0; i <= IFLA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IFLA_EXT_MASK:\n\t\t\t*filter_mask = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strict_check) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in bridge link dump request\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_bridge_getlink(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint idx = 0;\n\tu32 portid = NETLINK_CB(cb->skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\tu32 filter_mask = 0;\n\tint err;\n\n\terr = valid_bridge_getlink_req(nlh, cb->strict_check, &filter_mask,\n\t\t\t\t       cb->extack);\n\tif (err < 0 && cb->strict_check)\n\t\treturn err;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tconst struct net_device_ops *ops = dev->netdev_ops;\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (br_dev && br_dev->netdev_ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0]) {\n\t\t\t\terr = br_dev->netdev_ops->ndo_bridge_getlink(\n\t\t\t\t\t\tskb, portid, seq, dev,\n\t\t\t\t\t\tfilter_mask, NLM_F_MULTI);\n\t\t\t\tif (err < 0 && err != -EOPNOTSUPP) {\n\t\t\t\t\tif (likely(skb->len))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\n\t\tif (ops->ndo_bridge_getlink) {\n\t\t\tif (idx >= cb->args[0]) {\n\t\t\t\terr = ops->ndo_bridge_getlink(skb, portid,\n\t\t\t\t\t\t\t      seq, dev,\n\t\t\t\t\t\t\t      filter_mask,\n\t\t\t\t\t\t\t      NLM_F_MULTI);\n\t\t\t\tif (err < 0 && err != -EOPNOTSUPP) {\n\t\t\t\t\tif (likely(skb->len))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\terr = skb->len;\nout_err:\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\n\treturn err;\n}\n\nstatic inline size_t bridge_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t\t+ nla_total_size(IFNAMSIZ)\t/* IFLA_IFNAME */\n\t\t+ nla_total_size(MAX_ADDR_LEN)\t/* IFLA_ADDRESS */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MASTER */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_MTU */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_LINK */\n\t\t+ nla_total_size(sizeof(u32))\t/* IFLA_OPERSTATE */\n\t\t+ nla_total_size(sizeof(u8))\t/* IFLA_PROTINFO */\n\t\t+ nla_total_size(sizeof(struct nlattr))\t/* IFLA_AF_SPEC */\n\t\t+ nla_total_size(sizeof(u16))\t/* IFLA_BRIDGE_FLAGS */\n\t\t+ nla_total_size(sizeof(u16));\t/* IFLA_BRIDGE_MODE */\n}\n\nstatic int rtnl_bridge_notify(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\n\tif (!dev->netdev_ops->ndo_bridge_getlink)\n\t\treturn 0;\n\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (!skb->len)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\tif (err)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}\n\nstatic int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh, flags,\n\t\t\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags,\n\t\t\t\t\t\t\t\t  extack);\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\n\t\t\t/* Generate event to notify upper layer of bridge\n\t\t\t * change\n\t\t\t */\n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}\n\nstatic int rtnl_bridge_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"unknown ifindex\");\n\t\treturn -ENODEV;\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_dellink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = br_dev->netdev_ops->ndo_bridge_dellink(dev, nlh, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_dellink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_dellink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags);\n\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\n\t\t\t/* Generate event to notify upper layer of bridge\n\t\t\t * change\n\t\t\t */\n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}\n\nstatic bool stats_attr_valid(unsigned int mask, int attrid, int idxattr)\n{\n\treturn (mask & IFLA_STATS_FILTER_BIT(attrid)) &&\n\t       (!idxattr || idxattr == attrid);\n}\n\n#define IFLA_OFFLOAD_XSTATS_FIRST (IFLA_OFFLOAD_XSTATS_UNSPEC + 1)\nstatic int rtnl_get_offload_stats_attr_size(int attr_id)\n{\n\tswitch (attr_id) {\n\tcase IFLA_OFFLOAD_XSTATS_CPU_HIT:\n\t\treturn sizeof(struct rtnl_link_stats64);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_get_offload_stats(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t  int *prividx)\n{\n\tstruct nlattr *attr = NULL;\n\tint attr_id, size;\n\tvoid *attr_data;\n\tint err;\n\n\tif (!(dev->netdev_ops && dev->netdev_ops->ndo_has_offload_stats &&\n\t      dev->netdev_ops->ndo_get_offload_stats))\n\t\treturn -ENODATA;\n\n\tfor (attr_id = IFLA_OFFLOAD_XSTATS_FIRST;\n\t     attr_id <= IFLA_OFFLOAD_XSTATS_MAX; attr_id++) {\n\t\tif (attr_id < *prividx)\n\t\t\tcontinue;\n\n\t\tsize = rtnl_get_offload_stats_attr_size(attr_id);\n\t\tif (!size)\n\t\t\tcontinue;\n\n\t\tif (!dev->netdev_ops->ndo_has_offload_stats(dev, attr_id))\n\t\t\tcontinue;\n\n\t\tattr = nla_reserve_64bit(skb, attr_id, size,\n\t\t\t\t\t IFLA_OFFLOAD_XSTATS_UNSPEC);\n\t\tif (!attr)\n\t\t\tgoto nla_put_failure;\n\n\t\tattr_data = nla_data(attr);\n\t\tmemset(attr_data, 0, size);\n\t\terr = dev->netdev_ops->ndo_get_offload_stats(attr_id, dev,\n\t\t\t\t\t\t\t     attr_data);\n\t\tif (err)\n\t\t\tgoto get_offload_stats_failure;\n\t}\n\n\tif (!attr)\n\t\treturn -ENODATA;\n\n\t*prividx = 0;\n\treturn 0;\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nget_offload_stats_failure:\n\t*prividx = attr_id;\n\treturn err;\n}\n\nstatic int rtnl_get_offload_stats_size(const struct net_device *dev)\n{\n\tint nla_size = 0;\n\tint attr_id;\n\tint size;\n\n\tif (!(dev->netdev_ops && dev->netdev_ops->ndo_has_offload_stats &&\n\t      dev->netdev_ops->ndo_get_offload_stats))\n\t\treturn 0;\n\n\tfor (attr_id = IFLA_OFFLOAD_XSTATS_FIRST;\n\t     attr_id <= IFLA_OFFLOAD_XSTATS_MAX; attr_id++) {\n\t\tif (!dev->netdev_ops->ndo_has_offload_stats(dev, attr_id))\n\t\t\tcontinue;\n\t\tsize = rtnl_get_offload_stats_attr_size(attr_id);\n\t\tnla_size += nla_total_size_64bit(size);\n\t}\n\n\tif (nla_size != 0)\n\t\tnla_size += nla_total_size(0);\n\n\treturn nla_size;\n}\n\nstatic int rtnl_fill_statsinfo(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       int type, u32 pid, u32 seq, u32 change,\n\t\t\t       unsigned int flags, unsigned int filter_mask,\n\t\t\t       int *idxattr, int *prividx)\n{\n\tstruct if_stats_msg *ifsm;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *attr;\n\tint s_prividx = *prividx;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifsm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tifsm = nlmsg_data(nlh);\n\tifsm->family = PF_UNSPEC;\n\tifsm->pad1 = 0;\n\tifsm->pad2 = 0;\n\tifsm->ifindex = dev->ifindex;\n\tifsm->filter_mask = filter_mask;\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_64, *idxattr)) {\n\t\tstruct rtnl_link_stats64 *sp;\n\n\t\tattr = nla_reserve_64bit(skb, IFLA_STATS_LINK_64,\n\t\t\t\t\t sizeof(struct rtnl_link_stats64),\n\t\t\t\t\t IFLA_STATS_UNSPEC);\n\t\tif (!attr)\n\t\t\tgoto nla_put_failure;\n\n\t\tsp = nla_data(attr);\n\t\tdev_get_stats(dev, sp);\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS, *idxattr)) {\n\t\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\n\t\tif (ops && ops->fill_linkxstats) {\n\t\t\t*idxattr = IFLA_STATS_LINK_XSTATS;\n\t\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t     IFLA_STATS_LINK_XSTATS);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\terr = ops->fill_linkxstats(skb, dev, prividx, *idxattr);\n\t\t\tnla_nest_end(skb, attr);\n\t\t\tif (err)\n\t\t\t\tgoto nla_put_failure;\n\t\t\t*idxattr = 0;\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS_SLAVE,\n\t\t\t     *idxattr)) {\n\t\tconst struct rtnl_link_ops *ops = NULL;\n\t\tconst struct net_device *master;\n\n\t\tmaster = netdev_master_upper_dev_get(dev);\n\t\tif (master)\n\t\t\tops = master->rtnl_link_ops;\n\t\tif (ops && ops->fill_linkxstats) {\n\t\t\t*idxattr = IFLA_STATS_LINK_XSTATS_SLAVE;\n\t\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t     IFLA_STATS_LINK_XSTATS_SLAVE);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\terr = ops->fill_linkxstats(skb, dev, prividx, *idxattr);\n\t\t\tnla_nest_end(skb, attr);\n\t\t\tif (err)\n\t\t\t\tgoto nla_put_failure;\n\t\t\t*idxattr = 0;\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_OFFLOAD_XSTATS,\n\t\t\t     *idxattr)) {\n\t\t*idxattr = IFLA_STATS_LINK_OFFLOAD_XSTATS;\n\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t     IFLA_STATS_LINK_OFFLOAD_XSTATS);\n\t\tif (!attr)\n\t\t\tgoto nla_put_failure;\n\n\t\terr = rtnl_get_offload_stats(skb, dev, prividx);\n\t\tif (err == -ENODATA)\n\t\t\tnla_nest_cancel(skb, attr);\n\t\telse\n\t\t\tnla_nest_end(skb, attr);\n\n\t\tif (err && err != -ENODATA)\n\t\t\tgoto nla_put_failure;\n\t\t*idxattr = 0;\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_AF_SPEC, *idxattr)) {\n\t\tstruct rtnl_af_ops *af_ops;\n\n\t\t*idxattr = IFLA_STATS_AF_SPEC;\n\t\tattr = nla_nest_start_noflag(skb, IFLA_STATS_AF_SPEC);\n\t\tif (!attr)\n\t\t\tgoto nla_put_failure;\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\t\tif (af_ops->fill_stats_af) {\n\t\t\t\tstruct nlattr *af;\n\t\t\t\tint err;\n\n\t\t\t\taf = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t   af_ops->family);\n\t\t\t\tif (!af) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t}\n\t\t\t\terr = af_ops->fill_stats_af(skb, dev);\n\n\t\t\t\tif (err == -ENODATA) {\n\t\t\t\t\tnla_nest_cancel(skb, af);\n\t\t\t\t} else if (err < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\t}\n\n\t\t\t\tnla_nest_end(skb, af);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tnla_nest_end(skb, attr);\n\n\t\t*idxattr = 0;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\n\nnla_put_failure:\n\t/* not a multi message or no progress mean a real error */\n\tif (!(flags & NLM_F_MULTI) || s_prividx == *prividx)\n\t\tnlmsg_cancel(skb, nlh);\n\telse\n\t\tnlmsg_end(skb, nlh);\n\n\treturn -EMSGSIZE;\n}\n\nstatic size_t if_nlmsg_stats_size(const struct net_device *dev,\n\t\t\t\t  u32 filter_mask)\n{\n\tsize_t size = 0;\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_64, 0))\n\t\tsize += nla_total_size_64bit(sizeof(struct rtnl_link_stats64));\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS, 0)) {\n\t\tconst struct rtnl_link_ops *ops = dev->rtnl_link_ops;\n\t\tint attr = IFLA_STATS_LINK_XSTATS;\n\n\t\tif (ops && ops->get_linkxstats_size) {\n\t\t\tsize += nla_total_size(ops->get_linkxstats_size(dev,\n\t\t\t\t\t\t\t\t\tattr));\n\t\t\t/* for IFLA_STATS_LINK_XSTATS */\n\t\t\tsize += nla_total_size(0);\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS_SLAVE, 0)) {\n\t\tstruct net_device *_dev = (struct net_device *)dev;\n\t\tconst struct rtnl_link_ops *ops = NULL;\n\t\tconst struct net_device *master;\n\n\t\t/* netdev_master_upper_dev_get can't take const */\n\t\tmaster = netdev_master_upper_dev_get(_dev);\n\t\tif (master)\n\t\t\tops = master->rtnl_link_ops;\n\t\tif (ops && ops->get_linkxstats_size) {\n\t\t\tint attr = IFLA_STATS_LINK_XSTATS_SLAVE;\n\n\t\t\tsize += nla_total_size(ops->get_linkxstats_size(dev,\n\t\t\t\t\t\t\t\t\tattr));\n\t\t\t/* for IFLA_STATS_LINK_XSTATS_SLAVE */\n\t\t\tsize += nla_total_size(0);\n\t\t}\n\t}\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_LINK_OFFLOAD_XSTATS, 0))\n\t\tsize += rtnl_get_offload_stats_size(dev);\n\n\tif (stats_attr_valid(filter_mask, IFLA_STATS_AF_SPEC, 0)) {\n\t\tstruct rtnl_af_ops *af_ops;\n\n\t\t/* for IFLA_STATS_AF_SPEC */\n\t\tsize += nla_total_size(0);\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(af_ops, &rtnl_af_ops, list) {\n\t\t\tif (af_ops->get_stats_af_size) {\n\t\t\t\tsize += nla_total_size(\n\t\t\t\t\taf_ops->get_stats_af_size(dev));\n\n\t\t\t\t/* for AF_* */\n\t\t\t\tsize += nla_total_size(0);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\treturn size;\n}\n\nstatic int rtnl_valid_stats_req(const struct nlmsghdr *nlh, bool strict_check,\n\t\t\t\tbool is_dump, struct netlink_ext_ack *extack)\n{\n\tstruct if_stats_msg *ifsm;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifsm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for stats dump\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strict_check)\n\t\treturn 0;\n\n\tifsm = nlmsg_data(nlh);\n\n\t/* only requests using strict checks can pass data to influence\n\t * the dump. The legacy exception is filter_mask.\n\t */\n\tif (ifsm->pad1 || ifsm->pad2 || (is_dump && ifsm->ifindex)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for stats dump request\");\n\t\treturn -EINVAL;\n\t}\n\tif (nlmsg_attrlen(nlh, sizeof(*ifsm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid attributes after stats header\");\n\t\treturn -EINVAL;\n\t}\n\tif (ifsm->filter_mask >= IFLA_STATS_FILTER_BIT(IFLA_STATS_MAX + 1)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid stats requested through filter mask\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtnl_stats_get(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev = NULL;\n\tint idxattr = 0, prividx = 0;\n\tstruct if_stats_msg *ifsm;\n\tstruct sk_buff *nskb;\n\tu32 filter_mask;\n\tint err;\n\n\terr = rtnl_valid_stats_req(nlh, netlink_strict_get_check(skb),\n\t\t\t\t   false, extack);\n\tif (err)\n\t\treturn err;\n\n\tifsm = nlmsg_data(nlh);\n\tif (ifsm->ifindex > 0)\n\t\tdev = __dev_get_by_index(net, ifsm->ifindex);\n\telse\n\t\treturn -EINVAL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tfilter_mask = ifsm->filter_mask;\n\tif (!filter_mask)\n\t\treturn -EINVAL;\n\n\tnskb = nlmsg_new(if_nlmsg_stats_size(dev, filter_mask), GFP_KERNEL);\n\tif (!nskb)\n\t\treturn -ENOBUFS;\n\n\terr = rtnl_fill_statsinfo(nskb, dev, RTM_NEWSTATS,\n\t\t\t\t  NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,\n\t\t\t\t  0, filter_mask, &idxattr, &prividx);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in if_nlmsg_stats_size */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(nskb);\n\t} else {\n\t\terr = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);\n\t}\n\n\treturn err;\n}\n\nstatic int rtnl_stats_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tint h, s_h, err, s_idx, s_idxattr, s_prividx;\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int flags = NLM_F_MULTI;\n\tstruct if_stats_msg *ifsm;\n\tstruct hlist_head *head;\n\tstruct net_device *dev;\n\tu32 filter_mask = 0;\n\tint idx = 0;\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\ts_idxattr = cb->args[2];\n\ts_prividx = cb->args[3];\n\n\tcb->seq = net->dev_base_seq;\n\n\terr = rtnl_valid_stats_req(cb->nlh, cb->strict_check, true, extack);\n\tif (err)\n\t\treturn err;\n\n\tifsm = nlmsg_data(cb->nlh);\n\tfilter_mask = ifsm->filter_mask;\n\tif (!filter_mask) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter mask must be set for stats dump\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\terr = rtnl_fill_statsinfo(skb, dev, RTM_NEWSTATS,\n\t\t\t\t\t\t  NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t  cb->nlh->nlmsg_seq, 0,\n\t\t\t\t\t\t  flags, filter_mask,\n\t\t\t\t\t\t  &s_idxattr, &s_prividx);\n\t\t\t/* If we ran out of room on the first message,\n\t\t\t * we're in trouble\n\t\t\t */\n\t\t\tWARN_ON((err == -EMSGSIZE) && (skb->len == 0));\n\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\ts_prividx = 0;\n\t\t\ts_idxattr = 0;\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tcb->args[3] = s_prividx;\n\tcb->args[2] = s_idxattr;\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\n/* Process one rtnetlink message. */\n\nstatic int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rtnl_link *link;\n\tstruct module *owner;\n\tint err = -EOPNOTSUPP;\n\trtnl_doit_func doit;\n\tunsigned int flags;\n\tint kind;\n\tint family;\n\tint type;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > RTM_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\ttype -= RTM_BASE;\n\n\t/* All the messages must have at least 1 byte length */\n\tif (nlmsg_len(nlh) < sizeof(struct rtgenmsg))\n\t\treturn 0;\n\n\tfamily = ((struct rtgenmsg *)nlmsg_data(nlh))->rtgen_family;\n\tkind = type&3;\n\n\tif (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\trcu_read_lock();\n\tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {\n\t\tstruct sock *rtnl;\n\t\trtnl_dumpit_func dumpit;\n\t\tu32 min_dump_alloc = 0;\n\n\t\tlink = rtnl_get_link(family, type);\n\t\tif (!link || !link->dumpit) {\n\t\t\tfamily = PF_UNSPEC;\n\t\t\tlink = rtnl_get_link(family, type);\n\t\t\tif (!link || !link->dumpit)\n\t\t\t\tgoto err_unlock;\n\t\t}\n\t\towner = link->owner;\n\t\tdumpit = link->dumpit;\n\n\t\tif (type == RTM_GETLINK - RTM_BASE)\n\t\t\tmin_dump_alloc = rtnl_calcit(skb, nlh);\n\n\t\terr = 0;\n\t\t/* need to do this before rcu_read_unlock() */\n\t\tif (!try_module_get(owner))\n\t\t\terr = -EPROTONOSUPPORT;\n\n\t\trcu_read_unlock();\n\n\t\trtnl = net->rtnl;\n\t\tif (err == 0) {\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump\t\t= dumpit,\n\t\t\t\t.min_dump_alloc\t= min_dump_alloc,\n\t\t\t\t.module\t\t= owner,\n\t\t\t};\n\t\t\terr = netlink_dump_start(rtnl, skb, nlh, &c);\n\t\t\t/* netlink_dump_start() will keep a reference on\n\t\t\t * module if dump is still in progress.\n\t\t\t */\n\t\t\tmodule_put(owner);\n\t\t}\n\t\treturn err;\n\t}\n\n\tlink = rtnl_get_link(family, type);\n\tif (!link || !link->doit) {\n\t\tfamily = PF_UNSPEC;\n\t\tlink = rtnl_get_link(PF_UNSPEC, type);\n\t\tif (!link || !link->doit)\n\t\t\tgoto out_unlock;\n\t}\n\n\towner = link->owner;\n\tif (!try_module_get(owner)) {\n\t\terr = -EPROTONOSUPPORT;\n\t\tgoto out_unlock;\n\t}\n\n\tflags = link->flags;\n\tif (flags & RTNL_FLAG_DOIT_UNLOCKED) {\n\t\tdoit = link->doit;\n\t\trcu_read_unlock();\n\t\tif (doit)\n\t\t\terr = doit(skb, nlh, extack);\n\t\tmodule_put(owner);\n\t\treturn err;\n\t}\n\trcu_read_unlock();\n\n\trtnl_lock();\n\tlink = rtnl_get_link(family, type);\n\tif (link && link->doit)\n\t\terr = link->doit(skb, nlh, extack);\n\trtnl_unlock();\n\n\tmodule_put(owner);\n\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\n\treturn err;\n\nerr_unlock:\n\trcu_read_unlock();\n\treturn -EOPNOTSUPP;\n}\n\nstatic void rtnetlink_rcv(struct sk_buff *skb)\n{\n\tnetlink_rcv_skb(skb, &rtnetlink_rcv_msg);\n}\n\nstatic int rtnetlink_bind(struct net *net, int group)\n{\n\tswitch (group) {\n\tcase RTNLGRP_IPV4_MROUTE_R:\n\tcase RTNLGRP_IPV6_MROUTE_R:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rtnetlink_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\tcase NETDEV_CHANGEMTU:\n\tcase NETDEV_CHANGEADDR:\n\tcase NETDEV_CHANGENAME:\n\tcase NETDEV_FEAT_CHANGE:\n\tcase NETDEV_BONDING_FAILOVER:\n\tcase NETDEV_POST_TYPE_CHANGE:\n\tcase NETDEV_NOTIFY_PEERS:\n\tcase NETDEV_CHANGEUPPER:\n\tcase NETDEV_RESEND_IGMP:\n\tcase NETDEV_CHANGEINFODATA:\n\tcase NETDEV_CHANGELOWERSTATE:\n\tcase NETDEV_CHANGE_TX_QUEUE_LEN:\n\t\trtmsg_ifinfo_event(RTM_NEWLINK, dev, 0, rtnl_get_event(event),\n\t\t\t\t   GFP_KERNEL, NULL, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rtnetlink_dev_notifier = {\n\t.notifier_call\t= rtnetlink_event,\n};\n\n\nstatic int __net_init rtnetlink_net_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t\t= RTNLGRP_MAX,\n\t\t.input\t\t= rtnetlink_rcv,\n\t\t.cb_mutex\t= &rtnl_mutex,\n\t\t.flags\t\t= NL_CFG_F_NONROOT_RECV,\n\t\t.bind\t\t= rtnetlink_bind,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_ROUTE, &cfg);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tnet->rtnl = sk;\n\treturn 0;\n}\n\nstatic void __net_exit rtnetlink_net_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->rtnl);\n\tnet->rtnl = NULL;\n}\n\nstatic struct pernet_operations rtnetlink_net_ops = {\n\t.init = rtnetlink_net_init,\n\t.exit = rtnetlink_net_exit,\n};\n\nvoid __init rtnetlink_init(void)\n{\n\tif (register_pernet_subsys(&rtnetlink_net_ops))\n\t\tpanic(\"rtnetlink_init: cannot initialize rtnetlink\\n\");\n\n\tregister_netdevice_notifier(&rtnetlink_dev_notifier);\n\n\trtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,\n\t\t      rtnl_dump_ifinfo, 0);\n\trtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETNETCONF, NULL, rtnl_dump_all, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_NEWLINKPROP, rtnl_newlinkprop, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELLINKPROP, rtnl_dellinkprop, NULL, 0);\n\n\trtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, NULL, 0);\n\trtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, NULL, 0);\n\trtnl_register(PF_BRIDGE, RTM_GETNEIGH, rtnl_fdb_get, rtnl_fdb_dump, 0);\n\n\trtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, rtnl_bridge_getlink, 0);\n\trtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, NULL, 0);\n\trtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, NULL, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,\n\t\t      0);\n}\n"}, "4": {"id": 4, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Builtins */\n\n/*\n * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.\n * In the meantime, to support gcc < 10, we implement __has_builtin\n * by hand.\n */\n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 1, "line": 61}, "message": "expanded from macro 'rcu_dereference_rtnl'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 2, "line": 374}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 3, "line": 50}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 24, "file": 3, "line": 44}, "message": "expanded from macro '__READ_ONCE'"}, {"location": {"col": 6, "file": 0, "line": 5468}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 5468}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 5474}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 5474}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 5480}, "message": "Assuming 'kind' is equal to 2"}, {"location": {"col": 16, "file": 0, "line": 5480}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 5484}, "message": "'kind' is equal to 2"}, {"location": {"col": 6, "file": 0, "line": 5484}, "message": "Left side of '&&' is true"}, {"location": {"col": 19, "file": 0, "line": 5484}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 5484}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 5525}, "message": "Calling 'rtnl_get_link'"}, {"location": {"col": 6, "file": 0, "line": 162}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 162}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 165}, "message": "Left side of '||' is false"}, {"location": {"col": 2, "file": 1, "line": 61}, "message": "expanded from macro 'rcu_dereference_rtnl'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 2, "line": 374}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 3, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 21, "file": 3, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 3, "file": 4, "line": 282}, "message": "expanded from macro '__native_word'"}, {"location": {"col": 8, "file": 0, "line": 165}, "message": "Left side of '||' is false"}, {"location": {"col": 2, "file": 1, "line": 61}, "message": "expanded from macro 'rcu_dereference_rtnl'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 2, "line": 374}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 3, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 21, "file": 3, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 3, "file": 4, "line": 282}, "message": "expanded from macro '__native_word'"}, {"location": {"col": 8, "file": 0, "line": 165}, "message": "Left side of '||' is false"}, {"location": {"col": 2, "file": 1, "line": 61}, "message": "expanded from macro 'rcu_dereference_rtnl'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 2, "line": 374}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 3, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 21, "file": 3, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 3, "file": 4, "line": 282}, "message": "expanded from macro '__native_word'"}, {"location": {"col": 8, "file": 0, "line": 165}, "message": "Left side of '||' is true"}, {"location": {"col": 2, "file": 1, "line": 61}, "message": "expanded from macro 'rcu_dereference_rtnl'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 2, "line": 374}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 3, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 38, "file": 3, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 8, "file": 0, "line": 165}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 1, "line": 61}, "message": "expanded from macro 'rcu_dereference_rtnl'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 2, "line": 374}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 9, "file": 0, "line": 169}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/net/core/rtnetlink.c", "reportHash": "3ce07c81ebf0bb4b00b100f110a0da47", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2801}, "message": "Value stored to 'err' is never read"}, {"location": {"col": 2, "file": 0, "line": 2801}, "message": "Value stored to 'err' is never read"}], "macros": [], "notes": [], "path": "/src/net/core/rtnetlink.c", "reportHash": "a4c44d245d507fb6fbb8c869a676ebf0", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 2836}, "message": "Value stored to 'err' is never read"}, {"location": {"col": 2, "file": 0, "line": 2836}, "message": "Value stored to 'err' is never read"}], "macros": [], "notes": [], "path": "/src/net/core/rtnetlink.c", "reportHash": "a4c44d245d507fb6fbb8c869a676ebf0", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 0, "line": 3794}, "message": "Although the value stored to 'if_info_size' is used in the enclosing expression, the value is never actually read from 'if_info_size'"}, {"location": {"col": 19, "file": 0, "line": 3794}, "message": "Although the value stored to 'if_info_size' is used in the enclosing expression, the value is never actually read from 'if_info_size'"}], "macros": [], "notes": [], "path": "/src/net/core/rtnetlink.c", "reportHash": "bf9a490ef8e3f2fa36cc23ab05fbc8aa", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
