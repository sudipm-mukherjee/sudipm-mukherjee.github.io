<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/cpufreq/cpufreq.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/drivers/cpufreq/cpufreq.c\n *\n *  Copyright (C) 2001 Russell King\n *            (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>\n *            (C) 2013 Viresh Kumar <viresh.kumar@linaro.org>\n *\n *  Oct 2005 - Ashok Raj <ashok.raj@intel.com>\n *\tAdded handling for CPU hotplug\n *  Feb 2006 - Jacob Shin <jacob.shin@amd.com>\n *\tFix handling for CPU hotplug -- affected CPUs\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu_cooling.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/kernel_stat.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n#include <linux/tick.h>\n#include <trace/events/power.h>\n\nstatic LIST_HEAD(cpufreq_policy_list);\n\n/* Macros to iterate over CPU policies */\n#define for_each_suitable_policy(__policy, __active)\t\t\t \\\n\tlist_for_each_entry(__policy, &cpufreq_policy_list, policy_list) \\\n\t\tif ((__active) == !policy_is_inactive(__policy))\n\n#define for_each_active_policy(__policy)\t\t\\\n\tfor_each_suitable_policy(__policy, true)\n#define for_each_inactive_policy(__policy)\t\t\\\n\tfor_each_suitable_policy(__policy, false)\n\n#define for_each_policy(__policy)\t\t\t\\\n\tlist_for_each_entry(__policy, &cpufreq_policy_list, policy_list)\n\n/* Iterate over governors */\nstatic LIST_HEAD(cpufreq_governor_list);\n#define for_each_governor(__governor)\t\t\t\t\\\n\tlist_for_each_entry(__governor, &cpufreq_governor_list, governor_list)\n\nstatic char default_governor[CPUFREQ_NAME_LEN];\n\n/*\n * The \"cpufreq driver\" - the arch- or hardware-dependent low\n * level driver of CPUFreq support, and its spinlock. This lock\n * also protects the cpufreq_cpu_data array.\n */\nstatic struct cpufreq_driver *cpufreq_driver;\nstatic DEFINE_PER_CPU(struct cpufreq_policy *, cpufreq_cpu_data);\nstatic DEFINE_RWLOCK(cpufreq_driver_lock);\n\nstatic DEFINE_STATIC_KEY_FALSE(cpufreq_freq_invariance);\nbool cpufreq_supports_freq_invariance(void)\n{\n\treturn static_branch_likely(&cpufreq_freq_invariance);\n}\n\n/* Flag to suspend/resume CPUFreq governors */\nstatic bool cpufreq_suspended;\n\nstatic inline bool has_target(void)\n{\n\treturn cpufreq_driver->target_index || cpufreq_driver->target;\n}\n\n/* internal prototypes */\nstatic unsigned int __cpufreq_get(struct cpufreq_policy *policy);\nstatic int cpufreq_init_governor(struct cpufreq_policy *policy);\nstatic void cpufreq_exit_governor(struct cpufreq_policy *policy);\nstatic void cpufreq_governor_limits(struct cpufreq_policy *policy);\nstatic int cpufreq_set_policy(struct cpufreq_policy *policy,\n\t\t\t      struct cpufreq_governor *new_gov,\n\t\t\t      unsigned int new_pol);\n\n/*\n * Two notifier lists: the \"policy\" list is involved in the\n * validation process for a new CPU frequency policy; the\n * \"transition\" list for kernel code that needs to handle\n * changes to devices when the CPU clock speed changes.\n * The mutex locks both lists.\n */\nstatic BLOCKING_NOTIFIER_HEAD(cpufreq_policy_notifier_list);\nSRCU_NOTIFIER_HEAD_STATIC(cpufreq_transition_notifier_list);\n\nstatic int off __read_mostly;\nstatic int cpufreq_disabled(void)\n{\n\treturn off;\n}\nvoid disable_cpufreq(void)\n{\n\toff = 1;\n}\nstatic DEFINE_MUTEX(cpufreq_governor_mutex);\n\nbool have_governor_per_policy(void)\n{\n\treturn !!(cpufreq_driver->flags & CPUFREQ_HAVE_GOVERNOR_PER_POLICY);\n}\nEXPORT_SYMBOL_GPL(have_governor_per_policy);\n\nstatic struct kobject *cpufreq_global_kobject;\n\nstruct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy)\n{\n\tif (have_governor_per_policy())\n\t\treturn &policy->kobj;\n\telse\n\t\treturn cpufreq_global_kobject;\n}\nEXPORT_SYMBOL_GPL(get_governor_parent_kobj);\n\nstatic inline u64 get_cpu_idle_time_jiffy(unsigned int cpu, u64 *wall)\n{\n\tstruct kernel_cpustat kcpustat;\n\tu64 cur_wall_time;\n\tu64 idle_time;\n\tu64 busy_time;\n\n\tcur_wall_time = jiffies64_to_nsecs(get_jiffies_64());\n\n\tkcpustat_cpu_fetch(&kcpustat, cpu);\n\n\tbusy_time = kcpustat.cpustat[CPUTIME_USER];\n\tbusy_time += kcpustat.cpustat[CPUTIME_SYSTEM];\n\tbusy_time += kcpustat.cpustat[CPUTIME_IRQ];\n\tbusy_time += kcpustat.cpustat[CPUTIME_SOFTIRQ];\n\tbusy_time += kcpustat.cpustat[CPUTIME_STEAL];\n\tbusy_time += kcpustat.cpustat[CPUTIME_NICE];\n\n\tidle_time = cur_wall_time - busy_time;\n\tif (wall)\n\t\t*wall = div_u64(cur_wall_time, NSEC_PER_USEC);\n\n\treturn div_u64(idle_time, NSEC_PER_USEC);\n}\n\nu64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy)\n{\n\tu64 idle_time = get_cpu_idle_time_us(cpu, io_busy ? wall : NULL);\n\n\tif (idle_time == -1ULL)\n\t\treturn get_cpu_idle_time_jiffy(cpu, wall);\n\telse if (!io_busy)\n\t\tidle_time += get_cpu_iowait_time_us(cpu, wall);\n\n\treturn idle_time;\n}\nEXPORT_SYMBOL_GPL(get_cpu_idle_time);\n\n/*\n * This is a generic cpufreq init() routine which can be used by cpufreq\n * drivers of SMP systems. It will do following:\n * - validate & show freq table passed\n * - set policies transition latency\n * - policy->cpus with all possible CPUs\n */\nvoid cpufreq_generic_init(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_frequency_table *table,\n\t\tunsigned int transition_latency)\n{\n\tpolicy->freq_table = table;\n\tpolicy->cpuinfo.transition_latency = transition_latency;\n\n\t/*\n\t * The driver only supports the SMP configuration where all processors\n\t * share the clock and voltage and clock.\n\t */\n\tcpumask_setall(policy->cpus);\n}\nEXPORT_SYMBOL_GPL(cpufreq_generic_init);\n\nstruct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);\n\n\treturn policy && cpumask_test_cpu(cpu, policy->cpus) ? policy : NULL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_cpu_get_raw);\n\nunsigned int cpufreq_generic_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);\n\n\tif (!policy || IS_ERR(policy->clk)) {\n\t\tpr_err(\"%s: No %s associated to cpu: %d\\n\",\n\t\t       __func__, policy ? \"clk\" : \"policy\", cpu);\n\t\treturn 0;\n\t}\n\n\treturn clk_get_rate(policy->clk) / 1000;\n}\nEXPORT_SYMBOL_GPL(cpufreq_generic_get);\n\n/**\n * cpufreq_cpu_get - Return policy for a CPU and mark it as busy.\n * @cpu: CPU to find the policy for.\n *\n * Call cpufreq_cpu_get_raw() to obtain a cpufreq policy for @cpu and increment\n * the kobject reference counter of that policy.  Return a valid policy on\n * success or NULL on failure.\n *\n * The policy returned by this function has to be released with the help of\n * cpufreq_cpu_put() to balance its kobject reference counter properly.\n */\nstruct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = NULL;\n\tunsigned long flags;\n\n\tif (WARN_ON(cpu >= nr_cpu_ids))\n\t\treturn NULL;\n\n\t/* get the cpufreq driver */\n\tread_lock_irqsave(&cpufreq_driver_lock, flags);\n\n\tif (cpufreq_driver) {\n\t\t/* get the CPU */\n\t\tpolicy = cpufreq_cpu_get_raw(cpu);\n\t\tif (policy)\n\t\t\tkobject_get(&policy->kobj);\n\t}\n\n\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\treturn policy;\n}\nEXPORT_SYMBOL_GPL(cpufreq_cpu_get);\n\n/**\n * cpufreq_cpu_put - Decrement kobject usage counter for cpufreq policy.\n * @policy: cpufreq policy returned by cpufreq_cpu_get().\n */\nvoid cpufreq_cpu_put(struct cpufreq_policy *policy)\n{\n\tkobject_put(&policy->kobj);\n}\nEXPORT_SYMBOL_GPL(cpufreq_cpu_put);\n\n/**\n * cpufreq_cpu_release - Unlock a policy and decrement its usage counter.\n * @policy: cpufreq policy returned by cpufreq_cpu_acquire().\n */\nvoid cpufreq_cpu_release(struct cpufreq_policy *policy)\n{\n\tif (WARN_ON(!policy))\n\t\treturn;\n\n\tlockdep_assert_held(&policy->rwsem);\n\n\tup_write(&policy->rwsem);\n\n\tcpufreq_cpu_put(policy);\n}\n\n/**\n * cpufreq_cpu_acquire - Find policy for a CPU, mark it as busy and lock it.\n * @cpu: CPU to find the policy for.\n *\n * Call cpufreq_cpu_get() to get a reference on the cpufreq policy for @cpu and\n * if the policy returned by it is not NULL, acquire its rwsem for writing.\n * Return the policy if it is active or release it and return NULL otherwise.\n *\n * The policy returned by this function has to be released with the help of\n * cpufreq_cpu_release() in order to release its rwsem and balance its usage\n * counter properly.\n */\nstruct cpufreq_policy *cpufreq_cpu_acquire(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\n\tif (!policy)\n\t\treturn NULL;\n\n\tdown_write(&policy->rwsem);\n\n\tif (policy_is_inactive(policy)) {\n\t\tcpufreq_cpu_release(policy);\n\t\treturn NULL;\n\t}\n\n\treturn policy;\n}\n\n/*********************************************************************\n *            EXTERNALLY AFFECTING FREQUENCY CHANGES                 *\n *********************************************************************/\n\n/**\n * adjust_jiffies - Adjust the system \"loops_per_jiffy\".\n * @val: CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.\n * @ci: Frequency change information.\n *\n * This function alters the system \"loops_per_jiffy\" for the clock\n * speed change. Note that loops_per_jiffy cannot be updated on SMP\n * systems as each CPU might be scaled differently. So, use the arch\n * per-CPU loops_per_jiffy value wherever possible.\n */\nstatic void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)\n{\n#ifndef CONFIG_SMP\n\tstatic unsigned long l_p_j_ref;\n\tstatic unsigned int l_p_j_ref_freq;\n\n\tif (ci->flags & CPUFREQ_CONST_LOOPS)\n\t\treturn;\n\n\tif (!l_p_j_ref_freq) {\n\t\tl_p_j_ref = loops_per_jiffy;\n\t\tl_p_j_ref_freq = ci->old;\n\t\tpr_debug(\"saving %lu as reference value for loops_per_jiffy; freq is %u kHz\\n\",\n\t\t\t l_p_j_ref, l_p_j_ref_freq);\n\t}\n\tif (val == CPUFREQ_POSTCHANGE && ci->old != ci->new) {\n\t\tloops_per_jiffy = cpufreq_scale(l_p_j_ref, l_p_j_ref_freq,\n\t\t\t\t\t\t\t\tci->new);\n\t\tpr_debug(\"scaling loops_per_jiffy to %lu for frequency %u kHz\\n\",\n\t\t\t loops_per_jiffy, ci->new);\n\t}\n#endif\n}\n\n/**\n * cpufreq_notify_transition - Notify frequency transition and adjust jiffies.\n * @policy: cpufreq policy to enable fast frequency switching for.\n * @freqs: contain details of the frequency update.\n * @state: set to CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.\n *\n * This function calls the transition notifiers and adjust_jiffies().\n *\n * It is called twice on all CPU frequency changes that have external effects.\n */\nstatic void cpufreq_notify_transition(struct cpufreq_policy *policy,\n\t\t\t\t      struct cpufreq_freqs *freqs,\n\t\t\t\t      unsigned int state)\n{\n\tint cpu;\n\n\tBUG_ON(irqs_disabled());\n\n\tif (cpufreq_disabled())\n\t\treturn;\n\n\tfreqs->policy = policy;\n\tfreqs->flags = cpufreq_driver->flags;\n\tpr_debug(\"notification %u of frequency transition to %u kHz\\n\",\n\t\t state, freqs->new);\n\n\tswitch (state) {\n\tcase CPUFREQ_PRECHANGE:\n\t\t/*\n\t\t * Detect if the driver reported a value as \"old frequency\"\n\t\t * which is not equal to what the cpufreq core thinks is\n\t\t * \"old frequency\".\n\t\t */\n\t\tif (policy->cur && policy->cur != freqs->old) {\n\t\t\tpr_debug(\"Warning: CPU frequency is %u, cpufreq assumed %u kHz\\n\",\n\t\t\t\t freqs->old, policy->cur);\n\t\t\tfreqs->old = policy->cur;\n\t\t}\n\n\t\tsrcu_notifier_call_chain(&cpufreq_transition_notifier_list,\n\t\t\t\t\t CPUFREQ_PRECHANGE, freqs);\n\n\t\tadjust_jiffies(CPUFREQ_PRECHANGE, freqs);\n\t\tbreak;\n\n\tcase CPUFREQ_POSTCHANGE:\n\t\tadjust_jiffies(CPUFREQ_POSTCHANGE, freqs);\n\t\tpr_debug(\"FREQ: %u - CPUs: %*pbl\\n\", freqs->new,\n\t\t\t cpumask_pr_args(policy->cpus));\n\n\t\tfor_each_cpu(cpu, policy->cpus)\n\t\t\ttrace_cpu_frequency(freqs->new, cpu);\n\n\t\tsrcu_notifier_call_chain(&cpufreq_transition_notifier_list,\n\t\t\t\t\t CPUFREQ_POSTCHANGE, freqs);\n\n\t\tcpufreq_stats_record_transition(policy, freqs->new);\n\t\tpolicy->cur = freqs->new;\n\t}\n}\n\n/* Do post notifications when there are chances that transition has failed */\nstatic void cpufreq_notify_post_transition(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs, int transition_failed)\n{\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);\n\tif (!transition_failed)\n\t\treturn;\n\n\tswap(freqs->old, freqs->new);\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);\n}\n\nvoid cpufreq_freq_transition_begin(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs)\n{\n\n\t/*\n\t * Catch double invocations of _begin() which lead to self-deadlock.\n\t * ASYNC_NOTIFICATION drivers are left out because the cpufreq core\n\t * doesn't invoke _begin() on their behalf, and hence the chances of\n\t * double invocations are very low. Moreover, there are scenarios\n\t * where these checks can emit false-positive warnings in these\n\t * drivers; so we avoid that by skipping them altogether.\n\t */\n\tWARN_ON(!(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION)\n\t\t\t\t&& current == policy->transition_task);\n\nwait:\n\twait_event(policy->transition_wait, !policy->transition_ongoing);\n\n\tspin_lock(&policy->transition_lock);\n\n\tif (unlikely(policy->transition_ongoing)) {\n\t\tspin_unlock(&policy->transition_lock);\n\t\tgoto wait;\n\t}\n\n\tpolicy->transition_ongoing = true;\n\tpolicy->transition_task = current;\n\n\tspin_unlock(&policy->transition_lock);\n\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);\n}\nEXPORT_SYMBOL_GPL(cpufreq_freq_transition_begin);\n\nvoid cpufreq_freq_transition_end(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs, int transition_failed)\n{\n\tif (WARN_ON(!policy->transition_ongoing))\n\t\treturn;\n\n\tcpufreq_notify_post_transition(policy, freqs, transition_failed);\n\n\tarch_set_freq_scale(policy->related_cpus,\n\t\t\t    policy->cur,\n\t\t\t    policy->cpuinfo.max_freq);\n\n\tpolicy->transition_ongoing = false;\n\tpolicy->transition_task = NULL;\n\n\twake_up(&policy->transition_wait);\n}\nEXPORT_SYMBOL_GPL(cpufreq_freq_transition_end);\n\n/*\n * Fast frequency switching status count.  Positive means \"enabled\", negative\n * means \"disabled\" and 0 means \"not decided yet\".\n */\nstatic int cpufreq_fast_switch_count;\nstatic DEFINE_MUTEX(cpufreq_fast_switch_lock);\n\nstatic void cpufreq_list_transition_notifiers(void)\n{\n\tstruct notifier_block *nb;\n\n\tpr_info(\"Registered transition notifiers:\\n\");\n\n\tmutex_lock(&cpufreq_transition_notifier_list.mutex);\n\n\tfor (nb = cpufreq_transition_notifier_list.head; nb; nb = nb->next)\n\t\tpr_info(\"%pS\\n\", nb->notifier_call);\n\n\tmutex_unlock(&cpufreq_transition_notifier_list.mutex);\n}\n\n/**\n * cpufreq_enable_fast_switch - Enable fast frequency switching for policy.\n * @policy: cpufreq policy to enable fast frequency switching for.\n *\n * Try to enable fast frequency switching for @policy.\n *\n * The attempt will fail if there is at least one transition notifier registered\n * at this point, as fast frequency switching is quite fundamentally at odds\n * with transition notifiers.  Thus if successful, it will make registration of\n * transition notifiers fail going forward.\n */\nvoid cpufreq_enable_fast_switch(struct cpufreq_policy *policy)\n{\n\tlockdep_assert_held(&policy->rwsem);\n\n\tif (!policy->fast_switch_possible)\n\t\treturn;\n\n\tmutex_lock(&cpufreq_fast_switch_lock);\n\tif (cpufreq_fast_switch_count >= 0) {\n\t\tcpufreq_fast_switch_count++;\n\t\tpolicy->fast_switch_enabled = true;\n\t} else {\n\t\tpr_warn(\"CPU%u: Fast frequency switching not enabled\\n\",\n\t\t\tpolicy->cpu);\n\t\tcpufreq_list_transition_notifiers();\n\t}\n\tmutex_unlock(&cpufreq_fast_switch_lock);\n}\nEXPORT_SYMBOL_GPL(cpufreq_enable_fast_switch);\n\n/**\n * cpufreq_disable_fast_switch - Disable fast frequency switching for policy.\n * @policy: cpufreq policy to disable fast frequency switching for.\n */\nvoid cpufreq_disable_fast_switch(struct cpufreq_policy *policy)\n{\n\tmutex_lock(&cpufreq_fast_switch_lock);\n\tif (policy->fast_switch_enabled) {\n\t\tpolicy->fast_switch_enabled = false;\n\t\tif (!WARN_ON(cpufreq_fast_switch_count <= 0))\n\t\t\tcpufreq_fast_switch_count--;\n\t}\n\tmutex_unlock(&cpufreq_fast_switch_lock);\n}\nEXPORT_SYMBOL_GPL(cpufreq_disable_fast_switch);\n\n/**\n * cpufreq_driver_resolve_freq - Map a target frequency to a driver-supported\n * one.\n * @policy: associated policy to interrogate\n * @target_freq: target frequency to resolve.\n *\n * The target to driver frequency mapping is cached in the policy.\n *\n * Return: Lowest driver-supported frequency greater than or equal to the\n * given target_freq, subject to policy (min/max) and driver limitations.\n */\nunsigned int cpufreq_driver_resolve_freq(struct cpufreq_policy *policy,\n\t\t\t\t\t unsigned int target_freq)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\tpolicy->cached_target_freq = target_freq;\n\n\tif (cpufreq_driver->target_index) {\n\t\tunsigned int idx;\n\n\t\tidx = cpufreq_frequency_table_target(policy, target_freq,\n\t\t\t\t\t\t     CPUFREQ_RELATION_L);\n\t\tpolicy->cached_resolved_idx = idx;\n\t\treturn policy->freq_table[idx].frequency;\n\t}\n\n\tif (cpufreq_driver->resolve_freq)\n\t\treturn cpufreq_driver->resolve_freq(policy, target_freq);\n\n\treturn target_freq;\n}\nEXPORT_SYMBOL_GPL(cpufreq_driver_resolve_freq);\n\nunsigned int cpufreq_policy_transition_delay_us(struct cpufreq_policy *policy)\n{\n\tunsigned int latency;\n\n\tif (policy->transition_delay_us)\n\t\treturn policy->transition_delay_us;\n\n\tlatency = policy->cpuinfo.transition_latency / NSEC_PER_USEC;\n\tif (latency) {\n\t\t/*\n\t\t * For platforms that can change the frequency very fast (< 10\n\t\t * us), the above formula gives a decent transition delay. But\n\t\t * for platforms where transition_latency is in milliseconds, it\n\t\t * ends up giving unrealistic values.\n\t\t *\n\t\t * Cap the default transition delay to 10 ms, which seems to be\n\t\t * a reasonable amount of time after which we should reevaluate\n\t\t * the frequency.\n\t\t */\n\t\treturn min(latency * LATENCY_MULTIPLIER, (unsigned int)10000);\n\t}\n\n\treturn LATENCY_MULTIPLIER;\n}\nEXPORT_SYMBOL_GPL(cpufreq_policy_transition_delay_us);\n\n/*********************************************************************\n *                          SYSFS INTERFACE                          *\n *********************************************************************/\nstatic ssize_t show_boost(struct kobject *kobj,\n\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", cpufreq_driver->boost_enabled);\n}\n\nstatic ssize_t store_boost(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint ret, enable;\n\n\tret = sscanf(buf, \"%d\", &enable);\n\tif (ret != 1 || enable < 0 || enable > 1)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_boost_trigger_state(enable)) {\n\t\tpr_err(\"%s: Cannot %s BOOST!\\n\",\n\t\t       __func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"%s: cpufreq BOOST %s\\n\",\n\t\t __func__, enable ? \"enabled\" : \"disabled\");\n\n\treturn count;\n}\ndefine_one_global_rw(boost);\n\nstatic struct cpufreq_governor *find_governor(const char *str_governor)\n{\n\tstruct cpufreq_governor *t;\n\n\tfor_each_governor(t)\n\t\tif (!strncasecmp(str_governor, t->name, CPUFREQ_NAME_LEN))\n\t\t\treturn t;\n\n\treturn NULL;\n}\n\nstatic struct cpufreq_governor *get_governor(const char *str_governor)\n{\n\tstruct cpufreq_governor *t;\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\tt = find_governor(str_governor);\n\tif (!t)\n\t\tgoto unlock;\n\n\tif (!try_module_get(t->owner))\n\t\tt = NULL;\n\nunlock:\n\tmutex_unlock(&cpufreq_governor_mutex);\n\n\treturn t;\n}\n\nstatic unsigned int cpufreq_parse_policy(char *str_governor)\n{\n\tif (!strncasecmp(str_governor, \"performance\", CPUFREQ_NAME_LEN))\n\t\treturn CPUFREQ_POLICY_PERFORMANCE;\n\n\tif (!strncasecmp(str_governor, \"powersave\", CPUFREQ_NAME_LEN))\n\t\treturn CPUFREQ_POLICY_POWERSAVE;\n\n\treturn CPUFREQ_POLICY_UNKNOWN;\n}\n\n/**\n * cpufreq_parse_governor - parse a governor string only for has_target()\n * @str_governor: Governor name.\n */\nstatic struct cpufreq_governor *cpufreq_parse_governor(char *str_governor)\n{\n\tstruct cpufreq_governor *t;\n\n\tt = get_governor(str_governor);\n\tif (t)\n\t\treturn t;\n\n\tif (request_module(\"cpufreq_%s\", str_governor))\n\t\treturn NULL;\n\n\treturn get_governor(str_governor);\n}\n\n/*\n * cpufreq_per_cpu_attr_read() / show_##file_name() -\n * print out cpufreq information\n *\n * Write out information from cpufreq_driver->policy[cpu]; object must be\n * \"unsigned int\".\n */\n\n#define show_one(file_name, object)\t\t\t\\\nstatic ssize_t show_##file_name\t\t\t\t\\\n(struct cpufreq_policy *policy, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%u\\n\", policy->object);\t\\\n}\n\nshow_one(cpuinfo_min_freq, cpuinfo.min_freq);\nshow_one(cpuinfo_max_freq, cpuinfo.max_freq);\nshow_one(cpuinfo_transition_latency, cpuinfo.transition_latency);\nshow_one(scaling_min_freq, min);\nshow_one(scaling_max_freq, max);\n\n__weak unsigned int arch_freq_get_on_cpu(int cpu)\n{\n\treturn 0;\n}\n\nstatic ssize_t show_scaling_cur_freq(struct cpufreq_policy *policy, char *buf)\n{\n\tssize_t ret;\n\tunsigned int freq;\n\n\tfreq = arch_freq_get_on_cpu(policy->cpu);\n\tif (freq)\n\t\tret = sprintf(buf, \"%u\\n\", freq);\n\telse if (cpufreq_driver->setpolicy && cpufreq_driver->get)\n\t\tret = sprintf(buf, \"%u\\n\", cpufreq_driver->get(policy->cpu));\n\telse\n\t\tret = sprintf(buf, \"%u\\n\", policy->cur);\n\treturn ret;\n}\n\n/*\n * cpufreq_per_cpu_attr_write() / store_##file_name() - sysfs write access\n */\n#define store_one(file_name, object)\t\t\t\\\nstatic ssize_t store_##file_name\t\t\t\t\t\\\n(struct cpufreq_policy *policy, const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = sscanf(buf, \"%lu\", &val);\t\t\t\t\t\\\n\tif (ret != 1)\t\t\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = freq_qos_update_request(policy->object##_freq_req, val);\\\n\treturn ret >= 0 ? count : ret;\t\t\t\t\t\\\n}\n\nstore_one(scaling_min_freq, min);\nstore_one(scaling_max_freq, max);\n\n/*\n * show_cpuinfo_cur_freq - current CPU frequency as detected by hardware\n */\nstatic ssize_t show_cpuinfo_cur_freq(struct cpufreq_policy *policy,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned int cur_freq = __cpufreq_get(policy);\n\n\tif (cur_freq)\n\t\treturn sprintf(buf, \"%u\\n\", cur_freq);\n\n\treturn sprintf(buf, \"<unknown>\\n\");\n}\n\n/*\n * show_scaling_governor - show the current policy for the specified CPU\n */\nstatic ssize_t show_scaling_governor(struct cpufreq_policy *policy, char *buf)\n{\n\tif (policy->policy == CPUFREQ_POLICY_POWERSAVE)\n\t\treturn sprintf(buf, \"powersave\\n\");\n\telse if (policy->policy == CPUFREQ_POLICY_PERFORMANCE)\n\t\treturn sprintf(buf, \"performance\\n\");\n\telse if (policy->governor)\n\t\treturn scnprintf(buf, CPUFREQ_NAME_PLEN, \"%s\\n\",\n\t\t\t\tpolicy->governor->name);\n\treturn -EINVAL;\n}\n\n/*\n * store_scaling_governor - store policy for the specified CPU\n */\nstatic ssize_t store_scaling_governor(struct cpufreq_policy *policy,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tchar str_governor[16];\n\tint ret;\n\n\tret = sscanf(buf, \"%15s\", str_governor);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_driver->setpolicy) {\n\t\tunsigned int new_pol;\n\n\t\tnew_pol = cpufreq_parse_policy(str_governor);\n\t\tif (!new_pol)\n\t\t\treturn -EINVAL;\n\n\t\tret = cpufreq_set_policy(policy, NULL, new_pol);\n\t} else {\n\t\tstruct cpufreq_governor *new_gov;\n\n\t\tnew_gov = cpufreq_parse_governor(str_governor);\n\t\tif (!new_gov)\n\t\t\treturn -EINVAL;\n\n\t\tret = cpufreq_set_policy(policy, new_gov,\n\t\t\t\t\t CPUFREQ_POLICY_UNKNOWN);\n\n\t\tmodule_put(new_gov->owner);\n\t}\n\n\treturn ret ? ret : count;\n}\n\n/*\n * show_scaling_driver - show the cpufreq driver currently loaded\n */\nstatic ssize_t show_scaling_driver(struct cpufreq_policy *policy, char *buf)\n{\n\treturn scnprintf(buf, CPUFREQ_NAME_PLEN, \"%s\\n\", cpufreq_driver->name);\n}\n\n/*\n * show_scaling_available_governors - show the available CPUfreq governors\n */\nstatic ssize_t show_scaling_available_governors(struct cpufreq_policy *policy,\n\t\t\t\t\t\tchar *buf)\n{\n\tssize_t i = 0;\n\tstruct cpufreq_governor *t;\n\n\tif (!has_target()) {\n\t\ti += sprintf(buf, \"performance powersave\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\tfor_each_governor(t) {\n\t\tif (i >= (ssize_t) ((PAGE_SIZE / sizeof(char))\n\t\t    - (CPUFREQ_NAME_LEN + 2)))\n\t\t\tbreak;\n\t\ti += scnprintf(&buf[i], CPUFREQ_NAME_PLEN, \"%s \", t->name);\n\t}\n\tmutex_unlock(&cpufreq_governor_mutex);\nout:\n\ti += sprintf(&buf[i], \"\\n\");\n\treturn i;\n}\n\nssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf)\n{\n\tssize_t i = 0;\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\tif (i)\n\t\t\ti += scnprintf(&buf[i], (PAGE_SIZE - i - 2), \" \");\n\t\ti += scnprintf(&buf[i], (PAGE_SIZE - i - 2), \"%u\", cpu);\n\t\tif (i >= (PAGE_SIZE - 5))\n\t\t\tbreak;\n\t}\n\ti += sprintf(&buf[i], \"\\n\");\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(cpufreq_show_cpus);\n\n/*\n * show_related_cpus - show the CPUs affected by each transition even if\n * hw coordination is in use\n */\nstatic ssize_t show_related_cpus(struct cpufreq_policy *policy, char *buf)\n{\n\treturn cpufreq_show_cpus(policy->related_cpus, buf);\n}\n\n/*\n * show_affected_cpus - show the CPUs affected by each transition\n */\nstatic ssize_t show_affected_cpus(struct cpufreq_policy *policy, char *buf)\n{\n\treturn cpufreq_show_cpus(policy->cpus, buf);\n}\n\nstatic ssize_t store_scaling_setspeed(struct cpufreq_policy *policy,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned int freq = 0;\n\tunsigned int ret;\n\n\tif (!policy->governor || !policy->governor->store_setspeed)\n\t\treturn -EINVAL;\n\n\tret = sscanf(buf, \"%u\", &freq);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tpolicy->governor->store_setspeed(policy, freq);\n\n\treturn count;\n}\n\nstatic ssize_t show_scaling_setspeed(struct cpufreq_policy *policy, char *buf)\n{\n\tif (!policy->governor || !policy->governor->show_setspeed)\n\t\treturn sprintf(buf, \"<unsupported>\\n\");\n\n\treturn policy->governor->show_setspeed(policy, buf);\n}\n\n/*\n * show_bios_limit - show the current cpufreq HW/BIOS limitation\n */\nstatic ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)\n{\n\tunsigned int limit;\n\tint ret;\n\tret = cpufreq_driver->bios_limit(policy->cpu, &limit);\n\tif (!ret)\n\t\treturn sprintf(buf, \"%u\\n\", limit);\n\treturn sprintf(buf, \"%u\\n\", policy->cpuinfo.max_freq);\n}\n\ncpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);\ncpufreq_freq_attr_ro(cpuinfo_min_freq);\ncpufreq_freq_attr_ro(cpuinfo_max_freq);\ncpufreq_freq_attr_ro(cpuinfo_transition_latency);\ncpufreq_freq_attr_ro(scaling_available_governors);\ncpufreq_freq_attr_ro(scaling_driver);\ncpufreq_freq_attr_ro(scaling_cur_freq);\ncpufreq_freq_attr_ro(bios_limit);\ncpufreq_freq_attr_ro(related_cpus);\ncpufreq_freq_attr_ro(affected_cpus);\ncpufreq_freq_attr_rw(scaling_min_freq);\ncpufreq_freq_attr_rw(scaling_max_freq);\ncpufreq_freq_attr_rw(scaling_governor);\ncpufreq_freq_attr_rw(scaling_setspeed);\n\nstatic struct attribute *default_attrs[] = {\n\t&cpuinfo_min_freq.attr,\n\t&cpuinfo_max_freq.attr,\n\t&cpuinfo_transition_latency.attr,\n\t&scaling_min_freq.attr,\n\t&scaling_max_freq.attr,\n\t&affected_cpus.attr,\n\t&related_cpus.attr,\n\t&scaling_governor.attr,\n\t&scaling_driver.attr,\n\t&scaling_available_governors.attr,\n\t&scaling_setspeed.attr,\n\tNULL\n};\n\n#define to_policy(k) container_of(k, struct cpufreq_policy, kobj)\n#define to_attr(a) container_of(a, struct freq_attr, attr)\n\nstatic ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tstruct cpufreq_policy *policy = to_policy(kobj);\n\tstruct freq_attr *fattr = to_attr(attr);\n\tssize_t ret;\n\n\tif (!fattr->show)\n\t\treturn -EIO;\n\n\tdown_read(&policy->rwsem);\n\tret = fattr->show(policy, buf);\n\tup_read(&policy->rwsem);\n\n\treturn ret;\n}\n\nstatic ssize_t store(struct kobject *kobj, struct attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct cpufreq_policy *policy = to_policy(kobj);\n\tstruct freq_attr *fattr = to_attr(attr);\n\tssize_t ret = -EINVAL;\n\n\tif (!fattr->store)\n\t\treturn -EIO;\n\n\t/*\n\t * cpus_read_trylock() is used here to work around a circular lock\n\t * dependency problem with respect to the cpufreq_register_driver().\n\t */\n\tif (!cpus_read_trylock())\n\t\treturn -EBUSY;\n\n\tif (cpu_online(policy->cpu)) {\n\t\tdown_write(&policy->rwsem);\n\t\tret = fattr->store(policy, buf, count);\n\t\tup_write(&policy->rwsem);\n\t}\n\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\nstatic void cpufreq_sysfs_release(struct kobject *kobj)\n{\n\tstruct cpufreq_policy *policy = to_policy(kobj);\n\tpr_debug(\"last reference is dropped\\n\");\n\tcomplete(&policy->kobj_unregister);\n}\n\nstatic const struct sysfs_ops sysfs_ops = {\n\t.show\t= show,\n\t.store\t= store,\n};\n\nstatic struct kobj_type ktype_cpufreq = {\n\t.sysfs_ops\t= &sysfs_ops,\n\t.default_attrs\t= default_attrs,\n\t.release\t= cpufreq_sysfs_release,\n};\n\nstatic void add_cpu_dev_symlink(struct cpufreq_policy *policy, unsigned int cpu)\n{\n\tstruct device *dev = get_cpu_device(cpu);\n\n\tif (unlikely(!dev))\n\t\treturn;\n\n\tif (cpumask_test_and_set_cpu(cpu, policy->real_cpus))\n\t\treturn;\n\n\tdev_dbg(dev, \"%s: Adding symlink\\n\", __func__);\n\tif (sysfs_create_link(&dev->kobj, &policy->kobj, \"cpufreq\"))\n\t\tdev_err(dev, \"cpufreq symlink creation failed\\n\");\n}\n\nstatic void remove_cpu_dev_symlink(struct cpufreq_policy *policy,\n\t\t\t\t   struct device *dev)\n{\n\tdev_dbg(dev, \"%s: Removing symlink\\n\", __func__);\n\tsysfs_remove_link(&dev->kobj, \"cpufreq\");\n}\n\nstatic int cpufreq_add_dev_interface(struct cpufreq_policy *policy)\n{\n\tstruct freq_attr **drv_attr;\n\tint ret = 0;\n\n\t/* set up files for this cpu device */\n\tdrv_attr = cpufreq_driver->attr;\n\twhile (drv_attr && *drv_attr) {\n\t\tret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdrv_attr++;\n\t}\n\tif (cpufreq_driver->get) {\n\t\tret = sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sysfs_create_file(&policy->kobj, &scaling_cur_freq.attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cpufreq_driver->bios_limit) {\n\t\tret = sysfs_create_file(&policy->kobj, &bios_limit.attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpufreq_init_policy(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_governor *gov = NULL;\n\tunsigned int pol = CPUFREQ_POLICY_UNKNOWN;\n\tint ret;\n\n\tif (has_target()) {\n\t\t/* Update policy governor to the one used before hotplug. */\n\t\tgov = get_governor(policy->last_governor);\n\t\tif (gov) {\n\t\t\tpr_debug(\"Restoring governor %s for cpu %d\\n\",\n\t\t\t\t gov->name, policy->cpu);\n\t\t} else {\n\t\t\tgov = get_governor(default_governor);\n\t\t}\n\n\t\tif (!gov) {\n\t\t\tgov = cpufreq_default_governor();\n\t\t\t__module_get(gov->owner);\n\t\t}\n\n\t} else {\n\n\t\t/* Use the default policy if there is no last_policy. */\n\t\tif (policy->last_policy) {\n\t\t\tpol = policy->last_policy;\n\t\t} else {\n\t\t\tpol = cpufreq_parse_policy(default_governor);\n\t\t\t/*\n\t\t\t * In case the default governor is neither \"performance\"\n\t\t\t * nor \"powersave\", fall back to the initial policy\n\t\t\t * value set by the driver.\n\t\t\t */\n\t\t\tif (pol == CPUFREQ_POLICY_UNKNOWN)\n\t\t\t\tpol = policy->policy;\n\t\t}\n\t\tif (pol != CPUFREQ_POLICY_PERFORMANCE &&\n\t\t    pol != CPUFREQ_POLICY_POWERSAVE)\n\t\t\treturn -ENODATA;\n\t}\n\n\tret = cpufreq_set_policy(policy, gov, pol);\n\tif (gov)\n\t\tmodule_put(gov->owner);\n\n\treturn ret;\n}\n\nstatic int cpufreq_add_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)\n{\n\tint ret = 0;\n\n\t/* Has this CPU been taken care of already? */\n\tif (cpumask_test_cpu(cpu, policy->cpus))\n\t\treturn 0;\n\n\tdown_write(&policy->rwsem);\n\tif (has_target())\n\t\tcpufreq_stop_governor(policy);\n\n\tcpumask_set_cpu(cpu, policy->cpus);\n\n\tif (has_target()) {\n\t\tret = cpufreq_start_governor(policy);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: Failed to start governor\\n\", __func__);\n\t}\n\tup_write(&policy->rwsem);\n\treturn ret;\n}\n\nvoid refresh_frequency_limits(struct cpufreq_policy *policy)\n{\n\tif (!policy_is_inactive(policy)) {\n\t\tpr_debug(\"updating policy for CPU %u\\n\", policy->cpu);\n\n\t\tcpufreq_set_policy(policy, policy->governor, policy->policy);\n\t}\n}\nEXPORT_SYMBOL(refresh_frequency_limits);\n\nstatic void handle_update(struct work_struct *work)\n{\n\tstruct cpufreq_policy *policy =\n\t\tcontainer_of(work, struct cpufreq_policy, update);\n\n\tpr_debug(\"handle_update for cpu %u called\\n\", policy->cpu);\n\tdown_write(&policy->rwsem);\n\trefresh_frequency_limits(policy);\n\tup_write(&policy->rwsem);\n}\n\nstatic int cpufreq_notifier_min(struct notifier_block *nb, unsigned long freq,\n\t\t\t\tvoid *data)\n{\n\tstruct cpufreq_policy *policy = container_of(nb, struct cpufreq_policy, nb_min);\n\n\tschedule_work(&policy->update);\n\treturn 0;\n}\n\nstatic int cpufreq_notifier_max(struct notifier_block *nb, unsigned long freq,\n\t\t\t\tvoid *data)\n{\n\tstruct cpufreq_policy *policy = container_of(nb, struct cpufreq_policy, nb_max);\n\n\tschedule_work(&policy->update);\n\treturn 0;\n}\n\nstatic void cpufreq_policy_put_kobj(struct cpufreq_policy *policy)\n{\n\tstruct kobject *kobj;\n\tstruct completion *cmp;\n\n\tdown_write(&policy->rwsem);\n\tcpufreq_stats_free_table(policy);\n\tkobj = &policy->kobj;\n\tcmp = &policy->kobj_unregister;\n\tup_write(&policy->rwsem);\n\tkobject_put(kobj);\n\n\t/*\n\t * We need to make sure that the underlying kobj is\n\t * actually not referenced anymore by anybody before we\n\t * proceed with unloading.\n\t */\n\tpr_debug(\"waiting for dropping of refcount\\n\");\n\twait_for_completion(cmp);\n\tpr_debug(\"wait complete\\n\");\n}\n\nstatic struct cpufreq_policy *cpufreq_policy_alloc(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tstruct device *dev = get_cpu_device(cpu);\n\tint ret;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tpolicy = kzalloc(sizeof(*policy), GFP_KERNEL);\n\tif (!policy)\n\t\treturn NULL;\n\n\tif (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))\n\t\tgoto err_free_policy;\n\n\tif (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))\n\t\tgoto err_free_cpumask;\n\n\tif (!zalloc_cpumask_var(&policy->real_cpus, GFP_KERNEL))\n\t\tgoto err_free_rcpumask;\n\n\tret = kobject_init_and_add(&policy->kobj, &ktype_cpufreq,\n\t\t\t\t   cpufreq_global_kobject, \"policy%u\", cpu);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: failed to init policy->kobj: %d\\n\", __func__, ret);\n\t\t/*\n\t\t * The entire policy object will be freed below, but the extra\n\t\t * memory allocated for the kobject name needs to be freed by\n\t\t * releasing the kobject.\n\t\t */\n\t\tkobject_put(&policy->kobj);\n\t\tgoto err_free_real_cpus;\n\t}\n\n\tfreq_constraints_init(&policy->constraints);\n\n\tpolicy->nb_min.notifier_call = cpufreq_notifier_min;\n\tpolicy->nb_max.notifier_call = cpufreq_notifier_max;\n\n\tret = freq_qos_add_notifier(&policy->constraints, FREQ_QOS_MIN,\n\t\t\t\t    &policy->nb_min);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register MIN QoS notifier: %d (%*pbl)\\n\",\n\t\t\tret, cpumask_pr_args(policy->cpus));\n\t\tgoto err_kobj_remove;\n\t}\n\n\tret = freq_qos_add_notifier(&policy->constraints, FREQ_QOS_MAX,\n\t\t\t\t    &policy->nb_max);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register MAX QoS notifier: %d (%*pbl)\\n\",\n\t\t\tret, cpumask_pr_args(policy->cpus));\n\t\tgoto err_min_qos_notifier;\n\t}\n\n\tINIT_LIST_HEAD(&policy->policy_list);\n\tinit_rwsem(&policy->rwsem);\n\tspin_lock_init(&policy->transition_lock);\n\tinit_waitqueue_head(&policy->transition_wait);\n\tinit_completion(&policy->kobj_unregister);\n\tINIT_WORK(&policy->update, handle_update);\n\n\tpolicy->cpu = cpu;\n\treturn policy;\n\nerr_min_qos_notifier:\n\tfreq_qos_remove_notifier(&policy->constraints, FREQ_QOS_MIN,\n\t\t\t\t &policy->nb_min);\nerr_kobj_remove:\n\tcpufreq_policy_put_kobj(policy);\nerr_free_real_cpus:\n\tfree_cpumask_var(policy->real_cpus);\nerr_free_rcpumask:\n\tfree_cpumask_var(policy->related_cpus);\nerr_free_cpumask:\n\tfree_cpumask_var(policy->cpus);\nerr_free_policy:\n\tkfree(policy);\n\n\treturn NULL;\n}\n\nstatic void cpufreq_policy_free(struct cpufreq_policy *policy)\n{\n\tunsigned long flags;\n\tint cpu;\n\n\t/* Remove policy from list */\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tlist_del(&policy->policy_list);\n\n\tfor_each_cpu(cpu, policy->related_cpus)\n\t\tper_cpu(cpufreq_cpu_data, cpu) = NULL;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tfreq_qos_remove_notifier(&policy->constraints, FREQ_QOS_MAX,\n\t\t\t\t &policy->nb_max);\n\tfreq_qos_remove_notifier(&policy->constraints, FREQ_QOS_MIN,\n\t\t\t\t &policy->nb_min);\n\n\t/* Cancel any pending policy->update work before freeing the policy. */\n\tcancel_work_sync(&policy->update);\n\n\tif (policy->max_freq_req) {\n\t\t/*\n\t\t * CPUFREQ_CREATE_POLICY notification is sent only after\n\t\t * successfully adding max_freq_req request.\n\t\t */\n\t\tblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\n\t\t\t\t\t     CPUFREQ_REMOVE_POLICY, policy);\n\t\tfreq_qos_remove_request(policy->max_freq_req);\n\t}\n\n\tfreq_qos_remove_request(policy->min_freq_req);\n\tkfree(policy->min_freq_req);\n\n\tcpufreq_policy_put_kobj(policy);\n\tfree_cpumask_var(policy->real_cpus);\n\tfree_cpumask_var(policy->related_cpus);\n\tfree_cpumask_var(policy->cpus);\n\tkfree(policy);\n}\n\nstatic int cpufreq_online(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tbool new_policy;\n\tunsigned long flags;\n\tunsigned int j;\n\tint ret;\n\n\tpr_debug(\"%s: bringing CPU%u online\\n\", __func__, cpu);\n\n\t/* Check if this CPU already has a policy to manage it */\n\tpolicy = per_cpu(cpufreq_cpu_data, cpu);\n\tif (policy) {\n\t\tWARN_ON(!cpumask_test_cpu(cpu, policy->related_cpus));\n\t\tif (!policy_is_inactive(policy))\n\t\t\treturn cpufreq_add_policy_cpu(policy, cpu);\n\n\t\t/* This is the only online CPU for the policy.  Start over. */\n\t\tnew_policy = false;\n\t\tdown_write(&policy->rwsem);\n\t\tpolicy->cpu = cpu;\n\t\tpolicy->governor = NULL;\n\t\tup_write(&policy->rwsem);\n\t} else {\n\t\tnew_policy = true;\n\t\tpolicy = cpufreq_policy_alloc(cpu);\n\t\tif (!policy)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!new_policy && cpufreq_driver->online) {\n\t\tret = cpufreq_driver->online(policy);\n\t\tif (ret) {\n\t\t\tpr_debug(\"%s: %d: initialization failed\\n\", __func__,\n\t\t\t\t __LINE__);\n\t\t\tgoto out_exit_policy;\n\t\t}\n\n\t\t/* Recover policy->cpus using related_cpus */\n\t\tcpumask_copy(policy->cpus, policy->related_cpus);\n\t} else {\n\t\tcpumask_copy(policy->cpus, cpumask_of(cpu));\n\n\t\t/*\n\t\t * Call driver. From then on the cpufreq must be able\n\t\t * to accept all calls to ->verify and ->setpolicy for this CPU.\n\t\t */\n\t\tret = cpufreq_driver->init(policy);\n\t\tif (ret) {\n\t\t\tpr_debug(\"%s: %d: initialization failed\\n\", __func__,\n\t\t\t\t __LINE__);\n\t\t\tgoto out_free_policy;\n\t\t}\n\n\t\tret = cpufreq_table_validate_and_sort(policy);\n\t\tif (ret)\n\t\t\tgoto out_exit_policy;\n\n\t\t/* related_cpus should at least include policy->cpus. */\n\t\tcpumask_copy(policy->related_cpus, policy->cpus);\n\t}\n\n\tdown_write(&policy->rwsem);\n\t/*\n\t * affected cpus must always be the one, which are online. We aren't\n\t * managing offline cpus here.\n\t */\n\tcpumask_and(policy->cpus, policy->cpus, cpu_online_mask);\n\n\tif (new_policy) {\n\t\tfor_each_cpu(j, policy->related_cpus) {\n\t\t\tper_cpu(cpufreq_cpu_data, j) = policy;\n\t\t\tadd_cpu_dev_symlink(policy, j);\n\t\t}\n\n\t\tpolicy->min_freq_req = kzalloc(2 * sizeof(*policy->min_freq_req),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!policy->min_freq_req) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\n\t\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t\t   policy->min_freq_req, FREQ_QOS_MIN,\n\t\t\t\t\t   policy->min);\n\t\tif (ret < 0) {\n\t\t\t/*\n\t\t\t * So we don't call freq_qos_remove_request() for an\n\t\t\t * uninitialized request.\n\t\t\t */\n\t\t\tkfree(policy->min_freq_req);\n\t\t\tpolicy->min_freq_req = NULL;\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\n\t\t/*\n\t\t * This must be initialized right here to avoid calling\n\t\t * freq_qos_remove_request() on uninitialized request in case\n\t\t * of errors.\n\t\t */\n\t\tpolicy->max_freq_req = policy->min_freq_req + 1;\n\n\t\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t\t   policy->max_freq_req, FREQ_QOS_MAX,\n\t\t\t\t\t   policy->max);\n\t\tif (ret < 0) {\n\t\t\tpolicy->max_freq_req = NULL;\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\n\t\tblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\n\t\t\t\tCPUFREQ_CREATE_POLICY, policy);\n\t}\n\n\tif (cpufreq_driver->get && has_target()) {\n\t\tpolicy->cur = cpufreq_driver->get(policy->cpu);\n\t\tif (!policy->cur) {\n\t\t\tret = -EIO;\n\t\t\tpr_err(\"%s: ->get() failed\\n\", __func__);\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes boot loaders set CPU frequency to a value outside of\n\t * frequency table present with cpufreq core. In such cases CPU might be\n\t * unstable if it has to run on that frequency for long duration of time\n\t * and so its better to set it to a frequency which is specified in\n\t * freq-table. This also makes cpufreq stats inconsistent as\n\t * cpufreq-stats would fail to register because current frequency of CPU\n\t * isn't found in freq-table.\n\t *\n\t * Because we don't want this change to effect boot process badly, we go\n\t * for the next freq which is >= policy->cur ('cur' must be set by now,\n\t * otherwise we will end up setting freq to lowest of the table as 'cur'\n\t * is initialized to zero).\n\t *\n\t * We are passing target-freq as \"policy->cur - 1\" otherwise\n\t * __cpufreq_driver_target() would simply fail, as policy->cur will be\n\t * equal to target-freq.\n\t */\n\tif ((cpufreq_driver->flags & CPUFREQ_NEED_INITIAL_FREQ_CHECK)\n\t    && has_target()) {\n\t\tunsigned int old_freq = policy->cur;\n\n\t\t/* Are we running at unknown frequency ? */\n\t\tret = cpufreq_frequency_table_get_index(policy, old_freq);\n\t\tif (ret == -EINVAL) {\n\t\t\tret = __cpufreq_driver_target(policy, old_freq - 1,\n\t\t\t\t\t\t      CPUFREQ_RELATION_L);\n\n\t\t\t/*\n\t\t\t * Reaching here after boot in a few seconds may not\n\t\t\t * mean that system will remain stable at \"unknown\"\n\t\t\t * frequency for longer duration. Hence, a BUG_ON().\n\t\t\t */\n\t\t\tBUG_ON(ret);\n\t\t\tpr_info(\"%s: CPU%d: Running at unlisted initial frequency: %u KHz, changing to: %u KHz\\n\",\n\t\t\t\t__func__, policy->cpu, old_freq, policy->cur);\n\t\t}\n\t}\n\n\tif (new_policy) {\n\t\tret = cpufreq_add_dev_interface(policy);\n\t\tif (ret)\n\t\t\tgoto out_destroy_policy;\n\n\t\tcpufreq_stats_create_table(policy);\n\n\t\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\t\tlist_add(&policy->policy_list, &cpufreq_policy_list);\n\t\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\t}\n\n\tret = cpufreq_init_policy(policy);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to initialize policy for cpu: %d (%d)\\n\",\n\t\t       __func__, cpu, ret);\n\t\tgoto out_destroy_policy;\n\t}\n\n\tup_write(&policy->rwsem);\n\n\tkobject_uevent(&policy->kobj, KOBJ_ADD);\n\n\t/* Callback for handling stuff after policy is ready */\n\tif (cpufreq_driver->ready)\n\t\tcpufreq_driver->ready(policy);\n\n\tif (cpufreq_thermal_control_enabled(cpufreq_driver))\n\t\tpolicy->cdev = of_cpufreq_cooling_register(policy);\n\n\tpr_debug(\"initialization complete\\n\");\n\n\treturn 0;\n\nout_destroy_policy:\n\tfor_each_cpu(j, policy->real_cpus)\n\t\tremove_cpu_dev_symlink(policy, get_cpu_device(j));\n\n\tup_write(&policy->rwsem);\n\nout_exit_policy:\n\tif (cpufreq_driver->exit)\n\t\tcpufreq_driver->exit(policy);\n\nout_free_policy:\n\tcpufreq_policy_free(policy);\n\treturn ret;\n}\n\n/**\n * cpufreq_add_dev - the cpufreq interface for a CPU device.\n * @dev: CPU device.\n * @sif: Subsystem interface structure pointer (not used)\n */\nstatic int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned cpu = dev->id;\n\tint ret;\n\n\tdev_dbg(dev, \"%s: adding CPU%u\\n\", __func__, cpu);\n\n\tif (cpu_online(cpu)) {\n\t\tret = cpufreq_online(cpu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Create sysfs link on CPU registration */\n\tpolicy = per_cpu(cpufreq_cpu_data, cpu);\n\tif (policy)\n\t\tadd_cpu_dev_symlink(policy, cpu);\n\n\treturn 0;\n}\n\nstatic int cpufreq_offline(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tint ret;\n\n\tpr_debug(\"%s: unregistering CPU %u\\n\", __func__, cpu);\n\n\tpolicy = cpufreq_cpu_get_raw(cpu);\n\tif (!policy) {\n\t\tpr_debug(\"%s: No cpu_data found\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tdown_write(&policy->rwsem);\n\tif (has_target())\n\t\tcpufreq_stop_governor(policy);\n\n\tcpumask_clear_cpu(cpu, policy->cpus);\n\n\tif (policy_is_inactive(policy)) {\n\t\tif (has_target())\n\t\t\tstrncpy(policy->last_governor, policy->governor->name,\n\t\t\t\tCPUFREQ_NAME_LEN);\n\t\telse\n\t\t\tpolicy->last_policy = policy->policy;\n\t} else if (cpu == policy->cpu) {\n\t\t/* Nominate new CPU */\n\t\tpolicy->cpu = cpumask_any(policy->cpus);\n\t}\n\n\t/* Start governor again for active policy */\n\tif (!policy_is_inactive(policy)) {\n\t\tif (has_target()) {\n\t\t\tret = cpufreq_start_governor(policy);\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"%s: Failed to start governor\\n\", __func__);\n\t\t}\n\n\t\tgoto unlock;\n\t}\n\n\tif (cpufreq_thermal_control_enabled(cpufreq_driver)) {\n\t\tcpufreq_cooling_unregister(policy->cdev);\n\t\tpolicy->cdev = NULL;\n\t}\n\n\tif (cpufreq_driver->stop_cpu)\n\t\tcpufreq_driver->stop_cpu(policy);\n\n\tif (has_target())\n\t\tcpufreq_exit_governor(policy);\n\n\t/*\n\t * Perform the ->offline() during light-weight tear-down, as\n\t * that allows fast recovery when the CPU comes back.\n\t */\n\tif (cpufreq_driver->offline) {\n\t\tcpufreq_driver->offline(policy);\n\t} else if (cpufreq_driver->exit) {\n\t\tcpufreq_driver->exit(policy);\n\t\tpolicy->freq_table = NULL;\n\t}\n\nunlock:\n\tup_write(&policy->rwsem);\n\treturn 0;\n}\n\n/*\n * cpufreq_remove_dev - remove a CPU device\n *\n * Removes the cpufreq interface for a CPU device.\n */\nstatic void cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tunsigned int cpu = dev->id;\n\tstruct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);\n\n\tif (!policy)\n\t\treturn;\n\n\tif (cpu_online(cpu))\n\t\tcpufreq_offline(cpu);\n\n\tcpumask_clear_cpu(cpu, policy->real_cpus);\n\tremove_cpu_dev_symlink(policy, dev);\n\n\tif (cpumask_empty(policy->real_cpus)) {\n\t\t/* We did light-weight exit earlier, do full tear down now */\n\t\tif (cpufreq_driver->offline)\n\t\t\tcpufreq_driver->exit(policy);\n\n\t\tcpufreq_policy_free(policy);\n\t}\n}\n\n/**\n * cpufreq_out_of_sync - Fix up actual and saved CPU frequency difference.\n * @policy: Policy managing CPUs.\n * @new_freq: New CPU frequency.\n *\n * Adjust to the current frequency first and clean up later by either calling\n * cpufreq_update_policy(), or scheduling handle_update().\n */\nstatic void cpufreq_out_of_sync(struct cpufreq_policy *policy,\n\t\t\t\tunsigned int new_freq)\n{\n\tstruct cpufreq_freqs freqs;\n\n\tpr_debug(\"Warning: CPU frequency out of sync: cpufreq and timing core thinks of %u, is %u kHz\\n\",\n\t\t policy->cur, new_freq);\n\n\tfreqs.old = policy->cur;\n\tfreqs.new = new_freq;\n\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\tcpufreq_freq_transition_end(policy, &freqs, 0);\n}\n\nstatic unsigned int cpufreq_verify_current_freq(struct cpufreq_policy *policy, bool update)\n{\n\tunsigned int new_freq;\n\n\tnew_freq = cpufreq_driver->get(policy->cpu);\n\tif (!new_freq)\n\t\treturn 0;\n\n\t/*\n\t * If fast frequency switching is used with the given policy, the check\n\t * against policy->cur is pointless, so skip it in that case.\n\t */\n\tif (policy->fast_switch_enabled || !has_target())\n\t\treturn new_freq;\n\n\tif (policy->cur != new_freq) {\n\t\tcpufreq_out_of_sync(policy, new_freq);\n\t\tif (update)\n\t\t\tschedule_work(&policy->update);\n\t}\n\n\treturn new_freq;\n}\n\n/**\n * cpufreq_quick_get - get the CPU frequency (in kHz) from policy->cur\n * @cpu: CPU number\n *\n * This is the last known freq, without actually getting it from the driver.\n * Return value will be same as what is shown in scaling_cur_freq in sysfs.\n */\nunsigned int cpufreq_quick_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned int ret_freq = 0;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&cpufreq_driver_lock, flags);\n\n\tif (cpufreq_driver && cpufreq_driver->setpolicy && cpufreq_driver->get) {\n\t\tret_freq = cpufreq_driver->get(cpu);\n\t\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\t\treturn ret_freq;\n\t}\n\n\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tpolicy = cpufreq_cpu_get(cpu);\n\tif (policy) {\n\t\tret_freq = policy->cur;\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_quick_get);\n\n/**\n * cpufreq_quick_get_max - get the max reported CPU frequency for this CPU\n * @cpu: CPU number\n *\n * Just return the max possible frequency for a given CPU.\n */\nunsigned int cpufreq_quick_get_max(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tunsigned int ret_freq = 0;\n\n\tif (policy) {\n\t\tret_freq = policy->max;\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_quick_get_max);\n\n/**\n * cpufreq_get_hw_max_freq - get the max hardware frequency of the CPU\n * @cpu: CPU number\n *\n * The default return value is the max_freq field of cpuinfo.\n */\n__weak unsigned int cpufreq_get_hw_max_freq(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tunsigned int ret_freq = 0;\n\n\tif (policy) {\n\t\tret_freq = policy->cpuinfo.max_freq;\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_get_hw_max_freq);\n\nstatic unsigned int __cpufreq_get(struct cpufreq_policy *policy)\n{\n\tif (unlikely(policy_is_inactive(policy)))\n\t\treturn 0;\n\n\treturn cpufreq_verify_current_freq(policy, true);\n}\n\n/**\n * cpufreq_get - get the current CPU frequency (in kHz)\n * @cpu: CPU number\n *\n * Get the CPU current (static) CPU frequency\n */\nunsigned int cpufreq_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tunsigned int ret_freq = 0;\n\n\tif (policy) {\n\t\tdown_read(&policy->rwsem);\n\t\tif (cpufreq_driver->get)\n\t\t\tret_freq = __cpufreq_get(policy);\n\t\tup_read(&policy->rwsem);\n\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_get);\n\nstatic struct subsys_interface cpufreq_interface = {\n\t.name\t\t= \"cpufreq\",\n\t.subsys\t\t= &cpu_subsys,\n\t.add_dev\t= cpufreq_add_dev,\n\t.remove_dev\t= cpufreq_remove_dev,\n};\n\n/*\n * In case platform wants some specific frequency to be configured\n * during suspend..\n */\nint cpufreq_generic_suspend(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\tif (!policy->suspend_freq) {\n\t\tpr_debug(\"%s: suspend_freq not defined\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s: Setting suspend-freq: %u\\n\", __func__,\n\t\t\tpolicy->suspend_freq);\n\n\tret = __cpufreq_driver_target(policy, policy->suspend_freq,\n\t\t\tCPUFREQ_RELATION_H);\n\tif (ret)\n\t\tpr_err(\"%s: unable to set suspend-freq: %u. err: %d\\n\",\n\t\t\t\t__func__, policy->suspend_freq, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cpufreq_generic_suspend);\n\n/**\n * cpufreq_suspend() - Suspend CPUFreq governors.\n *\n * Called during system wide Suspend/Hibernate cycles for suspending governors\n * as some platforms can't change frequency after this point in suspend cycle.\n * Because some of the devices (like: i2c, regulators, etc) they use for\n * changing frequency are suspended quickly after this point.\n */\nvoid cpufreq_suspend(void)\n{\n\tstruct cpufreq_policy *policy;\n\n\tif (!cpufreq_driver)\n\t\treturn;\n\n\tif (!has_target() && !cpufreq_driver->suspend)\n\t\tgoto suspend;\n\n\tpr_debug(\"%s: Suspending Governors\\n\", __func__);\n\n\tfor_each_active_policy(policy) {\n\t\tif (has_target()) {\n\t\t\tdown_write(&policy->rwsem);\n\t\t\tcpufreq_stop_governor(policy);\n\t\t\tup_write(&policy->rwsem);\n\t\t}\n\n\t\tif (cpufreq_driver->suspend && cpufreq_driver->suspend(policy))\n\t\t\tpr_err(\"%s: Failed to suspend driver: %s\\n\", __func__,\n\t\t\t\tcpufreq_driver->name);\n\t}\n\nsuspend:\n\tcpufreq_suspended = true;\n}\n\n/**\n * cpufreq_resume() - Resume CPUFreq governors.\n *\n * Called during system wide Suspend/Hibernate cycle for resuming governors that\n * are suspended with cpufreq_suspend().\n */\nvoid cpufreq_resume(void)\n{\n\tstruct cpufreq_policy *policy;\n\tint ret;\n\n\tif (!cpufreq_driver)\n\t\treturn;\n\n\tif (unlikely(!cpufreq_suspended))\n\t\treturn;\n\n\tcpufreq_suspended = false;\n\n\tif (!has_target() && !cpufreq_driver->resume)\n\t\treturn;\n\n\tpr_debug(\"%s: Resuming Governors\\n\", __func__);\n\n\tfor_each_active_policy(policy) {\n\t\tif (cpufreq_driver->resume && cpufreq_driver->resume(policy)) {\n\t\t\tpr_err(\"%s: Failed to resume driver: %p\\n\", __func__,\n\t\t\t\tpolicy);\n\t\t} else if (has_target()) {\n\t\t\tdown_write(&policy->rwsem);\n\t\t\tret = cpufreq_start_governor(policy);\n\t\t\tup_write(&policy->rwsem);\n\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"%s: Failed to start governor for policy: %p\\n\",\n\t\t\t\t       __func__, policy);\n\t\t}\n\t}\n}\n\n/**\n * cpufreq_driver_test_flags - Test cpufreq driver's flags against given ones.\n * @flags: Flags to test against the current cpufreq driver's flags.\n *\n * Assumes that the driver is there, so callers must ensure that this is the\n * case.\n */\nbool cpufreq_driver_test_flags(u16 flags)\n{\n\treturn !!(cpufreq_driver->flags & flags);\n}\n\n/**\n * cpufreq_get_current_driver - Return the current driver's name.\n *\n * Return the name string of the currently registered cpufreq driver or NULL if\n * none.\n */\nconst char *cpufreq_get_current_driver(void)\n{\n\tif (cpufreq_driver)\n\t\treturn cpufreq_driver->name;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_get_current_driver);\n\n/**\n * cpufreq_get_driver_data - Return current driver data.\n *\n * Return the private data of the currently registered cpufreq driver, or NULL\n * if no cpufreq driver has been registered.\n */\nvoid *cpufreq_get_driver_data(void)\n{\n\tif (cpufreq_driver)\n\t\treturn cpufreq_driver->driver_data;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_get_driver_data);\n\n/*********************************************************************\n *                     NOTIFIER LISTS INTERFACE                      *\n *********************************************************************/\n\n/**\n * cpufreq_register_notifier - Register a notifier with cpufreq.\n * @nb: notifier function to register.\n * @list: CPUFREQ_TRANSITION_NOTIFIER or CPUFREQ_POLICY_NOTIFIER.\n *\n * Add a notifier to one of two lists: either a list of notifiers that run on\n * clock rate changes (once before and once after every transition), or a list\n * of notifiers that ron on cpufreq policy changes.\n *\n * This function may sleep and it has the same return values as\n * blocking_notifier_chain_register().\n */\nint cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)\n{\n\tint ret;\n\n\tif (cpufreq_disabled())\n\t\treturn -EINVAL;\n\n\tswitch (list) {\n\tcase CPUFREQ_TRANSITION_NOTIFIER:\n\t\tmutex_lock(&cpufreq_fast_switch_lock);\n\n\t\tif (cpufreq_fast_switch_count > 0) {\n\t\t\tmutex_unlock(&cpufreq_fast_switch_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tret = srcu_notifier_chain_register(\n\t\t\t\t&cpufreq_transition_notifier_list, nb);\n\t\tif (!ret)\n\t\t\tcpufreq_fast_switch_count--;\n\n\t\tmutex_unlock(&cpufreq_fast_switch_lock);\n\t\tbreak;\n\tcase CPUFREQ_POLICY_NOTIFIER:\n\t\tret = blocking_notifier_chain_register(\n\t\t\t\t&cpufreq_policy_notifier_list, nb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cpufreq_register_notifier);\n\n/**\n * cpufreq_unregister_notifier - Unregister a notifier from cpufreq.\n * @nb: notifier block to be unregistered.\n * @list: CPUFREQ_TRANSITION_NOTIFIER or CPUFREQ_POLICY_NOTIFIER.\n *\n * Remove a notifier from one of the cpufreq notifier lists.\n *\n * This function may sleep and it has the same return values as\n * blocking_notifier_chain_unregister().\n */\nint cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list)\n{\n\tint ret;\n\n\tif (cpufreq_disabled())\n\t\treturn -EINVAL;\n\n\tswitch (list) {\n\tcase CPUFREQ_TRANSITION_NOTIFIER:\n\t\tmutex_lock(&cpufreq_fast_switch_lock);\n\n\t\tret = srcu_notifier_chain_unregister(\n\t\t\t\t&cpufreq_transition_notifier_list, nb);\n\t\tif (!ret && !WARN_ON(cpufreq_fast_switch_count >= 0))\n\t\t\tcpufreq_fast_switch_count++;\n\n\t\tmutex_unlock(&cpufreq_fast_switch_lock);\n\t\tbreak;\n\tcase CPUFREQ_POLICY_NOTIFIER:\n\t\tret = blocking_notifier_chain_unregister(\n\t\t\t\t&cpufreq_policy_notifier_list, nb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cpufreq_unregister_notifier);\n\n\n/*********************************************************************\n *                              GOVERNORS                            *\n *********************************************************************/\n\n/**\n * cpufreq_driver_fast_switch - Carry out a fast CPU frequency switch.\n * @policy: cpufreq policy to switch the frequency for.\n * @target_freq: New frequency to set (may be approximate).\n *\n * Carry out a fast frequency switch without sleeping.\n *\n * The driver's ->fast_switch() callback invoked by this function must be\n * suitable for being called from within RCU-sched read-side critical sections\n * and it is expected to select the minimum available frequency greater than or\n * equal to @target_freq (CPUFREQ_RELATION_L).\n *\n * This function must not be called if policy->fast_switch_enabled is unset.\n *\n * Governors calling this function must guarantee that it will never be invoked\n * twice in parallel for the same policy and that it will never be called in\n * parallel with either ->target() or ->target_index() for the same policy.\n *\n * Returns the actual frequency set for the CPU.\n *\n * If 0 is returned by the driver's ->fast_switch() callback to indicate an\n * error condition, the hardware configuration must be preserved.\n */\nunsigned int cpufreq_driver_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int target_freq)\n{\n\tunsigned int freq;\n\tint cpu;\n\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\tfreq = cpufreq_driver->fast_switch(policy, target_freq);\n\n\tif (!freq)\n\t\treturn 0;\n\n\tpolicy->cur = freq;\n\tarch_set_freq_scale(policy->related_cpus, freq,\n\t\t\t    policy->cpuinfo.max_freq);\n\tcpufreq_stats_record_transition(policy, freq);\n\n\tif (trace_cpu_frequency_enabled()) {\n\t\tfor_each_cpu(cpu, policy->cpus)\n\t\t\ttrace_cpu_frequency(freq, cpu);\n\t}\n\n\treturn freq;\n}\nEXPORT_SYMBOL_GPL(cpufreq_driver_fast_switch);\n\n/**\n * cpufreq_driver_adjust_perf - Adjust CPU performance level in one go.\n * @cpu: Target CPU.\n * @min_perf: Minimum (required) performance level (units of @capacity).\n * @target_perf: Target (desired) performance level (units of @capacity).\n * @capacity: Capacity of the target CPU.\n *\n * Carry out a fast performance level switch of @cpu without sleeping.\n *\n * The driver's ->adjust_perf() callback invoked by this function must be\n * suitable for being called from within RCU-sched read-side critical sections\n * and it is expected to select a suitable performance level equal to or above\n * @min_perf and preferably equal to or below @target_perf.\n *\n * This function must not be called if policy->fast_switch_enabled is unset.\n *\n * Governors calling this function must guarantee that it will never be invoked\n * twice in parallel for the same CPU and that it will never be called in\n * parallel with either ->target() or ->target_index() or ->fast_switch() for\n * the same CPU.\n */\nvoid cpufreq_driver_adjust_perf(unsigned int cpu,\n\t\t\t\t unsigned long min_perf,\n\t\t\t\t unsigned long target_perf,\n\t\t\t\t unsigned long capacity)\n{\n\tcpufreq_driver->adjust_perf(cpu, min_perf, target_perf, capacity);\n}\n\n/**\n * cpufreq_driver_has_adjust_perf - Check \"direct fast switch\" callback.\n *\n * Return 'true' if the ->adjust_perf callback is present for the\n * current driver or 'false' otherwise.\n */\nbool cpufreq_driver_has_adjust_perf(void)\n{\n\treturn !!cpufreq_driver->adjust_perf;\n}\n\n/* Must set freqs->new to intermediate frequency */\nstatic int __target_intermediate(struct cpufreq_policy *policy,\n\t\t\t\t struct cpufreq_freqs *freqs, int index)\n{\n\tint ret;\n\n\tfreqs->new = cpufreq_driver->get_intermediate(policy, index);\n\n\t/* We don't need to switch to intermediate freq */\n\tif (!freqs->new)\n\t\treturn 0;\n\n\tpr_debug(\"%s: cpu: %d, switching to intermediate freq: oldfreq: %u, intermediate freq: %u\\n\",\n\t\t __func__, policy->cpu, freqs->old, freqs->new);\n\n\tcpufreq_freq_transition_begin(policy, freqs);\n\tret = cpufreq_driver->target_intermediate(policy, index);\n\tcpufreq_freq_transition_end(policy, freqs, ret);\n\n\tif (ret)\n\t\tpr_err(\"%s: Failed to change to intermediate frequency: %d\\n\",\n\t\t       __func__, ret);\n\n\treturn ret;\n}\n\nstatic int __target_index(struct cpufreq_policy *policy, int index)\n{\n\tstruct cpufreq_freqs freqs = {.old = policy->cur, .flags = 0};\n\tunsigned int restore_freq, intermediate_freq = 0;\n\tunsigned int newfreq = policy->freq_table[index].frequency;\n\tint retval = -EINVAL;\n\tbool notify;\n\n\tif (newfreq == policy->cur)\n\t\treturn 0;\n\n\t/* Save last value to restore later on errors */\n\trestore_freq = policy->cur;\n\n\tnotify = !(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION);\n\tif (notify) {\n\t\t/* Handle switching to intermediate frequency */\n\t\tif (cpufreq_driver->get_intermediate) {\n\t\t\tretval = __target_intermediate(policy, &freqs, index);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tintermediate_freq = freqs.new;\n\t\t\t/* Set old freq to intermediate */\n\t\t\tif (intermediate_freq)\n\t\t\t\tfreqs.old = freqs.new;\n\t\t}\n\n\t\tfreqs.new = newfreq;\n\t\tpr_debug(\"%s: cpu: %d, oldfreq: %u, new freq: %u\\n\",\n\t\t\t __func__, policy->cpu, freqs.old, freqs.new);\n\n\t\tcpufreq_freq_transition_begin(policy, &freqs);\n\t}\n\n\tretval = cpufreq_driver->target_index(policy, index);\n\tif (retval)\n\t\tpr_err(\"%s: Failed to change cpu frequency: %d\\n\", __func__,\n\t\t       retval);\n\n\tif (notify) {\n\t\tcpufreq_freq_transition_end(policy, &freqs, retval);\n\n\t\t/*\n\t\t * Failed after setting to intermediate freq? Driver should have\n\t\t * reverted back to initial frequency and so should we. Check\n\t\t * here for intermediate_freq instead of get_intermediate, in\n\t\t * case we haven't switched to intermediate freq at all.\n\t\t */\n\t\tif (unlikely(retval && intermediate_freq)) {\n\t\t\tfreqs.old = intermediate_freq;\n\t\t\tfreqs.new = restore_freq;\n\t\t\tcpufreq_freq_transition_begin(policy, &freqs);\n\t\t\tcpufreq_freq_transition_end(policy, &freqs, 0);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nint __cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t    unsigned int target_freq,\n\t\t\t    unsigned int relation)\n{\n\tunsigned int old_target_freq = target_freq;\n\tint index;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\t/* Make sure that target_freq is within supported range */\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tpr_debug(\"target for CPU %u: %u kHz, relation %u, requested %u kHz\\n\",\n\t\t policy->cpu, target_freq, relation, old_target_freq);\n\n\t/*\n\t * This might look like a redundant call as we are checking it again\n\t * after finding index. But it is left intentionally for cases where\n\t * exactly same freq is called again and so we can save on few function\n\t * calls.\n\t */\n\tif (target_freq == policy->cur &&\n\t    !(cpufreq_driver->flags & CPUFREQ_NEED_UPDATE_LIMITS))\n\t\treturn 0;\n\n\tif (cpufreq_driver->target)\n\t\treturn cpufreq_driver->target(policy, target_freq, relation);\n\n\tif (!cpufreq_driver->target_index)\n\t\treturn -EINVAL;\n\n\tindex = cpufreq_frequency_table_target(policy, target_freq, relation);\n\n\treturn __target_index(policy, index);\n}\nEXPORT_SYMBOL_GPL(__cpufreq_driver_target);\n\nint cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t  unsigned int target_freq,\n\t\t\t  unsigned int relation)\n{\n\tint ret;\n\n\tdown_write(&policy->rwsem);\n\n\tret = __cpufreq_driver_target(policy, target_freq, relation);\n\n\tup_write(&policy->rwsem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cpufreq_driver_target);\n\n__weak struct cpufreq_governor *cpufreq_fallback_governor(void)\n{\n\treturn NULL;\n}\n\nstatic int cpufreq_init_governor(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\t/* Don't start any governor operations if we are entering suspend */\n\tif (cpufreq_suspended)\n\t\treturn 0;\n\t/*\n\t * Governor might not be initiated here if ACPI _PPC changed\n\t * notification happened, so check it.\n\t */\n\tif (!policy->governor)\n\t\treturn -EINVAL;\n\n\t/* Platform doesn't want dynamic frequency switching ? */\n\tif (policy->governor->flags & CPUFREQ_GOV_DYNAMIC_SWITCHING &&\n\t    cpufreq_driver->flags & CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING) {\n\t\tstruct cpufreq_governor *gov = cpufreq_fallback_governor();\n\n\t\tif (gov) {\n\t\t\tpr_warn(\"Can't use %s governor as dynamic switching is disallowed. Fallback to %s governor\\n\",\n\t\t\t\tpolicy->governor->name, gov->name);\n\t\t\tpolicy->governor = gov;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!try_module_get(policy->governor->owner))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->init) {\n\t\tret = policy->governor->init(policy);\n\t\tif (ret) {\n\t\t\tmodule_put(policy->governor->owner);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpolicy->strict_target = !!(policy->governor->flags & CPUFREQ_GOV_STRICT_TARGET);\n\n\treturn 0;\n}\n\nstatic void cpufreq_exit_governor(struct cpufreq_policy *policy)\n{\n\tif (cpufreq_suspended || !policy->governor)\n\t\treturn;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->exit)\n\t\tpolicy->governor->exit(policy);\n\n\tmodule_put(policy->governor->owner);\n}\n\nint cpufreq_start_governor(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\tif (cpufreq_suspended)\n\t\treturn 0;\n\n\tif (!policy->governor)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (cpufreq_driver->get)\n\t\tcpufreq_verify_current_freq(policy, false);\n\n\tif (policy->governor->start) {\n\t\tret = policy->governor->start(policy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (policy->governor->limits)\n\t\tpolicy->governor->limits(policy);\n\n\treturn 0;\n}\n\nvoid cpufreq_stop_governor(struct cpufreq_policy *policy)\n{\n\tif (cpufreq_suspended || !policy->governor)\n\t\treturn;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->stop)\n\t\tpolicy->governor->stop(policy);\n}\n\nstatic void cpufreq_governor_limits(struct cpufreq_policy *policy)\n{\n\tif (cpufreq_suspended || !policy->governor)\n\t\treturn;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->limits)\n\t\tpolicy->governor->limits(policy);\n}\n\nint cpufreq_register_governor(struct cpufreq_governor *governor)\n{\n\tint err;\n\n\tif (!governor)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\n\terr = -EBUSY;\n\tif (!find_governor(governor->name)) {\n\t\terr = 0;\n\t\tlist_add(&governor->governor_list, &cpufreq_governor_list);\n\t}\n\n\tmutex_unlock(&cpufreq_governor_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cpufreq_register_governor);\n\nvoid cpufreq_unregister_governor(struct cpufreq_governor *governor)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned long flags;\n\n\tif (!governor)\n\t\treturn;\n\n\tif (cpufreq_disabled())\n\t\treturn;\n\n\t/* clear last_governor for all inactive policies */\n\tread_lock_irqsave(&cpufreq_driver_lock, flags);\n\tfor_each_inactive_policy(policy) {\n\t\tif (!strcmp(policy->last_governor, governor->name)) {\n\t\t\tpolicy->governor = NULL;\n\t\t\tstrcpy(policy->last_governor, \"\\0\");\n\t\t}\n\t}\n\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\tlist_del(&governor->governor_list);\n\tmutex_unlock(&cpufreq_governor_mutex);\n}\nEXPORT_SYMBOL_GPL(cpufreq_unregister_governor);\n\n\n/*********************************************************************\n *                          POLICY INTERFACE                         *\n *********************************************************************/\n\n/**\n * cpufreq_get_policy - get the current cpufreq_policy\n * @policy: struct cpufreq_policy into which the current cpufreq_policy\n *\tis written\n * @cpu: CPU to find the policy for\n *\n * Reads the current cpufreq policy.\n */\nint cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu)\n{\n\tstruct cpufreq_policy *cpu_policy;\n\tif (!policy)\n\t\treturn -EINVAL;\n\n\tcpu_policy = cpufreq_cpu_get(cpu);\n\tif (!cpu_policy)\n\t\treturn -EINVAL;\n\n\tmemcpy(policy, cpu_policy, sizeof(*policy));\n\n\tcpufreq_cpu_put(cpu_policy);\n\treturn 0;\n}\nEXPORT_SYMBOL(cpufreq_get_policy);\n\n/**\n * cpufreq_set_policy - Modify cpufreq policy parameters.\n * @policy: Policy object to modify.\n * @new_gov: Policy governor pointer.\n * @new_pol: Policy value (for drivers with built-in governors).\n *\n * Invoke the cpufreq driver's ->verify() callback to sanity-check the frequency\n * limits to be set for the policy, update @policy with the verified limits\n * values and either invoke the driver's ->setpolicy() callback (if present) or\n * carry out a governor update for @policy.  That is, run the current governor's\n * ->limits() callback (if @new_gov points to the same object as the one in\n * @policy) or replace the governor for @policy with @new_gov.\n *\n * The cpuinfo part of @policy is not updated by this function.\n */\nstatic int cpufreq_set_policy(struct cpufreq_policy *policy,\n\t\t\t      struct cpufreq_governor *new_gov,\n\t\t\t      unsigned int new_pol)\n{\n\tstruct cpufreq_policy_data new_data;\n\tstruct cpufreq_governor *old_gov;\n\tint ret;\n\n\tmemcpy(&new_data.cpuinfo, &policy->cpuinfo, sizeof(policy->cpuinfo));\n\tnew_data.freq_table = policy->freq_table;\n\tnew_data.cpu = policy->cpu;\n\t/*\n\t * PM QoS framework collects all the requests from users and provide us\n\t * the final aggregated value here.\n\t */\n\tnew_data.min = freq_qos_read_value(&policy->constraints, FREQ_QOS_MIN);\n\tnew_data.max = freq_qos_read_value(&policy->constraints, FREQ_QOS_MAX);\n\n\tpr_debug(\"setting new policy for CPU %u: %u - %u kHz\\n\",\n\t\t new_data.cpu, new_data.min, new_data.max);\n\n\t/*\n\t * Verify that the CPU speed can be set within these limits and make sure\n\t * that min <= max.\n\t */\n\tret = cpufreq_driver->verify(&new_data);\n\tif (ret)\n\t\treturn ret;\n\n\tpolicy->min = new_data.min;\n\tpolicy->max = new_data.max;\n\ttrace_cpu_frequency_limits(policy);\n\n\tpolicy->cached_target_freq = UINT_MAX;\n\n\tpr_debug(\"new min and max freqs are %u - %u kHz\\n\",\n\t\t policy->min, policy->max);\n\n\tif (cpufreq_driver->setpolicy) {\n\t\tpolicy->policy = new_pol;\n\t\tpr_debug(\"setting range\\n\");\n\t\treturn cpufreq_driver->setpolicy(policy);\n\t}\n\n\tif (new_gov == policy->governor) {\n\t\tpr_debug(\"governor limits update\\n\");\n\t\tcpufreq_governor_limits(policy);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"governor switch\\n\");\n\n\t/* save old, working values */\n\told_gov = policy->governor;\n\t/* end old governor */\n\tif (old_gov) {\n\t\tcpufreq_stop_governor(policy);\n\t\tcpufreq_exit_governor(policy);\n\t}\n\n\t/* start new governor */\n\tpolicy->governor = new_gov;\n\tret = cpufreq_init_governor(policy);\n\tif (!ret) {\n\t\tret = cpufreq_start_governor(policy);\n\t\tif (!ret) {\n\t\t\tpr_debug(\"governor change\\n\");\n\t\t\tsched_cpufreq_governor_change(policy, old_gov);\n\t\t\treturn 0;\n\t\t}\n\t\tcpufreq_exit_governor(policy);\n\t}\n\n\t/* new governor failed, so re-start old one */\n\tpr_debug(\"starting governor %s failed\\n\", policy->governor->name);\n\tif (old_gov) {\n\t\tpolicy->governor = old_gov;\n\t\tif (cpufreq_init_governor(policy))\n\t\t\tpolicy->governor = NULL;\n\t\telse\n\t\t\tcpufreq_start_governor(policy);\n\t}\n\n\treturn ret;\n}\n\n/**\n * cpufreq_update_policy - Re-evaluate an existing cpufreq policy.\n * @cpu: CPU to re-evaluate the policy for.\n *\n * Update the current frequency for the cpufreq policy of @cpu and use\n * cpufreq_set_policy() to re-apply the min and max limits, which triggers the\n * evaluation of policy notifiers and the cpufreq driver's ->verify() callback\n * for the policy in question, among other things.\n */\nvoid cpufreq_update_policy(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_acquire(cpu);\n\n\tif (!policy)\n\t\treturn;\n\n\t/*\n\t * BIOS might change freq behind our back\n\t * -> ask driver for current freq and notify governors about a change\n\t */\n\tif (cpufreq_driver->get && has_target() &&\n\t    (cpufreq_suspended || WARN_ON(!cpufreq_verify_current_freq(policy, false))))\n\t\tgoto unlock;\n\n\trefresh_frequency_limits(policy);\n\nunlock:\n\tcpufreq_cpu_release(policy);\n}\nEXPORT_SYMBOL(cpufreq_update_policy);\n\n/**\n * cpufreq_update_limits - Update policy limits for a given CPU.\n * @cpu: CPU to update the policy limits for.\n *\n * Invoke the driver's ->update_limits callback if present or call\n * cpufreq_update_policy() for @cpu.\n */\nvoid cpufreq_update_limits(unsigned int cpu)\n{\n\tif (cpufreq_driver->update_limits)\n\t\tcpufreq_driver->update_limits(cpu);\n\telse\n\t\tcpufreq_update_policy(cpu);\n}\nEXPORT_SYMBOL_GPL(cpufreq_update_limits);\n\n/*********************************************************************\n *               BOOST\t\t\t\t\t\t     *\n *********************************************************************/\nstatic int cpufreq_boost_set_sw(struct cpufreq_policy *policy, int state)\n{\n\tint ret;\n\n\tif (!policy->freq_table)\n\t\treturn -ENXIO;\n\n\tret = cpufreq_frequency_table_cpuinfo(policy, policy->freq_table);\n\tif (ret) {\n\t\tpr_err(\"%s: Policy frequency update failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = freq_qos_update_request(policy->max_freq_req, policy->max);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint cpufreq_boost_trigger_state(int state)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (cpufreq_driver->boost_enabled == state)\n\t\treturn 0;\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tcpufreq_driver->boost_enabled = state;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tget_online_cpus();\n\tfor_each_active_policy(policy) {\n\t\tret = cpufreq_driver->set_boost(policy, state);\n\t\tif (ret)\n\t\t\tgoto err_reset_state;\n\t}\n\tput_online_cpus();\n\n\treturn 0;\n\nerr_reset_state:\n\tput_online_cpus();\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tcpufreq_driver->boost_enabled = !state;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tpr_err(\"%s: Cannot %s BOOST\\n\",\n\t       __func__, state ? \"enable\" : \"disable\");\n\n\treturn ret;\n}\n\nstatic bool cpufreq_boost_supported(void)\n{\n\treturn cpufreq_driver->set_boost;\n}\n\nstatic int create_boost_sysfs_file(void)\n{\n\tint ret;\n\n\tret = sysfs_create_file(cpufreq_global_kobject, &boost.attr);\n\tif (ret)\n\t\tpr_err(\"%s: cannot register global BOOST sysfs file\\n\",\n\t\t       __func__);\n\n\treturn ret;\n}\n\nstatic void remove_boost_sysfs_file(void)\n{\n\tif (cpufreq_boost_supported())\n\t\tsysfs_remove_file(cpufreq_global_kobject, &boost.attr);\n}\n\nint cpufreq_enable_boost_support(void)\n{\n\tif (!cpufreq_driver)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_boost_supported())\n\t\treturn 0;\n\n\tcpufreq_driver->set_boost = cpufreq_boost_set_sw;\n\n\t/* This will get removed on driver unregister */\n\treturn create_boost_sysfs_file();\n}\nEXPORT_SYMBOL_GPL(cpufreq_enable_boost_support);\n\nint cpufreq_boost_enabled(void)\n{\n\treturn cpufreq_driver->boost_enabled;\n}\nEXPORT_SYMBOL_GPL(cpufreq_boost_enabled);\n\n/*********************************************************************\n *               REGISTER / UNREGISTER CPUFREQ DRIVER                *\n *********************************************************************/\nstatic enum cpuhp_state hp_online;\n\nstatic int cpuhp_cpufreq_online(unsigned int cpu)\n{\n\tcpufreq_online(cpu);\n\n\treturn 0;\n}\n\nstatic int cpuhp_cpufreq_offline(unsigned int cpu)\n{\n\tcpufreq_offline(cpu);\n\n\treturn 0;\n}\n\n/**\n * cpufreq_register_driver - register a CPU Frequency driver\n * @driver_data: A struct cpufreq_driver containing the values#\n * submitted by the CPU Frequency driver.\n *\n * Registers a CPU Frequency driver to this core code. This code\n * returns zero on success, -EEXIST when another driver got here first\n * (and isn't unregistered in the meantime).\n *\n */\nint cpufreq_register_driver(struct cpufreq_driver *driver_data)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\t/*\n\t * The cpufreq core depends heavily on the availability of device\n\t * structure, make sure they are available before proceeding further.\n\t */\n\tif (!get_cpu_device(0))\n\t\treturn -EPROBE_DEFER;\n\n\tif (!driver_data || !driver_data->verify || !driver_data->init ||\n\t    !(driver_data->setpolicy || driver_data->target_index ||\n\t\t    driver_data->target) ||\n\t     (driver_data->setpolicy && (driver_data->target_index ||\n\t\t    driver_data->target)) ||\n\t     (!driver_data->get_intermediate != !driver_data->target_intermediate) ||\n\t     (!driver_data->online != !driver_data->offline))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"trying to register driver %s\\n\", driver_data->name);\n\n\t/* Protect against concurrent CPU online/offline. */\n\tcpus_read_lock();\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tif (cpufreq_driver) {\n\t\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\tcpufreq_driver = driver_data;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\t/*\n\t * Mark support for the scheduler's frequency invariance engine for\n\t * drivers that implement target(), target_index() or fast_switch().\n\t */\n\tif (!cpufreq_driver->setpolicy) {\n\t\tstatic_branch_enable_cpuslocked(&cpufreq_freq_invariance);\n\t\tpr_debug(\"supports frequency invariance\");\n\t}\n\n\tif (driver_data->setpolicy)\n\t\tdriver_data->flags |= CPUFREQ_CONST_LOOPS;\n\n\tif (cpufreq_boost_supported()) {\n\t\tret = create_boost_sysfs_file();\n\t\tif (ret)\n\t\t\tgoto err_null_driver;\n\t}\n\n\tret = subsys_interface_register(&cpufreq_interface);\n\tif (ret)\n\t\tgoto err_boost_unreg;\n\n\tif (unlikely(list_empty(&cpufreq_policy_list))) {\n\t\t/* if all ->init() calls failed, unregister */\n\t\tret = -ENODEV;\n\t\tpr_debug(\"%s: No CPU initialized for driver %s\\n\", __func__,\n\t\t\t driver_data->name);\n\t\tgoto err_if_unreg;\n\t}\n\n\tret = cpuhp_setup_state_nocalls_cpuslocked(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\t   \"cpufreq:online\",\n\t\t\t\t\t\t   cpuhp_cpufreq_online,\n\t\t\t\t\t\t   cpuhp_cpufreq_offline);\n\tif (ret < 0)\n\t\tgoto err_if_unreg;\n\thp_online = ret;\n\tret = 0;\n\n\tpr_debug(\"driver %s up and running\\n\", driver_data->name);\n\tgoto out;\n\nerr_if_unreg:\n\tsubsys_interface_unregister(&cpufreq_interface);\nerr_boost_unreg:\n\tremove_boost_sysfs_file();\nerr_null_driver:\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tcpufreq_driver = NULL;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\nout:\n\tcpus_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cpufreq_register_driver);\n\n/*\n * cpufreq_unregister_driver - unregister the current CPUFreq driver\n *\n * Unregister the current CPUFreq driver. Only call this if you have\n * the right to do so, i.e. if you have succeeded in initialising before!\n * Returns zero if successful, and -EINVAL if the cpufreq_driver is\n * currently not initialised.\n */\nint cpufreq_unregister_driver(struct cpufreq_driver *driver)\n{\n\tunsigned long flags;\n\n\tif (!cpufreq_driver || (driver != cpufreq_driver))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"unregistering driver %s\\n\", driver->name);\n\n\t/* Protect against concurrent cpu hotplug */\n\tcpus_read_lock();\n\tsubsys_interface_unregister(&cpufreq_interface);\n\tremove_boost_sysfs_file();\n\tstatic_branch_disable_cpuslocked(&cpufreq_freq_invariance);\n\tcpuhp_remove_state_nocalls_cpuslocked(hp_online);\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\n\tcpufreq_driver = NULL;\n\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\tcpus_read_unlock();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cpufreq_unregister_driver);\n\nstatic int __init cpufreq_core_init(void)\n{\n\tstruct cpufreq_governor *gov = cpufreq_default_governor();\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\tcpufreq_global_kobject = kobject_create_and_add(\"cpufreq\", &cpu_subsys.dev_root->kobj);\n\tBUG_ON(!cpufreq_global_kobject);\n\n\tif (!strlen(default_governor))\n\t\tstrncpy(default_governor, gov->name, CPUFREQ_NAME_LEN);\n\n\treturn 0;\n}\nmodule_param(off, int, 0444);\nmodule_param_string(default_governor, default_governor, CPUFREQ_NAME_LEN, 0444);\ncore_initcall(cpufreq_core_init);\n"}, "1": {"id": 1, "path": "/src/include/linux/printk.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __KERNEL_PRINTK__\n#define __KERNEL_PRINTK__\n\n#include <stdarg.h>\n#include <linux/init.h>\n#include <linux/kern_levels.h>\n#include <linux/linkage.h>\n#include <linux/cache.h>\n#include <linux/ratelimit_types.h>\n\nextern const char linux_banner[];\nextern const char linux_proc_banner[];\n\nextern int oops_in_progress;\t/* If set, an oops, panic(), BUG() or die() is in progress */\n\n#define PRINTK_MAX_SINGLE_HEADER_LEN 2\n\nstatic inline int printk_get_level(const char *buffer)\n{\n\tif (buffer[0] == KERN_SOH_ASCII && buffer[1]) {\n\t\tswitch (buffer[1]) {\n\t\tcase '0' ... '7':\n\t\tcase 'c':\t/* KERN_CONT */\n\t\t\treturn buffer[1];\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline const char *printk_skip_level(const char *buffer)\n{\n\tif (printk_get_level(buffer))\n\t\treturn buffer + 2;\n\n\treturn buffer;\n}\n\nstatic inline const char *printk_skip_headers(const char *buffer)\n{\n\twhile (printk_get_level(buffer))\n\t\tbuffer = printk_skip_level(buffer);\n\n\treturn buffer;\n}\n\n#define CONSOLE_EXT_LOG_MAX\t8192\n\n/* printk's without a loglevel use this.. */\n#define MESSAGE_LOGLEVEL_DEFAULT CONFIG_MESSAGE_LOGLEVEL_DEFAULT\n\n/* We show everything that is MORE important than this.. */\n#define CONSOLE_LOGLEVEL_SILENT  0 /* Mum's the word */\n#define CONSOLE_LOGLEVEL_MIN\t 1 /* Minimum loglevel we let people use */\n#define CONSOLE_LOGLEVEL_DEBUG\t10 /* issue debug messages */\n#define CONSOLE_LOGLEVEL_MOTORMOUTH 15\t/* You can't shut this one up */\n\n/*\n * Default used to be hard-coded at 7, quiet used to be hardcoded at 4,\n * we're now allowing both to be set from kernel config.\n */\n#define CONSOLE_LOGLEVEL_DEFAULT CONFIG_CONSOLE_LOGLEVEL_DEFAULT\n#define CONSOLE_LOGLEVEL_QUIET\t CONFIG_CONSOLE_LOGLEVEL_QUIET\n\nextern int console_printk[];\n\n#define console_loglevel (console_printk[0])\n#define default_message_loglevel (console_printk[1])\n#define minimum_console_loglevel (console_printk[2])\n#define default_console_loglevel (console_printk[3])\n\nstatic inline void console_silent(void)\n{\n\tconsole_loglevel = CONSOLE_LOGLEVEL_SILENT;\n}\n\nstatic inline void console_verbose(void)\n{\n\tif (console_loglevel)\n\t\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}\n\n/* strlen(\"ratelimit\") + 1 */\n#define DEVKMSG_STR_MAX_SIZE 10\nextern char devkmsg_log_str[];\nstruct ctl_table;\n\nextern int suppress_printk;\n\nstruct va_format {\n\tconst char *fmt;\n\tva_list *va;\n};\n\n/*\n * FW_BUG\n * Add this to a message where you are sure the firmware is buggy or behaves\n * really stupid or out of spec. Be aware that the responsible BIOS developer\n * should be able to fix this issue or at least get a concrete idea of the\n * problem by reading your message without the need of looking at the kernel\n * code.\n *\n * Use it for definite and high priority BIOS bugs.\n *\n * FW_WARN\n * Use it for not that clear (e.g. could the kernel messed up things already?)\n * and medium priority BIOS bugs.\n *\n * FW_INFO\n * Use this one if you want to tell the user or vendor about something\n * suspicious, but generally harmless related to the firmware.\n *\n * Use it for information or very low priority BIOS bugs.\n */\n#define FW_BUG\t\t\"[Firmware Bug]: \"\n#define FW_WARN\t\t\"[Firmware Warn]: \"\n#define FW_INFO\t\t\"[Firmware Info]: \"\n\n/*\n * HW_ERR\n * Add this to a message for hardware errors, so that user can report\n * it to hardware vendor instead of LKML or software vendor.\n */\n#define HW_ERR\t\t\"[Hardware Error]: \"\n\n/*\n * DEPRECATED\n * Add this to a message whenever you want to warn user space about the use\n * of a deprecated aspect of an API so they can stop using it\n */\n#define DEPRECATED\t\"[Deprecated]: \"\n\n/*\n * Dummy printk for disabled debugging statements to use whilst maintaining\n * gcc's format checking.\n */\n#define no_printk(fmt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\t\\\n\t0;\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_EARLY_PRINTK\nextern asmlinkage __printf(1, 2)\nvoid early_printk(const char *fmt, ...);\n#else\nstatic inline __printf(1, 2) __cold\nvoid early_printk(const char *s, ...) { }\n#endif\n\n#ifdef CONFIG_PRINTK_NMI\nextern void printk_nmi_enter(void);\nextern void printk_nmi_exit(void);\nextern void printk_nmi_direct_enter(void);\nextern void printk_nmi_direct_exit(void);\n#else\nstatic inline void printk_nmi_enter(void) { }\nstatic inline void printk_nmi_exit(void) { }\nstatic inline void printk_nmi_direct_enter(void) { }\nstatic inline void printk_nmi_direct_exit(void) { }\n#endif /* PRINTK_NMI */\n\nstruct dev_printk_info;\n\n#ifdef CONFIG_PRINTK\nasmlinkage __printf(4, 0)\nint vprintk_emit(int facility, int level,\n\t\t const struct dev_printk_info *dev_info,\n\t\t const char *fmt, va_list args);\n\nasmlinkage __printf(1, 0)\nint vprintk(const char *fmt, va_list args);\n\nasmlinkage __printf(1, 2) __cold\nint printk(const char *fmt, ...);\n\n/*\n * Special printk facility for scheduler/timekeeping use only, _DO_NOT_USE_ !\n */\n__printf(1, 2) __cold int printk_deferred(const char *fmt, ...);\n\n/*\n * Please don't use printk_ratelimit(), because it shares ratelimiting state\n * with all other unrelated printk_ratelimit() callsites.  Instead use\n * printk_ratelimited() or plain old __ratelimit().\n */\nextern int __printk_ratelimit(const char *func);\n#define printk_ratelimit() __printk_ratelimit(__func__)\nextern bool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\t\t   unsigned int interval_msec);\n\nextern int printk_delay_msec;\nextern int dmesg_restrict;\n\nextern int\ndevkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void *buf,\n\t\t\t  size_t *lenp, loff_t *ppos);\n\nextern void wake_up_klogd(void);\n\nchar *log_buf_addr_get(void);\nu32 log_buf_len_get(void);\nvoid log_buf_vmcoreinfo_setup(void);\nvoid __init setup_log_buf(int early);\n__printf(1, 2) void dump_stack_set_arch_desc(const char *fmt, ...);\nvoid dump_stack_print_info(const char *log_lvl);\nvoid show_regs_print_info(const char *log_lvl);\nextern asmlinkage void dump_stack(void) __cold;\nextern void printk_safe_flush(void);\nextern void printk_safe_flush_on_panic(void);\n#else\nstatic inline __printf(1, 0)\nint vprintk(const char *s, va_list args)\n{\n\treturn 0;\n}\nstatic inline __printf(1, 2) __cold\nint printk(const char *s, ...)\n{\n\treturn 0;\n}\nstatic inline __printf(1, 2) __cold\nint printk_deferred(const char *s, ...)\n{\n\treturn 0;\n}\nstatic inline int printk_ratelimit(void)\n{\n\treturn 0;\n}\nstatic inline bool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\t\t\t  unsigned int interval_msec)\n{\n\treturn false;\n}\n\nstatic inline void wake_up_klogd(void)\n{\n}\n\nstatic inline char *log_buf_addr_get(void)\n{\n\treturn NULL;\n}\n\nstatic inline u32 log_buf_len_get(void)\n{\n\treturn 0;\n}\n\nstatic inline void log_buf_vmcoreinfo_setup(void)\n{\n}\n\nstatic inline void setup_log_buf(int early)\n{\n}\n\nstatic inline __printf(1, 2) void dump_stack_set_arch_desc(const char *fmt, ...)\n{\n}\n\nstatic inline void dump_stack_print_info(const char *log_lvl)\n{\n}\n\nstatic inline void show_regs_print_info(const char *log_lvl)\n{\n}\n\nstatic inline void dump_stack(void)\n{\n}\n\nstatic inline void printk_safe_flush(void)\n{\n}\n\nstatic inline void printk_safe_flush_on_panic(void)\n{\n}\n#endif\n\nextern int kptr_restrict;\n\n/**\n * pr_fmt - used by the pr_*() macros to generate the printk format string\n * @fmt: format string passed from a pr_*() macro\n *\n * This macro can be used to generate a unified format string for pr_*()\n * macros. A common use is to prefix all pr_*() messages in a file with a common\n * string. For example, defining this at the top of a source file:\n *\n *        #define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n *\n * would prefix all pr_info, pr_emerg... messages in the file with the module\n * name.\n */\n#ifndef pr_fmt\n#define pr_fmt(fmt) fmt\n#endif\n\n/**\n * pr_emerg - Print an emergency-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_EMERG loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_emerg(fmt, ...) \\\n\tprintk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_alert - Print an alert-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_ALERT loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_alert(fmt, ...) \\\n\tprintk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_crit - Print a critical-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_CRIT loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_crit(fmt, ...) \\\n\tprintk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_err - Print an error-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_ERR loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_err(fmt, ...) \\\n\tprintk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_warn - Print a warning-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_WARNING loglevel. It uses pr_fmt()\n * to generate the format string.\n */\n#define pr_warn(fmt, ...) \\\n\tprintk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_notice - Print a notice-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_NOTICE loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_notice(fmt, ...) \\\n\tprintk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)\n/**\n * pr_info - Print an info-level message\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_INFO loglevel. It uses pr_fmt() to\n * generate the format string.\n */\n#define pr_info(fmt, ...) \\\n\tprintk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)\n\n/**\n * pr_cont - Continues a previous log message in the same line.\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_CONT loglevel. It should only be\n * used when continuing a log message with no newline ('\\n') enclosed. Otherwise\n * it defaults back to KERN_DEFAULT loglevel.\n */\n#define pr_cont(fmt, ...) \\\n\tprintk(KERN_CONT fmt, ##__VA_ARGS__)\n\n/**\n * pr_devel - Print a debug-level message conditionally\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to a printk with KERN_DEBUG loglevel if DEBUG is\n * defined. Otherwise it does nothing.\n *\n * It uses pr_fmt() to generate the format string.\n */\n#ifdef DEBUG\n#define pr_devel(fmt, ...) \\\n\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_devel(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n\n/* If you are writing a driver, please use dev_dbg instead */\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#include <linux/dynamic_debug.h>\n\n/**\n * pr_debug - Print a debug-level message conditionally\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to dynamic_pr_debug() if CONFIG_DYNAMIC_DEBUG is\n * set. Otherwise, if DEBUG is defined, it's equivalent to a printk with\n * KERN_DEBUG loglevel. If DEBUG is not defined it does nothing.\n *\n * It uses pr_fmt() to generate the format string (dynamic_pr_debug() uses\n * pr_fmt() internally).\n */\n#define pr_debug(fmt, ...)\t\t\t\\\n\tdynamic_pr_debug(fmt, ##__VA_ARGS__)\n#elif defined(DEBUG)\n#define pr_debug(fmt, ...) \\\n\tprintk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/*\n * Print a one-time message (analogous to WARN_ONCE() et al):\n */\n\n#ifdef CONFIG_PRINTK\n#define printk_once(fmt, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __print_once;\t\\\n\tbool __ret_print_once = !__print_once;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\t\t\\\n\t\t__print_once = true;\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_print_once);\t\t\t\t\\\n})\n#define printk_deferred_once(fmt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __print_once;\t\\\n\tbool __ret_print_once = !__print_once;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!__print_once) {\t\t\t\t\t\\\n\t\t__print_once = true;\t\t\t\t\\\n\t\tprintk_deferred(fmt, ##__VA_ARGS__);\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_print_once);\t\t\t\t\\\n})\n#else\n#define printk_once(fmt, ...)\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__)\n#define printk_deferred_once(fmt, ...)\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n#define pr_emerg_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_alert_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_crit_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_err_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_warn_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_notice_once(fmt, ...)\t\t\t\t\\\n\tprintk_once(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_info_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)\n/* no pr_cont_once, don't do that... */\n\n#if defined(DEBUG)\n#define pr_devel_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_devel_once(fmt, ...)\t\t\t\t\t\\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/* If you are writing a driver, please use dev_dbg instead */\n#if defined(DEBUG)\n#define pr_debug_once(fmt, ...)\t\t\t\t\t\\\n\tprintk_once(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug_once(fmt, ...)\t\t\t\t\t\\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/*\n * ratelimited messages with local ratelimit_state,\n * no local ratelimit_state used in the !PRINTK case\n */\n#ifdef CONFIG_PRINTK\n#define printk_ratelimited(fmt, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,\t\t\t\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__ratelimit(&_rs))\t\t\t\t\t\t\\\n\t\tprintk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n})\n#else\n#define printk_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__)\n#endif\n\n#define pr_emerg_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_alert_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_crit_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_err_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_warn_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_notice_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)\n#define pr_info_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)\n/* no pr_cont_ratelimited, don't do that... */\n\n#if defined(DEBUG)\n#define pr_devel_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_devel_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\n/* If you are writing a driver, please use dev_dbg instead */\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n/* descriptor check is first to prevent flooding with \"callbacks suppressed\" */\n#define pr_debug_ratelimited(fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic DEFINE_RATELIMIT_STATE(_rs,\t\t\t\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_INTERVAL,\t\\\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\t\t\\\n\tDEFINE_DYNAMIC_DEBUG_METADATA(descriptor, pr_fmt(fmt));\t\t\\\n\tif (DYNAMIC_DEBUG_BRANCH(descriptor) &&\t\t\t\t\\\n\t    __ratelimit(&_rs))\t\t\t\t\t\t\\\n\t\t__dynamic_pr_debug(&descriptor, pr_fmt(fmt), ##__VA_ARGS__);\t\\\n} while (0)\n#elif defined(DEBUG)\n#define pr_debug_ratelimited(fmt, ...)\t\t\t\t\t\\\n\tprintk_ratelimited(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug_ratelimited(fmt, ...) \\\n\tno_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n\nextern const struct file_operations kmsg_fops;\n\nenum {\n\tDUMP_PREFIX_NONE,\n\tDUMP_PREFIX_ADDRESS,\n\tDUMP_PREFIX_OFFSET\n};\nextern int hex_dump_to_buffer(const void *buf, size_t len, int rowsize,\n\t\t\t      int groupsize, char *linebuf, size_t linebuflen,\n\t\t\t      bool ascii);\n#ifdef CONFIG_PRINTK\nextern void print_hex_dump(const char *level, const char *prefix_str,\n\t\t\t   int prefix_type, int rowsize, int groupsize,\n\t\t\t   const void *buf, size_t len, bool ascii);\n#else\nstatic inline void print_hex_dump(const char *level, const char *prefix_str,\n\t\t\t\t  int prefix_type, int rowsize, int groupsize,\n\t\t\t\t  const void *buf, size_t len, bool ascii)\n{\n}\nstatic inline void print_hex_dump_bytes(const char *prefix_str, int prefix_type,\n\t\t\t\t\tconst void *buf, size_t len)\n{\n}\n\n#endif\n\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined(CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#define print_hex_dump_debug(prefix_str, prefix_type, rowsize,\t\\\n\t\t\t     groupsize, buf, len, ascii)\t\\\n\tdynamic_hex_dump(prefix_str, prefix_type, rowsize,\t\\\n\t\t\t groupsize, buf, len, ascii)\n#elif defined(DEBUG)\n#define print_hex_dump_debug(prefix_str, prefix_type, rowsize,\t\t\\\n\t\t\t     groupsize, buf, len, ascii)\t\t\\\n\tprint_hex_dump(KERN_DEBUG, prefix_str, prefix_type, rowsize,\t\\\n\t\t       groupsize, buf, len, ascii)\n#else\nstatic inline void print_hex_dump_debug(const char *prefix_str, int prefix_type,\n\t\t\t\t\tint rowsize, int groupsize,\n\t\t\t\t\tconst void *buf, size_t len, bool ascii)\n{\n}\n#endif\n\n/**\n * print_hex_dump_bytes - shorthand form of print_hex_dump() with default params\n * @prefix_str: string to prefix each line with;\n *  caller supplies trailing spaces for alignment if desired\n * @prefix_type: controls whether prefix of an offset, address, or none\n *  is printed (%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE)\n * @buf: data blob to dump\n * @len: number of bytes in the @buf\n *\n * Calls print_hex_dump(), with log level of KERN_DEBUG,\n * rowsize of 16, groupsize of 1, and ASCII output included.\n */\n#define print_hex_dump_bytes(prefix_str, prefix_type, buf, len)\t\\\n\tprint_hex_dump_debug(prefix_str, prefix_type, 16, 1, buf, len, true)\n\n#endif\n"}, "2": {"id": 2, "path": "/src/include/linux/percpu-defs.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * linux/percpu-defs.h - basic definitions for percpu areas\n *\n * DO NOT INCLUDE DIRECTLY OUTSIDE PERCPU IMPLEMENTATION PROPER.\n *\n * This file is separate from linux/percpu.h to avoid cyclic inclusion\n * dependency from arch header files.  Only to be included from\n * asm/percpu.h.\n *\n * This file includes macros necessary to declare percpu sections and\n * variables, and definitions of percpu accessors and operations.  It\n * should provide enough percpu features to arch header files even when\n * they can only include asm/percpu.h to avoid cyclic inclusion dependency.\n */\n\n#ifndef _LINUX_PERCPU_DEFS_H\n#define _LINUX_PERCPU_DEFS_H\n\n#ifdef CONFIG_SMP\n\n#ifdef MODULE\n#define PER_CPU_SHARED_ALIGNED_SECTION \"\"\n#define PER_CPU_ALIGNED_SECTION \"\"\n#else\n#define PER_CPU_SHARED_ALIGNED_SECTION \"..shared_aligned\"\n#define PER_CPU_ALIGNED_SECTION \"..shared_aligned\"\n#endif\n#define PER_CPU_FIRST_SECTION \"..first\"\n\n#else\n\n#define PER_CPU_SHARED_ALIGNED_SECTION \"\"\n#define PER_CPU_ALIGNED_SECTION \"..shared_aligned\"\n#define PER_CPU_FIRST_SECTION \"\"\n\n#endif\n\n/*\n * Base implementations of per-CPU variable declarations and definitions, where\n * the section in which the variable is to be placed is provided by the\n * 'sec' argument.  This may be used to affect the parameters governing the\n * variable's storage.\n *\n * NOTE!  The sections for the DECLARE and for the DEFINE must match, lest\n * linkage errors occur due the compiler generating the wrong code to access\n * that section.\n */\n#define __PCPU_ATTRS(sec)\t\t\t\t\t\t\\\n\t__percpu __attribute__((section(PER_CPU_BASE_SECTION sec)))\t\\\n\tPER_CPU_ATTRIBUTES\n\n#define __PCPU_DUMMY_ATTRS\t\t\t\t\t\t\\\n\t__section(\".discard\") __attribute__((unused))\n\n/*\n * s390 and alpha modules require percpu variables to be defined as\n * weak to force the compiler to generate GOT based external\n * references for them.  This is necessary because percpu sections\n * will be located outside of the usually addressable area.\n *\n * This definition puts the following two extra restrictions when\n * defining percpu variables.\n *\n * 1. The symbol must be globally unique, even the static ones.\n * 2. Static percpu variables cannot be defined inside a function.\n *\n * Archs which need weak percpu definitions should define\n * ARCH_NEEDS_WEAK_PER_CPU in asm/percpu.h when necessary.\n *\n * To ensure that the generic code observes the above two\n * restrictions, if CONFIG_DEBUG_FORCE_WEAK_PER_CPU is set weak\n * definition is used for all cases.\n */\n#if defined(ARCH_NEEDS_WEAK_PER_CPU) || defined(CONFIG_DEBUG_FORCE_WEAK_PER_CPU)\n/*\n * __pcpu_scope_* dummy variable is used to enforce scope.  It\n * receives the static modifier when it's used in front of\n * DEFINE_PER_CPU() and will trigger build failure if\n * DECLARE_PER_CPU() is used for the same variable.\n *\n * __pcpu_unique_* dummy variable is used to enforce symbol uniqueness\n * such that hidden weak symbol collision, which will cause unrelated\n * variables to share the same address, can be detected during build.\n */\n#define DECLARE_PER_CPU_SECTION(type, name, sec)\t\t\t\\\n\textern __PCPU_DUMMY_ATTRS char __pcpu_scope_##name;\t\t\\\n\textern __PCPU_ATTRS(sec) __typeof__(type) name\n\n#define DEFINE_PER_CPU_SECTION(type, name, sec)\t\t\t\t\\\n\t__PCPU_DUMMY_ATTRS char __pcpu_scope_##name;\t\t\t\\\n\textern __PCPU_DUMMY_ATTRS char __pcpu_unique_##name;\t\t\\\n\t__PCPU_DUMMY_ATTRS char __pcpu_unique_##name;\t\t\t\\\n\textern __PCPU_ATTRS(sec) __typeof__(type) name;\t\t\t\\\n\t__PCPU_ATTRS(sec) __weak __typeof__(type) name\n#else\n/*\n * Normal declaration and definition macros.\n */\n#define DECLARE_PER_CPU_SECTION(type, name, sec)\t\t\t\\\n\textern __PCPU_ATTRS(sec) __typeof__(type) name\n\n#define DEFINE_PER_CPU_SECTION(type, name, sec)\t\t\t\t\\\n\t__PCPU_ATTRS(sec) __typeof__(type) name\n#endif\n\n/*\n * Variant on the per-CPU variable declaration/definition theme used for\n * ordinary per-CPU variables.\n */\n#define DECLARE_PER_CPU(type, name)\t\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"\")\n\n#define DEFINE_PER_CPU(type, name)\t\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"\")\n\n/*\n * Declaration/definition used for per-CPU variables that must come first in\n * the set of variables.\n */\n#define DECLARE_PER_CPU_FIRST(type, name)\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)\n\n#define DEFINE_PER_CPU_FIRST(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, PER_CPU_FIRST_SECTION)\n\n/*\n * Declaration/definition used for per-CPU variables that must be cacheline\n * aligned under SMP conditions so that, whilst a particular instance of the\n * data corresponds to a particular CPU, inefficiencies due to direct access by\n * other CPUs are reduced by preventing the data from unnecessarily spanning\n * cachelines.\n *\n * An example of this would be statistical data, where each CPU's set of data\n * is updated by that CPU alone, but the data from across all CPUs is collated\n * by a CPU processing a read from a proc file.\n */\n#define DECLARE_PER_CPU_SHARED_ALIGNED(type, name)\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \\\n\t____cacheline_aligned_in_smp\n\n#define DEFINE_PER_CPU_SHARED_ALIGNED(type, name)\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, PER_CPU_SHARED_ALIGNED_SECTION) \\\n\t____cacheline_aligned_in_smp\n\n#define DECLARE_PER_CPU_ALIGNED(type, name)\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, PER_CPU_ALIGNED_SECTION)\t\\\n\t____cacheline_aligned\n\n#define DEFINE_PER_CPU_ALIGNED(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, PER_CPU_ALIGNED_SECTION)\t\\\n\t____cacheline_aligned\n\n/*\n * Declaration/definition used for per-CPU variables that must be page aligned.\n */\n#define DECLARE_PER_CPU_PAGE_ALIGNED(type, name)\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"..page_aligned\")\t\t\\\n\t__aligned(PAGE_SIZE)\n\n#define DEFINE_PER_CPU_PAGE_ALIGNED(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"..page_aligned\")\t\t\\\n\t__aligned(PAGE_SIZE)\n\n/*\n * Declaration/definition used for per-CPU variables that must be read mostly.\n */\n#define DECLARE_PER_CPU_READ_MOSTLY(type, name)\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"..read_mostly\")\n\n#define DEFINE_PER_CPU_READ_MOSTLY(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"..read_mostly\")\n\n/*\n * Declaration/definition used for per-CPU variables that should be accessed\n * as decrypted when memory encryption is enabled in the guest.\n */\n#ifdef CONFIG_AMD_MEM_ENCRYPT\n#define DECLARE_PER_CPU_DECRYPTED(type, name)\t\t\t\t\\\n\tDECLARE_PER_CPU_SECTION(type, name, \"..decrypted\")\n\n#define DEFINE_PER_CPU_DECRYPTED(type, name)\t\t\t\t\\\n\tDEFINE_PER_CPU_SECTION(type, name, \"..decrypted\")\n#else\n#define DEFINE_PER_CPU_DECRYPTED(type, name)\tDEFINE_PER_CPU(type, name)\n#endif\n\n/*\n * Intermodule exports for per-CPU variables.  sparse forgets about\n * address space across EXPORT_SYMBOL(), change EXPORT_SYMBOL() to\n * noop if __CHECKER__.\n */\n#ifndef __CHECKER__\n#define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(var)\n#define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(var)\n#else\n#define EXPORT_PER_CPU_SYMBOL(var)\n#define EXPORT_PER_CPU_SYMBOL_GPL(var)\n#endif\n\n/*\n * Accessors and operations.\n */\n#ifndef __ASSEMBLY__\n\n/*\n * __verify_pcpu_ptr() verifies @ptr is a percpu pointer without evaluating\n * @ptr and is invoked once before a percpu area is accessed by all\n * accessors and operations.  This is performed in the generic part of\n * percpu and arch overrides don't need to worry about it; however, if an\n * arch wants to implement an arch-specific percpu accessor or operation,\n * it may use __verify_pcpu_ptr() to verify the parameters.\n *\n * + 0 is required in order to convert the pointer type from a\n * potential array type to a pointer to a single item of the array.\n */\n#define __verify_pcpu_ptr(ptr)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tconst void __percpu *__vpp_verify = (typeof((ptr) + 0))NULL;\t\\\n\t(void)__vpp_verify;\t\t\t\t\t\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n\n/*\n * Add an offset to a pointer but keep the pointer as-is.  Use RELOC_HIDE()\n * to prevent the compiler from making incorrect assumptions about the\n * pointer value.  The weird cast keeps both GCC and sparse happy.\n */\n#define SHIFT_PERCPU_PTR(__p, __offset)\t\t\t\t\t\\\n\tRELOC_HIDE((typeof(*(__p)) __kernel __force *)(__p), (__offset))\n\n#define per_cpu_ptr(ptr, cpu)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(ptr);\t\t\t\t\t\t\\\n\tSHIFT_PERCPU_PTR((ptr), per_cpu_offset((cpu)));\t\t\t\\\n})\n\n#define raw_cpu_ptr(ptr)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(ptr);\t\t\t\t\t\t\\\n\tarch_raw_cpu_ptr(ptr);\t\t\t\t\t\t\\\n})\n\n#ifdef CONFIG_DEBUG_PREEMPT\n#define this_cpu_ptr(ptr)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(ptr);\t\t\t\t\t\t\\\n\tSHIFT_PERCPU_PTR(ptr, my_cpu_offset);\t\t\t\t\\\n})\n#else\n#define this_cpu_ptr(ptr) raw_cpu_ptr(ptr)\n#endif\n\n#else\t/* CONFIG_SMP */\n\n#define VERIFY_PERCPU_PTR(__p)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(__p);\t\t\t\t\t\t\\\n\t(typeof(*(__p)) __kernel __force *)(__p);\t\t\t\\\n})\n\n#define per_cpu_ptr(ptr, cpu)\t({ (void)(cpu); VERIFY_PERCPU_PTR(ptr); })\n#define raw_cpu_ptr(ptr)\tper_cpu_ptr(ptr, 0)\n#define this_cpu_ptr(ptr)\traw_cpu_ptr(ptr)\n\n#endif\t/* CONFIG_SMP */\n\n#define per_cpu(var, cpu)\t(*per_cpu_ptr(&(var), cpu))\n\n/*\n * Must be an lvalue. Since @var must be a simple identifier,\n * we force a syntax error here if it isn't.\n */\n#define get_cpu_var(var)\t\t\t\t\t\t\\\n(*({\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\tthis_cpu_ptr(&var);\t\t\t\t\t\t\\\n}))\n\n/*\n * The weird & is necessary because sparse considers (void)(var) to be\n * a direct dereference of percpu variable (var).\n */\n#define put_cpu_var(var)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(void)&(var);\t\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n} while (0)\n\n#define get_cpu_ptr(var)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tpreempt_disable();\t\t\t\t\t\t\\\n\tthis_cpu_ptr(var);\t\t\t\t\t\t\\\n})\n\n#define put_cpu_ptr(var)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t(void)(var);\t\t\t\t\t\t\t\\\n\tpreempt_enable();\t\t\t\t\t\t\\\n} while (0)\n\n/*\n * Branching function to split up a function into a set of functions that\n * are called for different scalar sizes of the objects handled.\n */\n\nextern void __bad_size_call_parameter(void);\n\n#ifdef CONFIG_DEBUG_PREEMPT\nextern void __this_cpu_preempt_check(const char *op);\n#else\nstatic inline void __this_cpu_preempt_check(const char *op) { }\n#endif\n\n#define __pcpu_size_call_return(stem, variable)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(variable) pscr_ret__;\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(variable));\t\t\t\t\t\\\n\tswitch(sizeof(variable)) {\t\t\t\t\t\\\n\tcase 1: pscr_ret__ = stem##1(variable); break;\t\t\t\\\n\tcase 2: pscr_ret__ = stem##2(variable); break;\t\t\t\\\n\tcase 4: pscr_ret__ = stem##4(variable); break;\t\t\t\\\n\tcase 8: pscr_ret__ = stem##8(variable); break;\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t__bad_size_call_parameter(); break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpscr_ret__;\t\t\t\t\t\t\t\\\n})\n\n#define __pcpu_size_call_return2(stem, variable, ...)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(variable) pscr2_ret__;\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(variable));\t\t\t\t\t\\\n\tswitch(sizeof(variable)) {\t\t\t\t\t\\\n\tcase 1: pscr2_ret__ = stem##1(variable, __VA_ARGS__); break;\t\\\n\tcase 2: pscr2_ret__ = stem##2(variable, __VA_ARGS__); break;\t\\\n\tcase 4: pscr2_ret__ = stem##4(variable, __VA_ARGS__); break;\t\\\n\tcase 8: pscr2_ret__ = stem##8(variable, __VA_ARGS__); break;\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t__bad_size_call_parameter(); break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpscr2_ret__;\t\t\t\t\t\t\t\\\n})\n\n/*\n * Special handling for cmpxchg_double.  cmpxchg_double is passed two\n * percpu variables.  The first has to be aligned to a double word\n * boundary and the second has to follow directly thereafter.\n * We enforce this on all architectures even if they don't support\n * a double cmpxchg instruction, since it's a cheap requirement, and it\n * avoids breaking the requirement for architectures with the instruction.\n */\n#define __pcpu_double_call_return_bool(stem, pcp1, pcp2, ...)\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tbool pdcrb_ret__;\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(pcp1));\t\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(pcp1) != sizeof(pcp2));\t\t\t\\\n\tVM_BUG_ON((unsigned long)(&(pcp1)) % (2 * sizeof(pcp1)));\t\\\n\tVM_BUG_ON((unsigned long)(&(pcp2)) !=\t\t\t\t\\\n\t\t  (unsigned long)(&(pcp1)) + sizeof(pcp1));\t\t\\\n\tswitch(sizeof(pcp1)) {\t\t\t\t\t\t\\\n\tcase 1: pdcrb_ret__ = stem##1(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tcase 2: pdcrb_ret__ = stem##2(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tcase 4: pdcrb_ret__ = stem##4(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tcase 8: pdcrb_ret__ = stem##8(pcp1, pcp2, __VA_ARGS__); break;\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\t__bad_size_call_parameter(); break;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tpdcrb_ret__;\t\t\t\t\t\t\t\\\n})\n\n#define __pcpu_size_call(stem, variable, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__verify_pcpu_ptr(&(variable));\t\t\t\t\t\\\n\tswitch(sizeof(variable)) {\t\t\t\t\t\\\n\t\tcase 1: stem##1(variable, __VA_ARGS__);break;\t\t\\\n\t\tcase 2: stem##2(variable, __VA_ARGS__);break;\t\t\\\n\t\tcase 4: stem##4(variable, __VA_ARGS__);break;\t\t\\\n\t\tcase 8: stem##8(variable, __VA_ARGS__);break;\t\t\\\n\t\tdefault: \t\t\t\t\t\t\\\n\t\t\t__bad_size_call_parameter();break;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n/*\n * this_cpu operations (C) 2008-2013 Christoph Lameter <cl@linux.com>\n *\n * Optimized manipulation for memory allocated through the per cpu\n * allocator or for addresses of per cpu variables.\n *\n * These operation guarantee exclusivity of access for other operations\n * on the *same* processor. The assumption is that per cpu data is only\n * accessed by a single processor instance (the current one).\n *\n * The arch code can provide optimized implementation by defining macros\n * for certain scalar sizes. F.e. provide this_cpu_add_2() to provide per\n * cpu atomic operations for 2 byte sized RMW actions. If arch code does\n * not provide operations for a scalar size then the fallback in the\n * generic code will be used.\n *\n * cmpxchg_double replaces two adjacent scalars at once.  The first two\n * parameters are per cpu variables which have to be of the same size.  A\n * truth value is returned to indicate success or failure (since a double\n * register result is difficult to handle).  There is very limited hardware\n * support for these operations, so only certain sizes may work.\n */\n\n/*\n * Operations for contexts where we do not want to do any checks for\n * preemptions.  Unless strictly necessary, always use [__]this_cpu_*()\n * instead.\n *\n * If there is no other protection through preempt disable and/or disabling\n * interupts then one of these RMW operations can show unexpected behavior\n * because the execution thread was rescheduled on another processor or an\n * interrupt occurred and the same percpu variable was modified from the\n * interrupt context.\n */\n#define raw_cpu_read(pcp)\t\t__pcpu_size_call_return(raw_cpu_read_, pcp)\n#define raw_cpu_write(pcp, val)\t\t__pcpu_size_call(raw_cpu_write_, pcp, val)\n#define raw_cpu_add(pcp, val)\t\t__pcpu_size_call(raw_cpu_add_, pcp, val)\n#define raw_cpu_and(pcp, val)\t\t__pcpu_size_call(raw_cpu_and_, pcp, val)\n#define raw_cpu_or(pcp, val)\t\t__pcpu_size_call(raw_cpu_or_, pcp, val)\n#define raw_cpu_add_return(pcp, val)\t__pcpu_size_call_return2(raw_cpu_add_return_, pcp, val)\n#define raw_cpu_xchg(pcp, nval)\t\t__pcpu_size_call_return2(raw_cpu_xchg_, pcp, nval)\n#define raw_cpu_cmpxchg(pcp, oval, nval) \\\n\t__pcpu_size_call_return2(raw_cpu_cmpxchg_, pcp, oval, nval)\n#define raw_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2) \\\n\t__pcpu_double_call_return_bool(raw_cpu_cmpxchg_double_, pcp1, pcp2, oval1, oval2, nval1, nval2)\n\n#define raw_cpu_sub(pcp, val)\t\traw_cpu_add(pcp, -(val))\n#define raw_cpu_inc(pcp)\t\traw_cpu_add(pcp, 1)\n#define raw_cpu_dec(pcp)\t\traw_cpu_sub(pcp, 1)\n#define raw_cpu_sub_return(pcp, val)\traw_cpu_add_return(pcp, -(typeof(pcp))(val))\n#define raw_cpu_inc_return(pcp)\t\traw_cpu_add_return(pcp, 1)\n#define raw_cpu_dec_return(pcp)\t\traw_cpu_add_return(pcp, -1)\n\n/*\n * Operations for contexts that are safe from preemption/interrupts.  These\n * operations verify that preemption is disabled.\n */\n#define __this_cpu_read(pcp)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"read\");\t\t\t\t\\\n\traw_cpu_read(pcp);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_write(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"write\");\t\t\t\t\\\n\traw_cpu_write(pcp, val);\t\t\t\t\t\\\n})\n\n#define __this_cpu_add(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"add\");\t\t\t\t\\\n\traw_cpu_add(pcp, val);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_and(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"and\");\t\t\t\t\\\n\traw_cpu_and(pcp, val);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_or(pcp, val)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"or\");\t\t\t\t\t\\\n\traw_cpu_or(pcp, val);\t\t\t\t\t\t\\\n})\n\n#define __this_cpu_add_return(pcp, val)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"add_return\");\t\t\t\t\\\n\traw_cpu_add_return(pcp, val);\t\t\t\t\t\\\n})\n\n#define __this_cpu_xchg(pcp, nval)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"xchg\");\t\t\t\t\\\n\traw_cpu_xchg(pcp, nval);\t\t\t\t\t\\\n})\n\n#define __this_cpu_cmpxchg(pcp, oval, nval)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__this_cpu_preempt_check(\"cmpxchg\");\t\t\t\t\\\n\traw_cpu_cmpxchg(pcp, oval, nval);\t\t\t\t\\\n})\n\n#define __this_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2) \\\n({\t__this_cpu_preempt_check(\"cmpxchg_double\");\t\t\t\\\n\traw_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2);\t\\\n})\n\n#define __this_cpu_sub(pcp, val)\t__this_cpu_add(pcp, -(typeof(pcp))(val))\n#define __this_cpu_inc(pcp)\t\t__this_cpu_add(pcp, 1)\n#define __this_cpu_dec(pcp)\t\t__this_cpu_sub(pcp, 1)\n#define __this_cpu_sub_return(pcp, val)\t__this_cpu_add_return(pcp, -(typeof(pcp))(val))\n#define __this_cpu_inc_return(pcp)\t__this_cpu_add_return(pcp, 1)\n#define __this_cpu_dec_return(pcp)\t__this_cpu_add_return(pcp, -1)\n\n/*\n * Operations with implied preemption/interrupt protection.  These\n * operations can be used without worrying about preemption or interrupt.\n */\n#define this_cpu_read(pcp)\t\t__pcpu_size_call_return(this_cpu_read_, pcp)\n#define this_cpu_write(pcp, val)\t__pcpu_size_call(this_cpu_write_, pcp, val)\n#define this_cpu_add(pcp, val)\t\t__pcpu_size_call(this_cpu_add_, pcp, val)\n#define this_cpu_and(pcp, val)\t\t__pcpu_size_call(this_cpu_and_, pcp, val)\n#define this_cpu_or(pcp, val)\t\t__pcpu_size_call(this_cpu_or_, pcp, val)\n#define this_cpu_add_return(pcp, val)\t__pcpu_size_call_return2(this_cpu_add_return_, pcp, val)\n#define this_cpu_xchg(pcp, nval)\t__pcpu_size_call_return2(this_cpu_xchg_, pcp, nval)\n#define this_cpu_cmpxchg(pcp, oval, nval) \\\n\t__pcpu_size_call_return2(this_cpu_cmpxchg_, pcp, oval, nval)\n#define this_cpu_cmpxchg_double(pcp1, pcp2, oval1, oval2, nval1, nval2) \\\n\t__pcpu_double_call_return_bool(this_cpu_cmpxchg_double_, pcp1, pcp2, oval1, oval2, nval1, nval2)\n\n#define this_cpu_sub(pcp, val)\t\tthis_cpu_add(pcp, -(typeof(pcp))(val))\n#define this_cpu_inc(pcp)\t\tthis_cpu_add(pcp, 1)\n#define this_cpu_dec(pcp)\t\tthis_cpu_sub(pcp, 1)\n#define this_cpu_sub_return(pcp, val)\tthis_cpu_add_return(pcp, -(typeof(pcp))(val))\n#define this_cpu_inc_return(pcp)\tthis_cpu_add_return(pcp, 1)\n#define this_cpu_dec_return(pcp)\tthis_cpu_add_return(pcp, -1)\n\n#endif /* __ASSEMBLY__ */\n#endif /* _LINUX_PERCPU_DEFS_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/cpufreq.h", "content": "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * linux/include/linux/cpufreq.h\n *\n * Copyright (C) 2001 Russell King\n *           (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>\n */\n#ifndef _LINUX_CPUFREQ_H\n#define _LINUX_CPUFREQ_H\n\n#include <linux/clk.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/kobject.h>\n#include <linux/notifier.h>\n#include <linux/pm_qos.h>\n#include <linux/spinlock.h>\n#include <linux/sysfs.h>\n\n/*********************************************************************\n *                        CPUFREQ INTERFACE                          *\n *********************************************************************/\n/*\n * Frequency values here are CPU kHz\n *\n * Maximum transition latency is in nanoseconds - if it's unknown,\n * CPUFREQ_ETERNAL shall be used.\n */\n\n#define CPUFREQ_ETERNAL\t\t\t(-1)\n#define CPUFREQ_NAME_LEN\t\t16\n/* Print length for names. Extra 1 space for accommodating '\\n' in prints */\n#define CPUFREQ_NAME_PLEN\t\t(CPUFREQ_NAME_LEN + 1)\n\nstruct cpufreq_governor;\n\nenum cpufreq_table_sorting {\n\tCPUFREQ_TABLE_UNSORTED,\n\tCPUFREQ_TABLE_SORTED_ASCENDING,\n\tCPUFREQ_TABLE_SORTED_DESCENDING\n};\n\nstruct cpufreq_cpuinfo {\n\tunsigned int\t\tmax_freq;\n\tunsigned int\t\tmin_freq;\n\n\t/* in 10^(-9) s = nanoseconds */\n\tunsigned int\t\ttransition_latency;\n};\n\nstruct cpufreq_policy {\n\t/* CPUs sharing clock, require sw coordination */\n\tcpumask_var_t\t\tcpus;\t/* Online CPUs only */\n\tcpumask_var_t\t\trelated_cpus; /* Online + Offline CPUs */\n\tcpumask_var_t\t\treal_cpus; /* Related and present */\n\n\tunsigned int\t\tshared_type; /* ACPI: ANY or ALL affected CPUs\n\t\t\t\t\t\tshould set cpufreq */\n\tunsigned int\t\tcpu;    /* cpu managing this policy, must be online */\n\n\tstruct clk\t\t*clk;\n\tstruct cpufreq_cpuinfo\tcpuinfo;/* see above */\n\n\tunsigned int\t\tmin;    /* in kHz */\n\tunsigned int\t\tmax;    /* in kHz */\n\tunsigned int\t\tcur;    /* in kHz, only needed if cpufreq\n\t\t\t\t\t * governors are used */\n\tunsigned int\t\tsuspend_freq; /* freq to set during suspend */\n\n\tunsigned int\t\tpolicy; /* see above */\n\tunsigned int\t\tlast_policy; /* policy before unplug */\n\tstruct cpufreq_governor\t*governor; /* see below */\n\tvoid\t\t\t*governor_data;\n\tchar\t\t\tlast_governor[CPUFREQ_NAME_LEN]; /* last governor used */\n\n\tstruct work_struct\tupdate; /* if update_policy() needs to be\n\t\t\t\t\t * called, but you're in IRQ context */\n\n\tstruct freq_constraints\tconstraints;\n\tstruct freq_qos_request\t*min_freq_req;\n\tstruct freq_qos_request\t*max_freq_req;\n\n\tstruct cpufreq_frequency_table\t*freq_table;\n\tenum cpufreq_table_sorting freq_table_sorted;\n\n\tstruct list_head        policy_list;\n\tstruct kobject\t\tkobj;\n\tstruct completion\tkobj_unregister;\n\n\t/*\n\t * The rules for this semaphore:\n\t * - Any routine that wants to read from the policy structure will\n\t *   do a down_read on this semaphore.\n\t * - Any routine that will write to the policy structure and/or may take away\n\t *   the policy altogether (eg. CPU hotplug), will hold this lock in write\n\t *   mode before doing so.\n\t */\n\tstruct rw_semaphore\trwsem;\n\n\t/*\n\t * Fast switch flags:\n\t * - fast_switch_possible should be set by the driver if it can\n\t *   guarantee that frequency can be changed on any CPU sharing the\n\t *   policy and that the change will affect all of the policy CPUs then.\n\t * - fast_switch_enabled is to be set by governors that support fast\n\t *   frequency switching with the help of cpufreq_enable_fast_switch().\n\t */\n\tbool\t\t\tfast_switch_possible;\n\tbool\t\t\tfast_switch_enabled;\n\n\t/*\n\t * Set if the CPUFREQ_GOV_STRICT_TARGET flag is set for the current\n\t * governor.\n\t */\n\tbool\t\t\tstrict_target;\n\n\t/*\n\t * Preferred average time interval between consecutive invocations of\n\t * the driver to set the frequency for this policy.  To be set by the\n\t * scaling driver (0, which is the default, means no preference).\n\t */\n\tunsigned int\t\ttransition_delay_us;\n\n\t/*\n\t * Remote DVFS flag (Not added to the driver structure as we don't want\n\t * to access another structure from scheduler hotpath).\n\t *\n\t * Should be set if CPUs can do DVFS on behalf of other CPUs from\n\t * different cpufreq policies.\n\t */\n\tbool\t\t\tdvfs_possible_from_any_cpu;\n\n\t /* Cached frequency lookup from cpufreq_driver_resolve_freq. */\n\tunsigned int cached_target_freq;\n\tunsigned int cached_resolved_idx;\n\n\t/* Synchronization for frequency transitions */\n\tbool\t\t\ttransition_ongoing; /* Tracks transition status */\n\tspinlock_t\t\ttransition_lock;\n\twait_queue_head_t\ttransition_wait;\n\tstruct task_struct\t*transition_task; /* Task which is doing the transition */\n\n\t/* cpufreq-stats */\n\tstruct cpufreq_stats\t*stats;\n\n\t/* For cpufreq driver's internal use */\n\tvoid\t\t\t*driver_data;\n\n\t/* Pointer to the cooling device if used for thermal mitigation */\n\tstruct thermal_cooling_device *cdev;\n\n\tstruct notifier_block nb_min;\n\tstruct notifier_block nb_max;\n};\n\n/*\n * Used for passing new cpufreq policy data to the cpufreq driver's ->verify()\n * callback for sanitization.  That callback is only expected to modify the min\n * and max values, if necessary, and specifically it must not update the\n * frequency table.\n */\nstruct cpufreq_policy_data {\n\tstruct cpufreq_cpuinfo\t\tcpuinfo;\n\tstruct cpufreq_frequency_table\t*freq_table;\n\tunsigned int\t\t\tcpu;\n\tunsigned int\t\t\tmin;    /* in kHz */\n\tunsigned int\t\t\tmax;    /* in kHz */\n};\n\nstruct cpufreq_freqs {\n\tstruct cpufreq_policy *policy;\n\tunsigned int old;\n\tunsigned int new;\n\tu8 flags;\t\t/* flags of cpufreq_driver, see below. */\n};\n\n/* Only for ACPI */\n#define CPUFREQ_SHARED_TYPE_NONE (0) /* None */\n#define CPUFREQ_SHARED_TYPE_HW\t (1) /* HW does needed coordination */\n#define CPUFREQ_SHARED_TYPE_ALL\t (2) /* All dependent CPUs should set freq */\n#define CPUFREQ_SHARED_TYPE_ANY\t (3) /* Freq can be set from any dependent CPU*/\n\n#ifdef CONFIG_CPU_FREQ\nstruct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu);\nstruct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);\nvoid cpufreq_cpu_put(struct cpufreq_policy *policy);\n#else\nstatic inline struct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu)\n{\n\treturn NULL;\n}\nstatic inline struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)\n{\n\treturn NULL;\n}\nstatic inline void cpufreq_cpu_put(struct cpufreq_policy *policy) { }\n#endif\n\nstatic inline bool policy_is_inactive(struct cpufreq_policy *policy)\n{\n\treturn cpumask_empty(policy->cpus);\n}\n\nstatic inline bool policy_is_shared(struct cpufreq_policy *policy)\n{\n\treturn cpumask_weight(policy->cpus) > 1;\n}\n\n#ifdef CONFIG_CPU_FREQ\nunsigned int cpufreq_get(unsigned int cpu);\nunsigned int cpufreq_quick_get(unsigned int cpu);\nunsigned int cpufreq_quick_get_max(unsigned int cpu);\nunsigned int cpufreq_get_hw_max_freq(unsigned int cpu);\nvoid disable_cpufreq(void);\n\nu64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);\n\nstruct cpufreq_policy *cpufreq_cpu_acquire(unsigned int cpu);\nvoid cpufreq_cpu_release(struct cpufreq_policy *policy);\nint cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);\nvoid refresh_frequency_limits(struct cpufreq_policy *policy);\nvoid cpufreq_update_policy(unsigned int cpu);\nvoid cpufreq_update_limits(unsigned int cpu);\nbool have_governor_per_policy(void);\nbool cpufreq_supports_freq_invariance(void);\nstruct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);\nvoid cpufreq_enable_fast_switch(struct cpufreq_policy *policy);\nvoid cpufreq_disable_fast_switch(struct cpufreq_policy *policy);\n#else\nstatic inline unsigned int cpufreq_get(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline unsigned int cpufreq_quick_get(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline unsigned int cpufreq_quick_get_max(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline unsigned int cpufreq_get_hw_max_freq(unsigned int cpu)\n{\n\treturn 0;\n}\nstatic inline bool cpufreq_supports_freq_invariance(void)\n{\n\treturn false;\n}\nstatic inline void disable_cpufreq(void) { }\n#endif\n\n#ifdef CONFIG_CPU_FREQ_STAT\nvoid cpufreq_stats_create_table(struct cpufreq_policy *policy);\nvoid cpufreq_stats_free_table(struct cpufreq_policy *policy);\nvoid cpufreq_stats_record_transition(struct cpufreq_policy *policy,\n\t\t\t\t     unsigned int new_freq);\n#else\nstatic inline void cpufreq_stats_create_table(struct cpufreq_policy *policy) { }\nstatic inline void cpufreq_stats_free_table(struct cpufreq_policy *policy) { }\nstatic inline void cpufreq_stats_record_transition(struct cpufreq_policy *policy,\n\t\t\t\t\t\t   unsigned int new_freq) { }\n#endif /* CONFIG_CPU_FREQ_STAT */\n\n/*********************************************************************\n *                      CPUFREQ DRIVER INTERFACE                     *\n *********************************************************************/\n\n#define CPUFREQ_RELATION_L 0  /* lowest frequency at or above target */\n#define CPUFREQ_RELATION_H 1  /* highest frequency below or at target */\n#define CPUFREQ_RELATION_C 2  /* closest frequency to target */\n\nstruct freq_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct cpufreq_policy *, char *);\n\tssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);\n};\n\n#define cpufreq_freq_attr_ro(_name)\t\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, 0444, show_##_name, NULL)\n\n#define cpufreq_freq_attr_ro_perm(_name, _perm)\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, _perm, show_##_name, NULL)\n\n#define cpufreq_freq_attr_rw(_name)\t\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, 0644, show_##_name, store_##_name)\n\n#define cpufreq_freq_attr_wo(_name)\t\t\\\nstatic struct freq_attr _name =\t\t\t\\\n__ATTR(_name, 0200, NULL, store_##_name)\n\n#define define_one_global_ro(_name)\t\t\\\nstatic struct kobj_attribute _name =\t\t\\\n__ATTR(_name, 0444, show_##_name, NULL)\n\n#define define_one_global_rw(_name)\t\t\\\nstatic struct kobj_attribute _name =\t\t\\\n__ATTR(_name, 0644, show_##_name, store_##_name)\n\n\nstruct cpufreq_driver {\n\tchar\t\tname[CPUFREQ_NAME_LEN];\n\tu16\t\tflags;\n\tvoid\t\t*driver_data;\n\n\t/* needed by all drivers */\n\tint\t\t(*init)(struct cpufreq_policy *policy);\n\tint\t\t(*verify)(struct cpufreq_policy_data *policy);\n\n\t/* define one out of two */\n\tint\t\t(*setpolicy)(struct cpufreq_policy *policy);\n\n\tint\t\t(*target)(struct cpufreq_policy *policy,\n\t\t\t\t  unsigned int target_freq,\n\t\t\t\t  unsigned int relation);\t/* Deprecated */\n\tint\t\t(*target_index)(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int index);\n\tunsigned int\t(*fast_switch)(struct cpufreq_policy *policy,\n\t\t\t\t       unsigned int target_freq);\n\t/*\n\t * ->fast_switch() replacement for drivers that use an internal\n\t * representation of performance levels and can pass hints other than\n\t * the target performance level to the hardware.\n\t */\n\tvoid\t\t(*adjust_perf)(unsigned int cpu,\n\t\t\t\t       unsigned long min_perf,\n\t\t\t\t       unsigned long target_perf,\n\t\t\t\t       unsigned long capacity);\n\n\t/*\n\t * Caches and returns the lowest driver-supported frequency greater than\n\t * or equal to the target frequency, subject to any driver limitations.\n\t * Does not set the frequency. Only to be implemented for drivers with\n\t * target().\n\t */\n\tunsigned int\t(*resolve_freq)(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int target_freq);\n\n\t/*\n\t * Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION\n\t * unset.\n\t *\n\t * get_intermediate should return a stable intermediate frequency\n\t * platform wants to switch to and target_intermediate() should set CPU\n\t * to that frequency, before jumping to the frequency corresponding\n\t * to 'index'. Core will take care of sending notifications and driver\n\t * doesn't have to handle them in target_intermediate() or\n\t * target_index().\n\t *\n\t * Drivers can return '0' from get_intermediate() in case they don't\n\t * wish to switch to intermediate frequency for some target frequency.\n\t * In that case core will directly call ->target_index().\n\t */\n\tunsigned int\t(*get_intermediate)(struct cpufreq_policy *policy,\n\t\t\t\t\t    unsigned int index);\n\tint\t\t(*target_intermediate)(struct cpufreq_policy *policy,\n\t\t\t\t\t       unsigned int index);\n\n\t/* should be defined, if possible */\n\tunsigned int\t(*get)(unsigned int cpu);\n\n\t/* Called to update policy limits on firmware notifications. */\n\tvoid\t\t(*update_limits)(unsigned int cpu);\n\n\t/* optional */\n\tint\t\t(*bios_limit)(int cpu, unsigned int *limit);\n\n\tint\t\t(*online)(struct cpufreq_policy *policy);\n\tint\t\t(*offline)(struct cpufreq_policy *policy);\n\tint\t\t(*exit)(struct cpufreq_policy *policy);\n\tvoid\t\t(*stop_cpu)(struct cpufreq_policy *policy);\n\tint\t\t(*suspend)(struct cpufreq_policy *policy);\n\tint\t\t(*resume)(struct cpufreq_policy *policy);\n\n\t/* Will be called after the driver is fully initialized */\n\tvoid\t\t(*ready)(struct cpufreq_policy *policy);\n\n\tstruct freq_attr **attr;\n\n\t/* platform specific boost support code */\n\tbool\t\tboost_enabled;\n\tint\t\t(*set_boost)(struct cpufreq_policy *policy, int state);\n};\n\n/* flags */\n\n/*\n * Set by drivers that need to update internale upper and lower boundaries along\n * with the target frequency and so the core and governors should also invoke\n * the diver if the target frequency does not change, but the policy min or max\n * may have changed.\n */\n#define CPUFREQ_NEED_UPDATE_LIMITS\t\tBIT(0)\n\n/* loops_per_jiffy or other kernel \"constants\" aren't affected by frequency transitions */\n#define CPUFREQ_CONST_LOOPS\t\t\tBIT(1)\n\n/*\n * Set by drivers that want the core to automatically register the cpufreq\n * driver as a thermal cooling device.\n */\n#define CPUFREQ_IS_COOLING_DEV\t\t\tBIT(2)\n\n/*\n * This should be set by platforms having multiple clock-domains, i.e.\n * supporting multiple policies. With this sysfs directories of governor would\n * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same\n * governor with different tunables for different clusters.\n */\n#define CPUFREQ_HAVE_GOVERNOR_PER_POLICY\tBIT(3)\n\n/*\n * Driver will do POSTCHANGE notifications from outside of their ->target()\n * routine and so must set cpufreq_driver->flags with this flag, so that core\n * can handle them specially.\n */\n#define CPUFREQ_ASYNC_NOTIFICATION\t\tBIT(4)\n\n/*\n * Set by drivers which want cpufreq core to check if CPU is running at a\n * frequency present in freq-table exposed by the driver. For these drivers if\n * CPU is found running at an out of table freq, we will try to set it to a freq\n * from the table. And if that fails, we will stop further boot process by\n * issuing a BUG_ON().\n */\n#define CPUFREQ_NEED_INITIAL_FREQ_CHECK\tBIT(5)\n\n/*\n * Set by drivers to disallow use of governors with \"dynamic_switching\" flag\n * set.\n */\n#define CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING\tBIT(6)\n\nint cpufreq_register_driver(struct cpufreq_driver *driver_data);\nint cpufreq_unregister_driver(struct cpufreq_driver *driver_data);\n\nbool cpufreq_driver_test_flags(u16 flags);\nconst char *cpufreq_get_current_driver(void);\nvoid *cpufreq_get_driver_data(void);\n\nstatic inline int cpufreq_thermal_control_enabled(struct cpufreq_driver *drv)\n{\n\treturn IS_ENABLED(CONFIG_CPU_THERMAL) &&\n\t\t(drv->flags & CPUFREQ_IS_COOLING_DEV);\n}\n\nstatic inline void cpufreq_verify_within_limits(struct cpufreq_policy_data *policy,\n\t\t\t\t\t\tunsigned int min,\n\t\t\t\t\t\tunsigned int max)\n{\n\tif (policy->min < min)\n\t\tpolicy->min = min;\n\tif (policy->max < min)\n\t\tpolicy->max = min;\n\tif (policy->min > max)\n\t\tpolicy->min = max;\n\tif (policy->max > max)\n\t\tpolicy->max = max;\n\tif (policy->min > policy->max)\n\t\tpolicy->min = policy->max;\n\treturn;\n}\n\nstatic inline void\ncpufreq_verify_within_cpu_limits(struct cpufreq_policy_data *policy)\n{\n\tcpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,\n\t\t\t\t     policy->cpuinfo.max_freq);\n}\n\n#ifdef CONFIG_CPU_FREQ\nvoid cpufreq_suspend(void);\nvoid cpufreq_resume(void);\nint cpufreq_generic_suspend(struct cpufreq_policy *policy);\n#else\nstatic inline void cpufreq_suspend(void) {}\nstatic inline void cpufreq_resume(void) {}\n#endif\n\n/*********************************************************************\n *                     CPUFREQ NOTIFIER INTERFACE                    *\n *********************************************************************/\n\n#define CPUFREQ_TRANSITION_NOTIFIER\t(0)\n#define CPUFREQ_POLICY_NOTIFIER\t\t(1)\n\n/* Transition notifiers */\n#define CPUFREQ_PRECHANGE\t\t(0)\n#define CPUFREQ_POSTCHANGE\t\t(1)\n\n/* Policy Notifiers  */\n#define CPUFREQ_CREATE_POLICY\t\t(0)\n#define CPUFREQ_REMOVE_POLICY\t\t(1)\n\n#ifdef CONFIG_CPU_FREQ\nint cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);\nint cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);\n\nvoid cpufreq_freq_transition_begin(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs);\nvoid cpufreq_freq_transition_end(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs, int transition_failed);\n\n#else /* CONFIG_CPU_FREQ */\nstatic inline int cpufreq_register_notifier(struct notifier_block *nb,\n\t\t\t\t\t\tunsigned int list)\n{\n\treturn 0;\n}\nstatic inline int cpufreq_unregister_notifier(struct notifier_block *nb,\n\t\t\t\t\t\tunsigned int list)\n{\n\treturn 0;\n}\n#endif /* !CONFIG_CPU_FREQ */\n\n/**\n * cpufreq_scale - \"old * mult / div\" calculation for large values (32-bit-arch\n * safe)\n * @old:   old value\n * @div:   divisor\n * @mult:  multiplier\n *\n *\n * new = old * mult / div\n */\nstatic inline unsigned long cpufreq_scale(unsigned long old, u_int div,\n\t\tu_int mult)\n{\n#if BITS_PER_LONG == 32\n\tu64 result = ((u64) old) * ((u64) mult);\n\tdo_div(result, div);\n\treturn (unsigned long) result;\n\n#elif BITS_PER_LONG == 64\n\tunsigned long result = old * ((u64) mult);\n\tresult /= div;\n\treturn result;\n#endif\n}\n\n/*********************************************************************\n *                          CPUFREQ GOVERNORS                        *\n *********************************************************************/\n\n#define CPUFREQ_POLICY_UNKNOWN\t\t(0)\n/*\n * If (cpufreq_driver->target) exists, the ->governor decides what frequency\n * within the limits is used. If (cpufreq_driver->setpolicy> exists, these\n * two generic policies are available:\n */\n#define CPUFREQ_POLICY_POWERSAVE\t(1)\n#define CPUFREQ_POLICY_PERFORMANCE\t(2)\n\n/*\n * The polling frequency depends on the capability of the processor. Default\n * polling frequency is 1000 times the transition latency of the processor. The\n * ondemand governor will work on any processor with transition latency <= 10ms,\n * using appropriate sampling rate.\n */\n#define LATENCY_MULTIPLIER\t\t(1000)\n\nstruct cpufreq_governor {\n\tchar\tname[CPUFREQ_NAME_LEN];\n\tint\t(*init)(struct cpufreq_policy *policy);\n\tvoid\t(*exit)(struct cpufreq_policy *policy);\n\tint\t(*start)(struct cpufreq_policy *policy);\n\tvoid\t(*stop)(struct cpufreq_policy *policy);\n\tvoid\t(*limits)(struct cpufreq_policy *policy);\n\tssize_t\t(*show_setspeed)\t(struct cpufreq_policy *policy,\n\t\t\t\t\t char *buf);\n\tint\t(*store_setspeed)\t(struct cpufreq_policy *policy,\n\t\t\t\t\t unsigned int freq);\n\tstruct list_head\tgovernor_list;\n\tstruct module\t\t*owner;\n\tu8\t\t\tflags;\n};\n\n/* Governor flags */\n\n/* For governors which change frequency dynamically by themselves */\n#define CPUFREQ_GOV_DYNAMIC_SWITCHING\tBIT(0)\n\n/* For governors wanting the target frequency to be set exactly */\n#define CPUFREQ_GOV_STRICT_TARGET\tBIT(1)\n\n\n/* Pass a target to the cpufreq driver */\nunsigned int cpufreq_driver_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int target_freq);\nvoid cpufreq_driver_adjust_perf(unsigned int cpu,\n\t\t\t\tunsigned long min_perf,\n\t\t\t\tunsigned long target_perf,\n\t\t\t\tunsigned long capacity);\nbool cpufreq_driver_has_adjust_perf(void);\nint cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t\t unsigned int target_freq,\n\t\t\t\t unsigned int relation);\nint __cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t\t   unsigned int target_freq,\n\t\t\t\t   unsigned int relation);\nunsigned int cpufreq_driver_resolve_freq(struct cpufreq_policy *policy,\n\t\t\t\t\t unsigned int target_freq);\nunsigned int cpufreq_policy_transition_delay_us(struct cpufreq_policy *policy);\nint cpufreq_register_governor(struct cpufreq_governor *governor);\nvoid cpufreq_unregister_governor(struct cpufreq_governor *governor);\nint cpufreq_start_governor(struct cpufreq_policy *policy);\nvoid cpufreq_stop_governor(struct cpufreq_policy *policy);\n\n#define cpufreq_governor_init(__governor)\t\t\t\\\nstatic int __init __governor##_init(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn cpufreq_register_governor(&__governor);\t\\\n}\t\t\t\t\t\t\t\t\\\ncore_initcall(__governor##_init)\n\n#define cpufreq_governor_exit(__governor)\t\t\t\\\nstatic void __exit __governor##_exit(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\treturn cpufreq_unregister_governor(&__governor);\t\\\n}\t\t\t\t\t\t\t\t\\\nmodule_exit(__governor##_exit)\n\nstruct cpufreq_governor *cpufreq_default_governor(void);\nstruct cpufreq_governor *cpufreq_fallback_governor(void);\n\nstatic inline void cpufreq_policy_apply_limits(struct cpufreq_policy *policy)\n{\n\tif (policy->max < policy->cur)\n\t\t__cpufreq_driver_target(policy, policy->max, CPUFREQ_RELATION_H);\n\telse if (policy->min > policy->cur)\n\t\t__cpufreq_driver_target(policy, policy->min, CPUFREQ_RELATION_L);\n}\n\n/* Governor attribute set */\nstruct gov_attr_set {\n\tstruct kobject kobj;\n\tstruct list_head policy_list;\n\tstruct mutex update_lock;\n\tint usage_count;\n};\n\n/* sysfs ops for cpufreq governors */\nextern const struct sysfs_ops governor_sysfs_ops;\n\nvoid gov_attr_set_init(struct gov_attr_set *attr_set, struct list_head *list_node);\nvoid gov_attr_set_get(struct gov_attr_set *attr_set, struct list_head *list_node);\nunsigned int gov_attr_set_put(struct gov_attr_set *attr_set, struct list_head *list_node);\n\n/* Governor sysfs attribute */\nstruct governor_attr {\n\tstruct attribute attr;\n\tssize_t (*show)(struct gov_attr_set *attr_set, char *buf);\n\tssize_t (*store)(struct gov_attr_set *attr_set, const char *buf,\n\t\t\t size_t count);\n};\n\n/*********************************************************************\n *                     FREQUENCY TABLE HELPERS                       *\n *********************************************************************/\n\n/* Special Values of .frequency field */\n#define CPUFREQ_ENTRY_INVALID\t~0u\n#define CPUFREQ_TABLE_END\t~1u\n/* Special Values of .flags field */\n#define CPUFREQ_BOOST_FREQ\t(1 << 0)\n\nstruct cpufreq_frequency_table {\n\tunsigned int\tflags;\n\tunsigned int\tdriver_data; /* driver specific data, not used by core */\n\tunsigned int\tfrequency; /* kHz - doesn't need to be in ascending\n\t\t\t\t    * order */\n};\n\n#if defined(CONFIG_CPU_FREQ) && defined(CONFIG_PM_OPP)\nint dev_pm_opp_init_cpufreq_table(struct device *dev,\n\t\t\t\t  struct cpufreq_frequency_table **table);\nvoid dev_pm_opp_free_cpufreq_table(struct device *dev,\n\t\t\t\t   struct cpufreq_frequency_table **table);\n#else\nstatic inline int dev_pm_opp_init_cpufreq_table(struct device *dev,\n\t\t\t\t\t\tstruct cpufreq_frequency_table\n\t\t\t\t\t\t**table)\n{\n\treturn -EINVAL;\n}\n\nstatic inline void dev_pm_opp_free_cpufreq_table(struct device *dev,\n\t\t\t\t\t\t struct cpufreq_frequency_table\n\t\t\t\t\t\t **table)\n{\n}\n#endif\n\n/*\n * cpufreq_for_each_entry -\titerate over a cpufreq_frequency_table\n * @pos:\tthe cpufreq_frequency_table * to use as a loop cursor.\n * @table:\tthe cpufreq_frequency_table * to iterate over.\n */\n\n#define cpufreq_for_each_entry(pos, table)\t\\\n\tfor (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)\n\n/*\n * cpufreq_for_each_entry_idx -\titerate over a cpufreq_frequency_table\n *\twith index\n * @pos:\tthe cpufreq_frequency_table * to use as a loop cursor.\n * @table:\tthe cpufreq_frequency_table * to iterate over.\n * @idx:\tthe table entry currently being processed\n */\n\n#define cpufreq_for_each_entry_idx(pos, table, idx)\t\\\n\tfor (pos = table, idx = 0; pos->frequency != CPUFREQ_TABLE_END; \\\n\t\tpos++, idx++)\n\n/*\n * cpufreq_for_each_valid_entry -     iterate over a cpufreq_frequency_table\n *\texcluding CPUFREQ_ENTRY_INVALID frequencies.\n * @pos:        the cpufreq_frequency_table * to use as a loop cursor.\n * @table:      the cpufreq_frequency_table * to iterate over.\n */\n\n#define cpufreq_for_each_valid_entry(pos, table)\t\t\t\\\n\tfor (pos = table; pos->frequency != CPUFREQ_TABLE_END; pos++)\t\\\n\t\tif (pos->frequency == CPUFREQ_ENTRY_INVALID)\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\telse\n\n/*\n * cpufreq_for_each_valid_entry_idx -     iterate with index over a cpufreq\n *\tfrequency_table excluding CPUFREQ_ENTRY_INVALID frequencies.\n * @pos:\tthe cpufreq_frequency_table * to use as a loop cursor.\n * @table:\tthe cpufreq_frequency_table * to iterate over.\n * @idx:\tthe table entry currently being processed\n */\n\n#define cpufreq_for_each_valid_entry_idx(pos, table, idx)\t\t\\\n\tcpufreq_for_each_entry_idx(pos, table, idx)\t\t\t\\\n\t\tif (pos->frequency == CPUFREQ_ENTRY_INVALID)\t\t\\\n\t\t\tcontinue;\t\t\t\t\t\\\n\t\telse\n\n\nint cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,\n\t\t\t\t    struct cpufreq_frequency_table *table);\n\nint cpufreq_frequency_table_verify(struct cpufreq_policy_data *policy,\n\t\t\t\t   struct cpufreq_frequency_table *table);\nint cpufreq_generic_frequency_table_verify(struct cpufreq_policy_data *policy);\n\nint cpufreq_table_index_unsorted(struct cpufreq_policy *policy,\n\t\t\t\t unsigned int target_freq,\n\t\t\t\t unsigned int relation);\nint cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,\n\t\tunsigned int freq);\n\nssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);\n\n#ifdef CONFIG_CPU_FREQ\nint cpufreq_boost_trigger_state(int state);\nint cpufreq_boost_enabled(void);\nint cpufreq_enable_boost_support(void);\nbool policy_has_boost_freq(struct cpufreq_policy *policy);\n\n/* Find lowest freq at or above target in a table in ascending order */\nstatic inline int cpufreq_table_find_index_al(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq >= target_freq)\n\t\t\treturn idx;\n\n\t\tbest = idx;\n\t}\n\n\treturn best;\n}\n\n/* Find lowest freq at or above target in a table in descending order */\nstatic inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq > target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No freq found above target_freq */\n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n/* Works only on sorted freq-tables */\nstatic inline int cpufreq_table_find_index_l(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\treturn cpufreq_table_find_index_al(policy, target_freq);\n\telse\n\t\treturn cpufreq_table_find_index_dl(policy, target_freq);\n}\n\n/* Find highest freq at or below target in a table in ascending order */\nstatic inline int cpufreq_table_find_index_ah(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq < target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No freq found below target_freq */\n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n/* Find highest freq at or below target in a table in descending order */\nstatic inline int cpufreq_table_find_index_dh(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq <= target_freq)\n\t\t\treturn idx;\n\n\t\tbest = idx;\n\t}\n\n\treturn best;\n}\n\n/* Works only on sorted freq-tables */\nstatic inline int cpufreq_table_find_index_h(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\treturn cpufreq_table_find_index_ah(policy, target_freq);\n\telse\n\t\treturn cpufreq_table_find_index_dh(policy, target_freq);\n}\n\n/* Find closest freq to target in a table in ascending order */\nstatic inline int cpufreq_table_find_index_ac(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq < target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No freq found below target_freq */\n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\t/* Choose the closest freq */\n\t\tif (target_freq - table[best].frequency > freq - target_freq)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n/* Find closest freq to target in a table in descending order */\nstatic inline int cpufreq_table_find_index_dc(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq;\n\tint idx, best = -1;\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx) {\n\t\tfreq = pos->frequency;\n\n\t\tif (freq == target_freq)\n\t\t\treturn idx;\n\n\t\tif (freq > target_freq) {\n\t\t\tbest = idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No freq found above target_freq */\n\t\tif (best == -1)\n\t\t\treturn idx;\n\n\t\t/* Choose the closest freq */\n\t\tif (table[best].frequency - target_freq > target_freq - freq)\n\t\t\treturn idx;\n\n\t\treturn best;\n\t}\n\n\treturn best;\n}\n\n/* Works only on sorted freq-tables */\nstatic inline int cpufreq_table_find_index_c(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq)\n{\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (policy->freq_table_sorted == CPUFREQ_TABLE_SORTED_ASCENDING)\n\t\treturn cpufreq_table_find_index_ac(policy, target_freq);\n\telse\n\t\treturn cpufreq_table_find_index_dc(policy, target_freq);\n}\n\nstatic inline int cpufreq_frequency_table_target(struct cpufreq_policy *policy,\n\t\t\t\t\t\t unsigned int target_freq,\n\t\t\t\t\t\t unsigned int relation)\n{\n\tif (unlikely(policy->freq_table_sorted == CPUFREQ_TABLE_UNSORTED))\n\t\treturn cpufreq_table_index_unsorted(policy, target_freq,\n\t\t\t\t\t\t    relation);\n\n\tswitch (relation) {\n\tcase CPUFREQ_RELATION_L:\n\t\treturn cpufreq_table_find_index_l(policy, target_freq);\n\tcase CPUFREQ_RELATION_H:\n\t\treturn cpufreq_table_find_index_h(policy, target_freq);\n\tcase CPUFREQ_RELATION_C:\n\t\treturn cpufreq_table_find_index_c(policy, target_freq);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn 0;\n\t}\n}\n\nstatic inline int cpufreq_table_count_valid_entries(const struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tint count = 0;\n\n\tif (unlikely(!policy->freq_table))\n\t\treturn 0;\n\n\tcpufreq_for_each_valid_entry(pos, policy->freq_table)\n\t\tcount++;\n\n\treturn count;\n}\n#else\nstatic inline int cpufreq_boost_trigger_state(int state)\n{\n\treturn 0;\n}\nstatic inline int cpufreq_boost_enabled(void)\n{\n\treturn 0;\n}\n\nstatic inline int cpufreq_enable_boost_support(void)\n{\n\treturn -EINVAL;\n}\n\nstatic inline bool policy_has_boost_freq(struct cpufreq_policy *policy)\n{\n\treturn false;\n}\n#endif\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\nvoid sched_cpufreq_governor_change(struct cpufreq_policy *policy,\n\t\t\tstruct cpufreq_governor *old_gov);\n#else\nstatic inline void sched_cpufreq_governor_change(struct cpufreq_policy *policy,\n\t\t\tstruct cpufreq_governor *old_gov) { }\n#endif\n\nextern void arch_freq_prepare_all(void);\nextern unsigned int arch_freq_get_on_cpu(int cpu);\n\n#ifndef arch_set_freq_scale\nstatic __always_inline\nvoid arch_set_freq_scale(const struct cpumask *cpus,\n\t\t\t unsigned long cur_freq,\n\t\t\t unsigned long max_freq)\n{\n}\n#endif\n\n/* the following are really really optional */\nextern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;\nextern struct freq_attr cpufreq_freq_attr_scaling_boost_freqs;\nextern struct freq_attr *cpufreq_generic_attr[];\nint cpufreq_table_validate_and_sort(struct cpufreq_policy *policy);\n\nunsigned int cpufreq_generic_get(unsigned int cpu);\nvoid cpufreq_generic_init(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_frequency_table *table,\n\t\tunsigned int transition_latency);\n#endif /* _LINUX_CPUFREQ_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/cpumask.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_CPUMASK_H\n#define __LINUX_CPUMASK_H\n\n/*\n * Cpumasks provide a bitmap suitable for representing the\n * set of CPU's in a system, one bit position per CPU number.  In general,\n * only nr_cpu_ids (<= NR_CPUS) bits are valid.\n */\n#include <linux/kernel.h>\n#include <linux/threads.h>\n#include <linux/bitmap.h>\n#include <linux/atomic.h>\n#include <linux/bug.h>\n\n/* Don't assign or return these: may not be this big! */\ntypedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;\n\n/**\n * cpumask_bits - get the bits in a cpumask\n * @maskp: the struct cpumask *\n *\n * You should only assume nr_cpu_ids bits of this mask are valid.  This is\n * a macro so it's const-correct.\n */\n#define cpumask_bits(maskp) ((maskp)->bits)\n\n/**\n * cpumask_pr_args - printf args to output a cpumask\n * @maskp: cpumask to be printed\n *\n * Can be used to provide arguments for '%*pb[l]' when printing a cpumask.\n */\n#define cpumask_pr_args(maskp)\t\tnr_cpu_ids, cpumask_bits(maskp)\n\n#if NR_CPUS == 1\n#define nr_cpu_ids\t\t1U\n#else\nextern unsigned int nr_cpu_ids;\n#endif\n\n#ifdef CONFIG_CPUMASK_OFFSTACK\n/* Assuming NR_CPUS is huge, a runtime limit is more efficient.  Also,\n * not all bits may be allocated. */\n#define nr_cpumask_bits\tnr_cpu_ids\n#else\n#define nr_cpumask_bits\t((unsigned int)NR_CPUS)\n#endif\n\n/*\n * The following particular system cpumasks and operations manage\n * possible, present, active and online cpus.\n *\n *     cpu_possible_mask- has bit 'cpu' set iff cpu is populatable\n *     cpu_present_mask - has bit 'cpu' set iff cpu is populated\n *     cpu_online_mask  - has bit 'cpu' set iff cpu available to scheduler\n *     cpu_active_mask  - has bit 'cpu' set iff cpu available to migration\n *\n *  If !CONFIG_HOTPLUG_CPU, present == possible, and active == online.\n *\n *  The cpu_possible_mask is fixed at boot time, as the set of CPU id's\n *  that it is possible might ever be plugged in at anytime during the\n *  life of that system boot.  The cpu_present_mask is dynamic(*),\n *  representing which CPUs are currently plugged in.  And\n *  cpu_online_mask is the dynamic subset of cpu_present_mask,\n *  indicating those CPUs available for scheduling.\n *\n *  If HOTPLUG is enabled, then cpu_possible_mask is forced to have\n *  all NR_CPUS bits set, otherwise it is just the set of CPUs that\n *  ACPI reports present at boot.\n *\n *  If HOTPLUG is enabled, then cpu_present_mask varies dynamically,\n *  depending on what ACPI reports as currently plugged in, otherwise\n *  cpu_present_mask is just a copy of cpu_possible_mask.\n *\n *  (*) Well, cpu_present_mask is dynamic in the hotplug case.  If not\n *      hotplug, it's a copy of cpu_possible_mask, hence fixed at boot.\n *\n * Subtleties:\n * 1) UP arch's (NR_CPUS == 1, CONFIG_SMP not defined) hardcode\n *    assumption that their single CPU is online.  The UP\n *    cpu_{online,possible,present}_masks are placebos.  Changing them\n *    will have no useful affect on the following num_*_cpus()\n *    and cpu_*() macros in the UP case.  This ugliness is a UP\n *    optimization - don't waste any instructions or memory references\n *    asking if you're online or how many CPUs there are if there is\n *    only one CPU.\n */\n\nextern struct cpumask __cpu_possible_mask;\nextern struct cpumask __cpu_online_mask;\nextern struct cpumask __cpu_present_mask;\nextern struct cpumask __cpu_active_mask;\n#define cpu_possible_mask ((const struct cpumask *)&__cpu_possible_mask)\n#define cpu_online_mask   ((const struct cpumask *)&__cpu_online_mask)\n#define cpu_present_mask  ((const struct cpumask *)&__cpu_present_mask)\n#define cpu_active_mask   ((const struct cpumask *)&__cpu_active_mask)\n\nextern atomic_t __num_online_cpus;\n\n#if NR_CPUS > 1\n/**\n * num_online_cpus() - Read the number of online CPUs\n *\n * Despite the fact that __num_online_cpus is of type atomic_t, this\n * interface gives only a momentary snapshot and is not protected against\n * concurrent CPU hotplug operations unless invoked from a cpuhp_lock held\n * region.\n */\nstatic inline unsigned int num_online_cpus(void)\n{\n\treturn atomic_read(&__num_online_cpus);\n}\n#define num_possible_cpus()\tcpumask_weight(cpu_possible_mask)\n#define num_present_cpus()\tcpumask_weight(cpu_present_mask)\n#define num_active_cpus()\tcpumask_weight(cpu_active_mask)\n#define cpu_online(cpu)\t\tcpumask_test_cpu((cpu), cpu_online_mask)\n#define cpu_possible(cpu)\tcpumask_test_cpu((cpu), cpu_possible_mask)\n#define cpu_present(cpu)\tcpumask_test_cpu((cpu), cpu_present_mask)\n#define cpu_active(cpu)\t\tcpumask_test_cpu((cpu), cpu_active_mask)\n#else\n#define num_online_cpus()\t1U\n#define num_possible_cpus()\t1U\n#define num_present_cpus()\t1U\n#define num_active_cpus()\t1U\n#define cpu_online(cpu)\t\t((cpu) == 0)\n#define cpu_possible(cpu)\t((cpu) == 0)\n#define cpu_present(cpu)\t((cpu) == 0)\n#define cpu_active(cpu)\t\t((cpu) == 0)\n#endif\n\nextern cpumask_t cpus_booted_once_mask;\n\nstatic inline void cpu_max_bits_warn(unsigned int cpu, unsigned int bits)\n{\n#ifdef CONFIG_DEBUG_PER_CPU_MAPS\n\tWARN_ON_ONCE(cpu >= bits);\n#endif /* CONFIG_DEBUG_PER_CPU_MAPS */\n}\n\n/* verify cpu argument to cpumask_* operators */\nstatic inline unsigned int cpumask_check(unsigned int cpu)\n{\n\tcpu_max_bits_warn(cpu, nr_cpumask_bits);\n\treturn cpu;\n}\n\n#if NR_CPUS == 1\n/* Uniprocessor.  Assume all masks are \"1\". */\nstatic inline unsigned int cpumask_first(const struct cpumask *srcp)\n{\n\treturn 0;\n}\n\nstatic inline unsigned int cpumask_last(const struct cpumask *srcp)\n{\n\treturn 0;\n}\n\n/* Valid inputs for n are -1 and 0. */\nstatic inline unsigned int cpumask_next(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\nstatic inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)\n{\n\treturn n+1;\n}\n\nstatic inline unsigned int cpumask_next_and(int n,\n\t\t\t\t\t    const struct cpumask *srcp,\n\t\t\t\t\t    const struct cpumask *andp)\n{\n\treturn n+1;\n}\n\nstatic inline unsigned int cpumask_next_wrap(int n, const struct cpumask *mask,\n\t\t\t\t\t     int start, bool wrap)\n{\n\t/* cpu0 unless stop condition, wrap and at cpu0, then nr_cpumask_bits */\n\treturn (wrap && n == 0);\n}\n\n/* cpu must be a valid cpu, ie 0, so there's no other choice. */\nstatic inline unsigned int cpumask_any_but(const struct cpumask *mask,\n\t\t\t\t\t   unsigned int cpu)\n{\n\treturn 1;\n}\n\nstatic inline unsigned int cpumask_local_spread(unsigned int i, int node)\n{\n\treturn 0;\n}\n\nstatic inline int cpumask_any_and_distribute(const struct cpumask *src1p,\n\t\t\t\t\t     const struct cpumask *src2p) {\n\treturn cpumask_next_and(-1, src1p, src2p);\n}\n\nstatic inline int cpumask_any_distribute(const struct cpumask *srcp)\n{\n\treturn cpumask_first(srcp);\n}\n\n#define for_each_cpu(cpu, mask)\t\t\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)\n#define for_each_cpu_not(cpu, mask)\t\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)\n#define for_each_cpu_wrap(cpu, mask, start)\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask, (void)(start))\n#define for_each_cpu_and(cpu, mask1, mask2)\t\\\n\tfor ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask1, (void)mask2)\n#else\n/**\n * cpumask_first - get the first cpu in a cpumask\n * @srcp: the cpumask pointer\n *\n * Returns >= nr_cpu_ids if no cpus set.\n */\nstatic inline unsigned int cpumask_first(const struct cpumask *srcp)\n{\n\treturn find_first_bit(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_last - get the last CPU in a cpumask\n * @srcp:\t- the cpumask pointer\n *\n * Returns\t>= nr_cpumask_bits if no CPUs set.\n */\nstatic inline unsigned int cpumask_last(const struct cpumask *srcp)\n{\n\treturn find_last_bit(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\nunsigned int __pure cpumask_next(int n, const struct cpumask *srcp);\n\n/**\n * cpumask_next_zero - get the next unset cpu in a cpumask\n * @n: the cpu prior to the place to search (ie. return will be > @n)\n * @srcp: the cpumask pointer\n *\n * Returns >= nr_cpu_ids if no further cpus unset.\n */\nstatic inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)\n{\n\t/* -1 is a legal arg here. */\n\tif (n != -1)\n\t\tcpumask_check(n);\n\treturn find_next_zero_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);\n}\n\nint __pure cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);\nint __pure cpumask_any_but(const struct cpumask *mask, unsigned int cpu);\nunsigned int cpumask_local_spread(unsigned int i, int node);\nint cpumask_any_and_distribute(const struct cpumask *src1p,\n\t\t\t       const struct cpumask *src2p);\nint cpumask_any_distribute(const struct cpumask *srcp);\n\n/**\n * for_each_cpu - iterate over every cpu in a mask\n * @cpu: the (optionally unsigned) integer iterator\n * @mask: the cpumask pointer\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\\\n\t\t(cpu) = cpumask_next((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\n/**\n * for_each_cpu_not - iterate over every cpu in a complemented mask\n * @cpu: the (optionally unsigned) integer iterator\n * @mask: the cpumask pointer\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu_not(cpu, mask)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\t\\\n\t\t(cpu) = cpumask_next_zero((cpu), (mask)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n\nextern int cpumask_next_wrap(int n, const struct cpumask *mask, int start, bool wrap);\n\n/**\n * for_each_cpu_wrap - iterate over every cpu in a mask, starting at a specified location\n * @cpu: the (optionally unsigned) integer iterator\n * @mask: the cpumask poiter\n * @start: the start location\n *\n * The implementation does not assume any bit in @mask is set (including @start).\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu_wrap(cpu, mask, start)\t\t\t\t\t\\\n\tfor ((cpu) = cpumask_next_wrap((start)-1, (mask), (start), false);\t\\\n\t     (cpu) < nr_cpumask_bits;\t\t\t\t\t\t\\\n\t     (cpu) = cpumask_next_wrap((cpu), (mask), (start), true))\n\n/**\n * for_each_cpu_and - iterate over every cpu in both masks\n * @cpu: the (optionally unsigned) integer iterator\n * @mask1: the first cpumask pointer\n * @mask2: the second cpumask pointer\n *\n * This saves a temporary CPU mask in many places.  It is equivalent to:\n *\tstruct cpumask tmp;\n *\tcpumask_and(&tmp, &mask1, &mask2);\n *\tfor_each_cpu(cpu, &tmp)\n *\t\t...\n *\n * After the loop, cpu is >= nr_cpu_ids.\n */\n#define for_each_cpu_and(cpu, mask1, mask2)\t\t\t\t\\\n\tfor ((cpu) = -1;\t\t\t\t\t\t\\\n\t\t(cpu) = cpumask_next_and((cpu), (mask1), (mask2)),\t\\\n\t\t(cpu) < nr_cpu_ids;)\n#endif /* SMP */\n\n#define CPU_BITS_NONE\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-1] = 0UL\t\t\t\\\n}\n\n#define CPU_BITS_CPU0\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[0] =  1UL\t\t\t\t\t\t\\\n}\n\n/**\n * cpumask_set_cpu - set a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)\n{\n\tset_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\nstatic inline void __cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)\n{\n\t__set_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\n\n/**\n * cpumask_clear_cpu - clear a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_clear_cpu(int cpu, struct cpumask *dstp)\n{\n\tclear_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\nstatic inline void __cpumask_clear_cpu(int cpu, struct cpumask *dstp)\n{\n\t__clear_bit(cpumask_check(cpu), cpumask_bits(dstp));\n}\n\n/**\n * cpumask_test_cpu - test for a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @cpumask: the cpumask pointer\n *\n * Returns 1 if @cpu is set in @cpumask, else returns 0\n */\nstatic inline int cpumask_test_cpu(int cpu, const struct cpumask *cpumask)\n{\n\treturn test_bit(cpumask_check(cpu), cpumask_bits((cpumask)));\n}\n\n/**\n * cpumask_test_and_set_cpu - atomically test and set a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @cpumask: the cpumask pointer\n *\n * Returns 1 if @cpu is set in old bitmap of @cpumask, else returns 0\n *\n * test_and_set_bit wrapper for cpumasks.\n */\nstatic inline int cpumask_test_and_set_cpu(int cpu, struct cpumask *cpumask)\n{\n\treturn test_and_set_bit(cpumask_check(cpu), cpumask_bits(cpumask));\n}\n\n/**\n * cpumask_test_and_clear_cpu - atomically test and clear a cpu in a cpumask\n * @cpu: cpu number (< nr_cpu_ids)\n * @cpumask: the cpumask pointer\n *\n * Returns 1 if @cpu is set in old bitmap of @cpumask, else returns 0\n *\n * test_and_clear_bit wrapper for cpumasks.\n */\nstatic inline int cpumask_test_and_clear_cpu(int cpu, struct cpumask *cpumask)\n{\n\treturn test_and_clear_bit(cpumask_check(cpu), cpumask_bits(cpumask));\n}\n\n/**\n * cpumask_setall - set all cpus (< nr_cpu_ids) in a cpumask\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_setall(struct cpumask *dstp)\n{\n\tbitmap_fill(cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_clear - clear all cpus (< nr_cpu_ids) in a cpumask\n * @dstp: the cpumask pointer\n */\nstatic inline void cpumask_clear(struct cpumask *dstp)\n{\n\tbitmap_zero(cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_and - *dstp = *src1p & *src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n *\n * If *@dstp is empty, returns 0, else returns 1\n */\nstatic inline int cpumask_and(struct cpumask *dstp,\n\t\t\t       const struct cpumask *src1p,\n\t\t\t       const struct cpumask *src2p)\n{\n\treturn bitmap_and(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t       cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_or - *dstp = *src1p | *src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline void cpumask_or(struct cpumask *dstp, const struct cpumask *src1p,\n\t\t\t      const struct cpumask *src2p)\n{\n\tbitmap_or(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t      cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_xor - *dstp = *src1p ^ *src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline void cpumask_xor(struct cpumask *dstp,\n\t\t\t       const struct cpumask *src1p,\n\t\t\t       const struct cpumask *src2p)\n{\n\tbitmap_xor(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t       cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_andnot - *dstp = *src1p & ~*src2p\n * @dstp: the cpumask result\n * @src1p: the first input\n * @src2p: the second input\n *\n * If *@dstp is empty, returns 0, else returns 1\n */\nstatic inline int cpumask_andnot(struct cpumask *dstp,\n\t\t\t\t  const struct cpumask *src1p,\n\t\t\t\t  const struct cpumask *src2p)\n{\n\treturn bitmap_andnot(cpumask_bits(dstp), cpumask_bits(src1p),\n\t\t\t\t\t  cpumask_bits(src2p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_complement - *dstp = ~*srcp\n * @dstp: the cpumask result\n * @srcp: the input to invert\n */\nstatic inline void cpumask_complement(struct cpumask *dstp,\n\t\t\t\t      const struct cpumask *srcp)\n{\n\tbitmap_complement(cpumask_bits(dstp), cpumask_bits(srcp),\n\t\t\t\t\t      nr_cpumask_bits);\n}\n\n/**\n * cpumask_equal - *src1p == *src2p\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline bool cpumask_equal(const struct cpumask *src1p,\n\t\t\t\tconst struct cpumask *src2p)\n{\n\treturn bitmap_equal(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t\t\t\t nr_cpumask_bits);\n}\n\n/**\n * cpumask_or_equal - *src1p | *src2p == *src3p\n * @src1p: the first input\n * @src2p: the second input\n * @src3p: the third input\n */\nstatic inline bool cpumask_or_equal(const struct cpumask *src1p,\n\t\t\t\t    const struct cpumask *src2p,\n\t\t\t\t    const struct cpumask *src3p)\n{\n\treturn bitmap_or_equal(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t       cpumask_bits(src3p), nr_cpumask_bits);\n}\n\n/**\n * cpumask_intersects - (*src1p & *src2p) != 0\n * @src1p: the first input\n * @src2p: the second input\n */\nstatic inline bool cpumask_intersects(const struct cpumask *src1p,\n\t\t\t\t     const struct cpumask *src2p)\n{\n\treturn bitmap_intersects(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t\t\t\t      nr_cpumask_bits);\n}\n\n/**\n * cpumask_subset - (*src1p & ~*src2p) == 0\n * @src1p: the first input\n * @src2p: the second input\n *\n * Returns 1 if *@src1p is a subset of *@src2p, else returns 0\n */\nstatic inline int cpumask_subset(const struct cpumask *src1p,\n\t\t\t\t const struct cpumask *src2p)\n{\n\treturn bitmap_subset(cpumask_bits(src1p), cpumask_bits(src2p),\n\t\t\t\t\t\t  nr_cpumask_bits);\n}\n\n/**\n * cpumask_empty - *srcp == 0\n * @srcp: the cpumask to that all cpus < nr_cpu_ids are clear.\n */\nstatic inline bool cpumask_empty(const struct cpumask *srcp)\n{\n\treturn bitmap_empty(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_full - *srcp == 0xFFFFFFFF...\n * @srcp: the cpumask to that all cpus < nr_cpu_ids are set.\n */\nstatic inline bool cpumask_full(const struct cpumask *srcp)\n{\n\treturn bitmap_full(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_weight - Count of bits in *srcp\n * @srcp: the cpumask to count bits (< nr_cpu_ids) in.\n */\nstatic inline unsigned int cpumask_weight(const struct cpumask *srcp)\n{\n\treturn bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_shift_right - *dstp = *srcp >> n\n * @dstp: the cpumask result\n * @srcp: the input to shift\n * @n: the number of bits to shift by\n */\nstatic inline void cpumask_shift_right(struct cpumask *dstp,\n\t\t\t\t       const struct cpumask *srcp, int n)\n{\n\tbitmap_shift_right(cpumask_bits(dstp), cpumask_bits(srcp), n,\n\t\t\t\t\t       nr_cpumask_bits);\n}\n\n/**\n * cpumask_shift_left - *dstp = *srcp << n\n * @dstp: the cpumask result\n * @srcp: the input to shift\n * @n: the number of bits to shift by\n */\nstatic inline void cpumask_shift_left(struct cpumask *dstp,\n\t\t\t\t      const struct cpumask *srcp, int n)\n{\n\tbitmap_shift_left(cpumask_bits(dstp), cpumask_bits(srcp), n,\n\t\t\t\t\t      nr_cpumask_bits);\n}\n\n/**\n * cpumask_copy - *dstp = *srcp\n * @dstp: the result\n * @srcp: the input cpumask\n */\nstatic inline void cpumask_copy(struct cpumask *dstp,\n\t\t\t\tconst struct cpumask *srcp)\n{\n\tbitmap_copy(cpumask_bits(dstp), cpumask_bits(srcp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_any - pick a \"random\" cpu from *srcp\n * @srcp: the input cpumask\n *\n * Returns >= nr_cpu_ids if no cpus set.\n */\n#define cpumask_any(srcp) cpumask_first(srcp)\n\n/**\n * cpumask_first_and - return the first cpu from *srcp1 & *srcp2\n * @src1p: the first input\n * @src2p: the second input\n *\n * Returns >= nr_cpu_ids if no cpus set in both.  See also cpumask_next_and().\n */\n#define cpumask_first_and(src1p, src2p) cpumask_next_and(-1, (src1p), (src2p))\n\n/**\n * cpumask_any_and - pick a \"random\" cpu from *mask1 & *mask2\n * @mask1: the first input cpumask\n * @mask2: the second input cpumask\n *\n * Returns >= nr_cpu_ids if no cpus set.\n */\n#define cpumask_any_and(mask1, mask2) cpumask_first_and((mask1), (mask2))\n\n/**\n * cpumask_of - the cpumask containing just a given cpu\n * @cpu: the cpu (<= nr_cpu_ids)\n */\n#define cpumask_of(cpu) (get_cpu_mask(cpu))\n\n/**\n * cpumask_parse_user - extract a cpumask from a user string\n * @buf: the buffer to extract from\n * @len: the length of the buffer\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpumask_parse_user(const char __user *buf, int len,\n\t\t\t\t     struct cpumask *dstp)\n{\n\treturn bitmap_parse_user(buf, len, cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_parselist_user - extract a cpumask from a user string\n * @buf: the buffer to extract from\n * @len: the length of the buffer\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpumask_parselist_user(const char __user *buf, int len,\n\t\t\t\t     struct cpumask *dstp)\n{\n\treturn bitmap_parselist_user(buf, len, cpumask_bits(dstp),\n\t\t\t\t     nr_cpumask_bits);\n}\n\n/**\n * cpumask_parse - extract a cpumask from a string\n * @buf: the buffer to extract from\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpumask_parse(const char *buf, struct cpumask *dstp)\n{\n\treturn bitmap_parse(buf, UINT_MAX, cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpulist_parse - extract a cpumask from a user string of ranges\n * @buf: the buffer to extract from\n * @dstp: the cpumask to set.\n *\n * Returns -errno, or 0 for success.\n */\nstatic inline int cpulist_parse(const char *buf, struct cpumask *dstp)\n{\n\treturn bitmap_parselist(buf, cpumask_bits(dstp), nr_cpumask_bits);\n}\n\n/**\n * cpumask_size - size to allocate for a 'struct cpumask' in bytes\n */\nstatic inline unsigned int cpumask_size(void)\n{\n\treturn BITS_TO_LONGS(nr_cpumask_bits) * sizeof(long);\n}\n\n/*\n * cpumask_var_t: struct cpumask for stack usage.\n *\n * Oh, the wicked games we play!  In order to make kernel coding a\n * little more difficult, we typedef cpumask_var_t to an array or a\n * pointer: doing &mask on an array is a noop, so it still works.\n *\n * ie.\n *\tcpumask_var_t tmpmask;\n *\tif (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))\n *\t\treturn -ENOMEM;\n *\n *\t  ... use 'tmpmask' like a normal struct cpumask * ...\n *\n *\tfree_cpumask_var(tmpmask);\n *\n *\n * However, one notable exception is there. alloc_cpumask_var() allocates\n * only nr_cpumask_bits bits (in the other hand, real cpumask_t always has\n * NR_CPUS bits). Therefore you don't have to dereference cpumask_var_t.\n *\n *\tcpumask_var_t tmpmask;\n *\tif (!alloc_cpumask_var(&tmpmask, GFP_KERNEL))\n *\t\treturn -ENOMEM;\n *\n *\tvar = *tmpmask;\n *\n * This code makes NR_CPUS length memcopy and brings to a memory corruption.\n * cpumask_copy() provide safe copy functionality.\n *\n * Note that there is another evil here: If you define a cpumask_var_t\n * as a percpu variable then the way to obtain the address of the cpumask\n * structure differently influences what this_cpu_* operation needs to be\n * used. Please use this_cpu_cpumask_var_t in those cases. The direct use\n * of this_cpu_ptr() or this_cpu_read() will lead to failures when the\n * other type of cpumask_var_t implementation is configured.\n *\n * Please also note that __cpumask_var_read_mostly can be used to declare\n * a cpumask_var_t variable itself (not its content) as read mostly.\n */\n#ifdef CONFIG_CPUMASK_OFFSTACK\ntypedef struct cpumask *cpumask_var_t;\n\n#define this_cpu_cpumask_var_ptr(x)\tthis_cpu_read(x)\n#define __cpumask_var_read_mostly\t__read_mostly\n\nbool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);\nbool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);\nbool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags, int node);\nbool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags);\nvoid alloc_bootmem_cpumask_var(cpumask_var_t *mask);\nvoid free_cpumask_var(cpumask_var_t mask);\nvoid free_bootmem_cpumask_var(cpumask_var_t mask);\n\nstatic inline bool cpumask_available(cpumask_var_t mask)\n{\n\treturn mask != NULL;\n}\n\n#else\ntypedef struct cpumask cpumask_var_t[1];\n\n#define this_cpu_cpumask_var_ptr(x) this_cpu_ptr(x)\n#define __cpumask_var_read_mostly\n\nstatic inline bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)\n{\n\treturn true;\n}\n\nstatic inline bool alloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,\n\t\t\t\t\t  int node)\n{\n\treturn true;\n}\n\nstatic inline bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)\n{\n\tcpumask_clear(*mask);\n\treturn true;\n}\n\nstatic inline bool zalloc_cpumask_var_node(cpumask_var_t *mask, gfp_t flags,\n\t\t\t\t\t  int node)\n{\n\tcpumask_clear(*mask);\n\treturn true;\n}\n\nstatic inline void alloc_bootmem_cpumask_var(cpumask_var_t *mask)\n{\n}\n\nstatic inline void free_cpumask_var(cpumask_var_t mask)\n{\n}\n\nstatic inline void free_bootmem_cpumask_var(cpumask_var_t mask)\n{\n}\n\nstatic inline bool cpumask_available(cpumask_var_t mask)\n{\n\treturn true;\n}\n#endif /* CONFIG_CPUMASK_OFFSTACK */\n\n/* It's common to want to use cpu_all_mask in struct member initializers,\n * so it has to refer to an address rather than a pointer. */\nextern const DECLARE_BITMAP(cpu_all_bits, NR_CPUS);\n#define cpu_all_mask to_cpumask(cpu_all_bits)\n\n/* First bits of cpu_bit_bitmap are in fact unset. */\n#define cpu_none_mask to_cpumask(cpu_bit_bitmap[0])\n\n#define for_each_possible_cpu(cpu) for_each_cpu((cpu), cpu_possible_mask)\n#define for_each_online_cpu(cpu)   for_each_cpu((cpu), cpu_online_mask)\n#define for_each_present_cpu(cpu)  for_each_cpu((cpu), cpu_present_mask)\n\n/* Wrappers for arch boot code to manipulate normally-constant masks */\nvoid init_cpu_present(const struct cpumask *src);\nvoid init_cpu_possible(const struct cpumask *src);\nvoid init_cpu_online(const struct cpumask *src);\n\nstatic inline void reset_cpu_possible_mask(void)\n{\n\tbitmap_zero(cpumask_bits(&__cpu_possible_mask), NR_CPUS);\n}\n\nstatic inline void\nset_cpu_possible(unsigned int cpu, bool possible)\n{\n\tif (possible)\n\t\tcpumask_set_cpu(cpu, &__cpu_possible_mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, &__cpu_possible_mask);\n}\n\nstatic inline void\nset_cpu_present(unsigned int cpu, bool present)\n{\n\tif (present)\n\t\tcpumask_set_cpu(cpu, &__cpu_present_mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, &__cpu_present_mask);\n}\n\nvoid set_cpu_online(unsigned int cpu, bool online);\n\nstatic inline void\nset_cpu_active(unsigned int cpu, bool active)\n{\n\tif (active)\n\t\tcpumask_set_cpu(cpu, &__cpu_active_mask);\n\telse\n\t\tcpumask_clear_cpu(cpu, &__cpu_active_mask);\n}\n\n\n/**\n * to_cpumask - convert an NR_CPUS bitmap to a struct cpumask *\n * @bitmap: the bitmap\n *\n * There are a few places where cpumask_var_t isn't appropriate and\n * static cpumasks must be used (eg. very early boot), yet we don't\n * expose the definition of 'struct cpumask'.\n *\n * This does the conversion, and can be used as a constant initializer.\n */\n#define to_cpumask(bitmap)\t\t\t\t\t\t\\\n\t((struct cpumask *)(1 ? (bitmap)\t\t\t\t\\\n\t\t\t    : (void *)sizeof(__check_is_bitmap(bitmap))))\n\nstatic inline int __check_is_bitmap(const unsigned long *bitmap)\n{\n\treturn 1;\n}\n\n/*\n * Special-case data structure for \"single bit set only\" constant CPU masks.\n *\n * We pre-generate all the 64 (or 32) possible bit positions, with enough\n * padding to the left and the right, and return the constant pointer\n * appropriately offset.\n */\nextern const unsigned long\n\tcpu_bit_bitmap[BITS_PER_LONG+1][BITS_TO_LONGS(NR_CPUS)];\n\nstatic inline const struct cpumask *get_cpu_mask(unsigned int cpu)\n{\n\tconst unsigned long *p = cpu_bit_bitmap[1 + cpu % BITS_PER_LONG];\n\tp -= cpu / BITS_PER_LONG;\n\treturn to_cpumask(p);\n}\n\n#define cpu_is_offline(cpu)\tunlikely(!cpu_online(cpu))\n\n#if NR_CPUS <= BITS_PER_LONG\n#define CPU_BITS_ALL\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n}\n\n#else /* NR_CPUS > BITS_PER_LONG */\n\n#define CPU_BITS_ALL\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n}\n#endif /* NR_CPUS > BITS_PER_LONG */\n\n/**\n * cpumap_print_to_pagebuf  - copies the cpumask into the buffer either\n *\tas comma-separated list of cpus or hex values of cpumask\n * @list: indicates whether the cpumap must be list\n * @mask: the cpumask to copy\n * @buf: the buffer to copy into\n *\n * Returns the length of the (null-terminated) @buf string, zero if\n * nothing is copied.\n */\nstatic inline ssize_t\ncpumap_print_to_pagebuf(bool list, char *buf, const struct cpumask *mask)\n{\n\treturn bitmap_print_to_pagebuf(list, buf, cpumask_bits(mask),\n\t\t\t\t      nr_cpu_ids);\n}\n\n#if NR_CPUS <= BITS_PER_LONG\n#define CPU_MASK_ALL\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n} }\n#else\n#define CPU_MASK_ALL\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-2] = ~0UL,\t\t\t\\\n\t[BITS_TO_LONGS(NR_CPUS)-1] = BITMAP_LAST_WORD_MASK(NR_CPUS)\t\\\n} }\n#endif /* NR_CPUS > BITS_PER_LONG */\n\n#define CPU_MASK_NONE\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[0 ... BITS_TO_LONGS(NR_CPUS)-1] =  0UL\t\t\t\t\\\n} }\n\n#define CPU_MASK_CPU0\t\t\t\t\t\t\t\\\n(cpumask_t) { {\t\t\t\t\t\t\t\t\\\n\t[0] =  1UL\t\t\t\t\t\t\t\\\n} }\n\n#endif /* __LINUX_CPUMASK_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/bitmap.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_BITMAP_H\n#define __LINUX_BITMAP_H\n\n#ifndef __ASSEMBLY__\n\n#include <linux/align.h>\n#include <linux/bitops.h>\n#include <linux/limits.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct device;\n\n/*\n * bitmaps provide bit arrays that consume one or more unsigned\n * longs.  The bitmap interface and available operations are listed\n * here, in bitmap.h\n *\n * Function implementations generic to all architectures are in\n * lib/bitmap.c.  Functions implementations that are architecture\n * specific are in various include/asm-<arch>/bitops.h headers\n * and other arch/<arch> specific files.\n *\n * See lib/bitmap.c for more details.\n */\n\n/**\n * DOC: bitmap overview\n *\n * The available bitmap operations and their rough meaning in the\n * case that the bitmap is a single unsigned long are thus:\n *\n * The generated code is more efficient when nbits is known at\n * compile-time and at most BITS_PER_LONG.\n *\n * ::\n *\n *  bitmap_zero(dst, nbits)                     *dst = 0UL\n *  bitmap_fill(dst, nbits)                     *dst = ~0UL\n *  bitmap_copy(dst, src, nbits)                *dst = *src\n *  bitmap_and(dst, src1, src2, nbits)          *dst = *src1 & *src2\n *  bitmap_or(dst, src1, src2, nbits)           *dst = *src1 | *src2\n *  bitmap_xor(dst, src1, src2, nbits)          *dst = *src1 ^ *src2\n *  bitmap_andnot(dst, src1, src2, nbits)       *dst = *src1 & ~(*src2)\n *  bitmap_complement(dst, src, nbits)          *dst = ~(*src)\n *  bitmap_equal(src1, src2, nbits)             Are *src1 and *src2 equal?\n *  bitmap_intersects(src1, src2, nbits)        Do *src1 and *src2 overlap?\n *  bitmap_subset(src1, src2, nbits)            Is *src1 a subset of *src2?\n *  bitmap_empty(src, nbits)                    Are all bits zero in *src?\n *  bitmap_full(src, nbits)                     Are all bits set in *src?\n *  bitmap_weight(src, nbits)                   Hamming Weight: number set bits\n *  bitmap_set(dst, pos, nbits)                 Set specified bit area\n *  bitmap_clear(dst, pos, nbits)               Clear specified bit area\n *  bitmap_find_next_zero_area(buf, len, pos, n, mask)  Find bit free area\n *  bitmap_find_next_zero_area_off(buf, len, pos, n, mask, mask_off)  as above\n *  bitmap_next_clear_region(map, &start, &end, nbits)  Find next clear region\n *  bitmap_next_set_region(map, &start, &end, nbits)  Find next set region\n *  bitmap_for_each_clear_region(map, rs, re, start, end)\n *  \t\t\t\t\t\tIterate over all clear regions\n *  bitmap_for_each_set_region(map, rs, re, start, end)\n *  \t\t\t\t\t\tIterate over all set regions\n *  bitmap_shift_right(dst, src, n, nbits)      *dst = *src >> n\n *  bitmap_shift_left(dst, src, n, nbits)       *dst = *src << n\n *  bitmap_cut(dst, src, first, n, nbits)       Cut n bits from first, copy rest\n *  bitmap_replace(dst, old, new, mask, nbits)  *dst = (*old & ~(*mask)) | (*new & *mask)\n *  bitmap_remap(dst, src, old, new, nbits)     *dst = map(old, new)(src)\n *  bitmap_bitremap(oldbit, old, new, nbits)    newbit = map(old, new)(oldbit)\n *  bitmap_onto(dst, orig, relmap, nbits)       *dst = orig relative to relmap\n *  bitmap_fold(dst, orig, sz, nbits)           dst bits = orig bits mod sz\n *  bitmap_parse(buf, buflen, dst, nbits)       Parse bitmap dst from kernel buf\n *  bitmap_parse_user(ubuf, ulen, dst, nbits)   Parse bitmap dst from user buf\n *  bitmap_parselist(buf, dst, nbits)           Parse bitmap dst from kernel buf\n *  bitmap_parselist_user(buf, dst, nbits)      Parse bitmap dst from user buf\n *  bitmap_find_free_region(bitmap, bits, order)  Find and allocate bit region\n *  bitmap_release_region(bitmap, pos, order)   Free specified bit region\n *  bitmap_allocate_region(bitmap, pos, order)  Allocate specified bit region\n *  bitmap_from_arr32(dst, buf, nbits)          Copy nbits from u32[] buf to dst\n *  bitmap_to_arr32(buf, src, nbits)            Copy nbits from buf to u32[] dst\n *  bitmap_get_value8(map, start)               Get 8bit value from map at start\n *  bitmap_set_value8(map, value, start)        Set 8bit value to map at start\n *\n * Note, bitmap_zero() and bitmap_fill() operate over the region of\n * unsigned longs, that is, bits behind bitmap till the unsigned long\n * boundary will be zeroed or filled as well. Consider to use\n * bitmap_clear() or bitmap_set() to make explicit zeroing or filling\n * respectively.\n */\n\n/**\n * DOC: bitmap bitops\n *\n * Also the following operations in asm/bitops.h apply to bitmaps.::\n *\n *  set_bit(bit, addr)                  *addr |= bit\n *  clear_bit(bit, addr)                *addr &= ~bit\n *  change_bit(bit, addr)               *addr ^= bit\n *  test_bit(bit, addr)                 Is bit set in *addr?\n *  test_and_set_bit(bit, addr)         Set bit and return old value\n *  test_and_clear_bit(bit, addr)       Clear bit and return old value\n *  test_and_change_bit(bit, addr)      Change bit and return old value\n *  find_first_zero_bit(addr, nbits)    Position first zero bit in *addr\n *  find_first_bit(addr, nbits)         Position first set bit in *addr\n *  find_next_zero_bit(addr, nbits, bit)\n *                                      Position next zero bit in *addr >= bit\n *  find_next_bit(addr, nbits, bit)     Position next set bit in *addr >= bit\n *  find_next_and_bit(addr1, addr2, nbits, bit)\n *                                      Same as find_next_bit, but in\n *                                      (*addr1 & *addr2)\n *\n */\n\n/**\n * DOC: declare bitmap\n * The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used\n * to declare an array named 'name' of just enough unsigned longs to\n * contain all bit positions from 0 to 'bits' - 1.\n */\n\n/*\n * Allocation and deallocation of bitmap.\n * Provided in lib/bitmap.c to avoid circular dependency.\n */\nunsigned long *bitmap_alloc(unsigned int nbits, gfp_t flags);\nunsigned long *bitmap_zalloc(unsigned int nbits, gfp_t flags);\nvoid bitmap_free(const unsigned long *bitmap);\n\n/* Managed variants of the above. */\nunsigned long *devm_bitmap_alloc(struct device *dev,\n\t\t\t\t unsigned int nbits, gfp_t flags);\nunsigned long *devm_bitmap_zalloc(struct device *dev,\n\t\t\t\t  unsigned int nbits, gfp_t flags);\n\n/*\n * lib/bitmap.c provides these functions:\n */\n\nint __bitmap_equal(const unsigned long *bitmap1,\n\t\t   const unsigned long *bitmap2, unsigned int nbits);\nbool __pure __bitmap_or_equal(const unsigned long *src1,\n\t\t\t      const unsigned long *src2,\n\t\t\t      const unsigned long *src3,\n\t\t\t      unsigned int nbits);\nvoid __bitmap_complement(unsigned long *dst, const unsigned long *src,\n\t\t\t unsigned int nbits);\nvoid __bitmap_shift_right(unsigned long *dst, const unsigned long *src,\n\t\t\t  unsigned int shift, unsigned int nbits);\nvoid __bitmap_shift_left(unsigned long *dst, const unsigned long *src,\n\t\t\t unsigned int shift, unsigned int nbits);\nvoid bitmap_cut(unsigned long *dst, const unsigned long *src,\n\t\tunsigned int first, unsigned int cut, unsigned int nbits);\nint __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,\n\t\t const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,\n\t\t const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,\n\t\t  const unsigned long *bitmap2, unsigned int nbits);\nint __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,\n\t\t    const unsigned long *bitmap2, unsigned int nbits);\nvoid __bitmap_replace(unsigned long *dst,\n\t\t      const unsigned long *old, const unsigned long *new,\n\t\t      const unsigned long *mask, unsigned int nbits);\nint __bitmap_intersects(const unsigned long *bitmap1,\n\t\t\tconst unsigned long *bitmap2, unsigned int nbits);\nint __bitmap_subset(const unsigned long *bitmap1,\n\t\t    const unsigned long *bitmap2, unsigned int nbits);\nint __bitmap_weight(const unsigned long *bitmap, unsigned int nbits);\nvoid __bitmap_set(unsigned long *map, unsigned int start, int len);\nvoid __bitmap_clear(unsigned long *map, unsigned int start, int len);\n\nunsigned long bitmap_find_next_zero_area_off(unsigned long *map,\n\t\t\t\t\t     unsigned long size,\n\t\t\t\t\t     unsigned long start,\n\t\t\t\t\t     unsigned int nr,\n\t\t\t\t\t     unsigned long align_mask,\n\t\t\t\t\t     unsigned long align_offset);\n\n/**\n * bitmap_find_next_zero_area - find a contiguous aligned zero area\n * @map: The address to base the search on\n * @size: The bitmap size in bits\n * @start: The bitnumber to start searching at\n * @nr: The number of zeroed bits we're looking for\n * @align_mask: Alignment mask for zero area\n *\n * The @align_mask should be one less than a power of 2; the effect is that\n * the bit offset of all zero areas this function finds is multiples of that\n * power of 2. A @align_mask of 0 means no alignment is required.\n */\nstatic inline unsigned long\nbitmap_find_next_zero_area(unsigned long *map,\n\t\t\t   unsigned long size,\n\t\t\t   unsigned long start,\n\t\t\t   unsigned int nr,\n\t\t\t   unsigned long align_mask)\n{\n\treturn bitmap_find_next_zero_area_off(map, size, start, nr,\n\t\t\t\t\t      align_mask, 0);\n}\n\nint bitmap_parse(const char *buf, unsigned int buflen,\n\t\t\tunsigned long *dst, int nbits);\nint bitmap_parse_user(const char __user *ubuf, unsigned int ulen,\n\t\t\tunsigned long *dst, int nbits);\nint bitmap_parselist(const char *buf, unsigned long *maskp,\n\t\t\tint nmaskbits);\nint bitmap_parselist_user(const char __user *ubuf, unsigned int ulen,\n\t\t\tunsigned long *dst, int nbits);\nvoid bitmap_remap(unsigned long *dst, const unsigned long *src,\n\t\tconst unsigned long *old, const unsigned long *new, unsigned int nbits);\nint bitmap_bitremap(int oldbit,\n\t\tconst unsigned long *old, const unsigned long *new, int bits);\nvoid bitmap_onto(unsigned long *dst, const unsigned long *orig,\n\t\tconst unsigned long *relmap, unsigned int bits);\nvoid bitmap_fold(unsigned long *dst, const unsigned long *orig,\n\t\tunsigned int sz, unsigned int nbits);\nint bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order);\nvoid bitmap_release_region(unsigned long *bitmap, unsigned int pos, int order);\nint bitmap_allocate_region(unsigned long *bitmap, unsigned int pos, int order);\n\n#ifdef __BIG_ENDIAN\nvoid bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits);\n#else\n#define bitmap_copy_le bitmap_copy\n#endif\nunsigned int bitmap_ord_to_pos(const unsigned long *bitmap, unsigned int ord, unsigned int nbits);\nint bitmap_print_to_pagebuf(bool list, char *buf,\n\t\t\t\t   const unsigned long *maskp, int nmaskbits);\n\n#define BITMAP_FIRST_WORD_MASK(start) (~0UL << ((start) & (BITS_PER_LONG - 1)))\n#define BITMAP_LAST_WORD_MASK(nbits) (~0UL >> (-(nbits) & (BITS_PER_LONG - 1)))\n\nstatic inline void bitmap_zero(unsigned long *dst, unsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);\n\tmemset(dst, 0, len);\n}\n\nstatic inline void bitmap_fill(unsigned long *dst, unsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);\n\tmemset(dst, 0xff, len);\n}\n\nstatic inline void bitmap_copy(unsigned long *dst, const unsigned long *src,\n\t\t\tunsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);\n\tmemcpy(dst, src, len);\n}\n\n/*\n * Copy bitmap and clear tail bits in last word.\n */\nstatic inline void bitmap_copy_clear_tail(unsigned long *dst,\n\t\tconst unsigned long *src, unsigned int nbits)\n{\n\tbitmap_copy(dst, src, nbits);\n\tif (nbits % BITS_PER_LONG)\n\t\tdst[nbits / BITS_PER_LONG] &= BITMAP_LAST_WORD_MASK(nbits);\n}\n\n/*\n * On 32-bit systems bitmaps are represented as u32 arrays internally, and\n * therefore conversion is not needed when copying data from/to arrays of u32.\n */\n#if BITS_PER_LONG == 64\nvoid bitmap_from_arr32(unsigned long *bitmap, const u32 *buf,\n\t\t\t\t\t\t\tunsigned int nbits);\nvoid bitmap_to_arr32(u32 *buf, const unsigned long *bitmap,\n\t\t\t\t\t\t\tunsigned int nbits);\n#else\n#define bitmap_from_arr32(bitmap, buf, nbits)\t\t\t\\\n\tbitmap_copy_clear_tail((unsigned long *) (bitmap),\t\\\n\t\t\t(const unsigned long *) (buf), (nbits))\n#define bitmap_to_arr32(buf, bitmap, nbits)\t\t\t\\\n\tbitmap_copy_clear_tail((unsigned long *) (buf),\t\t\\\n\t\t\t(const unsigned long *) (bitmap), (nbits))\n#endif\n\nstatic inline int bitmap_and(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn (*dst = *src1 & *src2 & BITMAP_LAST_WORD_MASK(nbits)) != 0;\n\treturn __bitmap_and(dst, src1, src2, nbits);\n}\n\nstatic inline void bitmap_or(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = *src1 | *src2;\n\telse\n\t\t__bitmap_or(dst, src1, src2, nbits);\n}\n\nstatic inline void bitmap_xor(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = *src1 ^ *src2;\n\telse\n\t\t__bitmap_xor(dst, src1, src2, nbits);\n}\n\nstatic inline int bitmap_andnot(unsigned long *dst, const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn (*dst = *src1 & ~(*src2) & BITMAP_LAST_WORD_MASK(nbits)) != 0;\n\treturn __bitmap_andnot(dst, src1, src2, nbits);\n}\n\nstatic inline void bitmap_complement(unsigned long *dst, const unsigned long *src,\n\t\t\tunsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = ~(*src);\n\telse\n\t\t__bitmap_complement(dst, src, nbits);\n}\n\n#ifdef __LITTLE_ENDIAN\n#define BITMAP_MEM_ALIGNMENT 8\n#else\n#define BITMAP_MEM_ALIGNMENT (8 * sizeof(unsigned long))\n#endif\n#define BITMAP_MEM_MASK (BITMAP_MEM_ALIGNMENT - 1)\n\nstatic inline int bitmap_equal(const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn !((*src1 ^ *src2) & BITMAP_LAST_WORD_MASK(nbits));\n\tif (__builtin_constant_p(nbits & BITMAP_MEM_MASK) &&\n\t    IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))\n\t\treturn !memcmp(src1, src2, nbits / 8);\n\treturn __bitmap_equal(src1, src2, nbits);\n}\n\n/**\n * bitmap_or_equal - Check whether the or of two bitmaps is equal to a third\n * @src1:\tPointer to bitmap 1\n * @src2:\tPointer to bitmap 2 will be or'ed with bitmap 1\n * @src3:\tPointer to bitmap 3. Compare to the result of *@src1 | *@src2\n * @nbits:\tnumber of bits in each of these bitmaps\n *\n * Returns: True if (*@src1 | *@src2) == *@src3, false otherwise\n */\nstatic inline bool bitmap_or_equal(const unsigned long *src1,\n\t\t\t\t   const unsigned long *src2,\n\t\t\t\t   const unsigned long *src3,\n\t\t\t\t   unsigned int nbits)\n{\n\tif (!small_const_nbits(nbits))\n\t\treturn __bitmap_or_equal(src1, src2, src3, nbits);\n\n\treturn !(((*src1 | *src2) ^ *src3) & BITMAP_LAST_WORD_MASK(nbits));\n}\n\nstatic inline int bitmap_intersects(const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ((*src1 & *src2) & BITMAP_LAST_WORD_MASK(nbits)) != 0;\n\telse\n\t\treturn __bitmap_intersects(src1, src2, nbits);\n}\n\nstatic inline int bitmap_subset(const unsigned long *src1,\n\t\t\tconst unsigned long *src2, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ! ((*src1 & ~(*src2)) & BITMAP_LAST_WORD_MASK(nbits));\n\telse\n\t\treturn __bitmap_subset(src1, src2, nbits);\n}\n\nstatic inline bool bitmap_empty(const unsigned long *src, unsigned nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ! (*src & BITMAP_LAST_WORD_MASK(nbits));\n\n\treturn find_first_bit(src, nbits) == nbits;\n}\n\nstatic inline bool bitmap_full(const unsigned long *src, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn ! (~(*src) & BITMAP_LAST_WORD_MASK(nbits));\n\n\treturn find_first_zero_bit(src, nbits) == nbits;\n}\n\nstatic __always_inline int bitmap_weight(const unsigned long *src, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\treturn hweight_long(*src & BITMAP_LAST_WORD_MASK(nbits));\n\treturn __bitmap_weight(src, nbits);\n}\n\nstatic __always_inline void bitmap_set(unsigned long *map, unsigned int start,\n\t\tunsigned int nbits)\n{\n\tif (__builtin_constant_p(nbits) && nbits == 1)\n\t\t__set_bit(start, map);\n\telse if (__builtin_constant_p(start & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(start, BITMAP_MEM_ALIGNMENT) &&\n\t\t __builtin_constant_p(nbits & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))\n\t\tmemset((char *)map + start / 8, 0xff, nbits / 8);\n\telse\n\t\t__bitmap_set(map, start, nbits);\n}\n\nstatic __always_inline void bitmap_clear(unsigned long *map, unsigned int start,\n\t\tunsigned int nbits)\n{\n\tif (__builtin_constant_p(nbits) && nbits == 1)\n\t\t__clear_bit(start, map);\n\telse if (__builtin_constant_p(start & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(start, BITMAP_MEM_ALIGNMENT) &&\n\t\t __builtin_constant_p(nbits & BITMAP_MEM_MASK) &&\n\t\t IS_ALIGNED(nbits, BITMAP_MEM_ALIGNMENT))\n\t\tmemset((char *)map + start / 8, 0, nbits / 8);\n\telse\n\t\t__bitmap_clear(map, start, nbits);\n}\n\nstatic inline void bitmap_shift_right(unsigned long *dst, const unsigned long *src,\n\t\t\t\tunsigned int shift, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = (*src & BITMAP_LAST_WORD_MASK(nbits)) >> shift;\n\telse\n\t\t__bitmap_shift_right(dst, src, shift, nbits);\n}\n\nstatic inline void bitmap_shift_left(unsigned long *dst, const unsigned long *src,\n\t\t\t\tunsigned int shift, unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = (*src << shift) & BITMAP_LAST_WORD_MASK(nbits);\n\telse\n\t\t__bitmap_shift_left(dst, src, shift, nbits);\n}\n\nstatic inline void bitmap_replace(unsigned long *dst,\n\t\t\t\t  const unsigned long *old,\n\t\t\t\t  const unsigned long *new,\n\t\t\t\t  const unsigned long *mask,\n\t\t\t\t  unsigned int nbits)\n{\n\tif (small_const_nbits(nbits))\n\t\t*dst = (*old & ~(*mask)) | (*new & *mask);\n\telse\n\t\t__bitmap_replace(dst, old, new, mask, nbits);\n}\n\nstatic inline void bitmap_next_clear_region(unsigned long *bitmap,\n\t\t\t\t\t    unsigned int *rs, unsigned int *re,\n\t\t\t\t\t    unsigned int end)\n{\n\t*rs = find_next_zero_bit(bitmap, end, *rs);\n\t*re = find_next_bit(bitmap, end, *rs + 1);\n}\n\nstatic inline void bitmap_next_set_region(unsigned long *bitmap,\n\t\t\t\t\t  unsigned int *rs, unsigned int *re,\n\t\t\t\t\t  unsigned int end)\n{\n\t*rs = find_next_bit(bitmap, end, *rs);\n\t*re = find_next_zero_bit(bitmap, end, *rs + 1);\n}\n\n/*\n * Bitmap region iterators.  Iterates over the bitmap between [@start, @end).\n * @rs and @re should be integer variables and will be set to start and end\n * index of the current clear or set region.\n */\n#define bitmap_for_each_clear_region(bitmap, rs, re, start, end)\t     \\\n\tfor ((rs) = (start),\t\t\t\t\t\t     \\\n\t     bitmap_next_clear_region((bitmap), &(rs), &(re), (end));\t     \\\n\t     (rs) < (re);\t\t\t\t\t\t     \\\n\t     (rs) = (re) + 1,\t\t\t\t\t\t     \\\n\t     bitmap_next_clear_region((bitmap), &(rs), &(re), (end)))\n\n#define bitmap_for_each_set_region(bitmap, rs, re, start, end)\t\t     \\\n\tfor ((rs) = (start),\t\t\t\t\t\t     \\\n\t     bitmap_next_set_region((bitmap), &(rs), &(re), (end));\t     \\\n\t     (rs) < (re);\t\t\t\t\t\t     \\\n\t     (rs) = (re) + 1,\t\t\t\t\t\t     \\\n\t     bitmap_next_set_region((bitmap), &(rs), &(re), (end)))\n\n/**\n * BITMAP_FROM_U64() - Represent u64 value in the format suitable for bitmap.\n * @n: u64 value\n *\n * Linux bitmaps are internally arrays of unsigned longs, i.e. 32-bit\n * integers in 32-bit environment, and 64-bit integers in 64-bit one.\n *\n * There are four combinations of endianness and length of the word in linux\n * ABIs: LE64, BE64, LE32 and BE32.\n *\n * On 64-bit kernels 64-bit LE and BE numbers are naturally ordered in\n * bitmaps and therefore don't require any special handling.\n *\n * On 32-bit kernels 32-bit LE ABI orders lo word of 64-bit number in memory\n * prior to hi, and 32-bit BE orders hi word prior to lo. The bitmap on the\n * other hand is represented as an array of 32-bit words and the position of\n * bit N may therefore be calculated as: word #(N/32) and bit #(N%32) in that\n * word.  For example, bit #42 is located at 10th position of 2nd word.\n * It matches 32-bit LE ABI, and we can simply let the compiler store 64-bit\n * values in memory as it usually does. But for BE we need to swap hi and lo\n * words manually.\n *\n * With all that, the macro BITMAP_FROM_U64() does explicit reordering of hi and\n * lo parts of u64.  For LE32 it does nothing, and for BE environment it swaps\n * hi and lo words, as is expected by bitmap.\n */\n#if __BITS_PER_LONG == 64\n#define BITMAP_FROM_U64(n) (n)\n#else\n#define BITMAP_FROM_U64(n) ((unsigned long) ((u64)(n) & ULONG_MAX)), \\\n\t\t\t\t((unsigned long) ((u64)(n) >> 32))\n#endif\n\n/**\n * bitmap_from_u64 - Check and swap words within u64.\n *  @mask: source bitmap\n *  @dst:  destination bitmap\n *\n * In 32-bit Big Endian kernel, when using ``(u32 *)(&val)[*]``\n * to read u64 mask, we will get the wrong word.\n * That is ``(u32 *)(&val)[0]`` gets the upper 32 bits,\n * but we expect the lower 32-bits of u64.\n */\nstatic inline void bitmap_from_u64(unsigned long *dst, u64 mask)\n{\n\tdst[0] = mask & ULONG_MAX;\n\n\tif (sizeof(mask) > sizeof(unsigned long))\n\t\tdst[1] = mask >> 32;\n}\n\n/**\n * bitmap_get_value8 - get an 8-bit value within a memory region\n * @map: address to the bitmap memory region\n * @start: bit offset of the 8-bit value; must be a multiple of 8\n *\n * Returns the 8-bit value located at the @start bit offset within the @src\n * memory region.\n */\nstatic inline unsigned long bitmap_get_value8(const unsigned long *map,\n\t\t\t\t\t      unsigned long start)\n{\n\tconst size_t index = BIT_WORD(start);\n\tconst unsigned long offset = start % BITS_PER_LONG;\n\n\treturn (map[index] >> offset) & 0xFF;\n}\n\n/**\n * bitmap_set_value8 - set an 8-bit value within a memory region\n * @map: address to the bitmap memory region\n * @value: the 8-bit value; values wider than 8 bits may clobber bitmap\n * @start: bit offset of the 8-bit value; must be a multiple of 8\n */\nstatic inline void bitmap_set_value8(unsigned long *map, unsigned long value,\n\t\t\t\t     unsigned long start)\n{\n\tconst size_t index = BIT_WORD(start);\n\tconst unsigned long offset = start % BITS_PER_LONG;\n\n\tmap[index] &= ~(0xFFUL << offset);\n\tmap[index] |= value << offset;\n}\n\n#endif /* __ASSEMBLY__ */\n\n#endif /* __LINUX_BITMAP_H */\n"}, "6": {"id": 6, "path": "/src/include/asm-generic/bitsperlong.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __ASM_GENERIC_BITS_PER_LONG\n#define __ASM_GENERIC_BITS_PER_LONG\n\n#include <uapi/asm-generic/bitsperlong.h>\n\n\n#ifdef CONFIG_64BIT\n#define BITS_PER_LONG 64\n#else\n#define BITS_PER_LONG 32\n#endif /* CONFIG_64BIT */\n\n/*\n * FIXME: The check currently breaks x86-64 build, so it's\n * temporarily disabled. Please fix x86-64 and reenable\n */\n#if 0 && BITS_PER_LONG != __BITS_PER_LONG\n#error Inconsistent word size. Check asm/bitsperlong.h\n#endif\n\n#ifndef BITS_PER_LONG_LONG\n#define BITS_PER_LONG_LONG 64\n#endif\n\n/*\n * small_const_nbits(n) is true precisely when it is known at compile-time\n * that BITMAP_SIZE(n) is 1, i.e. 1 <= n <= BITS_PER_LONG. This allows\n * various bit/bitmap APIs to provide a fast inline implementation. Bitmaps\n * of size 0 are very rare, and a compile-time-known-size 0 is most likely\n * a sign of error. They will be handled correctly by the bit/bitmap APIs,\n * but using the out-of-line functions, so that the inline implementations\n * can unconditionally dereference the pointer(s).\n */\n#define small_const_nbits(nbits) \\\n\t(__builtin_constant_p(nbits) && (nbits) <= BITS_PER_LONG && (nbits) > 0)\n\n#endif /* __ASM_GENERIC_BITS_PER_LONG */\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 2738}, "message": "Calling 'cpufreq_offline'"}, {"location": {"col": 2, "file": 0, "line": 1562}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 1, "line": 430}, "message": "expanded from macro 'pr_debug'"}, {"location": {"col": 2, "file": 1, "line": 139}, "message": "expanded from macro 'no_printk'"}, {"location": {"col": 11, "file": 0, "line": 1564}, "message": "Calling 'cpufreq_cpu_get_raw'"}, {"location": {"col": 34, "file": 0, "line": 187}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 29, "file": 2, "line": 269}, "message": "expanded from macro 'per_cpu'"}, {"location": {"col": 2, "file": 2, "line": 235}, "message": "expanded from macro 'per_cpu_ptr'"}, {"location": {"col": 37, "file": 2, "line": 217}, "message": "expanded from macro '__verify_pcpu_ptr'"}, {"location": {"col": 9, "file": 0, "line": 189}, "message": "Assuming 'policy' is non-null, which participates in a condition later"}, {"location": {"col": 9, "file": 0, "line": 189}, "message": "Left side of '&&' is true"}, {"location": {"col": 19, "file": 0, "line": 189}, "message": "Assuming the condition is true"}, {"location": {"col": 9, "file": 0, "line": 189}, "message": "'?' condition is true"}, {"location": {"col": 2, "file": 0, "line": 189}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 11, "file": 0, "line": 1564}, "message": "Returning from 'cpufreq_cpu_get_raw'"}, {"location": {"col": 7, "file": 0, "line": 1565}, "message": "'policy' is non-null"}, {"location": {"col": 2, "file": 0, "line": 1565}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 1571}, "message": "Taking true branch"}, {"location": {"col": 6, "file": 0, "line": 1576}, "message": "Calling 'policy_is_inactive'"}, {"location": {"col": 9, "file": 3, "line": 201}, "message": "Calling 'cpumask_empty'"}, {"location": {"col": 9, "file": 4, "line": 551}, "message": "Calling 'bitmap_empty'"}, {"location": {"col": 6, "file": 5, "line": 382}, "message": "Left side of '&&' is false"}, {"location": {"col": 31, "file": 6, "line": 36}, "message": "expanded from macro 'small_const_nbits'"}, {"location": {"col": 9, "file": 5, "line": 385}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 5, "line": 385}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 9, "file": 4, "line": 551}, "message": "Returning from 'bitmap_empty'"}, {"location": {"col": 2, "file": 4, "line": 551}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 9, "file": 3, "line": 201}, "message": "Returning from 'cpumask_empty'"}, {"location": {"col": 2, "file": 3, "line": 201}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 1576}, "message": "Returning from 'policy_is_inactive'"}, {"location": {"col": 2, "file": 0, "line": 1576}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 1577}, "message": "Calling 'has_target'"}, {"location": {"col": 9, "file": 0, "line": 75}, "message": "Assuming field 'target_index' is non-null"}, {"location": {"col": 38, "file": 0, "line": 75}, "message": "Left side of '||' is true"}, {"location": {"col": 2, "file": 0, "line": 75}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 1577}, "message": "Returning from 'has_target'"}, {"location": {"col": 3, "file": 0, "line": 1577}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 1578}, "message": "Null pointer passed as 2nd argument to string copy function"}, {"location": {"col": 4, "file": 0, "line": 1578}, "message": "Null pointer passed as 2nd argument to string copy function"}], "macros": [], "notes": [], "path": "/src/drivers/cpufreq/cpufreq.c", "reportHash": "f0aad1d9535d1470240e30f65bf908a9", "checkerName": "clang-analyzer-unix.cstring.NullArg", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
