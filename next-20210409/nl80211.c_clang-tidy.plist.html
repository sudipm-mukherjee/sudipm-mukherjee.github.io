<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/wireless/nl80211.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * This is the new netlink-based wireless configuration interface.\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright 2015-2017\tIntel Deutschland GmbH\n * Copyright (C) 2018-2021 Intel Corporation\n */\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/nospec.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include <net/inet_connection_sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit);\n\n/* the netlink family */\nstatic struct genl_family nl80211_fam;\n\n/* multicast groups */\nenum nl80211_multicast_groups {\n\tNL80211_MCGRP_CONFIG,\n\tNL80211_MCGRP_SCAN,\n\tNL80211_MCGRP_REGULATORY,\n\tNL80211_MCGRP_MLME,\n\tNL80211_MCGRP_VENDOR,\n\tNL80211_MCGRP_NAN,\n\tNL80211_MCGRP_TESTMODE /* keep last - ifdef! */\n};\n\nstatic const struct genl_multicast_group nl80211_mcgrps[] = {\n\t[NL80211_MCGRP_CONFIG] = { .name = NL80211_MULTICAST_GROUP_CONFIG },\n\t[NL80211_MCGRP_SCAN] = { .name = NL80211_MULTICAST_GROUP_SCAN },\n\t[NL80211_MCGRP_REGULATORY] = { .name = NL80211_MULTICAST_GROUP_REG },\n\t[NL80211_MCGRP_MLME] = { .name = NL80211_MULTICAST_GROUP_MLME },\n\t[NL80211_MCGRP_VENDOR] = { .name = NL80211_MULTICAST_GROUP_VENDOR },\n\t[NL80211_MCGRP_NAN] = { .name = NL80211_MULTICAST_GROUP_NAN },\n#ifdef CONFIG_NL80211_TESTMODE\n\t[NL80211_MCGRP_TESTMODE] = { .name = NL80211_MULTICAST_GROUP_TESTMODE }\n#endif\n};\n\n/* returns ERR_PTR values */\nstatic struct wireless_dev *\n__cfg80211_wdev_from_attrs(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net *netns, struct nlattr **attrs)\n{\n\tstruct wireless_dev *result = NULL;\n\tbool have_ifidx = attrs[NL80211_ATTR_IFINDEX];\n\tbool have_wdev_id = attrs[NL80211_ATTR_WDEV];\n\tu64 wdev_id = 0;\n\tint wiphy_idx = -1;\n\tint ifidx = -1;\n\n\tif (!have_ifidx && !have_wdev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\tif (have_wdev_id) {\n\t\twdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\twiphy_idx = wdev_id >> 32;\n\t}\n\n\tif (rdev) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result ?: ERR_PTR(-ENODEV);\n\t}\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tif (wiphy_net(&rdev->wiphy) != netns)\n\t\t\tcontinue;\n\n\t\tif (have_wdev_id && rdev->wiphy_idx != wiphy_idx)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\n\tif (result)\n\t\treturn result;\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct cfg80211_registered_device *\n__cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev = NULL, *tmp;\n\tstruct net_device *netdev;\n\n\tASSERT_RTNL();\n\n\tif (!attrs[NL80211_ATTR_WIPHY] &&\n\t    !attrs[NL80211_ATTR_IFINDEX] &&\n\t    !attrs[NL80211_ATTR_WDEV])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_WIPHY])\n\t\trdev = cfg80211_rdev_by_wiphy_idx(\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_WIPHY]));\n\n\tif (attrs[NL80211_ATTR_WDEV]) {\n\t\tu64 wdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\tstruct wireless_dev *wdev;\n\t\tbool found = false;\n\n\t\ttmp = cfg80211_rdev_by_wiphy_idx(wdev_id >> 32);\n\t\tif (tmp) {\n\t\t\t/* make sure wdev exists */\n\t\t\tlist_for_each_entry(wdev, &tmp->wiphy.wdev_list, list) {\n\t\t\t\tif (wdev->identifier != (u32)wdev_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\ttmp = NULL;\n\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(netns, ifindex);\n\t\tif (netdev) {\n\t\t\tif (netdev->ieee80211_ptr)\n\t\t\t\ttmp = wiphy_to_rdev(\n\t\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\telse\n\t\t\t\ttmp = NULL;\n\n\t\t\t/* not wireless device -- return error */\n\t\t\tif (!tmp)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* mismatch -- return error */\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (netns != wiphy_net(&rdev->wiphy))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rdev;\n}\n\n/*\n * This function returns a pointer to the driver\n * that the genl_info item that is passed refers to.\n *\n * The result of this can be a PTR_ERR and hence must\n * be checked with IS_ERR() for errors.\n */\nstatic struct cfg80211_registered_device *\ncfg80211_get_dev_from_info(struct net *netns, struct genl_info *info)\n{\n\treturn __cfg80211_rdev_from_attrs(netns, info->attrs);\n}\n\nstatic int validate_beacon_head(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\tconst struct ieee80211_mgmt *mgmt = (void *)data;\n\tunsigned int fixedlen, hdrlen;\n\tbool s1g_bcn;\n\n\tif (len < offsetofend(typeof(*mgmt), frame_control))\n\t\tgoto err;\n\n\ts1g_bcn = ieee80211_is_s1g_beacon(mgmt->frame_control);\n\tif (s1g_bcn) {\n\t\tfixedlen = offsetof(struct ieee80211_ext,\n\t\t\t\t    u.s1g_beacon.variable);\n\t\thdrlen = offsetof(struct ieee80211_ext, u.s1g_beacon);\n\t} else {\n\t\tfixedlen = offsetof(struct ieee80211_mgmt,\n\t\t\t\t    u.beacon.variable);\n\t\thdrlen = offsetof(struct ieee80211_mgmt, u.beacon);\n\t}\n\n\tif (len < fixedlen)\n\t\tgoto err;\n\n\tif (ieee80211_hdrlen(mgmt->frame_control) != hdrlen)\n\t\tgoto err;\n\n\tdata += fixedlen;\n\tlen -= fixedlen;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\nerr:\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed beacon head\");\n\treturn -EINVAL;\n}\n\nstatic int validate_ie_attr(const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\n\tfor_each_element(elem, data, len) {\n\t\t/* nothing */\n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed information elements\");\n\treturn -EINVAL;\n}\n\n/* policy for the attributes */\nstatic const struct nla_policy nl80211_policy[NUM_NL80211_ATTR];\n\nstatic const struct nla_policy\nnl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {\n\t[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_FTM_RESP_ATTR_LCI] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = U8_MAX },\n\t[NL80211_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = U8_MAX },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =\n\t\tNLA_POLICY_MAX(NLA_U8, 31),\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_REQ_ATTR_DATA] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),\n\t[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_psmr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,\n\t[NL80211_PMSR_PEER_ATTR_CHAN] = NLA_POLICY_NESTED(nl80211_policy),\n\t[NL80211_PMSR_PEER_ATTR_REQ] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),\n\t[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_PEERS] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_psmr_peer_attr_policy),\n};\n\nstatic const struct nla_policy\nhe_obss_pd_policy[NL80211_HE_OBSS_PD_ATTR_MAX + 1] = {\n\t[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP] =\n\t\tNLA_POLICY_EXACT_LEN(8),\n\t[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP] =\n\t\tNLA_POLICY_EXACT_LEN(8),\n\t[NL80211_HE_OBSS_PD_ATTR_SR_CTRL] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\nhe_bss_color_policy[NL80211_HE_BSS_COLOR_ATTR_MAX + 1] = {\n\t[NL80211_HE_BSS_COLOR_ATTR_COLOR] = NLA_POLICY_RANGE(NLA_U8, 1, 63),\n\t[NL80211_HE_BSS_COLOR_ATTR_DISABLED] = { .type = NLA_FLAG },\n\t[NL80211_HE_BSS_COLOR_ATTR_PARTIAL] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_TXRATE_HT] = { .type = NLA_BINARY,\n\t\t\t\t.len = NL80211_MAX_SUPP_HT_RATES },\n\t[NL80211_TXRATE_VHT] = NLA_POLICY_EXACT_LEN_WARN(sizeof(struct nl80211_txrate_vht)),\n\t[NL80211_TXRATE_GI] = { .type = NLA_U8 },\n\t[NL80211_TXRATE_HE] = NLA_POLICY_EXACT_LEN(sizeof(struct nl80211_txrate_he)),\n\t[NL80211_TXRATE_HE_GI] =  NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_GI_0_8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_GI_3_2),\n\t[NL80211_TXRATE_HE_LTF] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_1XLTF,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_4XLTF),\n};\n\nstatic const struct nla_policy\nnl80211_tid_config_attr_policy[NL80211_TID_CONFIG_ATTR_MAX + 1] = {\n\t[NL80211_TID_CONFIG_ATTR_VIF_SUPP] = { .type = NLA_U64 },\n\t[NL80211_TID_CONFIG_ATTR_PEER_SUPP] = { .type = NLA_U64 },\n\t[NL80211_TID_CONFIG_ATTR_OVERRIDE] = { .type = NLA_FLAG },\n\t[NL80211_TID_CONFIG_ATTR_TIDS] = NLA_POLICY_RANGE(NLA_U16, 1, 0xff),\n\t[NL80211_TID_CONFIG_ATTR_NOACK] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_TID_CONFIG_ATTR_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TX_RATE_FIXED),\n\t[NL80211_TID_CONFIG_ATTR_TX_RATE] =\n\t\t\tNLA_POLICY_NESTED(nl80211_txattr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_fils_discovery_policy[NL80211_FILS_DISCOVERY_ATTR_MAX + 1] = {\n\t[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] = NLA_POLICY_MAX(NLA_U32, 10000),\n\t[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] = NLA_POLICY_MAX(NLA_U32, 10000),\n\t[NL80211_FILS_DISCOVERY_ATTR_TMPL] =\n\t\t\tNLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t NL80211_FILS_DISCOVERY_TMPL_MIN_LEN,\n\t\t\t\t\t IEEE80211_MAX_DATA_LEN),\n};\n\nstatic const struct nla_policy\nnl80211_unsol_bcast_probe_resp_policy[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX + 1] = {\n\t[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT] = NLA_POLICY_MAX(NLA_U32, 20),\n\t[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL] = { .type = NLA_BINARY,\n\t\t\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN }\n};\n\nstatic const struct nla_policy\nsar_specs_policy[NL80211_SAR_ATTR_SPECS_MAX + 1] = {\n\t[NL80211_SAR_ATTR_SPECS_POWER] = { .type = NLA_S32 },\n\t[NL80211_SAR_ATTR_SPECS_RANGE_INDEX] = {.type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nsar_policy[NL80211_SAR_ATTR_MAX + 1] = {\n\t[NL80211_SAR_ATTR_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_SAR_TYPE),\n\t[NL80211_SAR_ATTR_SPECS] = NLA_POLICY_NESTED_ARRAY(sar_specs_policy),\n};\n\nstatic const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {\n\t[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_EDMG_CHANNELS] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MIN,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MAX),\n\t[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MIN,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MAX),\n\n\t[NL80211_ATTR_CHANNEL_WIDTH] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),\n\t[NL80211_ATTR_CENTER_FREQ2] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_DYN_ACK] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_IFTYPE] = NLA_POLICY_MAX(NLA_U32, NL80211_IFTYPE_MAX),\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_PREV_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = NLA_POLICY_MAX(NLA_U8, 7),\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_ATTR_KEY_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES),\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_beacon_head,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_BEACON_TAIL] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_STA_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_ACTIONS - 1),\n\t[NL80211_ATTR_STA_TX_POWER_SETTING] =\n\t\tNLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t NL80211_TX_POWER_AUTOMATIC,\n\t\t\t\t NL80211_TX_POWER_FIXED),\n\t[NL80211_ATTR_STA_TX_POWER] = { .type = NLA_S16 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = { /* NLA_NESTED can't be empty */ },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = NLA_POLICY_ETH_ADDR_COMPAT,\n\n\t[NL80211_ATTR_REG_ALPHA2] = { .type = NLA_STRING, .len = 2 },\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = NLA_POLICY_EXACT_LEN_WARN(NL80211_HT_CAPABILITY_LEN),\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t   validate_ie_attr,\n\t\t\t\t\t\t   IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t  NL80211_MFP_NO,\n\t\t\t\t\t\t  NL80211_MFP_OPTIONAL),\n\t[NL80211_ATTR_STA_FLAGS2] = {\n\t\t.len = sizeof(struct nl80211_sta_flag_update),\n\t},\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_OVER_NL80211] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_STATUS_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = NLA_POLICY_EXACT_LEN_WARN(WLAN_PMKID_LEN),\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t   NL80211_PS_DISABLED,\n\t\t\t\t\t\t   NL80211_PS_ENABLED),\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_STATES - 1),\n\t[NL80211_ATTR_MEASUREMENT_DURATION] = { .type = NLA_U16 },\n\t[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_MESH_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HIDDEN_SSID] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_HIDDEN_SSID_NOT_IN_USE,\n\t\t\t\t NL80211_HIDDEN_SSID_ZERO_CONTENTS),\n\t[NL80211_ATTR_IE_PROBE_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_IE_ASSOC_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_DIALOG_TOKEN] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_OPERATION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_EXTERNAL_SETUP] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_INITIATOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_DONT_WAIT_FOR_ACK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PROBE_RESP] = { .type = NLA_BINARY,\n\t\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_DFS_REGION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_DISABLE_HT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_NOACK_MAP] = { .type = NLA_U16 },\n\t[NL80211_ATTR_INACTIVITY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_ATTR_BG_SCAN_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WDEV] = { .type = NLA_U64 },\n\t[NL80211_ATTR_USER_REG_HINT_TYPE] = { .type = NLA_U32 },\n\n\t/* need to include at least Auth Transaction and Status Code */\n\t[NL80211_ATTR_AUTH_DATA] = NLA_POLICY_MIN_LEN(4),\n\n\t[NL80211_ATTR_VHT_CAPABILITY] = NLA_POLICY_EXACT_LEN_WARN(NL80211_VHT_CAPABILITY_LEN),\n\t[NL80211_ATTR_SCAN_FLAGS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_P2P_CTWINDOW] = NLA_POLICY_MAX(NLA_U8, 127),\n\t[NL80211_ATTR_P2P_OPPPS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_ATTR_LOCAL_MESH_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_UNKNOWN + 1,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_ATTR_ACL_POLICY] = {. type = NLA_U32 },\n\t[NL80211_ATTR_MAC_ADDRS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_CAPABILITY] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_EXT_CAPABILITY] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_SPLIT_WIPHY_DUMP] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_DISABLE_VHT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_VHT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_VHT_CAPABILITY_LEN,\n\t},\n\t[NL80211_ATTR_MDID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,\n\t\t\t\t  .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_CRIT_PROT_ID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_MAX_CRIT_PROT_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U16, NL80211_CRIT_PROTO_MAX_DURATION),\n\t[NL80211_ATTR_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_CH_SWITCH_COUNT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CH_SWITCH_BLOCK_TX] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_IES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_CNTDWN_OFFS_BEACON] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CNTDWN_OFFS_PRESP] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_CHANNELS] = NLA_POLICY_MIN_LEN(2),\n\t/*\n\t * The value of the Length field of the Supported Operating\n\t * Classes element is between 2 and 253.\n\t */\n\t[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] =\n\t\tNLA_POLICY_RANGE(NLA_BINARY, 2, 253),\n\t[NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },\n\t[NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_QOS_MAP] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t\t  IEEE80211_QOS_MAP_LEN_MIN,\n\t\t\t\t\t\t  IEEE80211_QOS_MAP_LEN_MAX),\n\t[NL80211_ATTR_MAC_HINT] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SOCKET_OWNER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_USE_RRM] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TSID] = NLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_TIDS - 1),\n\t[NL80211_ATTR_USER_PRIO] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_UPS - 1),\n\t[NL80211_ATTR_ADMITTED_TIME] = { .type = NLA_U16 },\n\t[NL80211_ATTR_SMPS_MODE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_OPER_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_MAC_MASK] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_WIPHY_SELF_MANAGED_REG] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_NETNS_FD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SCHED_SCAN_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REG_INDOOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_SUPPORT_P2P_PS] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_P2P_PS_STATUS - 1),\n\t[NL80211_ATTR_MU_MIMO_GROUP_DATA] = {\n\t\t.len = VHT_MUMIMO_GROUPS_DATA_LEN\n\t},\n\t[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_NAN_MASTER_PREF] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_BANDS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FILS_KEK] = { .type = NLA_BINARY,\n\t\t\t\t    .len = FILS_MAX_KEK_LEN },\n\t[NL80211_ATTR_FILS_NONCES] = NLA_POLICY_EXACT_LEN_WARN(2 * FILS_NONCE_LEN),\n\t[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] = { .type = NLA_S8 },\n\t[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n\t[NL80211_ATTR_TIMEOUT_REASON] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FILS_ERP_USERNAME] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = FILS_ERP_MAX_USERNAME_LEN },\n\t[NL80211_ATTR_FILS_ERP_REALM] = { .type = NLA_BINARY,\n\t\t\t\t\t  .len = FILS_ERP_MAX_REALM_LEN },\n\t[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FILS_ERP_RRK] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = FILS_ERP_MAX_RRK_LEN },\n\t[NL80211_ATTR_FILS_CACHE_ID] = NLA_POLICY_EXACT_LEN_WARN(2),\n\t[NL80211_ATTR_PMK] = { .type = NLA_BINARY, .len = PMK_MAX_LEN },\n\t[NL80211_ATTR_PMKR0_NAME] = NLA_POLICY_EXACT_LEN(WLAN_PMK_NAME_LEN),\n\t[NL80211_ATTR_SCHED_SCAN_MULTI] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_TXQ_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_MEMORY_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },\n\t[NL80211_ATTR_HE_CAPABILITY] =\n\t\tNLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t NL80211_HE_MIN_CAPABILITY_LEN,\n\t\t\t\t NL80211_HE_MAX_CAPABILITY_LEN),\n\t[NL80211_ATTR_FTM_RESPONDER] =\n\t\tNLA_POLICY_NESTED(nl80211_ftm_responder_policy),\n\t[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PEER_MEASUREMENTS] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_attr_policy),\n\t[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_ATTR_SAE_PASSWORD] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = SAE_PASSWORD_MAX_LEN },\n\t[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),\n\t[NL80211_ATTR_VLAN_ID] = NLA_POLICY_RANGE(NLA_U16, 1, VLAN_N_VID - 2),\n\t[NL80211_ATTR_HE_BSS_COLOR] = NLA_POLICY_NESTED(he_bss_color_policy),\n\t[NL80211_ATTR_TID_CONFIG] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_tid_config_attr_policy),\n\t[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PMK_LIFETIME] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PMK_REAUTH_THRESHOLD] = NLA_POLICY_RANGE(NLA_U8, 1, 100),\n\t[NL80211_ATTR_RECEIVE_MULTICAST] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_WIPHY_FREQ_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),\n\t[NL80211_ATTR_SCAN_FREQ_KHZ] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HE_6GHZ_CAPABILITY] =\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct ieee80211_he_6ghz_capa)),\n\t[NL80211_ATTR_FILS_DISCOVERY] =\n\t\tNLA_POLICY_NESTED(nl80211_fils_discovery_policy),\n\t[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP] =\n\t\tNLA_POLICY_NESTED(nl80211_unsol_bcast_probe_resp_policy),\n\t[NL80211_ATTR_S1G_CAPABILITY] =\n\t\tNLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),\n\t[NL80211_ATTR_S1G_CAPABILITY_MASK] =\n\t\tNLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),\n\t[NL80211_ATTR_SAE_PWE] =\n\t\tNLA_POLICY_RANGE(NLA_U8, NL80211_SAE_PWE_HUNT_AND_PECK,\n\t\t\t\t NL80211_SAE_PWE_BOTH),\n\t[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },\n\t[NL80211_ATTR_SAR_SPEC] = NLA_POLICY_NESTED(sar_policy),\n\t[NL80211_ATTR_DISABLE_HE] = { .type = NLA_FLAG },\n};\n\n/* policy for the key attributes */\nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES - 1),\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_KEY_MODE] = NLA_POLICY_RANGE(NLA_U8, 0, NL80211_KEY_SET_TX),\n};\n\n/* policy for the key default flags */\nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n#ifdef CONFIG_PM\n/* policy for WoWLAN attributes */\nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_RFKILL_RELEASE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_TCP_CONNECTION] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_NET_DETECT] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nnl80211_wowlan_tcp_policy[NUM_NL80211_WOWLAN_TCP] = {\n\t[NL80211_WOWLAN_TCP_SRC_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_MAC] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_WOWLAN_TCP_SRC_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DST_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD] = NLA_POLICY_MIN_LEN(1),\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_seq)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_token)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] = NLA_POLICY_MIN_LEN(1),\n\t[NL80211_WOWLAN_TCP_WAKE_MASK] = NLA_POLICY_MIN_LEN(1),\n};\n#endif /* CONFIG_PM */\n\n/* policy for coalesce rule attributes */\nstatic const struct nla_policy\nnl80211_coalesce_policy[NUM_NL80211_ATTR_COALESCE_RULE] = {\n\t[NL80211_ATTR_COALESCE_RULE_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COALESCE_RULE_CONDITION] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_COALESCE_CONDITION_MATCH,\n\t\t\t\t NL80211_COALESCE_CONDITION_NO_MATCH),\n\t[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n/* policy for GTK rekey offload attributes */\nstatic const struct nla_policy\nnl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {\n\t[NL80211_REKEY_DATA_KEK] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = NL80211_KEK_EXT_LEN\n\t},\n\t[NL80211_REKEY_DATA_KCK] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = NL80211_KCK_EXT_LEN\n\t},\n\t[NL80211_REKEY_DATA_REPLAY_CTR] = NLA_POLICY_EXACT_LEN(NL80211_REPLAY_CTR_LEN),\n\t[NL80211_REKEY_DATA_AKM] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_band_rssi_policy[NUM_NL80211_BANDS] = {\n\t[NL80211_BAND_2GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_5GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_6GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_60GHZ] = { .type = NLA_S32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t\t\t .len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI] =\n\t\tNLA_POLICY_NESTED(nl80211_match_band_rssi_policy),\n};\n\nstatic const struct nla_policy\nnl80211_plan_policy[NL80211_SCHED_SCAN_PLAN_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_PLAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_PLAN_ITERATIONS] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_bss_select_policy[NL80211_BSS_SELECT_ATTR_MAX + 1] = {\n\t[NL80211_BSS_SELECT_ATTR_RSSI] = { .type = NLA_FLAG },\n\t[NL80211_BSS_SELECT_ATTR_BAND_PREF] = { .type = NLA_U32 },\n\t[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n};\n\n/* policy for NAN function attributes */\nstatic const struct nla_policy\nnl80211_nan_func_policy[NL80211_NAN_FUNC_ATTR_MAX + 1] = {\n\t[NL80211_NAN_FUNC_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NL80211_NAN_FUNC_MAX_TYPE),\n\t[NL80211_NAN_FUNC_SERVICE_ID] = {\n\t\t\t\t    .len = NL80211_NAN_FUNC_SERVICE_ID_LEN },\n\t[NL80211_NAN_FUNC_PUBLISH_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_PUBLISH_BCAST] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_DEST] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_NAN_FUNC_CLOSE_RANGE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_TTL] = { .type = NLA_U32 },\n\t[NL80211_NAN_FUNC_SERVICE_INFO] = { .type = NLA_BINARY,\n\t\t\t.len = NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN },\n\t[NL80211_NAN_FUNC_SRF] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_RX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_TX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_INSTANCE_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_TERM_REASON] = { .type = NLA_U8 },\n};\n\n/* policy for Service Response Filter attributes */\nstatic const struct nla_policy\nnl80211_nan_srf_policy[NL80211_NAN_SRF_ATTR_MAX + 1] = {\n\t[NL80211_NAN_SRF_INCLUDE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_SRF_BF] = { .type = NLA_BINARY,\n\t\t\t\t .len =  NL80211_NAN_FUNC_SRF_MAX_LEN },\n\t[NL80211_NAN_SRF_BF_IDX] = { .type = NLA_U8 },\n\t[NL80211_NAN_SRF_MAC_ADDRS] = { .type = NLA_NESTED },\n};\n\n/* policy for packet pattern attributes */\nstatic const struct nla_policy\nnl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {\n\t[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },\n};\n\nint nl80211_prepare_wdev_dump(struct netlink_callback *cb,\n\t\t\t      struct cfg80211_registered_device **rdev,\n\t\t\t      struct wireless_dev **wdev)\n{\n\tint err;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr **attrbuf;\n\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf)\n\t\t\treturn -ENOMEM;\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err) {\n\t\t\tkfree(attrbuf);\n\t\t\treturn err;\n\t\t}\n\n\t\trtnl_lock();\n\t\t*wdev = __cfg80211_wdev_from_attrs(NULL, sock_net(cb->skb->sk),\n\t\t\t\t\t\t   attrbuf);\n\t\tkfree(attrbuf);\n\t\tif (IS_ERR(*wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(*wdev);\n\t\t}\n\t\t*rdev = wiphy_to_rdev((*wdev)->wiphy);\n\t\tmutex_lock(&(*rdev)->wiphy.mtx);\n\t\trtnl_unlock();\n\t\t/* 0 is the first index - add 1 to parse only once */\n\t\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t\tcb->args[1] = (*wdev)->identifier;\n\t} else {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy;\n\t\tstruct wireless_dev *tmp;\n\n\t\trtnl_lock();\n\t\twiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tif (!wiphy) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tlist_for_each_entry(tmp, &(*rdev)->wiphy.wdev_list, list) {\n\t\t\tif (tmp->identifier == cb->args[1]) {\n\t\t\t\t*wdev = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*wdev) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmutex_lock(&(*rdev)->wiphy.mtx);\n\t\trtnl_unlock();\n\t}\n\n\treturn 0;\n}\n\n/* message building helper */\nvoid *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t     int flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_wmm_rules(struct sk_buff *msg,\n\t\t\t\t     const struct ieee80211_reg_rule *rule)\n{\n\tint j;\n\tstruct nlattr *nl_wmm_rules =\n\t\tnla_nest_start_noflag(msg, NL80211_FREQUENCY_ATTR_WMM);\n\n\tif (!nl_wmm_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (j = 0; j < IEEE80211_NUM_ACS; j++) {\n\t\tstruct nlattr *nl_wmm_rule = nla_nest_start_noflag(msg, j);\n\n\t\tif (!nl_wmm_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(msg, NL80211_WMMR_CW_MIN,\n\t\t\t\trule->wmm_rule.client[j].cw_min) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_CW_MAX,\n\t\t\t\trule->wmm_rule.client[j].cw_max) ||\n\t\t    nla_put_u8(msg, NL80211_WMMR_AIFSN,\n\t\t\t       rule->wmm_rule.client[j].aifsn) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_TXOP,\n\t\t\t        rule->wmm_rule.client[j].cot))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wmm_rule);\n\t}\n\tnla_nest_end(msg, nl_wmm_rules);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   bool large)\n{\n\t/* Some channels must be completely excluded from the\n\t * list to protect old user-space tools from breaking\n\t */\n\tif (!large && chan->flags &\n\t    (IEEE80211_CHAN_NO_10MHZ | IEEE80211_CHAN_NO_20MHZ))\n\t\treturn 0;\n\tif (!large && chan->freq_offset)\n\t\treturn 0;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t\tchan->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_OFFSET, chan->freq_offset))\n\t\tgoto nla_put_failure;\n\n\tif ((chan->flags & IEEE80211_CHAN_DISABLED) &&\n\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))\n\t\tgoto nla_put_failure;\n\tif (chan->flags & IEEE80211_CHAN_NO_IR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_flag(msg, __NL80211_FREQUENCY_ATTR_NO_IBSS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_RADAR))\n\t\t\tgoto nla_put_failure;\n\t\tif (large) {\n\t\t\tu32 time;\n\n\t\t\ttime = elapsed_jiffies_msecs(chan->dfs_state_entered);\n\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_STATE,\n\t\t\t\t\tchan->dfs_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_TIME,\n\t\t\t\t\ttime))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\tNL80211_FREQUENCY_ATTR_DFS_CAC_TIME,\n\t\t\t\t\tchan->dfs_cac_ms))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (large) {\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40MINUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_MINUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40PLUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_PLUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_80MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_80MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_160MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_160MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_INDOOR_ONLY) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_INDOOR_ONLY))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_IR_CONCURRENT) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_IR_CONCURRENT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_20MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_20MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_10MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_10MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HE) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HE))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_1MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_1MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_2MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_2MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_4MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_4MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_8MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_8MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_16MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_16MHZ))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t\tDBM_TO_MBM(chan->max_power)))\n\t\tgoto nla_put_failure;\n\n\tif (large) {\n\t\tconst struct ieee80211_reg_rule *rule =\n\t\t\tfreq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));\n\n\t\tif (!IS_ERR_OR_NULL(rule) && rule->has_wmm) {\n\t\t\tif (nl80211_msg_put_wmm_rules(msg, rule))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic bool nl80211_put_txq_stats(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_txq_stats *txqstats,\n\t\t\t\t  int attrtype)\n{\n\tstruct nlattr *txqattr;\n\n#define PUT_TXQVAL_U32(attr, memb) do {\t\t\t\t\t  \\\n\tif (txqstats->filled & BIT(NL80211_TXQ_STATS_ ## attr) &&\t  \\\n\t    nla_put_u32(msg, NL80211_TXQ_STATS_ ## attr, txqstats->memb)) \\\n\t\treturn false;\t\t\t\t\t\t  \\\n\t} while (0)\n\n\ttxqattr = nla_nest_start_noflag(msg, attrtype);\n\tif (!txqattr)\n\t\treturn false;\n\n\tPUT_TXQVAL_U32(BACKLOG_BYTES, backlog_bytes);\n\tPUT_TXQVAL_U32(BACKLOG_PACKETS, backlog_packets);\n\tPUT_TXQVAL_U32(FLOWS, flows);\n\tPUT_TXQVAL_U32(DROPS, drops);\n\tPUT_TXQVAL_U32(ECN_MARKS, ecn_marks);\n\tPUT_TXQVAL_U32(OVERLIMIT, overlimit);\n\tPUT_TXQVAL_U32(OVERMEMORY, overmemory);\n\tPUT_TXQVAL_U32(COLLISIONS, collisions);\n\tPUT_TXQVAL_U32(TX_BYTES, tx_bytes);\n\tPUT_TXQVAL_U32(TX_PACKETS, tx_packets);\n\tPUT_TXQVAL_U32(MAX_FLOWS, max_flows);\n\tnla_nest_end(msg, txqattr);\n\n#undef PUT_TXQVAL_U32\n\treturn true;\n}\n\n/* netlink command implementations */\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt, defbeacon;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct genl_info *info, struct nlattr *key,\n\t\t\t\t struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested_deprecated(tb, NL80211_KEY_MAX, key,\n\t\t\t\t\t      nl80211_key_policy,\n\t\t\t\t\t      info->extack);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tk->defbeacon = !!tb[NL80211_KEY_DEFAULT_BEACON];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt || k->defbeacon)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE])\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\n\t\terr = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t  NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t  tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t  nl80211_key_default_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\tif (tb[NL80211_KEY_MODE])\n\t\tk->p.mode = nla_get_u8(tb[NL80211_KEY_MODE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE])\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t      NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t      info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t      nl80211_key_default_policy,\n\t\t\t\t\t\t      info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info, info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif ((k->def ? 1 : 0) + (k->defmgmt ? 1 : 0) +\n\t    (k->defbeacon ? 1 : 0) > 1) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"key with multiple default flags is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (k->defmgmt || k->defbeacon) {\n\t\tif (k->def_uni || !k->def_multi) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"defmgmt/defbeacon key must be mcast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defmgmt key idx not 4 or 5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->defbeacon) {\n\t\t\tif (k->idx < 6 || k->idx > 7) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defbeacon key idx not 6 or 7\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"def key idx not 0-3\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 7) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"key idx not 0-7\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct genl_info *info, bool *no_ht)\n{\n\tstruct nlattr *keys = info->attrs[NL80211_ATTR_KEYS];\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\tbool have_key = false;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\thave_key = true;\n\t\tbreak;\n\t}\n\n\tif (!have_key)\n\t\treturn NULL;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(info, key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 3) {\n\t\t\tGENL_SET_ERR_MSG(info, \"key index out of range [0-3]\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (parse.def) {\n\t\t\tif (def) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"only one key can be default\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (parse.p.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t    parse.p.cipher != WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tGENL_SET_ERR_MSG(info, \"connect key must be WEP\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\n\t\t/* must be WEP key if we got here */\n\t\tif (no_ht)\n\t\t\t*no_ht = true;\n\t}\n\n\tif (result->def < 0) {\n\t\terr = -EINVAL;\n\t\tGENL_SET_ERR_MSG(info, \"need a default/TX key\");\n\t\tgoto error;\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (!wdev->current_bss)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_channel *nl80211_get_valid_chan(struct wiphy *wiphy,\n\t\t\t\t\t\t\tu32 freq)\n{\n\tstruct ieee80211_channel *chan;\n\n\tchan = ieee80211_get_channel_khz(wiphy, freq);\n\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn NULL;\n\treturn chan;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start_noflag(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg,\n\t\t\t\t\t  bool large)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t\tc->limits[j].max))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match &&\n\t\t    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t\tc->num_different_channels) ||\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t\tc->max_interfaces))\n\t\t\tgoto nla_put_failure;\n\t\tif (large &&\n\t\t    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,\n\t\t\t\tc->radar_detect_widths) ||\n\t\t     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,\n\t\t\t\tc->radar_detect_regions)))\n\t\t\tgoto nla_put_failure;\n\t\tif (c->beacon_int_min_gcd &&\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,\n\t\t\t\tc->beacon_int_min_gcd))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tconst struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan->tcp;\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->seq && nla_put_flag(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->tok && nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t\t\tsizeof(*tcp->tok), tcp->tok))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t\ttcp->wake_payload_max))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan(struct sk_buff *msg,\n\t\t\t       struct cfg80211_registered_device *rdev,\n\t\t\t       bool large)\n{\n\tstruct nlattr *nl_wowlan;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn 0;\n\n\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\tif (!nl_wowlan)\n\t\treturn -ENOBUFS;\n\n\tif (((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_ANY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_DISCONNECT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\treturn -ENOBUFS;\n\n\tif (rdev->wiphy.wowlan->n_patterns) {\n\t\tstruct nl80211_pattern_support pat = {\n\t\t\t.max_patterns = rdev->wiphy.wowlan->n_patterns,\n\t\t\t.min_pattern_len = rdev->wiphy.wowlan->pattern_min_len,\n\t\t\t.max_pattern_len = rdev->wiphy.wowlan->pattern_max_len,\n\t\t\t.max_pkt_offset = rdev->wiphy.wowlan->max_pkt_offset,\n\t\t};\n\n\t\tif (nla_put(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t    sizeof(pat), &pat))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_NET_DETECT) &&\n\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_NET_DETECT,\n\t\t\trdev->wiphy.wowlan->max_nd_match_sets))\n\t\treturn -ENOBUFS;\n\n\tif (large && nl80211_send_wowlan_tcp_caps(rdev, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_wowlan);\n\n\treturn 0;\n}\n#endif\n\nstatic int nl80211_send_coalesce(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev)\n{\n\tstruct nl80211_coalesce_rule_support rule;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn 0;\n\n\trule.max_rules = rdev->wiphy.coalesce->n_rules;\n\trule.max_delay = rdev->wiphy.coalesce->max_delay;\n\trule.pat.max_patterns = rdev->wiphy.coalesce->n_patterns;\n\trule.pat.min_pattern_len = rdev->wiphy.coalesce->pattern_min_len;\n\trule.pat.max_pattern_len = rdev->wiphy.coalesce->pattern_max_len;\n\trule.pat.max_pkt_offset = rdev->wiphy.coalesce->max_pkt_offset;\n\n\tif (nla_put(msg, NL80211_ATTR_COALESCE_RULE, sizeof(rule), &rule))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_iftype_data(struct sk_buff *msg,\n\t\t\t const struct ieee80211_supported_band *sband,\n\t\t\t const struct ieee80211_sband_iftype_data *iftdata)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap = &iftdata->he_cap;\n\n\tif (nl80211_put_iftypes(msg, NL80211_BAND_IFTYPE_ATTR_IFTYPES,\n\t\t\t\tiftdata->types_mask))\n\t\treturn -ENOBUFS;\n\n\tif (he_cap->has_he) {\n\t\tif (nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC,\n\t\t\t    sizeof(he_cap->he_cap_elem.mac_cap_info),\n\t\t\t    he_cap->he_cap_elem.mac_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,\n\t\t\t    sizeof(he_cap->he_cap_elem.phy_cap_info),\n\t\t\t    he_cap->he_cap_elem.phy_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,\n\t\t\t    sizeof(he_cap->he_mcs_nss_supp),\n\t\t\t    &he_cap->he_mcs_nss_supp) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,\n\t\t\t    sizeof(he_cap->ppe_thres), he_cap->ppe_thres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif (sband->band == NL80211_BAND_6GHZ &&\n\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA,\n\t\t    sizeof(iftdata->he_6ghz_capa),\n\t\t    &iftdata->he_6ghz_capa))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int nl80211_send_band_rateinfo(struct sk_buff *msg,\n\t\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t\t      bool large)\n{\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\n\t/* add HT info */\n\tif (sband->ht_cap.ht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t     sizeof(sband->ht_cap.mcs),\n\t\t     &sband->ht_cap.mcs) ||\n\t     nla_put_u16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t sband->ht_cap.cap) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\tsband->ht_cap.ampdu_factor) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\tsband->ht_cap.ampdu_density)))\n\t\treturn -ENOBUFS;\n\n\t/* add VHT info */\n\tif (sband->vht_cap.vht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_VHT_MCS_SET,\n\t\t     sizeof(sband->vht_cap.vht_mcs),\n\t\t     &sband->vht_cap.vht_mcs) ||\n\t     nla_put_u32(msg, NL80211_BAND_ATTR_VHT_CAPA,\n\t\t\t sband->vht_cap.cap)))\n\t\treturn -ENOBUFS;\n\n\tif (large && sband->n_iftype_data) {\n\t\tstruct nlattr *nl_iftype_data =\n\t\t\tnla_nest_start_noflag(msg,\n\t\t\t\t\t      NL80211_BAND_ATTR_IFTYPE_DATA);\n\t\tint err;\n\n\t\tif (!nl_iftype_data)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tstruct nlattr *iftdata;\n\n\t\t\tiftdata = nla_nest_start_noflag(msg, i + 1);\n\t\t\tif (!iftdata)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\terr = nl80211_send_iftype_data(msg, sband,\n\t\t\t\t\t\t       &sband->iftype_data[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_nest_end(msg, iftdata);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_iftype_data);\n\t}\n\n\t/* add EDMG info */\n\tif (large && sband->edmg_cap.channels &&\n\t    (nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_CHANNELS,\n\t\t       sband->edmg_cap.channels) ||\n\t    nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_BW_CONFIG,\n\t\t       sband->edmg_cap.bw_config)))\n\n\t\treturn -ENOBUFS;\n\n\t/* add bitrates */\n\tnl_rates = nla_nest_start_noflag(msg, NL80211_BAND_ATTR_RATES);\n\tif (!nl_rates)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tnl_rate = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_rate)\n\t\t\treturn -ENOBUFS;\n\n\t\trate = &sband->bitrates[i];\n\t\tif (nla_put_u32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\trate->bitrate))\n\t\t\treturn -ENOBUFS;\n\t\tif ((rate->flags & IEEE80211_RATE_SHORT_PREAMBLE) &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE))\n\t\t\treturn -ENOBUFS;\n\n\t\tnla_nest_end(msg, nl_rate);\n\t}\n\n\tnla_nest_end(msg, nl_rates);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_mgmt_stypes(struct sk_buff *msg,\n\t\t\t const struct ieee80211_txrx_stypes *mgmt_stypes)\n{\n\tu16 stypes;\n\tstruct nlattr *nl_ftypes, *nl_ifs;\n\tenum nl80211_iftype ift;\n\tint i;\n\n\tif (!mgmt_stypes)\n\t\treturn 0;\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].tx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\n\tnla_nest_end(msg, nl_ifs);\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].rx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\tnla_nest_end(msg, nl_ifs);\n\n\treturn 0;\n}\n\n#define CMD(op, n)\t\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\t\\\n\t\tif (rdev->ops->op) {\t\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\t\\\n\t\t\tif (nla_put_u32(msg, i, NL80211_CMD_ ## n)) \t\\\n\t\t\t\tgoto nla_put_failure;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int nl80211_add_commands_unsplit(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tint i = 0;\n\n\t/*\n\t * do *NOT* add anything into this function, new things need to be\n\t * advertised only to new versions of userspace that can deal with\n\t * the split (and they can't possibly care about new features...\n\t */\n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(start_ap, START_AP);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)\n\t\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_WIPHY_NETNS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->ops->set_monitor_channel || rdev->ops->start_ap ||\n\t    rdev->ops->join_mesh) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_CHANNEL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\tCMD(tdls_mgmt, TDLS_MGMT);\n\t\tCMD(tdls_oper, TDLS_OPER);\n\t}\n\tif (rdev->wiphy.max_sched_scan_reqs)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\tCMD(probe_client, PROBE_CLIENT);\n\tCMD(set_noack_map, SET_NOACK_MAP);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_REGISTER_BEACONS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(start_p2p_device, START_P2P_DEVICE);\n\tCMD(set_mcast_rate, SET_MCAST_RATE);\n#ifdef CONFIG_NL80211_TESTMODE\n\tCMD(testmode_cmd, TESTMODE);\n#endif\n\n\tif (rdev->ops->connect || rdev->ops->auth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_CONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->ops->disconnect || rdev->ops->deauth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_DISCONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn i;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_send_pmsr_ftm_capa(const struct cfg80211_pmsr_capabilities *cap,\n\t\t\t   struct sk_buff *msg)\n{\n\tstruct nlattr *ftm;\n\n\tif (!cap->ftm.supported)\n\t\treturn 0;\n\n\tftm = nla_nest_start_noflag(msg, NL80211_PMSR_TYPE_FTM);\n\tif (!ftm)\n\t\treturn -ENOBUFS;\n\n\tif (cap->ftm.asap && nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_asap &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_lci &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_civicloc &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,\n\t\t\tcap->ftm.preambles))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,\n\t\t\tcap->ftm.bandwidths))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_bursts_exponent >= 0 &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,\n\t\t\tcap->ftm.max_bursts_exponent))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_ftms_per_burst &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,\n\t\t\tcap->ftm.max_ftms_per_burst))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, ftm);\n\treturn 0;\n}\n\nstatic int nl80211_send_pmsr_capa(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct sk_buff *msg)\n{\n\tconst struct cfg80211_pmsr_capabilities *cap = rdev->wiphy.pmsr_capa;\n\tstruct nlattr *pmsr, *caps;\n\n\tif (!cap)\n\t\treturn 0;\n\n\t/*\n\t * we don't need to clean up anything here since the caller\n\t * will genlmsg_cancel() if we fail\n\t */\n\n\tpmsr = nla_nest_start_noflag(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_ATTR_MAX_PEERS, cap->max_peers))\n\t\treturn -ENOBUFS;\n\n\tif (cap->report_ap_tsf &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_REPORT_AP_TSF))\n\t\treturn -ENOBUFS;\n\n\tif (cap->randomize_mac_addr &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR))\n\t\treturn -ENOBUFS;\n\n\tcaps = nla_nest_start_noflag(msg, NL80211_PMSR_ATTR_TYPE_CAPA);\n\tif (!caps)\n\t\treturn -ENOBUFS;\n\n\tif (nl80211_send_pmsr_ftm_capa(cap, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, caps);\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_put_iftype_akm_suites(struct cfg80211_registered_device *rdev,\n\t\t\t      struct sk_buff *msg)\n{\n\tint i;\n\tstruct nlattr *nested, *nested_akms;\n\tconst struct wiphy_iftype_akm_suites *iftype_akms;\n\n\tif (!rdev->wiphy.num_iftype_akm_suites ||\n\t    !rdev->wiphy.iftype_akm_suites)\n\t\treturn 0;\n\n\tnested = nla_nest_start(msg, NL80211_ATTR_IFTYPE_AKM_SUITES);\n\tif (!nested)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->wiphy.num_iftype_akm_suites; i++) {\n\t\tnested_akms = nla_nest_start(msg, i + 1);\n\t\tif (!nested_akms)\n\t\t\treturn -ENOBUFS;\n\n\t\tiftype_akms = &rdev->wiphy.iftype_akm_suites[i];\n\n\t\tif (nl80211_put_iftypes(msg, NL80211_IFTYPE_AKM_ATTR_IFTYPES,\n\t\t\t\t\tiftype_akms->iftypes_mask))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put(msg, NL80211_IFTYPE_AKM_ATTR_SUITES,\n\t\t\t    sizeof(u32) * iftype_akms->n_akm_suites,\n\t\t\t    iftype_akms->akm_suites)) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tnla_nest_end(msg, nested_akms);\n\t}\n\n\tnla_nest_end(msg, nested);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_put_tid_config_support(struct cfg80211_registered_device *rdev,\n\t\t\t       struct sk_buff *msg)\n{\n\tstruct nlattr *supp;\n\n\tif (!rdev->wiphy.tid_config_support.vif &&\n\t    !rdev->wiphy.tid_config_support.peer)\n\t\treturn 0;\n\n\tsupp = nla_nest_start(msg, NL80211_ATTR_TID_CONFIG);\n\tif (!supp)\n\t\treturn -ENOSPC;\n\n\tif (rdev->wiphy.tid_config_support.vif &&\n\t    nla_put_u64_64bit(msg, NL80211_TID_CONFIG_ATTR_VIF_SUPP,\n\t\t\t      rdev->wiphy.tid_config_support.vif,\n\t\t\t      NL80211_TID_CONFIG_ATTR_PAD))\n\t\tgoto fail;\n\n\tif (rdev->wiphy.tid_config_support.peer &&\n\t    nla_put_u64_64bit(msg, NL80211_TID_CONFIG_ATTR_PEER_SUPP,\n\t\t\t      rdev->wiphy.tid_config_support.peer,\n\t\t\t      NL80211_TID_CONFIG_ATTR_PAD))\n\t\tgoto fail;\n\n\t/* for now we just use the same value ... makes more sense */\n\tif (nla_put_u8(msg, NL80211_TID_CONFIG_ATTR_RETRY_SHORT,\n\t\t       rdev->wiphy.tid_config_support.max_retry))\n\t\tgoto fail;\n\tif (nla_put_u8(msg, NL80211_TID_CONFIG_ATTR_RETRY_LONG,\n\t\t       rdev->wiphy.tid_config_support.max_retry))\n\t\tgoto fail;\n\n\tnla_nest_end(msg, supp);\n\n\treturn 0;\nfail:\n\tnla_nest_cancel(msg, supp);\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_put_sar_specs(struct cfg80211_registered_device *rdev,\n\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *sar_capa, *specs, *sub_freq_range;\n\tu8 num_freq_ranges;\n\tint i;\n\n\tif (!rdev->wiphy.sar_capa)\n\t\treturn 0;\n\n\tnum_freq_ranges = rdev->wiphy.sar_capa->num_freq_ranges;\n\n\tsar_capa = nla_nest_start(msg, NL80211_ATTR_SAR_SPEC);\n\tif (!sar_capa)\n\t\treturn -ENOSPC;\n\n\tif (nla_put_u32(msg, NL80211_SAR_ATTR_TYPE, rdev->wiphy.sar_capa->type))\n\t\tgoto fail;\n\n\tspecs = nla_nest_start(msg, NL80211_SAR_ATTR_SPECS);\n\tif (!specs)\n\t\tgoto fail;\n\n\t/* report supported freq_ranges */\n\tfor (i = 0; i < num_freq_ranges; i++) {\n\t\tsub_freq_range = nla_nest_start(msg, i + 1);\n\t\tif (!sub_freq_range)\n\t\t\tgoto fail;\n\n\t\tif (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_START_FREQ,\n\t\t\t\trdev->wiphy.sar_capa->freq_ranges[i].start_freq))\n\t\t\tgoto fail;\n\n\t\tif (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_END_FREQ,\n\t\t\t\trdev->wiphy.sar_capa->freq_ranges[i].end_freq))\n\t\t\tgoto fail;\n\n\t\tnla_nest_end(msg, sub_freq_range);\n\t}\n\n\tnla_nest_end(msg, specs);\n\tnla_nest_end(msg, sar_capa);\n\n\treturn 0;\nfail:\n\tnla_nest_cancel(msg, sar_capa);\n\treturn -ENOBUFS;\n}\n\nstruct nl80211_dump_wiphy_state {\n\ts64 filter_wiphy;\n\tlong start;\n\tlong split_start, band_start, chan_start, capa_start;\n\tbool split;\n};\n\nstatic int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t      enum nl80211_commands cmd,\n\t\t\t      struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t      int flags, struct nl80211_dump_wiphy_state *state)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_cmds;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\trdev->wiphy.mgmt_stypes;\n\tu32 features;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (WARN_ON(!state))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_string(msg, NL80211_ATTR_WIPHY_NAME,\n\t\t\t   wiphy_name(&rdev->wiphy)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\tcfg80211_rdev_list_generation))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != NL80211_CMD_NEW_WIPHY)\n\t\tgoto finish;\n\n\tswitch (state->split_start) {\n\tcase 0:\n\t\tif (nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t\t       rdev->wiphy.retry_short) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t\t       rdev->wiphy.retry_long) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t\t\trdev->wiphy.frag_threshold) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t\t\trdev->wiphy.rts_threshold) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t\t       rdev->wiphy.coverage_class) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_scan_ssids) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_sched_scan_ssids) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_scan_ie_len) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_sched_scan_ie_len) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_MATCH_SETS,\n\t\t\t       rdev->wiphy.max_match_sets))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_IBSS_RSN))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_MESH_AUTH))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_AP_UAPSD))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_ROAM_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_cipher_suites,\n\t\t\t    rdev->wiphy.cipher_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t\t       rdev->wiphy.max_num_pmkids))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t\t\trdev->wiphy.available_antennas_tx) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t\t\trdev->wiphy.available_antennas_rx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_PROBE_RESP_OFFLOAD,\n\t\t\t\trdev->wiphy.probe_resp_offload))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.available_antennas_tx ||\n\t\t     rdev->wiphy.available_antennas_rx) &&\n\t\t    rdev->ops->get_antenna) {\n\t\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\t\tint res;\n\n\t\t\tres = rdev_get_antenna(rdev, &tx_ant, &rx_ant);\n\t\t\tif (!res) {\n\t\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_TX,\n\t\t\t\t\t\ttx_ant) ||\n\t\t\t\t    nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_RX,\n\t\t\t\t\t\trx_ant))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 2:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\t\trdev->wiphy.interface_modes))\n\t\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 3:\n\t\tnl_bands = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_ATTR_WIPHY_BANDS);\n\t\tif (!nl_bands)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (band = state->band_start;\n\t\t     band < NUM_NL80211_BANDS; band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\n\t\t\t/* omit higher bands for ancient software */\n\t\t\tif (band > NL80211_BAND_5GHZ && !state->split)\n\t\t\t\tbreak;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tnl_band = nla_nest_start_noflag(msg, band);\n\t\t\tif (!nl_band)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tswitch (state->chan_start) {\n\t\t\tcase 0:\n\t\t\t\tif (nl80211_send_band_rateinfo(msg, sband,\n\t\t\t\t\t\t\t       state->split))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tstate->chan_start++;\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t/* add frequencies */\n\t\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t NL80211_BAND_ATTR_FREQS);\n\t\t\t\tif (!nl_freqs)\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tfor (i = state->chan_start - 1;\n\t\t\t\t     i < sband->n_channels;\n\t\t\t\t     i++) {\n\t\t\t\t\tnl_freq = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\ti);\n\t\t\t\t\tif (!nl_freq)\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tchan = &sband->channels[i];\n\n\t\t\t\t\tif (nl80211_msg_put_channel(\n\t\t\t\t\t\t\tmsg, &rdev->wiphy, chan,\n\t\t\t\t\t\t\tstate->split))\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tnla_nest_end(msg, nl_freq);\n\t\t\t\t\tif (state->split)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < sband->n_channels)\n\t\t\t\t\tstate->chan_start = i + 2;\n\t\t\t\telse\n\t\t\t\t\tstate->chan_start = 0;\n\t\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_band);\n\n\t\t\tif (state->split) {\n\t\t\t\t/* start again here */\n\t\t\t\tif (state->chan_start)\n\t\t\t\t\tband--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(msg, nl_bands);\n\n\t\tif (band < NUM_NL80211_BANDS)\n\t\t\tstate->band_start = band + 1;\n\t\telse\n\t\t\tstate->band_start = 0;\n\n\t\t/* if bands & channels are done, continue outside */\n\t\tif (state->band_start == 0 && state->chan_start == 0)\n\t\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 4:\n\t\tnl_cmds = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SUPPORTED_COMMANDS);\n\t\tif (!nl_cmds)\n\t\t\tgoto nla_put_failure;\n\n\t\ti = nl80211_add_commands_unsplit(rdev, msg);\n\t\tif (i < 0)\n\t\t\tgoto nla_put_failure;\n\t\tif (state->split) {\n\t\t\tCMD(crit_proto_start, CRIT_PROTOCOL_START);\n\t\t\tCMD(crit_proto_stop, CRIT_PROTOCOL_STOP);\n\t\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH)\n\t\t\t\tCMD(channel_switch, CHANNEL_SWITCH);\n\t\t\tCMD(set_qos_map, SET_QOS_MAP);\n\t\t\tif (rdev->wiphy.features &\n\t\t\t\t\tNL80211_FEATURE_SUPPORTS_WMM_ADMISSION)\n\t\t\t\tCMD(add_tx_ts, ADD_TX_TS);\n\t\t\tCMD(set_multicast_to_unicast, SET_MULTICAST_TO_UNICAST);\n\t\t\tCMD(update_connect_params, UPDATE_CONNECT_PARAMS);\n\t\t\tCMD(update_ft_ies, UPDATE_FT_IES);\n\t\t\tif (rdev->wiphy.sar_capa)\n\t\t\t\tCMD(set_sar_specs, SET_SAR_SPECS);\n\t\t}\n#undef CMD\n\n\t\tnla_nest_end(msg, nl_cmds);\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 5:\n\t\tif (rdev->ops->remain_on_channel &&\n\t\t    (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&\n\t\t    nla_put_u32(msg,\n\t\t\t\tNL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t\trdev->wiphy.max_remain_on_channel_duration))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_OFFCHANNEL_TX_OK))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 6:\n#ifdef CONFIG_PM\n\t\tif (nl80211_send_wowlan(msg, rdev, state->split))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n#else\n\t\tstate->split_start++;\n#endif\n\t\tfallthrough;\n\tcase 7:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\t\trdev->wiphy.software_iftypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iface_combinations(&rdev->wiphy, msg,\n\t\t\t\t\t\t   state->split))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 8:\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,\n\t\t\t\trdev->wiphy.ap_sme_capa))\n\t\t\tgoto nla_put_failure;\n\n\t\tfeatures = rdev->wiphy.features;\n\t\t/*\n\t\t * We can only add the per-channel limit information if the\n\t\t * dump is split, otherwise it makes it too big. Therefore\n\t\t * only advertise it in that case.\n\t\t */\n\t\tif (state->split)\n\t\t\tfeatures |= NL80211_FEATURE_ADVERTISE_CHAN_LIMITS;\n\t\tif (nla_put_u32(msg, NL80211_ATTR_FEATURE_FLAGS, features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.ht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_HT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.ht_capa_mod_mask),\n\t\t\t    rdev->wiphy.ht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&\n\t\t    rdev->wiphy.max_acl_mac_addrs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAC_ACL_MAX,\n\t\t\t\trdev->wiphy.max_acl_mac_addrs))\n\t\t\tgoto nla_put_failure;\n\n\t\t/*\n\t\t * Any information below this point is only available to\n\t\t * applications that can deal with it being split. This\n\t\t * helps ensure that newly added capabilities don't break\n\t\t * older tools by overrunning their buffers.\n\t\t *\n\t\t * We still increment split_start so that in the split\n\t\t * case we'll continue with more data in the next round,\n\t\t * but break unconditionally so unsplit data stops here.\n\t\t */\n\t\tif (state->split)\n\t\t\tstate->split_start++;\n\t\telse\n\t\t\tstate->split_start = 0;\n\t\tbreak;\n\tcase 9:\n\t\tif (nl80211_send_mgmt_stypes(msg, mgmt_stypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,\n\t\t\t\trdev->wiphy.max_sched_scan_plans) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_interval) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_iterations))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.extended_capabilities &&\n\t\t    (nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities) ||\n\t\t     nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities_mask)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.vht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_VHT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.vht_capa_mod_mask),\n\t\t\t    rdev->wiphy.vht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t    rdev->wiphy.perm_addr))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(rdev->wiphy.addr_mask) &&\n\t\t    nla_put(msg, NL80211_ATTR_MAC_MASK, ETH_ALEN,\n\t\t\t    rdev->wiphy.addr_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.n_addresses > 1) {\n\t\t\tvoid *attr;\n\n\t\t\tattr = nla_nest_start(msg, NL80211_ATTR_MAC_ADDRS);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_addresses; i++)\n\t\t\t\tif (nla_put(msg, i + 1, ETH_ALEN,\n\t\t\t\t\t    rdev->wiphy.addresses[i].addr))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, attr);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 10:\n\t\tif (nl80211_send_coalesce(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ) &&\n\t\t    (nla_put_flag(msg, NL80211_ATTR_SUPPORT_5_MHZ) ||\n\t\t     nla_put_flag(msg, NL80211_ATTR_SUPPORT_10_MHZ)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_ap_assoc_sta &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_AP_ASSOC_STA,\n\t\t\t\trdev->wiphy.max_ap_assoc_sta))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 11:\n\t\tif (rdev->wiphy.n_vendor_commands) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_DATA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_commands[i].info;\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tif (rdev->wiphy.n_vendor_events) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_EVENTS);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_events; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_events[i];\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 12:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH &&\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_CSA_COUNTERS,\n\t\t\t       rdev->wiphy.max_num_csa_counters))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_sched_scan_reqs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_MAX_REQS,\n\t\t\t\trdev->wiphy.max_sched_scan_reqs))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_EXT_FEATURES,\n\t\t\t    sizeof(rdev->wiphy.ext_features),\n\t\t\t    rdev->wiphy.ext_features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.bss_select_support) {\n\t\t\tstruct nlattr *nested;\n\t\t\tu32 bss_select_support = rdev->wiphy.bss_select_support;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_BSS_SELECT);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\ti = 0;\n\t\t\twhile (bss_select_support) {\n\t\t\t\tif ((bss_select_support & 1) &&\n\t\t\t\t    nla_put_flag(msg, i))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\ti++;\n\t\t\t\tbss_select_support >>= 1;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 13:\n\t\tif (rdev->wiphy.num_iftype_ext_capab &&\n\t\t    rdev->wiphy.iftype_ext_capab) {\n\t\t\tstruct nlattr *nested_ext_capab, *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_IFTYPE_EXT_CAPA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = state->capa_start;\n\t\t\t     i < rdev->wiphy.num_iftype_ext_capab; i++) {\n\t\t\t\tconst struct wiphy_iftype_ext_capab *capab;\n\n\t\t\t\tcapab = &rdev->wiphy.iftype_ext_capab[i];\n\n\t\t\t\tnested_ext_capab = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\t i);\n\t\t\t\tif (!nested_ext_capab ||\n\t\t\t\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE,\n\t\t\t\t\t\tcapab->iftype) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tnla_nest_end(msg, nested_ext_capab);\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t\tif (i < rdev->wiphy.num_iftype_ext_capab) {\n\t\t\t\tstate->capa_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_BANDS,\n\t\t\t\trdev->wiphy.nan_supported_bands))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\t\tint res;\n\n\t\t\tres = rdev_get_txq_stats(rdev, NULL, &txqstats);\n\t\t\tif (!res &&\n\t\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_MEMORY_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_memory_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_QUANTUM,\n\t\t\t\t\trdev->wiphy.txq_quantum))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 14:\n\t\tif (nl80211_send_pmsr_capa(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 15:\n\t\tif (rdev->wiphy.akm_suites &&\n\t\t    nla_put(msg, NL80211_ATTR_AKM_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_akm_suites,\n\t\t\t    rdev->wiphy.akm_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iftype_akm_suites(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_tid_config_support(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 16:\n\t\tif (nl80211_put_sar_specs(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\t/* done */\n\t\tstate->split_start = 0;\n\t\tbreak;\n\t}\n finish:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy_parse(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    struct nl80211_dump_wiphy_state *state)\n{\n\tstruct nlattr **tb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tint ret;\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     tb, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\t/* ignore parse errors for backward compatibility */\n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tstate->split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];\n\tif (tb[NL80211_ATTR_WIPHY])\n\t\tstate->filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);\n\tif (tb[NL80211_ATTR_WDEV])\n\t\tstate->filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;\n\tif (tb[NL80211_ATTR_IFINDEX]) {\n\t\tstruct net_device *netdev;\n\t\tstruct cfg80211_registered_device *rdev;\n\t\tint ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\t\tif (!netdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_rdev(\n\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\tstate->filter_wiphy = rdev->wiphy_idx;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tkfree(tb);\n\treturn ret;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, ret;\n\tstruct nl80211_dump_wiphy_state *state = (void *)cb->args[0];\n\tstruct cfg80211_registered_device *rdev;\n\n\trtnl_lock();\n\tif (!state) {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstate->filter_wiphy = -1;\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, state);\n\t\tif (ret) {\n\t\t\tkfree(state);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\tcb->args[0] = (long)state;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= state->start)\n\t\t\tcontinue;\n\t\tif (state->filter_wiphy != -1 &&\n\t\t    state->filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\t\t/* attempt to fit multiple wiphy data chunks into the skb */\n\t\tdo {\n\t\t\tret = nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI, state);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * If sending the wiphy data didn't fit (ENOBUFS\n\t\t\t\t * or EMSGSIZE returned), this SKB is still\n\t\t\t\t * empty (so it's not too big because another\n\t\t\t\t * wiphy dataset is already in the skb) and\n\t\t\t\t * we've not tried to adjust the dump allocation\n\t\t\t\t * yet ... then adjust the alloc size to be\n\t\t\t\t * bigger, and return 1 but with the empty skb.\n\t\t\t\t * This results in an empty message being RX'ed\n\t\t\t\t * in userspace, but that is ignored.\n\t\t\t\t *\n\t\t\t\t * We can then retry with the larger buffer.\n\t\t\t\t */\n\t\t\t\tif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\n\t\t\t\t    !skb->len && !state->split &&\n\t\t\t\t    cb->min_dump_alloc < 4096) {\n\t\t\t\t\tcb->min_dump_alloc = 4096;\n\t\t\t\t\tstate->split_start = 0;\n\t\t\t\t\trtnl_unlock();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tidx--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (state->split_start > 0);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tstate->start = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_dump_wiphy_done(struct netlink_callback *cb)\n{\n\tkfree((void *)cb->args[0]);\n\treturn 0;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tmsg = nlmsg_new(4096, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY, msg,\n\t\t\t       info->snd_portid, info->snd_seq, 0,\n\t\t\t       &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tu8 ac;\n\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\tac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\tif (ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\ttxq_params->ac = array_index_nospec(ac, NL80211_NUM_ACS);\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t/*\n\t * You can only set the channel explicitly for some interfaces,\n\t * most have their channel managed via their respective\n\t * \"establish a connection\" command (connect, join, ...)\n\t *\n\t * For AP/GO and mesh mode, the channel can be set with the\n\t * channel userspace API, but is only stored and passed to the\n\t * low-level driver when the AP starts or the mesh is joined.\n\t * This is for backward compatibility, userspace can also give\n\t * the channel in the start-ap or join-mesh commands instead.\n\t *\n\t * Monitors are special as they are normally slaved to\n\t * whatever else is going on, so they have their own special\n\t * operation to set the monitor channel if possible.\n\t */\n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nint nl80211_parse_chandef(struct cfg80211_registered_device *rdev,\n\t\t\t  struct genl_info *info,\n\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nlattr **attrs = info->attrs;\n\tu32 control_freq;\n\n\tif (!attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tcontrol_freq = MHZ_TO_KHZ(\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tcontrol_freq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tmemset(chandef, 0, sizeof(*chandef));\n\tchandef->chan = ieee80211_get_channel_khz(&rdev->wiphy, control_freq);\n\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\tchandef->center_freq1 = KHZ_TO_MHZ(control_freq);\n\tchandef->freq1_offset = control_freq % 1000;\n\tchandef->center_freq2 = 0;\n\n\t/* Primary channel not allowed */\n\tif (!chandef->chan || chandef->chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attrs[NL80211_ATTR_WIPHY_FREQ],\n\t\t\t\t    \"Channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tenum nl80211_channel_type chantype;\n\n\t\tchantype = nla_get_u32(attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\n\t\tswitch (chantype) {\n\t\tcase NL80211_CHAN_NO_HT:\n\t\tcase NL80211_CHAN_HT20:\n\t\tcase NL80211_CHAN_HT40PLUS:\n\t\tcase NL80211_CHAN_HT40MINUS:\n\t\t\tcfg80211_chandef_create(chandef, chandef->chan,\n\t\t\t\t\t\tchantype);\n\t\t\t/* user input for center_freq is incorrect */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1] &&\n\t\t\t    chandef->center_freq1 != nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ1],\n\t\t\t\t\t\t    \"bad center frequency 1\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* center_freq2 must be zero */\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2] &&\n\t\t\t    nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ2],\n\t\t\t\t\t\t    \"center frequency 2 can't be used\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE],\n\t\t\t\t\t    \"invalid channel type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (attrs[NL80211_ATTR_CHANNEL_WIDTH]) {\n\t\tchandef->width =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_CHANNEL_WIDTH]);\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1]) {\n\t\t\tchandef->center_freq1 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1]);\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1_OFFSET])\n\t\t\t\tchandef->freq1_offset = nla_get_u32(\n\t\t\t\t      attrs[NL80211_ATTR_CENTER_FREQ1_OFFSET]);\n\t\t\telse\n\t\t\t\tchandef->freq1_offset = 0;\n\t\t}\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2])\n\t\t\tchandef->center_freq2 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tchandef->edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tchandef->edmg.bw_config =\n\t\t     nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t} else {\n\t\tchandef->edmg.bw_config = 0;\n\t\tchandef->edmg.channels = 0;\n\t}\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid channel definition\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg80211_chandef_usable(&rdev->wiphy, chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED)) {\n\t\tNL_SET_ERR_MSG(extack, \"(extension) channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_5 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_10) &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ)) {\n\t\tNL_SET_ERR_MSG(extack, \"5/10 MHz not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_chan_def chandef;\n\tint result;\n\tenum nl80211_iftype iftype = NL80211_IFTYPE_MONITOR;\n\tstruct wireless_dev *wdev = NULL;\n\n\tif (dev)\n\t\twdev = dev->ieee80211_ptr;\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\tif (wdev)\n\t\tiftype = wdev->iftype;\n\n\tresult = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (result)\n\t\treturn result;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t\t   iftype)) {\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (wdev->beacon_interval) {\n\t\t\tif (!dev || !rdev->ops->set_ap_chanwidth ||\n\t\t\t    !(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE)) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Only allow dynamic channel width changes */\n\t\t\tif (chandef.chan != wdev->preset_chandef.chan) {\n\t\t\t\tresult = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = rdev_set_ap_chanwidth(rdev, dev, &chandef);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t\twdev->preset_chandef = chandef;\n\t\tresult = 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tresult = cfg80211_set_mesh_channel(rdev, wdev, &chandef);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tresult = cfg80211_set_monitor_channel(rdev, &chandef);\n\t\tbreak;\n\tdefault:\n\t\tresult = -EINVAL;\n\t}\n\n\treturn result;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *netdev = info->user_ptr[1];\n\n\treturn __nl80211_set_channel(rdev, netdev, info);\n}\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = NULL;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\tu32 txq_limit = 0, txq_memory_limit = 0, txq_quantum = 0;\n\n\trtnl_lock();\n\t/*\n\t * Try to find the wiphy and netdev. Normally this\n\t * function shouldn't need the netdev, but this is\n\t * done for backward compatibility -- previously\n\t * setting the channel was done per wiphy, but now\n\t * it is per netdev. Previous userland like hostapd\n\t * also passed a netdev to set_wiphy, so that it is\n\t * possible to let that go to the right netdev!\n\t */\n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr)\n\t\t\trdev = wiphy_to_rdev(netdev->ieee80211_ptr->wiphy);\n\t\telse\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(rdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\t} else\n\t\twdev = netdev->ieee80211_ptr;\n\n\twiphy_lock(&rdev->wiphy);\n\n\t/*\n\t * end workaround code, by now the rdev is available\n\t * and locked, and wdev may or may not be NULL.\n\t */\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\trtnl_unlock();\n\n\tif (result)\n\t\tgoto out;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!netdev) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t\t    netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!netif_running(netdev)) {\n\t\t\tresult = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tresult = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t     NL80211_TXQ_ATTR_MAX,\n\t\t\t\t\t\t\t     nl_txq_params,\n\t\t\t\t\t\t\t     txq_params_policy,\n\t\t\t\t\t\t\t     info->extack);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\n\t\t\tresult = rdev_set_txq_params(rdev, netdev,\n\t\t\t\t\t\t     &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tresult = __nl80211_set_channel(\n\t\t\trdev,\n\t\t\tnl80211_can_set_dev_channel(wdev) ? netdev : NULL,\n\t\t\tinfo);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tstruct wireless_dev *txp_wdev = wdev;\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))\n\t\t\ttxp_wdev = NULL;\n\n\t\tif (!rdev->ops->set_tx_power) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev_set_tx_power(rdev, txp_wdev, type, mbm);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t/* reject antenna configurations which don't match the\n\t\t * available antenna masks, except for the \"all\" mask */\n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx))) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev_set_antenna(rdev, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t/*\n\t\t\t * Fragments (apart from the last one) are required to\n\t\t\t * have even length. Make the fragmentation code\n\t\t\t * simpler by stripping LSB should someone try to use\n\t\t\t * odd threshold value.\n\t\t\t */\n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_ACKTO_ESTIMATION)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tchanged |= WIPHY_PARAM_DYN_ACK;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_memory_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_MEMORY_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_QUANTUM]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_quantum = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_QUANTUM]);\n\t\tchanged |= WIPHY_PARAM_TXQ_QUANTUM;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\t\tu32 old_txq_limit, old_txq_memory_limit, old_txq_quantum;\n\n\t\tif (!rdev->ops->set_wiphy_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\t\told_txq_limit = rdev->wiphy.txq_limit;\n\t\told_txq_memory_limit = rdev->wiphy.txq_memory_limit;\n\t\told_txq_quantum = rdev->wiphy.txq_quantum;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\t\tif (changed & WIPHY_PARAM_TXQ_LIMIT)\n\t\t\trdev->wiphy.txq_limit = txq_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_MEMORY_LIMIT)\n\t\t\trdev->wiphy.txq_memory_limit = txq_memory_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_QUANTUM)\n\t\t\trdev->wiphy.txq_quantum = txq_quantum;\n\n\t\tresult = rdev_set_wiphy_params(rdev, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t\trdev->wiphy.txq_limit = old_txq_limit;\n\t\t\trdev->wiphy.txq_memory_limit = old_txq_memory_limit;\n\t\t\trdev->wiphy.txq_quantum = old_txq_quantum;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = 0;\n\nout:\n\twiphy_unlock(&rdev->wiphy);\n\treturn result;\n}\n\nstatic int nl80211_send_chandef(struct sk_buff *msg,\n\t\t\t\tconst struct cfg80211_chan_def *chandef)\n{\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\tchandef->chan->center_freq))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET,\n\t\t\tchandef->chan->freq_offset))\n\t\treturn -ENOBUFS;\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\t\tcfg80211_get_chandef_type(chandef)))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, chandef->width))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ1, chandef->center_freq1))\n\t\treturn -ENOBUFS;\n\tif (chandef->center_freq2 &&\n\t    nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ2, chandef->center_freq2))\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_commands cmd)\n{\n\tstruct net_device *dev = wdev->netdev;\n\tvoid *hdr;\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_INTERFACE &&\n\t\tcmd != NL80211_CMD_DEL_INTERFACE &&\n\t\tcmd != NL80211_CMD_SET_INTERFACE);\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (dev &&\n\t    (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t     nla_put_string(msg, NL80211_ATTR_IFNAME, dev->name)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE, wdev->iftype) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, wdev_address(wdev)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\trdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2)) ||\n\t    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr))\n\t\tgoto nla_put_failure;\n\n\tif (rdev->ops->get_channel) {\n\t\tint ret;\n\t\tstruct cfg80211_chan_def chandef = {};\n\n\t\tret = rdev_get_channel(rdev, wdev, &chandef);\n\t\tif (ret == 0) {\n\t\t\tif (nl80211_send_chandef(msg, &chandef))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (rdev->ops->get_tx_power) {\n\t\tint dbm, ret;\n\n\t\tret = rdev_get_tx_power(rdev, wdev, &dbm);\n\t\tif (ret == 0 &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL,\n\t\t\t\tDBM_TO_MBM(dbm)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (wdev->ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->ssid_len, wdev->ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_ADHOC: {\n\t\tconst u8 *ssid_ie;\n\t\tif (!wdev->current_bss)\n\t\t\tbreak;\n\t\trcu_read_lock();\n\t\tssid_ie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t       WLAN_EID_SSID);\n\t\tif (ssid_ie &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, ssid_ie[1], ssid_ie + 2))\n\t\t\tgoto nla_put_failure_rcu_locked;\n\t\trcu_read_unlock();\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\t/* nothing */\n\t\tbreak;\n\t}\n\twdev_unlock(wdev);\n\n\tif (rdev->ops->get_txq_stats) {\n\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\tint ret = rdev_get_txq_stats(rdev, wdev, &txqstats);\n\n\t\tif (ret == 0 &&\n\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure_rcu_locked:\n\trcu_read_unlock();\n nla_put_failure_locked:\n\twdev_unlock(wdev);\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tint filter_wiphy = -1;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint ret;\n\n\trtnl_lock();\n\tif (!cb->args[2]) {\n\t\tstruct nl80211_dump_wiphy_state state = {\n\t\t\t.filter_wiphy = -1,\n\t\t};\n\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, &state);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tfilter_wiphy = state.filter_wiphy;\n\n\t\t/*\n\t\t * if filtering, set cb->args[2] to +1 since 0 is the default\n\t\t * value needed to determine that parsing is necessary.\n\t\t */\n\t\tif (filter_wiphy >= 0)\n\t\t\tcb->args[2] = filter_wiphy + 1;\n\t\telse\n\t\t\tcb->args[2] = -1;\n\t} else if (cb->args[2] > 0) {\n\t\tfilter_wiphy = cb->args[2] - 1;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filter_wiphy >= 0 && filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\n\t\tif_idx = 0;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev,\n\t\t\t\t\t       NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\n\t\twp_idx++;\n\t}\n out:\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\tret = skb->len;\n out_unlock:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\t*mntrflags |= MONITOR_FLAG_CHANGED;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_mon_options(struct cfg80211_registered_device *rdev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct genl_info *info,\n\t\t\t\t     struct vif_params *params)\n{\n\tbool change = false;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &params->flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tchange = true;\n\t}\n\n\tif (params->flags & MONITOR_FLAG_ACTIVE &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]) {\n\t\tconst u8 *mumimo_groups;\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmumimo_groups =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]);\n\n\t\t/* bits 0 and 63 are reserved and must be zero */\n\t\tif ((mumimo_groups[0] & BIT(0)) ||\n\t\t    (mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN - 1] & BIT(7)))\n\t\t\treturn -EINVAL;\n\n\t\tparams->vht_mumimo_groups = mumimo_groups;\n\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]) {\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tparams->vht_mumimo_follow_addr =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]);\n\t\tchange = true;\n\t}\n\n\treturn change ? 1 : 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && netif_is_bridge_port(netdev))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\terr = nl80211_parse_mon_options(rdev, ntype, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchange = true;\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\tif (change && !err) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct wireless_dev *wdev;\n\tstruct sk_buff *msg;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\n\t/* to avoid failing a new interface creation due to pending removal */\n\tcfg80211_destroy_ifaces(rdev);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE])\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\n\tif (!rdev->ops->add_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||\n\t     rdev->wiphy.features & NL80211_FEATURE_MAC_ON_CREATE) &&\n\t    info->attrs[NL80211_ATTR_MAC]) {\n\t\tnla_memcpy(params.macaddr, info->attrs[NL80211_ATTR_MAC],\n\t\t\t   ETH_ALEN);\n\t\tif (!is_valid_ether_addr(params.macaddr))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg80211_iftype_allowed(&rdev->wiphy, type, params.use_4addr, 0))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mon_options(rdev, type, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\twdev = rdev_add_virtual_intf(rdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\t\t\tNET_NAME_USER, type, &params);\n\tif (WARN_ON(!wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn -EPROTO;\n\t} else if (IS_ERR(wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn PTR_ERR(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\twdev->owner_nlportid = info->snd_portid;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!info->attrs[NL80211_ATTR_MESH_ID])\n\t\t\tbreak;\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->mesh_id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->ssid, nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->mesh_id_up_len);\n\t\twdev_unlock(wdev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t/*\n\t\t * P2P Device and NAN do not have a netdev, so don't go\n\t\t * through the netdev notifier and must be added here\n\t\t */\n\t\tcfg80211_init_wdev(wdev);\n\t\tcfg80211_register_wdev(rdev, wdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We hold RTNL, so this is safe, without RTNL opencount cannot\n\t * reach 0, and thus the rdev cannot be deleted.\n\t *\n\t * We need to do it for the dev_close(), since that will call\n\t * the netdev notifiers, and we need to acquire the mutex there\n\t * but don't know if we get there from here or from some other\n\t * place (e.g. \"ip link set ... down\").\n\t */\n\tmutex_unlock(&rdev->wiphy.mtx);\n\n\t/*\n\t * If we remove a wireless device without a netdev then clear\n\t * user_ptr[1] so that nl80211_post_doit won't dereference it\n\t * to check if it needs to do dev_put(). Otherwise it crashes\n\t * since the wdev has been freed, unlike with a netdev where\n\t * we need the dev_put() for the netdev to really be freed.\n\t */\n\tif (!wdev->netdev)\n\t\tinfo->user_ptr[1] = NULL;\n\telse\n\t\tdev_close(wdev->netdev);\n\n\tmutex_lock(&rdev->wiphy.mtx);\n\n\treturn rdev_del_virtual_intf(rdev, wdev);\n}\n\nstatic int nl80211_set_noack_map(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 noack_map;\n\n\tif (!info->attrs[NL80211_ATTR_NOACK_MAP])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_noack_map)\n\t\treturn -EOPNOTSUPP;\n\n\tnoack_map = nla_get_u16(info->attrs[NL80211_ATTR_NOACK_MAP]);\n\n\treturn rdev_set_noack_map(rdev, dev, noack_map);\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tkey = nla_nest_start_noflag(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(cookie->msg, NL80211_KEY_IDX, cookie->idx))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\tbool bigtk_support = false;\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION))\n\t\tbigtk_support = true;\n\n\tif ((dev->ieee80211_ptr->iftype == NL80211_IFTYPE_STATION ||\n\t     dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_CLIENT) &&\n\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT))\n\t\tbigtk_support = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX]) {\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\t\tif (key_idx >= 6 && key_idx <= 7 && !bigtk_support) {\n\t\t\tGENL_SET_ERR_MSG(info, \"BIGTK not supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_idx))\n\t\tgoto nla_put_failure;\n\tif (mac_addr &&\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr))\n\t\tgoto nla_put_failure;\n\n\terr = rdev_get_key(rdev, dev, key_idx, pairwise, mac_addr, &cookie,\n\t\t\t   get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t/* Only support setting default key and\n\t * Extended Key ID action NL80211_KEY_SET_TX.\n\t */\n\tif (!key.def && !key.defmgmt && !key.defbeacon &&\n\t    !(key.p.mode == NL80211_KEY_SET_TX))\n\t\treturn -EINVAL;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_key(rdev, dev, key.idx,\n\t\t\t\t\t\t key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_key = key.idx;\n#endif\n\t} else if (key.defmgmt) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_mgmt_key(rdev, dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tdev->ieee80211_ptr->wext.default_mgmt_key = key.idx;\n#endif\n\t} else if (key.defbeacon) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_beacon_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_beacon_key(rdev, dev, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (key.p.mode == NL80211_KEY_SET_TX &&\n\t\t   wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t   NL80211_EXT_FEATURE_EXT_KEY_ID)) {\n\t\tu8 *mac_addr = NULL;\n\n\t\tif (info->attrs[NL80211_ATTR_MAC])\n\t\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!mac_addr || key.idx < 0 || key.idx > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr, &key.p);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n out:\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key) {\n\t\tGENL_SET_ERR_MSG(info, \"no key\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP) {\n\t\tGENL_SET_ERR_MSG(info, \"key type not pairwise or group\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (key.type == NL80211_KEYTYPE_GROUP &&\n\t    info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tkey.p.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr)) {\n\t\tGENL_SET_ERR_MSG(info, \"key setting validation failed\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (err)\n\t\tGENL_SET_ERR_MSG(info, \"key not allowed\");\n\tif (!err) {\n\t\terr = rdev_add_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t    mac_addr, &key.p);\n\t\tif (err)\n\t\t\tGENL_SET_ERR_MSG(info, \"key addition failed\");\n\t}\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t/* for now */\n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_valid_key_idx(rdev, key.idx,\n\t\t\t\t    key.type == NL80211_KEYTYPE_PAIRWISE))\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = nl80211_key_allowed(dev->ieee80211_ptr);\n\n\tif (key.type == NL80211_KEYTYPE_GROUP && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = rdev_del_key(rdev, dev, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == dev->ieee80211_ptr->wext.default_key)\n\t\t\tdev->ieee80211_ptr->wext.default_key = -1;\n\t\telse if (key.idx == dev->ieee80211_ptr->wext.default_mgmt_key)\n\t\t\tdev->ieee80211_ptr->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\n/* This function returns an error or the number of nested attributes */\nstatic int validate_acl_mac_addrs(struct nlattr *nl_attr)\n{\n\tstruct nlattr *attr;\n\tint n_entries = 0, tmp;\n\n\tnla_for_each_nested(attr, nl_attr, tmp) {\n\t\tif (nla_len(attr) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tn_entries++;\n\t}\n\n\treturn n_entries;\n}\n\n/*\n * This function parses ACL information and allocates memory for ACL data.\n * On successful return, the calling function is responsible to free the\n * ACL buffer returned by this function.\n */\nstatic struct cfg80211_acl_data *parse_acl_data(struct wiphy *wiphy,\n\t\t\t\t\t\tstruct genl_info *info)\n{\n\tenum nl80211_acl_policy acl_policy;\n\tstruct nlattr *attr;\n\tstruct cfg80211_acl_data *acl;\n\tint i = 0, n_entries, tmp;\n\n\tif (!wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!info->attrs[NL80211_ATTR_ACL_POLICY])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tacl_policy = nla_get_u32(info->attrs[NL80211_ATTR_ACL_POLICY]);\n\tif (acl_policy != NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED &&\n\t    acl_policy != NL80211_ACL_POLICY_DENY_UNLESS_LISTED)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!info->attrs[NL80211_ATTR_MAC_ADDRS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tn_entries = validate_acl_mac_addrs(info->attrs[NL80211_ATTR_MAC_ADDRS]);\n\tif (n_entries < 0)\n\t\treturn ERR_PTR(n_entries);\n\n\tif (n_entries > wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tacl = kzalloc(struct_size(acl, mac_addrs, n_entries), GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_MAC_ADDRS], tmp) {\n\t\tmemcpy(acl->mac_addrs[i].addr, nla_data(attr), ETH_ALEN);\n\t\ti++;\n\t}\n\n\tacl->n_acl_entries = n_entries;\n\tacl->acl_policy = acl_policy;\n\n\treturn acl;\n}\n\nstatic int nl80211_set_mac_acl(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_acl_data *acl;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->ieee80211_ptr->beacon_interval)\n\t\treturn -EINVAL;\n\n\tacl = parse_acl_data(&rdev->wiphy, info);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\n\terr = rdev_set_mac_acl(rdev, dev, acl);\n\n\tkfree(acl);\n\n\treturn err;\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0; /* rate not found */\n\t}\n\n\treturn mask;\n}\n\nstatic bool ht_rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t       u8 *rates, u8 rates_len,\n\t\t\t       u8 mcs[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tu8 i;\n\n\tmemset(mcs, 0, IEEE80211_HT_MCS_MASK_LEN);\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint ridx, rbit;\n\n\t\tridx = rates[i] / 8;\n\t\trbit = BIT(rates[i] % 8);\n\n\t\t/* check validity */\n\t\tif ((ridx < 0) || (ridx >= IEEE80211_HT_MCS_MASK_LEN))\n\t\t\treturn false;\n\n\t\t/* check availability */\n\t\tridx = array_index_nospec(ridx, IEEE80211_HT_MCS_MASK_LEN);\n\t\tif (sband->ht_cap.mcs.rx_mask[ridx] & rbit)\n\t\t\tmcs[ridx] |= rbit;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 vht_mcs_map_to_mcs_mask(u8 vht_mcs_map)\n{\n\tu16 mcs_mask = 0;\n\n\tswitch (vht_mcs_map) {\n\tcase IEEE80211_VHT_MCS_NOT_SUPPORTED:\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\tmcs_mask = 0x00FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\tmcs_mask = 0x01FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\tmcs_mask = 0x03FF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mcs_mask;\n}\n\nstatic void vht_build_mcs_mask(u16 vht_mcs_map,\n\t\t\t       u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tvht_mcs_mask[nss] = vht_mcs_map_to_mcs_mask(vht_mcs_map & 0x03);\n\t\tvht_mcs_map >>= 2;\n\t}\n}\n\nstatic bool vht_set_mcs_mask(struct ieee80211_supported_band *sband,\n\t\t\t     struct nl80211_txrate_vht *txrate,\n\t\t\t     u16 mcs[NL80211_VHT_NSS_MAX])\n{\n\tu16 tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu16 tx_mcs_mask[NL80211_VHT_NSS_MAX] = {};\n\tu8 i;\n\n\tif (!sband->vht_cap.vht_supported)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_VHT_NSS_MAX);\n\n\t/* Build vht_mcs_mask from VHT capabilities */\n\tvht_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 he_mcs_map_to_mcs_mask(u8 he_mcs_map)\n{\n\tswitch (he_mcs_map) {\n\tcase IEEE80211_HE_MCS_NOT_SUPPORTED:\n\t\treturn 0;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_7:\n\t\treturn 0x00FF;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_9:\n\t\treturn 0x03FF;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_11:\n\t\treturn 0xFFF;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void he_build_mcs_mask(u16 he_mcs_map,\n\t\t\t      u16 he_mcs_mask[NL80211_HE_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_HE_NSS_MAX; nss++) {\n\t\the_mcs_mask[nss] = he_mcs_map_to_mcs_mask(he_mcs_map & 0x03);\n\t\the_mcs_map >>= 2;\n\t}\n}\n\nstatic u16 he_get_txmcsmap(struct genl_info *info,\n\t\t\t   const struct ieee80211_sta_he_cap *he_cap)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\t__le16\ttx_mcs;\n\n\tswitch (wdev->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_80p80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_160;\n\t\tbreak;\n\tdefault:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_80;\n\t\tbreak;\n\t}\n\treturn le16_to_cpu(tx_mcs);\n}\n\nstatic bool he_set_mcs_mask(struct genl_info *info,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t    struct nl80211_txrate_he *txrate,\n\t\t\t    u16 mcs[NL80211_HE_NSS_MAX])\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tu16 tx_mcs_mask[NL80211_HE_NSS_MAX] = {};\n\tu16 tx_mcs_map = 0;\n\tu8 i;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, wdev->iftype);\n\tif (!he_cap)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_HE_NSS_MAX);\n\n\ttx_mcs_map = he_get_txmcsmap(info, he_cap);\n\n\t/* Build he_mcs_mask from HE capabilities */\n\the_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nl80211_parse_tx_bitrate_mask(struct genl_info *info,\n\t\t\t\t\t struct nlattr *attrs[],\n\t\t\t\t\t enum nl80211_attrs attr,\n\t\t\t\t\t struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t bool default_all_enabled)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint rem, i;\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\tu16 vht_tx_mcs_map, he_tx_mcs_map;\n\n\tmemset(mask, 0, sizeof(*mask));\n\t/* Default to all rates enabled */\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tconst struct ieee80211_sta_he_cap *he_cap;\n\n\t\tif (!default_all_enabled)\n\t\t\tbreak;\n\n\t\tsband = rdev->wiphy.bands[i];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tmask->control[i].legacy = (1 << sband->n_bitrates) - 1;\n\t\tmemcpy(mask->control[i].ht_mcs,\n\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t       sizeof(mask->control[i].ht_mcs));\n\n\t\tif (!sband->vht_cap.vht_supported)\n\t\t\tcontinue;\n\n\t\tvht_tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\t\tvht_build_mcs_mask(vht_tx_mcs_map, mask->control[i].vht_mcs);\n\n\t\the_cap = ieee80211_get_he_iftype_cap(sband, wdev->iftype);\n\t\tif (!he_cap)\n\t\t\tcontinue;\n\n\t\the_tx_mcs_map = he_get_txmcsmap(info, he_cap);\n\t\the_build_mcs_mask(he_tx_mcs_map, mask->control[i].he_mcs);\n\n\t\tmask->control[i].he_gi = 0xFF;\n\t\tmask->control[i].he_ltf = 0xFF;\n\t}\n\n\t/* if no rates are given set it back to the defaults */\n\tif (!attrs[attr])\n\t\tgoto out;\n\n\t/* The nested attribute uses enum nl80211_band as the index. This maps\n\t * directly to the enum nl80211_band values used in cfg80211.\n\t */\n\tBUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);\n\tnla_for_each_nested(tx_rates, attrs[attr], rem) {\n\t\tenum nl80211_band band = nla_type(tx_rates);\n\t\tint err;\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(tb, NL80211_TXRATE_MAX,\n\t\t\t\t\t\t  tx_rates,\n\t\t\t\t\t\t  nl80211_txattr_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask->control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif ((mask->control[band].legacy == 0) &&\n\t\t\t    nla_len(tb[NL80211_TXRATE_LEGACY]))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HT]) {\n\t\t\tif (!ht_rateset_to_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tnla_len(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tmask->control[band].ht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tb[NL80211_TXRATE_VHT]) {\n\t\t\tif (!vht_set_mcs_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_VHT]),\n\t\t\t\t\tmask->control[band].vht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tb[NL80211_TXRATE_GI]) {\n\t\t\tmask->control[band].gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_GI]);\n\t\t\tif (mask->control[band].gi > NL80211_TXRATE_FORCE_LGI)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HE] &&\n\t\t    !he_set_mcs_mask(info, wdev, sband,\n\t\t\t\t     nla_data(tb[NL80211_TXRATE_HE]),\n\t\t\t\t     mask->control[band].he_mcs))\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[NL80211_TXRATE_HE_GI])\n\t\t\tmask->control[band].he_gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_HE_GI]);\n\t\tif (tb[NL80211_TXRATE_HE_LTF])\n\t\t\tmask->control[band].he_ltf =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_HE_LTF]);\n\n\t\tif (mask->control[band].legacy == 0) {\n\t\t\t/* don't allow empty legacy rates if HT, VHT or HE\n\t\t\t * are not even supported.\n\t\t\t */\n\t\t\tif (!(rdev->wiphy.bands[band]->ht_cap.ht_supported ||\n\t\t\t      rdev->wiphy.bands[band]->vht_cap.vht_supported ||\n\t\t\t      ieee80211_get_he_iftype_cap(sband, wdev->iftype)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\t\tif (mask->control[band].ht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].vht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].he_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\t/* legacy and mcs rates may not be both empty */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   struct cfg80211_bitrate_mask *beacon_rate)\n{\n\tu32 count_ht, count_vht, count_he, i;\n\tu32 rate = beacon_rate->control[band].legacy;\n\n\t/* Allow only one rate */\n\tif (hweight32(rate) > 1)\n\t\treturn -EINVAL;\n\n\tcount_ht = 0;\n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tif (hweight8(beacon_rate->control[band].ht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].ht_mcs[i]) {\n\t\t\tcount_ht++;\n\t\t\tif (count_ht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_ht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_vht = 0;\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].vht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].vht_mcs[i]) {\n\t\t\tcount_vht++;\n\t\t\tif (count_vht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_vht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_he = 0;\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].he_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].he_mcs[i]) {\n\t\t\tcount_he++;\n\t\t\tif (count_he > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_he && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((count_ht && count_vht && count_he) ||\n\t    (!rate && !count_ht && !count_vht && !count_he))\n\t\treturn -EINVAL;\n\n\tif (rate &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_LEGACY))\n\t\treturn -EINVAL;\n\tif (count_ht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HT))\n\t\treturn -EINVAL;\n\tif (count_vht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_VHT))\n\t\treturn -EINVAL;\n\tif (count_he &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_beacon(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct nlattr *attrs[],\n\t\t\t\tstruct cfg80211_beacon_data *bcn)\n{\n\tbool haveinfo = false;\n\tint err;\n\n\tmemset(bcn, 0, sizeof(*bcn));\n\n\tif (attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tbcn->head = nla_data(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tbcn->head_len = nla_len(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tif (!bcn->head_len)\n\t\t\treturn -EINVAL;\n\t\thaveinfo = true;\n\t}\n\n\tif (attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tbcn->tail = nla_data(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tbcn->tail_len = nla_len(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = true;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\tif (attrs[NL80211_ATTR_IE]) {\n\t\tbcn->beacon_ies = nla_data(attrs[NL80211_ATTR_IE]);\n\t\tbcn->beacon_ies_len = nla_len(attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_PROBE_RESP]) {\n\t\tbcn->proberesp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t\tbcn->proberesp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_ASSOC_RESP]) {\n\t\tbcn->assocresp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t\tbcn->assocresp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_PROBE_RESP]) {\n\t\tbcn->probe_resp = nla_data(attrs[NL80211_ATTR_PROBE_RESP]);\n\t\tbcn->probe_resp_len = nla_len(attrs[NL80211_ATTR_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_FTM_RESPONDER]) {\n\t\tstruct nlattr *tb[NL80211_FTM_RESP_ATTR_MAX + 1];\n\n\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t  NL80211_FTM_RESP_ATTR_MAX,\n\t\t\t\t\t\t  attrs[NL80211_ATTR_FTM_RESPONDER],\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_ENABLED] &&\n\t\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))\n\t\t\tbcn->ftm_responder = 1;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_LCI]) {\n\t\t\tbcn->lci = nla_data(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t\tbcn->lci_len = nla_len(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t}\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_CIVICLOC]) {\n\t\t\tbcn->civicloc = nla_data(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t\tbcn->civicloc_len = nla_len(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t}\n\t} else {\n\t\tbcn->ftm_responder = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_obss_pd(struct nlattr *attrs,\n\t\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct nlattr *tb[NL80211_HE_OBSS_PD_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_OBSS_PD_ATTR_MAX, attrs,\n\t\t\t       he_obss_pd_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_OBSS_PD_ATTR_SR_CTRL])\n\t\treturn -EINVAL;\n\n\the_obss_pd->sr_ctrl = nla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_SR_CTRL]);\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET])\n\t\the_obss_pd->min_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET]);\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET])\n\t\the_obss_pd->max_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET]);\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET])\n\t\the_obss_pd->non_srg_max_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET]);\n\n\tif (he_obss_pd->min_offset > he_obss_pd->max_offset)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP])\n\t\tmemcpy(he_obss_pd->bss_color_bitmap,\n\t\t       nla_data(tb[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP]),\n\t\t       sizeof(he_obss_pd->bss_color_bitmap));\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP])\n\t\tmemcpy(he_obss_pd->partial_bssid_bitmap,\n\t\t       nla_data(tb[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP]),\n\t\t       sizeof(he_obss_pd->partial_bssid_bitmap));\n\n\the_obss_pd->enable = true;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_bss_color(struct nlattr *attrs,\n\t\t\t\t      struct cfg80211_he_bss_color *he_bss_color)\n{\n\tstruct nlattr *tb[NL80211_HE_BSS_COLOR_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_BSS_COLOR_ATTR_MAX, attrs,\n\t\t\t       he_bss_color_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_BSS_COLOR_ATTR_COLOR])\n\t\treturn -EINVAL;\n\n\the_bss_color->color =\n\t\tnla_get_u8(tb[NL80211_HE_BSS_COLOR_ATTR_COLOR]);\n\the_bss_color->enabled =\n\t\t!nla_get_flag(tb[NL80211_HE_BSS_COLOR_ATTR_DISABLED]);\n\the_bss_color->partial =\n\t\tnla_get_flag(tb[NL80211_HE_BSS_COLOR_ATTR_PARTIAL]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_fils_discovery(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct nlattr *attrs,\n\t\t\t\t\tstruct cfg80211_ap_settings *params)\n{\n\tstruct nlattr *tb[NL80211_FILS_DISCOVERY_ATTR_MAX + 1];\n\tint ret;\n\tstruct cfg80211_fils_discovery *fd = &params->fils_discovery;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_DISCOVERY))\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_FILS_DISCOVERY_ATTR_MAX, attrs,\n\t\t\t       NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] ||\n\t    !tb[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] ||\n\t    !tb[NL80211_FILS_DISCOVERY_ATTR_TMPL])\n\t\treturn -EINVAL;\n\n\tfd->tmpl_len = nla_len(tb[NL80211_FILS_DISCOVERY_ATTR_TMPL]);\n\tfd->tmpl = nla_data(tb[NL80211_FILS_DISCOVERY_ATTR_TMPL]);\n\tfd->min_interval = nla_get_u32(tb[NL80211_FILS_DISCOVERY_ATTR_INT_MIN]);\n\tfd->max_interval = nla_get_u32(tb[NL80211_FILS_DISCOVERY_ATTR_INT_MAX]);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_unsol_bcast_probe_resp(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct nlattr *attrs,\n\t\t\t\t     struct cfg80211_ap_settings *params)\n{\n\tstruct nlattr *tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX + 1];\n\tint ret;\n\tstruct cfg80211_unsol_bcast_probe_resp *presp =\n\t\t\t\t\t&params->unsol_bcast_probe_resp;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP))\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX,\n\t\t\t       attrs, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT] ||\n\t    !tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL])\n\t\treturn -EINVAL;\n\n\tpresp->tmpl = nla_data(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL]);\n\tpresp->tmpl_len = nla_len(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL]);\n\tpresp->interval = nla_get_u32(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT]);\n\treturn 0;\n}\n\nstatic void nl80211_check_ap_rate_selectors(struct cfg80211_ap_settings *params,\n\t\t\t\t\t    const u8 *rates)\n{\n\tint i;\n\n\tif (!rates)\n\t\treturn;\n\n\tfor (i = 0; i < rates[1]; i++) {\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_HT_PHY)\n\t\t\tparams->ht_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)\n\t\t\tparams->vht_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_HE_PHY)\n\t\t\tparams->he_required = true;\n\t\tif (rates[2 + i] == BSS_MEMBERSHIP_SELECTOR_SAE_H2E)\n\t\t\tparams->sae_h2e_required = true;\n\t}\n}\n\n/*\n * Since the nl80211 API didn't include, from the beginning, attributes about\n * HT/VHT requirements/capabilities, we parse them out of the IEs for the\n * benefit of drivers that rebuild IEs in the firmware.\n */\nstatic void nl80211_calculate_ap_params(struct cfg80211_ap_settings *params)\n{\n\tconst struct cfg80211_beacon_data *bcn = &params->beacon;\n\tsize_t ies_len = bcn->tail_len;\n\tconst u8 *ies = bcn->tail;\n\tconst u8 *rates;\n\tconst u8 *cap;\n\n\trates = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\trates = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\tcap = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->ht_cap))\n\t\tparams->ht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ie(WLAN_EID_VHT_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->vht_cap))\n\t\tparams->vht_cap = (void *)(cap + 2);\n\tcap = cfg80211_find_ext_ie(WLAN_EID_EXT_HE_CAPABILITY, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->he_cap) + 1)\n\t\tparams->he_cap = (void *)(cap + 3);\n\tcap = cfg80211_find_ext_ie(WLAN_EID_EXT_HE_OPERATION, ies, ies_len);\n\tif (cap && cap[1] >= sizeof(*params->he_oper) + 1)\n\t\tparams->he_oper = (void *)(cap + 3);\n}\n\nstatic bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct cfg80211_ap_settings *params)\n{\n\tstruct wireless_dev *wdev;\n\tbool ret = false;\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\tcontinue;\n\n\t\tif (!wdev->preset_chandef.chan)\n\t\t\tcontinue;\n\n\t\tparams->chandef = wdev->preset_chandef;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool nl80211_valid_auth_type(struct cfg80211_registered_device *rdev,\n\t\t\t\t    enum nl80211_auth_type auth_type,\n\t\t\t\t    enum nl80211_commands cmd)\n{\n\tif (auth_type > NL80211_AUTHTYPE_MAX)\n\t\treturn false;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_AUTHENTICATE:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_FILS_STA) &&\n\t\t    (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_PK))\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_CONNECT:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\n\t\t/* FILS with SK PFS or PK not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(\n\t\t\t    &rdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK)\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_START_AP:\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\t/* FILS not supported yet */\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ap_settings params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_ap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->beacon_interval)\n\t\treturn -EALREADY;\n\n\tmemset(&params, 0, sizeof(params));\n\n\t/* these are required for START_AP */\n\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon);\n\tif (err)\n\t\treturn err;\n\n\tparams.beacon_interval =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\tparams.dtim_period =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\terr = cfg80211_validate_beacon_int(rdev, dev->ieee80211_ptr->iftype,\n\t\t\t\t\t   params.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * In theory, some of these attributes should be required here\n\t * but since they were not used when the command was originally\n\t * added, keep them optional for old user space programs to let\n\t * them continue to work with drivers that do not need the\n\t * additional information -- drivers must check!\n\t */\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tparams.ssid_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid_len == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HIDDEN_SSID])\n\t\tparams.hidden_ssid = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_HIDDEN_SSID]);\n\n\tparams.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tparams.auth_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, params.auth_type,\n\t\t\t\t\t     NL80211_CMD_START_AP))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tparams.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\terr = nl80211_crypto_settings(rdev, info, &params.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_INACTIVITY_TIMER))\n\t\t\treturn -EOPNOTSUPP;\n\t\tparams.inactivity_timeout = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (wdev->preset_chandef.chan) {\n\t\tparams.chandef = wdev->preset_chandef;\n\t} else if (!nl80211_get_ap_channel(rdev, &params))\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t\t    NL80211_ATTR_TX_RATES,\n\t\t\t\t\t\t    &params.beacon_rate,\n\t\t\t\t\t\t    dev, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = validate_beacon_tx_rate(rdev, params.chandef.chan->band,\n\t\t\t\t\t      &params.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SMPS_MODE]) {\n\t\tparams.smps_mode =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SMPS_MODE]);\n\t\tswitch (params.smps_mode) {\n\t\tcase NL80211_SMPS_OFF:\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_STATIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_STATIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_DYNAMIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_DYNAMIC_SMPS))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tparams.smps_mode = NL80211_SMPS_OFF;\n\t}\n\n\tparams.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (params.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ])\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_ACL_POLICY]) {\n\t\tparams.acl = parse_acl_data(&rdev->wiphy, info);\n\t\tif (IS_ERR(params.acl))\n\t\t\treturn PTR_ERR(params.acl);\n\t}\n\n\tparams.twt_responder =\n\t\t    nla_get_flag(info->attrs[NL80211_ATTR_TWT_RESPONDER]);\n\n\tif (info->attrs[NL80211_ATTR_HE_OBSS_PD]) {\n\t\terr = nl80211_parse_he_obss_pd(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_OBSS_PD],\n\t\t\t\t\t&params.he_obss_pd);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_BSS_COLOR]) {\n\t\terr = nl80211_parse_he_bss_color(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_BSS_COLOR],\n\t\t\t\t\t&params.he_bss_color);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_DISCOVERY]) {\n\t\terr = nl80211_parse_fils_discovery(rdev,\n\t\t\t\t\t\t   info->attrs[NL80211_ATTR_FILS_DISCOVERY],\n\t\t\t\t\t\t   &params);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP]) {\n\t\terr = nl80211_parse_unsol_bcast_probe_resp(\n\t\t\trdev, info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP],\n\t\t\t&params);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tnl80211_calculate_ap_params(&params);\n\n\tif (info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])\n\t\tparams.flags |= AP_SETTINGS_EXTERNAL_AUTH_SUPPORT;\n\n\twdev_lock(wdev);\n\terr = rdev_start_ap(rdev, dev, &params);\n\tif (!err) {\n\t\twdev->preset_chandef = params.chandef;\n\t\twdev->beacon_interval = params.beacon_interval;\n\t\twdev->chandef = params.chandef;\n\t\twdev->ssid_len = params.ssid_len;\n\t\tmemcpy(wdev->ssid, params.ssid, wdev->ssid_len);\n\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\t\twdev->conn_owner_nlportid = info->snd_portid;\n\t}\n\twdev_unlock(wdev);\n\nout:\n\tkfree(params.acl);\n\n\treturn err;\n}\n\nstatic int nl80211_set_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_beacon_data params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->change_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev->beacon_interval)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\terr = rdev_change_beacon(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_stop_ap(rdev, dev, false);\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_TDLS_PEER] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       enum nl80211_iftype iftype,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t/*\n\t * Try parsing the new attribute first so userspace\n\t * can specify both for older kernels.\n\t */\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tparams->sta_flags_set &= params->sta_flags_mask;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t/* if present, parse the old attribute */\n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_STA_FLAG_MAX, nla, sta_flags_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Only allow certain flags for interface types so that\n\t * other attributes are silently ignored. Remember that\n\t * this is backward compatibility code with old userspace\n\t * and shouldn't be hit in other cases anyway.\n\t */\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++) {\n\t\tif (flags[flag]) {\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\t\t\t/* no longer support new API additions in old API */\n\t\t\tif (flag > NL80211_STA_FLAG_MAX_OLD_API)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info, int attr)\n{\n\tstruct nlattr *rate;\n\tu32 bitrate;\n\tu16 bitrate_compat;\n\tenum nl80211_rate_info rate_flg;\n\n\trate = nla_nest_start_noflag(msg, attr);\n\tif (!rate)\n\t\treturn false;\n\n\t/* cfg80211_calculate_bitrate will return 0 for mcs >= 32 */\n\tbitrate = cfg80211_calculate_bitrate(info);\n\t/* report 16-bit bitrate only if we can */\n\tbitrate_compat = bitrate < (1UL << 16) ? bitrate : 0;\n\tif (bitrate > 0 &&\n\t    nla_put_u32(msg, NL80211_RATE_INFO_BITRATE32, bitrate))\n\t\treturn false;\n\tif (bitrate_compat > 0 &&\n\t    nla_put_u16(msg, NL80211_RATE_INFO_BITRATE, bitrate_compat))\n\t\treturn false;\n\n\tswitch (info->bw) {\n\tcase RATE_INFO_BW_5:\n\t\trate_flg = NL80211_RATE_INFO_5_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_10:\n\t\trate_flg = NL80211_RATE_INFO_10_MHZ_WIDTH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase RATE_INFO_BW_20:\n\t\trate_flg = 0;\n\t\tbreak;\n\tcase RATE_INFO_BW_40:\n\t\trate_flg = NL80211_RATE_INFO_40_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_80:\n\t\trate_flg = NL80211_RATE_INFO_80_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_160:\n\t\trate_flg = NL80211_RATE_INFO_160_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_HE_RU:\n\t\trate_flg = 0;\n\t\tWARN_ON(!(info->flags & RATE_INFO_FLAGS_HE_MCS));\n\t}\n\n\tif (rate_flg && nla_put_flag(msg, rate_flg))\n\t\treturn false;\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_GI, info->he_gi))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_DCM, info->he_dcm))\n\t\t\treturn false;\n\t\tif (info->bw == RATE_INFO_BW_HE_RU &&\n\t\t    nla_put_u8(msg, NL80211_RATE_INFO_HE_RU_ALLOC,\n\t\t\t       info->he_ru_alloc))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n}\n\nstatic bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,\n\t\t\t       int id)\n{\n\tvoid *attr;\n\tint i = 0;\n\n\tif (!mask)\n\t\treturn true;\n\n\tattr = nla_nest_start_noflag(msg, id);\n\tif (!attr)\n\t\treturn false;\n\n\tfor (i = 0; i < IEEE80211_MAX_CHAINS; i++) {\n\t\tif (!(mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (nla_put_u8(msg, i, signal[i]))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, attr);\n\n\treturn true;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn -1;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, sinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tsinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\n#define PUT_SINFO(attr, memb, type) do {\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(type) == sizeof(u64));\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_ ## type(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t     sinfo->memb))\t\t\t\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n#define PUT_SINFO_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t      sinfo->memb, NL80211_STA_INFO_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\tPUT_SINFO(CONNECTED_TIME, connected_time, u32);\n\tPUT_SINFO(INACTIVE_TIME, inactive_time, u32);\n\tPUT_SINFO_U64(ASSOC_AT_BOOTTIME, assoc_at);\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_RX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t(u32)sinfo->rx_bytes))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_TX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t(u32)sinfo->tx_bytes))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(RX_BYTES64, rx_bytes);\n\tPUT_SINFO_U64(TX_BYTES64, tx_bytes);\n\tPUT_SINFO(LLID, llid, u16);\n\tPUT_SINFO(PLID, plid, u16);\n\tPUT_SINFO(PLINK_STATE, plink_state, u8);\n\tPUT_SINFO_U64(RX_DURATION, rx_duration);\n\tPUT_SINFO_U64(TX_DURATION, tx_duration);\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\tPUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tPUT_SINFO(SIGNAL, signal, u8);\n\t\tPUT_SINFO(SIGNAL_AVG, signal_avg, u8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal_avg,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL_AVG))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tPUT_SINFO(RX_PACKETS, rx_packets, u32);\n\tPUT_SINFO(TX_PACKETS, tx_packets, u32);\n\tPUT_SINFO(TX_RETRIES, tx_retries, u32);\n\tPUT_SINFO(TX_FAILED, tx_failed, u32);\n\tPUT_SINFO(EXPECTED_THROUGHPUT, expected_throughput, u32);\n\tPUT_SINFO(AIRTIME_LINK_METRIC, airtime_link_metric, u32);\n\tPUT_SINFO(BEACON_LOSS, beacon_loss_count, u32);\n\tPUT_SINFO(LOCAL_PM, local_pm, u32);\n\tPUT_SINFO(PEER_PM, peer_pm, u32);\n\tPUT_SINFO(NONPEER_PM, nonpeer_pm, u32);\n\tPUT_SINFO(CONNECTED_TO_GATE, connected_to_gate, u8);\n\tPUT_SINFO(CONNECTED_TO_AS, connected_to_as, u8);\n\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_BSS_PARAM)) {\n\t\tbss_param = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (((sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_CTS_PROT)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME)) ||\n\t\t    nla_put_u8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t       sinfo->bss_param.dtim_period) ||\n\t\t    nla_put_u16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t\tsinfo->bss_param.beacon_interval))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tif ((sinfo->filled & BIT_ULL(NL80211_STA_INFO_STA_FLAGS)) &&\n\t    nla_put(msg, NL80211_STA_INFO_STA_FLAGS,\n\t\t    sizeof(struct nl80211_sta_flag_update),\n\t\t    &sinfo->sta_flags))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(T_OFFSET, t_offset);\n\tPUT_SINFO_U64(RX_DROP_MISC, rx_dropped_misc);\n\tPUT_SINFO_U64(BEACON_RX, rx_beacon);\n\tPUT_SINFO(BEACON_SIGNAL_AVG, rx_beacon_signal_avg, u8);\n\tPUT_SINFO(RX_MPDUS, rx_mpdu_count, u32);\n\tPUT_SINFO(FCS_ERROR_COUNT, fcs_err_count, u32);\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT)) {\n\t\tPUT_SINFO(ACK_SIGNAL, ack_signal, u8);\n\t\tPUT_SINFO(ACK_SIGNAL_AVG, avg_ack_signal, s8);\n\t}\n\n#undef PUT_SINFO\n#undef PUT_SINFO_U64\n\n\tif (sinfo->pertid) {\n\t\tstruct nlattr *tidsattr;\n\t\tint tid;\n\n\t\ttidsattr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_STA_INFO_TID_STATS);\n\t\tif (!tidsattr)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {\n\t\t\tstruct cfg80211_tid_stats *tidstats;\n\t\t\tstruct nlattr *tidattr;\n\n\t\t\ttidstats = &sinfo->pertid[tid];\n\n\t\t\tif (!tidstats->filled)\n\t\t\t\tcontinue;\n\n\t\t\ttidattr = nla_nest_start_noflag(msg, tid + 1);\n\t\t\tif (!tidattr)\n\t\t\t\tgoto nla_put_failure;\n\n#define PUT_TIDVAL_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (tidstats->filled & BIT(NL80211_TID_STATS_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_TID_STATS_ ## attr,\t\t\\\n\t\t\t      tidstats->memb, NL80211_TID_STATS_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\t\t\tPUT_TIDVAL_U64(RX_MSDU, rx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU, tx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_RETRIES, tx_msdu_retries);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_FAILED, tx_msdu_failed);\n\n#undef PUT_TIDVAL_U64\n\t\t\tif ((tidstats->filled &\n\t\t\t     BIT(NL80211_TID_STATS_TXQ_STATS)) &&\n\t\t\t    !nl80211_put_txq_stats(msg, &tidstats->txq_stats,\n\t\t\t\t\t\t   NL80211_TID_STATS_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, tidattr);\n\t\t}\n\n\t\tnla_nest_end(msg, tidsattr);\n\t}\n\n\tnla_nest_end(msg, sinfoattr);\n\n\tif (sinfo->assoc_req_ies_len &&\n\t    nla_put(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,\n\t\t    sinfo->assoc_req_ies))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\t/* nl80211_prepare_wdev_dump acquired it in the successful case */\n\t__acquire(&rdev->wiphy.mtx);\n\n\tif (!wdev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\terr = rdev_dump_station(rdev, wdev->netdev, sta_idx,\n\t\t\t\t\tmac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb, NL80211_CMD_NEW_STATION,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev->netdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n out:\n\tcb->args[2] = sta_idx;\n\terr = skb->len;\n out_err:\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION,\n\t\t\t\t info->snd_portid, info->snd_seq, 0,\n\t\t\t\t rdev, dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype)\n{\n\tif (params->listen_interval != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->support_p2p_ps != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->aid &&\n\t    !(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (statype) {\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\t/*\n\t\t * No ignoring the TDLS flag here -- the userspace mesh\n\t\t * code doesn't have the bug of including TDLS in the\n\t\t * mask everywhere.\n\t\t */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* ignore since it can't change */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tdefault:\n\t\t/* disallow mesh-specific things */\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION)\n\t\t\treturn -EINVAL;\n\t\tif (params->local_pm)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_TDLS_PEER_ACTIVE) {\n\t\t/* TDLS can't be set, ... */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * ... but don't bother the driver with it. This works around\n\t\t * a hostapd/wpa_supplicant issue -- it always includes the\n\t\t * TLDS_PEER flag in the mask even for AP mode.\n\t\t */\n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\t/* reject other things that can't change */\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_CAPABILITY)\n\t\t\treturn -EINVAL;\n\t\tif (params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tif (params->ext_capab || params->ht_capa || params->vht_capa ||\n\t\t    params->he_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_AP_CLIENT &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\tif (params->vlan)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (statype) {\n\tcase CFG80211_STA_AP_MLME_CLIENT:\n\t\t/* Use this only for authorizing/unauthorizing a station */\n\t\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase CFG80211_STA_AP_CLIENT:\n\tcase CFG80211_STA_AP_CLIENT_UNASSOC:\n\t\t/* accept only the listed bits */\n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP)))\n\t\t\treturn -EINVAL;\n\n\t\t/* but authenticated/associated only if driver handles it */\n\t\tif (!(wiphy->features & NL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params->sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_IBSS:\n\tcase CFG80211_STA_AP_STA:\n\t\t/* reject any changes other than AUTHORIZED */\n\t\tif (params->sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\t\t/* reject any changes other than AUTHORIZED or WME */\n\t\tif (params->sta_flags_mask & ~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t       BIT(NL80211_STA_FLAG_WME)))\n\t\t\treturn -EINVAL;\n\t\t/* force (at least) rates when authorizing */\n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED) &&\n\t\t    !params->supported_rates)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\t/* reject any changes */\n\t\treturn -EINVAL;\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION &&\n\t\t    params->plink_action != NL80211_PLINK_ACTION_BLOCK)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Older kernel versions ignored this attribute entirely, so don't\n\t * reject attempts to update it but mark it as unused instead so the\n\t * driver won't look at the data.\n\t */\n\tif (statype != CFG80211_STA_AP_CLIENT_UNASSOC &&\n\t    statype != CFG80211_STA_TDLS_PEER_SETUP)\n\t\tparams->opmode_notif_used = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_check_station_change);\n\n/*\n * Get vlan interface making sure it is running and on the right wiphy.\n */\nstatic struct net_device *get_vlan(struct genl_info *info,\n\t\t\t\t   struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\tstruct net_device *v;\n\tint ret;\n\n\tif (!vlanattr)\n\t\treturn NULL;\n\n\tv = dev_get_by_index(genl_info_net(info), nla_get_u32(vlanattr));\n\tif (!v)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!v->ieee80211_ptr || v->ieee80211_ptr->wiphy != &rdev->wiphy) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!netif_running(v)) {\n\t\tret = -ENETDOWN;\n\t\tgoto error;\n\t}\n\n\treturn v;\n error:\n\tdev_put(v);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct nla_policy\nnl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] = {\n\t[NL80211_STA_WME_UAPSD_QUEUES] = { .type = NLA_U8 },\n\t[NL80211_STA_WME_MAX_SP] = { .type = NLA_U8 },\n};\n\nstatic int nl80211_parse_sta_wme(struct genl_info *info,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct nlattr *tb[NL80211_STA_WME_MAX + 1];\n\tstruct nlattr *nla;\n\tint err;\n\n\t/* parse WME attributes if present */\n\tif (!info->attrs[NL80211_ATTR_STA_WME])\n\t\treturn 0;\n\n\tnla = info->attrs[NL80211_ATTR_STA_WME];\n\terr = nla_parse_nested_deprecated(tb, NL80211_STA_WME_MAX, nla,\n\t\t\t\t\t  nl80211_sta_wme_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_STA_WME_UAPSD_QUEUES])\n\t\tparams->uapsd_queues = nla_get_u8(\n\t\t\ttb[NL80211_STA_WME_UAPSD_QUEUES]);\n\tif (params->uapsd_queues & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_STA_WME_MAX_SP])\n\t\tparams->max_sp = nla_get_u8(tb[NL80211_STA_WME_MAX_SP]);\n\n\tif (params->max_sp & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\n\t\treturn -EINVAL;\n\n\tparams->sta_modify_mask |= STATION_PARAM_APPLY_UAPSD;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_sta_channel_info(struct genl_info *info,\n\t\t\t\t      struct station_parameters *params)\n{\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]) {\n\t\tparams->supported_channels =\n\t\t     nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\tparams->supported_channels_len =\n\t\t     nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\t/*\n\t\t * Need to include at least one (first channel, number of\n\t\t * channels) tuple for each subband (checked in policy),\n\t\t * and must have proper tuples for the rest of the data as well.\n\t\t */\n\t\tif (params->supported_channels_len % 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]) {\n\t\tparams->supported_oper_classes =\n\t\t nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\tparams->supported_oper_classes_len =\n\t\t  nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station_tdls(struct genl_info *info,\n\t\t\t\t    struct station_parameters *params)\n{\n\tint err;\n\t/* Dummy STA entry gets updated once the peer capabilities are known */\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams->aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams->ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams->vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams->he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams->he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t}\n\n\terr = nl80211_parse_sta_channel_info(info, params);\n\tif (err)\n\t\treturn err;\n\n\treturn nl80211_parse_sta_wme(info, params);\n}\n\nstatic int nl80211_parse_sta_txpower_setting(struct genl_info *info,\n\t\t\t\t\t     struct station_parameters *params)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint idx;\n\n\tif (info->attrs[NL80211_ATTR_STA_TX_POWER_SETTING]) {\n\t\tif (!rdev->ops->set_tx_power ||\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_STA_TX_PWR))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_STA_TX_POWER_SETTING;\n\t\tparams->txpwr.type = nla_get_u8(info->attrs[idx]);\n\n\t\tif (params->txpwr.type == NL80211_TX_POWER_LIMITED) {\n\t\t\tidx = NL80211_ATTR_STA_TX_POWER;\n\n\t\t\tif (info->attrs[idx])\n\t\t\t\tparams->txpwr.power =\n\t\t\t\t\tnla_get_s16(info->attrs[idx]);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tparams->sta_modify_mask |= STATION_PARAM_APPLY_STA_TXPOWER;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->change_station)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * AID and listen_interval properties can be set only for unassociated\n\t * station. Include these parameters here and will check them in\n\t * cfg80211_check_station_change().\n\t */\n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tparams.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t     nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\telse\n\t\tparams.listen_interval = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS])\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\telse\n\t\tparams.support_p2p_ps = -1;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE]) {\n\t\tparams.plink_state =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\t\tif (info->attrs[NL80211_ATTR_MESH_PEER_AID])\n\t\t\tparams.peer_aid = nla_get_u16(\n\t\t\t\tinfo->attrs[NL80211_ATTR_MESH_PEER_AID]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_PLINK_STATE;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE])\n\t\tparams.local_pm = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\t/* Include parameters for TDLS peer (will check later) */\n\terr = nl80211_set_station_tdls(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tparams.vlan = get_vlan(info, rdev);\n\tif (IS_ERR(params.vlan))\n\t\treturn PTR_ERR(params.vlan);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_put_vlan;\n\t}\n\n\t/* driver will call cfg80211_check_station_change() */\n\terr = rdev_change_station(rdev, dev, mac_addr, &params);\n\n out_put_vlan:\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\tu32 auth_assoc = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->add_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID] &&\n\t    !info->attrs[NL80211_ATTR_PEER_AID])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tparams.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tparams.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]) {\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\t} else {\n\t\t/*\n\t\t * if not specified, assume it's supported for P2P GO interface,\n\t\t * and is NOT supported for AP interface\n\t\t */\n\t\tparams.support_p2p_ps =\n\t\t\tdev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\telse\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_channel_info(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_wme(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\t/* HT/VHT requires QoS, but if we don't have that just ignore HT/VHT\n\t * as userspace might just pass through the capabilities from the IEs\n\t * directly, rather than enforcing this restriction and returning an\n\t * error in this case.\n\t */\n\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME))) {\n\t\tparams.ht_capa = NULL;\n\t\tparams.vht_capa = NULL;\n\n\t\t/* HE requires WME */\n\t\tif (params.he_capa_len || params.he_6ghz_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Ensure that HT/VHT capabilities are not set for 6 GHz HE STA */\n\tif (params.he_6ghz_capa && (params.ht_capa || params.vht_capa))\n\t\treturn -EINVAL;\n\n\t/* When you run into this, adjust the code below for the new flag */\n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* ignore WME attributes if iface/sta is not capable */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) ||\n\t\t    !(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME)))\n\t\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\t/* but don't bother the driver with it */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\n\t\t/* allow authenticated/associated only if driver handles it */\n\t\tif (!(rdev->wiphy.features &\n\t\t\t\tNL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params.sta_flags_mask & auth_assoc)\n\t\t\treturn -EINVAL;\n\n\t\t/* Older userspace, or userspace wanting to be compatible with\n\t\t * !NL80211_FEATURE_FULL_AP_CLIENT_STATE, will not set the auth\n\t\t * and assoc flags in the mask, but assumes the station will be\n\t\t * added as associated anyway since this was the required driver\n\t\t * behaviour before NL80211_FEATURE_FULL_AP_CLIENT_STATE was\n\t\t * introduced.\n\t\t * In order to not bother drivers with this quirk in the API\n\t\t * set the flags in both the mask and set for new stations in\n\t\t * this case.\n\t\t */\n\t\tif (!(params.sta_flags_mask & auth_assoc)) {\n\t\t\tparams.sta_flags_mask |= auth_assoc;\n\t\t\tparams.sta_flags_set |= auth_assoc;\n\t\t}\n\n\t\t/* must be last in here for error handling */\n\t\tparams.vlan = get_vlan(info, rdev);\n\t\tif (IS_ERR(params.vlan))\n\t\t\treturn PTR_ERR(params.vlan);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* associated is disallowed */\n\t\tif (params.sta_flags_mask & BIT(NL80211_STA_FLAG_ASSOCIATED))\n\t\t\treturn -EINVAL;\n\t\t/* TDLS peers cannot be added */\n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t/* ignore uAPSD data */\n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t/* these are disallowed */\n\t\tif (params.sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_AUTHENTICATED)))\n\t\t\treturn -EINVAL;\n\t\t/* Only TDLS peers can be added */\n\t\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t/* Can only add if TDLS ... */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* ... with external setup is supported */\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/*\n\t\t * Older wpa_supplicant versions always mark the TDLS peer\n\t\t * as authorized, but it shouldn't yet be.\n\t\t */\n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* be aware of params.vlan when changing code here */\n\n\terr = rdev_add_station(rdev, dev, mac_addr, &params);\n\n\tif (params.vlan)\n\t\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_del_parameters params;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tparams.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* always accept these */\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* conditionally accept */\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_DEL_IBSS_STA))\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {\n\t\tparams.subtype =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);\n\t\tif (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&\n\t\t    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Default to Deauthentication frame */\n\t\tparams.subtype = IEEE80211_STYPE_DEAUTH >> 4;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_REASON_CODE]) {\n\t\tparams.reason_code =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\t\tif (params.reason_code == 0)\n\t\t\treturn -EINVAL; /* 0 is reserved */\n\t} else {\n\t\t/* Default to reason code 2 */\n\t\tparams.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;\n\t}\n\n\treturn rdev_del_station(rdev, dev, &params);\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, NL80211_CMD_NEW_MPATH);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, dst) ||\n\t    nla_put(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, pinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif ((pinfo->filled & MPATH_INFO_FRAME_QLEN) &&\n\t    nla_put_u32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\tpinfo->frame_qlen))\n\t\tgoto nla_put_failure;\n\tif (((pinfo->filled & MPATH_INFO_SN) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_SN, pinfo->sn)) ||\n\t    ((pinfo->filled & MPATH_INFO_METRIC) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t pinfo->metric)) ||\n\t    ((pinfo->filled & MPATH_INFO_EXPTIME) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t pinfo->exptime)) ||\n\t    ((pinfo->filled & MPATH_INFO_FLAGS) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\tpinfo->flags)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t pinfo->discovery_timeout)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\tpinfo->discovery_retries)) ||\n\t    ((pinfo->filled & MPATH_INFO_HOP_COUNT) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_HOP_COUNT,\n\t\t\tpinfo->hop_count)) ||\n\t    ((pinfo->filled & MPATH_INFO_PATH_CHANGE) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_PATH_CHANGE,\n\t\t\t pinfo->path_change_count)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\t/* nl80211_prepare_wdev_dump acquired it in the successful case */\n\t__acquire(&rdev->wiphy.mtx);\n\n\tif (!rdev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpath(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t      next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\twiphy_unlock(&rdev->wiphy);\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpath(rdev, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_change_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_add_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_del_mpath(rdev, dev, dst);\n}\n\nstatic int nl80211_get_mpp(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 mpp[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpp(rdev, dev, dst, mpp, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       dev, dst, mpp, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_dump_mpp(struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\t/* nl80211_prepare_wdev_dump acquired it in the successful case */\n\t__acquire(&rdev->wiphy.mtx);\n\n\tif (!rdev->ops->dump_mpp) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpp(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t    mpp, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, mpp,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\twiphy_unlock(&rdev->wiphy);\n\treturn err;\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct bss_parameters params;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\t/* default to not changing parameters */\n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\tparams.p2p_ctwindow = -1;\n\tparams.p2p_opp_ps = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = rdev_change_bss(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tchar *data = NULL;\n\tbool is_indoor;\n\tenum nl80211_user_reg_hint_type user_reg_hint_type;\n\tu32 owner_nlportid;\n\n\t/*\n\t * You should only get this when cfg80211 hasn't yet initialized\n\t * completely when built-in to the kernel right between the time\n\t * window between nl80211_init() and regulatory_init(), if that is\n\t * even possible.\n\t */\n\tif (unlikely(!rcu_access_pointer(cfg80211_regdomain)))\n\t\treturn -EINPROGRESS;\n\n\tif (info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE])\n\t\tuser_reg_hint_type =\n\t\t  nla_get_u32(info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE]);\n\telse\n\t\tuser_reg_hint_type = NL80211_USER_REG_HINT_USER;\n\n\tswitch (user_reg_hint_type) {\n\tcase NL80211_USER_REG_HINT_USER:\n\tcase NL80211_USER_REG_HINT_CELL_BASE:\n\t\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\t\treturn -EINVAL;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\t\treturn regulatory_hint_user(data, user_reg_hint_type);\n\tcase NL80211_USER_REG_HINT_INDOOR:\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\towner_nlportid = info->snd_portid;\n\t\t\tis_indoor = !!info->attrs[NL80211_ATTR_REG_INDOOR];\n\t\t} else {\n\t\t\towner_nlportid = 0;\n\t\t\tis_indoor = true;\n\t\t}\n\n\t\treturn regulatory_hint_indoor(is_indoor, owner_nlportid);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nl80211_reload_regdb(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn reg_reload_regdb();\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t/* If not connected, get default parameters */\n\tif (!wdev->mesh_id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev_get_mesh_config(rdev, dev, &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t/* Draw up a netlink message to send back */\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t       cur_params.dot11MeshMaxRetries) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_TTL,\n\t\t       cur_params.dot11MeshTTL) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t       cur_params.element_ttl) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t       cur_params.auto_open_plinks) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\tcur_params.dot11MeshNbrOffsetMaxNeighbor) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t       cur_params.dot11MeshHWMPmaxPREQretries) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPperrMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t       cur_params.dot11MeshHWMPRootMode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPRannInterval) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t       cur_params.dot11MeshGateAnnouncementProtocol) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,\n\t\t       cur_params.dot11MeshForwarding) ||\n\t    nla_put_s32(msg, NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\tcur_params.rssi_threshold) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HT_OPMODE,\n\t\t\tcur_params.ht_opmode) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathToRootTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMProotInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPconfirmationInterval) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_POWER_MODE,\n\t\t\tcur_params.power_mode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_AWAKE_WINDOW,\n\t\t\tcur_params.dot11MeshAwakeWindowDuration) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,\n\t\t\tcur_params.plink_timeout) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t       cur_params.dot11MeshConnectedToMeshGate) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_NOLEARN,\n\t\t       cur_params.dot11MeshNolearn) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_AS,\n\t\t       cur_params.dot11MeshConnectedToAuthServer))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy\nnl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 0, 255),\n\t[NL80211_MESHCONF_MAX_RETRIES] = NLA_POLICY_MAX(NLA_U8, 16),\n\t[NL80211_MESHCONF_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_ELEMENT_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] =\n\t\tNLA_POLICY_RANGE(NLA_U32, 1, 255),\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ROOTMODE] = NLA_POLICY_MAX(NLA_U8, 4),\n\t[NL80211_MESHCONF_HWMP_RANN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_FORWARDING] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_RSSI_THRESHOLD] =\n\t\tNLA_POLICY_RANGE(NLA_S32, -255, 0),\n\t[NL80211_MESHCONF_HT_OPMODE] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_ACTIVE,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_CONNECTED_TO_GATE] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n\t[NL80211_MESHCONF_NOLEARN] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n\t[NL80211_MESHCONF_CONNECTED_TO_AS] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_AUTH_PROTOCOL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_MPM] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\tu16 ht_opmode;\n\n#define FILL_IN_MESH_PARAM_IF_SET(tb, cfg, param, mask, attr, fn)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (tb[attr]) {\t\t\t\t\t\t\t\\\n\t\tcfg->param = fn(tb[attr]);\t\t\t\t\\\n\t\tmask |= BIT((attr) - 1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESHCONF_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_CONFIG], nl80211_meshconf_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t/* This makes sure that there aren't more than 32 mesh config\n\t * parameters (otherwise our bitfield scheme would not work.) */\n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t/* Fill in the params struct */\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, mask,\n\t\t\t\t  NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, mask,\n\t\t\t\t  NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, mask,\n\t\t\t\t  NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNbrOffsetMaxNeighbor,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\t\t  nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, mask,\n\t\t\t\t  NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_PATH_REFRESH_TIME) &&\n\t    (cfg->path_refresh_time < 1 || cfg->path_refresh_time > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPnetDiameterTraversalTime, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOTMODE, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshGateAnnouncementProtocol,\n\t\t\t\t  mask, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, mask,\n\t\t\t\t  NL80211_MESHCONF_FORWARDING, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, mask,\n\t\t\t\t  NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\t\t  nla_get_s32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToMeshGate, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToAuthServer, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_AS,\n\t\t\t\t  nla_get_u8);\n\t/*\n\t * Check HT operation mode based on\n\t * IEEE 802.11-2016 9.4.2.57 HT Operation element.\n\t */\n\tif (tb[NL80211_MESHCONF_HT_OPMODE]) {\n\t\tht_opmode = nla_get_u16(tb[NL80211_MESHCONF_HT_OPMODE]);\n\n\t\tif (ht_opmode & ~(IEEE80211_HT_OP_MODE_PROTECTION |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT))\n\t\t\treturn -EINVAL;\n\n\t\t/* NON_HT_STA bit is reserved, but some programs set it */\n\t\tht_opmode &= ~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tcfg->ht_opmode = ht_opmode;\n\t\tmask |= (1 << (NL80211_MESHCONF_HT_OPMODE - 1));\n\t}\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPactivePathToRootTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathToRootTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathToRootTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMProotInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPconfirmationInterval,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, power_mode, mask,\n\t\t\t\t  NL80211_MESHCONF_POWER_MODE, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshAwakeWindowDuration, mask,\n\t\t\t\t  NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_PLINK_TIMEOUT, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNolearn, mask,\n\t\t\t\t  NL80211_MESHCONF_NOLEARN, nla_get_u8);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESH_SETUP_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_SETUP], nl80211_mesh_setup_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])\n\t\tsetup->sync_method =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])) ?\n\t\t IEEE80211_SYNC_METHOD_VENDOR :\n\t\t IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tif (tb[NL80211_MESH_SETUP_USERSPACE_MPM] &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_USERSPACE_MPM))\n\t\treturn -EINVAL;\n\tsetup->user_mpm = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_MPM]);\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\tif (setup->is_secure)\n\t\tsetup->user_mpm = true;\n\n\tif (tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]) {\n\t\tif (!setup->user_mpm)\n\t\t\treturn -EINVAL;\n\t\tsetup->auth_id =\n\t\t\tnla_get_u8(tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg;\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->mesh_id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev_update_mesh_config(rdev, dev, mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_put_regdom(const struct ieee80211_regdomain *regdom,\n\t\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\n\tif (nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, regdom->alpha2) ||\n\t    (regdom->dfs_region &&\n\t     nla_put_u8(msg, NL80211_ATTR_DFS_REGION, regdom->dfs_region)))\n\t\tgoto nla_put_failure;\n\n\tnl_reg_rules = nla_nest_start_noflag(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < regdom->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\t\tunsigned int max_bandwidth_khz;\n\n\t\treg_rule = &regdom->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tmax_bandwidth_khz = freq_range->max_bandwidth_khz;\n\t\tif (!max_bandwidth_khz)\n\t\t\tmax_bandwidth_khz = reg_get_max_bandwidth(regdom,\n\t\t\t\t\t\t\t\t  reg_rule);\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\t\treg_rule->flags) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\t\tfreq_range->start_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\t\tfreq_range->end_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\t\tmax_bandwidth_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\t\tpower_rule->max_antenna_gain) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\t\tpower_rule->max_eirp) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,\n\t\t\t\treg_rule->dfs_cac_ms))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy = NULL;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOBUFS;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\trtnl_lock();\n\n\tif (info->attrs[NL80211_ATTR_WIPHY]) {\n\t\tbool self_managed;\n\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\tnlmsg_free(msg);\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\n\t\twiphy = &rdev->wiphy;\n\t\tself_managed = wiphy->regulatory_flags &\n\t\t\t       REGULATORY_WIPHY_SELF_MANAGED;\n\t\tregdom = get_wiphy_regdom(wiphy);\n\n\t\t/* a self-managed-reg device must have a private regdom */\n\t\tif (WARN_ON(!regdom && self_managed)) {\n\t\t\tnlmsg_free(msg);\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (regdom &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\n\tif (!regdom)\n\t\tregdom = rcu_dereference(cfg80211_regdomain);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure_rcu;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(msg, hdr);\n\trtnl_unlock();\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\n\trtnl_unlock();\nput_failure:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_send_regdom(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t       u32 seq, int flags, struct wiphy *wiphy,\n\t\t\t       const struct ieee80211_regdomain *regdom)\n{\n\tvoid *hdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t\t   NL80211_CMD_GET_REG);\n\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure;\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy &&\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy && wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_dump(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tint err, reg_idx, start = cb->args[2];\n\n\trtnl_lock();\n\n\tif (cfg80211_regdomain && start == 0) {\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, NULL,\n\t\t\t\t\t  rtnl_dereference(cfg80211_regdomain));\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t}\n\n\t/* the global regdom is idx 0 */\n\treg_idx = 1;\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tregdom = get_wiphy_regdom(&rdev->wiphy);\n\t\tif (!regdom)\n\t\t\tcontinue;\n\n\t\tif (++reg_idx <= start)\n\t\t\tcontinue;\n\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, &rdev->wiphy, regdom);\n\t\tif (err < 0) {\n\t\t\treg_idx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[2] = reg_idx;\n\terr = skb->len;\nout_err:\n\trtnl_unlock();\n\treturn err;\n}\n\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_DFS_CAC_TIME]\t\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\tif (tb[NL80211_ATTR_DFS_CAC_TIME])\n\t\treg_rule->dfs_cac_ms =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_DFS_CAC_TIME]);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2;\n\tint rem_reg_rules, r;\n\tu32 num_rules = 0, rule_idx = 0;\n\tenum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;\n\tstruct ieee80211_regdomain *rd;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tif (info->attrs[NL80211_ATTR_DFS_REGION])\n\t\tdfs_region = nla_get_u8(info->attrs[NL80211_ATTR_DFS_REGION]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\trtnl_lock();\n\tif (!reg_is_valid_request(alpha2)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trd = kzalloc(struct_size(rd, reg_rules, num_rules), GFP_KERNEL);\n\tif (!rd) {\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\t/*\n\t * Disable DFS master mode if the DFS region was\n\t * not supported or known on this kernel.\n\t */\n\tif (reg_supported_dfs_region(dfs_region))\n\t\trd->dfs_region = dfs_region;\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tr = nla_parse_nested_deprecated(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\t\t\t\tnl_reg_rule, reg_rule_policy,\n\t\t\t\t\t\tinfo->extack);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\tr = set_regdom(rd, REGD_SOURCE_CRDA);\n\t/* set_regdom takes ownership of rd */\n\trd = NULL;\n bad_reg:\n\tkfree(rd);\n out:\n\trtnl_unlock();\n\treturn r;\n}\n#endif /* CONFIG_CFG80211_CRDA_SUPPORT */\n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1)\n\t\tif (nla_len(attr1) != sizeof(u32))\n\t\t\treturn 0;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic bool is_band_valid(struct wiphy *wiphy, enum nl80211_band b)\n{\n\treturn b < NUM_NL80211_BANDS && wiphy->bands[b];\n}\n\nstatic int parse_bss_select(struct nlattr *nla, struct wiphy *wiphy,\n\t\t\t    struct cfg80211_bss_selection *bss_select)\n{\n\tstruct nlattr *attr[NL80211_BSS_SELECT_ATTR_MAX + 1];\n\tstruct nlattr *nest;\n\tint err;\n\tbool found = false;\n\tint i;\n\n\t/* only process one nested attribute */\n\tnest = nla_data(nla);\n\tif (!nla_ok(nest, nla_len(nest)))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attr, NL80211_BSS_SELECT_ATTR_MAX,\n\t\t\t\t\t  nest, nl80211_bss_select_policy,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\t/* only one attribute may be given */\n\tfor (i = 0; i <= NL80211_BSS_SELECT_ATTR_MAX; i++) {\n\t\tif (attr[i]) {\n\t\t\tif (found)\n\t\t\t\treturn -EINVAL;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tbss_select->behaviour = __NL80211_BSS_SELECT_ATTR_INVALID;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI])\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]) {\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_BAND_PREF;\n\t\tbss_select->param.band_pref =\n\t\t\tnla_get_u32(attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]);\n\t\tif (!is_band_valid(wiphy, bss_select->param.band_pref))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *adj_param;\n\n\t\tadj_param = nla_data(attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]);\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI_ADJUST;\n\t\tbss_select->param.adjust.band = adj_param->band;\n\t\tbss_select->param.adjust.delta = adj_param->delta;\n\t\tif (!is_band_valid(wiphy, bss_select->param.adjust.band))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* user-space did not provide behaviour attribute */\n\tif (bss_select->behaviour == __NL80211_BSS_SELECT_ATTR_INVALID)\n\t\treturn -EINVAL;\n\n\tif (!(wiphy->bss_select_support & BIT(bss_select->behaviour)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nl80211_parse_random_mac(struct nlattr **attrs,\n\t\t\t     u8 *mac_addr, u8 *mac_addr_mask)\n{\n\tint i;\n\n\tif (!attrs[NL80211_ATTR_MAC] && !attrs[NL80211_ATTR_MAC_MASK]) {\n\t\teth_zero_addr(mac_addr);\n\t\teth_zero_addr(mac_addr_mask);\n\t\tmac_addr[0] = 0x2;\n\t\tmac_addr_mask[0] = 0x3;\n\n\t\treturn 0;\n\t}\n\n\t/* need both or none */\n\tif (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_MAC_MASK])\n\t\treturn -EINVAL;\n\n\tmemcpy(mac_addr, nla_data(attrs[NL80211_ATTR_MAC]), ETH_ALEN);\n\tmemcpy(mac_addr_mask, nla_data(attrs[NL80211_ATTR_MAC_MASK]), ETH_ALEN);\n\n\t/* don't allow or configure an mcast address */\n\tif (!is_multicast_ether_addr(mac_addr_mask) ||\n\t    is_multicast_ether_addr(mac_addr))\n\t\treturn -EINVAL;\n\n\t/*\n\t * allow users to pass a MAC address that has bits set outside\n\t * of the mask, but don't bother drivers with having to deal\n\t * with such bits\n\t */\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] &= mac_addr_mask[i];\n\n\treturn 0;\n}\n\nstatic bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!cfg80211_beaconing_iface_active(wdev))\n\t\treturn true;\n\n\tif (!(wdev->chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn true;\n\n\treturn regulatory_pre_cac_allowed(wdev->wiphy);\n}\n\nstatic bool nl80211_check_scan_feat(struct wiphy *wiphy, u32 flags, u32 flag,\n\t\t\t\t    enum nl80211_ext_feature_index feat)\n{\n\tif (!(flags & flag))\n\t\treturn true;\n\tif (wiphy_ext_feature_isset(wiphy, feat))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int\nnl80211_check_scan_flags(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t void *request, struct nlattr **attrs,\n\t\t\t bool is_sched_scan)\n{\n\tu8 *mac_addr, *mac_addr_mask;\n\tu32 *flags;\n\tenum nl80211_feature_flags randomness_flag;\n\n\tif (!attrs[NL80211_ATTR_SCAN_FLAGS])\n\t\treturn 0;\n\n\tif (is_sched_scan) {\n\t\tstruct cfg80211_sched_scan_request *req = request;\n\n\t\trandomness_flag = wdev ?\n\t\t\t\t  NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR :\n\t\t\t\t  NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t} else {\n\t\tstruct cfg80211_scan_request *req = request;\n\n\t\trandomness_flag = NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t}\n\n\t*flags = nla_get_u32(attrs[NL80211_ATTR_SCAN_FLAGS]);\n\n\tif (((*flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&\n\t     !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_SPAN,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_SPAN_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_POWER,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_POWER_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_HIGH_ACCURACY,\n\t\t\t\t     NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP,\n\t\t\t\t     NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_RANDOM_SN,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_RANDOM_SN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_MIN_PREQ_CONTENT,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (*flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tint err;\n\n\t\tif (!(wiphy->features & randomness_flag) ||\n\t\t    (wdev && wdev->current_bss))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nl80211_parse_random_mac(attrs, mac_addr, mac_addr_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *scan_freqs = NULL;\n\tbool scan_freqs_khz = false;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tsize_t ie_len;\n\n\twiphy = &rdev->wiphy;\n\n\tif (wdev->iftype == NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req || rdev->scan_msg)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQ_KHZ]) {\n\t\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SCAN_FREQ_KHZ))\n\t\t\treturn -EOPNOTSUPP;\n\t\tscan_freqs = info->attrs[NL80211_ATTR_SCAN_FREQ_KHZ];\n\t\tscan_freqs_khz = true;\n\t} else if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES])\n\t\tscan_freqs = info->attrs[NL80211_ATTR_SCAN_FREQUENCIES];\n\n\tif (scan_freqs) {\n\t\tn_channels = validate_scan_freqs(scan_freqs);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (scan_freqs) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, scan_freqs, tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\t\t\tint freq = nla_get_u32(attr);\n\n\t\t\tif (!scan_freqs_khz)\n\t\t\t\tfreq = MHZ_TO_KHZ(freq);\n\n\t\t\tchan = ieee80211_get_channel_khz(wiphy, freq);\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tenum nl80211_band band;\n\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev)) {\n\t\tstruct ieee80211_channel *chan;\n\n\t\tif (request->n_channels != 1) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tchan = request->channels[0];\n\t\tif (chan->center_freq != wdev->chandef.chan->center_freq) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\trequest->rates[i] =\n\t\t\t\t(1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SUPP_RATES]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_SUPP_RATES],\n\t\t\t\t    tmp) {\n\t\t\tenum nl80211_band band = nla_type(attr);\n\n\t\t\tif (band < 0 || band >= NUM_NL80211_BANDS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\terr = ieee80211_get_ratemask(wiphy->bands[band],\n\t\t\t\t\t\t     nla_data(attr),\n\t\t\t\t\t\t     nla_len(attr),\n\t\t\t\t\t\t     &request->rates[band]);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]) {\n\t\trequest->duration =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]);\n\t\trequest->duration_mandatory =\n\t\t\tnla_get_flag(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY]);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, info->attrs,\n\t\t\t\t       false);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->no_cck =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* Initial implementation used NL80211_ATTR_MAC to set the specific\n\t * BSSID to scan for. This was problematic because that same attribute\n\t * was already used for another purpose (local random MAC address). The\n\t * NL80211_ATTR_BSSID attribute was added to fix this. For backwards\n\t * compatibility with older userspace components, also use the\n\t * NL80211_ATTR_MAC value here if it can be determined to be used for\n\t * the specific BSSID use case instead of the random MAC address\n\t * (NL80211_ATTR_SCAN_FLAGS is used to enable random MAC address use).\n\t */\n\tif (info->attrs[NL80211_ATTR_BSSID])\n\t\tmemcpy(request->bssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_BSSID]), ETH_ALEN);\n\telse if (!(request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) &&\n\t\t info->attrs[NL80211_ATTR_MAC])\n\t\tmemcpy(request->bssid, nla_data(info->attrs[NL80211_ATTR_MAC]),\n\t\t       ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(request->bssid);\n\n\trequest->wdev = wdev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->scan_start = jiffies;\n\n\trdev->scan_req = request;\n\terr = cfg80211_scan(rdev);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tnl80211_send_scan_start(rdev, wdev);\n\tif (wdev->netdev)\n\t\tdev_hold(wdev->netdev);\n\n\treturn 0;\n\n out_free:\n\trdev->scan_req = NULL;\n\tkfree(request);\n\n\treturn err;\n}\n\nstatic int nl80211_abort_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->abort_scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_msg)\n\t\treturn 0;\n\n\tif (!rdev->scan_req)\n\t\treturn -ENOENT;\n\n\trdev_abort_scan(rdev, wdev);\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_plans(struct wiphy *wiphy, int n_plans,\n\t\t\t       struct cfg80211_sched_scan_request *request,\n\t\t\t       struct nlattr **attrs)\n{\n\tint tmp, err, i = 0;\n\tstruct nlattr *attr;\n\n\tif (!attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\tu32 interval;\n\n\t\t/*\n\t\t * If scan plans are not specified,\n\t\t * %NL80211_ATTR_SCHED_SCAN_INTERVAL will be specified. In this\n\t\t * case one scan plan will be set with the specified scan\n\t\t * interval and infinite number of iterations.\n\t\t */\n\t\tinterval = nla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\t\tif (!interval)\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[0].interval =\n\t\t\tDIV_ROUND_UP(interval, MSEC_PER_SEC);\n\t\tif (!request->scan_plans[0].interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (request->scan_plans[0].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\trequest->scan_plans[0].interval =\n\t\t\t\twiphy->max_sched_scan_plan_interval;\n\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp) {\n\t\tstruct nlattr *plan[NL80211_SCHED_SCAN_PLAN_MAX + 1];\n\n\t\tif (WARN_ON(i >= n_plans))\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(plan,\n\t\t\t\t\t\t  NL80211_SCHED_SCAN_PLAN_MAX,\n\t\t\t\t\t\t  attr, nl80211_plan_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!plan[NL80211_SCHED_SCAN_PLAN_INTERVAL])\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[i].interval =\n\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_INTERVAL]);\n\t\tif (!request->scan_plans[i].interval ||\n\t\t    request->scan_plans[i].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]) {\n\t\t\trequest->scan_plans[i].iterations =\n\t\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]);\n\t\t\tif (!request->scan_plans[i].iterations ||\n\t\t\t    (request->scan_plans[i].iterations >\n\t\t\t     wiphy->max_sched_scan_plan_iterations))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (i < n_plans - 1) {\n\t\t\t/*\n\t\t\t * All scan plans but the last one must specify\n\t\t\t * a finite number of iterations\n\t\t\t */\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/*\n\t * The last scan plan must not specify the number of\n\t * iterations, it is supposed to run infinitely\n\t */\n\tif (request->scan_plans[n_plans - 1].iterations)\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_per_band_rssi(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_match_set *match_sets,\n\t\t\t\t       struct nlattr *tb_band_rssi,\n\t\t\t\t       s32 rssi_thold)\n{\n\tstruct nlattr *attr;\n\tint i, tmp, ret = 0;\n\n\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t    NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD)) {\n\t\tif (tb_band_rssi)\n\t\t\tret = -EOPNOTSUPP;\n\t\telse\n\t\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\t\t\tmatch_sets->per_band_rssi_thold[i] =\n\t\t\t\t\tNL80211_SCAN_RSSI_THOLD_OFF;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tmatch_sets->per_band_rssi_thold[i] = rssi_thold;\n\n\tnla_for_each_nested(attr, tb_band_rssi, tmp) {\n\t\tenum nl80211_band band = nla_type(attr);\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\n\t\tmatch_sets->per_band_rssi_thold[band] =\tnla_get_s32(attr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_sched_scan_request *\nnl80211_parse_sched_scan(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct nlattr **attrs, int max_match_sets)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct nlattr *attr;\n\tint err, tmp, n_ssids = 0, n_match_sets = 0, n_channels, i, n_plans = 0;\n\tenum nl80211_band band;\n\tsize_t ie_len;\n\tstruct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];\n\ts32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;\n\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tattrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_sched_scan_ssids)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * First, count the number of 'real' matchsets. Due to an issue with\n\t * the old implementation, matchsets containing only the RSSI attribute\n\t * (NL80211_SCHED_SCAN_MATCH_ATTR_RSSI) are considered as the 'default'\n\t * RSSI for all matchsets, rather than their own matchset for reporting\n\t * all APs with a strong RSSI. This is needed to be compatible with\n\t * older userspace that treated a matchset with only the RSSI as the\n\t * global RSSI for all other matchsets - if there are other matchsets.\n\t */\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\t/* SSID and BSSID are mutually exclusive */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] &&\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID])\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t/* add other standalone attributes here */\n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] ||\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID]) {\n\t\t\t\tn_match_sets++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\tdefault_match_rssi = nla_get_s32(rssi);\n\t\t}\n\t}\n\n\t/* However, if there's no other matchset, add the RSSI one */\n\tif (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)\n\t\tn_match_sets = 1;\n\n\tif (n_match_sets > max_match_sets)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_sched_scan_ie_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\t/*\n\t\t * NL80211_ATTR_SCHED_SCAN_INTERVAL must not be specified since\n\t\t * each scan plan already specifies its own interval\n\t\t */\n\t\tif (attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp)\n\t\t\tn_plans++;\n\t} else {\n\t\t/*\n\t\t * The scan interval attribute is kept for backward\n\t\t * compatibility. If no scan plans are specified and sched scan\n\t\t * interval is specified, one scan plan will be set with this\n\t\t * scan interval and infinite number of iterations.\n\t\t */\n\t\tif (!attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tn_plans = 1;\n\t}\n\n\tif (!n_plans || n_plans > wiphy->max_sched_scan_plans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!wiphy_ext_feature_isset(\n\t\t    wiphy, NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI) &&\n\t    (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] ||\n\t     attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->match_sets) * n_match_sets\n\t\t\t+ sizeof(*request->scan_plans) * n_plans\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\tif (n_match_sets) {\n\t\tif (request->ie)\n\t\t\trequest->match_sets = (void *)(request->ie + ie_len);\n\t\telse if (n_ssids)\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->channels + n_channels);\n\t}\n\trequest->n_match_sets = n_match_sets;\n\n\tif (n_match_sets)\n\t\trequest->scan_plans = (void *)(request->match_sets +\n\t\t\t\t\t       n_match_sets);\n\telse if (request->ie)\n\t\trequest->scan_plans = (void *)(request->ie + ie_len);\n\telse if (n_ssids)\n\t\trequest->scan_plans = (void *)(request->ssids + n_ssids);\n\telse\n\t\trequest->scan_plans = (void *)(request->channels + n_channels);\n\n\trequest->n_scan_plans = n_plans;\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *ssid, *bssid, *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t\tssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];\n\t\t\tbssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID];\n\n\t\t\tif (!ssid && !bssid) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON(i >= n_match_sets)) {\n\t\t\t\t/* this indicates a programming error,\n\t\t\t\t * the loop above should have verified\n\t\t\t\t * things properly\n\t\t\t\t */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (ssid) {\n\t\t\t\tmemcpy(request->match_sets[i].ssid.ssid,\n\t\t\t\t       nla_data(ssid), nla_len(ssid));\n\t\t\t\trequest->match_sets[i].ssid.ssid_len =\n\t\t\t\t\tnla_len(ssid);\n\t\t\t}\n\t\t\tif (bssid)\n\t\t\t\tmemcpy(request->match_sets[i].bssid,\n\t\t\t\t       nla_data(bssid), ETH_ALEN);\n\n\t\t\t/* special attribute - old implementation w/a */\n\t\t\trequest->match_sets[i].rssi_thold = default_match_rssi;\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\trequest->match_sets[i].rssi_thold =\n\t\t\t\t\tnla_get_s32(rssi);\n\n\t\t\t/* Parse per band RSSI attribute */\n\t\t\terr = nl80211_parse_sched_scan_per_band_rssi(wiphy,\n\t\t\t\t&request->match_sets[i],\n\t\t\t\ttb[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI],\n\t\t\t\trequest->match_sets[i].rssi_thold);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\n\t\t\ti++;\n\t\t}\n\n\t\t/* there was no other matchset, so the RSSI one is alone */\n\t\tif (i == 0 && n_match_sets)\n\t\t\trequest->match_sets[0].rssi_thold = default_match_rssi;\n\n\t\trequest->min_rssi_thold = INT_MAX;\n\t\tfor (i = 0; i < n_match_sets; i++)\n\t\t\trequest->min_rssi_thold =\n\t\t\t\tmin(request->match_sets[i].rssi_thold,\n\t\t\t\t    request->min_rssi_thold);\n\t} else {\n\t\trequest->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;\n\t}\n\n\tif (ie_len) {\n\t\trequest->ie_len = ie_len;\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, attrs, true);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_DELAY])\n\t\trequest->delay =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_DELAY]);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]) {\n\t\trequest->relative_rssi = nla_get_s8(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]);\n\t\trequest->relative_rssi_set = true;\n\t}\n\n\tif (request->relative_rssi_set &&\n\t    attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *rssi_adjust;\n\n\t\trssi_adjust = nla_data(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]);\n\t\trequest->rssi_adjust.band = rssi_adjust->band;\n\t\trequest->rssi_adjust.delta = rssi_adjust->delta;\n\t\tif (!is_band_valid(wiphy, request->rssi_adjust.band)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = nl80211_parse_sched_scan_plans(wiphy, n_plans, request, attrs);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->scan_start = jiffies;\n\n\treturn request;\n\nout_free:\n\tkfree(request);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tbool want_multi;\n\tint err;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\twant_multi = info->attrs[NL80211_ATTR_SCHED_SCAN_MULTI];\n\terr = cfg80211_sched_scan_req_possible(rdev, want_multi);\n\tif (err)\n\t\treturn err;\n\n\tsched_scan_req = nl80211_parse_sched_scan(&rdev->wiphy, wdev,\n\t\t\t\t\t\t  info->attrs,\n\t\t\t\t\t\t  rdev->wiphy.max_match_sets);\n\n\terr = PTR_ERR_OR_ZERO(sched_scan_req);\n\tif (err)\n\t\tgoto out_err;\n\n\t/* leave request id zero for legacy request\n\t * or if driver does not support multi-scheduled scan\n\t */\n\tif (want_multi && rdev->wiphy.max_sched_scan_reqs > 1)\n\t\tsched_scan_req->reqid = cfg80211_assign_cookie(rdev);\n\n\terr = rdev_sched_scan_start(rdev, dev, sched_scan_req);\n\tif (err)\n\t\tgoto out_free;\n\n\tsched_scan_req->dev = dev;\n\tsched_scan_req->wiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tsched_scan_req->owner_nlportid = info->snd_portid;\n\n\tcfg80211_add_sched_scan_req(rdev, sched_scan_req);\n\n\tnl80211_send_sched_scan(sched_scan_req, NL80211_CMD_START_SCHED_SCAN);\n\treturn 0;\n\nout_free:\n\tkfree(sched_scan_req);\nout_err:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *req;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tu64 cookie;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_COOKIE]) {\n\t\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\t\treturn __cfg80211_stop_sched_scan(rdev, cookie, false);\n\t}\n\n\treq = list_first_or_null_rcu(&rdev->sched_scan_req_list,\n\t\t\t\t     struct cfg80211_sched_scan_request,\n\t\t\t\t     list);\n\tif (!req || req->reqid ||\n\t    (req->owner_nlportid &&\n\t     req->owner_nlportid != info->snd_portid))\n\t\treturn -ENOENT;\n\n\treturn cfg80211_stop_sched_scan_req(rdev, req, false);\n}\n\nstatic int nl80211_start_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tunsigned int cac_time_ms;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (netif_carrier_ok(dev))\n\t\treturn -EBUSY;\n\n\tif (wdev->cac_started)\n\t\treturn -EBUSY;\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err == 0)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_chandef_dfs_usable(wiphy, &chandef))\n\t\treturn -EINVAL;\n\n\t/* CAC start is offloaded to HW and can't be started manually */\n\tif (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_radar_detection)\n\t\treturn -EOPNOTSUPP;\n\n\tcac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);\n\tif (WARN_ON(!cac_time_ms))\n\t\tcac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\n\terr = rdev_start_radar_detection(rdev, dev, &chandef, cac_time_ms);\n\tif (!err) {\n\t\twdev->chandef = chandef;\n\t\twdev->cac_started = true;\n\t\twdev->cac_start_time = jiffies;\n\t\twdev->cac_time_ms = cac_time_ms;\n\t}\n\treturn err;\n}\n\nstatic int nl80211_notify_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"DFS Region is not set. Unexpected Radar indication\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err) {\n\t\tGENL_SET_ERR_MSG(info, \"Unable to extract chandef info\");\n\t\treturn err;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"chandef is invalid\");\n\t\treturn err;\n\t}\n\n\tif (err == 0) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"Unexpected Radar indication for chandef/iftype\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do not process this notification if radar is already detected\n\t * by kernel on this channel, and return success.\n\t */\n\tif (chandef.chan->dfs_state == NL80211_DFS_UNAVAILABLE)\n\t\treturn 0;\n\n\tcfg80211_set_dfs_state(wiphy, &chandef, NL80211_DFS_UNAVAILABLE);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\trdev->radar_chandef = chandef;\n\n\t/* Propagate this notification to other radios as well */\n\tqueue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);\n\n\treturn 0;\n}\n\nstatic int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_csa_settings params;\n\tstruct nlattr **csa_attrs = NULL;\n\tint err;\n\tbool need_new_beacon = false;\n\tbool need_handle_dfs_flag = true;\n\tint len, i;\n\tu32 cs_count;\n\n\tif (!rdev->ops->channel_switch ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tneed_new_beacon = true;\n\t\t/* For all modes except AP the handle_dfs flag needs to be\n\t\t * supplied to tell the kernel that userspace will handle radar\n\t\t * events when they happen. Otherwise a switch to a channel\n\t\t * requiring DFS will be rejected.\n\t\t */\n\t\tneed_handle_dfs_flag = false;\n\n\t\t/* useless if AP is not running */\n\t\tif (!wdev->beacon_interval)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->ssid_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!wdev->mesh_id_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.beacon_csa.ftm_responder = -1;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_CH_SWITCH_COUNT])\n\t\treturn -EINVAL;\n\n\t/* only important for AP, IBSS and mesh create IEs internally */\n\tif (need_new_beacon && !info->attrs[NL80211_ATTR_CSA_IES])\n\t\treturn -EINVAL;\n\n\t/* Even though the attribute is u32, the specification says\n\t * u8, so let's make sure we don't overflow.\n\t */\n\tcs_count = nla_get_u32(info->attrs[NL80211_ATTR_CH_SWITCH_COUNT]);\n\tif (cs_count > 255)\n\t\treturn -EINVAL;\n\n\tparams.count = cs_count;\n\n\tif (!need_new_beacon)\n\t\tgoto skip_beacons;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_after);\n\tif (err)\n\t\treturn err;\n\n\tcsa_attrs = kcalloc(NL80211_ATTR_MAX + 1, sizeof(*csa_attrs),\n\t\t\t    GFP_KERNEL);\n\tif (!csa_attrs)\n\t\treturn -ENOMEM;\n\n\terr = nla_parse_nested_deprecated(csa_attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_CSA_IES],\n\t\t\t\t\t  nl80211_policy, info->extack);\n\tif (err)\n\t\tgoto free;\n\n\terr = nl80211_parse_beacon(rdev, csa_attrs, &params.beacon_csa);\n\tif (err)\n\t\tgoto free;\n\n\tif (!csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = nla_len(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\tif (!len || (len % sizeof(u16))) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tparams.n_counter_offsets_beacon = len / sizeof(u16);\n\tif (rdev->wiphy.max_num_csa_counters &&\n\t    (params.n_counter_offsets_beacon >\n\t     rdev->wiphy.max_num_csa_counters)) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tparams.counter_offsets_beacon =\n\t\tnla_data(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\n\t/* sanity checks - counters should fit and be the same */\n\tfor (i = 0; i < params.n_counter_offsets_beacon; i++) {\n\t\tu16 offset = params.counter_offsets_beacon[i];\n\n\t\tif (offset >= params.beacon_csa.tail_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (params.beacon_csa.tail[offset] != params.count) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]) {\n\t\tlen = nla_len(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\t\tif (!len || (len % sizeof(u16))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tparams.n_counter_offsets_presp = len / sizeof(u16);\n\t\tif (rdev->wiphy.max_num_csa_counters &&\n\t\t    (params.n_counter_offsets_presp >\n\t\t     rdev->wiphy.max_num_csa_counters)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tparams.counter_offsets_presp =\n\t\t\tnla_data(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\n\t\t/* sanity checks - counters should fit and be the same */\n\t\tfor (i = 0; i < params.n_counter_offsets_presp; i++) {\n\t\t\tu16 offset = params.counter_offsets_presp[i];\n\n\t\t\tif (offset >= params.beacon_csa.probe_resp_len) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (params.beacon_csa.probe_resp[offset] !=\n\t\t\t    params.count) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t}\n\t}\n\nskip_beacons:\n\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\tif (err)\n\t\tgoto free;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype)) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wdev->wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    wdev->iftype);\n\tif (err < 0)\n\t\tgoto free;\n\n\tif (err > 0) {\n\t\tparams.radar_required = true;\n\t\tif (need_handle_dfs_flag &&\n\t\t    !nla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS])) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CH_SWITCH_BLOCK_TX])\n\t\tparams.block_tx = true;\n\n\twdev_lock(wdev);\n\terr = rdev_channel_switch(rdev, dev, &params);\n\twdev_unlock(wdev);\n\nfree:\n\tkfree(csa_attrs);\n\treturn err;\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t    u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tconst struct cfg80211_bss_ies *ies;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation))\n\t\tgoto nla_put_failure;\n\tif (wdev->netdev &&\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tbss = nla_nest_start_noflag(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif ((!is_zero_ether_addr(res->bssid) &&\n\t     nla_put(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid)))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\t/* indicate whether we have probe response data or not */\n\tif (rcu_access_pointer(res->proberesp_ies) &&\n\t    nla_put_flag(msg, NL80211_BSS_PRESP_DATA))\n\t\tgoto fail_unlock_rcu;\n\n\t/* this pointer prefers to be pointed to probe response data\n\t * but is always valid\n\t */\n\ties = rcu_dereference(res->ies);\n\tif (ies) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\n\t/* and this pointer is always (unless driver didn't know) beacon data */\n\ties = rcu_dereference(res->beacon_ies);\n\tif (ies && ies->from_beacon) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_BEACON_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_BEACON_IES,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tif (res->beacon_interval &&\n\t    nla_put_u16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, NL80211_BSS_CAPABILITY, res->capability) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY_OFFSET,\n\t\t\tres->channel->freq_offset) ||\n\t    nla_put_u32(msg, NL80211_BSS_CHAN_WIDTH, res->scan_width) ||\n\t    nla_put_u32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\t\tjiffies_to_msecs(jiffies - intbss->ts)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->parent_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_BSS_PARENT_TSF,\n\t\t\t       intbss->parent_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_BSS_PARENT_BSSID, ETH_ALEN,\n\t\t     intbss->parent_bssid)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->ts_boottime &&\n\t    nla_put_u64_64bit(msg, NL80211_BSS_LAST_SEEN_BOOTTIME,\n\t\t\t      intbss->ts_boottime, NL80211_BSS_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_put_signal(msg, intbss->pub.chains,\n\t\t\t\tintbss->pub.chain_signal,\n\t\t\t\tNL80211_BSS_CHAIN_SIGNAL))\n\t\tgoto nla_put_failure;\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tif (nla_put_u32(msg, NL80211_BSS_SIGNAL_MBM, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tif (nla_put_u8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_ASSOCIATED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_IBSS_JOINED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n fail_unlock_rcu:\n\trcu_read_unlock();\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[2], idx = 0;\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (err)\n\t\treturn err;\n\t/* nl80211_prepare_wdev_dump acquired it in the successful case */\n\t__acquire(&rdev->wiphy.mtx);\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\n\t/*\n\t * dump_scan will be called multiple times to break up the scan results\n\t * into multiple messages.  It is unlikely that any more bss-es will be\n\t * expired after the first call, so only call only call this on the\n\t * first dump_scan invocation.\n\t */\n\tif (start == 0)\n\t\tcfg80211_bss_expire(rdev);\n\n\tcb->seq = rdev->bss_generation;\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb, cb,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[2] = idx;\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       int flags, struct net_device *dev,\n\t\t\t       bool allow_radio_stats,\n\t\t\t       struct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t/* skip radio stats if userspace didn't request them */\n\tif (!survey->channel && !allow_radio_stats)\n\t\treturn 0;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t\tsurvey->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel && survey->channel->freq_offset &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY_OFFSET,\n\t\t\tsurvey->channel->freq_offset))\n\t\tgoto nla_put_failure;\n\n\tif ((survey->filled & SURVEY_INFO_NOISE_DBM) &&\n\t    nla_put_u8(msg, NL80211_SURVEY_INFO_NOISE, survey->noise))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_IN_USE) &&\n\t    nla_put_flag(msg, NL80211_SURVEY_INFO_IN_USE))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME,\n\t\t\tsurvey->time, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BUSY,\n\t\t\t      survey->time_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_EXT_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,\n\t\t\t      survey->time_ext_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_RX,\n\t\t\t      survey->time_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_TX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_TX,\n\t\t\t      survey->time_tx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_SCAN) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,\n\t\t\t      survey->time_scan, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BSS_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BSS_RX,\n\t\t\t      survey->time_bss_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, infoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr **attrbuf;\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint survey_idx = cb->args[2];\n\tint res;\n\tbool radio_stats;\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\tres = nl80211_prepare_wdev_dump(cb, &rdev, &wdev);\n\tif (res) {\n\t\tkfree(attrbuf);\n\t\treturn res;\n\t}\n\t/* nl80211_prepare_wdev_dump acquired it in the successful case */\n\t__acquire(&rdev->wiphy.mtx);\n\n\t/* prepare_wdev_dump parsed the attributes */\n\tradio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];\n\n\tif (!wdev->netdev) {\n\t\tres = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tres = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\t/* don't send disabled channels, but do send non-channel data */\n\t\tif (survey.channel &&\n\t\t    survey.channel->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\twdev->netdev, radio_stats, &survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[2] = survey_idx;\n\tres = skb->len;\n out_err:\n\tkfree(attrbuf);\n\twiphy_unlock(&rdev->wiphy);\n\treturn res;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2 |\n\t\t\t\t  NL80211_WPA_VERSION_3));\n}\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid, *ie = NULL, *auth_data = NULL;\n\tint err, ssid_len, ie_len = 0, auth_data_len = 0;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\tu32 freq;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 3)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tfreq = MHZ_TO_KHZ(nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tchan = nl80211_get_valid_chan(&rdev->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(rdev, auth_type, NL80211_CMD_AUTHENTICATE))\n\t\treturn -EINVAL;\n\n\tif ((auth_type == NL80211_AUTHTYPE_SAE ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_PK) &&\n\t    !info->attrs[NL80211_ATTR_AUTH_DATA])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_DATA]) {\n\t\tif (auth_type != NL80211_AUTHTYPE_SAE &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK_PFS &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn -EINVAL;\n\t\tauth_data = nla_data(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\tauth_data_len = nla_len(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\t/*\n\t * Since we no longer track auth state, ignore\n\t * requests to only change local state.\n\t */\n\tif (local_state_change)\n\t\treturn 0;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_auth(rdev, dev, chan, auth_type, bssid,\n\t\t\t\t ssid, ssid_len, ie, ie_len,\n\t\t\t\t key.p.key, key.p.key_len, key.idx,\n\t\t\t\t auth_data, auth_data_len);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int validate_pae_over_nl80211(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct genl_info *info)\n{\n\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tGENL_SET_ERR_MSG(info, \"SOCKET_OWNER not set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->tx_control_port ||\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsettings->control_port_over_nl80211 = true;\n\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH])\n\t\t\tsettings->control_port_no_preauth = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!cfg80211_supported_cipher_suite(\n\t\t\t\t\t&rdev->wiphy,\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!cfg80211_supported_cipher_suite(&rdev->wiphy,\n\t\t\t\t\t\t     settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_akm_suites > NL80211_MAX_NR_AKM_SUITES)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tif (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN)\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK))\n\t\t\treturn -EINVAL;\n\t\tsettings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PASSWORD]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP))\n\t\t\treturn -EINVAL;\n\t\tsettings->sae_pwd =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t\tsettings->sae_pwd_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PWE])\n\t\tsettings->sae_pwe =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SAE_PWE]);\n\telse\n\t\tsettings->sae_pwe = NL80211_SAE_PWE_UNSPECIFIED;\n\n\treturn 0;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tstruct cfg80211_assoc_request req = {};\n\tconst u8 *bssid, *ssid;\n\tint err, ssid_len = 0;\n\tu32 freq;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_SSID] ||\n\t    !info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tfreq = MHZ_TO_KHZ(nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\tchan = nl80211_get_valid_chan(&rdev->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\treq.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\treq.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\treq.use_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\treq.prev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&req.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(req.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(req.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HE]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HE;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&req.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(req.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(req.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM))\n\t\t\treturn -EINVAL;\n\t\treq.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_KEK]) {\n\t\treq.fils_kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\treq.fils_kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\tif (!info->attrs[NL80211_ATTR_FILS_NONCES])\n\t\t\treturn -EINVAL;\n\t\treq.fils_nonces =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK]) {\n\t\tif (!info->attrs[NL80211_ATTR_S1G_CAPABILITY])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.s1g_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK]),\n\t\t       sizeof(req.s1g_capa_mask));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_S1G_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.s1g_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_S1G_CAPABILITY]),\n\t\t       sizeof(req.s1g_capa));\n\t}\n\n\terr = nl80211_crypto_settings(rdev, info, &req.crypto, 1);\n\tif (!err) {\n\t\twdev_lock(dev->ieee80211_ptr);\n\n\t\terr = cfg80211_mlme_assoc(rdev, dev, chan, bssid,\n\t\t\t\t\t  ssid, ssid_len, &req);\n\n\t\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tdev->ieee80211_ptr->conn_owner_nlportid =\n\t\t\t\tinfo->snd_portid;\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       bssid, ETH_ALEN);\n\t\t}\n\n\t\twdev_unlock(dev->ieee80211_ptr);\n\t}\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t   local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t/* Reason Code 0 is reserved */\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t     local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[NUM_NL80211_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL])\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\terr = cfg80211_validate_beacon_int(rdev, NL80211_IFTYPE_ADHOC,\n\t\t\t\t\t   ibss.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!is_valid_ether_addr(ibss.bssid))\n\t\t\treturn -EINVAL;\n\t}\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &ibss.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tswitch (ibss.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_VHT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &ibss.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&ibss.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(ibss.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&ibss.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(ibss.ht_capa));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tbool no_ht = false;\n\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, &no_ht);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\n\t\tif ((ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT) &&\n\t\t    no_ht) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tibss.control_port =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn r;\n\t\t}\n\n\t\tibss.control_port_over_nl80211 = true;\n\t}\n\n\tibss.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree_sensitive(connkeys);\n\telse if (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\nstatic int nl80211_set_mcast_rate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 nla_rate;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_OCB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->set_mcast_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(mcast_rate, 0, sizeof(mcast_rate));\n\n\tif (!info->attrs[NL80211_ATTR_MCAST_RATE])\n\t\treturn -EINVAL;\n\n\tnla_rate = nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE]);\n\tif (!nl80211_parse_mcast_rate(rdev, mcast_rate, nla_rate))\n\t\treturn -EINVAL;\n\n\terr = rdev_set_mcast_rate(rdev, dev, mcast_rate);\n\n\treturn err;\n}\n\nstatic struct sk_buff *\n__cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev, int approxlen,\n\t\t\t    u32 portid, u32 seq, enum nl80211_commands cmd,\n\t\t\t    enum nl80211_attrs attr,\n\t\t\t    const struct nl80211_vendor_cmd_info *info,\n\t\t\t    gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, portid, seq, 0, cmd);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (info) {\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,\n\t\t\t\tinfo->vendor_id))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,\n\t\t\t\tinfo->subcmd))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (wdev) {\n\t\tif (nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t      wdev_id(wdev), NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tif (wdev->netdev &&\n\t\t    nla_put_u32(skb, NL80211_ATTR_IFINDEX,\n\t\t\t\twdev->netdev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tdata = nla_nest_start_noflag(skb, attr);\n\tif (!data)\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct nl80211_vendor_cmd_info *info;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_TESTMODE:\n\t\tif (WARN_ON(vendor_event_idx != -1))\n\t\t\treturn NULL;\n\t\tinfo = NULL;\n\t\tbreak;\n\tcase NL80211_CMD_VENDOR:\n\t\tif (WARN_ON(vendor_event_idx < 0 ||\n\t\t\t    vendor_event_idx >= wiphy->n_vendor_events))\n\t\t\treturn NULL;\n\t\tinfo = &wiphy->vendor_events[vendor_event_idx];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, wdev, approxlen, portid, 0,\n\t\t\t\t\t   cmd, attr, info, gfp);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_event_skb);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlmsghdr *nlhdr = nlmsg_hdr(skb);\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\tenum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\n\tif (nlhdr->nlmsg_pid) {\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), skb,\n\t\t\t\tnlhdr->nlmsg_pid);\n\t} else {\n\t\tif (data->nla_type == NL80211_ATTR_VENDOR_DATA)\n\t\t\tmcgrp = NL80211_MCGRP_VENDOR;\n\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tskb, 0, mcgrp, gfp);\n\t}\n}\nEXPORT_SYMBOL(__cfg80211_send_event_skb);\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\twdev = __cfg80211_wdev_from_attrs(rdev, genl_info_net(info),\n\t\t\t\t\t  info->attrs);\n\n\tif (!rdev->ops->testmode_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_testmode_cmd(rdev, wdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\trdev->cur_cmd_info = NULL;\n\n\treturn err;\n}\n\nstatic int nl80211_testmode_dump(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct nlattr **attrbuf = NULL;\n\tint err;\n\tlong phy_idx;\n\tvoid *data = NULL;\n\tint data_len = 0;\n\n\trtnl_lock();\n\n\tif (cb->args[0]) {\n\t\t/*\n\t\t * 0 is a valid index, but not valid for args[0],\n\t\t * so we need to offset by 1.\n\t\t */\n\t\tphy_idx = cb->args[0] - 1;\n\n\t\trdev = cfg80211_rdev_by_wiphy_idx(phy_idx);\n\t\tif (!rdev) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\trdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto out_err;\n\t\t}\n\t\tphy_idx = rdev->wiphy_idx;\n\n\t\tif (attrbuf[NL80211_ATTR_TESTDATA])\n\t\t\tcb->args[1] = (long)attrbuf[NL80211_ATTR_TESTDATA];\n\t}\n\n\tif (cb->args[1]) {\n\t\tdata = nla_data((void *)cb->args[1]);\n\t\tdata_len = nla_len((void *)cb->args[1]);\n\t}\n\n\tif (!rdev->ops->testmode_dump) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_TESTMODE);\n\t\tstruct nlattr *tmdata;\n\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, phy_idx)) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\ttmdata = nla_nest_start_noflag(skb, NL80211_ATTR_TESTDATA);\n\t\tif (!tmdata) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\t\terr = rdev_testmode_dump(rdev, skb, cb, data, data_len);\n\t\tnla_nest_end(skb, tmdata);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n\t/* see above */\n\tcb->args[0] = phy_idx + 1;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn err;\n}\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tu32 freq = 0;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, connect.auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EINVAL;\n\tconnect.want_1x = info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tconnect.bg_scan_period = -1;\n\tif (info->attrs[NL80211_ATTR_BG_SCAN_PERIOD] &&\n\t\t(wiphy->flags & WIPHY_FLAG_SUPPORTS_FW_ROAM)) {\n\t\tconnect.bg_scan_period =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BG_SCAN_PERIOD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\telse if (info->attrs[NL80211_ATTR_MAC_HINT])\n\t\tconnect.bssid_hint =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC_HINT]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tconnect.mfp = nla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (connect.mfp == NL80211_MFP_OPTIONAL &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_MFP_OPTIONAL))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tconnect.mfp = NL80211_MFP_NO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tconnect.prev_bssid =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\tfreq = MHZ_TO_KHZ(nla_get_u32(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tif (freq) {\n\t\tconnect.channel = nl80211_get_valid_chan(wiphy, freq);\n\t\tif (!connect.channel)\n\t\t\treturn -EINVAL;\n\t} else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {\n\t\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]);\n\t\tfreq = MHZ_TO_KHZ(freq);\n\t\tconnect.channel_hint = nl80211_get_valid_chan(wiphy, freq);\n\t\tif (!connect.channel_hint)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tconnect.edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tconnect.edmg.bw_config =\n\t\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, NULL);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(connect.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HE]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HE;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(connect.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM)) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tconnect.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (connect.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {\n\t\tkfree_sensitive(connkeys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_SELECT]) {\n\t\t/* bss selection makes no sense if bssid is set */\n\t\tif (connect.bssid) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = parse_bss_select(info->attrs[NL80211_ATTR_BSS_SELECT],\n\t\t\t\t       wiphy, &connect.bss_select);\n\t\tif (err) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tkfree_sensitive(connkeys);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])) {\n\t\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"external auth requires connection ownership\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= CONNECT_REQ_EXTERNAL_AUTH_SUPPORT;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys,\n\t\t\t       connect.prev_bssid);\n\tif (err)\n\t\tkfree_sensitive(connkeys);\n\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\t\tif (connect.bssid)\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       connect.bssid, ETH_ALEN);\n\t\telse\n\t\t\teth_zero_addr(dev->ieee80211_ptr->disconnect_bssid);\n\t}\n\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_update_connect_params(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_connect_params connect = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool fils_sk_offload;\n\tu32 auth_type;\n\tu32 changed = 0;\n\tint ret;\n\n\tif (!rdev->ops->update_connect_params)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tchanged |= UPDATE_ASSOC_IES;\n\t}\n\n\tfils_sk_offload = wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t\t  NL80211_EXT_FEATURE_FILS_SK_OFFLOAD);\n\n\t/*\n\t * when driver supports fils-sk offload all attributes must be\n\t * provided. So the else covers \"fils-sk-not-all\" and\n\t * \"no-fils-sk-any\".\n\t */\n\tif (fils_sk_offload &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tchanged |= UPDATE_FILS_ERP_INFO;\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK &&\n\t\t    fils_sk_offload && !(changed & UPDATE_FILS_ERP_INFO))\n\t\t\treturn -EINVAL;\n\n\t\tconnect.auth_type = auth_type;\n\t\tchanged |= UPDATE_AUTH_TYPE;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (!wdev->current_bss)\n\t\tret = -ENOLINK;\n\telse\n\t\tret = rdev_update_connect_params(rdev, dev, &connect, changed);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tint ret;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = cfg80211_disconnect(rdev, dev, reason, true);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn ret;\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_PID]) {\n\t\tu32 pid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\t\tnet = get_net_ns_by_pid(pid);\n\t} else if (info->attrs[NL80211_ATTR_NETNS_FD]) {\n\t\tu32 fd = nla_get_u32(info->attrs[NL80211_ATTR_NETNS_FD]);\n\n\t\tnet = get_net_ns_by_fd(fd);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t/* check if anything to do */\n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t} else if (info->attrs[NL80211_ATTR_SSID] &&\n\t\t   info->attrs[NL80211_ATTR_FILS_CACHE_ID] &&\n\t\t   (info->genlhdr->cmd == NL80211_CMD_DEL_PMKSA ||\n\t\t    info->attrs[NL80211_ATTR_PMK])) {\n\t\tpmksa.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.cache_id =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_CACHE_ID]);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tpmksa.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t\tpmksa.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK_LIFETIME])\n\t\tpmksa.pmk_lifetime =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_PMK_LIFETIME]);\n\n\tif (info->attrs[NL80211_ATTR_PMK_REAUTH_THRESHOLD])\n\t\tpmksa.pmk_reauth_threshold =\n\t\t\tnla_get_u8(\n\t\t\t\tinfo->attrs[NL80211_ATTR_PMK_REAUTH_THRESHOLD]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    !(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP &&\n\t      wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AP_PMKSA_CACHING)))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_flush_pmksa(rdev, dev);\n}\n\nstatic int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 action_code, dialog_token;\n\tu32 peer_capability = 0;\n\tu16 status_code;\n\tu8 *peer;\n\tbool initiator;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_ACTION] ||\n\t    !info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN] ||\n\t    !info->attrs[NL80211_ATTR_IE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\taction_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);\n\tstatus_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tdialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);\n\tinitiator = nla_get_flag(info->attrs[NL80211_ATTR_TDLS_INITIATOR]);\n\tif (info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY])\n\t\tpeer_capability =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY]);\n\n\treturn rdev_tdls_mgmt(rdev, dev, peer, action_code,\n\t\t\t      dialog_token, status_code, peer_capability,\n\t\t\t      initiator,\n\t\t\t      nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t\t      nla_len(info->attrs[NL80211_ATTR_IE]));\n}\n\nstatic int nl80211_tdls_oper(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tenum nl80211_tdls_operation operation;\n\tu8 *peer;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_oper)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_OPERATION] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\toperation = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_OPERATION]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treturn rdev_tdls_oper(rdev, dev, peer, operation);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tconst struct cfg80211_chan_def *compat_chandef;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tu32 duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\tif (!rdev->ops->remain_on_channel ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * We should be on that channel for at least a minimum amount of\n\t * time (10ms) but no longer than the driver supports.\n\t */\n\tif (duration < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev) &&\n\t    !cfg80211_chandef_identical(&wdev->chandef, &chandef)) {\n\t\tcompat_chandef = cfg80211_chandef_compatible(&wdev->chandef,\n\t\t\t\t\t\t\t     &chandef);\n\t\tif (compat_chandef != &chandef) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev_remain_on_channel(rdev, wdev, chandef.chan,\n\t\t\t\t     duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_cancel_remain_on_channel(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_bitrate_mask mask;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t    NL80211_ATTR_TX_RATES, &mask,\n\t\t\t\t\t    dev, true);\n\tif (err)\n\t\treturn err;\n\n\treturn rdev_set_bitrate_mask(rdev, dev, NULL, &mask);\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* not much point in registering if we can't reply */\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_RECEIVE_MULTICAST] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS)) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"multicast RX registrations are not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn cfg80211_mlme_register_mgmt(wdev, info->snd_portid, frame_type,\n\t\t\t\t\t   nla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\t\t\t   nla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\t\t\t   info->attrs[NL80211_ATTR_RECEIVE_MULTICAST],\n\t\t\t\t\t   info->extack);\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t/*\n\t\t * We should wait on the channel for at least a minimum amount\n\t\t * of time (10ms) but no longer than the driver supports.\n\t\t */\n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t/* get the channel if any has been specified, otherwise pass NULL to\n\t * the driver. The latter will use the current one\n\t */\n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!chandef.chan && params.offchan)\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (params.offchan && !cfg80211_off_channel_oper_allowed(wdev)) {\n\t\twdev_unlock(wdev);\n\t\treturn -EBUSY;\n\t}\n\twdev_unlock(wdev);\n\n\tparams.buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tparams.len = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]) {\n\t\tint len = nla_len(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\t\tint i;\n\n\t\tif (len % sizeof(u16))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_csa_offsets = len / sizeof(u16);\n\t\tparams.csa_offsets =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\n\t\t/* check that all the offsets fit the frame */\n\t\tfor (i = 0; i < params.n_csa_offsets; i++) {\n\t\t\tif (params.csa_offsets[i] >= params.len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!params.dont_wait_for_ack) {\n\t\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t     NL80211_CMD_FRAME);\n\t\tif (!hdr) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto free_msg;\n\t\t}\n\t}\n\n\tparams.chan = chandef.chan;\n\terr = cfg80211_mlme_mgmt_tx(rdev, wdev, &params, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (msg) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t\treturn genlmsg_reply(msg, info);\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_mgmt_tx_cancel_wait(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PS_STATE, ps_state))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic const struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_PKTS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_INTVL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_LEVEL] = { .type = NLA_S32 },\n};\n\nstatic int nl80211_set_cqm_txe(struct genl_info *info,\n\t\t\t       u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (rate > 100 || intvl > NL80211_CQM_TXE_MAX_INTVL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_cqm_txe_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_set_cqm_txe_config(rdev, dev, rate, pkts, intvl);\n}\n\nstatic int cfg80211_cqm_rssi_update(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\ts32 last, low, high;\n\tu32 hyst;\n\tint i, n, low_index;\n\tint err;\n\n\t/* RSSI reporting disabled? */\n\tif (!wdev->cqm_config)\n\t\treturn rdev_set_cqm_rssi_range_config(rdev, dev, 0, 0);\n\n\t/*\n\t * Obtain current RSSI value if possible, if not and no RSSI threshold\n\t * event has been received yet, we should receive an event after a\n\t * connection is established and enough beacons received to calculate\n\t * the average.\n\t */\n\tif (!wdev->cqm_config->last_rssi_event_value && wdev->current_bss &&\n\t    rdev->ops->get_station) {\n\t\tstruct station_info sinfo = {};\n\t\tu8 *mac_addr;\n\n\t\tmac_addr = wdev->current_bss->pub.bssid;\n\n\t\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG))\n\t\t\twdev->cqm_config->last_rssi_event_value =\n\t\t\t\t(s8) sinfo.rx_beacon_signal_avg;\n\t}\n\n\tlast = wdev->cqm_config->last_rssi_event_value;\n\thyst = wdev->cqm_config->rssi_hyst;\n\tn = wdev->cqm_config->n_rssi_thresholds;\n\n\tfor (i = 0; i < n; i++) {\n\t\ti = array_index_nospec(i, n);\n\t\tif (last < wdev->cqm_config->rssi_thresholds[i])\n\t\t\tbreak;\n\t}\n\n\tlow_index = i - 1;\n\tif (low_index >= 0) {\n\t\tlow_index = array_index_nospec(low_index, n);\n\t\tlow = wdev->cqm_config->rssi_thresholds[low_index] - hyst;\n\t} else {\n\t\tlow = S32_MIN;\n\t}\n\tif (i < n) {\n\t\ti = array_index_nospec(i, n);\n\t\thigh = wdev->cqm_config->rssi_thresholds[i] + hyst - 1;\n\t} else {\n\t\thigh = S32_MAX;\n\t}\n\n\treturn rdev_set_cqm_rssi_range_config(rdev, dev, low, high);\n}\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\tconst s32 *thresholds, int n_thresholds,\n\t\t\t\tu32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint i, err;\n\ts32 prev = S32_MIN;\n\n\t/* Check all values negative and sorted */\n\tfor (i = 0; i < n_thresholds; i++) {\n\t\tif (thresholds[i] > 0 || thresholds[i] <= prev)\n\t\t\treturn -EINVAL;\n\n\t\tprev = thresholds[i];\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\tcfg80211_cqm_config_free(wdev);\n\twdev_unlock(wdev);\n\n\tif (n_thresholds <= 1 && rdev->ops->set_cqm_rssi_config) {\n\t\tif (n_thresholds == 0 || thresholds[0] == 0) /* Disabling */\n\t\t\treturn rdev_set_cqm_rssi_config(rdev, dev, 0, 0);\n\n\t\treturn rdev_set_cqm_rssi_config(rdev, dev,\n\t\t\t\t\t\tthresholds[0], hysteresis);\n\t}\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CQM_RSSI_LIST))\n\t\treturn -EOPNOTSUPP;\n\n\tif (n_thresholds == 1 && thresholds[0] == 0) /* Disabling */\n\t\tn_thresholds = 0;\n\n\twdev_lock(wdev);\n\tif (n_thresholds) {\n\t\tstruct cfg80211_cqm_config *cqm_config;\n\n\t\tcqm_config = kzalloc(sizeof(struct cfg80211_cqm_config) +\n\t\t\t\t     n_thresholds * sizeof(s32), GFP_KERNEL);\n\t\tif (!cqm_config) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcqm_config->rssi_hyst = hysteresis;\n\t\tcqm_config->n_rssi_thresholds = n_thresholds;\n\t\tmemcpy(cqm_config->rssi_thresholds, thresholds,\n\t\t       n_thresholds * sizeof(s32));\n\n\t\twdev->cqm_config = cqm_config;\n\t}\n\n\terr = cfg80211_cqm_rssi_update(rdev, dev);\n\nunlock:\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t\t\t  nl80211_attr_cqm_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\tconst s32 *thresholds =\n\t\t\tnla_data(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tint len = nla_len(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tu32 hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\n\t\tif (len % 4)\n\t\t\treturn -EINVAL;\n\n\t\treturn nl80211_set_cqm_rssi(info, thresholds, len / 4,\n\t\t\t\t\t    hysteresis);\n\t}\n\n\tif (attrs[NL80211_ATTR_CQM_TXE_RATE] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_PKTS] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_INTVL]) {\n\t\tu32 rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);\n\t\tu32 pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);\n\t\tu32 intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);\n\n\t\treturn nl80211_set_cqm_txe(info, rate, pkts, intvl);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl80211_join_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ocb_setup setup = {};\n\tint err;\n\n\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\tif (err)\n\t\treturn err;\n\n\treturn cfg80211_join_ocb(rdev, dev, &setup);\n}\n\nstatic int nl80211_leave_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_ocb(rdev, dev);\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t/* start with default */\n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t/* and parse parameters if given */\n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, setup.mcast_rate,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tsetup.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev,\n\t\t\t\t\t\t   NL80211_IFTYPE_MESH_POINT,\n\t\t\t\t\t\t   setup.beacon_interval);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DTIM_PERIOD]) {\n\t\tsetup.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\t\tif (setup.dtim_period < 1 || setup.dtim_period > 100)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t/* parse additional setup parameters if given */\n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (setup.user_mpm)\n\t\tcfg.auto_open_plinks = false;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t/* __cfg80211_join_mesh() will sort it out */\n\t\tsetup.chandef.chan = NULL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates = nla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\tsband = rdev->wiphy.bands[setup.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &setup.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t\t    NL80211_ATTR_TX_RATES,\n\t\t\t\t\t\t    &setup.beacon_rate,\n\t\t\t\t\t\t    dev, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\terr = validate_beacon_tx_rate(rdev, setup.chandef.chan->band,\n\t\t\t\t\t      &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsetup.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsetup.control_port_over_nl80211 = true;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_patterns(struct sk_buff *msg,\n\t\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_wowlan *wowlan = rdev->wiphy.wowlan_config;\n\tstruct nlattr *nl_pats, *nl_pat;\n\tint i, pat_len;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tnl_pats = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN);\n\tif (!nl_pats)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tnl_pat = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_pat)\n\t\t\treturn -ENOBUFS;\n\t\tpat_len = wowlan->patterns[i].pattern_len;\n\t\tif (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),\n\t\t\t    wowlan->patterns[i].mask) ||\n\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t    wowlan->patterns[i].pattern) ||\n\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\twowlan->patterns[i].pkt_offset))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, nl_pat);\n\t}\n\tnla_nest_end(msg, nl_pats);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_tcp(struct sk_buff *msg,\n\t\t\t\t   struct cfg80211_wowlan_tcp *tcp)\n{\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_in_addr(msg, NL80211_WOWLAN_TCP_SRC_IPV4, tcp->src) ||\n\t    nla_put_in_addr(msg, NL80211_WOWLAN_TCP_DST_IPV4, tcp->dst) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DST_MAC, ETH_ALEN, tcp->dst_mac) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_SRC_PORT, tcp->src_port) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_DST_PORT, tcp->dst_port) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t    tcp->payload_len, tcp->payload) ||\n\t    nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t    tcp->wake_len, tcp->wake_data) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_MASK,\n\t\t    DIV_ROUND_UP(tcp->wake_len, 8), tcp->wake_mask))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_seq.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,\n\t\t    sizeof(tcp->payload_seq), &tcp->payload_seq))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_tok.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t    sizeof(tcp->payload_tok) + tcp->tokens_size,\n\t\t    &tcp->payload_tok))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_nd(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_sched_scan_request *req)\n{\n\tstruct nlattr *nd, *freqs, *matches, *match, *scan_plans, *scan_plan;\n\tint i;\n\n\tif (!req)\n\t\treturn 0;\n\n\tnd = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_NET_DETECT);\n\tif (!nd)\n\t\treturn -ENOBUFS;\n\n\tif (req->n_scan_plans == 1 &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL,\n\t\t\treq->scan_plans[0].interval * 1000))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_DELAY, req->delay))\n\t\treturn -ENOBUFS;\n\n\tif (req->relative_rssi_set) {\n\t\tstruct nl80211_bss_select_rssi_adjust rssi_adjust;\n\n\t\tif (nla_put_s8(msg, NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,\n\t\t\t       req->relative_rssi))\n\t\t\treturn -ENOBUFS;\n\n\t\trssi_adjust.band = req->rssi_adjust.band;\n\t\trssi_adjust.delta = req->rssi_adjust.delta;\n\t\tif (nla_put(msg, NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,\n\t\t\t    sizeof(rssi_adjust), &rssi_adjust))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tfreqs = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!freqs)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tnla_nest_end(msg, freqs);\n\n\tif (req->n_match_sets) {\n\t\tmatches = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SCHED_SCAN_MATCH);\n\t\tif (!matches)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\t\tmatch = nla_nest_start_noflag(msg, i);\n\t\t\tif (!match)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (nla_put(msg, NL80211_SCHED_SCAN_MATCH_ATTR_SSID,\n\t\t\t\t    req->match_sets[i].ssid.ssid_len,\n\t\t\t\t    req->match_sets[i].ssid.ssid))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, match);\n\t\t}\n\t\tnla_nest_end(msg, matches);\n\t}\n\n\tscan_plans = nla_nest_start_noflag(msg, NL80211_ATTR_SCHED_SCAN_PLANS);\n\tif (!scan_plans)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_scan_plans; i++) {\n\t\tscan_plan = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!scan_plan)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_INTERVAL,\n\t\t\t\treq->scan_plans[i].interval) ||\n\t\t    (req->scan_plans[i].iterations &&\n\t\t     nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_ITERATIONS,\n\t\t\t\t req->scan_plans[i].iterations)))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, scan_plan);\n\t}\n\tnla_nest_end(msg, scan_plans);\n\n\tnla_nest_end(msg, nd);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 size = NLMSG_DEFAULT_SIZE;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->wiphy.wowlan_config && rdev->wiphy.wowlan_config->tcp) {\n\t\t/* adjust size to have room for all the data */\n\t\tsize += rdev->wiphy.wowlan_config->tcp->tokens_size +\n\t\t\trdev->wiphy.wowlan_config->tcp->payload_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len / 8;\n\t}\n\n\tmsg = nlmsg_new(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wiphy.wowlan_config) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.wowlan_config->any &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t\t    (rdev->wiphy.wowlan_config->disconnect &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t\t    (rdev->wiphy.wowlan_config->magic_pkt &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t\t    (rdev->wiphy.wowlan_config->gtk_rekey_failure &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t\t    (rdev->wiphy.wowlan_config->eap_identity_req &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t\t    (rdev->wiphy.wowlan_config->four_way_handshake &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t\t    (rdev->wiphy.wowlan_config->rfkill_release &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_patterns(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_tcp(msg,\n\t\t\t\t\t    rdev->wiphy.wowlan_config->tcp))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_nd(\n\t\t\t    msg,\n\t\t\t    rdev->wiphy.wowlan_config->nd_config))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct nlattr *attr,\n\t\t\t\t    struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TCP];\n\tstruct cfg80211_wowlan_tcp *cfg;\n\tstruct nl80211_wowlan_tcp_data_token *tok = NULL;\n\tstruct nl80211_wowlan_tcp_data_seq *seq = NULL;\n\tu32 size;\n\tu32 data_size, wake_size, tokens_size = 0, wake_mask_size;\n\tint err, port;\n\n\tif (!rdev->wiphy.wowlan->tcp)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TCP, attr,\n\t\t\t\t\t  nl80211_wowlan_tcp_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_WOWLAN_TCP_SRC_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_MAC] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_PORT] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_INTERVAL] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_MASK])\n\t\treturn -EINVAL;\n\n\tdata_size = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]);\n\tif (data_size > rdev->wiphy.wowlan->tcp->data_payload_max)\n\t\treturn -EINVAL;\n\n\tif (nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) >\n\t\t\trdev->wiphy.wowlan->tcp->data_interval_max ||\n\t    nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) == 0)\n\t\treturn -EINVAL;\n\n\twake_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]);\n\tif (wake_size > rdev->wiphy.wowlan->tcp->wake_payload_max)\n\t\treturn -EINVAL;\n\n\twake_mask_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_MASK]);\n\tif (wake_mask_size != DIV_ROUND_UP(wake_size, 8))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]) {\n\t\tu32 tokln = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\n\t\ttok = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\t\ttokens_size = tokln - sizeof(*tok);\n\n\t\tif (!tok->len || tokens_size % tok->len)\n\t\t\treturn -EINVAL;\n\t\tif (!rdev->wiphy.wowlan->tcp->tok)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len > rdev->wiphy.wowlan->tcp->tok->max_len)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len < rdev->wiphy.wowlan->tcp->tok->min_len)\n\t\t\treturn -EINVAL;\n\t\tif (tokens_size > rdev->wiphy.wowlan->tcp->tok->bufsize)\n\t\t\treturn -EINVAL;\n\t\tif (tok->offset + tok->len > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]) {\n\t\tseq = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]);\n\t\tif (!rdev->wiphy.wowlan->tcp->seq)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len == 0 || seq->len > 4)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len + seq->offset > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(*cfg);\n\tsize += data_size;\n\tsize += wake_size + wake_mask_size;\n\tsize += tokens_size;\n\n\tcfg = kzalloc(size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\tcfg->src = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_SRC_IPV4]);\n\tcfg->dst = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_DST_IPV4]);\n\tmemcpy(cfg->dst_mac, nla_data(tb[NL80211_WOWLAN_TCP_DST_MAC]),\n\t       ETH_ALEN);\n\tif (tb[NL80211_WOWLAN_TCP_SRC_PORT])\n\t\tport = nla_get_u16(tb[NL80211_WOWLAN_TCP_SRC_PORT]);\n\telse\n\t\tport = 0;\n#ifdef CONFIG_INET\n\t/* allocate a socket and port for it and use it */\n\terr = __sock_create(wiphy_net(&rdev->wiphy), PF_INET, SOCK_STREAM,\n\t\t\t    IPPROTO_TCP, &cfg->sock, 1);\n\tif (err) {\n\t\tkfree(cfg);\n\t\treturn err;\n\t}\n\tif (inet_csk_get_port(cfg->sock->sk, port)) {\n\t\tsock_release(cfg->sock);\n\t\tkfree(cfg);\n\t\treturn -EADDRINUSE;\n\t}\n\tcfg->src_port = inet_sk(cfg->sock->sk)->inet_num;\n#else\n\tif (!port) {\n\t\tkfree(cfg);\n\t\treturn -EINVAL;\n\t}\n\tcfg->src_port = port;\n#endif\n\n\tcfg->dst_port = nla_get_u16(tb[NL80211_WOWLAN_TCP_DST_PORT]);\n\tcfg->payload_len = data_size;\n\tcfg->payload = (u8 *)cfg + sizeof(*cfg) + tokens_size;\n\tmemcpy((void *)cfg->payload,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]),\n\t       data_size);\n\tif (seq)\n\t\tcfg->payload_seq = *seq;\n\tcfg->data_interval = nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]);\n\tcfg->wake_len = wake_size;\n\tcfg->wake_data = (u8 *)cfg + sizeof(*cfg) + tokens_size + data_size;\n\tmemcpy((void *)cfg->wake_data,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]),\n\t       wake_size);\n\tcfg->wake_mask = (u8 *)cfg + sizeof(*cfg) + tokens_size +\n\t\t\t data_size + wake_size;\n\tmemcpy((void *)cfg->wake_mask,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_MASK]),\n\t       wake_mask_size);\n\tif (tok) {\n\t\tcfg->tokens_size = tokens_size;\n\t\tmemcpy(&cfg->payload_tok, tok, sizeof(*tok) + tokens_size);\n\t}\n\n\ttrig->tcp = cfg;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_wowlan_nd(struct cfg80211_registered_device *rdev,\n\t\t\t\t   const struct wiphy_wowlan_support *wowlan,\n\t\t\t\t   struct nlattr *attr,\n\t\t\t\t   struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr **tb;\n\tint err;\n\n\ttb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tif (!(wowlan->flags & WIPHY_WOWLAN_NET_DETECT)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_MAX, attr,\n\t\t\t\t\t  nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\ttrig->nd_config = nl80211_parse_sched_scan(&rdev->wiphy, NULL, tb,\n\t\t\t\t\t\t   wowlan->max_nd_match_sets);\n\terr = PTR_ERR_OR_ZERO(trig->nd_config);\n\tif (err)\n\t\ttrig->nd_config = NULL;\n\nout:\n\tkfree(tb);\n\treturn err;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct cfg80211_wowlan *ntrig;\n\tconst struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;\n\tint err, i;\n\tbool prev_enabled = rdev->wiphy.wowlan_config;\n\tbool regular = false;\n\n\tif (!wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]) {\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wiphy.wowlan_config = NULL;\n\t\tgoto set_wakeup;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS],\n\t\t\t\t\t  nl80211_wowlan_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.gtk_rekey_failure = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.eap_identity_req = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.four_way_handshake = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.rfkill_release = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len, pkt_offset;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\t\tregular = true;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tu8 *mask_pat;\n\n\t\t\terr = nla_parse_nested_deprecated(pat_tb,\n\t\t\t\t\t\t\t  MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t\t  info->extack);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\t\tpkt_offset = 0;\n\t\t\telse\n\t\t\t\tpkt_offset = nla_get_u32(\n\t\t\t\t\tpat_tb[NL80211_PKTPAT_OFFSET]);\n\t\t\tif (pkt_offset > wowlan->max_pkt_offset)\n\t\t\t\tgoto error;\n\t\t\tnew_triggers.patterns[i].pkt_offset = pkt_offset;\n\n\t\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!mask_pat) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].mask = mask_pat;\n\t\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tmask_pat += mask_len;\n\t\t\tnew_triggers.patterns[i].pattern = mask_pat;\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(mask_pat,\n\t\t\t       nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_tcp(\n\t\t\trdev, tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_NET_DETECT]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_nd(\n\t\t\trdev, wowlan, tb[NL80211_WOWLAN_TRIG_NET_DETECT],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t/* The 'any' trigger means the device continues operating more or less\n\t * as in its normal operation mode and wakes up the host on most of the\n\t * normal interrupts (like packet RX, ...)\n\t * It therefore makes little sense to combine with the more constrained\n\t * wakeup trigger modes.\n\t */\n\tif (new_triggers.any && regular) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tntrig = kmemdup(&new_triggers, sizeof(new_triggers), GFP_KERNEL);\n\tif (!ntrig) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_wowlan(rdev);\n\trdev->wiphy.wowlan_config = ntrig;\n\n set_wakeup:\n\tif (rdev->ops->set_wakeup &&\n\t    prev_enabled != !!rdev->wiphy.wowlan_config)\n\t\trdev_set_wakeup(rdev, rdev->wiphy.wowlan_config);\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\tif (new_triggers.tcp && new_triggers.tcp->sock)\n\t\tsock_release(new_triggers.tcp->sock);\n\tkfree(new_triggers.tcp);\n\tkfree(new_triggers.nd_config);\n\treturn err;\n}\n#endif\n\nstatic int nl80211_send_coalesce_rules(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *nl_pats, *nl_pat, *nl_rule, *nl_rules;\n\tint i, j, pat_len;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!rdev->coalesce->n_rules)\n\t\treturn 0;\n\n\tnl_rules = nla_nest_start_noflag(msg, NL80211_ATTR_COALESCE_RULE);\n\tif (!nl_rules)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->coalesce->n_rules; i++) {\n\t\tnl_rule = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_rule)\n\t\t\treturn -ENOBUFS;\n\n\t\trule = &rdev->coalesce->rules[i];\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_DELAY,\n\t\t\t\trule->delay))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_CONDITION,\n\t\t\t\trule->condition))\n\t\t\treturn -ENOBUFS;\n\n\t\tnl_pats = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_COALESCE_RULE_PKT_PATTERN);\n\t\tif (!nl_pats)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (j = 0; j < rule->n_patterns; j++) {\n\t\t\tnl_pat = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_pat)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tpat_len = rule->patterns[j].pattern_len;\n\t\t\tif (nla_put(msg, NL80211_PKTPAT_MASK,\n\t\t\t\t    DIV_ROUND_UP(pat_len, 8),\n\t\t\t\t    rule->patterns[j].mask) ||\n\t\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t\t    rule->patterns[j].pattern) ||\n\t\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\t\trule->patterns[j].pkt_offset))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, nl_pat);\n\t\t}\n\t\tnla_nest_end(msg, nl_pats);\n\t\tnla_nest_end(msg, nl_rule);\n\t}\n\tnla_nest_end(msg, nl_rules);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_COALESCE);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->coalesce && nl80211_send_coalesce_rules(msg, rdev))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_coalesce *coalesce = rdev->coalesce;\n\tint i, j;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!coalesce)\n\t\treturn;\n\n\tfor (i = 0; i < coalesce->n_rules; i++) {\n\t\trule = &coalesce->rules[i];\n\t\tfor (j = 0; j < rule->n_patterns; j++)\n\t\t\tkfree(rule->patterns[j].mask);\n\t\tkfree(rule->patterns);\n\t}\n\tkfree(coalesce->rules);\n\tkfree(coalesce);\n\trdev->coalesce = NULL;\n}\n\nstatic int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct nlattr *rule,\n\t\t\t\t       struct cfg80211_coalesce_rules *new_rule)\n{\n\tint err, i;\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct nlattr *tb[NUM_NL80211_ATTR_COALESCE_RULE], *pat;\n\tint rem, pat_len, mask_len, pkt_offset, n_patterns = 0;\n\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_COALESCE_RULE_MAX,\n\t\t\t\t\t  rule, nl80211_coalesce_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_DELAY])\n\t\tnew_rule->delay =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_DELAY]);\n\tif (new_rule->delay > coalesce->max_delay)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_CONDITION])\n\t\tnew_rule->condition =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_CONDITION]);\n\n\tif (!tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem)\n\t\tn_patterns++;\n\tif (n_patterns > coalesce->n_patterns)\n\t\treturn -EINVAL;\n\n\tnew_rule->patterns = kcalloc(n_patterns, sizeof(new_rule->patterns[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_rule->patterns)\n\t\treturn -ENOMEM;\n\n\tnew_rule->n_patterns = n_patterns;\n\ti = 0;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem) {\n\t\tu8 *mask_pat;\n\n\t\terr = nla_parse_nested_deprecated(pat_tb, MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\treturn -EINVAL;\n\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\treturn -EINVAL;\n\t\tif (pat_len > coalesce->pattern_max_len ||\n\t\t    pat_len < coalesce->pattern_min_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\tpkt_offset = 0;\n\t\telse\n\t\t\tpkt_offset = nla_get_u32(pat_tb[NL80211_PKTPAT_OFFSET]);\n\t\tif (pkt_offset > coalesce->max_pkt_offset)\n\t\t\treturn -EINVAL;\n\t\tnew_rule->patterns[i].pkt_offset = pkt_offset;\n\n\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\tif (!mask_pat)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_rule->patterns[i].mask = mask_pat;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t       mask_len);\n\n\t\tmask_pat += mask_len;\n\t\tnew_rule->patterns[i].pattern = mask_pat;\n\t\tnew_rule->patterns[i].pattern_len = pat_len;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t       pat_len);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct cfg80211_coalesce new_coalesce = {};\n\tstruct cfg80211_coalesce *n_coalesce;\n\tint err, rem_rule, n_rules = 0, i, j;\n\tstruct nlattr *rule;\n\tstruct cfg80211_coalesce_rules *tmp_rule;\n\n\tif (!rdev->wiphy.coalesce || !rdev->ops->set_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_COALESCE_RULE]) {\n\t\tcfg80211_rdev_free_coalesce(rdev);\n\t\trdev_set_coalesce(rdev, NULL);\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule)\n\t\tn_rules++;\n\tif (n_rules > coalesce->n_rules)\n\t\treturn -EINVAL;\n\n\tnew_coalesce.rules = kcalloc(n_rules, sizeof(new_coalesce.rules[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_coalesce.rules)\n\t\treturn -ENOMEM;\n\n\tnew_coalesce.n_rules = n_rules;\n\ti = 0;\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule) {\n\t\terr = nl80211_parse_coalesce_rule(rdev, rule,\n\t\t\t\t\t\t  &new_coalesce.rules[i]);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\ti++;\n\t}\n\n\terr = rdev_set_coalesce(rdev, &new_coalesce);\n\tif (err)\n\t\tgoto error;\n\n\tn_coalesce = kmemdup(&new_coalesce, sizeof(new_coalesce), GFP_KERNEL);\n\tif (!n_coalesce) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_coalesce(rdev);\n\trdev->coalesce = n_coalesce;\n\n\treturn 0;\nerror:\n\tfor (i = 0; i < new_coalesce.n_rules; i++) {\n\t\ttmp_rule = &new_coalesce.rules[i];\n\t\tfor (j = 0; j < tmp_rule->n_patterns; j++)\n\t\t\tkfree(tmp_rule->patterns[j].mask);\n\t\tkfree(tmp_rule->patterns);\n\t}\n\tkfree(new_coalesce.rules);\n\n\treturn err;\n}\n\nstatic int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct nlattr *tb[NUM_NL80211_REKEY_DATA];\n\tstruct cfg80211_gtk_rekey_data rekey_data = {};\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_REKEY_DATA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_REKEY_DATA,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_REKEY_DATA],\n\t\t\t\t\t  nl80211_rekey_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||\n\t    !tb[NL80211_REKEY_DATA_KCK])\n\t\treturn -EINVAL;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK &&\n\t      nla_len(tb[NL80211_REKEY_DATA_KEK]) == NL80211_KEK_EXT_LEN))\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK &&\n\t      nla_len(tb[NL80211_REKEY_DATA_KEK]) == NL80211_KCK_EXT_LEN))\n\t\treturn -ERANGE;\n\n\trekey_data.kek = nla_data(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck = nla_data(tb[NL80211_REKEY_DATA_KCK]);\n\trekey_data.replay_ctr = nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]);\n\trekey_data.kek_len = nla_len(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck_len = nla_len(tb[NL80211_REKEY_DATA_KCK]);\n\tif (tb[NL80211_REKEY_DATA_AKM])\n\t\trekey_data.akm = nla_get_u32(tb[NL80211_REKEY_DATA_AKM]);\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->ops->set_rekey_data) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_set_rekey_data(rdev, dev, &rekey_data);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_register_unexpected_frame(struct sk_buff *skb,\n\t\t\t\t\t     struct genl_info *info)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (wdev->ap_unexpected_nlportid)\n\t\treturn -EBUSY;\n\n\twdev->ap_unexpected_nlportid = info->snd_portid;\n\treturn 0;\n}\n\nstatic int nl80211_probe_client(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *addr;\n\tu64 cookie;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->probe_client)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\terr = rdev_probe_client(rdev, dev, addr, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_register_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_beacon_registration *reg, *nreg;\n\tint rv;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS))\n\t\treturn -EOPNOTSUPP;\n\n\tnreg = kzalloc(sizeof(*nreg), GFP_KERNEL);\n\tif (!nreg)\n\t\treturn -ENOMEM;\n\n\t/* First, check if already registered. */\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tif (reg->nlportid == info->snd_portid) {\n\t\t\trv = -EALREADY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\t/* Add it to the list */\n\tnreg->nlportid = info->snd_portid;\n\tlist_add(&nreg->list, &rdev->beacon_registrations);\n\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\n\treturn 0;\nout_err:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tkfree(nreg);\n\treturn rv;\n}\n\nstatic int nl80211_start_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->start_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn 0;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\terr = rdev_start_p2p_device(rdev, wdev);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->stop_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_p2p_device(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_start_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn -EEXIST;\n\n\tif (rfkill_blocked(rdev->rfkill))\n\t\treturn -ERFKILL;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_MASTER_PREF])\n\t\treturn -EINVAL;\n\n\tconf.master_pref =\n\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t}\n\n\terr = rdev_start_nan(rdev, wdev, &conf);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_nan(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int validate_nan_filter(struct nlattr *filter_attr)\n{\n\tstruct nlattr *attr;\n\tint len = 0, n_entries = 0, rem;\n\n\tnla_for_each_nested(attr, filter_attr, rem) {\n\t\tlen += nla_len(attr);\n\t\tn_entries++;\n\t}\n\n\tif (len >= U8_MAX)\n\t\treturn -EINVAL;\n\n\treturn n_entries;\n}\n\nstatic int handle_nan_filter(struct nlattr *attr_filter,\n\t\t\t     struct cfg80211_nan_func *func,\n\t\t\t     bool tx)\n{\n\tstruct nlattr *attr;\n\tint n_entries, rem, i;\n\tstruct cfg80211_nan_func_filter *filter;\n\n\tn_entries = validate_nan_filter(attr_filter);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tBUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));\n\n\tfilter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnla_for_each_nested(attr, attr_filter, rem) {\n\t\tfilter[i].filter = nla_memdup(attr, GFP_KERNEL);\n\t\tfilter[i].len = nla_len(attr);\n\t\ti++;\n\t}\n\tif (tx) {\n\t\tfunc->num_tx_filters = n_entries;\n\t\tfunc->tx_filters = filter;\n\t} else {\n\t\tfunc->num_rx_filters = n_entries;\n\t\tfunc->rx_filters = filter;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_add_func(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct nlattr *tb[NUM_NL80211_NAN_FUNC_ATTR], *func_attr;\n\tstruct cfg80211_nan_func *func;\n\tstruct sk_buff *msg = NULL;\n\tvoid *hdr = NULL;\n\tint err = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_FUNC])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_NAN_FUNC_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_NAN_FUNC],\n\t\t\t\t\t  nl80211_nan_func_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\tfunc->cookie = cfg80211_assign_cookie(rdev);\n\n\tif (!tb[NL80211_NAN_FUNC_TYPE]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\n\tfunc->type = nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]);\n\n\tif (!tb[NL80211_NAN_FUNC_SERVICE_ID]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(func->service_id, nla_data(tb[NL80211_NAN_FUNC_SERVICE_ID]),\n\t       sizeof(func->service_id));\n\n\tfunc->close_range =\n\t\tnla_get_flag(tb[NL80211_NAN_FUNC_CLOSE_RANGE]);\n\n\tif (tb[NL80211_NAN_FUNC_SERVICE_INFO]) {\n\t\tfunc->serv_spec_info_len =\n\t\t\tnla_len(tb[NL80211_NAN_FUNC_SERVICE_INFO]);\n\t\tfunc->serv_spec_info =\n\t\t\tkmemdup(nla_data(tb[NL80211_NAN_FUNC_SERVICE_INFO]),\n\t\t\t\tfunc->serv_spec_info_len,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!func->serv_spec_info) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TTL])\n\t\tfunc->ttl = nla_get_u32(tb[NL80211_NAN_FUNC_TTL]);\n\n\tswitch (func->type) {\n\tcase NL80211_NAN_FUNC_PUBLISH:\n\t\tif (!tb[NL80211_NAN_FUNC_PUBLISH_TYPE]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->publish_type =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_PUBLISH_TYPE]);\n\t\tfunc->publish_bcast =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_PUBLISH_BCAST]);\n\n\t\tif ((!(func->publish_type & NL80211_NAN_SOLICITED_PUBLISH)) &&\n\t\t\tfunc->publish_bcast) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_SUBSCRIBE:\n\t\tfunc->subscribe_active =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE]);\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_FOLLOW_UP:\n\t\tif (!tb[NL80211_NAN_FUNC_FOLLOW_UP_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->followup_id =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_ID]);\n\t\tfunc->followup_reqid =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]);\n\t\tmemcpy(func->followup_dest.addr,\n\t\t       nla_data(tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]),\n\t\t       sizeof(func->followup_dest.addr));\n\t\tif (func->ttl) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_SRF]) {\n\t\tstruct nlattr *srf_tb[NUM_NL80211_NAN_SRF_ATTR];\n\n\t\terr = nla_parse_nested_deprecated(srf_tb,\n\t\t\t\t\t\t  NL80211_NAN_SRF_ATTR_MAX,\n\t\t\t\t\t\t  tb[NL80211_NAN_FUNC_SRF],\n\t\t\t\t\t\t  nl80211_nan_srf_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfunc->srf_include =\n\t\t\tnla_get_flag(srf_tb[NL80211_NAN_SRF_INCLUDE]);\n\n\t\tif (srf_tb[NL80211_NAN_SRF_BF]) {\n\t\t\tif (srf_tb[NL80211_NAN_SRF_MAC_ADDRS] ||\n\t\t\t    !srf_tb[NL80211_NAN_SRF_BF_IDX]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_len =\n\t\t\t\tnla_len(srf_tb[NL80211_NAN_SRF_BF]);\n\t\t\tfunc->srf_bf =\n\t\t\t\tkmemdup(nla_data(srf_tb[NL80211_NAN_SRF_BF]),\n\t\t\t\t\tfunc->srf_bf_len, GFP_KERNEL);\n\t\t\tif (!func->srf_bf) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_idx =\n\t\t\t\tnla_get_u8(srf_tb[NL80211_NAN_SRF_BF_IDX]);\n\t\t} else {\n\t\t\tstruct nlattr *attr, *mac_attr =\n\t\t\t\tsrf_tb[NL80211_NAN_SRF_MAC_ADDRS];\n\t\t\tint n_entries, rem, i = 0;\n\n\t\t\tif (!mac_attr) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tn_entries = validate_acl_mac_addrs(mac_attr);\n\t\t\tif (n_entries <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_num_macs = n_entries;\n\t\t\tfunc->srf_macs =\n\t\t\t\tkcalloc(n_entries, sizeof(*func->srf_macs),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!func->srf_macs) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnla_for_each_nested(attr, mac_attr, rem)\n\t\t\t\tmemcpy(func->srf_macs[i++].addr, nla_data(attr),\n\t\t\t\t       sizeof(*func->srf_macs));\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_TX_MATCH_FILTER],\n\t\t\t\t\tfunc, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_RX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_RX_MATCH_FILTER],\n\t\t\t\t\tfunc, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_ADD_NAN_FUNCTION);\n\t/* This can't really happen - we just allocated 4KB */\n\tif (WARN_ON(!hdr)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_nan_func(rdev, wdev, func);\nout:\n\tif (err < 0) {\n\t\tcfg80211_free_nan_func(func);\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\t/* propagate the instance id and cookie to userspace  */\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID,\n\t\t       func->instance_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_nan_del_func(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\trdev_del_nan_func(rdev, wdev, cookie);\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_change_config(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tu32 changed = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (info->attrs[NL80211_ATTR_NAN_MASTER_PREF]) {\n\t\tconf.master_pref =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\t\tif (conf.master_pref <= 1 || conf.master_pref == 255)\n\t\t\treturn -EINVAL;\n\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_PREF;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_BANDS;\n\t}\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\treturn rdev_nan_change_conf(rdev, wdev, &conf, changed);\n}\n\nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct nlattr *match_attr, *local_func_attr, *peer_func_attr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(!match->inst_id || !match->peer_inst_id || !match->addr))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NAN_MATCH);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))\n\t\tgoto nla_put_failure;\n\n\tmatch_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_MATCH);\n\tif (!match_attr)\n\t\tgoto nla_put_failure;\n\n\tlocal_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_NAN_MATCH_FUNC_LOCAL);\n\tif (!local_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->inst_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, local_func_attr);\n\n\tpeer_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_NAN_MATCH_FUNC_PEER);\n\tif (!peer_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_TYPE, match->type) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->peer_inst_id))\n\t\tgoto nla_put_failure;\n\n\tif (match->info && match->info_len &&\n\t    nla_put(msg, NL80211_NAN_FUNC_SERVICE_INFO, match->info_len,\n\t\t    match->info))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, peer_func_attr);\n\tnla_nest_end(msg, match_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_match);\n\nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct nlattr *func_attr;\n\tvoid *hdr;\n\n\tif (WARN_ON(!inst_id))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_NAN_FUNCTION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, inst_id) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_TERM_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_func_terminated);\n\nstatic int nl80211_get_protocol_features(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_PROTOCOL_FEATURES);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PROTOCOL_FEATURES,\n\t\t\tNL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_ft_ies_params ft_params;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_ft_ies)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MDID] ||\n\t    !info->attrs[NL80211_ATTR_IE])\n\t\treturn -EINVAL;\n\n\tmemset(&ft_params, 0, sizeof(ft_params));\n\tft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);\n\tft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\tft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\n\treturn rdev_update_ft_ies(rdev, dev, &ft_params);\n}\n\nstatic int nl80211_crit_protocol_start(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tenum nl80211_crit_proto_id proto = NL80211_CRIT_PROTO_UNSPEC;\n\tu16 duration;\n\tint ret;\n\n\tif (!rdev->ops->crit_proto_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!rdev->ops->crit_proto_stop))\n\t\treturn -EINVAL;\n\n\tif (rdev->crit_proto_nlportid)\n\t\treturn -EBUSY;\n\n\t/* determine protocol if provided */\n\tif (info->attrs[NL80211_ATTR_CRIT_PROT_ID])\n\t\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CRIT_PROT_ID]);\n\n\tif (proto >= NUM_NL80211_CRIT_PROTO)\n\t\treturn -EINVAL;\n\n\t/* timeout must be provided */\n\tif (!info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION])\n\t\treturn -EINVAL;\n\n\tduration =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION]);\n\n\tret = rdev_crit_proto_start(rdev, wdev, proto, duration);\n\tif (!ret)\n\t\trdev->crit_proto_nlportid = info->snd_portid;\n\n\treturn ret;\n}\n\nstatic int nl80211_crit_protocol_stop(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->crit_proto_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->crit_proto_nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_vendor_check_policy(const struct wiphy_vendor_command *vcmd,\n\t\t\t\t       struct nlattr *attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (vcmd->policy == VENDOR_CMD_RAW_DATA) {\n\t\tif (attr->nla_type & NLA_F_NESTED) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"unexpected nested data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(attr->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"expected nested data\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nla_validate_nested(attr, vcmd->maxattr, vcmd->policy, extack);\n}\n\nstatic int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(rdev, genl_info_net(info),\n\t\t\t\t\t   info->attrs);\n\tint i, err;\n\tu32 vid, subcmd;\n\n\tif (!rdev->wiphy.vendor_commands)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tvid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);\n\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\t\tvoid *data = NULL;\n\t\tint len = 0;\n\n\t\tvcmd = &rdev->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\t\tif (!wdev)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t\t    !wdev->netdev)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\t\tif (!wdev_running(wdev))\n\t\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\t\t} else {\n\t\t\twdev = NULL;\n\t\t}\n\n\t\tif (!vcmd->doit)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (info->attrs[NL80211_ATTR_VENDOR_DATA]) {\n\t\t\tdata = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\t\t\tlen = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\n\t\t\terr = nl80211_vendor_check_policy(vcmd,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\t\tinfo->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\trdev->cur_cmd_info = info;\n\t\terr = vcmd->doit(&rdev->wiphy, wdev, data, len);\n\t\trdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_prepare_vendor_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct wireless_dev **wdev)\n{\n\tstruct nlattr **attrbuf;\n\tu32 vid, subcmd;\n\tunsigned int i;\n\tint vcmd_idx = -1;\n\tint err;\n\tvoid *data = NULL;\n\tunsigned int data_len = 0;\n\n\tif (cb->args[0]) {\n\t\t/* subtract the 1 again here */\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tif (cb->args[1]) {\n\t\t\tlist_for_each_entry(tmp, &wiphy->wdev_list, list) {\n\t\t\t\tif (tmp->identifier == cb->args[1] - 1) {\n\t\t\t\t\t*wdev = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* keep rtnl locked in successful case */\n\t\treturn 0;\n\t}\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (!attrbuf[NL80211_ATTR_VENDOR_ID] ||\n\t    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*wdev = __cfg80211_wdev_from_attrs(NULL, sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*wdev))\n\t\t*wdev = NULL;\n\n\t*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out;\n\t}\n\n\tvid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);\n\n\tfor (i = 0; i < (*rdev)->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\n\t\tvcmd = &(*rdev)->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (!vcmd->dumpit) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvcmd_idx = i;\n\t\tbreak;\n\t}\n\n\tif (vcmd_idx < 0) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (attrbuf[NL80211_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\n\t\terr = nl80211_vendor_check_policy(\n\t\t\t\t&(*rdev)->wiphy.vendor_commands[vcmd_idx],\n\t\t\t\tattrbuf[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\tcb->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* 0 is the first index - add 1 to parse only once */\n\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t/* add 1 to know if it was NULL */\n\tcb->args[1] = *wdev ? (*wdev)->identifier + 1 : 0;\n\tcb->args[2] = vcmd_idx;\n\tcb->args[3] = (unsigned long)data;\n\tcb->args[4] = data_len;\n\n\t/* keep rtnl locked in successful case */\n\terr = 0;\nout:\n\tkfree(attrbuf);\n\treturn err;\n}\n\nstatic int nl80211_vendor_cmd_dump(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tunsigned int vcmd_idx;\n\tconst struct wiphy_vendor_command *vcmd;\n\tvoid *data;\n\tint data_len;\n\tint err;\n\tstruct nlattr *vendor_data;\n\n\trtnl_lock();\n\terr = nl80211_prepare_vendor_dump(skb, cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out;\n\n\tvcmd_idx = cb->args[2];\n\tdata = (void *)cb->args[3];\n\tdata_len = cb->args[4];\n\tvcmd = &rdev->wiphy.vendor_commands[vcmd_idx];\n\n\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\tif (!wdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t    !wdev->netdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\tif (!wdev_running(wdev)) {\n\t\t\t\terr = -ENETDOWN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_VENDOR);\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (wdev && nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t\t       wdev_id(wdev),\n\t\t\t\t\t       NL80211_ATTR_PAD))) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tvendor_data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    NL80211_ATTR_VENDOR_DATA);\n\t\tif (!vendor_data) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = vcmd->dumpit(&rdev->wiphy, wdev, skb, data, data_len,\n\t\t\t\t   (unsigned long *)&cb->args[5]);\n\t\tnla_nest_end(skb, vendor_data);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err <= 0) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n out:\n\trtnl_unlock();\n\treturn err;\n}\n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, NULL, approxlen,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_portid,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_seq,\n\t\t\t\t\t   cmd, attr, NULL, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_reply_skb);\n\nint cfg80211_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!rdev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->cur_cmd_info);\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);\n\nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn 0;\n\n\treturn rdev->cur_cmd_info->snd_portid;\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_get_sender);\n\nstatic int nl80211_set_qos_map(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_qos_map *qos_map = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *pos, len, num_des, des_len, des;\n\tint ret;\n\n\tif (!rdev->ops->set_qos_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_QOS_MAP]) {\n\t\tpos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);\n\n\t\tif (len % 2)\n\t\t\treturn -EINVAL;\n\n\t\tqos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);\n\t\tif (!qos_map)\n\t\t\treturn -ENOMEM;\n\n\t\tnum_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;\n\t\tif (num_des) {\n\t\t\tdes_len = num_des *\n\t\t\t\tsizeof(struct cfg80211_dscp_exception);\n\t\t\tmemcpy(qos_map->dscp_exception, pos, des_len);\n\t\t\tqos_map->num_des = num_des;\n\t\t\tfor (des = 0; des < num_des; des++) {\n\t\t\t\tif (qos_map->dscp_exception[des].up > 7) {\n\t\t\t\t\tkfree(qos_map);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += des_len;\n\t\t}\n\t\tmemcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!ret)\n\t\tret = rdev_set_qos_map(rdev, dev, qos_map);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\tkfree(qos_map);\n\treturn ret;\n}\n\nstatic int nl80211_add_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid, up;\n\tu16 admitted_time = 0;\n\tint err;\n\n\tif (!(rdev->wiphy.features & NL80211_FEATURE_SUPPORTS_WMM_ADMISSION))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_USER_PRIO])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tup = nla_get_u8(info->attrs[NL80211_ATTR_USER_PRIO]);\n\n\t/* WMM uses TIDs 0-7 even for TSPEC */\n\tif (tsid >= IEEE80211_FIRST_TSPEC_TSID) {\n\t\t/* TODO: handle 802.11 TSPEC/admission control\n\t\t * need more attributes for that (e.g. BA session requirement);\n\t\t * change the WMM adminssion test above to allow both then\n\t\t */\n\t\treturn -EINVAL;\n\t}\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_ADMITTED_TIME]) {\n\t\tadmitted_time =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_ADMITTED_TIME]);\n\t\tif (!admitted_time)\n\t\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_tx_ts(rdev, dev, tsid, peer, up, admitted_time);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_del_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\terr = rdev_del_tx_ts(rdev, dev, tsid, peer);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_channel_switch(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_chan_def chandef = {};\n\tconst u8 *addr;\n\tu8 oper_class;\n\tint err;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_OPER_CLASS])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t * Don't allow wide channels on the 2.4Ghz band, as per IEEE802.11-2012\n\t * section 10.22.6.2.1. Disallow 5/10Mhz channels as well for now, the\n\t * specification is not defined for them.\n\t */\n\tif (chandef.chan->band == NL80211_BAND_2GHZ &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20)\n\t\treturn -EINVAL;\n\n\t/* we will be active on the TDLS link */\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\t/* don't allow switching to DFS channels */\n\tif (cfg80211_chandef_dfs_required(wdev->wiphy, &chandef, wdev->iftype))\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\toper_class = nla_get_u8(info->attrs[NL80211_ATTR_OPER_CLASS]);\n\n\twdev_lock(wdev);\n\terr = rdev_tdls_channel_switch(rdev, dev, addr, oper_class, &chandef);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_cancel_channel_switch(struct sk_buff *skb,\n\t\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *addr;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !rdev->ops->tdls_cancel_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\trdev_tdls_cancel_channel_switch(rdev, dev, addr);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst struct nlattr *nla;\n\tbool enabled;\n\n\tif (!rdev->ops->set_multicast_to_unicast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tnla = info->attrs[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED];\n\tenabled = nla_get_flag(nla);\n\n\treturn rdev_set_multicast_to_unicast(rdev, dev, enabled);\n}\n\nstatic int nl80211_set_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_pmk_conf pmk_conf = {};\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] || !info->attrs[NL80211_ATTR_PMK])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (!wdev->current_bss) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.aa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tif (memcmp(pmk_conf.aa, wdev->current_bss->pub.bssid, ETH_ALEN)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\tpmk_conf.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\tif (pmk_conf.pmk_len != WLAN_PMK_LEN &&\n\t    pmk_conf.pmk_len != WLAN_PMK_LEN_SUITE_B_192) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMKR0_NAME])\n\t\tpmk_conf.pmk_r0_name =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\n\tret = rdev_set_pmk(rdev, dev, &pmk_conf);\nout:\n\twdev_unlock(wdev);\n\treturn ret;\n}\n\nstatic int nl80211_del_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *aa;\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\taa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tret = rdev_del_pmk(rdev, dev, aa);\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nstatic int nl80211_external_auth(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_external_auth_params params;\n\n\tif (!rdev->ops->external_auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_BSSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE])\n\t\treturn -EINVAL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid.ssid_len == 0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(params.ssid.ssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_SSID]),\n\t\t       params.ssid.ssid_len);\n\t}\n\n\tmemcpy(params.bssid, nla_data(info->attrs[NL80211_ATTR_BSSID]),\n\t       ETH_ALEN);\n\n\tparams.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\n\tif (info->attrs[NL80211_ATTR_PMKID])\n\t\tparams.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\treturn rdev_external_auth(rdev, dev, &params);\n}\n\nstatic int nl80211_tx_control_port(struct sk_buff *skb, struct genl_info *info)\n{\n\tbool dont_wait_for_ack = info->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tu16 proto;\n\tbool noencrypt;\n\tu64 cookie = 0;\n\tint err;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->tx_control_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame, MAC or ethertype missing\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\twdev_unlock(wdev);\n\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\tnoencrypt =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT]);\n\n\terr = rdev_tx_control_port(rdev, dev, buf, len,\n\t\t\t\t   dest, cpu_to_be16(proto), noencrypt,\n\t\t\t\t   dont_wait_for_ack ? NULL : &cookie);\n\tif (!err && !dont_wait_for_ack)\n\t\tnl_set_extack_cookie_u64(info->extack, cookie);\n\treturn err;\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_owe_info(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_owe_info owe_info;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_owe_info)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmemset(&owe_info, 0, sizeof(owe_info));\n\towe_info.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tnla_memcpy(owe_info.peer, info->attrs[NL80211_ATTR_MAC], ETH_ALEN);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\towe_info.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\towe_info.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\treturn rdev_update_owe_info(rdev, dev, &owe_info);\n}\n\nstatic int nl80211_probe_mesh_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct station_info sinfo = {};\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tint err;\n\n\tif (!rdev->ops->probe_mesh_link || !rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_FRAME]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame or MAC missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (len < sizeof(struct ethhdr))\n\t\treturn -EINVAL;\n\n\tif (!ether_addr_equal(buf, dest) || is_multicast_ether_addr(buf) ||\n\t    !ether_addr_equal(buf + ETH_ALEN, dev->dev_addr))\n\t\treturn -EINVAL;\n\n\terr = rdev_get_station(rdev, dev, dest, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tcfg80211_sinfo_release_content(&sinfo);\n\n\treturn rdev_probe_mesh_link(rdev, dev, dest, buf, len);\n}\n\nstatic int parse_tid_conf(struct cfg80211_registered_device *rdev,\n\t\t\t  struct nlattr *attrs[], struct net_device *dev,\n\t\t\t  struct cfg80211_tid_cfg *tid_conf,\n\t\t\t  struct genl_info *info, const u8 *peer)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu64 mask;\n\tint err;\n\n\tif (!attrs[NL80211_TID_CONFIG_ATTR_TIDS])\n\t\treturn -EINVAL;\n\n\ttid_conf->config_override =\n\t\t\tnla_get_flag(attrs[NL80211_TID_CONFIG_ATTR_OVERRIDE]);\n\ttid_conf->tids = nla_get_u16(attrs[NL80211_TID_CONFIG_ATTR_TIDS]);\n\n\tif (tid_conf->config_override) {\n\t\tif (rdev->ops->reset_tid_config) {\n\t\t\terr = rdev_reset_tid_config(rdev, dev, peer,\n\t\t\t\t\t\t    tid_conf->tids);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_NOACK]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\ttid_conf->noack =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_NOACK]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RETRY_SHORT]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RETRY_SHORT);\n\t\ttid_conf->retry_short =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RETRY_SHORT]);\n\n\t\tif (tid_conf->retry_short > rdev->wiphy.max_data_retry_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RETRY_LONG]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\ttid_conf->retry_long =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RETRY_LONG]);\n\n\t\tif (tid_conf->retry_long > rdev->wiphy.max_data_retry_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\t\ttid_conf->ampdu =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL);\n\t\ttid_conf->rtscts =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_AMSDU_CTRL);\n\t\ttid_conf->amsdu =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE]) {\n\t\tu32 idx = NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE, attr;\n\n\t\ttid_conf->txrate_type = nla_get_u8(attrs[idx]);\n\n\t\tif (tid_conf->txrate_type != NL80211_TX_RATE_AUTOMATIC) {\n\t\t\tattr = NL80211_TID_CONFIG_ATTR_TX_RATE;\n\t\t\terr = nl80211_parse_tx_bitrate_mask(info, attrs, attr,\n\t\t\t\t\t\t    &tid_conf->txrate_mask, dev,\n\t\t\t\t\t\t    true);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_TX_RATE);\n\t\t}\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE);\n\t}\n\n\tif (peer)\n\t\tmask = rdev->wiphy.tid_config_support.peer;\n\telse\n\t\tmask = rdev->wiphy.tid_config_support.vif;\n\n\tif (tid_conf->mask & ~mask) {\n\t\tNL_SET_ERR_MSG(extack, \"unsupported TID configuration\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_tid_config(struct sk_buff *skb,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *attrs[NL80211_TID_CONFIG_ATTR_MAX + 1];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_tid_config *tid_config;\n\tstruct nlattr *tid;\n\tint conf_idx = 0, rem_conf;\n\tint ret = -EINVAL;\n\tu32 num_conf = 0;\n\n\tif (!info->attrs[NL80211_ATTR_TID_CONFIG])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_tid_config)\n\t\treturn -EOPNOTSUPP;\n\n\tnla_for_each_nested(tid, info->attrs[NL80211_ATTR_TID_CONFIG],\n\t\t\t    rem_conf)\n\t\tnum_conf++;\n\n\ttid_config = kzalloc(struct_size(tid_config, tid_conf, num_conf),\n\t\t\t     GFP_KERNEL);\n\tif (!tid_config)\n\t\treturn -ENOMEM;\n\n\ttid_config->n_tid_conf = num_conf;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\ttid_config->peer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tnla_for_each_nested(tid, info->attrs[NL80211_ATTR_TID_CONFIG],\n\t\t\t    rem_conf) {\n\t\tret = nla_parse_nested(attrs, NL80211_TID_CONFIG_ATTR_MAX,\n\t\t\t\t       tid, NULL, NULL);\n\n\t\tif (ret)\n\t\t\tgoto bad_tid_conf;\n\n\t\tret = parse_tid_conf(rdev, attrs, dev,\n\t\t\t\t     &tid_config->tid_conf[conf_idx],\n\t\t\t\t     info, tid_config->peer);\n\t\tif (ret)\n\t\t\tgoto bad_tid_conf;\n\n\t\tconf_idx++;\n\t}\n\n\tret = rdev_set_tid_config(rdev, dev, tid_config);\n\nbad_tid_conf:\n\tkfree(tid_config);\n\treturn ret;\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_NEED_WDEV\t\t0x10\n/* If a netdev is associated, it must be UP, P2P must be started */\n#define NL80211_FLAG_NEED_WDEV_UP\t(NL80211_FLAG_NEED_WDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_CLEAR_SKB\t\t0x20\n#define NL80211_FLAG_NO_WIPHY_MTX\t0x40\n\nstatic int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = NULL;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev;\n\n\trtnl_lock();\n\tif (ops->internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (ops->internal_flags & NL80211_FLAG_NEED_NETDEV ||\n\t\t   ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\twdev = __cfg80211_wdev_from_attrs(NULL, genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(wdev);\n\t\t}\n\n\t\tdev = wdev->netdev;\n\t\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\t\tif (!dev) {\n\t\t\t\trtnl_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tinfo->user_ptr[1] = dev;\n\t\t} else {\n\t\t\tinfo->user_ptr[1] = wdev;\n\t\t}\n\n\t\tif (ops->internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !wdev_running(wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENETDOWN;\n\t\t}\n\n\t\tif (dev)\n\t\t\tdev_hold(dev);\n\n\t\tinfo->user_ptr[0] = rdev;\n\t}\n\n\tif (rdev && !(ops->internal_flags & NL80211_FLAG_NO_WIPHY_MTX)) {\n\t\twiphy_lock(&rdev->wiphy);\n\t\t/* we keep the mutex locked until post_doit */\n\t\t__release(&rdev->wiphy.mtx);\n\t}\n\tif (!(ops->internal_flags & NL80211_FLAG_NEED_RTNL))\n\t\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tif (info->user_ptr[1]) {\n\t\tif (ops->internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\t\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\t\t\tif (wdev->netdev)\n\t\t\t\tdev_put(wdev->netdev);\n\t\t} else {\n\t\t\tdev_put(info->user_ptr[1]);\n\t\t}\n\t}\n\n\tif (info->user_ptr[0] &&\n\t    !(ops->internal_flags & NL80211_FLAG_NO_WIPHY_MTX)) {\n\t\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\n\t\t/* we kept the mutex locked since pre_doit */\n\t\t__acquire(&rdev->wiphy.mtx);\n\t\twiphy_unlock(&rdev->wiphy);\n\t}\n\n\tif (ops->internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n\n\t/* If needed, clear the netlink message payload from the SKB\n\t * as it might contain key data that shouldn't stick around on\n\t * the heap after the SKB is freed. The netlink message header\n\t * is still needed for further processing, so leave it intact.\n\t */\n\tif (ops->internal_flags & NL80211_FLAG_CLEAR_SKB) {\n\t\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\t\tmemset(nlmsg_data(nlh), 0, nlmsg_len(nlh));\n\t}\n}\n\nstatic int nl80211_set_sar_sub_specs(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct cfg80211_sar_specs *sar_specs,\n\t\t\t\t     struct nlattr *spec[], int index)\n{\n\tu32 range_index, i;\n\n\tif (!sar_specs || !spec)\n\t\treturn -EINVAL;\n\n\tif (!spec[NL80211_SAR_ATTR_SPECS_POWER] ||\n\t    !spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX])\n\t\treturn -EINVAL;\n\n\trange_index = nla_get_u32(spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX]);\n\n\t/* check if range_index exceeds num_freq_ranges */\n\tif (range_index >= rdev->wiphy.sar_capa->num_freq_ranges)\n\t\treturn -EINVAL;\n\n\t/* check if range_index duplicates */\n\tfor (i = 0; i < index; i++) {\n\t\tif (sar_specs->sub_specs[i].freq_range_index == range_index)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsar_specs->sub_specs[index].power =\n\t\tnla_get_s32(spec[NL80211_SAR_ATTR_SPECS_POWER]);\n\n\tsar_specs->sub_specs[index].freq_range_index = range_index;\n\n\treturn 0;\n}\n\nstatic int nl80211_set_sar_specs(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *spec[NL80211_SAR_ATTR_SPECS_MAX + 1];\n\tstruct nlattr *tb[NL80211_SAR_ATTR_MAX + 1];\n\tstruct cfg80211_sar_specs *sar_spec;\n\tenum nl80211_sar_type type;\n\tstruct nlattr *spec_list;\n\tu32 specs;\n\tint rem, err;\n\n\tif (!rdev->wiphy.sar_capa || !rdev->ops->set_sar_specs)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SAR_SPEC])\n\t\treturn -EINVAL;\n\n\tnla_parse_nested(tb, NL80211_SAR_ATTR_MAX,\n\t\t\t info->attrs[NL80211_ATTR_SAR_SPEC],\n\t\t\t NULL, NULL);\n\n\tif (!tb[NL80211_SAR_ATTR_TYPE] || !tb[NL80211_SAR_ATTR_SPECS])\n\t\treturn -EINVAL;\n\n\ttype = nla_get_u32(tb[NL80211_SAR_ATTR_TYPE]);\n\tif (type != rdev->wiphy.sar_capa->type)\n\t\treturn -EINVAL;\n\n\tspecs = 0;\n\tnla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem)\n\t\tspecs++;\n\n\tif (specs > rdev->wiphy.sar_capa->num_freq_ranges)\n\t\treturn -EINVAL;\n\n\tsar_spec = kzalloc(sizeof(*sar_spec) +\n\t\t\t   specs * sizeof(struct cfg80211_sar_sub_specs),\n\t\t\t   GFP_KERNEL);\n\tif (!sar_spec)\n\t\treturn -ENOMEM;\n\n\tsar_spec->type = type;\n\tspecs = 0;\n\tnla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem) {\n\t\tnla_parse_nested(spec, NL80211_SAR_ATTR_SPECS_MAX,\n\t\t\t\t spec_list, NULL, NULL);\n\n\t\tswitch (type) {\n\t\tcase NL80211_SAR_TYPE_POWER:\n\t\t\tif (nl80211_set_sar_sub_specs(rdev, sar_spec,\n\t\t\t\t\t\t      spec, specs)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tspecs++;\n\t}\n\n\tsar_spec->num_sub_specs = specs;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_set_sar_specs(rdev, sar_spec);\n\trdev->cur_cmd_info = NULL;\nerror:\n\tkfree(sar_spec);\n\treturn err;\n}\n\nstatic const struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.done = nl80211_dump_wiphy_done,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n};\n\nstatic const struct genl_small_ops nl80211_small_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_set_beacon,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_start_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_stop_ap,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpp,\n\t\t.dumpit = nl80211_dump_mpp,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_bss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_reg_do,\n\t\t.dumpit = nl80211_get_reg_dump,\n\t\t.internal_flags = 0,\n\t\t/* can be retrieved by unprivileged users */\n\t},\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = 0,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RELOAD_REGDB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_reload_regdb,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ABORT_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_abort_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_authenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_associate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disassociate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_testmode_do,\n\t\t.dumpit = nl80211_testmode_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_connect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_CONNECT_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_connect_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disconnect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL |\n\t\t\t\t  NL80211_FLAG_NO_WIPHY_MTX,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_power_save,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_power_save,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_cqm,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n#ifdef CONFIG_PM\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wowlan,\n\t\t/* can be retrieved by unprivileged users */\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_SET_REKEY_OFFLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_rekey_data,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_MGMT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_OPER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_oper,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UNEXPECTED_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_unexpected_frame,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_CLIENT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_probe_client,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_BEACONS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_beacons,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_NOACK_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_noack_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_add_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_del_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANGE_NAN_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_change_config,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MCAST_RATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mcast_rate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MAC_ACL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mac_acl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RADAR_DETECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_PROTOCOL_FEATURES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_protocol_features,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_FT_IES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_ft_ies,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_STOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_stop,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_coalesce,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_coalesce,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_vendor_cmd,\n\t\t.dumpit = nl80211_vendor_cmd_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_QOS_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_qos_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_add_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_cancel_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MULTICAST_TO_UNICAST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_multicast_to_unicast,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t  0 |\n\t\t\t\t  NL80211_FLAG_CLEAR_SKB,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_pmk,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_EXTERNAL_AUTH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_external_auth,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CONTROL_PORT_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_control_port,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_FTM_RESPONDER_STATS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_ftm_responder_stats,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PEER_MEASUREMENT_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_pmsr_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NOTIFY_RADAR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_notify_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_OWE_INFO,\n\t\t.doit = nl80211_update_owe_info,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_MESH_LINK,\n\t\t.doit = nl80211_probe_mesh_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV_UP,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TID_CONFIG,\n\t\t.doit = nl80211_set_tid_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_NETDEV,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_SAR_SPECS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_sar_specs,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t  NL80211_FLAG_NEED_RTNL,\n\t},\n};\n\nstatic struct genl_family nl80211_fam __ro_after_init = {\n\t.name = NL80211_GENL_NAME,\t/* have users key off the name instead */\n\t.hdrsize = 0,\t\t\t/* no private header */\n\t.version = 1,\t\t\t/* no particular meaning now */\n\t.maxattr = NL80211_ATTR_MAX,\n\t.policy = nl80211_policy,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n\t.module = THIS_MODULE,\n\t.ops = nl80211_ops,\n\t.n_ops = ARRAY_SIZE(nl80211_ops),\n\t.small_ops = nl80211_small_ops,\n\t.n_small_ops = ARRAY_SIZE(nl80211_small_ops),\n\t.mcgrps = nl80211_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),\n\t.parallel_ops = true,\n};\n\n/* notification functions */\n\nvoid nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t  enum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_WIPHY &&\n\t\tcmd != NL80211_CMD_DEL_WIPHY);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(rdev, cmd, msg, 0, 0, 0, &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid nl80211_notify_iface(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tenum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_iface(msg, 0, 0, 0, rdev, wdev, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\tstruct cfg80211_scan_info *info;\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (nla_put(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tif (req->flags & NL80211_SCAN_FLAG_FREQ_KHZ) {\n\t\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_FREQ_KHZ);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tif (nla_put_u32(msg, i,\n\t\t\t\t   ieee80211_channel_to_khz(req->channels[i])))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t} else {\n\t\tnest = nla_nest_start_noflag(msg,\n\t\t\t\t\t     NL80211_ATTR_SCAN_FREQUENCIES);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t}\n\n\tif (req->ie &&\n\t    nla_put(msg, NL80211_ATTR_IE, req->ie_len, req->ie))\n\t\tgoto nla_put_failure;\n\n\tif (req->flags &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags))\n\t\tgoto nla_put_failure;\n\n\tinfo = rdev->int_scan_req ? &rdev->int_scan_req->info :\n\t\t&rdev->scan_req->info;\n\tif (info->scan_start_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_ATTR_SCAN_START_TIME_TSF,\n\t\t\t       info->scan_start_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_ATTR_SCAN_START_TIME_TSF_BSSID, ETH_ALEN,\n\t\t     info->tsf_bssid)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_prep_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t u32 portid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_prep_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY,\n\t\t\twiphy_to_rdev(req->wiphy)->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, req->dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->reqid,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct wireless_dev *wdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstruct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct wireless_dev *wdev, bool aborted)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  aborted ? NL80211_CMD_SCAN_ABORTED :\n\t\t\t\t\t    NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}\n\n/* send message created by nl80211_build_scan_msg() */\nvoid nl80211_send_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t   struct sk_buff *msg)\n{\n\tif (!msg)\n\t\treturn;\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_sched_scan_msg(msg, req, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(req->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstatic bool nl80211_reg_change_event_fill(struct sk_buff *msg,\n\t\t\t\t\t  struct regulatory_request *request)\n{\n\t/* Userspace can always count this one always being set */\n\tif (nla_put_u8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator))\n\t\tgoto nla_put_failure;\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if (request->alpha2[0] == '9' && request->alpha2[1] == '9') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_CUSTOM_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t   request->intersect) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_INTERSECTION))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_COUNTRY) ||\n\t\t    nla_put_string(msg, NL80211_ATTR_REG_ALPHA2,\n\t\t\t\t   request->alpha2))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (request->wiphy_idx != WIPHY_IDX_INVALID) {\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(request->wiphy_idx);\n\n\t\tif (wiphy &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy &&\n\t\t    wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\n/*\n * This can happen on global regulatory changes or device specific settings\n * based on custom regulatory domains.\n */\nvoid nl80211_common_reg_change_event(enum nl80211_commands cmd_id,\n\t\t\t\t     struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd_id);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_reg_change_event_fill(msg, request))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp,\n\t\t\t\t    int uapsd_queues, const u8 *req_ies,\n\t\t\t\t    size_t req_ies_len, bool reconnect)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len + req_ies_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (req_ies &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, req_ies_len, req_ies)))\n\t\tgoto nla_put_failure;\n\n\tif (reconnect && nla_put_flag(msg, NL80211_ATTR_RECONNECT_REQUESTED))\n\t\tgoto nla_put_failure;\n\n\tif (uapsd_queues >= 0) {\n\t\tstruct nlattr *nla_wmm =\n\t\t\tnla_nest_start_noflag(msg, NL80211_ATTR_STA_WME);\n\t\tif (!nla_wmm)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_STA_WME_UAPSD_QUEUES,\n\t\t\t       uapsd_queues))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nla_wmm);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0,\n\t\t\t\tfalse);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, gfp_t gfp, int uapsd_queues,\n\t\t\t   const u8 *req_ies, size_t req_ies_len)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, gfp, uapsd_queues,\n\t\t\t\treq_ies, req_ies_len, false);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, bool reconnect, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0,\n\t\t\t\treconnect);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, bool reconnect, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0,\n\t\t\t\treconnect);\n}\n\nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct ieee80211_mgmt *mgmt = (void *)buf;\n\tu32 cmd;\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_deauth(mgmt->frame_control)) {\n\t\tcmd = NL80211_CMD_UNPROT_DEAUTHENTICATE;\n\t} else if (ieee80211_is_disassoc(mgmt->frame_control)) {\n\t\tcmd = NL80211_CMD_UNPROT_DISASSOCIATE;\n\t} else if (ieee80211_is_beacon(mgmt->frame_control)) {\n\t\tif (wdev->unprot_beacon_reported &&\n\t\t    elapsed_jiffies_msecs(wdev->unprot_beacon_reported) < 10000)\n\t\t\treturn;\n\t\tcmd = NL80211_CMD_UNPROT_BEACON;\n\t\twdev->unprot_beacon_reported = jiffies;\n\t} else {\n\t\treturn;\n\t}\n\n\ttrace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);\n\tnl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1,\n\t\t\t\tNULL, 0, false);\n}\nEXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t struct cfg80211_connect_resp_params *cr,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + cr->req_ie_len + cr->resp_ie_len +\n\t\t\tcr->fils.kek_len + cr->fils.pmk_len +\n\t\t\t(cr->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (cr->bssid &&\n\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, cr->bssid)) ||\n\t    nla_put_u16(msg, NL80211_ATTR_STATUS_CODE,\n\t\t\tcr->status < 0 ? WLAN_STATUS_UNSPECIFIED_FAILURE :\n\t\t\tcr->status) ||\n\t    (cr->status < 0 &&\n\t     (nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t      nla_put_u32(msg, NL80211_ATTR_TIMEOUT_REASON,\n\t\t\t  cr->timeout_reason))) ||\n\t    (cr->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, cr->req_ie_len, cr->req_ie)) ||\n\t    (cr->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, cr->resp_ie_len,\n\t\t     cr->resp_ie)) ||\n\t    (cr->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t cr->fils.erp_next_seq_num)) ||\n\t    (cr->status == WLAN_STATUS_SUCCESS &&\n\t     ((cr->fils.kek &&\n\t       nla_put(msg, NL80211_ATTR_FILS_KEK, cr->fils.kek_len,\n\t\t       cr->fils.kek)) ||\n\t      (cr->fils.pmk &&\n\t       nla_put(msg, NL80211_ATTR_PMK, cr->fils.pmk_len, cr->fils.pmk)) ||\n\t      (cr->fils.pmkid &&\n\t       nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, cr->fils.pmkid)))))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev,\n\t\t\t struct cfg80211_roam_info *info, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *bssid = info->bss ? info->bss->bssid : info->bssid;\n\n\tmsg = nlmsg_new(100 + info->req_ie_len + info->resp_ie_len +\n\t\t\tinfo->fils.kek_len + info->fils.pmk_len +\n\t\t\t(info->fils.pmkid ? WLAN_PMKID_LEN : 0), gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid) ||\n\t    (info->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, info->req_ie_len,\n\t\t     info->req_ie)) ||\n\t    (info->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, info->resp_ie_len,\n\t\t     info->resp_ie)) ||\n\t    (info->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t info->fils.erp_next_seq_num)) ||\n\t    (info->fils.kek &&\n\t     nla_put(msg, NL80211_ATTR_FILS_KEK, info->fils.kek_len,\n\t\t     info->fils.kek)) ||\n\t    (info->fils.pmk &&\n\t     nla_put(msg, NL80211_ATTR_PMK, info->fils.pmk_len, info->fils.pmk)) ||\n\t    (info->fils.pmkid &&\n\t     nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, info->fils.pmkid)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *bssid)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PORT_AUTHORIZED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + ie_len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,\n\t\t\t\t\tconst u8 *ie, u8 ie_len,\n\t\t\t\t\tint sig_dbm, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))\n\t\treturn;\n\n\ttrace_cfg80211_notify_new_peer_candidate(dev, addr);\n\n\tmsg = nlmsg_new(100 + ie_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    (ie_len && ie &&\n\t     nla_put(msg, NL80211_ATTR_IE, ie_len, ie)) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (addr && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_KEY_TYPE, key_type) ||\n\t    (key_id != -1 &&\n\t     nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_id)) ||\n\t    (tsc && nla_put(msg, NL80211_ATTR_KEY_SEQ, 6, tsc)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t/*\n\t * Since we are applying the beacon hint to a wiphy we know its\n\t * wiphy_idx is valid\n\t */\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\t/* Before */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_before, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t/* After */\n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_after, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\tNL80211_CHAN_NO_HT) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL &&\n\t    nla_put_u32(msg, NL80211_ATTR_DURATION, duration))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan,\n\t\t\t\t\t  duration, gfp);\n}\nEXPORT_SYMBOL(cfg80211_ready_on_channel);\n\nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_remain_on_channel_expired);\n\nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_tx_mgmt_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_tx_mgmt_expired);\n\nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_new_sta(dev, mac_addr, sinfo);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_new_sta);\n\nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct station_info empty_sinfo = {};\n\n\tif (!sinfo)\n\t\tsinfo = &empty_sinfo;\n\n\ttrace_cfg80211_del_sta(dev, mac_addr);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_DEL_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_del_sta_sinfo);\n\nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONN_FAILED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_CONN_FAILED_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_conn_failed);\n\nstatic bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,\n\t\t\t\t       const u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid = READ_ONCE(wdev->ap_unexpected_nlportid);\n\n\tif (!nlportid)\n\t\treturn false;\n\n\tmsg = nlmsg_new(100, gfp);\n\tif (!msg)\n\t\treturn true;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn true;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn true;\n}\n\nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_spurious_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev, NL80211_CMD_UNEXPECTED_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_spurious_frame);\n\nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_unexpected_4addr_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->iftype != NL80211_IFTYPE_AP_VLAN)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev,\n\t\t\t\t\t NL80211_CMD_UNEXPECTED_4ADDR_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct wireless_dev *wdev, u32 nlportid,\n\t\t      int freq, int sig_dbm,\n\t\t      const u8 *buf, size_t len, u32 flags, gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\tnetdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, KHZ_TO_MHZ(freq)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET, freq % 1000) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (flags &&\n\t     nla_put_u32(msg, NL80211_ATTR_RXMGMT_FLAGS, flags)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic void nl80211_frame_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t    const u8 *buf, size_t len, bool ack,\n\t\t\t\t    gfp_t gfp, enum nl80211_commands command)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (command == NL80211_CMD_FRAME_TX_STATUS)\n\t\ttrace_cfg80211_mgmt_tx_status(wdev, cookie, ack);\n\telse\n\t\ttrace_cfg80211_control_port_tx_status(wdev, cookie, ack);\n\n\tmsg = nlmsg_new(100 + len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, command);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_control_port_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t     const u8 *buf, size_t len, bool ack,\n\t\t\t\t     gfp_t gfp)\n{\n\tnl80211_frame_tx_status(wdev, cookie, buf, len, ack, gfp,\n\t\t\t\tNL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS);\n}\nEXPORT_SYMBOL(cfg80211_control_port_tx_status);\n\nvoid cfg80211_mgmt_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t     const u8 *buf, size_t len, bool ack, gfp_t gfp)\n{\n\tnl80211_frame_tx_status(wdev, cookie, buf, len, ack, gfp,\n\t\t\t\tNL80211_CMD_FRAME_TX_STATUS);\n}\nEXPORT_SYMBOL(cfg80211_mgmt_tx_status);\n\nstatic int __nl80211_rx_control_port(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     bool unencrypted, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ethhdr *ehdr = eth_hdr(skb);\n\tconst u8 *addr = ehdr->h_source;\n\tu16 proto = be16_to_cpu(skb->protocol);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *frame;\n\n\tu32 nlportid = READ_ONCE(wdev->conn_owner_nlportid);\n\n\tif (!nlportid)\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(100 + skb->len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONTROL_PORT_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u16(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE, proto) ||\n\t    (unencrypted && nla_put_flag(msg,\n\t\t\t\t\t NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT)))\n\t\tgoto nla_put_failure;\n\n\tframe = nla_reserve(msg, NL80211_ATTR_FRAME, skb->len);\n\tif (!frame)\n\t\tgoto nla_put_failure;\n\n\tskb_copy_bits(skb, 0, nla_data(frame), skb->len);\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nbool cfg80211_rx_control_port(struct net_device *dev,\n\t\t\t      struct sk_buff *skb, bool unencrypted)\n{\n\tint ret;\n\n\ttrace_cfg80211_rx_control_port(dev, skb, unencrypted);\n\tret = __nl80211_rx_control_port(dev, skb, unencrypted, GFP_ATOMIC);\n\ttrace_cfg80211_return_bool(ret == 0);\n\treturn ret == 0;\n}\nEXPORT_SYMBOL(cfg80211_rx_control_port);\n\nstatic struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,\n\t\t\t\t\t    const char *mac, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tvoid **cb;\n\n\tif (!msg)\n\t\treturn NULL;\n\n\tcb = (void **)msg->cb;\n\n\tcb[0] = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!cb[0]) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (mac && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tcb[1] = nla_nest_start_noflag(msg, NL80211_ATTR_CQM);\n\tif (!cb[1])\n\t\tgoto nla_put_failure;\n\n\tcb[2] = rdev;\n\n\treturn msg;\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn NULL;\n}\n\nstatic void cfg80211_send_cqm(struct sk_buff *msg, gfp_t gfp)\n{\n\tvoid **cb = (void **)msg->cb;\n\tstruct cfg80211_registered_device *rdev = cb[2];\n\n\tnla_nest_end(msg, cb[1]);\n\tgenlmsg_end(msg, cb[0]);\n\n\tmemset(msg->cb, 0, sizeof(msg->cb));\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\n\nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\ttrace_cfg80211_cqm_rssi_notify(dev, rssi_event, rssi_level);\n\n\tif (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&\n\t\t    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))\n\t\treturn;\n\n\tif (wdev->cqm_config) {\n\t\twdev->cqm_config->last_rssi_event_value = rssi_level;\n\n\t\tcfg80211_cqm_rssi_update(rdev, dev);\n\n\t\tif (rssi_level == 0)\n\t\t\trssi_level = wdev->cqm_config->last_rssi_event_value;\n\t}\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t\trssi_event))\n\t\tgoto nla_put_failure;\n\n\tif (rssi_level && nla_put_s32(msg, NL80211_ATTR_CQM_RSSI_LEVEL,\n\t\t\t\t      rssi_level))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_rssi_notify);\n\nvoid cfg80211_cqm_txe_notify(struct net_device *dev,\n\t\t\t     const u8 *peer, u32 num_packets,\n\t\t\t     u32 rate, u32 intvl, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_txe_notify);\n\nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);\n\nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_flag(msg, NL80211_ATTR_CQM_BEACON_LOSS_EVENT))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);\n\nstatic void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t\t     const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\trekey_attr = nla_nest_start_noflag(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, rekey_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_gtk_rekey_notify(dev, bssid);\n\tnl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);\n}\nEXPORT_SYMBOL(cfg80211_gtk_rekey_notify);\n\nstatic void\nnl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, int index,\n\t\t\t       const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(msg, NL80211_ATTR_PMKSA_CANDIDATE);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_PMKSA_CANDIDATE_INDEX, index) ||\n\t    nla_put(msg, NL80211_PMKSA_CANDIDATE_BSSID, ETH_ALEN, bssid) ||\n\t    (preauth &&\n\t     nla_put_flag(msg, NL80211_PMKSA_CANDIDATE_PREAUTH)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);\n\tnl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);\n}\nEXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);\n\nstatic void nl80211_ch_switch_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev,\n\t\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t\t     gfp_t gfp,\n\t\t\t\t     enum nl80211_commands notif,\n\t\t\t\t     u8 count, bool quiet)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, notif);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tif (notif == NL80211_CMD_CH_SWITCH_STARTED_NOTIFY) {\n\t\tif (nla_put_u32(msg, NL80211_ATTR_CH_SWITCH_COUNT, count))\n\t\t\tgoto nla_put_failure;\n\t\tif (quiet &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CH_SWITCH_BLOCK_TX))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_ch_switch_notify(dev, chandef);\n\n\twdev->chandef = *chandef;\n\twdev->preset_chandef = *chandef;\n\n\tif (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t    !WARN_ON(!wdev->current_bss))\n\t\tcfg80211_update_assoc_bss_entry(wdev, chandef->chan);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_NOTIFY, 0, false);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_notify);\n\nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       u8 count, bool quiet)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ch_switch_started_notify(dev, chandef);\n\n\tnl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_STARTED_NOTIFY,\n\t\t\t\t count, quiet);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_started_notify);\n\nvoid\nnl80211_radar_notify(struct cfg80211_registered_device *rdev,\n\t\t     const struct cfg80211_chan_def *chandef,\n\t\t     enum nl80211_radar_event event,\n\t\t     struct net_device *netdev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_RADAR_DETECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\t/* NOP and radar events don't need a netdev parameter */\n\tif (netdev) {\n\t\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_RADAR_EVENT, event))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tvoid *hdr;\n\n\tif (WARN_ON(!mac))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STA_OPMODE_CHANGED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_SMPS_MODE_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_SMPS_MODE, sta_opmode->smps_mode))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_MAX_BW_CHANGED) &&\n\t    nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, sta_opmode->bw))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_N_SS_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_NSS, sta_opmode->rx_nss))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_sta_opmode_change_notify);\n\nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_probe_status(dev, addr, cookie, acked);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)) ||\n\t    (is_valid_ack_signal && nla_put_s32(msg, NL80211_ATTR_ACK_SIGNAL,\n\t\t\t\t\t\tack_signal)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_probe_status);\n\nvoid cfg80211_report_obss_beacon_khz(struct wiphy *wiphy, const u8 *frame,\n\t\t\t\t     size_t len, int freq, int sig_dbm)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct cfg80211_beacon_registration *reg;\n\n\ttrace_cfg80211_report_obss_beacon(wiphy, frame, len, freq, sig_dbm);\n\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tmsg = nlmsg_new(len + 100, GFP_ATOMIC);\n\t\tif (!msg) {\n\t\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (freq &&\n\t\t     (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\t\t  KHZ_TO_MHZ(freq)) ||\n\t\t      nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET,\n\t\t\t\t  freq % 1000))) ||\n\t\t    (sig_dbm &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t\t    nla_put(msg, NL80211_ATTR_FRAME, len, frame))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, reg->nlportid);\n\t}\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\treturn;\n\n nla_put_failure:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_obss_beacon_khz);\n\n#ifdef CONFIG_PM\nstatic int cfg80211_net_detect_results(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_wowlan_wakeup *wakeup)\n{\n\tstruct cfg80211_wowlan_nd_info *nd = wakeup->net_detect;\n\tstruct nlattr *nl_results, *nl_match, *nl_freqs;\n\tint i, j;\n\n\tnl_results = nla_nest_start_noflag(msg,\n\t\t\t\t\t   NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS);\n\tif (!nl_results)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < nd->n_matches; i++) {\n\t\tstruct cfg80211_wowlan_nd_match *match = nd->matches[i];\n\n\t\tnl_match = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_match)\n\t\t\tbreak;\n\n\t\t/* The SSID attribute is optional in nl80211, but for\n\t\t * simplicity reasons it's always present in the\n\t\t * cfg80211 structure.  If a driver can't pass the\n\t\t * SSID, that needs to be changed.  A zero length SSID\n\t\t * is still a valid SSID (wildcard), so it cannot be\n\t\t * used for this purpose.\n\t\t */\n\t\tif (nla_put(msg, NL80211_ATTR_SSID, match->ssid.ssid_len,\n\t\t\t    match->ssid.ssid)) {\n\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (match->n_channels) {\n\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t NL80211_ATTR_SCAN_FREQUENCIES);\n\t\t\tif (!nl_freqs) {\n\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < match->n_channels; j++) {\n\t\t\t\tif (nla_put_u32(msg, j, match->channels[j])) {\n\t\t\t\t\tnla_nest_cancel(msg, nl_freqs);\n\t\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_match);\n\t}\n\nout:\n\tnla_nest_end(msg, nl_results);\n\treturn 0;\n}\n\nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint size = 200;\n\n\ttrace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);\n\n\tif (wakeup)\n\t\tsize += wakeup->packet_present_len;\n\n\tmsg = nlmsg_new(size, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_WOWLAN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tif (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\twdev->netdev->ifindex))\n\t\tgoto free_msg;\n\n\tif (wakeup) {\n\t\tstruct nlattr *reasons;\n\n\t\treasons = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!reasons)\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->disconnect &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->magic_pkt &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->gtk_rekey_failure &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->eap_identity_req &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->four_way_handshake &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->rfkill_release &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->pattern_idx >= 0 &&\n\t\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\twakeup->pattern_idx))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_match &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_connlost &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_nomoretokens &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->packet) {\n\t\t\tu32 pkt_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211;\n\t\t\tu32 len_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN;\n\n\t\t\tif (!wakeup->packet_80211) {\n\t\t\t\tpkt_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023;\n\t\t\t\tlen_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN;\n\t\t\t}\n\n\t\t\tif (wakeup->packet_len &&\n\t\t\t    nla_put_u32(msg, len_attr, wakeup->packet_len))\n\t\t\t\tgoto free_msg;\n\n\t\t\tif (nla_put(msg, pkt_attr, wakeup->packet_present_len,\n\t\t\t\t    wakeup->packet))\n\t\t\t\tgoto free_msg;\n\t\t}\n\n\t\tif (wakeup->net_detect &&\n\t\t    cfg80211_net_detect_results(msg, wakeup))\n\t\t\t\tgoto free_msg;\n\n\t\tnla_nest_end(msg, reasons);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n free_msg:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_wowlan_wakeup);\n#endif\n\nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,\n\t\t\t\t\t reason_code);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_TDLS_OPER);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_TDLS_OPERATION, oper) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer) ||\n\t    (reason_code > 0 &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_tdls_oper_request);\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\n\tif (state != NETLINK_URELEASE || notify->protocol != NETLINK_GENERIC)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\n\t\tlist_for_each_entry_rcu(sched_scan_req,\n\t\t\t\t\t&rdev->sched_scan_req_list,\n\t\t\t\t\tlist) {\n\t\t\tif (sched_scan_req->owner_nlportid == notify->portid) {\n\t\t\t\tsched_scan_req->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->sched_scan_stop_wk);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\n\t\t\tif (wdev->owner_nlportid == notify->portid) {\n\t\t\t\twdev->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->destroy_work);\n\t\t\t} else if (wdev->conn_owner_nlportid == notify->portid) {\n\t\t\t\tschedule_work(&wdev->disconnect_wk);\n\t\t\t}\n\n\t\t\tcfg80211_release_pmsr(wdev, notify->portid);\n\t\t}\n\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\n\trcu_read_unlock();\n\n\t/*\n\t * It is possible that the user space process that is controlling the\n\t * indoor setting disappeared, so notify the regulatory core.\n\t */\n\tregulatory_netlink_notify(notify->portid);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_ft_event(wiphy, netdev, ft_event);\n\n\tif (!ft_event->target_ap)\n\t\treturn;\n\n\tmsg = nlmsg_new(100 + ft_event->ies_len + ft_event->ric_ies_len,\n\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FT_EVENT);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap))\n\t\tgoto out;\n\n\tif (ft_event->ies &&\n\t    nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies))\n\t\tgoto out;\n\tif (ft_event->ric_ies &&\n\t    nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,\n\t\t    ft_event->ric_ies))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_ft_event);\n\nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->crit_proto_nlportid)\n\t\treturn;\n\n\tnlportid = rdev->crit_proto_nlportid;\n\trdev->crit_proto_nlportid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CRIT_PROTOCOL_STOP);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_crit_proto_stopped);\n\nvoid nl80211_send_ap_stopped(struct wireless_dev *wdev)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\n\nint cfg80211_external_auth_request(struct net_device *dev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!wdev->conn_owner_nlportid)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_EXTERNAL_AUTH);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u32(msg, NL80211_ATTR_AKM_SUITES, params->key_mgmt_suite) ||\n\t    nla_put_u32(msg, NL80211_ATTR_EXTERNAL_AUTH_ACTION,\n\t\t\tparams->action) ||\n\t    nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, params->bssid) ||\n\t    nla_put(msg, NL80211_ATTR_SSID, params->ssid.ssid_len,\n\t\t    params->ssid.ssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\twdev->conn_owner_nlportid);\n\treturn 0;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\nEXPORT_SYMBOL(cfg80211_external_auth_request);\n\nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_update_owe_info_event(wiphy, netdev, owe_info);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_UPDATE_OWE_INFO);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, owe_info->peer))\n\t\tgoto nla_put_failure;\n\n\tif (!owe_info->ie_len ||\n\t    nla_put(msg, NL80211_ATTR_IE, owe_info->ie_len, owe_info->ie))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_update_owe_info_event);\n\n/* initialisation/exit functions */\n\nint __init nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&nl80211_fam);\n\tif (err)\n\t\treturn err;\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n"}, "1": {"id": 1, "path": "/src/include/linux/slab.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Written by Mark Hemment, 1996 (markhe@nextd.demon.co.uk).\n *\n * (C) SGI 2006, Christoph Lameter\n * \tCleaned up and restructured to ease the addition of alternative\n * \timplementations of SLAB allocators.\n * (C) Linux Foundation 2008-2013\n *      Unified interface for all slab allocators\n */\n\n#ifndef _LINUX_SLAB_H\n#define\t_LINUX_SLAB_H\n\n#include <linux/gfp.h>\n#include <linux/overflow.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <linux/percpu-refcount.h>\n\n\n/*\n * Flags to pass to kmem_cache_create().\n * The ones marked DEBUG are only valid if CONFIG_DEBUG_SLAB is set.\n */\n/* DEBUG: Perform (expensive) checks on alloc/free */\n#define SLAB_CONSISTENCY_CHECKS\t((slab_flags_t __force)0x00000100U)\n/* DEBUG: Silent bug reports */\n#define SLAB_SILENT_ERRORS\t((slab_flags_t __force)0x00000200U)\n/* DEBUG: Red zone objs in a cache */\n#define SLAB_RED_ZONE\t\t((slab_flags_t __force)0x00000400U)\n/* DEBUG: Poison objects */\n#define SLAB_POISON\t\t((slab_flags_t __force)0x00000800U)\n/* Align objs on cache lines */\n#define SLAB_HWCACHE_ALIGN\t((slab_flags_t __force)0x00002000U)\n/* Use GFP_DMA memory */\n#define SLAB_CACHE_DMA\t\t((slab_flags_t __force)0x00004000U)\n/* Use GFP_DMA32 memory */\n#define SLAB_CACHE_DMA32\t((slab_flags_t __force)0x00008000U)\n/* DEBUG: Store the last owner for bug hunting */\n#define SLAB_STORE_USER\t\t((slab_flags_t __force)0x00010000U)\n/* Panic if kmem_cache_create() fails */\n#define SLAB_PANIC\t\t((slab_flags_t __force)0x00040000U)\n/*\n * SLAB_TYPESAFE_BY_RCU - **WARNING** READ THIS!\n *\n * This delays freeing the SLAB page by a grace period, it does _NOT_\n * delay object freeing. This means that if you do kmem_cache_free()\n * that memory location is free to be reused at any time. Thus it may\n * be possible to see another object there in the same RCU grace period.\n *\n * This feature only ensures the memory location backing the object\n * stays valid, the trick to using this is relying on an independent\n * object validation pass. Something like:\n *\n *  rcu_read_lock()\n * again:\n *  obj = lockless_lookup(key);\n *  if (obj) {\n *    if (!try_get_ref(obj)) // might fail for free objects\n *      goto again;\n *\n *    if (obj->key != key) { // not the object we expected\n *      put_ref(obj);\n *      goto again;\n *    }\n *  }\n *  rcu_read_unlock();\n *\n * This is useful if we need to approach a kernel structure obliquely,\n * from its address obtained without the usual locking. We can lock\n * the structure to stabilize it and check it's still at the given address,\n * only if we can be sure that the memory has not been meanwhile reused\n * for some other kind of object (which our subsystem's lock might corrupt).\n *\n * rcu_read_lock before reading the address, then rcu_read_unlock after\n * taking the spinlock within the structure expected at that address.\n *\n * Note that SLAB_TYPESAFE_BY_RCU was originally named SLAB_DESTROY_BY_RCU.\n */\n/* Defer freeing slabs to RCU */\n#define SLAB_TYPESAFE_BY_RCU\t((slab_flags_t __force)0x00080000U)\n/* Spread some memory over cpuset */\n#define SLAB_MEM_SPREAD\t\t((slab_flags_t __force)0x00100000U)\n/* Trace allocations and frees */\n#define SLAB_TRACE\t\t((slab_flags_t __force)0x00200000U)\n\n/* Flag to prevent checks on free */\n#ifdef CONFIG_DEBUG_OBJECTS\n# define SLAB_DEBUG_OBJECTS\t((slab_flags_t __force)0x00400000U)\n#else\n# define SLAB_DEBUG_OBJECTS\t0\n#endif\n\n/* Avoid kmemleak tracing */\n#define SLAB_NOLEAKTRACE\t((slab_flags_t __force)0x00800000U)\n\n/* Fault injection mark */\n#ifdef CONFIG_FAILSLAB\n# define SLAB_FAILSLAB\t\t((slab_flags_t __force)0x02000000U)\n#else\n# define SLAB_FAILSLAB\t\t0\n#endif\n/* Account to memcg */\n#ifdef CONFIG_MEMCG_KMEM\n# define SLAB_ACCOUNT\t\t((slab_flags_t __force)0x04000000U)\n#else\n# define SLAB_ACCOUNT\t\t0\n#endif\n\n#ifdef CONFIG_KASAN\n#define SLAB_KASAN\t\t((slab_flags_t __force)0x08000000U)\n#else\n#define SLAB_KASAN\t\t0\n#endif\n\n/* The following flags affect the page allocator grouping pages by mobility */\n/* Objects are reclaimable */\n#define SLAB_RECLAIM_ACCOUNT\t((slab_flags_t __force)0x00020000U)\n#define SLAB_TEMPORARY\t\tSLAB_RECLAIM_ACCOUNT\t/* Objects are short-lived */\n\n/* Slab deactivation flag */\n#define SLAB_DEACTIVATED\t((slab_flags_t __force)0x10000000U)\n\n/*\n * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.\n *\n * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.\n *\n * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.\n * Both make kfree a no-op.\n */\n#define ZERO_SIZE_PTR ((void *)16)\n\n#define ZERO_OR_NULL_PTR(x) ((unsigned long)(x) <= \\\n\t\t\t\t(unsigned long)ZERO_SIZE_PTR)\n\n#include <linux/kasan.h>\n\nstruct mem_cgroup;\n/*\n * struct kmem_cache related prototypes\n */\nvoid __init kmem_cache_init(void);\nbool slab_is_available(void);\n\nextern bool usercopy_fallback;\n\nstruct kmem_cache *kmem_cache_create(const char *name, unsigned int size,\n\t\t\tunsigned int align, slab_flags_t flags,\n\t\t\tvoid (*ctor)(void *));\nstruct kmem_cache *kmem_cache_create_usercopy(const char *name,\n\t\t\tunsigned int size, unsigned int align,\n\t\t\tslab_flags_t flags,\n\t\t\tunsigned int useroffset, unsigned int usersize,\n\t\t\tvoid (*ctor)(void *));\nvoid kmem_cache_destroy(struct kmem_cache *);\nint kmem_cache_shrink(struct kmem_cache *);\n\n/*\n * Please use this macro to create slab caches. Simply specify the\n * name of the structure and maybe some flags that are listed above.\n *\n * The alignment of the struct determines object alignment. If you\n * f.e. add ____cacheline_aligned_in_smp to the struct declaration\n * then the objects will be properly aligned in SMP configurations.\n */\n#define KMEM_CACHE(__struct, __flags)\t\t\t\t\t\\\n\t\tkmem_cache_create(#__struct, sizeof(struct __struct),\t\\\n\t\t\t__alignof__(struct __struct), (__flags), NULL)\n\n/*\n * To whitelist a single field for copying to/from usercopy, use this\n * macro instead for KMEM_CACHE() above.\n */\n#define KMEM_CACHE_USERCOPY(__struct, __flags, __field)\t\t\t\\\n\t\tkmem_cache_create_usercopy(#__struct,\t\t\t\\\n\t\t\tsizeof(struct __struct),\t\t\t\\\n\t\t\t__alignof__(struct __struct), (__flags),\t\\\n\t\t\toffsetof(struct __struct, __field),\t\t\\\n\t\t\tsizeof_field(struct __struct, __field), NULL)\n\n/*\n * Common kmalloc functions provided by all allocators\n */\nvoid * __must_check krealloc(const void *, size_t, gfp_t);\nvoid kfree(const void *);\nvoid kfree_sensitive(const void *);\nsize_t __ksize(const void *);\nsize_t ksize(const void *);\n#ifdef CONFIG_PRINTK\nbool kmem_valid_obj(void *object);\nvoid kmem_dump_obj(void *object);\n#endif\n\n#ifdef CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR\nvoid __check_heap_object(const void *ptr, unsigned long n, struct page *page,\n\t\t\tbool to_user);\n#else\nstatic inline void __check_heap_object(const void *ptr, unsigned long n,\n\t\t\t\t       struct page *page, bool to_user) { }\n#endif\n\n/*\n * Some archs want to perform DMA into kmalloc caches and need a guaranteed\n * alignment larger than the alignment of a 64-bit integer.\n * Setting ARCH_KMALLOC_MINALIGN in arch headers allows that.\n */\n#if defined(ARCH_DMA_MINALIGN) && ARCH_DMA_MINALIGN > 8\n#define ARCH_KMALLOC_MINALIGN ARCH_DMA_MINALIGN\n#define KMALLOC_MIN_SIZE ARCH_DMA_MINALIGN\n#define KMALLOC_SHIFT_LOW ilog2(ARCH_DMA_MINALIGN)\n#else\n#define ARCH_KMALLOC_MINALIGN __alignof__(unsigned long long)\n#endif\n\n/*\n * Setting ARCH_SLAB_MINALIGN in arch headers allows a different alignment.\n * Intended for arches that get misalignment faults even for 64 bit integer\n * aligned buffers.\n */\n#ifndef ARCH_SLAB_MINALIGN\n#define ARCH_SLAB_MINALIGN __alignof__(unsigned long long)\n#endif\n\n/*\n * kmalloc and friends return ARCH_KMALLOC_MINALIGN aligned\n * pointers. kmem_cache_alloc and friends return ARCH_SLAB_MINALIGN\n * aligned pointers.\n */\n#define __assume_kmalloc_alignment __assume_aligned(ARCH_KMALLOC_MINALIGN)\n#define __assume_slab_alignment __assume_aligned(ARCH_SLAB_MINALIGN)\n#define __assume_page_alignment __assume_aligned(PAGE_SIZE)\n\n/*\n * Kmalloc array related definitions\n */\n\n#ifdef CONFIG_SLAB\n/*\n * The largest kmalloc size supported by the SLAB allocators is\n * 32 megabyte (2^25) or the maximum allocatable page order if that is\n * less than 32 MB.\n *\n * WARNING: Its not easy to increase this value since the allocators have\n * to do various tricks to work around compiler limitations in order to\n * ensure proper constant folding.\n */\n#define KMALLOC_SHIFT_HIGH\t((MAX_ORDER + PAGE_SHIFT - 1) <= 25 ? \\\n\t\t\t\t(MAX_ORDER + PAGE_SHIFT - 1) : 25)\n#define KMALLOC_SHIFT_MAX\tKMALLOC_SHIFT_HIGH\n#ifndef KMALLOC_SHIFT_LOW\n#define KMALLOC_SHIFT_LOW\t5\n#endif\n#endif\n\n#ifdef CONFIG_SLUB\n/*\n * SLUB directly allocates requests fitting in to an order-1 page\n * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.\n */\n#define KMALLOC_SHIFT_HIGH\t(PAGE_SHIFT + 1)\n#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)\n#ifndef KMALLOC_SHIFT_LOW\n#define KMALLOC_SHIFT_LOW\t3\n#endif\n#endif\n\n#ifdef CONFIG_SLOB\n/*\n * SLOB passes all requests larger than one page to the page allocator.\n * No kmalloc array is necessary since objects of different sizes can\n * be allocated from the same page.\n */\n#define KMALLOC_SHIFT_HIGH\tPAGE_SHIFT\n#define KMALLOC_SHIFT_MAX\t(MAX_ORDER + PAGE_SHIFT - 1)\n#ifndef KMALLOC_SHIFT_LOW\n#define KMALLOC_SHIFT_LOW\t3\n#endif\n#endif\n\n/* Maximum allocatable size */\n#define KMALLOC_MAX_SIZE\t(1UL << KMALLOC_SHIFT_MAX)\n/* Maximum size for which we actually use a slab cache */\n#define KMALLOC_MAX_CACHE_SIZE\t(1UL << KMALLOC_SHIFT_HIGH)\n/* Maximum order allocatable via the slab allocator */\n#define KMALLOC_MAX_ORDER\t(KMALLOC_SHIFT_MAX - PAGE_SHIFT)\n\n/*\n * Kmalloc subsystem.\n */\n#ifndef KMALLOC_MIN_SIZE\n#define KMALLOC_MIN_SIZE (1 << KMALLOC_SHIFT_LOW)\n#endif\n\n/*\n * This restriction comes from byte sized index implementation.\n * Page size is normally 2^12 bytes and, in this case, if we want to use\n * byte sized index which can represent 2^8 entries, the size of the object\n * should be equal or greater to 2^12 / 2^8 = 2^4 = 16.\n * If minimum size of kmalloc is less than 16, we use it as minimum object\n * size and give up to use byte sized index.\n */\n#define SLAB_OBJ_MIN_SIZE      (KMALLOC_MIN_SIZE < 16 ? \\\n                               (KMALLOC_MIN_SIZE) : 16)\n\n/*\n * Whenever changing this, take care of that kmalloc_type() and\n * create_kmalloc_caches() still work as intended.\n */\nenum kmalloc_cache_type {\n\tKMALLOC_NORMAL = 0,\n\tKMALLOC_RECLAIM,\n#ifdef CONFIG_ZONE_DMA\n\tKMALLOC_DMA,\n#endif\n\tNR_KMALLOC_TYPES\n};\n\n#ifndef CONFIG_SLOB\nextern struct kmem_cache *\nkmalloc_caches[NR_KMALLOC_TYPES][KMALLOC_SHIFT_HIGH + 1];\n\nstatic __always_inline enum kmalloc_cache_type kmalloc_type(gfp_t flags)\n{\n#ifdef CONFIG_ZONE_DMA\n\t/*\n\t * The most common case is KMALLOC_NORMAL, so test for it\n\t * with a single branch for both flags.\n\t */\n\tif (likely((flags & (__GFP_DMA | __GFP_RECLAIMABLE)) == 0))\n\t\treturn KMALLOC_NORMAL;\n\n\t/*\n\t * At least one of the flags has to be set. If both are, __GFP_DMA\n\t * is more important.\n\t */\n\treturn flags & __GFP_DMA ? KMALLOC_DMA : KMALLOC_RECLAIM;\n#else\n\treturn flags & __GFP_RECLAIMABLE ? KMALLOC_RECLAIM : KMALLOC_NORMAL;\n#endif\n}\n\n/*\n * Figure out which kmalloc slab an allocation of a certain size\n * belongs to.\n * 0 = zero alloc\n * 1 =  65 .. 96 bytes\n * 2 = 129 .. 192 bytes\n * n = 2^(n-1)+1 .. 2^n\n */\nstatic __always_inline unsigned int kmalloc_index(size_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\n\tif (size <= KMALLOC_MIN_SIZE)\n\t\treturn KMALLOC_SHIFT_LOW;\n\n\tif (KMALLOC_MIN_SIZE <= 32 && size > 64 && size <= 96)\n\t\treturn 1;\n\tif (KMALLOC_MIN_SIZE <= 64 && size > 128 && size <= 192)\n\t\treturn 2;\n\tif (size <=          8) return 3;\n\tif (size <=         16) return 4;\n\tif (size <=         32) return 5;\n\tif (size <=         64) return 6;\n\tif (size <=        128) return 7;\n\tif (size <=        256) return 8;\n\tif (size <=        512) return 9;\n\tif (size <=       1024) return 10;\n\tif (size <=   2 * 1024) return 11;\n\tif (size <=   4 * 1024) return 12;\n\tif (size <=   8 * 1024) return 13;\n\tif (size <=  16 * 1024) return 14;\n\tif (size <=  32 * 1024) return 15;\n\tif (size <=  64 * 1024) return 16;\n\tif (size <= 128 * 1024) return 17;\n\tif (size <= 256 * 1024) return 18;\n\tif (size <= 512 * 1024) return 19;\n\tif (size <= 1024 * 1024) return 20;\n\tif (size <=  2 * 1024 * 1024) return 21;\n\tif (size <=  4 * 1024 * 1024) return 22;\n\tif (size <=  8 * 1024 * 1024) return 23;\n\tif (size <=  16 * 1024 * 1024) return 24;\n\tif (size <=  32 * 1024 * 1024) return 25;\n\tif (size <=  64 * 1024 * 1024) return 26;\n\tBUG();\n\n\t/* Will never be reached. Needed because the compiler may complain */\n\treturn -1;\n}\n#endif /* !CONFIG_SLOB */\n\nvoid *__kmalloc(size_t size, gfp_t flags) __assume_kmalloc_alignment __malloc;\nvoid *kmem_cache_alloc(struct kmem_cache *, gfp_t flags) __assume_slab_alignment __malloc;\nvoid kmem_cache_free(struct kmem_cache *, void *);\n\n/*\n * Bulk allocation and freeing operations. These are accelerated in an\n * allocator specific way to avoid taking locks repeatedly or building\n * metadata structures unnecessarily.\n *\n * Note that interrupts must be enabled when calling these functions.\n */\nvoid kmem_cache_free_bulk(struct kmem_cache *, size_t, void **);\nint kmem_cache_alloc_bulk(struct kmem_cache *, gfp_t, size_t, void **);\n\n/*\n * Caller must not use kfree_bulk() on memory not originally allocated\n * by kmalloc(), because the SLOB allocator cannot handle this.\n */\nstatic __always_inline void kfree_bulk(size_t size, void **p)\n{\n\tkmem_cache_free_bulk(NULL, size, p);\n}\n\n#ifdef CONFIG_NUMA\nvoid *__kmalloc_node(size_t size, gfp_t flags, int node) __assume_kmalloc_alignment __malloc;\nvoid *kmem_cache_alloc_node(struct kmem_cache *, gfp_t flags, int node) __assume_slab_alignment __malloc;\n#else\nstatic __always_inline void *__kmalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn __kmalloc(size, flags);\n}\n\nstatic __always_inline void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t flags, int node)\n{\n\treturn kmem_cache_alloc(s, flags);\n}\n#endif\n\n#ifdef CONFIG_TRACING\nextern void *kmem_cache_alloc_trace(struct kmem_cache *, gfp_t, size_t) __assume_slab_alignment __malloc;\n\n#ifdef CONFIG_NUMA\nextern void *kmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t\t\t   gfp_t gfpflags,\n\t\t\t\t\t   int node, size_t size) __assume_slab_alignment __malloc;\n#else\nstatic __always_inline void *\nkmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t      gfp_t gfpflags,\n\t\t\t      int node, size_t size)\n{\n\treturn kmem_cache_alloc_trace(s, gfpflags, size);\n}\n#endif /* CONFIG_NUMA */\n\n#else /* CONFIG_TRACING */\nstatic __always_inline void *kmem_cache_alloc_trace(struct kmem_cache *s,\n\t\tgfp_t flags, size_t size)\n{\n\tvoid *ret = kmem_cache_alloc(s, flags);\n\n\tret = kasan_kmalloc(s, ret, size, flags);\n\treturn ret;\n}\n\nstatic __always_inline void *\nkmem_cache_alloc_node_trace(struct kmem_cache *s,\n\t\t\t      gfp_t gfpflags,\n\t\t\t      int node, size_t size)\n{\n\tvoid *ret = kmem_cache_alloc_node(s, gfpflags, node);\n\n\tret = kasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}\n#endif /* CONFIG_TRACING */\n\nextern void *kmalloc_order(size_t size, gfp_t flags, unsigned int order) __assume_page_alignment __malloc;\n\n#ifdef CONFIG_TRACING\nextern void *kmalloc_order_trace(size_t size, gfp_t flags, unsigned int order) __assume_page_alignment __malloc;\n#else\nstatic __always_inline void *\nkmalloc_order_trace(size_t size, gfp_t flags, unsigned int order)\n{\n\treturn kmalloc_order(size, flags, order);\n}\n#endif\n\nstatic __always_inline void *kmalloc_large(size_t size, gfp_t flags)\n{\n\tunsigned int order = get_order(size);\n\treturn kmalloc_order_trace(size, flags, order);\n}\n\n/**\n * kmalloc - allocate memory\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate.\n *\n * kmalloc is the normal method of allocating memory\n * for objects smaller than page size in the kernel.\n *\n * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN\n * bytes. For @size of power of two bytes, the alignment is also guaranteed\n * to be at least to the size.\n *\n * The @flags argument may be one of the GFP flags defined at\n * include/linux/gfp.h and described at\n * :ref:`Documentation/core-api/mm-api.rst <mm-api-gfp-flags>`\n *\n * The recommended usage of the @flags is described at\n * :ref:`Documentation/core-api/memory-allocation.rst <memory_allocation>`\n *\n * Below is a brief outline of the most useful GFP flags\n *\n * %GFP_KERNEL\n *\tAllocate normal kernel ram. May sleep.\n *\n * %GFP_NOWAIT\n *\tAllocation will not sleep.\n *\n * %GFP_ATOMIC\n *\tAllocation will not sleep.  May use emergency pools.\n *\n * %GFP_HIGHUSER\n *\tAllocate memory from high memory on behalf of user.\n *\n * Also it is possible to set different flags by OR'ing\n * in one or more of the following additional @flags:\n *\n * %__GFP_HIGH\n *\tThis allocation has high priority and may use emergency pools.\n *\n * %__GFP_NOFAIL\n *\tIndicate that this allocation is in no way allowed to fail\n *\t(think twice before using).\n *\n * %__GFP_NORETRY\n *\tIf memory is not immediately available,\n *\tthen give up at once.\n *\n * %__GFP_NOWARN\n *\tIf allocation fails, don't issue any warnings.\n *\n * %__GFP_RETRY_MAYFAIL\n *\tTry really hard to succeed the allocation but fail\n *\teventually.\n */\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags)\n{\n\tif (__builtin_constant_p(size)) {\n#ifndef CONFIG_SLOB\n\t\tunsigned int index;\n#endif\n\t\tif (size > KMALLOC_MAX_CACHE_SIZE)\n\t\t\treturn kmalloc_large(size, flags);\n#ifndef CONFIG_SLOB\n\t\tindex = kmalloc_index(size);\n\n\t\tif (!index)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\treturn kmem_cache_alloc_trace(\n\t\t\t\tkmalloc_caches[kmalloc_type(flags)][index],\n\t\t\t\tflags, size);\n#endif\n\t}\n\treturn __kmalloc(size, flags);\n}\n\nstatic __always_inline void *kmalloc_node(size_t size, gfp_t flags, int node)\n{\n#ifndef CONFIG_SLOB\n\tif (__builtin_constant_p(size) &&\n\t\tsize <= KMALLOC_MAX_CACHE_SIZE) {\n\t\tunsigned int i = kmalloc_index(size);\n\n\t\tif (!i)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\treturn kmem_cache_alloc_node_trace(\n\t\t\t\tkmalloc_caches[kmalloc_type(flags)][i],\n\t\t\t\t\t\tflags, node, size);\n\t}\n#endif\n\treturn __kmalloc_node(size, flags, node);\n}\n\n/**\n * kmalloc_array - allocate memory for an array.\n * @n: number of elements.\n * @size: element size.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(n, size, &bytes)))\n\t\treturn NULL;\n\tif (__builtin_constant_p(n) && __builtin_constant_p(size))\n\t\treturn kmalloc(bytes, flags);\n\treturn __kmalloc(bytes, flags);\n}\n\n/**\n * krealloc_array - reallocate memory for an array.\n * @p: pointer to the memory chunk to reallocate\n * @new_n: new number of elements to alloc\n * @new_size: new size of a single member of the array\n * @flags: the type of memory to allocate (see kmalloc)\n */\nstatic __must_check inline void *\nkrealloc_array(void *p, size_t new_n, size_t new_size, gfp_t flags)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(new_n, new_size, &bytes)))\n\t\treturn NULL;\n\n\treturn krealloc(p, bytes, flags);\n}\n\n/**\n * kcalloc - allocate memory for an array. The memory is set to zero.\n * @n: number of elements.\n * @size: element size.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kcalloc(size_t n, size_t size, gfp_t flags)\n{\n\treturn kmalloc_array(n, size, flags | __GFP_ZERO);\n}\n\n/*\n * kmalloc_track_caller is a special version of kmalloc that records the\n * calling function of the routine calling it for slab leak tracking instead\n * of just the calling function (confusing, eh?).\n * It's useful when the call to kmalloc comes from a widely-used standard\n * allocator where we care about the real place the memory allocation\n * request comes from.\n */\nextern void *__kmalloc_track_caller(size_t, gfp_t, unsigned long);\n#define kmalloc_track_caller(size, flags) \\\n\t__kmalloc_track_caller(size, flags, _RET_IP_)\n\nstatic inline void *kmalloc_array_node(size_t n, size_t size, gfp_t flags,\n\t\t\t\t       int node)\n{\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(n, size, &bytes)))\n\t\treturn NULL;\n\tif (__builtin_constant_p(n) && __builtin_constant_p(size))\n\t\treturn kmalloc_node(bytes, flags, node);\n\treturn __kmalloc_node(bytes, flags, node);\n}\n\nstatic inline void *kcalloc_node(size_t n, size_t size, gfp_t flags, int node)\n{\n\treturn kmalloc_array_node(n, size, flags | __GFP_ZERO, node);\n}\n\n\n#ifdef CONFIG_NUMA\nextern void *__kmalloc_node_track_caller(size_t, gfp_t, int, unsigned long);\n#define kmalloc_node_track_caller(size, flags, node) \\\n\t__kmalloc_node_track_caller(size, flags, node, \\\n\t\t\t_RET_IP_)\n\n#else /* CONFIG_NUMA */\n\n#define kmalloc_node_track_caller(size, flags, node) \\\n\tkmalloc_track_caller(size, flags)\n\n#endif /* CONFIG_NUMA */\n\n/*\n * Shortcuts\n */\nstatic inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags)\n{\n\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);\n}\n\n/**\n * kzalloc - allocate memory. The memory is set to zero.\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kzalloc(size_t size, gfp_t flags)\n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n\n/**\n * kzalloc_node - allocate zeroed memory from a particular memory node.\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate (see kmalloc).\n * @node: memory node from which to allocate\n */\nstatic inline void *kzalloc_node(size_t size, gfp_t flags, int node)\n{\n\treturn kmalloc_node(size, flags | __GFP_ZERO, node);\n}\n\nunsigned int kmem_cache_size(struct kmem_cache *s);\nvoid __init kmem_cache_init_late(void);\n\n#if defined(CONFIG_SMP) && defined(CONFIG_SLAB)\nint slab_prepare_cpu(unsigned int cpu);\nint slab_dead_cpu(unsigned int cpu);\n#else\n#define slab_prepare_cpu\tNULL\n#define slab_dead_cpu\t\tNULL\n#endif\n\n#endif\t/* _LINUX_SLAB_H */\n"}, "2": {"id": 2, "path": "/src/include/net/netlink.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __NET_NETLINK_H\n#define __NET_NETLINK_H\n\n#include <linux/types.h>\n#include <linux/netlink.h>\n#include <linux/jiffies.h>\n#include <linux/in6.h>\n\n/* ========================================================================\n *         Netlink Messages and Attributes Interface (As Seen On TV)\n * ------------------------------------------------------------------------\n *                          Messages Interface\n * ------------------------------------------------------------------------\n *\n * Message Format:\n *    <--- nlmsg_total_size(payload)  --->\n *    <-- nlmsg_msg_size(payload) ->\n *   +----------+- - -+-------------+- - -+-------- - -\n *   | nlmsghdr | Pad |   Payload   | Pad | nlmsghdr\n *   +----------+- - -+-------------+- - -+-------- - -\n *   nlmsg_data(nlh)---^                   ^\n *   nlmsg_next(nlh)-----------------------+\n *\n * Payload Format:\n *    <---------------------- nlmsg_len(nlh) --------------------->\n *    <------ hdrlen ------>       <- nlmsg_attrlen(nlh, hdrlen) ->\n *   +----------------------+- - -+--------------------------------+\n *   |     Family Header    | Pad |           Attributes           |\n *   +----------------------+- - -+--------------------------------+\n *   nlmsg_attrdata(nlh, hdrlen)---^\n *\n * Data Structures:\n *   struct nlmsghdr\t\t\tnetlink message header\n *\n * Message Construction:\n *   nlmsg_new()\t\t\tcreate a new netlink message\n *   nlmsg_put()\t\t\tadd a netlink message to an skb\n *   nlmsg_put_answer()\t\t\tcallback based nlmsg_put()\n *   nlmsg_end()\t\t\tfinalize netlink message\n *   nlmsg_get_pos()\t\t\treturn current position in message\n *   nlmsg_trim()\t\t\ttrim part of message\n *   nlmsg_cancel()\t\t\tcancel message construction\n *   nlmsg_free()\t\t\tfree a netlink message\n *\n * Message Sending:\n *   nlmsg_multicast()\t\t\tmulticast message to several groups\n *   nlmsg_unicast()\t\t\tunicast a message to a single socket\n *   nlmsg_notify()\t\t\tsend notification message\n *\n * Message Length Calculations:\n *   nlmsg_msg_size(payload)\t\tlength of message w/o padding\n *   nlmsg_total_size(payload)\t\tlength of message w/ padding\n *   nlmsg_padlen(payload)\t\tlength of padding at tail\n *\n * Message Payload Access:\n *   nlmsg_data(nlh)\t\t\thead of message payload\n *   nlmsg_len(nlh)\t\t\tlength of message payload\n *   nlmsg_attrdata(nlh, hdrlen)\thead of attributes data\n *   nlmsg_attrlen(nlh, hdrlen)\t\tlength of attributes data\n *\n * Message Parsing:\n *   nlmsg_ok(nlh, remaining)\t\tdoes nlh fit into remaining bytes?\n *   nlmsg_next(nlh, remaining)\t\tget next netlink message\n *   nlmsg_parse()\t\t\tparse attributes of a message\n *   nlmsg_find_attr()\t\t\tfind an attribute in a message\n *   nlmsg_for_each_msg()\t\tloop over all messages\n *   nlmsg_validate()\t\t\tvalidate netlink message incl. attrs\n *   nlmsg_for_each_attr()\t\tloop over all attributes\n *\n * Misc:\n *   nlmsg_report()\t\t\treport back to application?\n *\n * ------------------------------------------------------------------------\n *                          Attributes Interface\n * ------------------------------------------------------------------------\n *\n * Attribute Format:\n *    <------- nla_total_size(payload) ------->\n *    <---- nla_attr_size(payload) ----->\n *   +----------+- - -+- - - - - - - - - +- - -+-------- - -\n *   |  Header  | Pad |     Payload      | Pad |  Header\n *   +----------+- - -+- - - - - - - - - +- - -+-------- - -\n *                     <- nla_len(nla) ->      ^\n *   nla_data(nla)----^                        |\n *   nla_next(nla)-----------------------------'\n *\n * Data Structures:\n *   struct nlattr\t\t\tnetlink attribute header\n *\n * Attribute Construction:\n *   nla_reserve(skb, type, len)\treserve room for an attribute\n *   nla_reserve_nohdr(skb, len)\treserve room for an attribute w/o hdr\n *   nla_put(skb, type, len, data)\tadd attribute to skb\n *   nla_put_nohdr(skb, len, data)\tadd attribute w/o hdr\n *   nla_append(skb, len, data)\t\tappend data to skb\n *\n * Attribute Construction for Basic Types:\n *   nla_put_u8(skb, type, value)\tadd u8 attribute to skb\n *   nla_put_u16(skb, type, value)\tadd u16 attribute to skb\n *   nla_put_u32(skb, type, value)\tadd u32 attribute to skb\n *   nla_put_u64_64bit(skb, type,\n *                     value, padattr)\tadd u64 attribute to skb\n *   nla_put_s8(skb, type, value)\tadd s8 attribute to skb\n *   nla_put_s16(skb, type, value)\tadd s16 attribute to skb\n *   nla_put_s32(skb, type, value)\tadd s32 attribute to skb\n *   nla_put_s64(skb, type, value,\n *               padattr)\t\tadd s64 attribute to skb\n *   nla_put_string(skb, type, str)\tadd string attribute to skb\n *   nla_put_flag(skb, type)\t\tadd flag attribute to skb\n *   nla_put_msecs(skb, type, jiffies,\n *                 padattr)\t\tadd msecs attribute to skb\n *   nla_put_in_addr(skb, type, addr)\tadd IPv4 address attribute to skb\n *   nla_put_in6_addr(skb, type, addr)\tadd IPv6 address attribute to skb\n *\n * Nested Attributes Construction:\n *   nla_nest_start(skb, type)\t\tstart a nested attribute\n *   nla_nest_end(skb, nla)\t\tfinalize a nested attribute\n *   nla_nest_cancel(skb, nla)\t\tcancel nested attribute construction\n *\n * Attribute Length Calculations:\n *   nla_attr_size(payload)\t\tlength of attribute w/o padding\n *   nla_total_size(payload)\t\tlength of attribute w/ padding\n *   nla_padlen(payload)\t\tlength of padding\n *\n * Attribute Payload Access:\n *   nla_data(nla)\t\t\thead of attribute payload\n *   nla_len(nla)\t\t\tlength of attribute payload\n *\n * Attribute Payload Access for Basic Types:\n *   nla_get_u8(nla)\t\t\tget payload for a u8 attribute\n *   nla_get_u16(nla)\t\t\tget payload for a u16 attribute\n *   nla_get_u32(nla)\t\t\tget payload for a u32 attribute\n *   nla_get_u64(nla)\t\t\tget payload for a u64 attribute\n *   nla_get_s8(nla)\t\t\tget payload for a s8 attribute\n *   nla_get_s16(nla)\t\t\tget payload for a s16 attribute\n *   nla_get_s32(nla)\t\t\tget payload for a s32 attribute\n *   nla_get_s64(nla)\t\t\tget payload for a s64 attribute\n *   nla_get_flag(nla)\t\t\treturn 1 if flag is true\n *   nla_get_msecs(nla)\t\t\tget payload for a msecs attribute\n *\n * Attribute Misc:\n *   nla_memcpy(dest, nla, count)\tcopy attribute into memory\n *   nla_memcmp(nla, data, size)\tcompare attribute with memory area\n *   nla_strscpy(dst, nla, size)\tcopy attribute to a sized string\n *   nla_strcmp(nla, str)\t\tcompare attribute with string\n *\n * Attribute Parsing:\n *   nla_ok(nla, remaining)\t\tdoes nla fit into remaining bytes?\n *   nla_next(nla, remaining)\t\tget next netlink attribute\n *   nla_validate()\t\t\tvalidate a stream of attributes\n *   nla_validate_nested()\t\tvalidate a stream of nested attributes\n *   nla_find()\t\t\t\tfind attribute in stream of attributes\n *   nla_find_nested()\t\t\tfind attribute in nested attributes\n *   nla_parse()\t\t\tparse and validate stream of attrs\n *   nla_parse_nested()\t\t\tparse nested attributes\n *   nla_for_each_attr()\t\tloop over all attributes\n *   nla_for_each_nested()\t\tloop over the nested attributes\n *=========================================================================\n */\n\n /**\n  * Standard attribute types to specify validation policy\n  */\nenum {\n\tNLA_UNSPEC,\n\tNLA_U8,\n\tNLA_U16,\n\tNLA_U32,\n\tNLA_U64,\n\tNLA_STRING,\n\tNLA_FLAG,\n\tNLA_MSECS,\n\tNLA_NESTED,\n\tNLA_NESTED_ARRAY,\n\tNLA_NUL_STRING,\n\tNLA_BINARY,\n\tNLA_S8,\n\tNLA_S16,\n\tNLA_S32,\n\tNLA_S64,\n\tNLA_BITFIELD32,\n\tNLA_REJECT,\n\t__NLA_TYPE_MAX,\n};\n\n#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)\n\nstruct netlink_range_validation {\n\tu64 min, max;\n};\n\nstruct netlink_range_validation_signed {\n\ts64 min, max;\n};\n\nenum nla_policy_validation {\n\tNLA_VALIDATE_NONE,\n\tNLA_VALIDATE_RANGE,\n\tNLA_VALIDATE_RANGE_WARN_TOO_LONG,\n\tNLA_VALIDATE_MIN,\n\tNLA_VALIDATE_MAX,\n\tNLA_VALIDATE_MASK,\n\tNLA_VALIDATE_RANGE_PTR,\n\tNLA_VALIDATE_FUNCTION,\n};\n\n/**\n * struct nla_policy - attribute validation policy\n * @type: Type of attribute or NLA_UNSPEC\n * @validation_type: type of attribute validation done in addition to\n *\ttype-specific validation (e.g. range, function call), see\n *\t&enum nla_policy_validation\n * @len: Type specific length of payload\n *\n * Policies are defined as arrays of this struct, the array must be\n * accessible by attribute type up to the highest identifier to be expected.\n *\n * Meaning of `len' field:\n *    NLA_STRING           Maximum length of string\n *    NLA_NUL_STRING       Maximum length of string (excluding NUL)\n *    NLA_FLAG             Unused\n *    NLA_BINARY           Maximum length of attribute payload\n *                         (but see also below with the validation type)\n *    NLA_NESTED,\n *    NLA_NESTED_ARRAY     Length verification is done by checking len of\n *                         nested header (or empty); len field is used if\n *                         nested_policy is also used, for the max attr\n *                         number in the nested policy.\n *    NLA_U8, NLA_U16,\n *    NLA_U32, NLA_U64,\n *    NLA_S8, NLA_S16,\n *    NLA_S32, NLA_S64,\n *    NLA_MSECS            Leaving the length field zero will verify the\n *                         given type fits, using it verifies minimum length\n *                         just like \"All other\"\n *    NLA_BITFIELD32       Unused\n *    NLA_REJECT           Unused\n *    All other            Minimum length of attribute payload\n *\n * Meaning of validation union:\n *    NLA_BITFIELD32       This is a 32-bit bitmap/bitselector attribute and\n *                         `bitfield32_valid' is the u32 value of valid flags\n *    NLA_REJECT           This attribute is always rejected and `reject_message'\n *                         may point to a string to report as the error instead\n *                         of the generic one in extended ACK.\n *    NLA_NESTED           `nested_policy' to a nested policy to validate, must\n *                         also set `len' to the max attribute number. Use the\n *                         provided NLA_POLICY_NESTED() macro.\n *                         Note that nla_parse() will validate, but of course not\n *                         parse, the nested sub-policies.\n *    NLA_NESTED_ARRAY     `nested_policy' points to a nested policy to validate,\n *                         must also set `len' to the max attribute number. Use\n *                         the provided NLA_POLICY_NESTED_ARRAY() macro.\n *                         The difference to NLA_NESTED is the structure:\n *                         NLA_NESTED has the nested attributes directly inside\n *                         while an array has the nested attributes at another\n *                         level down and the attribute types directly in the\n *                         nesting don't matter.\n *    NLA_U8,\n *    NLA_U16,\n *    NLA_U32,\n *    NLA_U64,\n *    NLA_S8,\n *    NLA_S16,\n *    NLA_S32,\n *    NLA_S64              The `min' and `max' fields are used depending on the\n *                         validation_type field, if that is min/max/range then\n *                         the min, max or both are used (respectively) to check\n *                         the value of the integer attribute.\n *                         Note that in the interest of code simplicity and\n *                         struct size both limits are s16, so you cannot\n *                         enforce a range that doesn't fall within the range\n *                         of s16 - do that as usual in the code instead.\n *                         Use the NLA_POLICY_MIN(), NLA_POLICY_MAX() and\n *                         NLA_POLICY_RANGE() macros.\n *    NLA_U8,\n *    NLA_U16,\n *    NLA_U32,\n *    NLA_U64              If the validation_type field instead is set to\n *                         NLA_VALIDATE_RANGE_PTR, `range' must be a pointer\n *                         to a struct netlink_range_validation that indicates\n *                         the min/max values.\n *                         Use NLA_POLICY_FULL_RANGE().\n *    NLA_S8,\n *    NLA_S16,\n *    NLA_S32,\n *    NLA_S64              If the validation_type field instead is set to\n *                         NLA_VALIDATE_RANGE_PTR, `range_signed' must be a\n *                         pointer to a struct netlink_range_validation_signed\n *                         that indicates the min/max values.\n *                         Use NLA_POLICY_FULL_RANGE_SIGNED().\n *\n *    NLA_BINARY           If the validation type is like the ones for integers\n *                         above, then the min/max length (not value like for\n *                         integers) of the attribute is enforced.\n *\n *    All other            Unused - but note that it's a union\n *\n * Meaning of `validate' field, use via NLA_POLICY_VALIDATE_FN:\n *    NLA_BINARY           Validation function called for the attribute.\n *    All other            Unused - but note that it's a union\n *\n * Example:\n *\n * static const u32 myvalidflags = 0xff231023;\n *\n * static const struct nla_policy my_policy[ATTR_MAX+1] = {\n * \t[ATTR_FOO] = { .type = NLA_U16 },\n *\t[ATTR_BAR] = { .type = NLA_STRING, .len = BARSIZ },\n *\t[ATTR_BAZ] = NLA_POLICY_EXACT_LEN(sizeof(struct mystruct)),\n *\t[ATTR_GOO] = NLA_POLICY_BITFIELD32(myvalidflags),\n * };\n */\nstruct nla_policy {\n\tu8\t\ttype;\n\tu8\t\tvalidation_type;\n\tu16\t\tlen;\n\tunion {\n\t\tconst u32 bitfield32_valid;\n\t\tconst u32 mask;\n\t\tconst char *reject_message;\n\t\tconst struct nla_policy *nested_policy;\n\t\tstruct netlink_range_validation *range;\n\t\tstruct netlink_range_validation_signed *range_signed;\n\t\tstruct {\n\t\t\ts16 min, max;\n\t\t};\n\t\tint (*validate)(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack);\n\t\t/* This entry is special, and used for the attribute at index 0\n\t\t * only, and specifies special data about the policy, namely it\n\t\t * specifies the \"boundary type\" where strict length validation\n\t\t * starts for any attribute types >= this value, also, strict\n\t\t * nesting validation starts here.\n\t\t *\n\t\t * Additionally, it means that NLA_UNSPEC is actually NLA_REJECT\n\t\t * for any types >= this, so need to use NLA_POLICY_MIN_LEN() to\n\t\t * get the previous pure { .len = xyz } behaviour. The advantage\n\t\t * of this is that types not specified in the policy will be\n\t\t * rejected.\n\t\t *\n\t\t * For completely new families it should be set to 1 so that the\n\t\t * validation is enforced for all attributes. For existing ones\n\t\t * it should be set at least when new attributes are added to\n\t\t * the enum used by the policy, and be set to the new value that\n\t\t * was added to enforce strict validation from thereon.\n\t\t */\n\t\tu16 strict_start_type;\n\t};\n};\n\n#define NLA_POLICY_ETH_ADDR\t\tNLA_POLICY_EXACT_LEN(ETH_ALEN)\n#define NLA_POLICY_ETH_ADDR_COMPAT\tNLA_POLICY_EXACT_LEN_WARN(ETH_ALEN)\n\n#define _NLA_POLICY_NESTED(maxattr, policy) \\\n\t{ .type = NLA_NESTED, .nested_policy = policy, .len = maxattr }\n#define _NLA_POLICY_NESTED_ARRAY(maxattr, policy) \\\n\t{ .type = NLA_NESTED_ARRAY, .nested_policy = policy, .len = maxattr }\n#define NLA_POLICY_NESTED(policy) \\\n\t_NLA_POLICY_NESTED(ARRAY_SIZE(policy) - 1, policy)\n#define NLA_POLICY_NESTED_ARRAY(policy) \\\n\t_NLA_POLICY_NESTED_ARRAY(ARRAY_SIZE(policy) - 1, policy)\n#define NLA_POLICY_BITFIELD32(valid) \\\n\t{ .type = NLA_BITFIELD32, .bitfield32_valid = valid }\n\n#define __NLA_IS_UINT_TYPE(tp)\t\t\t\t\t\t\\\n\t(tp == NLA_U8 || tp == NLA_U16 || tp == NLA_U32 || tp == NLA_U64)\n#define __NLA_IS_SINT_TYPE(tp)\t\t\t\t\t\t\\\n\t(tp == NLA_S8 || tp == NLA_S16 || tp == NLA_S32 || tp == NLA_S64)\n\n#define __NLA_ENSURE(condition) BUILD_BUG_ON_ZERO(!(condition))\n#define NLA_ENSURE_UINT_TYPE(tp)\t\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp)) + tp)\n#define NLA_ENSURE_UINT_OR_BINARY_TYPE(tp)\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp) ||\t\\\n\t\t      tp == NLA_MSECS ||\t\t\\\n\t\t      tp == NLA_BINARY) + tp)\n#define NLA_ENSURE_SINT_TYPE(tp)\t\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_SINT_TYPE(tp)) + tp)\n#define NLA_ENSURE_INT_OR_BINARY_TYPE(tp)\t\t\\\n\t(__NLA_ENSURE(__NLA_IS_UINT_TYPE(tp) ||\t\t\\\n\t\t      __NLA_IS_SINT_TYPE(tp) ||\t\t\\\n\t\t      tp == NLA_MSECS ||\t\t\\\n\t\t      tp == NLA_BINARY) + tp)\n#define NLA_ENSURE_NO_VALIDATION_PTR(tp)\t\t\\\n\t(__NLA_ENSURE(tp != NLA_BITFIELD32 &&\t\t\\\n\t\t      tp != NLA_REJECT &&\t\t\\\n\t\t      tp != NLA_NESTED &&\t\t\\\n\t\t      tp != NLA_NESTED_ARRAY) + tp)\n\n#define NLA_POLICY_RANGE(tp, _min, _max) {\t\t\\\n\t.type = NLA_ENSURE_INT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_RANGE,\t\t\\\n\t.min = _min,\t\t\t\t\t\\\n\t.max = _max\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_FULL_RANGE(tp, _range) {\t\t\\\n\t.type = NLA_ENSURE_UINT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_RANGE_PTR,\t\\\n\t.range = _range,\t\t\t\t\\\n}\n\n#define NLA_POLICY_FULL_RANGE_SIGNED(tp, _range) {\t\\\n\t.type = NLA_ENSURE_SINT_TYPE(tp),\t\t\\\n\t.validation_type = NLA_VALIDATE_RANGE_PTR,\t\\\n\t.range_signed = _range,\t\t\t\t\\\n}\n\n#define NLA_POLICY_MIN(tp, _min) {\t\t\t\\\n\t.type = NLA_ENSURE_INT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_MIN,\t\t\\\n\t.min = _min,\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_MAX(tp, _max) {\t\t\t\\\n\t.type = NLA_ENSURE_INT_OR_BINARY_TYPE(tp),\t\\\n\t.validation_type = NLA_VALIDATE_MAX,\t\t\\\n\t.max = _max,\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_MASK(tp, _mask) {\t\t\t\\\n\t.type = NLA_ENSURE_UINT_TYPE(tp),\t\t\\\n\t.validation_type = NLA_VALIDATE_MASK,\t\t\\\n\t.mask = _mask,\t\t\t\t\t\\\n}\n\n#define NLA_POLICY_VALIDATE_FN(tp, fn, ...) {\t\t\\\n\t.type = NLA_ENSURE_NO_VALIDATION_PTR(tp),\t\\\n\t.validation_type = NLA_VALIDATE_FUNCTION,\t\\\n\t.validate = fn,\t\t\t\t\t\\\n\t.len = __VA_ARGS__ + 0,\t\t\t\t\\\n}\n\n#define NLA_POLICY_EXACT_LEN(_len)\tNLA_POLICY_RANGE(NLA_BINARY, _len, _len)\n#define NLA_POLICY_EXACT_LEN_WARN(_len) {\t\t\t\\\n\t.type = NLA_BINARY,\t\t\t\t\t\\\n\t.validation_type = NLA_VALIDATE_RANGE_WARN_TOO_LONG,\t\\\n\t.min = _len,\t\t\t\t\t\t\\\n\t.max = _len\t\t\t\t\t\t\\\n}\n#define NLA_POLICY_MIN_LEN(_len)\tNLA_POLICY_MIN(NLA_BINARY, _len)\n\n/**\n * struct nl_info - netlink source information\n * @nlh: Netlink message header of original request\n * @nl_net: Network namespace\n * @portid: Netlink PORTID of requesting application\n * @skip_notify: Skip netlink notifications to user space\n * @skip_notify_kernel: Skip selected in-kernel notifications\n */\nstruct nl_info {\n\tstruct nlmsghdr\t\t*nlh;\n\tstruct net\t\t*nl_net;\n\tu32\t\t\tportid;\n\tu8\t\t\tskip_notify:1,\n\t\t\t\tskip_notify_kernel:1;\n};\n\n/**\n * enum netlink_validation - netlink message/attribute validation levels\n * @NL_VALIDATE_LIBERAL: Old-style \"be liberal\" validation, not caring about\n *\textra data at the end of the message, attributes being longer than\n *\tthey should be, or unknown attributes being present.\n * @NL_VALIDATE_TRAILING: Reject junk data encountered after attribute parsing.\n * @NL_VALIDATE_MAXTYPE: Reject attributes > max type; Together with _TRAILING\n *\tthis is equivalent to the old nla_parse_strict()/nlmsg_parse_strict().\n * @NL_VALIDATE_UNSPEC: Reject attributes with NLA_UNSPEC in the policy.\n *\tThis can safely be set by the kernel when the given policy has no\n *\tNLA_UNSPEC anymore, and can thus be used to ensure policy entries\n *\tare enforced going forward.\n * @NL_VALIDATE_STRICT_ATTRS: strict attribute policy parsing (e.g.\n *\tU8, U16, U32 must have exact size, etc.)\n * @NL_VALIDATE_NESTED: Check that NLA_F_NESTED is set for NLA_NESTED(_ARRAY)\n *\tand unset for other policies.\n */\nenum netlink_validation {\n\tNL_VALIDATE_LIBERAL = 0,\n\tNL_VALIDATE_TRAILING = BIT(0),\n\tNL_VALIDATE_MAXTYPE = BIT(1),\n\tNL_VALIDATE_UNSPEC = BIT(2),\n\tNL_VALIDATE_STRICT_ATTRS = BIT(3),\n\tNL_VALIDATE_NESTED = BIT(4),\n};\n\n#define NL_VALIDATE_DEPRECATED_STRICT (NL_VALIDATE_TRAILING |\\\n\t\t\t\t       NL_VALIDATE_MAXTYPE)\n#define NL_VALIDATE_STRICT (NL_VALIDATE_TRAILING |\\\n\t\t\t    NL_VALIDATE_MAXTYPE |\\\n\t\t\t    NL_VALIDATE_UNSPEC |\\\n\t\t\t    NL_VALIDATE_STRICT_ATTRS |\\\n\t\t\t    NL_VALIDATE_NESTED)\n\nint netlink_rcv_skb(struct sk_buff *skb,\n\t\t    int (*cb)(struct sk_buff *, struct nlmsghdr *,\n\t\t\t      struct netlink_ext_ack *));\nint nlmsg_notify(struct sock *sk, struct sk_buff *skb, u32 portid,\n\t\t unsigned int group, int report, gfp_t flags);\n\nint __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack);\nint __nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head,\n\t\tint len, const struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack);\nint nla_policy_len(const struct nla_policy *, int);\nstruct nlattr *nla_find(const struct nlattr *head, int len, int attrtype);\nssize_t nla_strscpy(char *dst, const struct nlattr *nla, size_t dstsize);\nchar *nla_strdup(const struct nlattr *nla, gfp_t flags);\nint nla_memcpy(void *dest, const struct nlattr *src, int count);\nint nla_memcmp(const struct nlattr *nla, const void *data, size_t size);\nint nla_strcmp(const struct nlattr *nla, const char *str);\nstruct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen);\nstruct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t   int attrlen, int padattr);\nvoid *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen);\nstruct nlattr *nla_reserve(struct sk_buff *skb, int attrtype, int attrlen);\nstruct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t int attrlen, int padattr);\nvoid *nla_reserve_nohdr(struct sk_buff *skb, int attrlen);\nvoid __nla_put(struct sk_buff *skb, int attrtype, int attrlen,\n\t       const void *data);\nvoid __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t     const void *data, int padattr);\nvoid __nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data);\nint nla_put(struct sk_buff *skb, int attrtype, int attrlen, const void *data);\nint nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t  const void *data, int padattr);\nint nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data);\nint nla_append(struct sk_buff *skb, int attrlen, const void *data);\n\n/**************************************************************************\n * Netlink Messages\n **************************************************************************/\n\n/**\n * nlmsg_msg_size - length of netlink message not including padding\n * @payload: length of message payload\n */\nstatic inline int nlmsg_msg_size(int payload)\n{\n\treturn NLMSG_HDRLEN + payload;\n}\n\n/**\n * nlmsg_total_size - length of netlink message including padding\n * @payload: length of message payload\n */\nstatic inline int nlmsg_total_size(int payload)\n{\n\treturn NLMSG_ALIGN(nlmsg_msg_size(payload));\n}\n\n/**\n * nlmsg_padlen - length of padding at the message's tail\n * @payload: length of message payload\n */\nstatic inline int nlmsg_padlen(int payload)\n{\n\treturn nlmsg_total_size(payload) - nlmsg_msg_size(payload);\n}\n\n/**\n * nlmsg_data - head of message payload\n * @nlh: netlink message header\n */\nstatic inline void *nlmsg_data(const struct nlmsghdr *nlh)\n{\n\treturn (unsigned char *) nlh + NLMSG_HDRLEN;\n}\n\n/**\n * nlmsg_len - length of message payload\n * @nlh: netlink message header\n */\nstatic inline int nlmsg_len(const struct nlmsghdr *nlh)\n{\n\treturn nlh->nlmsg_len - NLMSG_HDRLEN;\n}\n\n/**\n * nlmsg_attrdata - head of attributes data\n * @nlh: netlink message header\n * @hdrlen: length of family specific header\n */\nstatic inline struct nlattr *nlmsg_attrdata(const struct nlmsghdr *nlh,\n\t\t\t\t\t    int hdrlen)\n{\n\tunsigned char *data = nlmsg_data(nlh);\n\treturn (struct nlattr *) (data + NLMSG_ALIGN(hdrlen));\n}\n\n/**\n * nlmsg_attrlen - length of attributes data\n * @nlh: netlink message header\n * @hdrlen: length of family specific header\n */\nstatic inline int nlmsg_attrlen(const struct nlmsghdr *nlh, int hdrlen)\n{\n\treturn nlmsg_len(nlh) - NLMSG_ALIGN(hdrlen);\n}\n\n/**\n * nlmsg_ok - check if the netlink message fits into the remaining bytes\n * @nlh: netlink message header\n * @remaining: number of bytes remaining in message stream\n */\nstatic inline int nlmsg_ok(const struct nlmsghdr *nlh, int remaining)\n{\n\treturn (remaining >= (int) sizeof(struct nlmsghdr) &&\n\t\tnlh->nlmsg_len >= sizeof(struct nlmsghdr) &&\n\t\tnlh->nlmsg_len <= remaining);\n}\n\n/**\n * nlmsg_next - next netlink message in message stream\n * @nlh: netlink message header\n * @remaining: number of bytes remaining in message stream\n *\n * Returns the next netlink message in the message stream and\n * decrements remaining by the size of the current message.\n */\nstatic inline struct nlmsghdr *\nnlmsg_next(const struct nlmsghdr *nlh, int *remaining)\n{\n\tint totlen = NLMSG_ALIGN(nlh->nlmsg_len);\n\n\t*remaining -= totlen;\n\n\treturn (struct nlmsghdr *) ((unsigned char *) nlh + totlen);\n}\n\n/**\n * nla_parse - Parse a stream of attributes into a tb buffer\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @policy: validation policy\n * @extack: extended ACK pointer\n *\n * Parses a stream of attributes and stores a pointer to each attribute in\n * the tb array accessible via the attribute type. Attributes with a type\n * exceeding maxtype will be rejected, policy must be specified, attributes\n * will be validated in the strictest way possible.\n *\n * Returns 0 on success or a negative error code.\n */\nstatic inline int nla_parse(struct nlattr **tb, int maxtype,\n\t\t\t    const struct nlattr *head, int len,\n\t\t\t    const struct nla_policy *policy,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, head, len, policy,\n\t\t\t   NL_VALIDATE_STRICT, extack);\n}\n\n/**\n * nla_parse_deprecated - Parse a stream of attributes into a tb buffer\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @policy: validation policy\n * @extack: extended ACK pointer\n *\n * Parses a stream of attributes and stores a pointer to each attribute in\n * the tb array accessible via the attribute type. Attributes with a type\n * exceeding maxtype will be ignored and attributes from the policy are not\n * always strictly validated (only for new attributes).\n *\n * Returns 0 on success or a negative error code.\n */\nstatic inline int nla_parse_deprecated(struct nlattr **tb, int maxtype,\n\t\t\t\t       const struct nlattr *head, int len,\n\t\t\t\t       const struct nla_policy *policy,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, head, len, policy,\n\t\t\t   NL_VALIDATE_LIBERAL, extack);\n}\n\n/**\n * nla_parse_deprecated_strict - Parse a stream of attributes into a tb buffer\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @policy: validation policy\n * @extack: extended ACK pointer\n *\n * Parses a stream of attributes and stores a pointer to each attribute in\n * the tb array accessible via the attribute type. Attributes with a type\n * exceeding maxtype will be rejected as well as trailing data, but the\n * policy is not completely strictly validated (only for new attributes).\n *\n * Returns 0 on success or a negative error code.\n */\nstatic inline int nla_parse_deprecated_strict(struct nlattr **tb, int maxtype,\n\t\t\t\t\t      const struct nlattr *head,\n\t\t\t\t\t      int len,\n\t\t\t\t\t      const struct nla_policy *policy,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, head, len, policy,\n\t\t\t   NL_VALIDATE_DEPRECATED_STRICT, extack);\n}\n\n/**\n * __nlmsg_parse - parse attributes of a netlink message\n * @nlh: netlink message header\n * @hdrlen: length of family specific header\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK report struct\n *\n * See nla_parse()\n */\nstatic inline int __nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t\tstruct nlattr *tb[], int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header length\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),\n\t\t\t   nlmsg_attrlen(nlh, hdrlen), policy, validate,\n\t\t\t   extack);\n}\n\n/**\n * nlmsg_parse - parse attributes of a netlink message\n * @nlh: netlink message header\n * @hdrlen: length of family specific header\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @extack: extended ACK report struct\n *\n * See nla_parse()\n */\nstatic inline int nlmsg_parse(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,\n\t\t\t     NL_VALIDATE_STRICT, extack);\n}\n\n/**\n * nlmsg_parse_deprecated - parse attributes of a netlink message\n * @nlh: netlink message header\n * @hdrlen: length of family specific header\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @extack: extended ACK report struct\n *\n * See nla_parse_deprecated()\n */\nstatic inline int nlmsg_parse_deprecated(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t\t\t struct nlattr *tb[], int maxtype,\n\t\t\t\t\t const struct nla_policy *policy,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,\n\t\t\t     NL_VALIDATE_LIBERAL, extack);\n}\n\n/**\n * nlmsg_parse_deprecated_strict - parse attributes of a netlink message\n * @nlh: netlink message header\n * @hdrlen: length of family specific header\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @extack: extended ACK report struct\n *\n * See nla_parse_deprecated_strict()\n */\nstatic inline int\nnlmsg_parse_deprecated_strict(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nlmsg_parse(nlh, hdrlen, tb, maxtype, policy,\n\t\t\t     NL_VALIDATE_DEPRECATED_STRICT, extack);\n}\n\n/**\n * nlmsg_find_attr - find a specific attribute in a netlink message\n * @nlh: netlink message header\n * @hdrlen: length of familiy specific header\n * @attrtype: type of attribute to look for\n *\n * Returns the first attribute which matches the specified type.\n */\nstatic inline struct nlattr *nlmsg_find_attr(const struct nlmsghdr *nlh,\n\t\t\t\t\t     int hdrlen, int attrtype)\n{\n\treturn nla_find(nlmsg_attrdata(nlh, hdrlen),\n\t\t\tnlmsg_attrlen(nlh, hdrlen), attrtype);\n}\n\n/**\n * nla_validate_deprecated - Validate a stream of attributes\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK report struct\n *\n * Validates all attributes in the specified attribute stream against the\n * specified policy. Validation is done in liberal mode.\n * See documenation of struct nla_policy for more details.\n *\n * Returns 0 on success or a negative error code.\n */\nstatic inline int nla_validate_deprecated(const struct nlattr *head, int len,\n\t\t\t\t\t  int maxtype,\n\t\t\t\t\t  const struct nla_policy *policy,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate(head, len, maxtype, policy, NL_VALIDATE_LIBERAL,\n\t\t\t      extack);\n}\n\n/**\n * nla_validate - Validate a stream of attributes\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @extack: extended ACK report struct\n *\n * Validates all attributes in the specified attribute stream against the\n * specified policy. Validation is done in strict mode.\n * See documenation of struct nla_policy for more details.\n *\n * Returns 0 on success or a negative error code.\n */\nstatic inline int nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t\t       const struct nla_policy *policy,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate(head, len, maxtype, policy, NL_VALIDATE_STRICT,\n\t\t\t      extack);\n}\n\n/**\n * nlmsg_validate_deprecated - validate a netlink message including attributes\n * @nlh: netlinket message header\n * @hdrlen: length of familiy specific header\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @extack: extended ACK report struct\n */\nstatic inline int nlmsg_validate_deprecated(const struct nlmsghdr *nlh,\n\t\t\t\t\t    int hdrlen, int maxtype,\n\t\t\t\t\t    const struct nla_policy *policy,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\n\treturn __nla_validate(nlmsg_attrdata(nlh, hdrlen),\n\t\t\t      nlmsg_attrlen(nlh, hdrlen), maxtype,\n\t\t\t      policy, NL_VALIDATE_LIBERAL, extack);\n}\n\n\n\n/**\n * nlmsg_report - need to report back to application?\n * @nlh: netlink message header\n *\n * Returns 1 if a report back to the application is requested.\n */\nstatic inline int nlmsg_report(const struct nlmsghdr *nlh)\n{\n\treturn !!(nlh->nlmsg_flags & NLM_F_ECHO);\n}\n\n/**\n * nlmsg_for_each_attr - iterate over a stream of attributes\n * @pos: loop counter, set to current attribute\n * @nlh: netlink message header\n * @hdrlen: length of familiy specific header\n * @rem: initialized to len, holds bytes currently remaining in stream\n */\n#define nlmsg_for_each_attr(pos, nlh, hdrlen, rem) \\\n\tnla_for_each_attr(pos, nlmsg_attrdata(nlh, hdrlen), \\\n\t\t\t  nlmsg_attrlen(nlh, hdrlen), rem)\n\n/**\n * nlmsg_put - Add a new netlink message to an skb\n * @skb: socket buffer to store message in\n * @portid: netlink PORTID of requesting application\n * @seq: sequence number of message\n * @type: message type\n * @payload: length of message payload\n * @flags: message flags\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the message header and payload.\n */\nstatic inline struct nlmsghdr *nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\t\t int type, int payload, int flags)\n{\n\tif (unlikely(skb_tailroom(skb) < nlmsg_total_size(payload)))\n\t\treturn NULL;\n\n\treturn __nlmsg_put(skb, portid, seq, type, payload, flags);\n}\n\n/**\n * nlmsg_put_answer - Add a new callback based netlink message to an skb\n * @skb: socket buffer to store message in\n * @cb: netlink callback\n * @type: message type\n * @payload: length of message payload\n * @flags: message flags\n *\n * Returns NULL if the tailroom of the skb is insufficient to store\n * the message header and payload.\n */\nstatic inline struct nlmsghdr *nlmsg_put_answer(struct sk_buff *skb,\n\t\t\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\t\t\tint type, int payload,\n\t\t\t\t\t\tint flags)\n{\n\treturn nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t type, payload, flags);\n}\n\n/**\n * nlmsg_new - Allocate a new netlink message\n * @payload: size of the message payload\n * @flags: the type of memory to allocate.\n *\n * Use NLMSG_DEFAULT_SIZE if the size of the payload isn't known\n * and a good default is needed.\n */\nstatic inline struct sk_buff *nlmsg_new(size_t payload, gfp_t flags)\n{\n\treturn alloc_skb(nlmsg_total_size(payload), flags);\n}\n\n/**\n * nlmsg_end - Finalize a netlink message\n * @skb: socket buffer the message is stored in\n * @nlh: netlink message header\n *\n * Corrects the netlink message header to include the appeneded\n * attributes. Only necessary if attributes have been added to\n * the message.\n */\nstatic inline void nlmsg_end(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - (unsigned char *)nlh;\n}\n\n/**\n * nlmsg_get_pos - return current position in netlink message\n * @skb: socket buffer the message is stored in\n *\n * Returns a pointer to the current tail of the message.\n */\nstatic inline void *nlmsg_get_pos(struct sk_buff *skb)\n{\n\treturn skb_tail_pointer(skb);\n}\n\n/**\n * nlmsg_trim - Trim message to a mark\n * @skb: socket buffer the message is stored in\n * @mark: mark to trim to\n *\n * Trims the message to the provided mark.\n */\nstatic inline void nlmsg_trim(struct sk_buff *skb, const void *mark)\n{\n\tif (mark) {\n\t\tWARN_ON((unsigned char *) mark < skb->data);\n\t\tskb_trim(skb, (unsigned char *) mark - skb->data);\n\t}\n}\n\n/**\n * nlmsg_cancel - Cancel construction of a netlink message\n * @skb: socket buffer the message is stored in\n * @nlh: netlink message header\n *\n * Removes the complete netlink message including all\n * attributes from the socket buffer again.\n */\nstatic inline void nlmsg_cancel(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tnlmsg_trim(skb, nlh);\n}\n\n/**\n * nlmsg_free - free a netlink message\n * @skb: socket buffer of netlink message\n */\nstatic inline void nlmsg_free(struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\n/**\n * nlmsg_multicast - multicast a netlink message\n * @sk: netlink socket to spread messages to\n * @skb: netlink message as socket buffer\n * @portid: own netlink portid to avoid sending to yourself\n * @group: multicast group id\n * @flags: allocation flags\n */\nstatic inline int nlmsg_multicast(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  u32 portid, unsigned int group, gfp_t flags)\n{\n\tint err;\n\n\tNETLINK_CB(skb).dst_group = group;\n\n\terr = netlink_broadcast(sk, skb, portid, group, flags);\n\tif (err > 0)\n\t\terr = 0;\n\n\treturn err;\n}\n\n/**\n * nlmsg_unicast - unicast a netlink message\n * @sk: netlink socket to spread message to\n * @skb: netlink message as socket buffer\n * @portid: netlink portid of the destination socket\n */\nstatic inline int nlmsg_unicast(struct sock *sk, struct sk_buff *skb, u32 portid)\n{\n\tint err;\n\n\terr = netlink_unicast(sk, skb, portid, MSG_DONTWAIT);\n\tif (err > 0)\n\t\terr = 0;\n\n\treturn err;\n}\n\n/**\n * nlmsg_for_each_msg - iterate over a stream of messages\n * @pos: loop counter, set to current message\n * @head: head of message stream\n * @len: length of message stream\n * @rem: initialized to len, holds bytes currently remaining in stream\n */\n#define nlmsg_for_each_msg(pos, head, len, rem) \\\n\tfor (pos = head, rem = len; \\\n\t     nlmsg_ok(pos, rem); \\\n\t     pos = nlmsg_next(pos, &(rem)))\n\n/**\n * nl_dump_check_consistent - check if sequence is consistent and advertise if not\n * @cb: netlink callback structure that stores the sequence number\n * @nlh: netlink message header to write the flag to\n *\n * This function checks if the sequence (generation) number changed during dump\n * and if it did, advertises it in the netlink message header.\n *\n * The correct way to use it is to set cb->seq to the generation counter when\n * all locks for dumping have been acquired, and then call this function for\n * each message that is generated.\n *\n * Note that due to initialisation concerns, 0 is an invalid sequence number\n * and must not be used by code that uses this functionality.\n */\nstatic inline void\nnl_dump_check_consistent(struct netlink_callback *cb,\n\t\t\t struct nlmsghdr *nlh)\n{\n\tif (cb->prev_seq && cb->seq != cb->prev_seq)\n\t\tnlh->nlmsg_flags |= NLM_F_DUMP_INTR;\n\tcb->prev_seq = cb->seq;\n}\n\n/**************************************************************************\n * Netlink Attributes\n **************************************************************************/\n\n/**\n * nla_attr_size - length of attribute not including padding\n * @payload: length of payload\n */\nstatic inline int nla_attr_size(int payload)\n{\n\treturn NLA_HDRLEN + payload;\n}\n\n/**\n * nla_total_size - total length of attribute including padding\n * @payload: length of payload\n */\nstatic inline int nla_total_size(int payload)\n{\n\treturn NLA_ALIGN(nla_attr_size(payload));\n}\n\n/**\n * nla_padlen - length of padding at the tail of attribute\n * @payload: length of payload\n */\nstatic inline int nla_padlen(int payload)\n{\n\treturn nla_total_size(payload) - nla_attr_size(payload);\n}\n\n/**\n * nla_type - attribute type\n * @nla: netlink attribute\n */\nstatic inline int nla_type(const struct nlattr *nla)\n{\n\treturn nla->nla_type & NLA_TYPE_MASK;\n}\n\n/**\n * nla_data - head of payload\n * @nla: netlink attribute\n */\nstatic inline void *nla_data(const struct nlattr *nla)\n{\n\treturn (char *) nla + NLA_HDRLEN;\n}\n\n/**\n * nla_len - length of payload\n * @nla: netlink attribute\n */\nstatic inline int nla_len(const struct nlattr *nla)\n{\n\treturn nla->nla_len - NLA_HDRLEN;\n}\n\n/**\n * nla_ok - check if the netlink attribute fits into the remaining bytes\n * @nla: netlink attribute\n * @remaining: number of bytes remaining in attribute stream\n */\nstatic inline int nla_ok(const struct nlattr *nla, int remaining)\n{\n\treturn remaining >= (int) sizeof(*nla) &&\n\t       nla->nla_len >= sizeof(*nla) &&\n\t       nla->nla_len <= remaining;\n}\n\n/**\n * nla_next - next netlink attribute in attribute stream\n * @nla: netlink attribute\n * @remaining: number of bytes remaining in attribute stream\n *\n * Returns the next netlink attribute in the attribute stream and\n * decrements remaining by the size of the current attribute.\n */\nstatic inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tunsigned int totlen = NLA_ALIGN(nla->nla_len);\n\n\t*remaining -= totlen;\n\treturn (struct nlattr *) ((char *) nla + totlen);\n}\n\n/**\n * nla_find_nested - find attribute in a set of nested attributes\n * @nla: attribute containing the nested attributes\n * @attrtype: type of attribute to look for\n *\n * Returns the first attribute which matches the specified type.\n */\nstatic inline struct nlattr *\nnla_find_nested(const struct nlattr *nla, int attrtype)\n{\n\treturn nla_find(nla_data(nla), nla_len(nla), attrtype);\n}\n\n/**\n * nla_parse_nested - parse nested attributes\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @nla: attribute containing the nested attributes\n * @policy: validation policy\n * @extack: extended ACK report struct\n *\n * See nla_parse()\n */\nstatic inline int nla_parse_nested(struct nlattr *tb[], int maxtype,\n\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t   const struct nla_policy *policy,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (!(nla->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla, \"NLA_F_NESTED is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,\n\t\t\t   NL_VALIDATE_STRICT, extack);\n}\n\n/**\n * nla_parse_nested_deprecated - parse nested attributes\n * @tb: destination array with maxtype+1 elements\n * @maxtype: maximum attribute type to be expected\n * @nla: attribute containing the nested attributes\n * @policy: validation policy\n * @extack: extended ACK report struct\n *\n * See nla_parse_deprecated()\n */\nstatic inline int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,\n\t\t\t\t\t      const struct nlattr *nla,\n\t\t\t\t\t      const struct nla_policy *policy,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,\n\t\t\t   NL_VALIDATE_LIBERAL, extack);\n}\n\n/**\n * nla_put_u8 - Add a u8 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_u8(struct sk_buff *skb, int attrtype, u8 value)\n{\n\t/* temporary variables to work around GCC PR81715 with asan-stack=1 */\n\tu8 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(u8), &tmp);\n}\n\n/**\n * nla_put_u16 - Add a u16 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_u16(struct sk_buff *skb, int attrtype, u16 value)\n{\n\tu16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(u16), &tmp);\n}\n\n/**\n * nla_put_be16 - Add a __be16 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_be16(struct sk_buff *skb, int attrtype, __be16 value)\n{\n\t__be16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__be16), &tmp);\n}\n\n/**\n * nla_put_net16 - Add 16-bit network byte order netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_net16(struct sk_buff *skb, int attrtype, __be16 value)\n{\n\t__be16 tmp = value;\n\n\treturn nla_put_be16(skb, attrtype | NLA_F_NET_BYTEORDER, tmp);\n}\n\n/**\n * nla_put_le16 - Add a __le16 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_le16(struct sk_buff *skb, int attrtype, __le16 value)\n{\n\t__le16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__le16), &tmp);\n}\n\n/**\n * nla_put_u32 - Add a u32 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_u32(struct sk_buff *skb, int attrtype, u32 value)\n{\n\tu32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(u32), &tmp);\n}\n\n/**\n * nla_put_be32 - Add a __be32 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_be32(struct sk_buff *skb, int attrtype, __be32 value)\n{\n\t__be32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__be32), &tmp);\n}\n\n/**\n * nla_put_net32 - Add 32-bit network byte order netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_net32(struct sk_buff *skb, int attrtype, __be32 value)\n{\n\t__be32 tmp = value;\n\n\treturn nla_put_be32(skb, attrtype | NLA_F_NET_BYTEORDER, tmp);\n}\n\n/**\n * nla_put_le32 - Add a __le32 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_le32(struct sk_buff *skb, int attrtype, __le32 value)\n{\n\t__le32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(__le32), &tmp);\n}\n\n/**\n * nla_put_u64_64bit - Add a u64 netlink attribute to a skb and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n * @padattr: attribute type for the padding\n */\nstatic inline int nla_put_u64_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t    u64 value, int padattr)\n{\n\tu64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(u64), &tmp, padattr);\n}\n\n/**\n * nla_put_be64 - Add a __be64 netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n * @padattr: attribute type for the padding\n */\nstatic inline int nla_put_be64(struct sk_buff *skb, int attrtype, __be64 value,\n\t\t\t       int padattr)\n{\n\t__be64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(__be64), &tmp, padattr);\n}\n\n/**\n * nla_put_net64 - Add 64-bit network byte order nlattr to a skb and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n * @padattr: attribute type for the padding\n */\nstatic inline int nla_put_net64(struct sk_buff *skb, int attrtype, __be64 value,\n\t\t\t\tint padattr)\n{\n\t__be64 tmp = value;\n\n\treturn nla_put_be64(skb, attrtype | NLA_F_NET_BYTEORDER, tmp,\n\t\t\t    padattr);\n}\n\n/**\n * nla_put_le64 - Add a __le64 netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n * @padattr: attribute type for the padding\n */\nstatic inline int nla_put_le64(struct sk_buff *skb, int attrtype, __le64 value,\n\t\t\t       int padattr)\n{\n\t__le64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(__le64), &tmp, padattr);\n}\n\n/**\n * nla_put_s8 - Add a s8 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_s8(struct sk_buff *skb, int attrtype, s8 value)\n{\n\ts8 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(s8), &tmp);\n}\n\n/**\n * nla_put_s16 - Add a s16 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_s16(struct sk_buff *skb, int attrtype, s16 value)\n{\n\ts16 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(s16), &tmp);\n}\n\n/**\n * nla_put_s32 - Add a s32 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n */\nstatic inline int nla_put_s32(struct sk_buff *skb, int attrtype, s32 value)\n{\n\ts32 tmp = value;\n\n\treturn nla_put(skb, attrtype, sizeof(s32), &tmp);\n}\n\n/**\n * nla_put_s64 - Add a s64 netlink attribute to a socket buffer and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: numeric value\n * @padattr: attribute type for the padding\n */\nstatic inline int nla_put_s64(struct sk_buff *skb, int attrtype, s64 value,\n\t\t\t      int padattr)\n{\n\ts64 tmp = value;\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(s64), &tmp, padattr);\n}\n\n/**\n * nla_put_string - Add a string netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @str: NUL terminated string\n */\nstatic inline int nla_put_string(struct sk_buff *skb, int attrtype,\n\t\t\t\t const char *str)\n{\n\treturn nla_put(skb, attrtype, strlen(str) + 1, str);\n}\n\n/**\n * nla_put_flag - Add a flag netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n */\nstatic inline int nla_put_flag(struct sk_buff *skb, int attrtype)\n{\n\treturn nla_put(skb, attrtype, 0, NULL);\n}\n\n/**\n * nla_put_msecs - Add a msecs netlink attribute to a skb and align it\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @njiffies: number of jiffies to convert to msecs\n * @padattr: attribute type for the padding\n */\nstatic inline int nla_put_msecs(struct sk_buff *skb, int attrtype,\n\t\t\t\tunsigned long njiffies, int padattr)\n{\n\tu64 tmp = jiffies_to_msecs(njiffies);\n\n\treturn nla_put_64bit(skb, attrtype, sizeof(u64), &tmp, padattr);\n}\n\n/**\n * nla_put_in_addr - Add an IPv4 address netlink attribute to a socket\n * buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @addr: IPv4 address\n */\nstatic inline int nla_put_in_addr(struct sk_buff *skb, int attrtype,\n\t\t\t\t  __be32 addr)\n{\n\t__be32 tmp = addr;\n\n\treturn nla_put_be32(skb, attrtype, tmp);\n}\n\n/**\n * nla_put_in6_addr - Add an IPv6 address netlink attribute to a socket\n * buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @addr: IPv6 address\n */\nstatic inline int nla_put_in6_addr(struct sk_buff *skb, int attrtype,\n\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn nla_put(skb, attrtype, sizeof(*addr), addr);\n}\n\n/**\n * nla_put_bitfield32 - Add a bitfield32 netlink attribute to a socket buffer\n * @skb: socket buffer to add attribute to\n * @attrtype: attribute type\n * @value: value carrying bits\n * @selector: selector of valid bits\n */\nstatic inline int nla_put_bitfield32(struct sk_buff *skb, int attrtype,\n\t\t\t\t     __u32 value, __u32 selector)\n{\n\tstruct nla_bitfield32 tmp = { value, selector, };\n\n\treturn nla_put(skb, attrtype, sizeof(tmp), &tmp);\n}\n\n/**\n * nla_get_u32 - return payload of u32 attribute\n * @nla: u32 netlink attribute\n */\nstatic inline u32 nla_get_u32(const struct nlattr *nla)\n{\n\treturn *(u32 *) nla_data(nla);\n}\n\n/**\n * nla_get_be32 - return payload of __be32 attribute\n * @nla: __be32 netlink attribute\n */\nstatic inline __be32 nla_get_be32(const struct nlattr *nla)\n{\n\treturn *(__be32 *) nla_data(nla);\n}\n\n/**\n * nla_get_le32 - return payload of __le32 attribute\n * @nla: __le32 netlink attribute\n */\nstatic inline __le32 nla_get_le32(const struct nlattr *nla)\n{\n\treturn *(__le32 *) nla_data(nla);\n}\n\n/**\n * nla_get_u16 - return payload of u16 attribute\n * @nla: u16 netlink attribute\n */\nstatic inline u16 nla_get_u16(const struct nlattr *nla)\n{\n\treturn *(u16 *) nla_data(nla);\n}\n\n/**\n * nla_get_be16 - return payload of __be16 attribute\n * @nla: __be16 netlink attribute\n */\nstatic inline __be16 nla_get_be16(const struct nlattr *nla)\n{\n\treturn *(__be16 *) nla_data(nla);\n}\n\n/**\n * nla_get_le16 - return payload of __le16 attribute\n * @nla: __le16 netlink attribute\n */\nstatic inline __le16 nla_get_le16(const struct nlattr *nla)\n{\n\treturn *(__le16 *) nla_data(nla);\n}\n\n/**\n * nla_get_u8 - return payload of u8 attribute\n * @nla: u8 netlink attribute\n */\nstatic inline u8 nla_get_u8(const struct nlattr *nla)\n{\n\treturn *(u8 *) nla_data(nla);\n}\n\n/**\n * nla_get_u64 - return payload of u64 attribute\n * @nla: u64 netlink attribute\n */\nstatic inline u64 nla_get_u64(const struct nlattr *nla)\n{\n\tu64 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\n\treturn tmp;\n}\n\n/**\n * nla_get_be64 - return payload of __be64 attribute\n * @nla: __be64 netlink attribute\n */\nstatic inline __be64 nla_get_be64(const struct nlattr *nla)\n{\n\t__be64 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\n\treturn tmp;\n}\n\n/**\n * nla_get_le64 - return payload of __le64 attribute\n * @nla: __le64 netlink attribute\n */\nstatic inline __le64 nla_get_le64(const struct nlattr *nla)\n{\n\treturn *(__le64 *) nla_data(nla);\n}\n\n/**\n * nla_get_s32 - return payload of s32 attribute\n * @nla: s32 netlink attribute\n */\nstatic inline s32 nla_get_s32(const struct nlattr *nla)\n{\n\treturn *(s32 *) nla_data(nla);\n}\n\n/**\n * nla_get_s16 - return payload of s16 attribute\n * @nla: s16 netlink attribute\n */\nstatic inline s16 nla_get_s16(const struct nlattr *nla)\n{\n\treturn *(s16 *) nla_data(nla);\n}\n\n/**\n * nla_get_s8 - return payload of s8 attribute\n * @nla: s8 netlink attribute\n */\nstatic inline s8 nla_get_s8(const struct nlattr *nla)\n{\n\treturn *(s8 *) nla_data(nla);\n}\n\n/**\n * nla_get_s64 - return payload of s64 attribute\n * @nla: s64 netlink attribute\n */\nstatic inline s64 nla_get_s64(const struct nlattr *nla)\n{\n\ts64 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\n\treturn tmp;\n}\n\n/**\n * nla_get_flag - return payload of flag attribute\n * @nla: flag netlink attribute\n */\nstatic inline int nla_get_flag(const struct nlattr *nla)\n{\n\treturn !!nla;\n}\n\n/**\n * nla_get_msecs - return payload of msecs attribute\n * @nla: msecs netlink attribute\n *\n * Returns the number of milliseconds in jiffies.\n */\nstatic inline unsigned long nla_get_msecs(const struct nlattr *nla)\n{\n\tu64 msecs = nla_get_u64(nla);\n\n\treturn msecs_to_jiffies((unsigned long) msecs);\n}\n\n/**\n * nla_get_in_addr - return payload of IPv4 address attribute\n * @nla: IPv4 address netlink attribute\n */\nstatic inline __be32 nla_get_in_addr(const struct nlattr *nla)\n{\n\treturn *(__be32 *) nla_data(nla);\n}\n\n/**\n * nla_get_in6_addr - return payload of IPv6 address attribute\n * @nla: IPv6 address netlink attribute\n */\nstatic inline struct in6_addr nla_get_in6_addr(const struct nlattr *nla)\n{\n\tstruct in6_addr tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\treturn tmp;\n}\n\n/**\n * nla_get_bitfield32 - return payload of 32 bitfield attribute\n * @nla: nla_bitfield32 attribute\n */\nstatic inline struct nla_bitfield32 nla_get_bitfield32(const struct nlattr *nla)\n{\n\tstruct nla_bitfield32 tmp;\n\n\tnla_memcpy(&tmp, nla, sizeof(tmp));\n\treturn tmp;\n}\n\n/**\n * nla_memdup - duplicate attribute memory (kmemdup)\n * @src: netlink attribute to duplicate from\n * @gfp: GFP mask\n */\nstatic inline void *nla_memdup(const struct nlattr *src, gfp_t gfp)\n{\n\treturn kmemdup(nla_data(src), nla_len(src), gfp);\n}\n\n/**\n * nla_nest_start_noflag - Start a new level of nested attributes\n * @skb: socket buffer to add attributes to\n * @attrtype: attribute type of container\n *\n * This function exists for backward compatibility to use in APIs which never\n * marked their nest attributes with NLA_F_NESTED flag. New APIs should use\n * nla_nest_start() which sets the flag.\n *\n * Returns the container attribute or NULL on error\n */\nstatic inline struct nlattr *nla_nest_start_noflag(struct sk_buff *skb,\n\t\t\t\t\t\t   int attrtype)\n{\n\tstruct nlattr *start = (struct nlattr *)skb_tail_pointer(skb);\n\n\tif (nla_put(skb, attrtype, 0, NULL) < 0)\n\t\treturn NULL;\n\n\treturn start;\n}\n\n/**\n * nla_nest_start - Start a new level of nested attributes, with NLA_F_NESTED\n * @skb: socket buffer to add attributes to\n * @attrtype: attribute type of container\n *\n * Unlike nla_nest_start_noflag(), mark the nest attribute with NLA_F_NESTED\n * flag. This is the preferred function to use in new code.\n *\n * Returns the container attribute or NULL on error\n */\nstatic inline struct nlattr *nla_nest_start(struct sk_buff *skb, int attrtype)\n{\n\treturn nla_nest_start_noflag(skb, attrtype | NLA_F_NESTED);\n}\n\n/**\n * nla_nest_end - Finalize nesting of attributes\n * @skb: socket buffer the attributes are stored in\n * @start: container attribute\n *\n * Corrects the container attribute header to include the all\n * appeneded attributes.\n *\n * Returns the total data length of the skb.\n */\nstatic inline int nla_nest_end(struct sk_buff *skb, struct nlattr *start)\n{\n\tstart->nla_len = skb_tail_pointer(skb) - (unsigned char *)start;\n\treturn skb->len;\n}\n\n/**\n * nla_nest_cancel - Cancel nesting of attributes\n * @skb: socket buffer the message is stored in\n * @start: container attribute\n *\n * Removes the container attribute and including all nested\n * attributes. Returns -EMSGSIZE\n */\nstatic inline void nla_nest_cancel(struct sk_buff *skb, struct nlattr *start)\n{\n\tnlmsg_trim(skb, start);\n}\n\n/**\n * __nla_validate_nested - Validate a stream of nested attributes\n * @start: container attribute\n * @maxtype: maximum attribute type to be expected\n * @policy: validation policy\n * @validate: validation strictness\n * @extack: extended ACK report struct\n *\n * Validates all attributes in the nested attribute stream against the\n * specified policy. Attributes with a type exceeding maxtype will be\n * ignored. See documenation of struct nla_policy for more details.\n *\n * Returns 0 on success or a negative error code.\n */\nstatic inline int __nla_validate_nested(const struct nlattr *start, int maxtype,\n\t\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\t\tunsigned int validate,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate(nla_data(start), nla_len(start), maxtype, policy,\n\t\t\t      validate, extack);\n}\n\nstatic inline int\nnla_validate_nested(const struct nlattr *start, int maxtype,\n\t\t    const struct nla_policy *policy,\n\t\t    struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_nested(start, maxtype, policy,\n\t\t\t\t     NL_VALIDATE_STRICT, extack);\n}\n\nstatic inline int\nnla_validate_nested_deprecated(const struct nlattr *start, int maxtype,\n\t\t\t       const struct nla_policy *policy,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_nested(start, maxtype, policy,\n\t\t\t\t     NL_VALIDATE_LIBERAL, extack);\n}\n\n/**\n * nla_need_padding_for_64bit - test 64-bit alignment of the next attribute\n * @skb: socket buffer the message is stored in\n *\n * Return true if padding is needed to align the next attribute (nla_data()) to\n * a 64-bit aligned area.\n */\nstatic inline bool nla_need_padding_for_64bit(struct sk_buff *skb)\n{\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t/* The nlattr header is 4 bytes in size, that's why we test\n\t * if the skb->data _is_ aligned.  A NOP attribute, plus\n\t * nlattr header for next attribute, will make nla_data()\n\t * 8-byte aligned.\n\t */\n\tif (IS_ALIGNED((unsigned long)skb_tail_pointer(skb), 8))\n\t\treturn true;\n#endif\n\treturn false;\n}\n\n/**\n * nla_align_64bit - 64-bit align the nla_data() of next attribute\n * @skb: socket buffer the message is stored in\n * @padattr: attribute type for the padding\n *\n * Conditionally emit a padding netlink attribute in order to make\n * the next attribute we emit have a 64-bit aligned nla_data() area.\n * This will only be done in architectures which do not have\n * CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS defined.\n *\n * Returns zero on success or a negative error code.\n */\nstatic inline int nla_align_64bit(struct sk_buff *skb, int padattr)\n{\n\tif (nla_need_padding_for_64bit(skb) &&\n\t    !nla_reserve(skb, padattr, 0))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\n/**\n * nla_total_size_64bit - total length of attribute including padding\n * @payload: length of payload\n */\nstatic inline int nla_total_size_64bit(int payload)\n{\n\treturn NLA_ALIGN(nla_attr_size(payload))\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t\t+ NLA_ALIGN(nla_attr_size(0))\n#endif\n\t\t;\n}\n\n/**\n * nla_for_each_attr - iterate over a stream of attributes\n * @pos: loop counter, set to current attribute\n * @head: head of attribute stream\n * @len: length of attribute stream\n * @rem: initialized to len, holds bytes currently remaining in stream\n */\n#define nla_for_each_attr(pos, head, len, rem) \\\n\tfor (pos = head, rem = len; \\\n\t     nla_ok(pos, rem); \\\n\t     pos = nla_next(pos, &(rem)))\n\n/**\n * nla_for_each_nested - iterate over nested attributes\n * @pos: loop counter, set to current attribute\n * @nla: attribute containing the nested attributes\n * @rem: initialized to len, holds bytes currently remaining in stream\n */\n#define nla_for_each_nested(pos, nla, rem) \\\n\tnla_for_each_attr(pos, nla_data(nla), nla_len(nla), rem)\n\n/**\n * nla_is_last - Test if attribute is last in stream\n * @nla: attribute to test\n * @rem: bytes remaining in stream\n */\nstatic inline bool nla_is_last(const struct nlattr *nla, int rem)\n{\n\treturn nla->nla_len == rem;\n}\n\nvoid nla_get_range_unsigned(const struct nla_policy *pt,\n\t\t\t    struct netlink_range_validation *range);\nvoid nla_get_range_signed(const struct nla_policy *pt,\n\t\t\t  struct netlink_range_validation_signed *range);\n\nstruct netlink_policy_dump_state;\n\nint netlink_policy_dump_add_policy(struct netlink_policy_dump_state **pstate,\n\t\t\t\t   const struct nla_policy *policy,\n\t\t\t\t   unsigned int maxtype);\nint netlink_policy_dump_get_policy_idx(struct netlink_policy_dump_state *state,\n\t\t\t\t       const struct nla_policy *policy,\n\t\t\t\t       unsigned int maxtype);\nbool netlink_policy_dump_loop(struct netlink_policy_dump_state *state);\nint netlink_policy_dump_write(struct sk_buff *skb,\n\t\t\t      struct netlink_policy_dump_state *state);\nint netlink_policy_dump_attr_size_estimate(const struct nla_policy *pt);\nint netlink_policy_dump_write_attr(struct sk_buff *skb,\n\t\t\t\t   const struct nla_policy *pt,\n\t\t\t\t   int nestattr);\nvoid netlink_policy_dump_free(struct netlink_policy_dump_state *state);\n\n#endif\n"}, "3": {"id": 3, "path": "/src/include/linux/err.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_ERR_H\n#define _LINUX_ERR_H\n\n#include <linux/compiler.h>\n#include <linux/types.h>\n\n#include <asm/errno.h>\n\n/*\n * Kernel pointers have redundant information, so we can use a\n * scheme where we can return either an error code or a normal\n * pointer with the same return value.\n *\n * This should be a per-architecture thing, to allow different\n * error and pointer decisions.\n */\n#define MAX_ERRNO\t4095\n\n#ifndef __ASSEMBLY__\n\n#define IS_ERR_VALUE(x) unlikely((unsigned long)(void *)(x) >= (unsigned long)-MAX_ERRNO)\n\nstatic inline void * __must_check ERR_PTR(long error)\n{\n\treturn (void *) error;\n}\n\nstatic inline long __must_check PTR_ERR(__force const void *ptr)\n{\n\treturn (long) ptr;\n}\n\nstatic inline bool __must_check IS_ERR(__force const void *ptr)\n{\n\treturn IS_ERR_VALUE((unsigned long)ptr);\n}\n\nstatic inline bool __must_check IS_ERR_OR_NULL(__force const void *ptr)\n{\n\treturn unlikely(!ptr) || IS_ERR_VALUE((unsigned long)ptr);\n}\n\n/**\n * ERR_CAST - Explicitly cast an error-valued pointer to another pointer type\n * @ptr: The pointer to cast.\n *\n * Explicitly cast an error-valued pointer to another pointer type in such a\n * way as to make it clear that's what's going on.\n */\nstatic inline void * __must_check ERR_CAST(__force const void *ptr)\n{\n\t/* cast away the const */\n\treturn (void *) ptr;\n}\n\nstatic inline int __must_check PTR_ERR_OR_ZERO(__force const void *ptr)\n{\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\telse\n\t\treturn 0;\n}\n\n#endif\n\n#endif /* _LINUX_ERR_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/compiler.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_H\n#define __LINUX_COMPILER_H\n\n#include <linux/compiler_types.h>\n\n#ifndef __ASSEMBLY__\n\n#ifdef __KERNEL__\n\n/*\n * Note: DISABLE_BRANCH_PROFILING can be used by special lowlevel code\n * to disable branch tracing on a per file basis.\n */\n#if defined(CONFIG_TRACE_BRANCH_PROFILING) \\\n    && !defined(DISABLE_BRANCH_PROFILING) && !defined(__CHECKER__)\nvoid ftrace_likely_update(struct ftrace_likely_data *f, int val,\n\t\t\t  int expect, int is_constant);\n\n#define likely_notrace(x)\t__builtin_expect(!!(x), 1)\n#define unlikely_notrace(x)\t__builtin_expect(!!(x), 0)\n\n#define __branch_check__(x, expect, is_constant) ({\t\t\t\\\n\t\t\tlong ______r;\t\t\t\t\t\\\n\t\t\tstatic struct ftrace_likely_data\t\t\\\n\t\t\t\t__aligned(4)\t\t\t\t\\\n\t\t\t\t__section(\"_ftrace_annotated_branch\")\t\\\n\t\t\t\t______f = {\t\t\t\t\\\n\t\t\t\t.data.func = __func__,\t\t\t\\\n\t\t\t\t.data.file = __FILE__,\t\t\t\\\n\t\t\t\t.data.line = __LINE__,\t\t\t\\\n\t\t\t};\t\t\t\t\t\t\\\n\t\t\t______r = __builtin_expect(!!(x), expect);\t\\\n\t\t\tftrace_likely_update(&______f, ______r,\t\t\\\n\t\t\t\t\t     expect, is_constant);\t\\\n\t\t\t______r;\t\t\t\t\t\\\n\t\t})\n\n/*\n * Using __builtin_constant_p(x) to ignore cases where the return\n * value is always the same.  This idea is taken from a similar patch\n * written by Daniel Walker.\n */\n# ifndef likely\n#  define likely(x)\t(__branch_check__(x, 1, __builtin_constant_p(x)))\n# endif\n# ifndef unlikely\n#  define unlikely(x)\t(__branch_check__(x, 0, __builtin_constant_p(x)))\n# endif\n\n#ifdef CONFIG_PROFILE_ALL_BRANCHES\n/*\n * \"Define 'is'\", Bill Clinton\n * \"Define 'if'\", Steven Rostedt\n */\n#define if(cond, ...) if ( __trace_if_var( !!(cond , ## __VA_ARGS__) ) )\n\n#define __trace_if_var(cond) (__builtin_constant_p(cond) ? (cond) : __trace_if_value(cond))\n\n#define __trace_if_value(cond) ({\t\t\t\\\n\tstatic struct ftrace_branch_data\t\t\\\n\t\t__aligned(4)\t\t\t\t\\\n\t\t__section(\"_ftrace_branch\")\t\t\\\n\t\t__if_trace = {\t\t\t\t\\\n\t\t\t.func = __func__,\t\t\\\n\t\t\t.file = __FILE__,\t\t\\\n\t\t\t.line = __LINE__,\t\t\\\n\t\t};\t\t\t\t\t\\\n\t(cond) ?\t\t\t\t\t\\\n\t\t(__if_trace.miss_hit[1]++,1) :\t\t\\\n\t\t(__if_trace.miss_hit[0]++,0);\t\t\\\n})\n\n#endif /* CONFIG_PROFILE_ALL_BRANCHES */\n\n#else\n# define likely(x)\t__builtin_expect(!!(x), 1)\n# define unlikely(x)\t__builtin_expect(!!(x), 0)\n# define likely_notrace(x)\tlikely(x)\n# define unlikely_notrace(x)\tunlikely(x)\n#endif\n\n/* Optimization barrier */\n#ifndef barrier\n/* The \"volatile\" is due to gcc bugs */\n# define barrier() __asm__ __volatile__(\"\": : :\"memory\")\n#endif\n\n#ifndef barrier_data\n/*\n * This version is i.e. to prevent dead stores elimination on @ptr\n * where gcc and llvm may behave differently when otherwise using\n * normal barrier(): while gcc behavior gets along with a normal\n * barrier(), llvm needs an explicit input variable to be assumed\n * clobbered. The issue is as follows: while the inline asm might\n * access any memory it wants, the compiler could have fit all of\n * @ptr into memory registers instead, and since @ptr never escaped\n * from that, it proved that the inline asm wasn't touching any of\n * it. This version works well with both compilers, i.e. we're telling\n * the compiler that the inline asm absolutely may see the contents\n * of @ptr. See also: https://llvm.org/bugs/show_bug.cgi?id=15495\n */\n# define barrier_data(ptr) __asm__ __volatile__(\"\": :\"r\"(ptr) :\"memory\")\n#endif\n\n/* workaround for GCC PR82365 if needed */\n#ifndef barrier_before_unreachable\n# define barrier_before_unreachable() do { } while (0)\n#endif\n\n/* Unreachable code */\n#ifdef CONFIG_STACK_VALIDATION\n/*\n * These macros help objtool understand GCC code flow for unreachable code.\n * The __COUNTER__ based labels are a hack to make each instance of the macros\n * unique, to convince GCC not to merge duplicate inline asm statements.\n */\n#define annotate_reachable() ({\t\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.reachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define annotate_unreachable() ({\t\t\t\t\t\\\n\tasm volatile(\"%c0:\\n\\t\"\t\t\t\t\t\t\\\n\t\t     \".pushsection .discard.unreachable\\n\\t\"\t\t\\\n\t\t     \".long %c0b - .\\n\\t\"\t\t\t\t\\\n\t\t     \".popsection\\n\\t\" : : \"i\" (__COUNTER__));\t\t\\\n})\n#define ASM_UNREACHABLE\t\t\t\t\t\t\t\\\n\t\"999:\\n\\t\"\t\t\t\t\t\t\t\\\n\t\".pushsection .discard.unreachable\\n\\t\"\t\t\t\t\\\n\t\".long 999b - .\\n\\t\"\t\t\t\t\t\t\\\n\t\".popsection\\n\\t\"\n\n/* Annotate a C jump table to allow objtool to follow the code flow */\n#define __annotate_jump_table __section(\".rodata..c_jump_table\")\n\n#else\n#define annotate_reachable()\n#define annotate_unreachable()\n#define __annotate_jump_table\n#endif\n\n#ifndef ASM_UNREACHABLE\n# define ASM_UNREACHABLE\n#endif\n#ifndef unreachable\n# define unreachable() do {\t\t\\\n\tannotate_unreachable();\t\t\\\n\t__builtin_unreachable();\t\\\n} while (0)\n#endif\n\n/*\n * KENTRY - kernel entry point\n * This can be used to annotate symbols (functions or data) that are used\n * without their linker symbol being referenced explicitly. For example,\n * interrupt vector handlers, or functions in the kernel image that are found\n * programatically.\n *\n * Not required for symbols exported with EXPORT_SYMBOL, or initcalls. Those\n * are handled in their own way (with KEEP() in linker scripts).\n *\n * KENTRY can be avoided if the symbols in question are marked as KEEP() in the\n * linker script. For example an architecture could KEEP() its entire\n * boot/exception vector code rather than annotate each function and data.\n */\n#ifndef KENTRY\n# define KENTRY(sym)\t\t\t\t\t\t\\\n\textern typeof(sym) sym;\t\t\t\t\t\\\n\tstatic const unsigned long __kentry_##sym\t\t\\\n\t__used\t\t\t\t\t\t\t\\\n\t__attribute__((__section__(\"___kentry+\" #sym)))\t\t\\\n\t= (unsigned long)&sym;\n#endif\n\n#ifndef RELOC_HIDE\n# define RELOC_HIDE(ptr, off)\t\t\t\t\t\\\n  ({ unsigned long __ptr;\t\t\t\t\t\\\n     __ptr = (unsigned long) (ptr);\t\t\t\t\\\n    (typeof(ptr)) (__ptr + (off)); })\n#endif\n\n#ifndef OPTIMIZER_HIDE_VAR\n/* Make the optimizer believe the variable can be manipulated arbitrarily. */\n#define OPTIMIZER_HIDE_VAR(var)\t\t\t\t\t\t\\\n\t__asm__ (\"\" : \"=r\" (var) : \"0\" (var))\n#endif\n\n/* Not-quite-unique ID. */\n#ifndef __UNIQUE_ID\n# define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __LINE__)\n#endif\n\n/**\n * data_race - mark an expression as containing intentional data races\n *\n * This data_race() macro is useful for situations in which data races\n * should be forgiven.  One example is diagnostic code that accesses\n * shared variables but is not a part of the core synchronization design.\n *\n * This macro *does not* affect normal code generation, but is a hint\n * to tooling that data races here are to be ignored.\n */\n#define data_race(expr)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t__unqual_scalar_typeof(({ expr; })) __v = ({\t\t\t\\\n\t\t__kcsan_disable_current();\t\t\t\t\\\n\t\texpr;\t\t\t\t\t\t\t\\\n\t});\t\t\t\t\t\t\t\t\\\n\t__kcsan_enable_current();\t\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#endif /* __KERNEL__ */\n\n/*\n * Force the compiler to emit 'sym' as a symbol, so that we can reference\n * it from inline assembler. Necessary in case 'sym' could be inlined\n * otherwise, or eliminated entirely due to lack of references that are\n * visible to the compiler.\n */\n#define __ADDRESSABLE(sym) \\\n\tstatic void * __section(\".discard.addressable\") __used \\\n\t\t__UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;\n\n/**\n * offset_to_ptr - convert a relative memory offset to an absolute pointer\n * @off:\tthe address of the 32-bit offset value\n */\nstatic inline void *offset_to_ptr(const int *off)\n{\n\treturn (void *)((unsigned long)off + *off);\n}\n\n#endif /* __ASSEMBLY__ */\n\n/* &a[0] degrades to a pointer: a different type from an array */\n#define __must_be_array(a)\tBUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))\n\n/*\n * This is needed in functions which generate the stack canary, see\n * arch/x86/kernel/smpboot.c::start_secondary() for an example.\n */\n#define prevent_tail_call_optimization()\tmb()\n\n#include <asm/rwonce.h>\n\n#endif /* __LINUX_COMPILER_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/netlink.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_NETLINK_H\n#define __LINUX_NETLINK_H\n\n\n#include <linux/capability.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <net/scm.h>\n#include <uapi/linux/netlink.h>\n\nstruct net;\n\nvoid do_trace_netlink_extack(const char *msg);\n\nstatic inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)\n{\n\treturn (struct nlmsghdr *)skb->data;\n}\n\nenum netlink_skb_flags {\n\tNETLINK_SKB_DST\t\t= 0x8,\t/* Dst set in sendto or sendmsg */\n};\n\nstruct netlink_skb_parms {\n\tstruct scm_creds\tcreds;\t\t/* Skb credentials\t*/\n\t__u32\t\t\tportid;\n\t__u32\t\t\tdst_group;\n\t__u32\t\t\tflags;\n\tstruct sock\t\t*sk;\n\tbool\t\t\tnsid_is_set;\n\tint\t\t\tnsid;\n};\n\n#define NETLINK_CB(skb)\t\t(*(struct netlink_skb_parms*)&((skb)->cb))\n#define NETLINK_CREDS(skb)\t(&NETLINK_CB((skb)).creds)\n\n\nvoid netlink_table_grab(void);\nvoid netlink_table_ungrab(void);\n\n#define NL_CFG_F_NONROOT_RECV\t(1 << 0)\n#define NL_CFG_F_NONROOT_SEND\t(1 << 1)\n\n/* optional Netlink kernel configuration parameters */\nstruct netlink_kernel_cfg {\n\tunsigned int\tgroups;\n\tunsigned int\tflags;\n\tvoid\t\t(*input)(struct sk_buff *skb);\n\tstruct mutex\t*cb_mutex;\n\tint\t\t(*bind)(struct net *net, int group);\n\tvoid\t\t(*unbind)(struct net *net, int group);\n\tbool\t\t(*compare)(struct net *net, struct sock *sk);\n};\n\nstruct sock *__netlink_kernel_create(struct net *net, int unit,\n\t\t\t\t\t    struct module *module,\n\t\t\t\t\t    struct netlink_kernel_cfg *cfg);\nstatic inline struct sock *\nnetlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg)\n{\n\treturn __netlink_kernel_create(net, unit, THIS_MODULE, cfg);\n}\n\n/* this can be increased when necessary - don't expose to userland */\n#define NETLINK_MAX_COOKIE_LEN\t20\n\n/**\n * struct netlink_ext_ack - netlink extended ACK report struct\n * @_msg: message string to report - don't access directly, use\n *\t%NL_SET_ERR_MSG\n * @bad_attr: attribute with error\n * @policy: policy for a bad attribute\n * @cookie: cookie data to return to userspace (for success)\n * @cookie_len: actual cookie data length\n */\nstruct netlink_ext_ack {\n\tconst char *_msg;\n\tconst struct nlattr *bad_attr;\n\tconst struct nla_policy *policy;\n\tu8 cookie[NETLINK_MAX_COOKIE_LEN];\n\tu8 cookie_len;\n};\n\n/* Always use this macro, this allows later putting the\n * message into a separate section or such for things\n * like translation or listing all possible messages.\n * Currently string formatting is not supported (due\n * to the lack of an output buffer.)\n */\n#define NL_SET_ERR_MSG(extack, msg) do {\t\t\\\n\tstatic const char __msg[] = msg;\t\t\\\n\tstruct netlink_ext_ack *__extack = (extack);\t\\\n\t\t\t\t\t\t\t\\\n\tdo_trace_netlink_extack(__msg);\t\t\t\\\n\t\t\t\t\t\t\t\\\n\tif (__extack)\t\t\t\t\t\\\n\t\t__extack->_msg = __msg;\t\t\t\\\n} while (0)\n\n#define NL_SET_ERR_MSG_MOD(extack, msg)\t\t\t\\\n\tNL_SET_ERR_MSG((extack), KBUILD_MODNAME \": \" msg)\n\n#define NL_SET_BAD_ATTR_POLICY(extack, attr, pol) do {\t\\\n\tif ((extack)) {\t\t\t\t\t\\\n\t\t(extack)->bad_attr = (attr);\t\t\\\n\t\t(extack)->policy = (pol);\t\t\\\n\t}\t\t\t\t\t\t\\\n} while (0)\n\n#define NL_SET_BAD_ATTR(extack, attr) NL_SET_BAD_ATTR_POLICY(extack, attr, NULL)\n\n#define NL_SET_ERR_MSG_ATTR_POL(extack, attr, pol, msg) do {\t\\\n\tstatic const char __msg[] = msg;\t\t\t\\\n\tstruct netlink_ext_ack *__extack = (extack);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tdo_trace_netlink_extack(__msg);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (__extack) {\t\t\t\t\t\t\\\n\t\t__extack->_msg = __msg;\t\t\t\t\\\n\t\t__extack->bad_attr = (attr);\t\t\t\\\n\t\t__extack->policy = (pol);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define NL_SET_ERR_MSG_ATTR(extack, attr, msg)\t\t\\\n\tNL_SET_ERR_MSG_ATTR_POL(extack, attr, NULL, msg)\n\nstatic inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,\n\t\t\t\t\t    u64 cookie)\n{\n\tu64 __cookie = cookie;\n\n\tif (!extack)\n\t\treturn;\n\tmemcpy(extack->cookie, &__cookie, sizeof(__cookie));\n\textack->cookie_len = sizeof(__cookie);\n}\n\nstatic inline void nl_set_extack_cookie_u32(struct netlink_ext_ack *extack,\n\t\t\t\t\t    u32 cookie)\n{\n\tu32 __cookie = cookie;\n\n\tif (!extack)\n\t\treturn;\n\tmemcpy(extack->cookie, &__cookie, sizeof(__cookie));\n\textack->cookie_len = sizeof(__cookie);\n}\n\nvoid netlink_kernel_release(struct sock *sk);\nint __netlink_change_ngroups(struct sock *sk, unsigned int groups);\nint netlink_change_ngroups(struct sock *sk, unsigned int groups);\nvoid __netlink_clear_multicast_users(struct sock *sk, unsigned int group);\nvoid netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,\n\t\t const struct netlink_ext_ack *extack);\nint netlink_has_listeners(struct sock *sk, unsigned int group);\nbool netlink_strict_get_check(struct sk_buff *skb);\n\nint netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);\nint netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,\n\t\t      __u32 group, gfp_t allocation);\nint netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,\n\t\t\t       __u32 portid, __u32 group, gfp_t allocation,\n\t\t\t       int (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),\n\t\t\t       void *filter_data);\nint netlink_set_err(struct sock *ssk, __u32 portid, __u32 group, int code);\nint netlink_register_notifier(struct notifier_block *nb);\nint netlink_unregister_notifier(struct notifier_block *nb);\n\n/* finegrained unicast helpers: */\nstruct sock *netlink_getsockbyfilp(struct file *filp);\nint netlink_attachskb(struct sock *sk, struct sk_buff *skb,\n\t\t      long *timeo, struct sock *ssk);\nvoid netlink_detachskb(struct sock *sk, struct sk_buff *skb);\nint netlink_sendskb(struct sock *sk, struct sk_buff *skb);\n\nstatic inline struct sk_buff *\nnetlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)\n{\n\tstruct sk_buff *nskb;\n\n\tnskb = skb_clone(skb, gfp_mask);\n\tif (!nskb)\n\t\treturn NULL;\n\n\t/* This is a large skb, set destructor callback to release head */\n\tif (is_vmalloc_addr(skb->head))\n\t\tnskb->destructor = skb->destructor;\n\n\treturn nskb;\n}\n\n/*\n *\tskb should fit one page. This choice is good for headerless malloc.\n *\tBut we should limit to 8K so that userspace does not have to\n *\tuse enormous buffer sizes on recvmsg() calls just to avoid\n *\tMSG_TRUNC when PAGE_SIZE is very large.\n */\n#if PAGE_SIZE < 8192UL\n#define NLMSG_GOODSIZE\tSKB_WITH_OVERHEAD(PAGE_SIZE)\n#else\n#define NLMSG_GOODSIZE\tSKB_WITH_OVERHEAD(8192UL)\n#endif\n\n#define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)\n\n\nstruct netlink_callback {\n\tstruct sk_buff\t\t*skb;\n\tconst struct nlmsghdr\t*nlh;\n\tint\t\t\t(*dump)(struct sk_buff * skb,\n\t\t\t\t\tstruct netlink_callback *cb);\n\tint\t\t\t(*done)(struct netlink_callback *cb);\n\tvoid\t\t\t*data;\n\t/* the module that dump function belong to */\n\tstruct module\t\t*module;\n\tstruct netlink_ext_ack\t*extack;\n\tu16\t\t\tfamily;\n\tu16\t\t\tanswer_flags;\n\tu32\t\t\tmin_dump_alloc;\n\tunsigned int\t\tprev_seq, seq;\n\tbool\t\t\tstrict_check;\n\tunion {\n\t\tu8\t\tctx[48];\n\n\t\t/* args is deprecated. Cast a struct over ctx instead\n\t\t * for proper type safety.\n\t\t */\n\t\tlong\t\targs[6];\n\t};\n};\n\nstruct netlink_notify {\n\tstruct net *net;\n\tu32 portid;\n\tint protocol;\n};\n\nstruct nlmsghdr *\n__nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags);\n\nstruct netlink_dump_control {\n\tint (*start)(struct netlink_callback *);\n\tint (*dump)(struct sk_buff *skb, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n\tvoid *data;\n\tstruct module *module;\n\tu32 min_dump_alloc;\n};\n\nint __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,\n\t\t\t\tconst struct nlmsghdr *nlh,\n\t\t\t\tstruct netlink_dump_control *control);\nstatic inline int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,\n\t\t\t\t     const struct nlmsghdr *nlh,\n\t\t\t\t     struct netlink_dump_control *control)\n{\n\tif (!control->module)\n\t\tcontrol->module = THIS_MODULE;\n\n\treturn __netlink_dump_start(ssk, skb, nlh, control);\n}\n\nstruct netlink_tap {\n\tstruct net_device *dev;\n\tstruct module *module;\n\tstruct list_head list;\n};\n\nint netlink_add_tap(struct netlink_tap *nt);\nint netlink_remove_tap(struct netlink_tap *nt);\n\nbool __netlink_ns_capable(const struct netlink_skb_parms *nsp,\n\t\t\t  struct user_namespace *ns, int cap);\nbool netlink_ns_capable(const struct sk_buff *skb,\n\t\t\tstruct user_namespace *ns, int cap);\nbool netlink_capable(const struct sk_buff *skb, int cap);\nbool netlink_net_capable(const struct sk_buff *skb, int cap);\n\n#endif\t/* __LINUX_NETLINK_H */\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 9623}, "message": "'rdev' declared without an initial value"}, {"location": {"col": 12, "file": 0, "line": 9629}, "message": "Calling 'kcalloc'"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Calling 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 594}, "message": "Taking false branch"}, {"location": {"col": 30, "file": 1, "line": 596}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 1, "line": 598}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Returning from 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 627}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 12, "file": 0, "line": 9629}, "message": "Returning from 'kcalloc'"}, {"location": {"col": 6, "file": 0, "line": 9630}, "message": "Assuming 'attrbuf' is non-null"}, {"location": {"col": 2, "file": 0, "line": 9630}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 9633}, "message": "Calling 'nl80211_prepare_wdev_dump'"}, {"location": {"col": 6, "file": 0, "line": 926}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 926}, "message": "Taking true branch"}, {"location": {"col": 13, "file": 0, "line": 929}, "message": "Calling 'kcalloc'"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Calling 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 594}, "message": "Taking false branch"}, {"location": {"col": 30, "file": 1, "line": 596}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 1, "line": 598}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Returning from 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 627}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 13, "file": 0, "line": 929}, "message": "Returning from 'kcalloc'"}, {"location": {"col": 7, "file": 0, "line": 931}, "message": "Assuming 'attrbuf' is non-null, which participates in a condition later"}, {"location": {"col": 3, "file": 0, "line": 931}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 934}, "message": "Calling 'nlmsg_parse_deprecated'"}, {"location": {"col": 9, "file": 2, "line": 772}, "message": "Calling '__nlmsg_parse'"}, {"location": {"col": 6, "file": 2, "line": 728}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 2, "line": 728}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 733}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 9, "file": 2, "line": 772}, "message": "Returning from '__nlmsg_parse'"}, {"location": {"col": 2, "file": 2, "line": 772}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 9, "file": 0, "line": 934}, "message": "Returning from 'nlmsg_parse_deprecated'"}, {"location": {"col": 7, "file": 0, "line": 938}, "message": "Assuming 'err' is 0"}, {"location": {"col": 3, "file": 0, "line": 938}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 947}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 3, "line": 36}, "message": "Assuming the condition is true"}, {"location": {"col": 34, "file": 3, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 4, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 3, "line": 36}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 947}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 3, "file": 0, "line": 947}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 949}, "message": "Returning without writing to '(*wdev)->netdev', which participates in a condition later"}, {"location": {"col": 4, "file": 0, "line": 949}, "message": "Returning without writing to '*rdev'"}, {"location": {"col": 4, "file": 0, "line": 949}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 9633}, "message": "Returning from 'nl80211_prepare_wdev_dump'"}, {"location": {"col": 6, "file": 0, "line": 9634}, "message": "Assuming 'res' is 0"}, {"location": {"col": 2, "file": 0, "line": 9634}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 9644}, "message": "Assuming field 'netdev' is non-null"}, {"location": {"col": 2, "file": 0, "line": 9644}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 9649}, "message": "Access to field 'ops' results in a dereference of an undefined pointer value (loaded from variable 'rdev')"}, {"location": {"col": 7, "file": 0, "line": 9649}, "message": "Access to field 'ops' results in a dereference of an undefined pointer value (loaded from variable 'rdev')"}], "macros": [], "notes": [], "path": "/src/net/wireless/nl80211.c", "reportHash": "443605a1a8adcf5a994079cbe548fa30", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 9623}, "message": "'rdev' declared without an initial value"}, {"location": {"col": 12, "file": 0, "line": 9629}, "message": "Calling 'kcalloc'"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Calling 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 594}, "message": "Taking false branch"}, {"location": {"col": 30, "file": 1, "line": 596}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 1, "line": 598}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Returning from 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 627}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 12, "file": 0, "line": 9629}, "message": "Returning from 'kcalloc'"}, {"location": {"col": 6, "file": 0, "line": 9630}, "message": "Assuming 'attrbuf' is non-null"}, {"location": {"col": 2, "file": 0, "line": 9630}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 9633}, "message": "Calling 'nl80211_prepare_wdev_dump'"}, {"location": {"col": 6, "file": 0, "line": 926}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 0, "line": 926}, "message": "Taking true branch"}, {"location": {"col": 13, "file": 0, "line": 929}, "message": "Calling 'kcalloc'"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Calling 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 594}, "message": "Taking false branch"}, {"location": {"col": 30, "file": 1, "line": 596}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 1, "line": 598}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 627}, "message": "Returning from 'kmalloc_array'"}, {"location": {"col": 2, "file": 1, "line": 627}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 13, "file": 0, "line": 929}, "message": "Returning from 'kcalloc'"}, {"location": {"col": 7, "file": 0, "line": 931}, "message": "Assuming 'attrbuf' is non-null, which participates in a condition later"}, {"location": {"col": 3, "file": 0, "line": 931}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 934}, "message": "Calling 'nlmsg_parse_deprecated'"}, {"location": {"col": 9, "file": 2, "line": 772}, "message": "Calling '__nlmsg_parse'"}, {"location": {"col": 6, "file": 2, "line": 728}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 2, "line": 728}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 733}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 9, "file": 2, "line": 772}, "message": "Returning from '__nlmsg_parse'"}, {"location": {"col": 2, "file": 2, "line": 772}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 9, "file": 0, "line": 934}, "message": "Returning from 'nlmsg_parse_deprecated'"}, {"location": {"col": 7, "file": 0, "line": 938}, "message": "Assuming 'err' is 0"}, {"location": {"col": 3, "file": 0, "line": 938}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 947}, "message": "Calling 'IS_ERR'"}, {"location": {"col": 9, "file": 3, "line": 36}, "message": "Assuming the condition is true"}, {"location": {"col": 34, "file": 3, "line": 22}, "message": "expanded from macro 'IS_ERR_VALUE'"}, {"location": {"col": 42, "file": 4, "line": 78}, "message": "expanded from macro 'unlikely'"}, {"location": {"col": 2, "file": 3, "line": 36}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 947}, "message": "Returning from 'IS_ERR'"}, {"location": {"col": 3, "file": 0, "line": 947}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 949}, "message": "Returning without writing to '*rdev'"}, {"location": {"col": 4, "file": 0, "line": 949}, "message": "Returning value, which participates in a condition later"}, {"location": {"col": 8, "file": 0, "line": 9633}, "message": "Returning from 'nl80211_prepare_wdev_dump'"}, {"location": {"col": 6, "file": 0, "line": 9634}, "message": "Assuming 'res' is 0"}, {"location": {"col": 2, "file": 0, "line": 9634}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 9644}, "message": "Assuming field 'netdev' is null"}, {"location": {"col": 2, "file": 0, "line": 9644}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 9646}, "message": "Control jumps to line 9680"}, {"location": {"col": 2, "file": 0, "line": 9681}, "message": "1st function call argument is an uninitialized value"}, {"location": {"col": 2, "file": 0, "line": 9681}, "message": "1st function call argument is an uninitialized value"}], "macros": [], "notes": [], "path": "/src/net/wireless/nl80211.c", "reportHash": "7a47180c856cd6beb212f8abb6dde914", "checkerName": "clang-analyzer-core.CallAndMessage", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 14942}, "message": "Assuming field 'sar_capa' is non-null"}, {"location": {"col": 6, "file": 0, "line": 14942}, "message": "Left side of '||' is false"}, {"location": {"col": 31, "file": 0, "line": 14942}, "message": "Assuming field 'set_sar_specs' is non-null"}, {"location": {"col": 2, "file": 0, "line": 14942}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 14945}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 14945}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 14948}, "message": "Calling 'nla_parse_nested'"}, {"location": {"col": 6, "file": 2, "line": 1207}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 2, "line": 1207}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 2, "line": 1212}, "message": "Assigning value, which participates in a condition later"}, {"location": {"col": 2, "file": 0, "line": 14948}, "message": "Returning from 'nla_parse_nested'"}, {"location": {"col": 6, "file": 0, "line": 14952}, "message": "Assuming the condition is false"}, {"location": {"col": 6, "file": 0, "line": 14952}, "message": "Left side of '||' is false"}, {"location": {"col": 36, "file": 0, "line": 14952}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 14952}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 14956}, "message": "Assuming 'type' is equal to field 'type'"}, {"location": {"col": 2, "file": 0, "line": 14956}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 14960}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 2, "file": 2, "line": 1932}, "message": "expanded from macro 'nla_for_each_nested'"}, {"location": {"col": 2, "file": 2, "line": 1921}, "message": "expanded from macro 'nla_for_each_attr'"}, {"location": {"col": 2, "file": 0, "line": 14960}, "message": "Loop condition is false. Execution continues on line 14963"}, {"location": {"col": 2, "file": 2, "line": 1932}, "message": "expanded from macro 'nla_for_each_nested'"}, {"location": {"col": 2, "file": 2, "line": 1921}, "message": "expanded from macro 'nla_for_each_attr'"}, {"location": {"col": 6, "file": 0, "line": 14963}, "message": "Assuming 'specs' is <= field 'num_freq_ranges'"}, {"location": {"col": 2, "file": 0, "line": 14963}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 0, "line": 14966}, "message": "Calling 'kzalloc'"}, {"location": {"col": 9, "file": 1, "line": 688}, "message": "Calling 'kmalloc'"}, {"location": {"col": 2, "file": 1, "line": 546}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 1, "line": 563}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 688}, "message": "Returning from 'kmalloc'"}, {"location": {"col": 2, "file": 1, "line": 688}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 13, "file": 0, "line": 14966}, "message": "Returning from 'kzalloc'"}, {"location": {"col": 6, "file": 0, "line": 14969}, "message": "Assuming 'sar_spec' is non-null"}, {"location": {"col": 2, "file": 0, "line": 14969}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 14974}, "message": "Calling 'nla_ok'"}, {"location": {"col": 2, "file": 2, "line": 1932}, "message": "expanded from macro 'nla_for_each_nested'"}, {"location": {"col": 7, "file": 2, "line": 1922}, "message": "expanded from macro 'nla_for_each_attr'"}, {"location": {"col": 9, "file": 2, "line": 1158}, "message": "Left side of '&&' is true"}, {"location": {"col": 9, "file": 2, "line": 1158}, "message": "Left side of '&&' is true"}, {"location": {"col": 25, "file": 2, "line": 1160}, "message": "'remaining' is >= field 'nla_len'"}, {"location": {"col": 2, "file": 2, "line": 1158}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 2, "file": 0, "line": 14974}, "message": "Returning from 'nla_ok'"}, {"location": {"col": 2, "file": 2, "line": 1932}, "message": "expanded from macro 'nla_for_each_nested'"}, {"location": {"col": 7, "file": 2, "line": 1922}, "message": "expanded from macro 'nla_for_each_attr'"}, {"location": {"col": 2, "file": 0, "line": 14974}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 2, "file": 2, "line": 1932}, "message": "expanded from macro 'nla_for_each_nested'"}, {"location": {"col": 2, "file": 2, "line": 1921}, "message": "expanded from macro 'nla_for_each_attr'"}, {"location": {"col": 3, "file": 0, "line": 14975}, "message": "Calling 'nla_parse_nested'"}, {"location": {"col": 6, "file": 2, "line": 1207}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 2, "line": 1207}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 2, "line": 1208}, "message": "'__extack' is null"}, {"location": {"col": 2, "file": 5, "line": 127}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR'"}, {"location": {"col": 6, "file": 5, "line": 119}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR_POL'"}, {"location": {"col": 3, "file": 2, "line": 1208}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 5, "line": 127}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR'"}, {"location": {"col": 2, "file": 5, "line": 119}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR_POL'"}, {"location": {"col": 3, "file": 2, "line": 1208}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 5, "line": 127}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR'"}, {"location": {"col": 57, "file": 5, "line": 113}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR_POL'"}, {"location": {"col": 3, "file": 0, "line": 14975}, "message": "Returning from 'nla_parse_nested'"}, {"location": {"col": 3, "file": 0, "line": 14978}, "message": "Control jumps to 'case NL80211_SAR_TYPE_POWER:'  at line 14979"}, {"location": {"col": 8, "file": 0, "line": 14980}, "message": "Calling 'nl80211_set_sar_sub_specs'"}, {"location": {"col": 7, "file": 0, "line": 14904}, "message": "'sar_specs' is non-null"}, {"location": {"col": 6, "file": 0, "line": 14904}, "message": "Left side of '||' is false"}, {"location": {"col": 21, "file": 0, "line": 14904}, "message": "'spec' is non-null"}, {"location": {"col": 2, "file": 0, "line": 14904}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 14907}, "message": "Branch condition evaluates to a garbage value"}, {"location": {"col": 6, "file": 0, "line": 14907}, "message": "Branch condition evaluates to a garbage value"}], "macros": [], "notes": [], "path": "/src/net/wireless/nl80211.c", "reportHash": "5ddb971704b0344c938031a5d87bc0de", "checkerName": "clang-analyzer-core.uninitialized.Branch", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 14942}, "message": "Assuming field 'sar_capa' is non-null"}, {"location": {"col": 6, "file": 0, "line": 14942}, "message": "Left side of '||' is false"}, {"location": {"col": 31, "file": 0, "line": 14942}, "message": "Assuming field 'set_sar_specs' is non-null"}, {"location": {"col": 2, "file": 0, "line": 14942}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 14945}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 14945}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 14948}, "message": "Calling 'nla_parse_nested'"}, {"location": {"col": 6, "file": 2, "line": 1207}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 2, "line": 1207}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 2, "line": 1208}, "message": "'__extack' is null"}, {"location": {"col": 2, "file": 5, "line": 127}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR'"}, {"location": {"col": 6, "file": 5, "line": 119}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR_POL'"}, {"location": {"col": 3, "file": 2, "line": 1208}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 5, "line": 127}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR'"}, {"location": {"col": 2, "file": 5, "line": 119}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR_POL'"}, {"location": {"col": 3, "file": 2, "line": 1208}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 5, "line": 127}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR'"}, {"location": {"col": 57, "file": 5, "line": 113}, "message": "expanded from macro 'NL_SET_ERR_MSG_ATTR_POL'"}, {"location": {"col": 2, "file": 0, "line": 14948}, "message": "Returning from 'nla_parse_nested'"}, {"location": {"col": 6, "file": 0, "line": 14952}, "message": "Branch condition evaluates to a garbage value"}, {"location": {"col": 6, "file": 0, "line": 14952}, "message": "Branch condition evaluates to a garbage value"}], "macros": [], "notes": [], "path": "/src/net/wireless/nl80211.c", "reportHash": "46d65044c00e7daec7224f2ad545b017", "checkerName": "clang-analyzer-core.uninitialized.Branch", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
