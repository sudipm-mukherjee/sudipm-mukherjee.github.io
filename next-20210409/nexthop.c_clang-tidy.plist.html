<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/include/linux/math.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_MATH_H\n#define _LINUX_MATH_H\n\n#include <asm/div64.h>\n#include <uapi/linux/kernel.h>\n\n/*\n * This looks more complex than it should be. But we need to\n * get the type for the ~ right in round_down (it needs to be\n * as wide as the result!), and we want to evaluate the macro\n * arguments just once each.\n */\n#define __round_mask(x, y) ((__typeof__(x))((y)-1))\n\n/**\n * round_up - round up to next specified power of 2\n * @x: the value to round\n * @y: multiple to round up to (must be a power of 2)\n *\n * Rounds @x up to next multiple of @y (which must be a power of 2).\n * To perform arbitrary rounding up, use roundup() below.\n */\n#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)\n\n/**\n * round_down - round down to next specified power of 2\n * @x: the value to round\n * @y: multiple to round down to (must be a power of 2)\n *\n * Rounds @x down to next multiple of @y (which must be a power of 2).\n * To perform arbitrary rounding down, use rounddown() below.\n */\n#define round_down(x, y) ((x) & ~__round_mask(x, y))\n\n#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP\n\n#define DIV_ROUND_DOWN_ULL(ll, d) \\\n\t({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })\n\n#define DIV_ROUND_UP_ULL(ll, d) \\\n\tDIV_ROUND_DOWN_ULL((unsigned long long)(ll) + (d) - 1, (d))\n\n#if BITS_PER_LONG == 32\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)\n#else\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)\n#endif\n\n/**\n * roundup - round up to the next specified multiple\n * @x: the value to up\n * @y: multiple to round up to\n *\n * Rounds @x up to next multiple of @y. If @y will always be a power\n * of 2, consider using the faster round_up().\n */\n#define roundup(x, y) (\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(y) __y = y;\t\t\t\t\\\n\t(((x) + (__y - 1)) / __y) * __y;\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n/**\n * rounddown - round down to next specified multiple\n * @x: the value to round\n * @y: multiple to round down to\n *\n * Rounds @x down to next multiple of @y. If @y will always be a power\n * of 2, consider using the faster round_down().\n */\n#define rounddown(x, y) (\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\t\\\n\t__x - (__x % (y));\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n/*\n * Divide positive or negative dividend by positive or negative divisor\n * and round to closest integer. Result is undefined for negative\n * divisors if the dividend variable type is unsigned and for negative\n * dividends if the divisor variable type is unsigned.\n */\n#define DIV_ROUND_CLOSEST(x, divisor)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = x;\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\t(((typeof(x))-1) > 0 ||\t\t\t\t\\\n\t ((typeof(divisor))-1) > 0 ||\t\t\t\\\n\t (((__x) > 0) == ((__d) > 0))) ?\t\t\\\n\t\t(((__x) + ((__d) / 2)) / (__d)) :\t\\\n\t\t(((__x) - ((__d) / 2)) / (__d));\t\\\n}\t\t\t\t\t\t\t\\\n)\n/*\n * Same as above but for u64 dividends. divisor must be a 32-bit\n * number.\n */\n#define DIV_ROUND_CLOSEST_ULL(x, divisor)(\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\tunsigned long long _tmp = (x) + (__d) / 2;\t\\\n\tdo_div(_tmp, __d);\t\t\t\t\\\n\t_tmp;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n/*\n * Multiplies an integer by a fraction, while avoiding unnecessary\n * overflow or loss of precision.\n */\n#define mult_frac(x, numer, denom)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) quot = (x) / (denom);\t\t\t\\\n\ttypeof(x) rem  = (x) % (denom);\t\t\t\\\n\t(quot * (numer)) + ((rem * (numer)) / (denom));\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n#define sector_div(a, b) do_div(a, b)\n\n/**\n * abs - return absolute value of an argument\n * @x: the value.  If it is unsigned type, it is converted to signed type first.\n *     char is treated as if it was signed (regardless of whether it really is)\n *     but the macro's return type is preserved as char.\n *\n * Return: an absolute value of x.\n */\n#define abs(x)\t__abs_choose_expr(x, long long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, int,\t\t\t\t\\\n\t\t__abs_choose_expr(x, short,\t\t\t\t\\\n\t\t__abs_choose_expr(x, char,\t\t\t\t\\\n\t\t__builtin_choose_expr(\t\t\t\t\t\\\n\t\t\t__builtin_types_compatible_p(typeof(x), char),\t\\\n\t\t\t(char)({ signed char __x = (x); __x<0?-__x:__x; }), \\\n\t\t\t((void)0)))))))\n\n#define __abs_choose_expr(x, type, other) __builtin_choose_expr(\t\\\n\t__builtin_types_compatible_p(typeof(x),   signed type) ||\t\\\n\t__builtin_types_compatible_p(typeof(x), unsigned type),\t\t\\\n\t({ signed type __x = (x); __x < 0 ? -__x : __x; }), other)\n\n/**\n * reciprocal_scale - \"scale\" a value into range [0, ep_ro)\n * @val: value\n * @ep_ro: right open interval endpoint\n *\n * Perform a \"reciprocal multiplication\" in order to \"scale\" a value into\n * range [0, @ep_ro), where the upper interval endpoint is right-open.\n * This is useful, e.g. for accessing a index of an array containing\n * @ep_ro elements, for example. Think of it as sort of modulus, only that\n * the result isn't that of modulo. ;) Note that if initial input is a\n * small value, then result will return 0.\n *\n * Return: a result based on @val in interval [0, @ep_ro).\n */\nstatic inline u32 reciprocal_scale(u32 val, u32 ep_ro)\n{\n\treturn (u32)(((u64) val * ep_ro) >> 32);\n}\n\nu64 int_pow(u64 base, unsigned int exp);\nunsigned long int_sqrt(unsigned long);\n\n#if BITS_PER_LONG < 64\nu32 int_sqrt64(u64 x);\n#else\nstatic inline u32 int_sqrt64(u64 x)\n{\n\treturn (u32)int_sqrt(x);\n}\n#endif\n\n#endif\t/* _LINUX_MATH_H */\n"}, "0": {"id": 0, "path": "/src/net/ipv4/nexthop.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/* Generic nexthop implementation\n *\n * Copyright (c) 2017-19 Cumulus Networks\n * Copyright (c) 2017-19 David Ahern <dsa@cumulusnetworks.com>\n */\n\n#include <linux/nexthop.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <net/arp.h>\n#include <net/ipv6_stubs.h>\n#include <net/lwtunnel.h>\n#include <net/ndisc.h>\n#include <net/nexthop.h>\n#include <net/route.h>\n#include <net/sock.h>\n\n#define NH_RES_DEFAULT_IDLE_TIMER\t(120 * HZ)\n#define NH_RES_DEFAULT_UNBALANCED_TIMER\t0\t/* No forced rebalancing. */\n\nstatic void remove_nexthop(struct net *net, struct nexthop *nh,\n\t\t\t   struct nl_info *nlinfo);\n\n#define NH_DEV_HASHBITS  8\n#define NH_DEV_HASHSIZE (1U << NH_DEV_HASHBITS)\n\nstatic const struct nla_policy rtm_nh_policy_new[] = {\n\t[NHA_ID]\t\t= { .type = NLA_U32 },\n\t[NHA_GROUP]\t\t= { .type = NLA_BINARY },\n\t[NHA_GROUP_TYPE]\t= { .type = NLA_U16 },\n\t[NHA_BLACKHOLE]\t\t= { .type = NLA_FLAG },\n\t[NHA_OIF]\t\t= { .type = NLA_U32 },\n\t[NHA_GATEWAY]\t\t= { .type = NLA_BINARY },\n\t[NHA_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[NHA_ENCAP]\t\t= { .type = NLA_NESTED },\n\t[NHA_FDB]\t\t= { .type = NLA_FLAG },\n\t[NHA_RES_GROUP]\t\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy rtm_nh_policy_get[] = {\n\t[NHA_ID]\t\t= { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy rtm_nh_policy_dump[] = {\n\t[NHA_OIF]\t\t= { .type = NLA_U32 },\n\t[NHA_GROUPS]\t\t= { .type = NLA_FLAG },\n\t[NHA_MASTER]\t\t= { .type = NLA_U32 },\n\t[NHA_FDB]\t\t= { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy rtm_nh_res_policy_new[] = {\n\t[NHA_RES_GROUP_BUCKETS]\t\t\t= { .type = NLA_U16 },\n\t[NHA_RES_GROUP_IDLE_TIMER]\t\t= { .type = NLA_U32 },\n\t[NHA_RES_GROUP_UNBALANCED_TIMER]\t= { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy rtm_nh_policy_dump_bucket[] = {\n\t[NHA_ID]\t\t= { .type = NLA_U32 },\n\t[NHA_OIF]\t\t= { .type = NLA_U32 },\n\t[NHA_MASTER]\t\t= { .type = NLA_U32 },\n\t[NHA_RES_BUCKET]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy rtm_nh_res_bucket_policy_dump[] = {\n\t[NHA_RES_BUCKET_NH_ID]\t= { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy rtm_nh_policy_get_bucket[] = {\n\t[NHA_ID]\t\t= { .type = NLA_U32 },\n\t[NHA_RES_BUCKET]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy rtm_nh_res_bucket_policy_get[] = {\n\t[NHA_RES_BUCKET_INDEX]\t= { .type = NLA_U16 },\n};\n\nstatic bool nexthop_notifiers_is_empty(struct net *net)\n{\n\treturn !net->nexthop.notifier_chain.head;\n}\n\nstatic void\n__nh_notifier_single_info_init(struct nh_notifier_single_info *nh_info,\n\t\t\t       const struct nh_info *nhi)\n{\n\tnh_info->dev = nhi->fib_nhc.nhc_dev;\n\tnh_info->gw_family = nhi->fib_nhc.nhc_gw_family;\n\tif (nh_info->gw_family == AF_INET)\n\t\tnh_info->ipv4 = nhi->fib_nhc.nhc_gw.ipv4;\n\telse if (nh_info->gw_family == AF_INET6)\n\t\tnh_info->ipv6 = nhi->fib_nhc.nhc_gw.ipv6;\n\n\tnh_info->is_reject = nhi->reject_nh;\n\tnh_info->is_fdb = nhi->fdb_nh;\n\tnh_info->has_encap = !!nhi->fib_nhc.nhc_lwtstate;\n}\n\nstatic int nh_notifier_single_info_init(struct nh_notifier_info *info,\n\t\t\t\t\tconst struct nexthop *nh)\n{\n\tstruct nh_info *nhi = rtnl_dereference(nh->nh_info);\n\n\tinfo->type = NH_NOTIFIER_INFO_TYPE_SINGLE;\n\tinfo->nh = kzalloc(sizeof(*info->nh), GFP_KERNEL);\n\tif (!info->nh)\n\t\treturn -ENOMEM;\n\n\t__nh_notifier_single_info_init(info->nh, nhi);\n\n\treturn 0;\n}\n\nstatic void nh_notifier_single_info_fini(struct nh_notifier_info *info)\n{\n\tkfree(info->nh);\n}\n\nstatic int nh_notifier_mpath_info_init(struct nh_notifier_info *info,\n\t\t\t\t       struct nh_group *nhg)\n{\n\tu16 num_nh = nhg->num_nh;\n\tint i;\n\n\tinfo->type = NH_NOTIFIER_INFO_TYPE_GRP;\n\tinfo->nh_grp = kzalloc(struct_size(info->nh_grp, nh_entries, num_nh),\n\t\t\t       GFP_KERNEL);\n\tif (!info->nh_grp)\n\t\treturn -ENOMEM;\n\n\tinfo->nh_grp->num_nh = num_nh;\n\tinfo->nh_grp->is_fdb = nhg->fdb_nh;\n\n\tfor (i = 0; i < num_nh; i++) {\n\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\t\tstruct nh_info *nhi;\n\n\t\tnhi = rtnl_dereference(nhge->nh->nh_info);\n\t\tinfo->nh_grp->nh_entries[i].id = nhge->nh->id;\n\t\tinfo->nh_grp->nh_entries[i].weight = nhge->weight;\n\t\t__nh_notifier_single_info_init(&info->nh_grp->nh_entries[i].nh,\n\t\t\t\t\t       nhi);\n\t}\n\n\treturn 0;\n}\n\nstatic int nh_notifier_res_table_info_init(struct nh_notifier_info *info,\n\t\t\t\t\t   struct nh_group *nhg)\n{\n\tstruct nh_res_table *res_table = rtnl_dereference(nhg->res_table);\n\tu16 num_nh_buckets = res_table->num_nh_buckets;\n\tunsigned long size;\n\tu16 i;\n\n\tinfo->type = NH_NOTIFIER_INFO_TYPE_RES_TABLE;\n\tsize = struct_size(info->nh_res_table, nhs, num_nh_buckets);\n\tinfo->nh_res_table = __vmalloc(size, GFP_KERNEL | __GFP_ZERO |\n\t\t\t\t       __GFP_NOWARN);\n\tif (!info->nh_res_table)\n\t\treturn -ENOMEM;\n\n\tinfo->nh_res_table->num_nh_buckets = num_nh_buckets;\n\n\tfor (i = 0; i < num_nh_buckets; i++) {\n\t\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[i];\n\t\tstruct nh_grp_entry *nhge;\n\t\tstruct nh_info *nhi;\n\n\t\tnhge = rtnl_dereference(bucket->nh_entry);\n\t\tnhi = rtnl_dereference(nhge->nh->nh_info);\n\t\t__nh_notifier_single_info_init(&info->nh_res_table->nhs[i],\n\t\t\t\t\t       nhi);\n\t}\n\n\treturn 0;\n}\n\nstatic int nh_notifier_grp_info_init(struct nh_notifier_info *info,\n\t\t\t\t     const struct nexthop *nh)\n{\n\tstruct nh_group *nhg = rtnl_dereference(nh->nh_grp);\n\n\tif (nhg->hash_threshold)\n\t\treturn nh_notifier_mpath_info_init(info, nhg);\n\telse if (nhg->resilient)\n\t\treturn nh_notifier_res_table_info_init(info, nhg);\n\treturn -EINVAL;\n}\n\nstatic void nh_notifier_grp_info_fini(struct nh_notifier_info *info,\n\t\t\t\t      const struct nexthop *nh)\n{\n\tstruct nh_group *nhg = rtnl_dereference(nh->nh_grp);\n\n\tif (nhg->hash_threshold)\n\t\tkfree(info->nh_grp);\n\telse if (nhg->resilient)\n\t\tvfree(info->nh_res_table);\n}\n\nstatic int nh_notifier_info_init(struct nh_notifier_info *info,\n\t\t\t\t const struct nexthop *nh)\n{\n\tinfo->id = nh->id;\n\n\tif (nh->is_group)\n\t\treturn nh_notifier_grp_info_init(info, nh);\n\telse\n\t\treturn nh_notifier_single_info_init(info, nh);\n}\n\nstatic void nh_notifier_info_fini(struct nh_notifier_info *info,\n\t\t\t\t  const struct nexthop *nh)\n{\n\tif (nh->is_group)\n\t\tnh_notifier_grp_info_fini(info, nh);\n\telse\n\t\tnh_notifier_single_info_fini(info);\n}\n\nstatic int call_nexthop_notifiers(struct net *net,\n\t\t\t\t  enum nexthop_event_type event_type,\n\t\t\t\t  struct nexthop *nh,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nh_notifier_info info = {\n\t\t.net = net,\n\t\t.extack = extack,\n\t};\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (nexthop_notifiers_is_empty(net))\n\t\treturn 0;\n\n\terr = nh_notifier_info_init(&info, nh);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to initialize nexthop notifier info\");\n\t\treturn err;\n\t}\n\n\terr = blocking_notifier_call_chain(&net->nexthop.notifier_chain,\n\t\t\t\t\t   event_type, &info);\n\tnh_notifier_info_fini(&info, nh);\n\n\treturn notifier_to_errno(err);\n}\n\nstatic int\nnh_notifier_res_bucket_idle_timer_get(const struct nh_notifier_info *info,\n\t\t\t\t      bool force, unsigned int *p_idle_timer_ms)\n{\n\tstruct nh_res_table *res_table;\n\tstruct nh_group *nhg;\n\tstruct nexthop *nh;\n\tint err = 0;\n\n\t/* When 'force' is false, nexthop bucket replacement is performed\n\t * because the bucket was deemed to be idle. In this case, capable\n\t * listeners can choose to perform an atomic replacement: The bucket is\n\t * only replaced if it is inactive. However, if the idle timer interval\n\t * is smaller than the interval in which a listener is querying\n\t * buckets' activity from the device, then atomic replacement should\n\t * not be tried. Pass the idle timer value to listeners, so that they\n\t * could determine which type of replacement to perform.\n\t */\n\tif (force) {\n\t\t*p_idle_timer_ms = 0;\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\n\tnh = nexthop_find_by_id(info->net, info->id);\n\tif (!nh) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnhg = rcu_dereference(nh->nh_grp);\n\tres_table = rcu_dereference(nhg->res_table);\n\t*p_idle_timer_ms = jiffies_to_msecs(res_table->idle_timer);\n\nout:\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic int nh_notifier_res_bucket_info_init(struct nh_notifier_info *info,\n\t\t\t\t\t    u16 bucket_index, bool force,\n\t\t\t\t\t    struct nh_info *oldi,\n\t\t\t\t\t    struct nh_info *newi)\n{\n\tunsigned int idle_timer_ms;\n\tint err;\n\n\terr = nh_notifier_res_bucket_idle_timer_get(info, force,\n\t\t\t\t\t\t    &idle_timer_ms);\n\tif (err)\n\t\treturn err;\n\n\tinfo->type = NH_NOTIFIER_INFO_TYPE_RES_BUCKET;\n\tinfo->nh_res_bucket = kzalloc(sizeof(*info->nh_res_bucket),\n\t\t\t\t      GFP_KERNEL);\n\tif (!info->nh_res_bucket)\n\t\treturn -ENOMEM;\n\n\tinfo->nh_res_bucket->bucket_index = bucket_index;\n\tinfo->nh_res_bucket->idle_timer_ms = idle_timer_ms;\n\tinfo->nh_res_bucket->force = force;\n\t__nh_notifier_single_info_init(&info->nh_res_bucket->old_nh, oldi);\n\t__nh_notifier_single_info_init(&info->nh_res_bucket->new_nh, newi);\n\treturn 0;\n}\n\nstatic void nh_notifier_res_bucket_info_fini(struct nh_notifier_info *info)\n{\n\tkfree(info->nh_res_bucket);\n}\n\nstatic int __call_nexthop_res_bucket_notifiers(struct net *net, u32 nhg_id,\n\t\t\t\t\t       u16 bucket_index, bool force,\n\t\t\t\t\t       struct nh_info *oldi,\n\t\t\t\t\t       struct nh_info *newi,\n\t\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nh_notifier_info info = {\n\t\t.net = net,\n\t\t.extack = extack,\n\t\t.id = nhg_id,\n\t};\n\tint err;\n\n\tif (nexthop_notifiers_is_empty(net))\n\t\treturn 0;\n\n\terr = nh_notifier_res_bucket_info_init(&info, bucket_index, force,\n\t\t\t\t\t       oldi, newi);\n\tif (err)\n\t\treturn err;\n\n\terr = blocking_notifier_call_chain(&net->nexthop.notifier_chain,\n\t\t\t\t\t   NEXTHOP_EVENT_BUCKET_REPLACE, &info);\n\tnh_notifier_res_bucket_info_fini(&info);\n\n\treturn notifier_to_errno(err);\n}\n\n/* There are three users of RES_TABLE, and NHs etc. referenced from there:\n *\n * 1) a collection of callbacks for NH maintenance. This operates under\n *    RTNL,\n * 2) the delayed work that gradually balances the resilient table,\n * 3) and nexthop_select_path(), operating under RCU.\n *\n * Both the delayed work and the RTNL block are writers, and need to\n * maintain mutual exclusion. Since there are only two and well-known\n * writers for each table, the RTNL code can make sure it has exclusive\n * access thus:\n *\n * - Have the DW operate without locking;\n * - synchronously cancel the DW;\n * - do the writing;\n * - if the write was not actually a delete, call upkeep, which schedules\n *   DW again if necessary.\n *\n * The functions that are always called from the RTNL context use\n * rtnl_dereference(). The functions that can also be called from the DW do\n * a raw dereference and rely on the above mutual exclusion scheme.\n */\n#define nh_res_dereference(p) (rcu_dereference_raw(p))\n\nstatic int call_nexthop_res_bucket_notifiers(struct net *net, u32 nhg_id,\n\t\t\t\t\t     u16 bucket_index, bool force,\n\t\t\t\t\t     struct nexthop *old_nh,\n\t\t\t\t\t     struct nexthop *new_nh,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nh_info *oldi = nh_res_dereference(old_nh->nh_info);\n\tstruct nh_info *newi = nh_res_dereference(new_nh->nh_info);\n\n\treturn __call_nexthop_res_bucket_notifiers(net, nhg_id, bucket_index,\n\t\t\t\t\t\t   force, oldi, newi, extack);\n}\n\nstatic int call_nexthop_res_table_notifiers(struct net *net, struct nexthop *nh,\n\t\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nh_notifier_info info = {\n\t\t.net = net,\n\t\t.extack = extack,\n\t};\n\tstruct nh_group *nhg;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (nexthop_notifiers_is_empty(net))\n\t\treturn 0;\n\n\t/* At this point, the nexthop buckets are still not populated. Only\n\t * emit a notification with the logical nexthops, so that a listener\n\t * could potentially veto it in case of unsupported configuration.\n\t */\n\tnhg = rtnl_dereference(nh->nh_grp);\n\terr = nh_notifier_mpath_info_init(&info, nhg);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"Failed to initialize nexthop notifier info\");\n\t\treturn err;\n\t}\n\n\terr = blocking_notifier_call_chain(&net->nexthop.notifier_chain,\n\t\t\t\t\t   NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE,\n\t\t\t\t\t   &info);\n\tkfree(info.nh_grp);\n\n\treturn notifier_to_errno(err);\n}\n\nstatic int call_nexthop_notifier(struct notifier_block *nb, struct net *net,\n\t\t\t\t enum nexthop_event_type event_type,\n\t\t\t\t struct nexthop *nh,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nh_notifier_info info = {\n\t\t.net = net,\n\t\t.extack = extack,\n\t};\n\tint err;\n\n\terr = nh_notifier_info_init(&info, nh);\n\tif (err)\n\t\treturn err;\n\n\terr = nb->notifier_call(nb, event_type, &info);\n\tnh_notifier_info_fini(&info, nh);\n\n\treturn notifier_to_errno(err);\n}\n\nstatic unsigned int nh_dev_hashfn(unsigned int val)\n{\n\tunsigned int mask = NH_DEV_HASHSIZE - 1;\n\n\treturn (val ^\n\t\t(val >> NH_DEV_HASHBITS) ^\n\t\t(val >> (NH_DEV_HASHBITS * 2))) & mask;\n}\n\nstatic void nexthop_devhash_add(struct net *net, struct nh_info *nhi)\n{\n\tstruct net_device *dev = nhi->fib_nhc.nhc_dev;\n\tstruct hlist_head *head;\n\tunsigned int hash;\n\n\tWARN_ON(!dev);\n\n\thash = nh_dev_hashfn(dev->ifindex);\n\thead = &net->nexthop.devhash[hash];\n\thlist_add_head(&nhi->dev_hash, head);\n}\n\nstatic void nexthop_free_group(struct nexthop *nh)\n{\n\tstruct nh_group *nhg;\n\tint i;\n\n\tnhg = rcu_dereference_raw(nh->nh_grp);\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\n\t\tWARN_ON(!list_empty(&nhge->nh_list));\n\t\tnexthop_put(nhge->nh);\n\t}\n\n\tWARN_ON(nhg->spare == nhg);\n\n\tif (nhg->resilient)\n\t\tvfree(rcu_dereference_raw(nhg->res_table));\n\n\tkfree(nhg->spare);\n\tkfree(nhg);\n}\n\nstatic void nexthop_free_single(struct nexthop *nh)\n{\n\tstruct nh_info *nhi;\n\n\tnhi = rcu_dereference_raw(nh->nh_info);\n\tswitch (nhi->family) {\n\tcase AF_INET:\n\t\tfib_nh_release(nh->net, &nhi->fib_nh);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tipv6_stub->fib6_nh_release(&nhi->fib6_nh);\n\t\tbreak;\n\t}\n\tkfree(nhi);\n}\n\nvoid nexthop_free_rcu(struct rcu_head *head)\n{\n\tstruct nexthop *nh = container_of(head, struct nexthop, rcu);\n\n\tif (nh->is_group)\n\t\tnexthop_free_group(nh);\n\telse\n\t\tnexthop_free_single(nh);\n\n\tkfree(nh);\n}\nEXPORT_SYMBOL_GPL(nexthop_free_rcu);\n\nstatic struct nexthop *nexthop_alloc(void)\n{\n\tstruct nexthop *nh;\n\n\tnh = kzalloc(sizeof(struct nexthop), GFP_KERNEL);\n\tif (nh) {\n\t\tINIT_LIST_HEAD(&nh->fi_list);\n\t\tINIT_LIST_HEAD(&nh->f6i_list);\n\t\tINIT_LIST_HEAD(&nh->grp_list);\n\t\tINIT_LIST_HEAD(&nh->fdb_list);\n\t}\n\treturn nh;\n}\n\nstatic struct nh_group *nexthop_grp_alloc(u16 num_nh)\n{\n\tstruct nh_group *nhg;\n\n\tnhg = kzalloc(struct_size(nhg, nh_entries, num_nh), GFP_KERNEL);\n\tif (nhg)\n\t\tnhg->num_nh = num_nh;\n\n\treturn nhg;\n}\n\nstatic void nh_res_table_upkeep_dw(struct work_struct *work);\n\nstatic struct nh_res_table *\nnexthop_res_table_alloc(struct net *net, u32 nhg_id, struct nh_config *cfg)\n{\n\tconst u16 num_nh_buckets = cfg->nh_grp_res_num_buckets;\n\tstruct nh_res_table *res_table;\n\tunsigned long size;\n\n\tsize = struct_size(res_table, nh_buckets, num_nh_buckets);\n\tres_table = __vmalloc(size, GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN);\n\tif (!res_table)\n\t\treturn NULL;\n\n\tres_table->net = net;\n\tres_table->nhg_id = nhg_id;\n\tINIT_DELAYED_WORK(&res_table->upkeep_dw, &nh_res_table_upkeep_dw);\n\tINIT_LIST_HEAD(&res_table->uw_nh_entries);\n\tres_table->idle_timer = cfg->nh_grp_res_idle_timer;\n\tres_table->unbalanced_timer = cfg->nh_grp_res_unbalanced_timer;\n\tres_table->num_nh_buckets = num_nh_buckets;\n\treturn res_table;\n}\n\nstatic void nh_base_seq_inc(struct net *net)\n{\n\twhile (++net->nexthop.seq == 0)\n\t\t;\n}\n\n/* no reference taken; rcu lock or rtnl must be held */\nstruct nexthop *nexthop_find_by_id(struct net *net, u32 id)\n{\n\tstruct rb_node **pp, *parent = NULL, *next;\n\n\tpp = &net->nexthop.rb_root.rb_node;\n\twhile (1) {\n\t\tstruct nexthop *nh;\n\n\t\tnext = rcu_dereference_raw(*pp);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tparent = next;\n\n\t\tnh = rb_entry(parent, struct nexthop, rb_node);\n\t\tif (id < nh->id)\n\t\t\tpp = &next->rb_left;\n\t\telse if (id > nh->id)\n\t\t\tpp = &next->rb_right;\n\t\telse\n\t\t\treturn nh;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(nexthop_find_by_id);\n\n/* used for auto id allocation; called with rtnl held */\nstatic u32 nh_find_unused_id(struct net *net)\n{\n\tu32 id_start = net->nexthop.last_id_allocated;\n\n\twhile (1) {\n\t\tnet->nexthop.last_id_allocated++;\n\t\tif (net->nexthop.last_id_allocated == id_start)\n\t\t\tbreak;\n\n\t\tif (!nexthop_find_by_id(net, net->nexthop.last_id_allocated))\n\t\t\treturn net->nexthop.last_id_allocated;\n\t}\n\treturn 0;\n}\n\nstatic void nh_res_time_set_deadline(unsigned long next_time,\n\t\t\t\t     unsigned long *deadline)\n{\n\tif (time_before(next_time, *deadline))\n\t\t*deadline = next_time;\n}\n\nstatic clock_t nh_res_table_unbalanced_time(struct nh_res_table *res_table)\n{\n\tif (list_empty(&res_table->uw_nh_entries))\n\t\treturn 0;\n\treturn jiffies_delta_to_clock_t(jiffies - res_table->unbalanced_since);\n}\n\nstatic int nla_put_nh_group_res(struct sk_buff *skb, struct nh_group *nhg)\n{\n\tstruct nh_res_table *res_table = rtnl_dereference(nhg->res_table);\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, NHA_RES_GROUP);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u16(skb, NHA_RES_GROUP_BUCKETS,\n\t\t\tres_table->num_nh_buckets) ||\n\t    nla_put_u32(skb, NHA_RES_GROUP_IDLE_TIMER,\n\t\t\tjiffies_to_clock_t(res_table->idle_timer)) ||\n\t    nla_put_u32(skb, NHA_RES_GROUP_UNBALANCED_TIMER,\n\t\t\tjiffies_to_clock_t(res_table->unbalanced_timer)) ||\n\t    nla_put_u64_64bit(skb, NHA_RES_GROUP_UNBALANCED_TIME,\n\t\t\t      nh_res_table_unbalanced_time(res_table),\n\t\t\t      NHA_RES_GROUP_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int nla_put_nh_group(struct sk_buff *skb, struct nh_group *nhg)\n{\n\tstruct nexthop_grp *p;\n\tsize_t len = nhg->num_nh * sizeof(*p);\n\tstruct nlattr *nla;\n\tu16 group_type = 0;\n\tint i;\n\n\tif (nhg->hash_threshold)\n\t\tgroup_type = NEXTHOP_GRP_TYPE_MPATH;\n\telse if (nhg->resilient)\n\t\tgroup_type = NEXTHOP_GRP_TYPE_RES;\n\n\tif (nla_put_u16(skb, NHA_GROUP_TYPE, group_type))\n\t\tgoto nla_put_failure;\n\n\tnla = nla_reserve(skb, NHA_GROUP, len);\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\n\tp = nla_data(nla);\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tp->id = nhg->nh_entries[i].nh->id;\n\t\tp->weight = nhg->nh_entries[i].weight - 1;\n\t\tp += 1;\n\t}\n\n\tif (nhg->resilient && nla_put_nh_group_res(skb, nhg))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int nh_fill_node(struct sk_buff *skb, struct nexthop *nh,\n\t\t\tint event, u32 portid, u32 seq, unsigned int nlflags)\n{\n\tstruct fib6_nh *fib6_nh;\n\tstruct fib_nh *fib_nh;\n\tstruct nlmsghdr *nlh;\n\tstruct nh_info *nhi;\n\tstruct nhmsg *nhm;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nhm), nlflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tnhm = nlmsg_data(nlh);\n\tnhm->nh_family = AF_UNSPEC;\n\tnhm->nh_flags = nh->nh_flags;\n\tnhm->nh_protocol = nh->protocol;\n\tnhm->nh_scope = 0;\n\tnhm->resvd = 0;\n\n\tif (nla_put_u32(skb, NHA_ID, nh->id))\n\t\tgoto nla_put_failure;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg = rtnl_dereference(nh->nh_grp);\n\n\t\tif (nhg->fdb_nh && nla_put_flag(skb, NHA_FDB))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_nh_group(skb, nhg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tnhi = rtnl_dereference(nh->nh_info);\n\tnhm->nh_family = nhi->family;\n\tif (nhi->reject_nh) {\n\t\tif (nla_put_flag(skb, NHA_BLACKHOLE))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t} else if (nhi->fdb_nh) {\n\t\tif (nla_put_flag(skb, NHA_FDB))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tconst struct net_device *dev;\n\n\t\tdev = nhi->fib_nhc.nhc_dev;\n\t\tif (dev && nla_put_u32(skb, NHA_OIF, dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnhm->nh_scope = nhi->fib_nhc.nhc_scope;\n\tswitch (nhi->family) {\n\tcase AF_INET:\n\t\tfib_nh = &nhi->fib_nh;\n\t\tif (fib_nh->fib_nh_gw_family &&\n\t\t    nla_put_be32(skb, NHA_GATEWAY, fib_nh->fib_nh_gw4))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tfib6_nh = &nhi->fib6_nh;\n\t\tif (fib6_nh->fib_nh_gw_family &&\n\t\t    nla_put_in6_addr(skb, NHA_GATEWAY, &fib6_nh->fib_nh_gw6))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n\n\tif (nhi->fib_nhc.nhc_lwtstate &&\n\t    lwtunnel_fill_encap(skb, nhi->fib_nhc.nhc_lwtstate,\n\t\t\t\tNHA_ENCAP, NHA_ENCAP_TYPE) < 0)\n\t\tgoto nla_put_failure;\n\nout:\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic size_t nh_nlmsg_size_grp_res(struct nh_group *nhg)\n{\n\treturn nla_total_size(0) +\t/* NHA_RES_GROUP */\n\t\tnla_total_size(2) +\t/* NHA_RES_GROUP_BUCKETS */\n\t\tnla_total_size(4) +\t/* NHA_RES_GROUP_IDLE_TIMER */\n\t\tnla_total_size(4) +\t/* NHA_RES_GROUP_UNBALANCED_TIMER */\n\t\tnla_total_size_64bit(8);/* NHA_RES_GROUP_UNBALANCED_TIME */\n}\n\nstatic size_t nh_nlmsg_size_grp(struct nexthop *nh)\n{\n\tstruct nh_group *nhg = rtnl_dereference(nh->nh_grp);\n\tsize_t sz = sizeof(struct nexthop_grp) * nhg->num_nh;\n\tsize_t tot = nla_total_size(sz) +\n\t\tnla_total_size(2); /* NHA_GROUP_TYPE */\n\n\tif (nhg->resilient)\n\t\ttot += nh_nlmsg_size_grp_res(nhg);\n\n\treturn tot;\n}\n\nstatic size_t nh_nlmsg_size_single(struct nexthop *nh)\n{\n\tstruct nh_info *nhi = rtnl_dereference(nh->nh_info);\n\tsize_t sz;\n\n\t/* covers NHA_BLACKHOLE since NHA_OIF and BLACKHOLE\n\t * are mutually exclusive\n\t */\n\tsz = nla_total_size(4);  /* NHA_OIF */\n\n\tswitch (nhi->family) {\n\tcase AF_INET:\n\t\tif (nhi->fib_nh.fib_nh_gw_family)\n\t\t\tsz += nla_total_size(4);  /* NHA_GATEWAY */\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\t/* NHA_GATEWAY */\n\t\tif (nhi->fib6_nh.fib_nh_gw_family)\n\t\t\tsz += nla_total_size(sizeof(const struct in6_addr));\n\t\tbreak;\n\t}\n\n\tif (nhi->fib_nhc.nhc_lwtstate) {\n\t\tsz += lwtunnel_get_encap_size(nhi->fib_nhc.nhc_lwtstate);\n\t\tsz += nla_total_size(2);  /* NHA_ENCAP_TYPE */\n\t}\n\n\treturn sz;\n}\n\nstatic size_t nh_nlmsg_size(struct nexthop *nh)\n{\n\tsize_t sz = NLMSG_ALIGN(sizeof(struct nhmsg));\n\n\tsz += nla_total_size(4); /* NHA_ID */\n\n\tif (nh->is_group)\n\t\tsz += nh_nlmsg_size_grp(nh);\n\telse\n\t\tsz += nh_nlmsg_size_single(nh);\n\n\treturn sz;\n}\n\nstatic void nexthop_notify(int event, struct nexthop *nh, struct nl_info *info)\n{\n\tunsigned int nlflags = info->nlh ? info->nlh->nlmsg_flags : 0;\n\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(nh_nlmsg_size(nh), gfp_any());\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nh_fill_node(skb, nh, event, info->portid, seq, nlflags);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in nh_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, info->nl_net, info->portid, RTNLGRP_NEXTHOP,\n\t\t    info->nlh, gfp_any());\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(info->nl_net, RTNLGRP_NEXTHOP, err);\n}\n\nstatic unsigned long nh_res_bucket_used_time(const struct nh_res_bucket *bucket)\n{\n\treturn (unsigned long)atomic_long_read(&bucket->used_time);\n}\n\nstatic unsigned long\nnh_res_bucket_idle_point(const struct nh_res_table *res_table,\n\t\t\t const struct nh_res_bucket *bucket,\n\t\t\t unsigned long now)\n{\n\tunsigned long time = nh_res_bucket_used_time(bucket);\n\n\t/* Bucket was not used since it was migrated. The idle time is now. */\n\tif (time == bucket->migrated_time)\n\t\treturn now;\n\n\treturn time + res_table->idle_timer;\n}\n\nstatic unsigned long\nnh_res_table_unb_point(const struct nh_res_table *res_table)\n{\n\treturn res_table->unbalanced_since + res_table->unbalanced_timer;\n}\n\nstatic void nh_res_bucket_set_idle(const struct nh_res_table *res_table,\n\t\t\t\t   struct nh_res_bucket *bucket)\n{\n\tunsigned long now = jiffies;\n\n\tatomic_long_set(&bucket->used_time, (long)now);\n\tbucket->migrated_time = now;\n}\n\nstatic void nh_res_bucket_set_busy(struct nh_res_bucket *bucket)\n{\n\tatomic_long_set(&bucket->used_time, (long)jiffies);\n}\n\nstatic clock_t nh_res_bucket_idle_time(const struct nh_res_bucket *bucket)\n{\n\tunsigned long used_time = nh_res_bucket_used_time(bucket);\n\n\treturn jiffies_delta_to_clock_t(jiffies - used_time);\n}\n\nstatic int nh_fill_res_bucket(struct sk_buff *skb, struct nexthop *nh,\n\t\t\t      struct nh_res_bucket *bucket, u16 bucket_index,\n\t\t\t      int event, u32 portid, u32 seq,\n\t\t\t      unsigned int nlflags,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nh_grp_entry *nhge = nh_res_dereference(bucket->nh_entry);\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nest;\n\tstruct nhmsg *nhm;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*nhm), nlflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tnhm = nlmsg_data(nlh);\n\tnhm->nh_family = AF_UNSPEC;\n\tnhm->nh_flags = bucket->nh_flags;\n\tnhm->nh_protocol = nh->protocol;\n\tnhm->nh_scope = 0;\n\tnhm->resvd = 0;\n\n\tif (nla_put_u32(skb, NHA_ID, nh->id))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, NHA_RES_BUCKET);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, NHA_RES_BUCKET_INDEX, bucket_index) ||\n\t    nla_put_u32(skb, NHA_RES_BUCKET_NH_ID, nhge->nh->id) ||\n\t    nla_put_u64_64bit(skb, NHA_RES_BUCKET_IDLE_TIME,\n\t\t\t      nh_res_bucket_idle_time(bucket),\n\t\t\t      NHA_RES_BUCKET_PAD))\n\t\tgoto nla_put_failure_nest;\n\n\tnla_nest_end(skb, nest);\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure_nest:\n\tnla_nest_cancel(skb, nest);\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic void nexthop_bucket_notify(struct nh_res_table *res_table,\n\t\t\t\t  u16 bucket_index)\n{\n\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[bucket_index];\n\tstruct nh_grp_entry *nhge = nh_res_dereference(bucket->nh_entry);\n\tstruct nexthop *nh = nhge->nh_parent;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = nh_fill_res_bucket(skb, nh, bucket, bucket_index,\n\t\t\t\t RTM_NEWNEXTHOPBUCKET, 0, 0, NLM_F_REPLACE,\n\t\t\t\t NULL);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, nh->net, 0, RTNLGRP_NEXTHOP, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(nh->net, RTNLGRP_NEXTHOP, err);\n}\n\nstatic bool valid_group_nh(struct nexthop *nh, unsigned int npaths,\n\t\t\t   bool *is_fdb, struct netlink_ext_ack *extack)\n{\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg = rtnl_dereference(nh->nh_grp);\n\n\t\t/* Nesting groups within groups is not supported. */\n\t\tif (nhg->hash_threshold) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Hash-threshold group can not be a nexthop within a group\");\n\t\t\treturn false;\n\t\t}\n\t\tif (nhg->resilient) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Resilient group can not be a nexthop within a group\");\n\t\t\treturn false;\n\t\t}\n\t\t*is_fdb = nhg->fdb_nh;\n\t} else {\n\t\tstruct nh_info *nhi = rtnl_dereference(nh->nh_info);\n\n\t\tif (nhi->reject_nh && npaths > 1) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Blackhole nexthop can not be used in a group with more than 1 path\");\n\t\t\treturn false;\n\t\t}\n\t\t*is_fdb = nhi->fdb_nh;\n\t}\n\n\treturn true;\n}\n\nstatic int nh_check_attr_fdb_group(struct nexthop *nh, u8 *nh_family,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nh_info *nhi;\n\n\tnhi = rtnl_dereference(nh->nh_info);\n\n\tif (!nhi->fdb_nh) {\n\t\tNL_SET_ERR_MSG(extack, \"FDB nexthop group can only have fdb nexthops\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*nh_family == AF_UNSPEC) {\n\t\t*nh_family = nhi->family;\n\t} else if (*nh_family != nhi->family) {\n\t\tNL_SET_ERR_MSG(extack, \"FDB nexthop group cannot have mixed family nexthops\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nh_check_attr_group(struct net *net,\n\t\t\t       struct nlattr *tb[], size_t tb_size,\n\t\t\t       u16 nh_grp_type, struct netlink_ext_ack *extack)\n{\n\tunsigned int len = nla_len(tb[NHA_GROUP]);\n\tu8 nh_family = AF_UNSPEC;\n\tstruct nexthop_grp *nhg;\n\tunsigned int i, j;\n\tu8 nhg_fdb = 0;\n\n\tif (!len || len & (sizeof(struct nexthop_grp) - 1)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid length for nexthop group attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* convert len to number of nexthop ids */\n\tlen /= sizeof(*nhg);\n\n\tnhg = nla_data(tb[NHA_GROUP]);\n\tfor (i = 0; i < len; ++i) {\n\t\tif (nhg[i].resvd1 || nhg[i].resvd2) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Reserved fields in nexthop_grp must be 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nhg[i].weight > 254) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid value for weight\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (j = i + 1; j < len; ++j) {\n\t\t\tif (nhg[i].id == nhg[j].id) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop id can not be used twice in a group\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tb[NHA_FDB])\n\t\tnhg_fdb = 1;\n\tnhg = nla_data(tb[NHA_GROUP]);\n\tfor (i = 0; i < len; ++i) {\n\t\tstruct nexthop *nh;\n\t\tbool is_fdb_nh;\n\n\t\tnh = nexthop_find_by_id(net, nhg[i].id);\n\t\tif (!nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid nexthop id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!valid_group_nh(nh, len, &is_fdb_nh, extack))\n\t\t\treturn -EINVAL;\n\n\t\tif (nhg_fdb && nh_check_attr_fdb_group(nh, &nh_family, extack))\n\t\t\treturn -EINVAL;\n\n\t\tif (!nhg_fdb && is_fdb_nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Non FDB nexthop group cannot have fdb nexthops\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tfor (i = NHA_GROUP_TYPE + 1; i < tb_size; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase NHA_FDB:\n\t\t\tcontinue;\n\t\tcase NHA_RES_GROUP:\n\t\t\tif (nh_grp_type == NEXTHOP_GRP_TYPE_RES)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"No other attributes can be set in nexthop groups\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ipv6_good_nh(const struct fib6_nh *nh)\n{\n\tint state = NUD_REACHABLE;\n\tstruct neighbour *n;\n\n\trcu_read_lock_bh();\n\n\tn = __ipv6_neigh_lookup_noref_stub(nh->fib_nh_dev, &nh->fib_nh_gw6);\n\tif (n)\n\t\tstate = n->nud_state;\n\n\trcu_read_unlock_bh();\n\n\treturn !!(state & NUD_VALID);\n}\n\nstatic bool ipv4_good_nh(const struct fib_nh *nh)\n{\n\tint state = NUD_REACHABLE;\n\tstruct neighbour *n;\n\n\trcu_read_lock_bh();\n\n\tn = __ipv4_neigh_lookup_noref(nh->fib_nh_dev,\n\t\t\t\t      (__force u32)nh->fib_nh_gw4);\n\tif (n)\n\t\tstate = n->nud_state;\n\n\trcu_read_unlock_bh();\n\n\treturn !!(state & NUD_VALID);\n}\n\nstatic struct nexthop *nexthop_select_path_hthr(struct nh_group *nhg, int hash)\n{\n\tstruct nexthop *rc = NULL;\n\tint i;\n\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\t\tstruct nh_info *nhi;\n\n\t\tif (hash > atomic_read(&nhge->hthr.upper_bound))\n\t\t\tcontinue;\n\n\t\tnhi = rcu_dereference(nhge->nh->nh_info);\n\t\tif (nhi->fdb_nh)\n\t\t\treturn nhge->nh;\n\n\t\t/* nexthops always check if it is good and does\n\t\t * not rely on a sysctl for this behavior\n\t\t */\n\t\tswitch (nhi->family) {\n\t\tcase AF_INET:\n\t\t\tif (ipv4_good_nh(&nhi->fib_nh))\n\t\t\t\treturn nhge->nh;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tif (ipv6_good_nh(&nhi->fib6_nh))\n\t\t\t\treturn nhge->nh;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rc)\n\t\t\trc = nhge->nh;\n\t}\n\n\treturn rc;\n}\n\nstatic struct nexthop *nexthop_select_path_res(struct nh_group *nhg, int hash)\n{\n\tstruct nh_res_table *res_table = rcu_dereference(nhg->res_table);\n\tu16 bucket_index = hash % res_table->num_nh_buckets;\n\tstruct nh_res_bucket *bucket;\n\tstruct nh_grp_entry *nhge;\n\n\t/* nexthop_select_path() is expected to return a non-NULL value, so\n\t * skip protocol validation and just hand out whatever there is.\n\t */\n\tbucket = &res_table->nh_buckets[bucket_index];\n\tnh_res_bucket_set_busy(bucket);\n\tnhge = rcu_dereference(bucket->nh_entry);\n\treturn nhge->nh;\n}\n\nstruct nexthop *nexthop_select_path(struct nexthop *nh, int hash)\n{\n\tstruct nh_group *nhg;\n\n\tif (!nh->is_group)\n\t\treturn nh;\n\n\tnhg = rcu_dereference(nh->nh_grp);\n\tif (nhg->hash_threshold)\n\t\treturn nexthop_select_path_hthr(nhg, hash);\n\telse if (nhg->resilient)\n\t\treturn nexthop_select_path_res(nhg, hash);\n\n\t/* Unreachable. */\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(nexthop_select_path);\n\nint nexthop_for_each_fib6_nh(struct nexthop *nh,\n\t\t\t     int (*cb)(struct fib6_nh *nh, void *arg),\n\t\t\t     void *arg)\n{\n\tstruct nh_info *nhi;\n\tint err;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg;\n\t\tint i;\n\n\t\tnhg = rcu_dereference_rtnl(nh->nh_grp);\n\t\tfor (i = 0; i < nhg->num_nh; i++) {\n\t\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\n\t\t\tnhi = rcu_dereference_rtnl(nhge->nh->nh_info);\n\t\t\terr = cb(&nhi->fib6_nh, arg);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tnhi = rcu_dereference_rtnl(nh->nh_info);\n\t\terr = cb(&nhi->fib6_nh, arg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nexthop_for_each_fib6_nh);\n\nstatic int check_src_addr(const struct in6_addr *saddr,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (!ipv6_addr_any(saddr)) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 routes using source address can not use nexthop objects\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint fib6_check_nexthop(struct nexthop *nh, struct fib6_config *cfg,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nh_info *nhi;\n\tbool is_fdb_nh;\n\n\t/* fib6_src is unique to a fib6_info and limits the ability to cache\n\t * routes in fib6_nh within a nexthop that is potentially shared\n\t * across multiple fib entries. If the config wants to use source\n\t * routing it can not use nexthop objects. mlxsw also does not allow\n\t * fib6_src on routes.\n\t */\n\tif (cfg && check_src_addr(&cfg->fc_src, extack) < 0)\n\t\treturn -EINVAL;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg;\n\n\t\tnhg = rtnl_dereference(nh->nh_grp);\n\t\tif (nhg->has_v4)\n\t\t\tgoto no_v4_nh;\n\t\tis_fdb_nh = nhg->fdb_nh;\n\t} else {\n\t\tnhi = rtnl_dereference(nh->nh_info);\n\t\tif (nhi->family == AF_INET)\n\t\t\tgoto no_v4_nh;\n\t\tis_fdb_nh = nhi->fdb_nh;\n\t}\n\n\tif (is_fdb_nh) {\n\t\tNL_SET_ERR_MSG(extack, \"Route cannot point to a fdb nexthop\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\nno_v4_nh:\n\tNL_SET_ERR_MSG(extack, \"IPv6 routes can not use an IPv4 nexthop\");\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(fib6_check_nexthop);\n\n/* if existing nexthop has ipv6 routes linked to it, need\n * to verify this new spec works with ipv6\n */\nstatic int fib6_check_nh_list(struct nexthop *old, struct nexthop *new,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *f6i;\n\n\tif (list_empty(&old->f6i_list))\n\t\treturn 0;\n\n\tlist_for_each_entry(f6i, &old->f6i_list, nh_list) {\n\t\tif (check_src_addr(&f6i->fib6_src.addr, extack) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn fib6_check_nexthop(new, NULL, extack);\n}\n\nstatic int nexthop_check_scope(struct nh_info *nhi, u8 scope,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (scope == RT_SCOPE_HOST && nhi->fib_nhc.nhc_gw_family) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Route with host scope can not have a gateway\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nhi->fib_nhc.nhc_flags & RTNH_F_ONLINK && scope >= RT_SCOPE_LINK) {\n\t\tNL_SET_ERR_MSG(extack, \"Scope mismatch with nexthop\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* Invoked by fib add code to verify nexthop by id is ok with\n * config for prefix; parts of fib_check_nh not done when nexthop\n * object is used.\n */\nint fib_check_nexthop(struct nexthop *nh, u8 scope,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nh_info *nhi;\n\tint err = 0;\n\n\tif (nh->is_group) {\n\t\tstruct nh_group *nhg;\n\n\t\tnhg = rtnl_dereference(nh->nh_grp);\n\t\tif (nhg->fdb_nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Route cannot point to a fdb nexthop\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (scope == RT_SCOPE_HOST) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Route with host scope can not have multiple nexthops\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* all nexthops in a group have the same scope */\n\t\tnhi = rtnl_dereference(nhg->nh_entries[0].nh->nh_info);\n\t\terr = nexthop_check_scope(nhi, scope, extack);\n\t} else {\n\t\tnhi = rtnl_dereference(nh->nh_info);\n\t\tif (nhi->fdb_nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Route cannot point to a fdb nexthop\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\terr = nexthop_check_scope(nhi, scope, extack);\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int fib_check_nh_list(struct nexthop *old, struct nexthop *new,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct fib_info *fi;\n\n\tlist_for_each_entry(fi, &old->fi_list, nh_list) {\n\t\tint err;\n\n\t\terr = fib_check_nexthop(new, fi->fib_scope, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic bool nh_res_nhge_is_balanced(const struct nh_grp_entry *nhge)\n{\n\treturn nhge->res.count_buckets == nhge->res.wants_buckets;\n}\n\nstatic bool nh_res_nhge_is_ow(const struct nh_grp_entry *nhge)\n{\n\treturn nhge->res.count_buckets > nhge->res.wants_buckets;\n}\n\nstatic bool nh_res_nhge_is_uw(const struct nh_grp_entry *nhge)\n{\n\treturn nhge->res.count_buckets < nhge->res.wants_buckets;\n}\n\nstatic bool nh_res_table_is_balanced(const struct nh_res_table *res_table)\n{\n\treturn list_empty(&res_table->uw_nh_entries);\n}\n\nstatic void nh_res_bucket_unset_nh(struct nh_res_bucket *bucket)\n{\n\tstruct nh_grp_entry *nhge;\n\n\tif (bucket->occupied) {\n\t\tnhge = nh_res_dereference(bucket->nh_entry);\n\t\tnhge->res.count_buckets--;\n\t\tbucket->occupied = false;\n\t}\n}\n\nstatic void nh_res_bucket_set_nh(struct nh_res_bucket *bucket,\n\t\t\t\t struct nh_grp_entry *nhge)\n{\n\tnh_res_bucket_unset_nh(bucket);\n\n\tbucket->occupied = true;\n\trcu_assign_pointer(bucket->nh_entry, nhge);\n\tnhge->res.count_buckets++;\n}\n\nstatic bool nh_res_bucket_should_migrate(struct nh_res_table *res_table,\n\t\t\t\t\t struct nh_res_bucket *bucket,\n\t\t\t\t\t unsigned long *deadline, bool *force)\n{\n\tunsigned long now = jiffies;\n\tstruct nh_grp_entry *nhge;\n\tunsigned long idle_point;\n\n\tif (!bucket->occupied) {\n\t\t/* The bucket is not occupied, its NHGE pointer is either\n\t\t * NULL or obsolete. We _have to_ migrate: set force.\n\t\t */\n\t\t*force = true;\n\t\treturn true;\n\t}\n\n\tnhge = nh_res_dereference(bucket->nh_entry);\n\n\t/* If the bucket is populated by an underweight or balanced\n\t * nexthop, do not migrate.\n\t */\n\tif (!nh_res_nhge_is_ow(nhge))\n\t\treturn false;\n\n\t/* At this point we know that the bucket is populated with an\n\t * overweight nexthop. It needs to be migrated to a new nexthop if\n\t * the idle timer of unbalanced timer expired.\n\t */\n\n\tidle_point = nh_res_bucket_idle_point(res_table, bucket, now);\n\tif (time_after_eq(now, idle_point)) {\n\t\t/* The bucket is idle. We _can_ migrate: unset force. */\n\t\t*force = false;\n\t\treturn true;\n\t}\n\n\t/* Unbalanced timer of 0 means \"never force\". */\n\tif (res_table->unbalanced_timer) {\n\t\tunsigned long unb_point;\n\n\t\tunb_point = nh_res_table_unb_point(res_table);\n\t\tif (time_after(now, unb_point)) {\n\t\t\t/* The bucket is not idle, but the unbalanced timer\n\t\t\t * expired. We _can_ migrate, but set force anyway,\n\t\t\t * so that drivers know to ignore activity reports\n\t\t\t * from the HW.\n\t\t\t */\n\t\t\t*force = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tnh_res_time_set_deadline(unb_point, deadline);\n\t}\n\n\tnh_res_time_set_deadline(idle_point, deadline);\n\treturn false;\n}\n\nstatic bool nh_res_bucket_migrate(struct nh_res_table *res_table,\n\t\t\t\t  u16 bucket_index, bool notify,\n\t\t\t\t  bool notify_nl, bool force)\n{\n\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[bucket_index];\n\tstruct nh_grp_entry *new_nhge;\n\tstruct netlink_ext_ack extack;\n\tint err;\n\n\tnew_nhge = list_first_entry_or_null(&res_table->uw_nh_entries,\n\t\t\t\t\t    struct nh_grp_entry,\n\t\t\t\t\t    res.uw_nh_entry);\n\tif (WARN_ON_ONCE(!new_nhge))\n\t\t/* If this function is called, \"bucket\" is either not\n\t\t * occupied, or it belongs to a next hop that is\n\t\t * overweight. In either case, there ought to be a\n\t\t * corresponding underweight next hop.\n\t\t */\n\t\treturn false;\n\n\tif (notify) {\n\t\tstruct nh_grp_entry *old_nhge;\n\n\t\told_nhge = nh_res_dereference(bucket->nh_entry);\n\t\terr = call_nexthop_res_bucket_notifiers(res_table->net,\n\t\t\t\t\t\t\tres_table->nhg_id,\n\t\t\t\t\t\t\tbucket_index, force,\n\t\t\t\t\t\t\told_nhge->nh,\n\t\t\t\t\t\t\tnew_nhge->nh, &extack);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited(\"%s\\n\", extack._msg);\n\t\t\tif (!force)\n\t\t\t\treturn false;\n\t\t\t/* It is not possible to veto a forced replacement, so\n\t\t\t * just clear the hardware flags from the nexthop\n\t\t\t * bucket to indicate to user space that this bucket is\n\t\t\t * not correctly populated in hardware.\n\t\t\t */\n\t\t\tbucket->nh_flags &= ~(RTNH_F_OFFLOAD | RTNH_F_TRAP);\n\t\t}\n\t}\n\n\tnh_res_bucket_set_nh(bucket, new_nhge);\n\tnh_res_bucket_set_idle(res_table, bucket);\n\n\tif (notify_nl)\n\t\tnexthop_bucket_notify(res_table, bucket_index);\n\n\tif (nh_res_nhge_is_balanced(new_nhge))\n\t\tlist_del(&new_nhge->res.uw_nh_entry);\n\treturn true;\n}\n\n#define NH_RES_UPKEEP_DW_MINIMUM_INTERVAL (HZ / 2)\n\nstatic void nh_res_table_upkeep(struct nh_res_table *res_table,\n\t\t\t\tbool notify, bool notify_nl)\n{\n\tunsigned long now = jiffies;\n\tunsigned long deadline;\n\tu16 i;\n\n\t/* Deadline is the next time that upkeep should be run. It is the\n\t * earliest time at which one of the buckets might be migrated.\n\t * Start at the most pessimistic estimate: either unbalanced_timer\n\t * from now, or if there is none, idle_timer from now. For each\n\t * encountered time point, call nh_res_time_set_deadline() to\n\t * refine the estimate.\n\t */\n\tif (res_table->unbalanced_timer)\n\t\tdeadline = now + res_table->unbalanced_timer;\n\telse\n\t\tdeadline = now + res_table->idle_timer;\n\n\tfor (i = 0; i < res_table->num_nh_buckets; i++) {\n\t\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[i];\n\t\tbool force;\n\n\t\tif (nh_res_bucket_should_migrate(res_table, bucket,\n\t\t\t\t\t\t &deadline, &force)) {\n\t\t\tif (!nh_res_bucket_migrate(res_table, i, notify,\n\t\t\t\t\t\t   notify_nl, force)) {\n\t\t\t\tunsigned long idle_point;\n\n\t\t\t\t/* A driver can override the migration\n\t\t\t\t * decision if the HW reports that the\n\t\t\t\t * bucket is actually not idle. Therefore\n\t\t\t\t * remark the bucket as busy again and\n\t\t\t\t * update the deadline.\n\t\t\t\t */\n\t\t\t\tnh_res_bucket_set_busy(bucket);\n\t\t\t\tidle_point = nh_res_bucket_idle_point(res_table,\n\t\t\t\t\t\t\t\t      bucket,\n\t\t\t\t\t\t\t\t      now);\n\t\t\t\tnh_res_time_set_deadline(idle_point, &deadline);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* If the group is still unbalanced, schedule the next upkeep to\n\t * either the deadline computed above, or the minimum deadline,\n\t * whichever comes later.\n\t */\n\tif (!nh_res_table_is_balanced(res_table)) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long min_deadline;\n\n\t\tmin_deadline = now + NH_RES_UPKEEP_DW_MINIMUM_INTERVAL;\n\t\tif (time_before(deadline, min_deadline))\n\t\t\tdeadline = min_deadline;\n\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t   &res_table->upkeep_dw, deadline - now);\n\t}\n}\n\nstatic void nh_res_table_upkeep_dw(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct nh_res_table *res_table;\n\n\tres_table = container_of(dw, struct nh_res_table, upkeep_dw);\n\tnh_res_table_upkeep(res_table, true, true);\n}\n\nstatic void nh_res_table_cancel_upkeep(struct nh_res_table *res_table)\n{\n\tcancel_delayed_work_sync(&res_table->upkeep_dw);\n}\n\nstatic void nh_res_group_rebalance(struct nh_group *nhg,\n\t\t\t\t   struct nh_res_table *res_table)\n{\n\tint prev_upper_bound = 0;\n\tint total = 0;\n\tint w = 0;\n\tint i;\n\n\tINIT_LIST_HEAD(&res_table->uw_nh_entries);\n\n\tfor (i = 0; i < nhg->num_nh; ++i)\n\t\ttotal += nhg->nh_entries[i].weight;\n\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\t\tint upper_bound;\n\n\t\tw += nhge->weight;\n\t\tupper_bound = DIV_ROUND_CLOSEST(res_table->num_nh_buckets * w,\n\t\t\t\t\t\ttotal);\n\t\tnhge->res.wants_buckets = upper_bound - prev_upper_bound;\n\t\tprev_upper_bound = upper_bound;\n\n\t\tif (nh_res_nhge_is_uw(nhge)) {\n\t\t\tif (list_empty(&res_table->uw_nh_entries))\n\t\t\t\tres_table->unbalanced_since = jiffies;\n\t\t\tlist_add(&nhge->res.uw_nh_entry,\n\t\t\t\t &res_table->uw_nh_entries);\n\t\t}\n\t}\n}\n\n/* Migrate buckets in res_table so that they reference NHGE's from NHG with\n * the right NH ID. Set those buckets that do not have a corresponding NHGE\n * entry in NHG as not occupied.\n */\nstatic void nh_res_table_migrate_buckets(struct nh_res_table *res_table,\n\t\t\t\t\t struct nh_group *nhg)\n{\n\tu16 i;\n\n\tfor (i = 0; i < res_table->num_nh_buckets; i++) {\n\t\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[i];\n\t\tu32 id = rtnl_dereference(bucket->nh_entry)->nh->id;\n\t\tbool found = false;\n\t\tint j;\n\n\t\tfor (j = 0; j < nhg->num_nh; j++) {\n\t\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[j];\n\n\t\t\tif (nhge->nh->id == id) {\n\t\t\t\tnh_res_bucket_set_nh(bucket, nhge);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\tnh_res_bucket_unset_nh(bucket);\n\t}\n}\n\nstatic void replace_nexthop_grp_res(struct nh_group *oldg,\n\t\t\t\t    struct nh_group *newg)\n{\n\t/* For NH group replacement, the new NHG might only have a stub\n\t * hash table with 0 buckets, because the number of buckets was not\n\t * specified. For NH removal, oldg and newg both reference the same\n\t * res_table. So in any case, in the following, we want to work\n\t * with oldg->res_table.\n\t */\n\tstruct nh_res_table *old_res_table = rtnl_dereference(oldg->res_table);\n\tunsigned long prev_unbalanced_since = old_res_table->unbalanced_since;\n\tbool prev_has_uw = !list_empty(&old_res_table->uw_nh_entries);\n\n\tnh_res_table_cancel_upkeep(old_res_table);\n\tnh_res_table_migrate_buckets(old_res_table, newg);\n\tnh_res_group_rebalance(newg, old_res_table);\n\tif (prev_has_uw && !list_empty(&old_res_table->uw_nh_entries))\n\t\told_res_table->unbalanced_since = prev_unbalanced_since;\n\tnh_res_table_upkeep(old_res_table, true, false);\n}\n\nstatic void nh_hthr_group_rebalance(struct nh_group *nhg)\n{\n\tint total = 0;\n\tint w = 0;\n\tint i;\n\n\tfor (i = 0; i < nhg->num_nh; ++i)\n\t\ttotal += nhg->nh_entries[i].weight;\n\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\t\tint upper_bound;\n\n\t\tw += nhge->weight;\n\t\tupper_bound = DIV_ROUND_CLOSEST_ULL((u64)w << 31, total) - 1;\n\t\tatomic_set(&nhge->hthr.upper_bound, upper_bound);\n\t}\n}\n\nstatic void remove_nh_grp_entry(struct net *net, struct nh_grp_entry *nhge,\n\t\t\t\tstruct nl_info *nlinfo)\n{\n\tstruct nh_grp_entry *nhges, *new_nhges;\n\tstruct nexthop *nhp = nhge->nh_parent;\n\tstruct netlink_ext_ack extack;\n\tstruct nexthop *nh = nhge->nh;\n\tstruct nh_group *nhg, *newg;\n\tint i, j, err;\n\n\tWARN_ON(!nh);\n\n\tnhg = rtnl_dereference(nhp->nh_grp);\n\tnewg = nhg->spare;\n\n\t/* last entry, keep it visible and remove the parent */\n\tif (nhg->num_nh == 1) {\n\t\tremove_nexthop(net, nhp, nlinfo);\n\t\treturn;\n\t}\n\n\tnewg->has_v4 = false;\n\tnewg->is_multipath = nhg->is_multipath;\n\tnewg->hash_threshold = nhg->hash_threshold;\n\tnewg->resilient = nhg->resilient;\n\tnewg->fdb_nh = nhg->fdb_nh;\n\tnewg->num_nh = nhg->num_nh;\n\n\t/* copy old entries to new except the one getting removed */\n\tnhges = nhg->nh_entries;\n\tnew_nhges = newg->nh_entries;\n\tfor (i = 0, j = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nh_info *nhi;\n\n\t\t/* current nexthop getting removed */\n\t\tif (nhg->nh_entries[i].nh == nh) {\n\t\t\tnewg->num_nh--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnhi = rtnl_dereference(nhges[i].nh->nh_info);\n\t\tif (nhi->family == AF_INET)\n\t\t\tnewg->has_v4 = true;\n\n\t\tlist_del(&nhges[i].nh_list);\n\t\tnew_nhges[j].nh_parent = nhges[i].nh_parent;\n\t\tnew_nhges[j].nh = nhges[i].nh;\n\t\tnew_nhges[j].weight = nhges[i].weight;\n\t\tlist_add(&new_nhges[j].nh_list, &new_nhges[j].nh->grp_list);\n\t\tj++;\n\t}\n\n\tif (newg->hash_threshold)\n\t\tnh_hthr_group_rebalance(newg);\n\telse if (newg->resilient)\n\t\treplace_nexthop_grp_res(nhg, newg);\n\n\trcu_assign_pointer(nhp->nh_grp, newg);\n\n\tlist_del(&nhge->nh_list);\n\tnexthop_put(nhge->nh);\n\n\t/* Removal of a NH from a resilient group is notified through\n\t * bucket notifications.\n\t */\n\tif (newg->hash_threshold) {\n\t\terr = call_nexthop_notifiers(net, NEXTHOP_EVENT_REPLACE, nhp,\n\t\t\t\t\t     &extack);\n\t\tif (err)\n\t\t\tpr_err(\"%s\\n\", extack._msg);\n\t}\n\n\tif (nlinfo)\n\t\tnexthop_notify(RTM_NEWNEXTHOP, nhp, nlinfo);\n}\n\nstatic void remove_nexthop_from_groups(struct net *net, struct nexthop *nh,\n\t\t\t\t       struct nl_info *nlinfo)\n{\n\tstruct nh_grp_entry *nhge, *tmp;\n\n\tlist_for_each_entry_safe(nhge, tmp, &nh->grp_list, nh_list)\n\t\tremove_nh_grp_entry(net, nhge, nlinfo);\n\n\t/* make sure all see the newly published array before releasing rtnl */\n\tsynchronize_net();\n}\n\nstatic void remove_nexthop_group(struct nexthop *nh, struct nl_info *nlinfo)\n{\n\tstruct nh_group *nhg = rcu_dereference_rtnl(nh->nh_grp);\n\tstruct nh_res_table *res_table;\n\tint i, num_nh = nhg->num_nh;\n\n\tfor (i = 0; i < num_nh; ++i) {\n\t\tstruct nh_grp_entry *nhge = &nhg->nh_entries[i];\n\n\t\tif (WARN_ON(!nhge->nh))\n\t\t\tcontinue;\n\n\t\tlist_del_init(&nhge->nh_list);\n\t}\n\n\tif (nhg->resilient) {\n\t\tres_table = rtnl_dereference(nhg->res_table);\n\t\tnh_res_table_cancel_upkeep(res_table);\n\t}\n}\n\n/* not called for nexthop replace */\nstatic void __remove_nexthop_fib(struct net *net, struct nexthop *nh)\n{\n\tstruct fib6_info *f6i, *tmp;\n\tbool do_flush = false;\n\tstruct fib_info *fi;\n\n\tlist_for_each_entry(fi, &nh->fi_list, nh_list) {\n\t\tfi->fib_flags |= RTNH_F_DEAD;\n\t\tdo_flush = true;\n\t}\n\tif (do_flush)\n\t\tfib_flush(net);\n\n\t/* ip6_del_rt removes the entry from this list hence the _safe */\n\tlist_for_each_entry_safe(f6i, tmp, &nh->f6i_list, nh_list) {\n\t\t/* __ip6_del_rt does a release, so do a hold here */\n\t\tfib6_info_hold(f6i);\n\t\tipv6_stub->ip6_del_rt(net, f6i,\n\t\t\t\t      !net->ipv4.sysctl_nexthop_compat_mode);\n\t}\n}\n\nstatic void __remove_nexthop(struct net *net, struct nexthop *nh,\n\t\t\t     struct nl_info *nlinfo)\n{\n\t__remove_nexthop_fib(net, nh);\n\n\tif (nh->is_group) {\n\t\tremove_nexthop_group(nh, nlinfo);\n\t} else {\n\t\tstruct nh_info *nhi;\n\n\t\tnhi = rtnl_dereference(nh->nh_info);\n\t\tif (nhi->fib_nhc.nhc_dev)\n\t\t\thlist_del(&nhi->dev_hash);\n\n\t\tremove_nexthop_from_groups(net, nh, nlinfo);\n\t}\n}\n\nstatic void remove_nexthop(struct net *net, struct nexthop *nh,\n\t\t\t   struct nl_info *nlinfo)\n{\n\tcall_nexthop_notifiers(net, NEXTHOP_EVENT_DEL, nh, NULL);\n\n\t/* remove from the tree */\n\trb_erase(&nh->rb_node, &net->nexthop.rb_root);\n\n\tif (nlinfo)\n\t\tnexthop_notify(RTM_DELNEXTHOP, nh, nlinfo);\n\n\t__remove_nexthop(net, nh, nlinfo);\n\tnh_base_seq_inc(net);\n\n\tnexthop_put(nh);\n}\n\n/* if any FIB entries reference this nexthop, any dst entries\n * need to be regenerated\n */\nstatic void nh_rt_cache_flush(struct net *net, struct nexthop *nh)\n{\n\tstruct fib6_info *f6i;\n\n\tif (!list_empty(&nh->fi_list))\n\t\trt_cache_flush(net);\n\n\tlist_for_each_entry(f6i, &nh->f6i_list, nh_list)\n\t\tipv6_stub->fib6_update_sernum(net, f6i);\n}\n\nstatic int replace_nexthop_grp(struct net *net, struct nexthop *old,\n\t\t\t       struct nexthop *new, const struct nh_config *cfg,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nh_res_table *tmp_table = NULL;\n\tstruct nh_res_table *new_res_table;\n\tstruct nh_res_table *old_res_table;\n\tstruct nh_group *oldg, *newg;\n\tint i, err;\n\n\tif (!new->is_group) {\n\t\tNL_SET_ERR_MSG(extack, \"Can not replace a nexthop group with a nexthop.\");\n\t\treturn -EINVAL;\n\t}\n\n\toldg = rtnl_dereference(old->nh_grp);\n\tnewg = rtnl_dereference(new->nh_grp);\n\n\tif (newg->hash_threshold != oldg->hash_threshold) {\n\t\tNL_SET_ERR_MSG(extack, \"Can not replace a nexthop group with one of a different type.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (newg->hash_threshold) {\n\t\terr = call_nexthop_notifiers(net, NEXTHOP_EVENT_REPLACE, new,\n\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (newg->resilient) {\n\t\tnew_res_table = rtnl_dereference(newg->res_table);\n\t\told_res_table = rtnl_dereference(oldg->res_table);\n\n\t\t/* Accept if num_nh_buckets was not given, but if it was\n\t\t * given, demand that the value be correct.\n\t\t */\n\t\tif (cfg->nh_grp_res_has_num_buckets &&\n\t\t    cfg->nh_grp_res_num_buckets !=\n\t\t    old_res_table->num_nh_buckets) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Can not change number of buckets of a resilient nexthop group.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Emit a pre-replace notification so that listeners could veto\n\t\t * a potentially unsupported configuration. Otherwise,\n\t\t * individual bucket replacement notifications would need to be\n\t\t * vetoed, which is something that should only happen if the\n\t\t * bucket is currently active.\n\t\t */\n\t\terr = call_nexthop_res_table_notifiers(net, new, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (cfg->nh_grp_res_has_idle_timer)\n\t\t\told_res_table->idle_timer = cfg->nh_grp_res_idle_timer;\n\t\tif (cfg->nh_grp_res_has_unbalanced_timer)\n\t\t\told_res_table->unbalanced_timer =\n\t\t\t\tcfg->nh_grp_res_unbalanced_timer;\n\n\t\treplace_nexthop_grp_res(oldg, newg);\n\n\t\ttmp_table = new_res_table;\n\t\trcu_assign_pointer(newg->res_table, old_res_table);\n\t\trcu_assign_pointer(newg->spare->res_table, old_res_table);\n\t}\n\n\t/* update parents - used by nexthop code for cleanup */\n\tfor (i = 0; i < newg->num_nh; i++)\n\t\tnewg->nh_entries[i].nh_parent = old;\n\n\trcu_assign_pointer(old->nh_grp, newg);\n\n\tif (newg->resilient) {\n\t\trcu_assign_pointer(oldg->res_table, tmp_table);\n\t\trcu_assign_pointer(oldg->spare->res_table, tmp_table);\n\t}\n\n\tfor (i = 0; i < oldg->num_nh; i++)\n\t\toldg->nh_entries[i].nh_parent = new;\n\n\trcu_assign_pointer(new->nh_grp, oldg);\n\n\treturn 0;\n}\n\nstatic void nh_group_v4_update(struct nh_group *nhg)\n{\n\tstruct nh_grp_entry *nhges;\n\tbool has_v4 = false;\n\tint i;\n\n\tnhges = nhg->nh_entries;\n\tfor (i = 0; i < nhg->num_nh; i++) {\n\t\tstruct nh_info *nhi;\n\n\t\tnhi = rtnl_dereference(nhges[i].nh->nh_info);\n\t\tif (nhi->family == AF_INET)\n\t\t\thas_v4 = true;\n\t}\n\tnhg->has_v4 = has_v4;\n}\n\nstatic int replace_nexthop_single_notify_res(struct net *net,\n\t\t\t\t\t     struct nh_res_table *res_table,\n\t\t\t\t\t     struct nexthop *old,\n\t\t\t\t\t     struct nh_info *oldi,\n\t\t\t\t\t     struct nh_info *newi,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 nhg_id = res_table->nhg_id;\n\tint err;\n\tu16 i;\n\n\tfor (i = 0; i < res_table->num_nh_buckets; i++) {\n\t\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[i];\n\t\tstruct nh_grp_entry *nhge;\n\n\t\tnhge = rtnl_dereference(bucket->nh_entry);\n\t\tif (nhge->nh == old) {\n\t\t\terr = __call_nexthop_res_bucket_notifiers(net, nhg_id,\n\t\t\t\t\t\t\t\t  i, true,\n\t\t\t\t\t\t\t\t  oldi, newi,\n\t\t\t\t\t\t\t\t  extack);\n\t\t\tif (err)\n\t\t\t\tgoto err_notify;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_notify:\n\twhile (i-- > 0) {\n\t\tstruct nh_res_bucket *bucket = &res_table->nh_buckets[i];\n\t\tstruct nh_grp_entry *nhge;\n\n\t\tnhge = rtnl_dereference(bucket->nh_entry);\n\t\tif (nhge->nh == old)\n\t\t\t__call_nexthop_res_bucket_notifiers(net, nhg_id, i,\n\t\t\t\t\t\t\t    true, newi, oldi,\n\t\t\t\t\t\t\t    extack);\n\t}\n\treturn err;\n}\n\nstatic int replace_nexthop_single_notify(struct net *net,\n\t\t\t\t\t struct nexthop *group_nh,\n\t\t\t\t\t struct nexthop *old,\n\t\t\t\t\t struct nh_info *oldi,\n\t\t\t\t\t struct nh_info *newi,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nh_group *nhg = rtnl_dereference(group_nh->nh_grp);\n\tstruct nh_res_table *res_table;\n\n\tif (nhg->hash_threshold) {\n\t\treturn call_nexthop_notifiers(net, NEXTHOP_EVENT_REPLACE,\n\t\t\t\t\t      group_nh, extack);\n\t} else if (nhg->resilient) {\n\t\tres_table = rtnl_dereference(nhg->res_table);\n\t\treturn replace_nexthop_single_notify_res(net, res_table,\n\t\t\t\t\t\t\t old, oldi, newi,\n\t\t\t\t\t\t\t extack);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int replace_nexthop_single(struct net *net, struct nexthop *old,\n\t\t\t\t  struct nexthop *new,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tu8 old_protocol, old_nh_flags;\n\tstruct nh_info *oldi, *newi;\n\tstruct nh_grp_entry *nhge;\n\tint err;\n\n\tif (new->is_group) {\n\t\tNL_SET_ERR_MSG(extack, \"Can not replace a nexthop with a nexthop group.\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = call_nexthop_notifiers(net, NEXTHOP_EVENT_REPLACE, new, extack);\n\tif (err)\n\t\treturn err;\n\n\t/* Hardware flags were set on 'old' as 'new' is not in the red-black\n\t * tree. Therefore, inherit the flags from 'old' to 'new'.\n\t */\n\tnew->nh_flags |= old->nh_flags & (RTNH_F_OFFLOAD | RTNH_F_TRAP);\n\n\toldi = rtnl_dereference(old->nh_info);\n\tnewi = rtnl_dereference(new->nh_info);\n\n\tnewi->nh_parent = old;\n\toldi->nh_parent = new;\n\n\told_protocol = old->protocol;\n\told_nh_flags = old->nh_flags;\n\n\told->protocol = new->protocol;\n\told->nh_flags = new->nh_flags;\n\n\trcu_assign_pointer(old->nh_info, newi);\n\trcu_assign_pointer(new->nh_info, oldi);\n\n\t/* Send a replace notification for all the groups using the nexthop. */\n\tlist_for_each_entry(nhge, &old->grp_list, nh_list) {\n\t\tstruct nexthop *nhp = nhge->nh_parent;\n\n\t\terr = replace_nexthop_single_notify(net, nhp, old, oldi, newi,\n\t\t\t\t\t\t    extack);\n\t\tif (err)\n\t\t\tgoto err_notify;\n\t}\n\n\t/* When replacing an IPv4 nexthop with an IPv6 nexthop, potentially\n\t * update IPv4 indication in all the groups using the nexthop.\n\t */\n\tif (oldi->family == AF_INET && newi->family == AF_INET6) {\n\t\tlist_for_each_entry(nhge, &old->grp_list, nh_list) {\n\t\t\tstruct nexthop *nhp = nhge->nh_parent;\n\t\t\tstruct nh_group *nhg;\n\n\t\t\tnhg = rtnl_dereference(nhp->nh_grp);\n\t\t\tnh_group_v4_update(nhg);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_notify:\n\trcu_assign_pointer(new->nh_info, newi);\n\trcu_assign_pointer(old->nh_info, oldi);\n\told->nh_flags = old_nh_flags;\n\told->protocol = old_protocol;\n\toldi->nh_parent = old;\n\tnewi->nh_parent = new;\n\tlist_for_each_entry_continue_reverse(nhge, &old->grp_list, nh_list) {\n\t\tstruct nexthop *nhp = nhge->nh_parent;\n\n\t\treplace_nexthop_single_notify(net, nhp, old, newi, oldi, NULL);\n\t}\n\tcall_nexthop_notifiers(net, NEXTHOP_EVENT_REPLACE, old, extack);\n\treturn err;\n}\n\nstatic void __nexthop_replace_notify(struct net *net, struct nexthop *nh,\n\t\t\t\t     struct nl_info *info)\n{\n\tstruct fib6_info *f6i;\n\n\tif (!list_empty(&nh->fi_list)) {\n\t\tstruct fib_info *fi;\n\n\t\t/* expectation is a few fib_info per nexthop and then\n\t\t * a lot of routes per fib_info. So mark the fib_info\n\t\t * and then walk the fib tables once\n\t\t */\n\t\tlist_for_each_entry(fi, &nh->fi_list, nh_list)\n\t\t\tfi->nh_updated = true;\n\n\t\tfib_info_notify_update(net, info);\n\n\t\tlist_for_each_entry(fi, &nh->fi_list, nh_list)\n\t\t\tfi->nh_updated = false;\n\t}\n\n\tlist_for_each_entry(f6i, &nh->f6i_list, nh_list)\n\t\tipv6_stub->fib6_rt_update(net, f6i, info);\n}\n\n/* send RTM_NEWROUTE with REPLACE flag set for all FIB entries\n * linked to this nexthop and for all groups that the nexthop\n * is a member of\n */\nstatic void nexthop_replace_notify(struct net *net, struct nexthop *nh,\n\t\t\t\t   struct nl_info *info)\n{\n\tstruct nh_grp_entry *nhge;\n\n\t__nexthop_replace_notify(net, nh, info);\n\n\tlist_for_each_entry(nhge, &nh->grp_list, nh_list)\n\t\t__nexthop_replace_notify(net, nhge->nh_parent, info);\n}\n\nstatic int replace_nexthop(struct net *net, struct nexthop *old,\n\t\t\t   struct nexthop *new, const struct nh_config *cfg,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbool new_is_reject = false;\n\tstruct nh_grp_entry *nhge;\n\tint err;\n\n\t/* check that existing FIB entries are ok with the\n\t * new nexthop definition\n\t */\n\terr = fib_check_nh_list(old, new, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = fib6_check_nh_list(old, new, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!new->is_group) {\n\t\tstruct nh_info *nhi = rtnl_dereference(new->nh_info);\n\n\t\tnew_is_reject = nhi->reject_nh;\n\t}\n\n\tlist_for_each_entry(nhge, &old->grp_list, nh_list) {\n\t\t/* if new nexthop is a blackhole, any groups using this\n\t\t * nexthop cannot have more than 1 path\n\t\t */\n\t\tif (new_is_reject &&\n\t\t    nexthop_num_path(nhge->nh_parent) > 1) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Blackhole nexthop can not be a member of a group with more than one path\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = fib_check_nh_list(nhge->nh_parent, new, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = fib6_check_nh_list(nhge->nh_parent, new, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (old->is_group)\n\t\terr = replace_nexthop_grp(net, old, new, cfg, extack);\n\telse\n\t\terr = replace_nexthop_single(net, old, new, extack);\n\n\tif (!err) {\n\t\tnh_rt_cache_flush(net, old);\n\n\t\t__remove_nexthop(net, new, NULL);\n\t\tnexthop_put(new);\n\t}\n\n\treturn err;\n}\n\n/* called with rtnl_lock held */\nstatic int insert_nexthop(struct net *net, struct nexthop *new_nh,\n\t\t\t  struct nh_config *cfg, struct netlink_ext_ack *extack)\n{\n\tstruct rb_node **pp, *parent = NULL, *next;\n\tstruct rb_root *root = &net->nexthop.rb_root;\n\tbool replace = !!(cfg->nlflags & NLM_F_REPLACE);\n\tbool create = !!(cfg->nlflags & NLM_F_CREATE);\n\tu32 new_id = new_nh->id;\n\tint replace_notify = 0;\n\tint rc = -EEXIST;\n\n\tpp = &root->rb_node;\n\twhile (1) {\n\t\tstruct nexthop *nh;\n\n\t\tnext = *pp;\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tparent = next;\n\n\t\tnh = rb_entry(parent, struct nexthop, rb_node);\n\t\tif (new_id < nh->id) {\n\t\t\tpp = &next->rb_left;\n\t\t} else if (new_id > nh->id) {\n\t\t\tpp = &next->rb_right;\n\t\t} else if (replace) {\n\t\t\trc = replace_nexthop(net, nh, new_nh, cfg, extack);\n\t\t\tif (!rc) {\n\t\t\t\tnew_nh = nh; /* send notification with old nh */\n\t\t\t\treplace_notify = 1;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t/* id already exists and not a replace */\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (replace && !create) {\n\t\tNL_SET_ERR_MSG(extack, \"Replace specified without create and no entry exists\");\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (new_nh->is_group) {\n\t\tstruct nh_group *nhg = rtnl_dereference(new_nh->nh_grp);\n\t\tstruct nh_res_table *res_table;\n\n\t\tif (nhg->resilient) {\n\t\t\tres_table = rtnl_dereference(nhg->res_table);\n\n\t\t\t/* Not passing the number of buckets is OK when\n\t\t\t * replacing, but not when creating a new group.\n\t\t\t */\n\t\t\tif (!cfg->nh_grp_res_has_num_buckets) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Number of buckets not specified for nexthop group insertion\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnh_res_group_rebalance(nhg, res_table);\n\n\t\t\t/* Do not send bucket notifications, we do full\n\t\t\t * notification below.\n\t\t\t */\n\t\t\tnh_res_table_upkeep(res_table, false, false);\n\t\t}\n\t}\n\n\trb_link_node_rcu(&new_nh->rb_node, parent, pp);\n\trb_insert_color(&new_nh->rb_node, root);\n\n\t/* The initial insertion is a full notification for hash-threshold as\n\t * well as resilient groups.\n\t */\n\trc = call_nexthop_notifiers(net, NEXTHOP_EVENT_REPLACE, new_nh, extack);\n\tif (rc)\n\t\trb_erase(&new_nh->rb_node, &net->nexthop.rb_root);\n\nout:\n\tif (!rc) {\n\t\tnh_base_seq_inc(net);\n\t\tnexthop_notify(RTM_NEWNEXTHOP, new_nh, &cfg->nlinfo);\n\t\tif (replace_notify && net->ipv4.sysctl_nexthop_compat_mode)\n\t\t\tnexthop_replace_notify(net, new_nh, &cfg->nlinfo);\n\t}\n\n\treturn rc;\n}\n\n/* rtnl */\n/* remove all nexthops tied to a device being deleted */\nstatic void nexthop_flush_dev(struct net_device *dev, unsigned long event)\n{\n\tunsigned int hash = nh_dev_hashfn(dev->ifindex);\n\tstruct net *net = dev_net(dev);\n\tstruct hlist_head *head = &net->nexthop.devhash[hash];\n\tstruct hlist_node *n;\n\tstruct nh_info *nhi;\n\n\thlist_for_each_entry_safe(nhi, n, head, dev_hash) {\n\t\tif (nhi->fib_nhc.nhc_dev != dev)\n\t\t\tcontinue;\n\n\t\tif (nhi->reject_nh &&\n\t\t    (event == NETDEV_DOWN || event == NETDEV_CHANGE))\n\t\t\tcontinue;\n\n\t\tremove_nexthop(net, nhi->nh_parent, NULL);\n\t}\n}\n\n/* rtnl; called when net namespace is deleted */\nstatic void flush_all_nexthops(struct net *net)\n{\n\tstruct rb_root *root = &net->nexthop.rb_root;\n\tstruct rb_node *node;\n\tstruct nexthop *nh;\n\n\twhile ((node = rb_first(root))) {\n\t\tnh = rb_entry(node, struct nexthop, rb_node);\n\t\tremove_nexthop(net, nh, NULL);\n\t\tcond_resched();\n\t}\n}\n\nstatic struct nexthop *nexthop_create_group(struct net *net,\n\t\t\t\t\t    struct nh_config *cfg)\n{\n\tstruct nlattr *grps_attr = cfg->nh_grp;\n\tstruct nexthop_grp *entry = nla_data(grps_attr);\n\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);\n\tstruct nh_group *nhg;\n\tstruct nexthop *nh;\n\tint err;\n\tint i;\n\n\tif (WARN_ON(!num_nh))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnh = nexthop_alloc();\n\tif (!nh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnh->is_group = 1;\n\n\tnhg = nexthop_grp_alloc(num_nh);\n\tif (!nhg) {\n\t\tkfree(nh);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* spare group used for removals */\n\tnhg->spare = nexthop_grp_alloc(num_nh);\n\tif (!nhg->spare) {\n\t\tkfree(nhg);\n\t\tkfree(nh);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnhg->spare->spare = nhg;\n\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nexthop *nhe;\n\t\tstruct nh_info *nhi;\n\n\t\tnhe = nexthop_find_by_id(net, entry[i].id);\n\t\tif (!nexthop_get(nhe)) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_no_nh;\n\t\t}\n\n\t\tnhi = rtnl_dereference(nhe->nh_info);\n\t\tif (nhi->family == AF_INET)\n\t\t\tnhg->has_v4 = true;\n\n\t\tnhg->nh_entries[i].nh = nhe;\n\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;\n\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);\n\t\tnhg->nh_entries[i].nh_parent = nh;\n\t}\n\n\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {\n\t\tnhg->hash_threshold = 1;\n\t\tnhg->is_multipath = true;\n\t} else if (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_RES) {\n\t\tstruct nh_res_table *res_table;\n\n\t\tres_table = nexthop_res_table_alloc(net, cfg->nh_id, cfg);\n\t\tif (!res_table) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_no_nh;\n\t\t}\n\n\t\trcu_assign_pointer(nhg->spare->res_table, res_table);\n\t\trcu_assign_pointer(nhg->res_table, res_table);\n\t\tnhg->resilient = true;\n\t\tnhg->is_multipath = true;\n\t}\n\n\tWARN_ON_ONCE(nhg->hash_threshold + nhg->resilient != 1);\n\n\tif (nhg->hash_threshold)\n\t\tnh_hthr_group_rebalance(nhg);\n\n\tif (cfg->nh_fdb)\n\t\tnhg->fdb_nh = 1;\n\n\trcu_assign_pointer(nh->nh_grp, nhg);\n\n\treturn nh;\n\nout_no_nh:\n\tfor (i--; i >= 0; --i) {\n\t\tlist_del(&nhg->nh_entries[i].nh_list);\n\t\tnexthop_put(nhg->nh_entries[i].nh);\n\t}\n\n\tkfree(nhg->spare);\n\tkfree(nhg);\n\tkfree(nh);\n\n\treturn ERR_PTR(err);\n}\n\nstatic int nh_create_ipv4(struct net *net, struct nexthop *nh,\n\t\t\t  struct nh_info *nhi, struct nh_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct fib_nh *fib_nh = &nhi->fib_nh;\n\tstruct fib_config fib_cfg = {\n\t\t.fc_oif   = cfg->nh_ifindex,\n\t\t.fc_gw4   = cfg->gw.ipv4,\n\t\t.fc_gw_family = cfg->gw.ipv4 ? AF_INET : 0,\n\t\t.fc_flags = cfg->nh_flags,\n\t\t.fc_encap = cfg->nh_encap,\n\t\t.fc_encap_type = cfg->nh_encap_type,\n\t};\n\tu32 tb_id = (cfg->dev ? l3mdev_fib_table(cfg->dev) : RT_TABLE_MAIN);\n\tint err;\n\n\terr = fib_nh_init(net, fib_nh, &fib_cfg, 1, extack);\n\tif (err) {\n\t\tfib_nh_release(net, fib_nh);\n\t\tgoto out;\n\t}\n\n\tif (nhi->fdb_nh)\n\t\tgoto out;\n\n\t/* sets nh_dev if successful */\n\terr = fib_check_nh(net, fib_nh, tb_id, 0, extack);\n\tif (!err) {\n\t\tnh->nh_flags = fib_nh->fib_nh_flags;\n\t\tfib_info_update_nhc_saddr(net, &fib_nh->nh_common,\n\t\t\t\t\t  fib_nh->fib_nh_scope);\n\t} else {\n\t\tfib_nh_release(net, fib_nh);\n\t}\nout:\n\treturn err;\n}\n\nstatic int nh_create_ipv6(struct net *net,  struct nexthop *nh,\n\t\t\t  struct nh_info *nhi, struct nh_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct fib6_nh *fib6_nh = &nhi->fib6_nh;\n\tstruct fib6_config fib6_cfg = {\n\t\t.fc_table = l3mdev_fib_table(cfg->dev),\n\t\t.fc_ifindex = cfg->nh_ifindex,\n\t\t.fc_gateway = cfg->gw.ipv6,\n\t\t.fc_flags = cfg->nh_flags,\n\t\t.fc_encap = cfg->nh_encap,\n\t\t.fc_encap_type = cfg->nh_encap_type,\n\t\t.fc_is_fdb = cfg->nh_fdb,\n\t};\n\tint err;\n\n\tif (!ipv6_addr_any(&cfg->gw.ipv6))\n\t\tfib6_cfg.fc_flags |= RTF_GATEWAY;\n\n\t/* sets nh_dev if successful */\n\terr = ipv6_stub->fib6_nh_init(net, fib6_nh, &fib6_cfg, GFP_KERNEL,\n\t\t\t\t      extack);\n\tif (err)\n\t\tipv6_stub->fib6_nh_release(fib6_nh);\n\telse\n\t\tnh->nh_flags = fib6_nh->fib_nh_flags;\n\n\treturn err;\n}\n\nstatic struct nexthop *nexthop_create(struct net *net, struct nh_config *cfg,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nh_info *nhi;\n\tstruct nexthop *nh;\n\tint err = 0;\n\n\tnh = nexthop_alloc();\n\tif (!nh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnhi = kzalloc(sizeof(*nhi), GFP_KERNEL);\n\tif (!nhi) {\n\t\tkfree(nh);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnh->nh_flags = cfg->nh_flags;\n\tnh->net = net;\n\n\tnhi->nh_parent = nh;\n\tnhi->family = cfg->nh_family;\n\tnhi->fib_nhc.nhc_scope = RT_SCOPE_LINK;\n\n\tif (cfg->nh_fdb)\n\t\tnhi->fdb_nh = 1;\n\n\tif (cfg->nh_blackhole) {\n\t\tnhi->reject_nh = 1;\n\t\tcfg->nh_ifindex = net->loopback_dev->ifindex;\n\t}\n\n\tswitch (cfg->nh_family) {\n\tcase AF_INET:\n\t\terr = nh_create_ipv4(net, nh, nhi, cfg, extack);\n\t\tbreak;\n\tcase AF_INET6:\n\t\terr = nh_create_ipv6(net, nh, nhi, cfg, extack);\n\t\tbreak;\n\t}\n\n\tif (err) {\n\t\tkfree(nhi);\n\t\tkfree(nh);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t/* add the entry to the device based hash */\n\tif (!nhi->fdb_nh)\n\t\tnexthop_devhash_add(net, nhi);\n\n\trcu_assign_pointer(nh->nh_info, nhi);\n\n\treturn nh;\n}\n\n/* called with rtnl lock held */\nstatic struct nexthop *nexthop_add(struct net *net, struct nh_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nexthop *nh;\n\tint err;\n\n\tif (cfg->nlflags & NLM_F_REPLACE && !cfg->nh_id) {\n\t\tNL_SET_ERR_MSG(extack, \"Replace requires nexthop id\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!cfg->nh_id) {\n\t\tcfg->nh_id = nh_find_unused_id(net);\n\t\tif (!cfg->nh_id) {\n\t\t\tNL_SET_ERR_MSG(extack, \"No unused id\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tif (cfg->nh_grp)\n\t\tnh = nexthop_create_group(net, cfg);\n\telse\n\t\tnh = nexthop_create(net, cfg, extack);\n\n\tif (IS_ERR(nh))\n\t\treturn nh;\n\n\trefcount_set(&nh->refcnt, 1);\n\tnh->id = cfg->nh_id;\n\tnh->protocol = cfg->nh_protocol;\n\tnh->net = net;\n\n\terr = insert_nexthop(net, nh, cfg, extack);\n\tif (err) {\n\t\t__remove_nexthop(net, nh, NULL);\n\t\tnexthop_put(nh);\n\t\tnh = ERR_PTR(err);\n\t}\n\n\treturn nh;\n}\n\nstatic int rtm_nh_get_timer(struct nlattr *attr, unsigned long fallback,\n\t\t\t    unsigned long *timer_p, bool *has_p,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tunsigned long timer;\n\tu32 value;\n\n\tif (!attr) {\n\t\t*timer_p = fallback;\n\t\t*has_p = false;\n\t\treturn 0;\n\t}\n\n\tvalue = nla_get_u32(attr);\n\ttimer = clock_t_to_jiffies(value);\n\tif (timer == ~0UL) {\n\t\tNL_SET_ERR_MSG(extack, \"Timer value too large\");\n\t\treturn -EINVAL;\n\t}\n\n\t*timer_p = timer;\n\t*has_p = true;\n\treturn 0;\n}\n\nstatic int rtm_to_nh_config_grp_res(struct nlattr *res, struct nh_config *cfg,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_res_policy_new)] = {};\n\tint err;\n\n\tif (res) {\n\t\terr = nla_parse_nested(tb,\n\t\t\t\t       ARRAY_SIZE(rtm_nh_res_policy_new) - 1,\n\t\t\t\t       res, rtm_nh_res_policy_new, extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (tb[NHA_RES_GROUP_BUCKETS]) {\n\t\tcfg->nh_grp_res_num_buckets =\n\t\t\tnla_get_u16(tb[NHA_RES_GROUP_BUCKETS]);\n\t\tcfg->nh_grp_res_has_num_buckets = true;\n\t\tif (!cfg->nh_grp_res_num_buckets) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Number of buckets needs to be non-0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = rtm_nh_get_timer(tb[NHA_RES_GROUP_IDLE_TIMER],\n\t\t\t       NH_RES_DEFAULT_IDLE_TIMER,\n\t\t\t       &cfg->nh_grp_res_idle_timer,\n\t\t\t       &cfg->nh_grp_res_has_idle_timer,\n\t\t\t       extack);\n\tif (err)\n\t\treturn err;\n\n\treturn rtm_nh_get_timer(tb[NHA_RES_GROUP_UNBALANCED_TIMER],\n\t\t\t\tNH_RES_DEFAULT_UNBALANCED_TIMER,\n\t\t\t\t&cfg->nh_grp_res_unbalanced_timer,\n\t\t\t\t&cfg->nh_grp_res_has_unbalanced_timer,\n\t\t\t\textack);\n}\n\nstatic int rtm_to_nh_config(struct net *net, struct sk_buff *skb,\n\t\t\t    struct nlmsghdr *nlh, struct nh_config *cfg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nhmsg *nhm = nlmsg_data(nlh);\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_policy_new)];\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*nhm), tb,\n\t\t\t  ARRAY_SIZE(rtm_nh_policy_new) - 1,\n\t\t\t  rtm_nh_policy_new, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EINVAL;\n\tif (nhm->resvd || nhm->nh_scope) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in ancillary header\");\n\t\tgoto out;\n\t}\n\tif (nhm->nh_flags & ~NEXTHOP_VALID_USER_FLAGS) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid nexthop flags in ancillary header\");\n\t\tgoto out;\n\t}\n\n\tswitch (nhm->nh_family) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\tbreak;\n\tcase AF_UNSPEC:\n\t\tif (tb[NHA_GROUP])\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Invalid address family\");\n\t\tgoto out;\n\t}\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\tcfg->nlflags = nlh->nlmsg_flags;\n\tcfg->nlinfo.portid = NETLINK_CB(skb).portid;\n\tcfg->nlinfo.nlh = nlh;\n\tcfg->nlinfo.nl_net = net;\n\n\tcfg->nh_family = nhm->nh_family;\n\tcfg->nh_protocol = nhm->nh_protocol;\n\tcfg->nh_flags = nhm->nh_flags;\n\n\tif (tb[NHA_ID])\n\t\tcfg->nh_id = nla_get_u32(tb[NHA_ID]);\n\n\tif (tb[NHA_FDB]) {\n\t\tif (tb[NHA_OIF] || tb[NHA_BLACKHOLE] ||\n\t\t    tb[NHA_ENCAP]   || tb[NHA_ENCAP_TYPE]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Fdb attribute can not be used with encap, oif or blackhole\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (nhm->nh_flags) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported nexthop flags in ancillary header\");\n\t\t\tgoto out;\n\t\t}\n\t\tcfg->nh_fdb = nla_get_flag(tb[NHA_FDB]);\n\t}\n\n\tif (tb[NHA_GROUP]) {\n\t\tif (nhm->nh_family != AF_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid family for group\");\n\t\t\tgoto out;\n\t\t}\n\t\tcfg->nh_grp = tb[NHA_GROUP];\n\n\t\tcfg->nh_grp_type = NEXTHOP_GRP_TYPE_MPATH;\n\t\tif (tb[NHA_GROUP_TYPE])\n\t\t\tcfg->nh_grp_type = nla_get_u16(tb[NHA_GROUP_TYPE]);\n\n\t\tif (cfg->nh_grp_type > NEXTHOP_GRP_TYPE_MAX) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid group type\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = nh_check_attr_group(net, tb, ARRAY_SIZE(tb),\n\t\t\t\t\t  cfg->nh_grp_type, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_RES)\n\t\t\terr = rtm_to_nh_config_grp_res(tb[NHA_RES_GROUP],\n\t\t\t\t\t\t       cfg, extack);\n\n\t\t/* no other attributes should be set */\n\t\tgoto out;\n\t}\n\n\tif (tb[NHA_BLACKHOLE]) {\n\t\tif (tb[NHA_GATEWAY] || tb[NHA_OIF] ||\n\t\t    tb[NHA_ENCAP]   || tb[NHA_ENCAP_TYPE] || tb[NHA_FDB]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Blackhole attribute can not be used with gateway, oif, encap or fdb\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcfg->nh_blackhole = 1;\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (!cfg->nh_fdb && !tb[NHA_OIF]) {\n\t\tNL_SET_ERR_MSG(extack, \"Device attribute required for non-blackhole and non-fdb nexthops\");\n\t\tgoto out;\n\t}\n\n\tif (!cfg->nh_fdb && tb[NHA_OIF]) {\n\t\tcfg->nh_ifindex = nla_get_u32(tb[NHA_OIF]);\n\t\tif (cfg->nh_ifindex)\n\t\t\tcfg->dev = __dev_get_by_index(net, cfg->nh_ifindex);\n\n\t\tif (!cfg->dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid device index\");\n\t\t\tgoto out;\n\t\t} else if (!(cfg->dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t} else if (!netif_carrier_ok(cfg->dev)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Carrier for nexthop device is down\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = -EINVAL;\n\tif (tb[NHA_GATEWAY]) {\n\t\tstruct nlattr *gwa = tb[NHA_GATEWAY];\n\n\t\tswitch (cfg->nh_family) {\n\t\tcase AF_INET:\n\t\t\tif (nla_len(gwa) != sizeof(u32)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid gateway\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcfg->gw.ipv4 = nla_get_be32(gwa);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tif (nla_len(gwa) != sizeof(struct in6_addr)) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid gateway\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcfg->gw.ipv6 = nla_get_in6_addr(gwa);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Unknown address family for gateway\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* device only nexthop (no gateway) */\n\t\tif (cfg->nh_flags & RTNH_F_ONLINK) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"ONLINK flag can not be set for nexthop without a gateway\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tb[NHA_ENCAP]) {\n\t\tcfg->nh_encap = tb[NHA_ENCAP];\n\n\t\tif (!tb[NHA_ENCAP_TYPE]) {\n\t\t\tNL_SET_ERR_MSG(extack, \"LWT encapsulation type is missing\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcfg->nh_encap_type = nla_get_u16(tb[NHA_ENCAP_TYPE]);\n\t\terr = lwtunnel_valid_encap_type(cfg->nh_encap_type, extack);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t} else if (tb[NHA_ENCAP_TYPE]) {\n\t\tNL_SET_ERR_MSG(extack, \"LWT encapsulation attribute is missing\");\n\t\tgoto out;\n\t}\n\n\n\terr = 0;\nout:\n\treturn err;\n}\n\n/* rtnl */\nstatic int rtm_new_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nh_config cfg;\n\tstruct nexthop *nh;\n\tint err;\n\n\terr = rtm_to_nh_config(net, skb, nlh, &cfg, extack);\n\tif (!err) {\n\t\tnh = nexthop_add(net, &cfg, extack);\n\t\tif (IS_ERR(nh))\n\t\t\terr = PTR_ERR(nh);\n\t}\n\n\treturn err;\n}\n\nstatic int __nh_valid_get_del_req(const struct nlmsghdr *nlh,\n\t\t\t\t  struct nlattr **tb, u32 *id,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nhmsg *nhm = nlmsg_data(nlh);\n\n\tif (nhm->nh_protocol || nhm->resvd || nhm->nh_scope || nhm->nh_flags) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tb[NHA_ID]) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop id is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\t*id = nla_get_u32(tb[NHA_ID]);\n\tif (!(*id)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid nexthop id\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nh_valid_get_del_req(const struct nlmsghdr *nlh, u32 *id,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_policy_get)];\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(struct nhmsg), tb,\n\t\t\t  ARRAY_SIZE(rtm_nh_policy_get) - 1,\n\t\t\t  rtm_nh_policy_get, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn __nh_valid_get_del_req(nlh, tb, id, extack);\n}\n\n/* rtnl */\nstatic int rtm_del_nexthop(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nl_info nlinfo = {\n\t\t.nlh = nlh,\n\t\t.nl_net = net,\n\t\t.portid = NETLINK_CB(skb).portid,\n\t};\n\tstruct nexthop *nh;\n\tint err;\n\tu32 id;\n\n\terr = nh_valid_get_del_req(nlh, &id, extack);\n\tif (err)\n\t\treturn err;\n\n\tnh = nexthop_find_by_id(net, id);\n\tif (!nh)\n\t\treturn -ENOENT;\n\n\tremove_nexthop(net, nh, &nlinfo);\n\n\treturn 0;\n}\n\n/* rtnl */\nstatic int rtm_get_nexthop(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct sk_buff *skb = NULL;\n\tstruct nexthop *nh;\n\tint err;\n\tu32 id;\n\n\terr = nh_valid_get_del_req(nlh, &id, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = -ENOBUFS;\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tnh = nexthop_find_by_id(net, id);\n\tif (!nh)\n\t\tgoto errout_free;\n\n\terr = nh_fill_node(skb, nh, RTM_NEWNEXTHOP, NETLINK_CB(in_skb).portid,\n\t\t\t   nlh->nlmsg_seq, 0);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tgoto errout_free;\n\t}\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nout:\n\treturn err;\nerrout_free:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\nstruct nh_dump_filter {\n\tu32 nh_id;\n\tint dev_idx;\n\tint master_idx;\n\tbool group_filter;\n\tbool fdb_filter;\n\tu32 res_bucket_nh_id;\n};\n\nstatic bool nh_dump_filtered(struct nexthop *nh,\n\t\t\t     struct nh_dump_filter *filter, u8 family)\n{\n\tconst struct net_device *dev;\n\tconst struct nh_info *nhi;\n\n\tif (filter->group_filter && !nh->is_group)\n\t\treturn true;\n\n\tif (!filter->dev_idx && !filter->master_idx && !family)\n\t\treturn false;\n\n\tif (nh->is_group)\n\t\treturn true;\n\n\tnhi = rtnl_dereference(nh->nh_info);\n\tif (family && nhi->family != family)\n\t\treturn true;\n\n\tdev = nhi->fib_nhc.nhc_dev;\n\tif (filter->dev_idx && (!dev || dev->ifindex != filter->dev_idx))\n\t\treturn true;\n\n\tif (filter->master_idx) {\n\t\tstruct net_device *master;\n\n\t\tif (!dev)\n\t\t\treturn true;\n\n\t\tmaster = netdev_master_upper_dev_get((struct net_device *)dev);\n\t\tif (!master || master->ifindex != filter->master_idx)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int __nh_valid_dump_req(const struct nlmsghdr *nlh, struct nlattr **tb,\n\t\t\t       struct nh_dump_filter *filter,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nhmsg *nhm;\n\tu32 idx;\n\n\tif (tb[NHA_OIF]) {\n\t\tidx = nla_get_u32(tb[NHA_OIF]);\n\t\tif (idx > INT_MAX) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid device index\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter->dev_idx = idx;\n\t}\n\tif (tb[NHA_MASTER]) {\n\t\tidx = nla_get_u32(tb[NHA_MASTER]);\n\t\tif (idx > INT_MAX) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid master device index\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfilter->master_idx = idx;\n\t}\n\tfilter->group_filter = nla_get_flag(tb[NHA_GROUPS]);\n\tfilter->fdb_filter = nla_get_flag(tb[NHA_FDB]);\n\n\tnhm = nlmsg_data(nlh);\n\tif (nhm->nh_protocol || nhm->resvd || nhm->nh_scope || nhm->nh_flags) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for nexthop dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nh_valid_dump_req(const struct nlmsghdr *nlh,\n\t\t\t     struct nh_dump_filter *filter,\n\t\t\t     struct netlink_callback *cb)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_policy_dump)];\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(struct nhmsg), tb,\n\t\t\t  ARRAY_SIZE(rtm_nh_policy_dump) - 1,\n\t\t\t  rtm_nh_policy_dump, cb->extack);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn __nh_valid_dump_req(nlh, tb, filter, cb->extack);\n}\n\nstruct rtm_dump_nh_ctx {\n\tu32 idx;\n};\n\nstatic struct rtm_dump_nh_ctx *\nrtm_dump_nh_ctx(struct netlink_callback *cb)\n{\n\tstruct rtm_dump_nh_ctx *ctx = (void *)cb->ctx;\n\n\tBUILD_BUG_ON(sizeof(*ctx) > sizeof(cb->ctx));\n\treturn ctx;\n}\n\nstatic int rtm_dump_walk_nexthops(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb,\n\t\t\t\t  struct rb_root *root,\n\t\t\t\t  struct rtm_dump_nh_ctx *ctx,\n\t\t\t\t  int (*nh_cb)(struct sk_buff *skb,\n\t\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t\t       struct nexthop *nh, void *data),\n\t\t\t\t  void *data)\n{\n\tstruct rb_node *node;\n\tint idx = 0, s_idx;\n\tint err;\n\n\ts_idx = ctx->idx;\n\tfor (node = rb_first(root); node; node = rb_next(node)) {\n\t\tstruct nexthop *nh;\n\n\t\tif (idx < s_idx)\n\t\t\tgoto cont;\n\n\t\tnh = rb_entry(node, struct nexthop, rb_node);\n\t\tctx->idx = idx;\n\t\terr = nh_cb(skb, cb, nh, data);\n\t\tif (err)\n\t\t\treturn err;\ncont:\n\t\tidx++;\n\t}\n\n\tctx->idx = idx;\n\treturn 0;\n}\n\nstatic int rtm_dump_nexthop_cb(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t       struct nexthop *nh, void *data)\n{\n\tstruct nhmsg *nhm = nlmsg_data(cb->nlh);\n\tstruct nh_dump_filter *filter = data;\n\n\tif (nh_dump_filtered(nh, filter, nhm->nh_family))\n\t\treturn 0;\n\n\treturn nh_fill_node(skb, nh, RTM_NEWNEXTHOP,\n\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t    cb->nlh->nlmsg_seq, NLM_F_MULTI);\n}\n\n/* rtnl */\nstatic int rtm_dump_nexthop(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rtm_dump_nh_ctx *ctx = rtm_dump_nh_ctx(cb);\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rb_root *root = &net->nexthop.rb_root;\n\tstruct nh_dump_filter filter = {};\n\tint err;\n\n\terr = nh_valid_dump_req(cb->nlh, &filter, cb);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtm_dump_walk_nexthops(skb, cb, root, ctx,\n\t\t\t\t     &rtm_dump_nexthop_cb, &filter);\n\tif (err < 0) {\n\t\tif (likely(skb->len))\n\t\t\tgoto out;\n\t\tgoto out_err;\n\t}\n\nout:\n\terr = skb->len;\nout_err:\n\tcb->seq = net->nexthop.seq;\n\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\treturn err;\n}\n\nstatic struct nexthop *\nnexthop_find_group_resilient(struct net *net, u32 id,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nh_group *nhg;\n\tstruct nexthop *nh;\n\n\tnh = nexthop_find_by_id(net, id);\n\tif (!nh)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (!nh->is_group) {\n\t\tNL_SET_ERR_MSG(extack, \"Not a nexthop group\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnhg = rtnl_dereference(nh->nh_grp);\n\tif (!nhg->resilient) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop group not of type resilient\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn nh;\n}\n\nstatic int nh_valid_dump_nhid(struct nlattr *attr, u32 *nh_id_p,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tu32 idx;\n\n\tif (attr) {\n\t\tidx = nla_get_u32(attr);\n\t\tif (!idx) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid nexthop id\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*nh_id_p = idx;\n\t} else {\n\t\t*nh_id_p = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int nh_valid_dump_bucket_req(const struct nlmsghdr *nlh,\n\t\t\t\t    struct nh_dump_filter *filter,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct nlattr *res_tb[ARRAY_SIZE(rtm_nh_res_bucket_policy_dump)];\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_policy_dump_bucket)];\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(struct nhmsg), tb,\n\t\t\t  ARRAY_SIZE(rtm_nh_policy_dump_bucket) - 1,\n\t\t\t  rtm_nh_policy_dump_bucket, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = nh_valid_dump_nhid(tb[NHA_ID], &filter->nh_id, cb->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NHA_RES_BUCKET]) {\n\t\tsize_t max = ARRAY_SIZE(rtm_nh_res_bucket_policy_dump) - 1;\n\n\t\terr = nla_parse_nested(res_tb, max,\n\t\t\t\t       tb[NHA_RES_BUCKET],\n\t\t\t\t       rtm_nh_res_bucket_policy_dump,\n\t\t\t\t       cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = nh_valid_dump_nhid(res_tb[NHA_RES_BUCKET_NH_ID],\n\t\t\t\t\t &filter->res_bucket_nh_id,\n\t\t\t\t\t cb->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn __nh_valid_dump_req(nlh, tb, filter, cb->extack);\n}\n\nstruct rtm_dump_res_bucket_ctx {\n\tstruct rtm_dump_nh_ctx nh;\n\tu16 bucket_index;\n\tu32 done_nh_idx; /* 1 + the index of the last fully processed NH. */\n};\n\nstatic struct rtm_dump_res_bucket_ctx *\nrtm_dump_res_bucket_ctx(struct netlink_callback *cb)\n{\n\tstruct rtm_dump_res_bucket_ctx *ctx = (void *)cb->ctx;\n\n\tBUILD_BUG_ON(sizeof(*ctx) > sizeof(cb->ctx));\n\treturn ctx;\n}\n\nstruct rtm_dump_nexthop_bucket_data {\n\tstruct rtm_dump_res_bucket_ctx *ctx;\n\tstruct nh_dump_filter filter;\n};\n\nstatic int rtm_dump_nexthop_bucket_nh(struct sk_buff *skb,\n\t\t\t\t      struct netlink_callback *cb,\n\t\t\t\t      struct nexthop *nh,\n\t\t\t\t      struct rtm_dump_nexthop_bucket_data *dd)\n{\n\tu32 portid = NETLINK_CB(cb->skb).portid;\n\tstruct nhmsg *nhm = nlmsg_data(cb->nlh);\n\tstruct nh_res_table *res_table;\n\tstruct nh_group *nhg;\n\tu16 bucket_index;\n\tint err;\n\n\tif (dd->ctx->nh.idx < dd->ctx->done_nh_idx)\n\t\treturn 0;\n\n\tnhg = rtnl_dereference(nh->nh_grp);\n\tres_table = rtnl_dereference(nhg->res_table);\n\tfor (bucket_index = dd->ctx->bucket_index;\n\t     bucket_index < res_table->num_nh_buckets;\n\t     bucket_index++) {\n\t\tstruct nh_res_bucket *bucket;\n\t\tstruct nh_grp_entry *nhge;\n\n\t\tbucket = &res_table->nh_buckets[bucket_index];\n\t\tnhge = rtnl_dereference(bucket->nh_entry);\n\t\tif (nh_dump_filtered(nhge->nh, &dd->filter, nhm->nh_family))\n\t\t\tcontinue;\n\n\t\tif (dd->filter.res_bucket_nh_id &&\n\t\t    dd->filter.res_bucket_nh_id != nhge->nh->id)\n\t\t\tcontinue;\n\n\t\terr = nh_fill_res_bucket(skb, nh, bucket, bucket_index,\n\t\t\t\t\t RTM_NEWNEXTHOPBUCKET, portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t cb->extack);\n\t\tif (err < 0) {\n\t\t\tif (likely(skb->len))\n\t\t\t\tgoto out;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tdd->ctx->done_nh_idx = dd->ctx->nh.idx + 1;\n\tbucket_index = 0;\n\nout:\n\terr = skb->len;\nout_err:\n\tdd->ctx->bucket_index = bucket_index;\n\treturn err;\n}\n\nstatic int rtm_dump_nexthop_bucket_cb(struct sk_buff *skb,\n\t\t\t\t      struct netlink_callback *cb,\n\t\t\t\t      struct nexthop *nh, void *data)\n{\n\tstruct rtm_dump_nexthop_bucket_data *dd = data;\n\tstruct nh_group *nhg;\n\n\tif (!nh->is_group)\n\t\treturn 0;\n\n\tnhg = rtnl_dereference(nh->nh_grp);\n\tif (!nhg->resilient)\n\t\treturn 0;\n\n\treturn rtm_dump_nexthop_bucket_nh(skb, cb, nh, dd);\n}\n\n/* rtnl */\nstatic int rtm_dump_nexthop_bucket(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct rtm_dump_res_bucket_ctx *ctx = rtm_dump_res_bucket_ctx(cb);\n\tstruct rtm_dump_nexthop_bucket_data dd = { .ctx = ctx };\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nexthop *nh;\n\tint err;\n\n\terr = nh_valid_dump_bucket_req(cb->nlh, &dd.filter, cb);\n\tif (err)\n\t\treturn err;\n\n\tif (dd.filter.nh_id) {\n\t\tnh = nexthop_find_group_resilient(net, dd.filter.nh_id,\n\t\t\t\t\t\t  cb->extack);\n\t\tif (IS_ERR(nh))\n\t\t\treturn PTR_ERR(nh);\n\t\terr = rtm_dump_nexthop_bucket_nh(skb, cb, nh, &dd);\n\t} else {\n\t\tstruct rb_root *root = &net->nexthop.rb_root;\n\n\t\terr = rtm_dump_walk_nexthops(skb, cb, root, &ctx->nh,\n\t\t\t\t\t     &rtm_dump_nexthop_bucket_cb, &dd);\n\t}\n\n\tif (err < 0) {\n\t\tif (likely(skb->len))\n\t\t\tgoto out;\n\t\tgoto out_err;\n\t}\n\nout:\n\terr = skb->len;\nout_err:\n\tcb->seq = net->nexthop.seq;\n\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\treturn err;\n}\n\nstatic int nh_valid_get_bucket_req_res_bucket(struct nlattr *res,\n\t\t\t\t\t      u16 *bucket_index,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_res_bucket_policy_get)];\n\tint err;\n\n\terr = nla_parse_nested(tb, ARRAY_SIZE(rtm_nh_res_bucket_policy_get) - 1,\n\t\t\t       res, rtm_nh_res_bucket_policy_get, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NHA_RES_BUCKET_INDEX]) {\n\t\tNL_SET_ERR_MSG(extack, \"Bucket index is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\t*bucket_index = nla_get_u16(tb[NHA_RES_BUCKET_INDEX]);\n\treturn 0;\n}\n\nstatic int nh_valid_get_bucket_req(const struct nlmsghdr *nlh,\n\t\t\t\t   u32 *id, u16 *bucket_index,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[ARRAY_SIZE(rtm_nh_policy_get_bucket)];\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(struct nhmsg), tb,\n\t\t\t  ARRAY_SIZE(rtm_nh_policy_get_bucket) - 1,\n\t\t\t  rtm_nh_policy_get_bucket, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = __nh_valid_get_del_req(nlh, tb, id, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NHA_RES_BUCKET]) {\n\t\tNL_SET_ERR_MSG(extack, \"Bucket information is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nh_valid_get_bucket_req_res_bucket(tb[NHA_RES_BUCKET],\n\t\t\t\t\t\t bucket_index, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/* rtnl */\nstatic int rtm_get_nexthop_bucket(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nh_res_table *res_table;\n\tstruct sk_buff *skb = NULL;\n\tstruct nh_group *nhg;\n\tstruct nexthop *nh;\n\tu16 bucket_index;\n\tint err;\n\tu32 id;\n\n\terr = nh_valid_get_bucket_req(nlh, &id, &bucket_index, extack);\n\tif (err)\n\t\treturn err;\n\n\tnh = nexthop_find_group_resilient(net, id, extack);\n\tif (IS_ERR(nh))\n\t\treturn PTR_ERR(nh);\n\n\tnhg = rtnl_dereference(nh->nh_grp);\n\tres_table = rtnl_dereference(nhg->res_table);\n\tif (bucket_index >= res_table->num_nh_buckets) {\n\t\tNL_SET_ERR_MSG(extack, \"Bucket index out of bounds\");\n\t\treturn -ENOENT;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\terr = nh_fill_res_bucket(skb, nh, &res_table->nh_buckets[bucket_index],\n\t\t\t\t bucket_index, RTM_NEWNEXTHOPBUCKET,\n\t\t\t\t NETLINK_CB(in_skb).portid, nlh->nlmsg_seq,\n\t\t\t\t 0, extack);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tgoto errout_free;\n\t}\n\n\treturn rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\n\nerrout_free:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic void nexthop_sync_mtu(struct net_device *dev, u32 orig_mtu)\n{\n\tunsigned int hash = nh_dev_hashfn(dev->ifindex);\n\tstruct net *net = dev_net(dev);\n\tstruct hlist_head *head = &net->nexthop.devhash[hash];\n\tstruct hlist_node *n;\n\tstruct nh_info *nhi;\n\n\thlist_for_each_entry_safe(nhi, n, head, dev_hash) {\n\t\tif (nhi->fib_nhc.nhc_dev == dev) {\n\t\t\tif (nhi->family == AF_INET)\n\t\t\t\tfib_nhc_update_mtu(&nhi->fib_nhc, dev->mtu,\n\t\t\t\t\t\t   orig_mtu);\n\t\t}\n\t}\n}\n\n/* rtnl */\nstatic int nh_netdev_event(struct notifier_block *this,\n\t\t\t   unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_info_ext *info_ext;\n\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\tcase NETDEV_UNREGISTER:\n\t\tnexthop_flush_dev(dev, event);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tif (!(dev_get_flags(dev) & (IFF_RUNNING | IFF_LOWER_UP)))\n\t\t\tnexthop_flush_dev(dev, event);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tinfo_ext = ptr;\n\t\tnexthop_sync_mtu(dev, info_ext->ext.mtu);\n\t\trt_cache_flush(dev_net(dev));\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block nh_netdev_notifier = {\n\t.notifier_call = nh_netdev_event,\n};\n\nstatic int nexthops_dump(struct net *net, struct notifier_block *nb,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct rb_root *root = &net->nexthop.rb_root;\n\tstruct rb_node *node;\n\tint err = 0;\n\n\tfor (node = rb_first(root); node; node = rb_next(node)) {\n\t\tstruct nexthop *nh;\n\n\t\tnh = rb_entry(node, struct nexthop, rb_node);\n\t\terr = call_nexthop_notifier(nb, net, NEXTHOP_EVENT_REPLACE, nh,\n\t\t\t\t\t    extack);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint register_nexthop_notifier(struct net *net, struct notifier_block *nb,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = nexthops_dump(net, nb, extack);\n\tif (err)\n\t\tgoto unlock;\n\terr = blocking_notifier_chain_register(&net->nexthop.notifier_chain,\n\t\t\t\t\t       nb);\nunlock:\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(register_nexthop_notifier);\n\nint unregister_nexthop_notifier(struct net *net, struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&net->nexthop.notifier_chain,\n\t\t\t\t\t\t  nb);\n}\nEXPORT_SYMBOL(unregister_nexthop_notifier);\n\nvoid nexthop_set_hw_flags(struct net *net, u32 id, bool offload, bool trap)\n{\n\tstruct nexthop *nexthop;\n\n\trcu_read_lock();\n\n\tnexthop = nexthop_find_by_id(net, id);\n\tif (!nexthop)\n\t\tgoto out;\n\n\tnexthop->nh_flags &= ~(RTNH_F_OFFLOAD | RTNH_F_TRAP);\n\tif (offload)\n\t\tnexthop->nh_flags |= RTNH_F_OFFLOAD;\n\tif (trap)\n\t\tnexthop->nh_flags |= RTNH_F_TRAP;\n\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(nexthop_set_hw_flags);\n\nvoid nexthop_bucket_set_hw_flags(struct net *net, u32 id, u16 bucket_index,\n\t\t\t\t bool offload, bool trap)\n{\n\tstruct nh_res_table *res_table;\n\tstruct nh_res_bucket *bucket;\n\tstruct nexthop *nexthop;\n\tstruct nh_group *nhg;\n\n\trcu_read_lock();\n\n\tnexthop = nexthop_find_by_id(net, id);\n\tif (!nexthop || !nexthop->is_group)\n\t\tgoto out;\n\n\tnhg = rcu_dereference(nexthop->nh_grp);\n\tif (!nhg->resilient)\n\t\tgoto out;\n\n\tif (bucket_index >= nhg->res_table->num_nh_buckets)\n\t\tgoto out;\n\n\tres_table = rcu_dereference(nhg->res_table);\n\tbucket = &res_table->nh_buckets[bucket_index];\n\tbucket->nh_flags &= ~(RTNH_F_OFFLOAD | RTNH_F_TRAP);\n\tif (offload)\n\t\tbucket->nh_flags |= RTNH_F_OFFLOAD;\n\tif (trap)\n\t\tbucket->nh_flags |= RTNH_F_TRAP;\n\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(nexthop_bucket_set_hw_flags);\n\nvoid nexthop_res_grp_activity_update(struct net *net, u32 id, u16 num_buckets,\n\t\t\t\t     unsigned long *activity)\n{\n\tstruct nh_res_table *res_table;\n\tstruct nexthop *nexthop;\n\tstruct nh_group *nhg;\n\tu16 i;\n\n\trcu_read_lock();\n\n\tnexthop = nexthop_find_by_id(net, id);\n\tif (!nexthop || !nexthop->is_group)\n\t\tgoto out;\n\n\tnhg = rcu_dereference(nexthop->nh_grp);\n\tif (!nhg->resilient)\n\t\tgoto out;\n\n\t/* Instead of silently ignoring some buckets, demand that the sizes\n\t * be the same.\n\t */\n\tres_table = rcu_dereference(nhg->res_table);\n\tif (num_buckets != res_table->num_nh_buckets)\n\t\tgoto out;\n\n\tfor (i = 0; i < num_buckets; i++) {\n\t\tif (test_bit(i, activity))\n\t\t\tnh_res_bucket_set_busy(&res_table->nh_buckets[i]);\n\t}\n\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(nexthop_res_grp_activity_update);\n\nstatic void __net_exit nexthop_net_exit(struct net *net)\n{\n\trtnl_lock();\n\tflush_all_nexthops(net);\n\trtnl_unlock();\n\tkfree(net->nexthop.devhash);\n}\n\nstatic int __net_init nexthop_net_init(struct net *net)\n{\n\tsize_t sz = sizeof(struct hlist_head) * NH_DEV_HASHSIZE;\n\n\tnet->nexthop.rb_root = RB_ROOT;\n\tnet->nexthop.devhash = kzalloc(sz, GFP_KERNEL);\n\tif (!net->nexthop.devhash)\n\t\treturn -ENOMEM;\n\tBLOCKING_INIT_NOTIFIER_HEAD(&net->nexthop.notifier_chain);\n\n\treturn 0;\n}\n\nstatic struct pernet_operations nexthop_net_ops = {\n\t.init = nexthop_net_init,\n\t.exit = nexthop_net_exit,\n};\n\nstatic int __init nexthop_init(void)\n{\n\tregister_pernet_subsys(&nexthop_net_ops);\n\n\tregister_netdevice_notifier(&nh_netdev_notifier);\n\n\trtnl_register(PF_UNSPEC, RTM_NEWNEXTHOP, rtm_new_nexthop, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_DELNEXTHOP, rtm_del_nexthop, NULL, 0);\n\trtnl_register(PF_UNSPEC, RTM_GETNEXTHOP, rtm_get_nexthop,\n\t\t      rtm_dump_nexthop, 0);\n\n\trtnl_register(PF_INET, RTM_NEWNEXTHOP, rtm_new_nexthop, NULL, 0);\n\trtnl_register(PF_INET, RTM_GETNEXTHOP, NULL, rtm_dump_nexthop, 0);\n\n\trtnl_register(PF_INET6, RTM_NEWNEXTHOP, rtm_new_nexthop, NULL, 0);\n\trtnl_register(PF_INET6, RTM_GETNEXTHOP, NULL, rtm_dump_nexthop, 0);\n\n\trtnl_register(PF_UNSPEC, RTM_GETNEXTHOPBUCKET, rtm_get_nexthop_bucket,\n\t\t      rtm_dump_nexthop_bucket, 0);\n\n\treturn 0;\n}\nsubsys_initcall(nexthop_init);\n"}, "2": {"id": 2, "path": "/src/include/linux/rtnetlink.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_RTNETLINK_H\n#define __LINUX_RTNETLINK_H\n\n\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/wait.h>\n#include <linux/refcount.h>\n#include <uapi/linux/rtnetlink.h>\n\nextern int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, u32 group, int echo);\nextern int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid);\nextern void rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid,\n\t\t\tu32 group, struct nlmsghdr *nlh, gfp_t flags);\nextern void rtnl_set_sk_err(struct net *net, u32 group, int error);\nextern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);\nextern int rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst,\n\t\t\t      u32 id, long expires, u32 error);\n\nvoid rtmsg_ifinfo(int type, struct net_device *dev, unsigned change, gfp_t flags);\nvoid rtmsg_ifinfo_newnet(int type, struct net_device *dev, unsigned int change,\n\t\t\t gfp_t flags, int *new_nsid, int new_ifindex);\nstruct sk_buff *rtmsg_ifinfo_build_skb(int type, struct net_device *dev,\n\t\t\t\t       unsigned change, u32 event,\n\t\t\t\t       gfp_t flags, int *new_nsid,\n\t\t\t\t       int new_ifindex);\nvoid rtmsg_ifinfo_send(struct sk_buff *skb, struct net_device *dev,\n\t\t       gfp_t flags);\n\n\n/* RTNL is used as a global lock for all changes to network configuration  */\nextern void rtnl_lock(void);\nextern void rtnl_unlock(void);\nextern int rtnl_trylock(void);\nextern int rtnl_is_locked(void);\nextern int rtnl_lock_killable(void);\nextern bool refcount_dec_and_rtnl_lock(refcount_t *r);\n\nextern wait_queue_head_t netdev_unregistering_wq;\nextern struct rw_semaphore pernet_ops_rwsem;\nextern struct rw_semaphore net_rwsem;\n\n#ifdef CONFIG_PROVE_LOCKING\nextern bool lockdep_rtnl_is_held(void);\n#else\nstatic inline bool lockdep_rtnl_is_held(void)\n{\n\treturn true;\n}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n\n/**\n * rcu_dereference_rtnl - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n *\n * Do an rcu_dereference(p), but check caller either holds rcu_read_lock()\n * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference()\n */\n#define rcu_dereference_rtnl(p)\t\t\t\t\t\\\n\trcu_dereference_check(p, lockdep_rtnl_is_held())\n\n/**\n * rcu_dereference_bh_rtnl - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereference\n *\n * Do an rcu_dereference_bh(p), but check caller either holds rcu_read_lock_bh()\n * or RTNL. Note : Please prefer rtnl_dereference() or rcu_dereference_bh()\n */\n#define rcu_dereference_bh_rtnl(p)\t\t\t\t\\\n\trcu_dereference_bh_check(p, lockdep_rtnl_is_held())\n\n/**\n * rtnl_dereference - fetch RCU pointer when updates are prevented by RTNL\n * @p: The pointer to read, prior to dereferencing\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE(), because caller holds RTNL.\n */\n#define rtnl_dereference(p)\t\t\t\t\t\\\n\trcu_dereference_protected(p, lockdep_rtnl_is_held())\n\nstatic inline struct netdev_queue *dev_ingress_queue(struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->ingress_queue);\n}\n\nstatic inline struct netdev_queue *dev_ingress_queue_rcu(struct net_device *dev)\n{\n\treturn rcu_dereference(dev->ingress_queue);\n}\n\nstruct netdev_queue *dev_ingress_queue_create(struct net_device *dev);\n\n#ifdef CONFIG_NET_INGRESS\nvoid net_inc_ingress_queue(void);\nvoid net_dec_ingress_queue(void);\n#endif\n\n#ifdef CONFIG_NET_EGRESS\nvoid net_inc_egress_queue(void);\nvoid net_dec_egress_queue(void);\n#endif\n\nvoid rtnetlink_init(void);\nvoid __rtnl_unlock(void);\nvoid rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail);\n\n#define ASSERT_RTNL() \\\n\tWARN_ONCE(!rtnl_is_locked(), \\\n\t\t  \"RTNL: assertion failed at %s (%d)\\n\", __FILE__,  __LINE__)\n\nextern int ndo_dflt_fdb_dump(struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     struct net_device *dev,\n\t\t\t     struct net_device *filter_dev,\n\t\t\t     int *idx);\nextern int ndo_dflt_fdb_add(struct ndmsg *ndm,\n\t\t\t    struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid,\n\t\t\t    u16 flags);\nextern int ndo_dflt_fdb_del(struct ndmsg *ndm,\n\t\t\t    struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid);\n\nextern int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t   struct net_device *dev, u16 mode,\n\t\t\t\t   u32 flags, u32 mask, int nlflags,\n\t\t\t\t   u32 filter_mask,\n\t\t\t\t   int (*vlan_fill)(struct sk_buff *skb,\n\t\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t\t    u32 filter_mask));\n#endif\t/* __LINUX_RTNETLINK_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/rcupdate.h", "content": "/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Read-Copy Update mechanism for mutual exclusion\n *\n * Copyright IBM Corporation, 2001\n *\n * Author: Dipankar Sarma <dipankar@in.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@vnet.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n * Papers:\n * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf\n * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\t\thttp://lse.sourceforge.net/locking/rcupdate.html\n *\n */\n\n#ifndef __LINUX_RCUPDATE_H\n#define __LINUX_RCUPDATE_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/processor.h>\n#include <linux/cpumask.h>\n\n#define ULONG_CMP_GE(a, b)\t(ULONG_MAX / 2 >= (a) - (b))\n#define ULONG_CMP_LT(a, b)\t(ULONG_MAX / 2 < (a) - (b))\n#define ulong2long(a)\t\t(*(long *)(&(a)))\n#define USHORT_CMP_GE(a, b)\t(USHRT_MAX / 2 >= (unsigned short)((a) - (b)))\n#define USHORT_CMP_LT(a, b)\t(USHRT_MAX / 2 < (unsigned short)((a) - (b)))\n\n/* Exported common interfaces */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func);\nvoid rcu_barrier_tasks(void);\nvoid rcu_barrier_tasks_rude(void);\nvoid synchronize_rcu(void);\n\n#ifdef CONFIG_PREEMPT_RCU\n\nvoid __rcu_read_lock(void);\nvoid __rcu_read_unlock(void);\n\n/*\n * Defined as a macro as it is a very low level header included from\n * areas that don't even know about current.  This gives the rcu_read_lock()\n * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other\n * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.\n */\n#define rcu_preempt_depth() (current->rcu_read_lock_nesting)\n\n#else /* #ifdef CONFIG_PREEMPT_RCU */\n\n#ifdef CONFIG_TINY_RCU\n#define rcu_read_unlock_strict() do { } while (0)\n#else\nvoid rcu_read_unlock_strict(void);\n#endif\n\nstatic inline void __rcu_read_lock(void)\n{\n\tpreempt_disable();\n}\n\nstatic inline void __rcu_read_unlock(void)\n{\n\tpreempt_enable();\n\trcu_read_unlock_strict();\n}\n\nstatic inline int rcu_preempt_depth(void)\n{\n\treturn 0;\n}\n\n#endif /* #else #ifdef CONFIG_PREEMPT_RCU */\n\n/* Internal to kernel */\nvoid rcu_init(void);\nextern int rcu_scheduler_active __read_mostly;\nvoid rcu_sched_clock_irq(int user);\nvoid rcu_report_dead(unsigned int cpu);\nvoid rcutree_migrate_callbacks(int cpu);\n\n#ifdef CONFIG_TASKS_RCU_GENERIC\nvoid rcu_init_tasks_generic(void);\n#else\nstatic inline void rcu_init_tasks_generic(void) { }\n#endif\n\n#ifdef CONFIG_RCU_STALL_COMMON\nvoid rcu_sysrq_start(void);\nvoid rcu_sysrq_end(void);\n#else /* #ifdef CONFIG_RCU_STALL_COMMON */\nstatic inline void rcu_sysrq_start(void) { }\nstatic inline void rcu_sysrq_end(void) { }\n#endif /* #else #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nvoid rcu_user_enter(void);\nvoid rcu_user_exit(void);\n#else\nstatic inline void rcu_user_enter(void) { }\nstatic inline void rcu_user_exit(void) { }\n#endif /* CONFIG_NO_HZ_FULL */\n\n#ifdef CONFIG_RCU_NOCB_CPU\nvoid rcu_init_nohz(void);\nint rcu_nocb_cpu_offload(int cpu);\nint rcu_nocb_cpu_deoffload(int cpu);\nvoid rcu_nocb_flush_deferred_wakeup(void);\n#else /* #ifdef CONFIG_RCU_NOCB_CPU */\nstatic inline void rcu_init_nohz(void) { }\nstatic inline int rcu_nocb_cpu_offload(int cpu) { return -EINVAL; }\nstatic inline int rcu_nocb_cpu_deoffload(int cpu) { return 0; }\nstatic inline void rcu_nocb_flush_deferred_wakeup(void) { }\n#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */\n\n/**\n * RCU_NONIDLE - Indicate idle-loop code that needs RCU readers\n * @a: Code that RCU needs to pay attention to.\n *\n * RCU read-side critical sections are forbidden in the inner idle loop,\n * that is, between the rcu_idle_enter() and the rcu_idle_exit() -- RCU\n * will happily ignore any such read-side critical sections.  However,\n * things like powertop need tracepoints in the inner idle loop.\n *\n * This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())\n * will tell RCU that it needs to pay attention, invoke its argument\n * (in this example, calling the do_something_with_RCU() function),\n * and then tell RCU to go back to ignoring this CPU.  It is permissible\n * to nest RCU_NONIDLE() wrappers, but not indefinitely (but the limit is\n * on the order of a million or so, even on 32-bit systems).  It is\n * not legal to block within RCU_NONIDLE(), nor is it permissible to\n * transfer control either into or out of RCU_NONIDLE()'s statement.\n */\n#define RCU_NONIDLE(a) \\\n\tdo { \\\n\t\trcu_irq_enter_irqson(); \\\n\t\tdo { a; } while (0); \\\n\t\trcu_irq_exit_irqson(); \\\n\t} while (0)\n\n/*\n * Note a quasi-voluntary context switch for RCU-tasks's benefit.\n * This is a macro rather than an inline function to avoid #include hell.\n */\n#ifdef CONFIG_TASKS_RCU_GENERIC\n\n# ifdef CONFIG_TASKS_RCU\n# define rcu_tasks_classic_qs(t, preempt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(preempt) && READ_ONCE((t)->rcu_tasks_holdout))\t\\\n\t\t\tWRITE_ONCE((t)->rcu_tasks_holdout, false);\t\\\n\t} while (0)\nvoid call_rcu_tasks(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks(void);\n# else\n# define rcu_tasks_classic_qs(t, preempt) do { } while (0)\n# define call_rcu_tasks call_rcu\n# define synchronize_rcu_tasks synchronize_rcu\n# endif\n\n# ifdef CONFIG_TASKS_RCU_TRACE\n# define rcu_tasks_trace_qs(t)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!likely(READ_ONCE((t)->trc_reader_checked)) &&\t\\\n\t\t    !unlikely(READ_ONCE((t)->trc_reader_nesting))) {\t\\\n\t\t\tsmp_store_release(&(t)->trc_reader_checked, true); \\\n\t\t\tsmp_mb(); /* Readers partitioned by store. */\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n# else\n# define rcu_tasks_trace_qs(t) do { } while (0)\n# endif\n\n#define rcu_tasks_qs(t, preempt)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_tasks_classic_qs((t), (preempt));\t\t\t\t\\\n\trcu_tasks_trace_qs((t));\t\t\t\t\t\\\n} while (0)\n\n# ifdef CONFIG_TASKS_RUDE_RCU\nvoid call_rcu_tasks_rude(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks_rude(void);\n# endif\n\n#define rcu_note_voluntary_context_switch(t) rcu_tasks_qs(t, false)\nvoid exit_tasks_rcu_start(void);\nvoid exit_tasks_rcu_finish(void);\n#else /* #ifdef CONFIG_TASKS_RCU_GENERIC */\n#define rcu_tasks_qs(t, preempt) do { } while (0)\n#define rcu_note_voluntary_context_switch(t) do { } while (0)\n#define call_rcu_tasks call_rcu\n#define synchronize_rcu_tasks synchronize_rcu\nstatic inline void exit_tasks_rcu_start(void) { }\nstatic inline void exit_tasks_rcu_finish(void) { }\n#endif /* #else #ifdef CONFIG_TASKS_RCU_GENERIC */\n\n/**\n * cond_resched_tasks_rcu_qs - Report potential quiescent states to RCU\n *\n * This macro resembles cond_resched(), except that it is defined to\n * report potential quiescent states to RCU-tasks even if the cond_resched()\n * machinery were to be shut off, as some advocate for PREEMPTION kernels.\n */\n#define cond_resched_tasks_rcu_qs() \\\ndo { \\\n\trcu_tasks_qs(current, false); \\\n\tcond_resched(); \\\n} while (0)\n\n/*\n * Infrastructure to implement the synchronize_() primitives in\n * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.\n */\n\n#if defined(CONFIG_TREE_RCU)\n#include <linux/rcutree.h>\n#elif defined(CONFIG_TINY_RCU)\n#include <linux/rcutiny.h>\n#else\n#error \"Unknown RCU implementation specified to kernel configuration\"\n#endif\n\n/*\n * The init_rcu_head_on_stack() and destroy_rcu_head_on_stack() calls\n * are needed for dynamic initialization and destruction of rcu_head\n * on the stack, and init_rcu_head()/destroy_rcu_head() are needed for\n * dynamic initialization and destruction of statically allocated rcu_head\n * structures.  However, rcu_head structures allocated dynamically in the\n * heap don't need any initialization.\n */\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\nvoid init_rcu_head(struct rcu_head *head);\nvoid destroy_rcu_head(struct rcu_head *head);\nvoid init_rcu_head_on_stack(struct rcu_head *head);\nvoid destroy_rcu_head_on_stack(struct rcu_head *head);\n#else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\nstatic inline void init_rcu_head(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head(struct rcu_head *head) { }\nstatic inline void init_rcu_head_on_stack(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head_on_stack(struct rcu_head *head) { }\n#endif\t/* #else !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\n#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU)\nbool rcu_lockdep_current_cpu_online(void);\n#else /* #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\nstatic inline bool rcu_lockdep_current_cpu_online(void) { return true; }\n#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\n\nextern struct lockdep_map rcu_lock_map;\nextern struct lockdep_map rcu_bh_lock_map;\nextern struct lockdep_map rcu_sched_lock_map;\nextern struct lockdep_map rcu_callback_map;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nstatic inline void rcu_lock_acquire(struct lockdep_map *map)\n{\n\tlock_acquire(map, 0, 0, 2, 0, NULL, _THIS_IP_);\n}\n\nstatic inline void rcu_lock_release(struct lockdep_map *map)\n{\n\tlock_release(map, _THIS_IP_);\n}\n\nint debug_lockdep_rcu_enabled(void);\nint rcu_read_lock_held(void);\nint rcu_read_lock_bh_held(void);\nint rcu_read_lock_sched_held(void);\nint rcu_read_lock_any_held(void);\n\n#else /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n# define rcu_lock_acquire(a)\t\tdo { } while (0)\n# define rcu_lock_release(a)\t\tdo { } while (0)\n\nstatic inline int rcu_read_lock_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_bh_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_sched_held(void)\n{\n\treturn !preemptible();\n}\n\nstatic inline int rcu_read_lock_any_held(void)\n{\n\treturn !preemptible();\n}\n\n#endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n#ifdef CONFIG_PROVE_RCU\n\n/**\n * RCU_LOCKDEP_WARN - emit lockdep splat if specified condition is met\n * @c: condition to check\n * @s: informative message\n */\n#define RCU_LOCKDEP_WARN(c, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic bool __section(\".data.unlikely\") __warned;\t\\\n\t\tif ((c) && debug_lockdep_rcu_enabled() && !__warned) {\t\\\n\t\t\t__warned = true;\t\t\t\t\\\n\t\t\tlockdep_rcu_suspicious(__FILE__, __LINE__, s);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#if defined(CONFIG_PROVE_RCU) && !defined(CONFIG_PREEMPT_RCU)\nstatic inline void rcu_preempt_sleep_check(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_lock_map),\n\t\t\t \"Illegal context switch in RCU read-side critical section\");\n}\n#else /* #ifdef CONFIG_PROVE_RCU */\nstatic inline void rcu_preempt_sleep_check(void) { }\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n#define rcu_sleep_check()\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trcu_preempt_sleep_check();\t\t\t\t\\\n\t\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\t\t\t\\\n\t\t    RCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-bh read-side critical section\"); \\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-sched read-side critical section\"); \\\n\t} while (0)\n\n#else /* #ifdef CONFIG_PROVE_RCU */\n\n#define RCU_LOCKDEP_WARN(c, s) do { } while (0 && (c))\n#define rcu_sleep_check() do { } while (0)\n\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Helper functions for rcu_dereference_check(), rcu_dereference_protected()\n * and rcu_assign_pointer().  Some of these could be folded into their\n * callers, but they are left separate in order to ease introduction of\n * multiple pointers markings to match different RCU implementations\n * (e.g., __srcu), should this make sense in the future.\n */\n\n#ifdef __CHECKER__\n#define rcu_check_sparse(p, space) \\\n\t((void)(((typeof(*p) space *)p) == p))\n#else /* #ifdef __CHECKER__ */\n#define rcu_check_sparse(p, space)\n#endif /* #else #ifdef __CHECKER__ */\n\n#define __rcu_access_pointer(p, space) \\\n({ \\\n\ttypeof(*p) *_________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(_________p1)); \\\n})\n#define __rcu_dereference_check(p, c, space) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(*p) *________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_check() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n#define __rcu_dereference_protected(p, c, space) \\\n({ \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_protected() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(p)); \\\n})\n#define rcu_dereference_raw(p) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(p) ________p1 = READ_ONCE(p); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n\n/**\n * RCU_INITIALIZER() - statically initialize an RCU-protected global variable\n * @v: The value to statically initialize with.\n */\n#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)\n\n/**\n * rcu_assign_pointer() - assign to RCU-protected pointer\n * @p: pointer to assign to\n * @v: value to assign (publish)\n *\n * Assigns the specified value to the specified RCU-protected\n * pointer, ensuring that any concurrent RCU readers will see\n * any prior initialization.\n *\n * Inserts memory barriers on architectures that require them\n * (which is most of them), and also prevents the compiler from\n * reordering the code that initializes the structure after the pointer\n * assignment.  More importantly, this call documents which pointers\n * will be dereferenced by RCU read-side code.\n *\n * In some special cases, you may use RCU_INIT_POINTER() instead\n * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due\n * to the fact that it does not constrain either the CPU or the compiler.\n * That said, using RCU_INIT_POINTER() when you should have used\n * rcu_assign_pointer() is a very bad thing that results in\n * impossible-to-diagnose memory corruption.  So please be careful.\n * See the RCU_INIT_POINTER() comment header for details.\n *\n * Note that rcu_assign_pointer() evaluates each of its arguments only\n * once, appearances notwithstanding.  One of the \"extra\" evaluations\n * is in typeof() and the other visible only to sparse (__CHECKER__),\n * neither of which actually execute the argument.  As with most cpp\n * macros, this execute-arguments-only-once property is important, so\n * please be careful when making changes to rcu_assign_pointer() and the\n * other macros that it invokes.\n */\n#define rcu_assign_pointer(p, v)\t\t\t\t\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tuintptr_t _r_a_p__v = (uintptr_t)(v);\t\t\t\t      \\\n\trcu_check_sparse(p, __rcu);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)\t      \\\n\t\tWRITE_ONCE((p), (typeof(p))(_r_a_p__v));\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t\tsmp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \\\n} while (0)\n\n/**\n * rcu_replace_pointer() - replace an RCU pointer, returning its old value\n * @rcu_ptr: RCU pointer, whose old value is returned\n * @ptr: regular pointer\n * @c: the lockdep conditions under which the dereference will take place\n *\n * Perform a replacement, where @rcu_ptr is an RCU-annotated\n * pointer and @c is the lockdep argument that is passed to the\n * rcu_dereference_protected() call used to read that pointer.  The old\n * value of @rcu_ptr is returned, and @rcu_ptr is set to @ptr.\n */\n#define rcu_replace_pointer(rcu_ptr, ptr, c)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c));\t\\\n\trcu_assign_pointer((rcu_ptr), (ptr));\t\t\t\t\\\n\t__tmp;\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * rcu_access_pointer() - fetch RCU pointer with no dereferencing\n * @p: The pointer to read\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * lockdep checks for being in an RCU read-side critical section.  This is\n * useful when the value of this pointer is accessed, but the pointer is\n * not dereferenced, for example, when testing an RCU-protected pointer\n * against NULL.  Although rcu_access_pointer() may also be used in cases\n * where update-side locks prevent the value of the pointer from changing,\n * you should instead use rcu_dereference_protected() for this use case.\n *\n * It is also permissible to use rcu_access_pointer() when read-side\n * access to the pointer was removed at least one grace period ago, as\n * is the case in the context of the RCU callback that is freeing up\n * the data, or after a synchronize_rcu() returns.  This can be useful\n * when tearing down multi-linked structures after a grace period\n * has elapsed.\n */\n#define rcu_access_pointer(p) __rcu_access_pointer((p), __rcu)\n\n/**\n * rcu_dereference_check() - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Do an rcu_dereference(), but check that the conditions under which the\n * dereference will take place are correct.  Typically the conditions\n * indicate the various locking conditions that should be held at that\n * point.  The check should return true if the conditions are satisfied.\n * An implicit check for being in an RCU read-side critical section\n * (rcu_read_lock()) is included.\n *\n * For example:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock));\n *\n * could be used to indicate to lockdep that foo->bar may only be dereferenced\n * if either rcu_read_lock() is held, or that the lock required to replace\n * the bar struct at foo->bar is held.\n *\n * Note that the list of conditions may also include indications of when a lock\n * need not be held, for example during initialisation or destruction of the\n * target struct:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock) ||\n *\t\t\t\t\t      atomic_read(&foo->usage) == 0);\n *\n * Inserts memory barriers on architectures that require them\n * (currently only the Alpha), prevents the compiler from refetching\n * (and from merging fetches), and, more importantly, documents exactly\n * which pointers are protected by RCU and checks that the pointer is\n * annotated as __rcu.\n */\n#define rcu_dereference_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_held(), __rcu)\n\n/**\n * rcu_dereference_bh_check() - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-bh counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_bh_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_bh_held(), __rcu)\n\n/**\n * rcu_dereference_sched_check() - rcu_dereference_sched with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-sched counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_sched_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_sched_held(), \\\n\t\t\t\t__rcu)\n\n/*\n * The tracing infrastructure traces RCU (we want that), but unfortunately\n * some of the RCU checks causes tracing to lock up the system.\n *\n * The no-tracing version of rcu_dereference_raw() must not call\n * rcu_read_lock_held().\n */\n#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), 1, __rcu)\n\n/**\n * rcu_dereference_protected() - fetch RCU pointer when updates prevented\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE().  This is useful in cases where update-side locks\n * prevent the value of the pointer from changing.  Please note that this\n * primitive does *not* prevent the compiler from repeating this reference\n * or combining it with other references, so it should not be used without\n * protection of appropriate locks.\n *\n * This function is only for update-side use.  Using this function\n * when protected only by rcu_read_lock() will result in infrequent\n * but very ugly failures.\n */\n#define rcu_dereference_protected(p, c) \\\n\t__rcu_dereference_protected((p), (c), __rcu)\n\n\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n\n/**\n * rcu_dereference_bh() - fetch an RCU-bh-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)\n\n/**\n * rcu_dereference_sched() - fetch RCU-sched-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)\n\n/**\n * rcu_pointer_handoff() - Hand off a pointer from RCU to other mechanism\n * @p: The pointer to hand off\n *\n * This is simply an identity function, but it documents where a pointer\n * is handed off from RCU to some other synchronization mechanism, for\n * example, reference counting or locking.  In C11, it would map to\n * kill_dependency().  It could be used as follows::\n *\n *\trcu_read_lock();\n *\tp = rcu_dereference(gp);\n *\tlong_lived = is_long_lived(p);\n *\tif (long_lived) {\n *\t\tif (!atomic_inc_not_zero(p->refcnt))\n *\t\t\tlong_lived = false;\n *\t\telse\n *\t\t\tp = rcu_pointer_handoff(p);\n *\t}\n *\trcu_read_unlock();\n */\n#define rcu_pointer_handoff(p) (p)\n\n/**\n * rcu_read_lock() - mark the beginning of an RCU read-side critical section\n *\n * When synchronize_rcu() is invoked on one CPU while other CPUs\n * are within RCU read-side critical sections, then the\n * synchronize_rcu() is guaranteed to block until after all the other\n * CPUs exit their critical sections.  Similarly, if call_rcu() is invoked\n * on one CPU while other CPUs are within RCU read-side critical\n * sections, invocation of the corresponding RCU callback is deferred\n * until after the all the other CPUs exit their critical sections.\n *\n * Note, however, that RCU callbacks are permitted to run concurrently\n * with new RCU read-side critical sections.  One way that this can happen\n * is via the following sequence of events: (1) CPU 0 enters an RCU\n * read-side critical section, (2) CPU 1 invokes call_rcu() to register\n * an RCU callback, (3) CPU 0 exits the RCU read-side critical section,\n * (4) CPU 2 enters a RCU read-side critical section, (5) the RCU\n * callback is invoked.  This is legal, because the RCU read-side critical\n * section that was running concurrently with the call_rcu() (and which\n * therefore might be referencing something that the corresponding RCU\n * callback would free up) has completed before the corresponding\n * RCU callback is invoked.\n *\n * RCU read-side critical sections may be nested.  Any deferred actions\n * will be deferred until the outermost RCU read-side critical section\n * completes.\n *\n * You can avoid reading and understanding the next paragraph by\n * following this rule: don't put anything in an rcu_read_lock() RCU\n * read-side critical section that would block in a !PREEMPTION kernel.\n * But if you want the full story, read on!\n *\n * In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),\n * it is illegal to block while in an RCU read-side critical section.\n * In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION\n * kernel builds, RCU read-side critical sections may be preempted,\n * but explicit blocking is illegal.  Finally, in preemptible RCU\n * implementations in real-time (with -rt patchset) kernel builds, RCU\n * read-side critical sections may be preempted and they may also block, but\n * only when acquiring spinlocks that are subject to priority inheritance.\n */\nstatic __always_inline void rcu_read_lock(void)\n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_lock_acquire(&rcu_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock() used illegally while idle\");\n}\n\n/*\n * So where is rcu_write_lock()?  It does not exist, as there is no\n * way for writers to lock out RCU readers.  This is a feature, not\n * a bug -- this property is what provides RCU's performance benefits.\n * Of course, writers must coordinate with each other.  The normal\n * spinlock primitives work well for this, but any other technique may be\n * used as well.  RCU does not care how the writers keep out of each\n * others' way, as long as they do so.\n */\n\n/**\n * rcu_read_unlock() - marks the end of an RCU read-side critical section.\n *\n * In most situations, rcu_read_unlock() is immune from deadlock.\n * However, in kernels built with CONFIG_RCU_BOOST, rcu_read_unlock()\n * is responsible for deboosting, which it does via rt_mutex_unlock().\n * Unfortunately, this function acquires the scheduler's runqueue and\n * priority-inheritance spinlocks.  This means that deadlock could result\n * if the caller of rcu_read_unlock() already holds one of these locks or\n * any lock that is ever acquired while holding them.\n *\n * That said, RCU readers are never priority boosted unless they were\n * preempted.  Therefore, one way to avoid deadlock is to make sure\n * that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with one of\n * rt_mutex_unlock()'s locks held.  Such preemption can be avoided in\n * a number of ways, for example, by invoking preempt_disable() before\n * critical section's outermost rcu_read_lock().\n *\n * Given that the set of locks acquired by rt_mutex_unlock() might change\n * at any time, a somewhat more future-proofed approach is to make sure\n * that that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with irqs disabled.\n * This approach relies on the fact that rt_mutex_unlock() currently only\n * acquires irq-disabled locks.\n *\n * The second of these two approaches is best in most situations,\n * however, the first approach can also be useful, at least to those\n * developers willing to keep abreast of the set of locks acquired by\n * rt_mutex_unlock().\n *\n * See rcu_read_lock() for more information.\n */\nstatic inline void rcu_read_unlock(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock() used illegally while idle\");\n\t__release(RCU);\n\t__rcu_read_unlock();\n\trcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */\n}\n\n/**\n * rcu_read_lock_bh() - mark the beginning of an RCU-bh critical section\n *\n * This is equivalent of rcu_read_lock(), but also disables softirqs.\n * Note that anything else that disables softirqs can also serve as\n * an RCU read-side critical section.\n *\n * Note that rcu_read_lock_bh() and the matching rcu_read_unlock_bh()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_bh() from one task if the matching rcu_read_lock_bh()\n * was invoked from some other task.\n */\nstatic inline void rcu_read_lock_bh(void)\n{\n\tlocal_bh_disable();\n\t__acquire(RCU_BH);\n\trcu_lock_acquire(&rcu_bh_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_bh() used illegally while idle\");\n}\n\n/**\n * rcu_read_unlock_bh() - marks the end of a softirq-only RCU critical section\n *\n * See rcu_read_lock_bh() for more information.\n */\nstatic inline void rcu_read_unlock_bh(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_bh() used illegally while idle\");\n\trcu_lock_release(&rcu_bh_lock_map);\n\t__release(RCU_BH);\n\tlocal_bh_enable();\n}\n\n/**\n * rcu_read_lock_sched() - mark the beginning of a RCU-sched critical section\n *\n * This is equivalent of rcu_read_lock(), but disables preemption.\n * Read-side critical sections can also be introduced by anything else\n * that disables preemption, including local_irq_disable() and friends.\n *\n * Note that rcu_read_lock_sched() and the matching rcu_read_unlock_sched()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_sched() from process context if the matching\n * rcu_read_lock_sched() was invoked from an NMI handler.\n */\nstatic inline void rcu_read_lock_sched(void)\n{\n\tpreempt_disable();\n\t__acquire(RCU_SCHED);\n\trcu_lock_acquire(&rcu_sched_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_sched() used illegally while idle\");\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_lock_sched_notrace(void)\n{\n\tpreempt_disable_notrace();\n\t__acquire(RCU_SCHED);\n}\n\n/**\n * rcu_read_unlock_sched() - marks the end of a RCU-classic critical section\n *\n * See rcu_read_lock_sched() for more information.\n */\nstatic inline void rcu_read_unlock_sched(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_sched() used illegally while idle\");\n\trcu_lock_release(&rcu_sched_lock_map);\n\t__release(RCU_SCHED);\n\tpreempt_enable();\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_unlock_sched_notrace(void)\n{\n\t__release(RCU_SCHED);\n\tpreempt_enable_notrace();\n}\n\n/**\n * RCU_INIT_POINTER() - initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * Initialize an RCU-protected pointer in special cases where readers\n * do not need ordering constraints on the CPU or the compiler.  These\n * special cases are:\n *\n * 1.\tThis use of RCU_INIT_POINTER() is NULLing out the pointer *or*\n * 2.\tThe caller has taken whatever steps are required to prevent\n *\tRCU readers from concurrently accessing this pointer *or*\n * 3.\tThe referenced data structure has already been exposed to\n *\treaders either at compile time or via rcu_assign_pointer() *and*\n *\n *\ta.\tYou have not made *any* reader-visible changes to\n *\t\tthis structure since then *or*\n *\tb.\tIt is OK for readers accessing this structure from its\n *\t\tnew location to see the old state of the structure.  (For\n *\t\texample, the changes were to statistical counters or to\n *\t\tother state where exact synchronization is not required.)\n *\n * Failure to follow these rules governing use of RCU_INIT_POINTER() will\n * result in impossible-to-diagnose memory corruption.  As in the structures\n * will look OK in crash dumps, but any concurrent RCU readers might\n * see pre-initialized values of the referenced data structure.  So\n * please be very careful how you use RCU_INIT_POINTER()!!!\n *\n * If you are creating an RCU-protected linked structure that is accessed\n * by a single external-to-structure RCU-protected pointer, then you may\n * use RCU_INIT_POINTER() to initialize the internal RCU-protected\n * pointers, but you must use rcu_assign_pointer() to initialize the\n * external-to-structure pointer *after* you have completely initialized\n * the reader-accessible portions of the linked structure.\n *\n * Note that unlike rcu_assign_pointer(), RCU_INIT_POINTER() provides no\n * ordering guarantees for either the CPU or the compiler.\n */\n#define RCU_INIT_POINTER(p, v) \\\n\tdo { \\\n\t\trcu_check_sparse(p, __rcu); \\\n\t\tWRITE_ONCE(p, RCU_INITIALIZER(v)); \\\n\t} while (0)\n\n/**\n * RCU_POINTER_INITIALIZER() - statically initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * GCC-style initialization for an RCU-protected pointer in a structure field.\n */\n#define RCU_POINTER_INITIALIZER(p, v) \\\n\t\t.p = RCU_INITIALIZER(v)\n\n/*\n * Does the specified offset indicate that the corresponding rcu_head\n * structure can be handled by kvfree_rcu()?\n */\n#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)\n\n/**\n * kfree_rcu() - kfree an object after a grace period.\n * @ptr: pointer to kfree for both single- and double-argument invocations.\n * @rhf: the name of the struct rcu_head within the type of @ptr,\n *       but only for double-argument invocations.\n *\n * Many rcu callbacks functions just call kfree() on the base structure.\n * These functions are trivial, but their size adds up, and furthermore\n * when they are used in a kernel module, that module must invoke the\n * high-latency rcu_barrier() function at module-unload time.\n *\n * The kfree_rcu() function handles this issue.  Rather than encoding a\n * function address in the embedded rcu_head structure, kfree_rcu() instead\n * encodes the offset of the rcu_head structure within the base structure.\n * Because the functions are not allowed in the low-order 4096 bytes of\n * kernel virtual memory, offsets up to 4095 bytes can be accommodated.\n * If the offset is larger than 4095 bytes, a compile-time error will\n * be generated in kvfree_rcu_arg_2(). If this error is triggered, you can\n * either fall back to use of call_rcu() or rearrange the structure to\n * position the rcu_head structure into the first 4096 bytes.\n *\n * Note that the allowable offset might decrease in the future, for example,\n * to allow something like kmem_cache_free_rcu().\n *\n * The BUILD_BUG_ON check must not involve any function calls, hence the\n * checks are done in macros here.\n */\n#define kfree_rcu(ptr, rhf...) kvfree_rcu(ptr, ## rhf)\n\n/**\n * kvfree_rcu() - kvfree an object after a grace period.\n *\n * This macro consists of one or two arguments and it is\n * based on whether an object is head-less or not. If it\n * has a head then a semantic stays the same as it used\n * to be before:\n *\n *     kvfree_rcu(ptr, rhf);\n *\n * where @ptr is a pointer to kvfree(), @rhf is the name\n * of the rcu_head structure within the type of @ptr.\n *\n * When it comes to head-less variant, only one argument\n * is passed and that is just a pointer which has to be\n * freed after a grace period. Therefore the semantic is\n *\n *     kvfree_rcu(ptr);\n *\n * where @ptr is a pointer to kvfree().\n *\n * Please note, head-less way of freeing is permitted to\n * use from a context that has to follow might_sleep()\n * annotation. Otherwise, please switch and embed the\n * rcu_head structure within the type of @ptr.\n */\n#define kvfree_rcu(...) KVFREE_GET_MACRO(__VA_ARGS__,\t\t\\\n\tkvfree_rcu_arg_2, kvfree_rcu_arg_1)(__VA_ARGS__)\n\n#define KVFREE_GET_MACRO(_1, _2, NAME, ...) NAME\n#define kvfree_rcu_arg_2(ptr, rhf)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof (ptr) ___p = (ptr);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (___p) {\t\t\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG_ON(!__is_kvfree_rcu_offset(offsetof(typeof(*(ptr)), rhf)));\t\\\n\t\tkvfree_call_rcu(&((___p)->rhf), (rcu_callback_t)(unsigned long)\t\t\\\n\t\t\t(offsetof(typeof(*(ptr)), rhf)));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define kvfree_rcu_arg_1(ptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) ___p = (ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\\\n\t\tkvfree_call_rcu(NULL, (rcu_callback_t) (___p));\t\\\n} while (0)\n\n/*\n * Place this after a lock-acquisition primitive to guarantee that\n * an UNLOCK+LOCK pair acts as a full barrier.  This guarantee applies\n * if the UNLOCK and LOCK are executed by the same CPU or if the\n * UNLOCK and LOCK operate on the same lock variable.\n */\n#ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE\n#define smp_mb__after_unlock_lock()\tsmp_mb()  /* Full ordering for lock. */\n#else /* #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n#define smp_mb__after_unlock_lock()\tdo { } while (0)\n#endif /* #else #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n\n\n/* Has the specified rcu_head structure been handed to call_rcu()? */\n\n/**\n * rcu_head_init - Initialize rcu_head for rcu_head_after_call_rcu()\n * @rhp: The rcu_head structure to initialize.\n *\n * If you intend to invoke rcu_head_after_call_rcu() to test whether a\n * given rcu_head structure has already been passed to call_rcu(), then\n * you must also invoke this rcu_head_init() function on it just after\n * allocating that structure.  Calls to this function must not race with\n * calls to call_rcu(), rcu_head_after_call_rcu(), or callback invocation.\n */\nstatic inline void rcu_head_init(struct rcu_head *rhp)\n{\n\trhp->func = (rcu_callback_t)~0L;\n}\n\n/**\n * rcu_head_after_call_rcu() - Has this rcu_head been passed to call_rcu()?\n * @rhp: The rcu_head structure to test.\n * @f: The function passed to call_rcu() along with @rhp.\n *\n * Returns @true if the @rhp has been passed to call_rcu() with @func,\n * and @false otherwise.  Emits a warning in any other case, including\n * the case where @rhp has already been invoked after a grace period.\n * Calls to this function must not race with callback invocation.  One way\n * to avoid such races is to enclose the call to rcu_head_after_call_rcu()\n * in an RCU read-side critical section that includes a read-side fetch\n * of the pointer to the structure containing @rhp.\n */\nstatic inline bool\nrcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)\n{\n\trcu_callback_t func = READ_ONCE(rhp->func);\n\n\tif (func == f)\n\t\treturn true;\n\tWARN_ON_ONCE(func != (rcu_callback_t)~0L);\n\treturn false;\n}\n\n/* kernel/ksysfs.c definitions */\nextern int rcu_expedited;\nextern int rcu_normal;\n\n#endif /* __LINUX_RCUPDATE_H */\n"}}, "reports": [{"events": [{"location": {"col": 26, "file": 1, "line": 92}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 6, "file": 0, "line": 2908}, "message": "Assuming 'err' is 0"}, {"location": {"col": 2, "file": 0, "line": 2908}, "message": "Taking true branch"}, {"location": {"col": 8, "file": 0, "line": 2909}, "message": "Calling 'nexthop_add'"}, {"location": {"col": 6, "file": 0, "line": 2614}, "message": "Assuming the condition is false"}, {"location": {"col": 35, "file": 0, "line": 2614}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 2619}, "message": "Assuming field 'nh_id' is not equal to 0"}, {"location": {"col": 2, "file": 0, "line": 2619}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 2627}, "message": "Assuming field 'nh_grp' is non-null"}, {"location": {"col": 2, "file": 0, "line": 2627}, "message": "Taking true branch"}, {"location": {"col": 2, "file": 0, "line": 2632}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 2640}, "message": "Calling 'insert_nexthop'"}, {"location": {"col": 18, "file": 0, "line": 2263}, "message": "Assuming the condition is true"}, {"location": {"col": 17, "file": 0, "line": 2264}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2270}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 0, "line": 2274}, "message": "Assuming 'next' is null"}, {"location": {"col": 3, "file": 0, "line": 2274}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 0, "line": 2275}, "message": "Execution continues on line 2297"}, {"location": {"col": 6, "file": 0, "line": 2297}, "message": "'replace' is false"}, {"location": {"col": 14, "file": 0, "line": 2297}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 2303}, "message": "Assuming field 'is_group' is true"}, {"location": {"col": 2, "file": 0, "line": 2303}, "message": "Taking true branch"}, {"location": {"col": 26, "file": 0, "line": 2304}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 2, "line": 81}, "message": "expanded from macro 'rtnl_dereference'"}, {"location": {"col": 2, "file": 3, "line": 563}, "message": "expanded from macro 'rcu_dereference_protected'"}, {"location": {"col": 2, "file": 3, "line": 382}, "message": "expanded from macro '__rcu_dereference_protected'"}, {"location": {"col": 48, "file": 3, "line": 346}, "message": "expanded from macro 'RCU_LOCKDEP_WARN'"}, {"location": {"col": 26, "file": 0, "line": 2304}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 2, "line": 81}, "message": "expanded from macro 'rtnl_dereference'"}, {"location": {"col": 2, "file": 3, "line": 563}, "message": "expanded from macro 'rcu_dereference_protected'"}, {"location": {"col": 2, "file": 3, "line": 382}, "message": "expanded from macro '__rcu_dereference_protected'"}, {"location": {"col": 32, "file": 3, "line": 346}, "message": "expanded from macro 'RCU_LOCKDEP_WARN'"}, {"location": {"col": 7, "file": 0, "line": 2307}, "message": "Assuming field 'resilient' is true"}, {"location": {"col": 3, "file": 0, "line": 2307}, "message": "Taking true branch"}, {"location": {"col": 16, "file": 0, "line": 2308}, "message": "Left side of '&&' is false"}, {"location": {"col": 2, "file": 2, "line": 81}, "message": "expanded from macro 'rtnl_dereference'"}, {"location": {"col": 2, "file": 3, "line": 563}, "message": "expanded from macro 'rcu_dereference_protected'"}, {"location": {"col": 2, "file": 3, "line": 382}, "message": "expanded from macro '__rcu_dereference_protected'"}, {"location": {"col": 48, "file": 3, "line": 346}, "message": "expanded from macro 'RCU_LOCKDEP_WARN'"}, {"location": {"col": 16, "file": 0, "line": 2308}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 2, "line": 81}, "message": "expanded from macro 'rtnl_dereference'"}, {"location": {"col": 2, "file": 3, "line": 563}, "message": "expanded from macro 'rcu_dereference_protected'"}, {"location": {"col": 2, "file": 3, "line": 382}, "message": "expanded from macro '__rcu_dereference_protected'"}, {"location": {"col": 32, "file": 3, "line": 346}, "message": "expanded from macro 'RCU_LOCKDEP_WARN'"}, {"location": {"col": 8, "file": 0, "line": 2313}, "message": "Assuming field 'nh_grp_res_has_num_buckets' is true"}, {"location": {"col": 4, "file": 0, "line": 2313}, "message": "Taking false branch"}, {"location": {"col": 4, "file": 0, "line": 2319}, "message": "Calling 'nh_res_group_rebalance'"}, {"location": {"col": 14, "file": 0, "line": 1640}, "message": "Assuming 'i' is < field 'num_nh'"}, {"location": {"col": 2, "file": 0, "line": 1640}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 3, "file": 0, "line": 1641}, "message": "Value assigned to 'total'"}, {"location": {"col": 14, "file": 0, "line": 1640}, "message": "Assuming 'i' is >= field 'num_nh'"}, {"location": {"col": 2, "file": 0, "line": 1640}, "message": "Loop condition is false. Execution continues on line 1643"}, {"location": {"col": 2, "file": 0, "line": 1643}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "'__d' initialized here"}, {"location": {"col": 2, "file": 1, "line": 88}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "Left side of '||' is false"}, {"location": {"col": 3, "file": 1, "line": 89}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "Left side of '||' is false"}, {"location": {"col": 3, "file": 1, "line": 89}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "Assuming '__x' is <= 0"}, {"location": {"col": 5, "file": 1, "line": 91}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "Assuming '__d' is <= 0"}, {"location": {"col": 20, "file": 1, "line": 91}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "'?' condition is true"}, {"location": {"col": 2, "file": 1, "line": 89}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "Division by zero"}, {"location": {"col": 26, "file": 1, "line": 92}, "message": "expanded from macro 'DIV_ROUND_CLOSEST'"}, {"location": {"col": 17, "file": 0, "line": 1648}, "message": "Division by zero"}], "macros": [], "notes": [], "path": "/src/net/ipv4/nexthop.c", "reportHash": "dd66cc43d2ed863b88d030f0fea9de0a", "checkerName": "clang-analyzer-core.DivideZero", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
