<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * QLogic iSCSI HBA Driver\n * Copyright (c)  2003-2013 QLogic Corporation\n */\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/iscsi_boot_sysfs.h>\n#include <linux/inet.h>\n\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n\n#include \"ql4_def.h\"\n#include \"ql4_version.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n#include \"ql4_83xx.h\"\n\n/*\n * Driver version\n */\nstatic char qla4xxx_version_str[40];\n\n/*\n * SRB allocation cache\n */\nstatic struct kmem_cache *srb_cachep;\n\n/*\n * Module parameter information and variables\n */\nstatic int ql4xdisablesysfsboot = 1;\nmodule_param(ql4xdisablesysfsboot, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xdisablesysfsboot,\n\t\t \" Set to disable exporting boot targets to sysfs.\\n\"\n\t\t \"\\t\\t  0 - Export boot targets\\n\"\n\t\t \"\\t\\t  1 - Do not export boot targets (Default)\");\n\nint ql4xdontresethba;\nmodule_param(ql4xdontresethba, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xdontresethba,\n\t\t \" Don't reset the HBA for driver recovery.\\n\"\n\t\t \"\\t\\t  0 - It will reset HBA (Default)\\n\"\n\t\t \"\\t\\t  1 - It will NOT reset HBA\");\n\nint ql4xextended_error_logging;\nmodule_param(ql4xextended_error_logging, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xextended_error_logging,\n\t\t \" Option to enable extended error logging.\\n\"\n\t\t \"\\t\\t  0 - no logging (Default)\\n\"\n\t\t \"\\t\\t  2 - debug logging\");\n\nint ql4xenablemsix = 1;\nmodule_param(ql4xenablemsix, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql4xenablemsix,\n\t\t \" Set to enable MSI or MSI-X interrupt mechanism.\\n\"\n\t\t \"\\t\\t  0 = enable INTx interrupt mechanism.\\n\"\n\t\t \"\\t\\t  1 = enable MSI-X interrupt mechanism (Default).\\n\"\n\t\t \"\\t\\t  2 = enable MSI interrupt mechanism.\");\n\n#define QL4_DEF_QDEPTH 32\nstatic int ql4xmaxqdepth = QL4_DEF_QDEPTH;\nmodule_param(ql4xmaxqdepth, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xmaxqdepth,\n\t\t \" Maximum queue depth to report for target devices.\\n\"\n\t\t \"\\t\\t  Default: 32.\");\n\nstatic int ql4xqfulltracking = 1;\nmodule_param(ql4xqfulltracking, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xqfulltracking,\n\t\t \" Enable or disable dynamic tracking and adjustment of\\n\"\n\t\t \"\\t\\t scsi device queue depth.\\n\"\n\t\t \"\\t\\t  0 - Disable.\\n\"\n\t\t \"\\t\\t  1 - Enable. (Default)\");\n\nstatic int ql4xsess_recovery_tmo = QL4_SESS_RECOVERY_TMO;\nmodule_param(ql4xsess_recovery_tmo, int, S_IRUGO);\nMODULE_PARM_DESC(ql4xsess_recovery_tmo,\n\t\t\" Target Session Recovery Timeout.\\n\"\n\t\t\"\\t\\t  Default: 120 sec.\");\n\nint ql4xmdcapmask = 0;\nmodule_param(ql4xmdcapmask, int, S_IRUGO);\nMODULE_PARM_DESC(ql4xmdcapmask,\n\t\t \" Set the Minidump driver capture mask level.\\n\"\n\t\t \"\\t\\t  Default is 0 (firmware default capture mask)\\n\"\n\t\t \"\\t\\t  Can be set to 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F, 0xFF\");\n\nint ql4xenablemd = 1;\nmodule_param(ql4xenablemd, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xenablemd,\n\t\t \" Set to enable minidump.\\n\"\n\t\t \"\\t\\t  0 - disable minidump\\n\"\n\t\t \"\\t\\t  1 - enable minidump (Default)\");\n\nstatic int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha);\n/*\n * SCSI host template entry points\n */\nstatic void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha);\n\n/*\n * iSCSI template entry points\n */\nstatic int qla4xxx_session_get_param(struct iscsi_cls_session *cls_sess,\n\t\t\t\t     enum iscsi_param param, char *buf);\nstatic int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,\n\t\t\t\t  enum iscsi_param param, char *buf);\nstatic int qla4xxx_host_get_param(struct Scsi_Host *shost,\n\t\t\t\t  enum iscsi_host_param param, char *buf);\nstatic int qla4xxx_iface_set_param(struct Scsi_Host *shost, void *data,\n\t\t\t\t   uint32_t len);\nstatic int qla4xxx_get_iface_param(struct iscsi_iface *iface,\n\t\t\t\t   enum iscsi_param_type param_type,\n\t\t\t\t   int param, char *buf);\nstatic enum blk_eh_timer_return qla4xxx_eh_cmd_timed_out(struct scsi_cmnd *sc);\nstatic struct iscsi_endpoint *qla4xxx_ep_connect(struct Scsi_Host *shost,\n\t\t\t\t\t\t struct sockaddr *dst_addr,\n\t\t\t\t\t\t int non_blocking);\nstatic int qla4xxx_ep_poll(struct iscsi_endpoint *ep, int timeout_ms);\nstatic void qla4xxx_ep_disconnect(struct iscsi_endpoint *ep);\nstatic int qla4xxx_get_ep_param(struct iscsi_endpoint *ep,\n\t\t\t\tenum iscsi_param param, char *buf);\nstatic int qla4xxx_conn_start(struct iscsi_cls_conn *conn);\nstatic struct iscsi_cls_conn *\nqla4xxx_conn_create(struct iscsi_cls_session *cls_sess, uint32_t conn_idx);\nstatic int qla4xxx_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t     struct iscsi_cls_conn *cls_conn,\n\t\t\t     uint64_t transport_fd, int is_leading);\nstatic void qla4xxx_conn_destroy(struct iscsi_cls_conn *conn);\nstatic struct iscsi_cls_session *\nqla4xxx_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,\n\t\t\tuint16_t qdepth, uint32_t initial_cmdsn);\nstatic void qla4xxx_session_destroy(struct iscsi_cls_session *sess);\nstatic void qla4xxx_task_work(struct work_struct *wdata);\nstatic int qla4xxx_alloc_pdu(struct iscsi_task *, uint8_t);\nstatic int qla4xxx_task_xmit(struct iscsi_task *);\nstatic void qla4xxx_task_cleanup(struct iscsi_task *);\nstatic void qla4xxx_fail_session(struct iscsi_cls_session *cls_session);\nstatic void qla4xxx_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t   struct iscsi_stats *stats);\nstatic int qla4xxx_send_ping(struct Scsi_Host *shost, uint32_t iface_num,\n\t\t\t     uint32_t iface_type, uint32_t payload_size,\n\t\t\t     uint32_t pid, struct sockaddr *dst_addr);\nstatic int qla4xxx_get_chap_list(struct Scsi_Host *shost, uint16_t chap_tbl_idx,\n\t\t\t\t uint32_t *num_entries, char *buf);\nstatic int qla4xxx_delete_chap(struct Scsi_Host *shost, uint16_t chap_tbl_idx);\nstatic int qla4xxx_set_chap_entry(struct Scsi_Host *shost, void  *data,\n\t\t\t\t  int len);\nstatic int qla4xxx_get_host_stats(struct Scsi_Host *shost, char *buf, int len);\n\n/*\n * SCSI host template entry points\n */\nstatic int qla4xxx_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_abort(struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd);\nstatic int qla4xxx_slave_alloc(struct scsi_device *device);\nstatic umode_t qla4_attr_is_visible(int param_type, int param);\nstatic int qla4xxx_host_reset(struct Scsi_Host *shost, int reset_type);\n\n/*\n * iSCSI Flash DDB sysfs entry points\n */\nstatic int\nqla4xxx_sysfs_ddb_set_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    struct iscsi_bus_flash_conn *fnode_conn,\n\t\t\t    void *data, int len);\nstatic int\nqla4xxx_sysfs_ddb_get_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    int param, char *buf);\nstatic int qla4xxx_sysfs_ddb_add(struct Scsi_Host *shost, const char *buf,\n\t\t\t\t int len);\nstatic int\nqla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess);\nstatic int qla4xxx_sysfs_ddb_login(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t   struct iscsi_bus_flash_conn *fnode_conn);\nstatic int qla4xxx_sysfs_ddb_logout(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t    struct iscsi_bus_flash_conn *fnode_conn);\nstatic int qla4xxx_sysfs_ddb_logout_sid(struct iscsi_cls_session *cls_sess);\n\nstatic struct qla4_8xxx_legacy_intr_set legacy_intr[] =\n    QLA82XX_LEGACY_INTR_CONFIG;\n\nstatic const uint32_t qla4_82xx_reg_tbl[] = {\n\tQLA82XX_PEG_HALT_STATUS1,\n\tQLA82XX_PEG_HALT_STATUS2,\n\tQLA82XX_PEG_ALIVE_COUNTER,\n\tQLA82XX_CRB_DRV_ACTIVE,\n\tQLA82XX_CRB_DEV_STATE,\n\tQLA82XX_CRB_DRV_STATE,\n\tQLA82XX_CRB_DRV_SCRATCH,\n\tQLA82XX_CRB_DEV_PART_INFO,\n\tQLA82XX_CRB_DRV_IDC_VERSION,\n\tQLA82XX_FW_VERSION_MAJOR,\n\tQLA82XX_FW_VERSION_MINOR,\n\tQLA82XX_FW_VERSION_SUB,\n\tCRB_CMDPEG_STATE,\n\tCRB_TEMP_STATE,\n};\n\nstatic const uint32_t qla4_83xx_reg_tbl[] = {\n\tQLA83XX_PEG_HALT_STATUS1,\n\tQLA83XX_PEG_HALT_STATUS2,\n\tQLA83XX_PEG_ALIVE_COUNTER,\n\tQLA83XX_CRB_DRV_ACTIVE,\n\tQLA83XX_CRB_DEV_STATE,\n\tQLA83XX_CRB_DRV_STATE,\n\tQLA83XX_CRB_DRV_SCRATCH,\n\tQLA83XX_CRB_DEV_PART_INFO1,\n\tQLA83XX_CRB_IDC_VER_MAJOR,\n\tQLA83XX_FW_VER_MAJOR,\n\tQLA83XX_FW_VER_MINOR,\n\tQLA83XX_FW_VER_SUB,\n\tQLA83XX_CMDPEG_STATE,\n\tQLA83XX_ASIC_TEMP,\n};\n\nstatic struct scsi_host_template qla4xxx_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= DRIVER_NAME,\n\t.proc_name\t\t= DRIVER_NAME,\n\t.queuecommand\t\t= qla4xxx_queuecommand,\n\n\t.eh_abort_handler\t= qla4xxx_eh_abort,\n\t.eh_device_reset_handler = qla4xxx_eh_device_reset,\n\t.eh_target_reset_handler = qla4xxx_eh_target_reset,\n\t.eh_host_reset_handler\t= qla4xxx_eh_host_reset,\n\t.eh_timed_out\t\t= qla4xxx_eh_cmd_timed_out,\n\n\t.slave_alloc\t\t= qla4xxx_slave_alloc,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\n\t.this_id\t\t= -1,\n\t.cmd_per_lun\t\t= 3,\n\t.sg_tablesize\t\t= SG_ALL,\n\n\t.max_sectors\t\t= 0xFFFF,\n\t.shost_attrs\t\t= qla4xxx_host_attrs,\n\t.host_reset\t\t= qla4xxx_host_reset,\n\t.vendor_id\t\t= SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_QLOGIC,\n};\n\nstatic struct iscsi_transport qla4xxx_iscsi_transport = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= DRIVER_NAME,\n\t.caps\t\t\t= CAP_TEXT_NEGO |\n\t\t\t\t  CAP_DATA_PATH_OFFLOAD | CAP_HDRDGST |\n\t\t\t\t  CAP_DATADGST | CAP_LOGIN_OFFLOAD |\n\t\t\t\t  CAP_MULTI_R2T,\n\t.attr_is_visible\t= qla4_attr_is_visible,\n\t.create_session         = qla4xxx_session_create,\n\t.destroy_session        = qla4xxx_session_destroy,\n\t.start_conn             = qla4xxx_conn_start,\n\t.create_conn            = qla4xxx_conn_create,\n\t.bind_conn              = qla4xxx_conn_bind,\n\t.stop_conn              = iscsi_conn_stop,\n\t.destroy_conn           = qla4xxx_conn_destroy,\n\t.set_param              = iscsi_set_param,\n\t.get_conn_param\t\t= qla4xxx_conn_get_param,\n\t.get_session_param\t= qla4xxx_session_get_param,\n\t.get_ep_param           = qla4xxx_get_ep_param,\n\t.ep_connect\t\t= qla4xxx_ep_connect,\n\t.ep_poll\t\t= qla4xxx_ep_poll,\n\t.ep_disconnect\t\t= qla4xxx_ep_disconnect,\n\t.get_stats\t\t= qla4xxx_conn_get_stats,\n\t.send_pdu\t\t= iscsi_conn_send_pdu,\n\t.xmit_task\t\t= qla4xxx_task_xmit,\n\t.cleanup_task\t\t= qla4xxx_task_cleanup,\n\t.alloc_pdu\t\t= qla4xxx_alloc_pdu,\n\n\t.get_host_param\t\t= qla4xxx_host_get_param,\n\t.set_iface_param\t= qla4xxx_iface_set_param,\n\t.get_iface_param\t= qla4xxx_get_iface_param,\n\t.bsg_request\t\t= qla4xxx_bsg_request,\n\t.send_ping\t\t= qla4xxx_send_ping,\n\t.get_chap\t\t= qla4xxx_get_chap_list,\n\t.delete_chap\t\t= qla4xxx_delete_chap,\n\t.set_chap\t\t= qla4xxx_set_chap_entry,\n\t.get_flashnode_param\t= qla4xxx_sysfs_ddb_get_param,\n\t.set_flashnode_param\t= qla4xxx_sysfs_ddb_set_param,\n\t.new_flashnode\t\t= qla4xxx_sysfs_ddb_add,\n\t.del_flashnode\t\t= qla4xxx_sysfs_ddb_delete,\n\t.login_flashnode\t= qla4xxx_sysfs_ddb_login,\n\t.logout_flashnode\t= qla4xxx_sysfs_ddb_logout,\n\t.logout_flashnode_sid\t= qla4xxx_sysfs_ddb_logout_sid,\n\t.get_host_stats\t\t= qla4xxx_get_host_stats,\n};\n\nstatic struct scsi_transport_template *qla4xxx_scsi_transport;\n\nstatic int qla4xxx_isp_check_reg(struct scsi_qla_host *ha)\n{\n\tu32 reg_val = 0;\n\tint rval = QLA_SUCCESS;\n\n\tif (is_qla8022(ha))\n\t\treg_val = readl(&ha->qla4_82xx_reg->host_status);\n\telse if (is_qla8032(ha) || is_qla8042(ha))\n\t\treg_val = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_ALIVE_COUNTER);\n\telse\n\t\treg_val = readw(&ha->reg->ctrl_status);\n\n\tif (reg_val == QL4_ISP_REG_DISCONNECT)\n\t\trval = QLA_ERROR;\n\n\treturn rval;\n}\n\nstatic int qla4xxx_send_ping(struct Scsi_Host *shost, uint32_t iface_num,\n\t\t\t     uint32_t iface_type, uint32_t payload_size,\n\t\t\t     uint32_t pid, struct sockaddr *dst_addr)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tuint32_t options = 0;\n\tuint8_t ipaddr[IPv6_ADDR_LEN];\n\tint rval;\n\n\tmemset(ipaddr, 0, IPv6_ADDR_LEN);\n\t/* IPv4 to IPv4 */\n\tif ((iface_type == ISCSI_IFACE_TYPE_IPV4) &&\n\t    (dst_addr->sa_family == AF_INET)) {\n\t\taddr = (struct sockaddr_in *)dst_addr;\n\t\tmemcpy(ipaddr, &addr->sin_addr.s_addr, IP_ADDR_LEN);\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: IPv4 Ping src: %pI4 \"\n\t\t\t\t  \"dest: %pI4\\n\", __func__,\n\t\t\t\t  &ha->ip_config.ip_address, ipaddr));\n\t\trval = qla4xxx_ping_iocb(ha, options, payload_size, pid,\n\t\t\t\t\t ipaddr);\n\t\tif (rval)\n\t\t\trval = -EINVAL;\n\t} else if ((iface_type == ISCSI_IFACE_TYPE_IPV6) &&\n\t\t   (dst_addr->sa_family == AF_INET6)) {\n\t\t/* IPv6 to IPv6 */\n\t\taddr6 = (struct sockaddr_in6 *)dst_addr;\n\t\tmemcpy(ipaddr, &addr6->sin6_addr.in6_u.u6_addr8, IPv6_ADDR_LEN);\n\n\t\toptions |= PING_IPV6_PROTOCOL_ENABLE;\n\n\t\t/* Ping using LinkLocal address */\n\t\tif ((iface_num == 0) || (iface_num == 1)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: LinkLocal Ping \"\n\t\t\t\t\t  \"src: %pI6 dest: %pI6\\n\", __func__,\n\t\t\t\t\t  &ha->ip_config.ipv6_link_local_addr,\n\t\t\t\t\t  ipaddr));\n\t\t\toptions |= PING_IPV6_LINKLOCAL_ADDR;\n\t\t\trval = qla4xxx_ping_iocb(ha, options, payload_size,\n\t\t\t\t\t\t pid, ipaddr);\n\t\t} else {\n\t\t\tql4_printk(KERN_WARNING, ha, \"%s: iface num = %d \"\n\t\t\t\t   \"not supported\\n\", __func__, iface_num);\n\t\t\trval = -ENOSYS;\n\t\t\tgoto exit_send_ping;\n\t\t}\n\n\t\t/*\n\t\t * If ping using LinkLocal address fails, try ping using\n\t\t * IPv6 address\n\t\t */\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\toptions &= ~PING_IPV6_LINKLOCAL_ADDR;\n\t\t\tif (iface_num == 0) {\n\t\t\t\toptions |= PING_IPV6_ADDR0;\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: IPv6 \"\n\t\t\t\t\t\t  \"Ping src: %pI6 \"\n\t\t\t\t\t\t  \"dest: %pI6\\n\", __func__,\n\t\t\t\t\t\t  &ha->ip_config.ipv6_addr0,\n\t\t\t\t\t\t  ipaddr));\n\t\t\t} else if (iface_num == 1) {\n\t\t\t\toptions |= PING_IPV6_ADDR1;\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: IPv6 \"\n\t\t\t\t\t\t  \"Ping src: %pI6 \"\n\t\t\t\t\t\t  \"dest: %pI6\\n\", __func__,\n\t\t\t\t\t\t  &ha->ip_config.ipv6_addr1,\n\t\t\t\t\t\t  ipaddr));\n\t\t\t}\n\t\t\trval = qla4xxx_ping_iocb(ha, options, payload_size,\n\t\t\t\t\t\t pid, ipaddr);\n\t\t\tif (rval)\n\t\t\t\trval = -EINVAL;\n\t\t}\n\t} else\n\t\trval = -ENOSYS;\nexit_send_ping:\n\treturn rval;\n}\n\nstatic umode_t qla4_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tcase ISCSI_HOST_PARAM_PORT_STATE:\n\t\tcase ISCSI_HOST_PARAM_PORT_SPEED:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_TARGET_ALIAS:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_CHAP_OUT_IDX:\n\t\tcase ISCSI_PARAM_CHAP_IN_IDX:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\n\t\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\tcase ISCSI_PARAM_PORTAL_TYPE:\n\t\tcase ISCSI_PARAM_CHAP_AUTH_EN:\n\t\tcase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tcase ISCSI_PARAM_BIDI_CHAP_EN:\n\t\tcase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tcase ISCSI_PARAM_DEF_TIME2WAIT:\n\t\tcase ISCSI_PARAM_DEF_TIME2RETAIN:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_MAX_SEGMENT_SIZE:\n\t\tcase ISCSI_PARAM_TCP_TIMESTAMP_STAT:\n\t\tcase ISCSI_PARAM_TCP_WSF_DISABLE:\n\t\tcase ISCSI_PARAM_TCP_NAGLE_DISABLE:\n\t\tcase ISCSI_PARAM_TCP_TIMER_SCALE:\n\t\tcase ISCSI_PARAM_TCP_TIMESTAMP_EN:\n\t\tcase ISCSI_PARAM_TCP_XMIT_WSF:\n\t\tcase ISCSI_PARAM_TCP_RECV_WSF:\n\t\tcase ISCSI_PARAM_IP_FRAGMENT_DISABLE:\n\t\tcase ISCSI_PARAM_IPV4_TOS:\n\t\tcase ISCSI_PARAM_IPV6_TC:\n\t\tcase ISCSI_PARAM_IPV6_FLOW_LABEL:\n\t\tcase ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:\n\t\tcase ISCSI_PARAM_KEEPALIVE_TMO:\n\t\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tcase ISCSI_PARAM_ISID:\n\t\tcase ISCSI_PARAM_TSID:\n\t\tcase ISCSI_PARAM_DEF_TASKMGMT_TMO:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_STATSN:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\n\t\tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n\t\tcase ISCSI_PARAM_LOCAL_IPADDR:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_NET_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER:\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\n\t\tcase ISCSI_NET_PARAM_VLAN_ID:\n\t\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tcase ISCSI_NET_PARAM_MTU:\n\t\tcase ISCSI_NET_PARAM_PORT:\n\t\tcase ISCSI_NET_PARAM_IPADDR_STATE:\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE:\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER_STATE:\n\t\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\tcase ISCSI_NET_PARAM_CACHE_ID:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS:\n\t\tcase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\n\t\tcase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\n\t\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_TTL:\n\t\tcase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\n\t\tcase ISCSI_NET_PARAM_IPV6_MLD_EN:\n\t\tcase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\n\t\tcase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\n\t\tcase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\n\t\tcase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\n\t\tcase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_IFACE_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\n\t\tcase ISCSI_IFACE_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_IFACE_PARAM_DATADGST_EN:\n\t\tcase ISCSI_IFACE_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_IFACE_PARAM_ERL:\n\t\tcase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_IFACE_PARAM_FIRST_BURST:\n\t\tcase ISCSI_IFACE_PARAM_MAX_R2T:\n\t\tcase ISCSI_IFACE_PARAM_MAX_BURST:\n\t\tcase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\n\t\tcase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tcase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\n\t\tcase ISCSI_IFACE_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_FLASHNODE_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\n\t\tcase ISCSI_FLASHNODE_PORTAL_TYPE:\n\t\tcase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_SESS:\n\t\tcase ISCSI_FLASHNODE_ENTRY_EN:\n\t\tcase ISCSI_FLASHNODE_HDR_DGST_EN:\n\t\tcase ISCSI_FLASHNODE_DATA_DGST_EN:\n\t\tcase ISCSI_FLASHNODE_IMM_DATA_EN:\n\t\tcase ISCSI_FLASHNODE_INITIAL_R2T_EN:\n\t\tcase ISCSI_FLASHNODE_DATASEQ_INORDER:\n\t\tcase ISCSI_FLASHNODE_PDU_INORDER:\n\t\tcase ISCSI_FLASHNODE_CHAP_AUTH_EN:\n\t\tcase ISCSI_FLASHNODE_SNACK_REQ_EN:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\n\t\tcase ISCSI_FLASHNODE_BIDI_CHAP_EN:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\n\t\tcase ISCSI_FLASHNODE_ERL:\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\n\t\tcase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\n\t\tcase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\n\t\tcase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\n\t\tcase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\n\t\tcase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_FLASHNODE_FIRST_BURST:\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2WAIT:\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\n\t\tcase ISCSI_FLASHNODE_MAX_R2T:\n\t\tcase ISCSI_FLASHNODE_KEEPALIVE_TMO:\n\t\tcase ISCSI_FLASHNODE_ISID:\n\t\tcase ISCSI_FLASHNODE_TSID:\n\t\tcase ISCSI_FLASHNODE_PORT:\n\t\tcase ISCSI_FLASHNODE_MAX_BURST:\n\t\tcase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\n\t\tcase ISCSI_FLASHNODE_IPADDR:\n\t\tcase ISCSI_FLASHNODE_ALIAS:\n\t\tcase ISCSI_FLASHNODE_REDIRECT_IPADDR:\n\t\tcase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\n\t\tcase ISCSI_FLASHNODE_LOCAL_PORT:\n\t\tcase ISCSI_FLASHNODE_IPV4_TOS:\n\t\tcase ISCSI_FLASHNODE_IPV6_TC:\n\t\tcase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\n\t\tcase ISCSI_FLASHNODE_NAME:\n\t\tcase ISCSI_FLASHNODE_TPGT:\n\t\tcase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE:\n\t\tcase ISCSI_FLASHNODE_TCP_XMIT_WSF:\n\t\tcase ISCSI_FLASHNODE_TCP_RECV_WSF:\n\t\tcase ISCSI_FLASHNODE_CHAP_OUT_IDX:\n\t\tcase ISCSI_FLASHNODE_USERNAME:\n\t\tcase ISCSI_FLASHNODE_PASSWORD:\n\t\tcase ISCSI_FLASHNODE_STATSN:\n\t\tcase ISCSI_FLASHNODE_EXP_STATSN:\n\t\tcase ISCSI_FLASHNODE_IS_BOOT_TGT:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * qla4xxx_create_chap_list - Create CHAP list from FLASH\n * @ha: pointer to adapter structure\n *\n * Read flash and make a list of CHAP entries, during login when a CHAP entry\n * is received, it will be checked in this list. If entry exist then the CHAP\n * entry index is set in the DDB. If CHAP entry does not exist in this list\n * then a new entry is added in FLASH in CHAP table and the index obtained is\n * used in the DDB.\n **/\nstatic void qla4xxx_create_chap_list(struct scsi_qla_host *ha)\n{\n\tint rval = 0;\n\tuint8_t *chap_flash_data = NULL;\n\tuint32_t offset;\n\tdma_addr_t chap_dma;\n\tuint32_t chap_size = 0;\n\n\tif (is_qla40XX(ha))\n\t\tchap_size = MAX_CHAP_ENTRIES_40XX *\n\t\t\t    sizeof(struct ql4_chap_table);\n\telse\t/* Single region contains CHAP info for both\n\t\t * ports which is divided into half for each port.\n\t\t */\n\t\tchap_size = ha->hw.flt_chap_size / 2;\n\n\tchap_flash_data = dma_alloc_coherent(&ha->pdev->dev, chap_size,\n\t\t\t\t\t     &chap_dma, GFP_KERNEL);\n\tif (!chap_flash_data) {\n\t\tql4_printk(KERN_ERR, ha, \"No memory for chap_flash_data\\n\");\n\t\treturn;\n\t}\n\n\tif (is_qla40XX(ha)) {\n\t\toffset = FLASH_CHAP_OFFSET;\n\t} else {\n\t\toffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\n\t\tif (ha->port_num == 1)\n\t\t\toffset += chap_size;\n\t}\n\n\trval = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto exit_chap_list;\n\n\tif (ha->chap_list == NULL)\n\t\tha->chap_list = vmalloc(chap_size);\n\tif (ha->chap_list == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"No memory for ha->chap_list\\n\");\n\t\tgoto exit_chap_list;\n\t}\n\n\tmemset(ha->chap_list, 0, chap_size);\n\tmemcpy(ha->chap_list, chap_flash_data, chap_size);\n\nexit_chap_list:\n\tdma_free_coherent(&ha->pdev->dev, chap_size, chap_flash_data, chap_dma);\n}\n\nstatic int qla4xxx_get_chap_by_index(struct scsi_qla_host *ha,\n\t\t\t\t     int16_t chap_index,\n\t\t\t\t     struct ql4_chap_table **chap_entry)\n{\n\tint rval = QLA_ERROR;\n\tint max_chap_entries;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"CHAP table cache is empty!\\n\");\n\t\tgoto exit_get_chap;\n\t}\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (chap_index > max_chap_entries) {\n\t\tql4_printk(KERN_ERR, ha, \"Invalid Chap index\\n\");\n\t\tgoto exit_get_chap;\n\t}\n\n\t*chap_entry = (struct ql4_chap_table *)ha->chap_list + chap_index;\n\tif ((*chap_entry)->cookie !=\n\t     __constant_cpu_to_le16(CHAP_VALID_COOKIE)) {\n\t\t*chap_entry = NULL;\n\t} else {\n\t\trval = QLA_SUCCESS;\n\t}\n\nexit_get_chap:\n\treturn rval;\n}\n\n/**\n * qla4xxx_find_free_chap_index - Find the first free chap index\n * @ha: pointer to adapter structure\n * @chap_index: CHAP index to be returned\n *\n * Find the first free chap index available in the chap table\n *\n * Note: Caller should acquire the chap lock before getting here.\n **/\nstatic int qla4xxx_find_free_chap_index(struct scsi_qla_host *ha,\n\t\t\t\t\tuint16_t *chap_index)\n{\n\tint i, rval;\n\tint free_index = -1;\n\tint max_chap_entries = 0;\n\tstruct ql4_chap_table *chap_table;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"CHAP table cache is empty!\\n\");\n\t\trval = QLA_ERROR;\n\t\tgoto exit_find_chap;\n\t}\n\n\tfor (i = 0; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\n\t\tif ((chap_table->cookie !=\n\t\t    __constant_cpu_to_le16(CHAP_VALID_COOKIE)) &&\n\t\t   (i > MAX_RESRV_CHAP_IDX)) {\n\t\t\t\tfree_index = i;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (free_index != -1) {\n\t\t*chap_index = free_index;\n\t\trval = QLA_SUCCESS;\n\t} else {\n\t\trval = QLA_ERROR;\n\t}\n\nexit_find_chap:\n\treturn rval;\n}\n\nstatic int qla4xxx_get_chap_list(struct Scsi_Host *shost, uint16_t chap_tbl_idx,\n\t\t\t\t  uint32_t *num_entries, char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct ql4_chap_table *chap_table;\n\tstruct iscsi_chap_rec *chap_rec;\n\tint max_chap_entries = 0;\n\tint valid_chap_entries = 0;\n\tint ret = 0, i;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tql4_printk(KERN_INFO, ha, \"%s: num_entries = %d, CHAP idx = %d\\n\",\n\t\t\t__func__, *num_entries, chap_tbl_idx);\n\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_get_chap_list;\n\t}\n\n\tqla4xxx_create_chap_list(ha);\n\n\tchap_rec = (struct iscsi_chap_rec *) buf;\n\tmutex_lock(&ha->chap_sem);\n\tfor (i = chap_tbl_idx; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\t\tif (chap_table->cookie !=\n\t\t    __constant_cpu_to_le16(CHAP_VALID_COOKIE))\n\t\t\tcontinue;\n\n\t\tchap_rec->chap_tbl_idx = i;\n\t\tstrlcpy(chap_rec->username, chap_table->name,\n\t\t\tISCSI_CHAP_AUTH_NAME_MAX_LEN);\n\t\tstrlcpy(chap_rec->password, chap_table->secret,\n\t\t\tQL4_CHAP_MAX_SECRET_LEN);\n\t\tchap_rec->password_length = chap_table->secret_len;\n\n\t\tif (chap_table->flags & BIT_7) /* local */\n\t\t\tchap_rec->chap_type = CHAP_TYPE_OUT;\n\n\t\tif (chap_table->flags & BIT_6) /* peer */\n\t\t\tchap_rec->chap_type = CHAP_TYPE_IN;\n\n\t\tchap_rec++;\n\n\t\tvalid_chap_entries++;\n\t\tif (valid_chap_entries == *num_entries)\n\t\t\tbreak;\n\t\telse\n\t\t\tcontinue;\n\t}\n\tmutex_unlock(&ha->chap_sem);\n\nexit_get_chap_list:\n\tql4_printk(KERN_INFO, ha, \"%s: Valid CHAP Entries = %d\\n\",\n\t\t\t__func__,  valid_chap_entries);\n\t*num_entries = valid_chap_entries;\n\treturn ret;\n}\n\nstatic int __qla4xxx_is_chap_active(struct device *dev, void *data)\n{\n\tint ret = 0;\n\tuint16_t *chap_tbl_idx = (uint16_t *) data;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\n\tif (!iscsi_is_session_dev(dev))\n\t\tgoto exit_is_chap_active;\n\n\tcls_session = iscsi_dev_to_session(dev);\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\n\tif (iscsi_is_session_online(cls_session))\n\t\tgoto exit_is_chap_active;\n\n\tif (ddb_entry->chap_tbl_idx == *chap_tbl_idx)\n\t\tret = 1;\n\nexit_is_chap_active:\n\treturn ret;\n}\n\nstatic int qla4xxx_is_chap_active(struct Scsi_Host *shost,\n\t\t\t\t  uint16_t chap_tbl_idx)\n{\n\tint ret = 0;\n\n\tret = device_for_each_child(&shost->shost_gendev, &chap_tbl_idx,\n\t\t\t\t    __qla4xxx_is_chap_active);\n\n\treturn ret;\n}\n\nstatic int qla4xxx_delete_chap(struct Scsi_Host *shost, uint16_t chap_tbl_idx)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct ql4_chap_table *chap_table;\n\tdma_addr_t chap_dma;\n\tint max_chap_entries = 0;\n\tuint32_t offset = 0;\n\tuint32_t chap_size;\n\tint ret = 0;\n\n\tchap_table = dma_pool_zalloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\n\tif (chap_table == NULL)\n\t\treturn -ENOMEM;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (chap_tbl_idx > max_chap_entries) {\n\t\tret = -EINVAL;\n\t\tgoto exit_delete_chap;\n\t}\n\n\t/* Check if chap index is in use.\n\t * If chap is in use don't delet chap entry */\n\tret = qla4xxx_is_chap_active(shost, chap_tbl_idx);\n\tif (ret) {\n\t\tql4_printk(KERN_INFO, ha, \"CHAP entry %d is in use, cannot \"\n\t\t\t   \"delete from flash\\n\", chap_tbl_idx);\n\t\tret = -EBUSY;\n\t\tgoto exit_delete_chap;\n\t}\n\n\tchap_size = sizeof(struct ql4_chap_table);\n\tif (is_qla40XX(ha))\n\t\toffset = FLASH_CHAP_OFFSET | (chap_tbl_idx * chap_size);\n\telse {\n\t\toffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\n\t\t/* flt_chap_size is CHAP table size for both ports\n\t\t * so divide it by 2 to calculate the offset for second port\n\t\t */\n\t\tif (ha->port_num == 1)\n\t\t\toffset += (ha->hw.flt_chap_size / 2);\n\t\toffset += (chap_tbl_idx * chap_size);\n\t}\n\n\tret = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\n\tif (ret != QLA_SUCCESS) {\n\t\tret = -EINVAL;\n\t\tgoto exit_delete_chap;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Chap Cookie: x%x\\n\",\n\t\t\t  __le16_to_cpu(chap_table->cookie)));\n\n\tif (__le16_to_cpu(chap_table->cookie) != CHAP_VALID_COOKIE) {\n\t\tql4_printk(KERN_ERR, ha, \"No valid chap entry found\\n\");\n\t\tgoto exit_delete_chap;\n\t}\n\n\tchap_table->cookie = __constant_cpu_to_le16(0xFFFF);\n\n\toffset = FLASH_CHAP_OFFSET |\n\t\t\t(chap_tbl_idx * sizeof(struct ql4_chap_table));\n\tret = qla4xxx_set_flash(ha, chap_dma, offset, chap_size,\n\t\t\t\tFLASH_OPT_RMW_COMMIT);\n\tif (ret == QLA_SUCCESS && ha->chap_list) {\n\t\tmutex_lock(&ha->chap_sem);\n\t\t/* Update ha chap_list cache */\n\t\tmemcpy((struct ql4_chap_table *)ha->chap_list + chap_tbl_idx,\n\t\t\tchap_table, sizeof(struct ql4_chap_table));\n\t\tmutex_unlock(&ha->chap_sem);\n\t}\n\tif (ret != QLA_SUCCESS)\n\t\tret =  -EINVAL;\n\nexit_delete_chap:\n\tdma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\n\treturn ret;\n}\n\n/**\n * qla4xxx_set_chap_entry - Make chap entry with given information\n * @shost: pointer to host\n * @data: chap info - credentials, index and type to make chap entry\n * @len: length of data\n *\n * Add or update chap entry with the given information\n **/\nstatic int qla4xxx_set_chap_entry(struct Scsi_Host *shost, void *data, int len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_chap_rec chap_rec;\n\tstruct ql4_chap_table *chap_entry = NULL;\n\tstruct iscsi_param_info *param_info;\n\tstruct nlattr *attr;\n\tint max_chap_entries = 0;\n\tint type;\n\tint rem = len;\n\tint rc = 0;\n\tint size;\n\n\tmemset(&chap_rec, 0, sizeof(chap_rec));\n\n\tnla_for_each_attr(attr, data, len, rem) {\n\t\tparam_info = nla_data(attr);\n\n\t\tswitch (param_info->param) {\n\t\tcase ISCSI_CHAP_PARAM_INDEX:\n\t\t\tchap_rec.chap_tbl_idx = *(uint16_t *)param_info->value;\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_CHAP_TYPE:\n\t\t\tchap_rec.chap_type = param_info->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_USERNAME:\n\t\t\tsize = min_t(size_t, sizeof(chap_rec.username),\n\t\t\t\t     param_info->len);\n\t\t\tmemcpy(chap_rec.username, param_info->value, size);\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_PASSWORD:\n\t\t\tsize = min_t(size_t, sizeof(chap_rec.password),\n\t\t\t\t     param_info->len);\n\t\t\tmemcpy(chap_rec.password, param_info->value, size);\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_PASSWORD_LEN:\n\t\t\tchap_rec.password_length = param_info->value[0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"%s: No such sysfs attribute\\n\", __func__);\n\t\t\trc = -ENOSYS;\n\t\t\tgoto exit_set_chap;\n\t\t}\n\t}\n\n\tif (chap_rec.chap_type == CHAP_TYPE_IN)\n\t\ttype = BIDI_CHAP;\n\telse\n\t\ttype = LOCAL_CHAP;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tmutex_lock(&ha->chap_sem);\n\tif (chap_rec.chap_tbl_idx < max_chap_entries) {\n\t\trc = qla4xxx_get_chap_by_index(ha, chap_rec.chap_tbl_idx,\n\t\t\t\t\t       &chap_entry);\n\t\tif (!rc) {\n\t\t\tif (!(type == qla4xxx_get_chap_type(chap_entry))) {\n\t\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t\t   \"Type mismatch for CHAP entry %d\\n\",\n\t\t\t\t\t   chap_rec.chap_tbl_idx);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto exit_unlock_chap;\n\t\t\t}\n\n\t\t\t/* If chap index is in use then don't modify it */\n\t\t\trc = qla4xxx_is_chap_active(shost,\n\t\t\t\t\t\t    chap_rec.chap_tbl_idx);\n\t\t\tif (rc) {\n\t\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t\t   \"CHAP entry %d is in use\\n\",\n\t\t\t\t\t   chap_rec.chap_tbl_idx);\n\t\t\t\trc = -EBUSY;\n\t\t\t\tgoto exit_unlock_chap;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = qla4xxx_find_free_chap_index(ha, &chap_rec.chap_tbl_idx);\n\t\tif (rc) {\n\t\t\tql4_printk(KERN_INFO, ha, \"CHAP entry not available\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tgoto exit_unlock_chap;\n\t\t}\n\t}\n\n\trc = qla4xxx_set_chap(ha, chap_rec.username, chap_rec.password,\n\t\t\t      chap_rec.chap_tbl_idx, type);\n\nexit_unlock_chap:\n\tmutex_unlock(&ha->chap_sem);\n\nexit_set_chap:\n\treturn rc;\n}\n\n\nstatic int qla4xxx_get_host_stats(struct Scsi_Host *shost, char *buf, int len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_offload_host_stats *host_stats = NULL;\n\tint host_stats_size;\n\tint ret = 0;\n\tint ddb_idx = 0;\n\tstruct ql_iscsi_stats *ql_iscsi_stats = NULL;\n\tint stats_size;\n\tdma_addr_t iscsi_stats_dma;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Func: %s\\n\", __func__));\n\n\thost_stats_size = sizeof(struct iscsi_offload_host_stats);\n\n\tif (host_stats_size != len) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: host_stats size mismatch expected = %d, is = %d\\n\",\n\t\t\t   __func__, len, host_stats_size);\n\t\tret = -EINVAL;\n\t\tgoto exit_host_stats;\n\t}\n\thost_stats = (struct iscsi_offload_host_stats *)buf;\n\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_host_stats;\n\t}\n\n\tstats_size = PAGE_ALIGN(sizeof(struct ql_iscsi_stats));\n\n\tql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,\n\t\t\t\t\t    &iscsi_stats_dma, GFP_KERNEL);\n\tif (!ql_iscsi_stats) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to allocate memory for iscsi stats\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto exit_host_stats;\n\t}\n\n\tret =  qla4xxx_get_mgmt_data(ha, ddb_idx, stats_size,\n\t\t\t\t     iscsi_stats_dma);\n\tif (ret != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to retrieve iscsi stats\\n\");\n\t\tret = -EIO;\n\t\tgoto exit_host_stats;\n\t}\n\thost_stats->mactx_frames = le64_to_cpu(ql_iscsi_stats->mac_tx_frames);\n\thost_stats->mactx_bytes = le64_to_cpu(ql_iscsi_stats->mac_tx_bytes);\n\thost_stats->mactx_multicast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_multicast_frames);\n\thost_stats->mactx_broadcast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_broadcast_frames);\n\thost_stats->mactx_pause_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_pause_frames);\n\thost_stats->mactx_control_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_control_frames);\n\thost_stats->mactx_deferral =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_deferral);\n\thost_stats->mactx_excess_deferral =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_excess_deferral);\n\thost_stats->mactx_late_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_late_collision);\n\thost_stats->mactx_abort\t= le64_to_cpu(ql_iscsi_stats->mac_tx_abort);\n\thost_stats->mactx_single_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_single_collision);\n\thost_stats->mactx_multiple_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_multiple_collision);\n\thost_stats->mactx_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_collision);\n\thost_stats->mactx_frames_dropped =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_frames_dropped);\n\thost_stats->mactx_jumbo_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_jumbo_frames);\n\thost_stats->macrx_frames = le64_to_cpu(ql_iscsi_stats->mac_rx_frames);\n\thost_stats->macrx_bytes = le64_to_cpu(ql_iscsi_stats->mac_rx_bytes);\n\thost_stats->macrx_unknown_control_frames =\n\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_unknown_control_frames);\n\thost_stats->macrx_pause_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_pause_frames);\n\thost_stats->macrx_control_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_control_frames);\n\thost_stats->macrx_dribble =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_dribble);\n\thost_stats->macrx_frame_length_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_frame_length_error);\n\thost_stats->macrx_jabber = le64_to_cpu(ql_iscsi_stats->mac_rx_jabber);\n\thost_stats->macrx_carrier_sense_error =\n\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_carrier_sense_error);\n\thost_stats->macrx_frame_discarded =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_frame_discarded);\n\thost_stats->macrx_frames_dropped =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_frames_dropped);\n\thost_stats->mac_crc_error = le64_to_cpu(ql_iscsi_stats->mac_crc_error);\n\thost_stats->mac_encoding_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_encoding_error);\n\thost_stats->macrx_length_error_large =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_length_error_large);\n\thost_stats->macrx_length_error_small =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_length_error_small);\n\thost_stats->macrx_multicast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_multicast_frames);\n\thost_stats->macrx_broadcast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_broadcast_frames);\n\thost_stats->iptx_packets = le64_to_cpu(ql_iscsi_stats->ip_tx_packets);\n\thost_stats->iptx_bytes = le64_to_cpu(ql_iscsi_stats->ip_tx_bytes);\n\thost_stats->iptx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_tx_fragments);\n\thost_stats->iprx_packets = le64_to_cpu(ql_iscsi_stats->ip_rx_packets);\n\thost_stats->iprx_bytes = le64_to_cpu(ql_iscsi_stats->ip_rx_bytes);\n\thost_stats->iprx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_rx_fragments);\n\thost_stats->ip_datagram_reassembly =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_datagram_reassembly);\n\thost_stats->ip_invalid_address_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_invalid_address_error);\n\thost_stats->ip_error_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_error_packets);\n\thost_stats->ip_fragrx_overlap =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_fragrx_overlap);\n\thost_stats->ip_fragrx_outoforder =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_fragrx_outoforder);\n\thost_stats->ip_datagram_reassembly_timeout =\n\t\tle64_to_cpu(ql_iscsi_stats->ip_datagram_reassembly_timeout);\n\thost_stats->ipv6tx_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_tx_packets);\n\thost_stats->ipv6tx_bytes = le64_to_cpu(ql_iscsi_stats->ipv6_tx_bytes);\n\thost_stats->ipv6tx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_tx_fragments);\n\thost_stats->ipv6rx_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_rx_packets);\n\thost_stats->ipv6rx_bytes = le64_to_cpu(ql_iscsi_stats->ipv6_rx_bytes);\n\thost_stats->ipv6rx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_rx_fragments);\n\thost_stats->ipv6_datagram_reassembly =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_datagram_reassembly);\n\thost_stats->ipv6_invalid_address_error =\n\t\tle64_to_cpu(ql_iscsi_stats->ipv6_invalid_address_error);\n\thost_stats->ipv6_error_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_error_packets);\n\thost_stats->ipv6_fragrx_overlap =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_fragrx_overlap);\n\thost_stats->ipv6_fragrx_outoforder =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_fragrx_outoforder);\n\thost_stats->ipv6_datagram_reassembly_timeout =\n\t\tle64_to_cpu(ql_iscsi_stats->ipv6_datagram_reassembly_timeout);\n\thost_stats->tcptx_segments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_segments);\n\thost_stats->tcptx_bytes\t= le64_to_cpu(ql_iscsi_stats->tcp_tx_bytes);\n\thost_stats->tcprx_segments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_segments);\n\thost_stats->tcprx_byte = le64_to_cpu(ql_iscsi_stats->tcp_rx_byte);\n\thost_stats->tcp_duplicate_ack_retx =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_duplicate_ack_retx);\n\thost_stats->tcp_retx_timer_expired =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_retx_timer_expired);\n\thost_stats->tcprx_duplicate_ack\t=\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_duplicate_ack);\n\thost_stats->tcprx_pure_ackr =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_pure_ackr);\n\thost_stats->tcptx_delayed_ack =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_delayed_ack);\n\thost_stats->tcptx_pure_ack =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_pure_ack);\n\thost_stats->tcprx_segment_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_segment_error);\n\thost_stats->tcprx_segment_outoforder =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_segment_outoforder);\n\thost_stats->tcprx_window_probe =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_window_probe);\n\thost_stats->tcprx_window_update =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_window_update);\n\thost_stats->tcptx_window_probe_persist =\n\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_window_probe_persist);\n\thost_stats->ecc_error_correction =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ecc_error_correction);\n\thost_stats->iscsi_pdu_tx = le64_to_cpu(ql_iscsi_stats->iscsi_pdu_tx);\n\thost_stats->iscsi_data_bytes_tx =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_data_bytes_tx);\n\thost_stats->iscsi_pdu_rx = le64_to_cpu(ql_iscsi_stats->iscsi_pdu_rx);\n\thost_stats->iscsi_data_bytes_rx\t=\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_data_bytes_rx);\n\thost_stats->iscsi_io_completed =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_io_completed);\n\thost_stats->iscsi_unexpected_io_rx =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_unexpected_io_rx);\n\thost_stats->iscsi_format_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_format_error);\n\thost_stats->iscsi_hdr_digest_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_hdr_digest_error);\n\thost_stats->iscsi_data_digest_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_data_digest_error);\n\thost_stats->iscsi_sequence_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_sequence_error);\nexit_host_stats:\n\tif (ql_iscsi_stats)\n\t\tdma_free_coherent(&ha->pdev->dev, stats_size,\n\t\t\t\t  ql_iscsi_stats, iscsi_stats_dma);\n\n\tql4_printk(KERN_INFO, ha, \"%s: Get host stats done\\n\",\n\t\t   __func__);\n\treturn ret;\n}\n\nstatic int qla4xxx_get_iface_param(struct iscsi_iface *iface,\n\t\t\t\t   enum iscsi_param_type param_type,\n\t\t\t\t   int param, char *buf)\n{\n\tstruct Scsi_Host *shost = iscsi_iface_to_shost(iface);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint ival;\n\tchar *pval = NULL;\n\tint len = -ENOSYS;\n\n\tif (param_type == ISCSI_NET_PARAM) {\n\t\tswitch (param) {\n\t\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &ha->ip_config.ip_address);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\t\tlen = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t      &ha->ip_config.subnet_mask);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &ha->ip_config.gateway);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t\t IPOPT_IPV4_PROTOCOL_ENABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t\t IPV6_OPT_IPV6_PROTOCOL_ENABLE, pval);\n\t\t\t}\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t\t      (ha->ip_config.tcp_options &\n\t\t\t\t       TCPOPT_DHCP_ENABLE) ?\n\t\t\t\t      \"dhcp\" : \"static\");\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\t\tif (iface->iface_num == 0)\n\t\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t\t      &ha->ip_config.ipv6_addr0);\n\t\t\tif (iface->iface_num == 1)\n\t\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t\t      &ha->ip_config.ipv6_addr1);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\n\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t      &ha->ip_config.ipv6_link_local_addr);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER:\n\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t      &ha->ip_config.ipv6_default_router_addr);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\n\t\t\tpval = (ha->ip_config.ipv6_addl_options &\n\t\t\t\tIPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) ?\n\t\t\t\t\"nd\" : \"static\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\n\t\t\tpval = (ha->ip_config.ipv6_addl_options &\n\t\t\t\tIPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR) ?\n\t\t\t\t\"auto\" : \"static\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_VLAN_ID:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tival = ha->ip_config.ipv4_vlan_tag &\n\t\t\t\t       ISCSI_MAX_VLAN_ID;\n\t\t\telse\n\t\t\t\tival = ha->ip_config.ipv6_vlan_tag &\n\t\t\t\t       ISCSI_MAX_VLAN_ID;\n\n\t\t\tlen = sprintf(buf, \"%d\\n\", ival);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tival = (ha->ip_config.ipv4_vlan_tag >> 13) &\n\t\t\t\t       ISCSI_MAX_VLAN_PRIORITY;\n\t\t\telse\n\t\t\t\tival = (ha->ip_config.ipv6_vlan_tag >> 13) &\n\t\t\t\t       ISCSI_MAX_VLAN_PRIORITY;\n\n\t\t\tlen = sprintf(buf, \"%d\\n\", ival);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t\t IPOPT_VLAN_TAGGING_ENABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t\t IPV6_OPT_VLAN_TAGGING_ENABLE, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_MTU:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.eth_mtu_size);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_PORT:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv4_port);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv6_port);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPADDR_STATE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\t\tha->ip_config.ipv4_addr_state);\n\t\t\t} else {\n\t\t\t\tif (iface->iface_num == 0)\n\t\t\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\t\tha->ip_config.ipv6_addr0_state);\n\t\t\t\telse if (iface->iface_num == 1)\n\t\t\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\t\tha->ip_config.ipv6_addr1_state);\n\t\t\t}\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE:\n\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\tha->ip_config.ipv6_link_local_state);\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER_STATE:\n\t\t\tpval = iscsi_get_router_state_name(\n\t\t\t\t      ha->ip_config.ipv6_default_router_state);\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(~ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_DELAYED_ACK_DISABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(~ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_DELAYED_ACK_DISABLE, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(~ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_NAGLE_ALGO_DISABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(~ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_NAGLE_ALGO_DISABLE, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(~ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_WINDOW_SCALE_DISABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(~ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_WINDOW_SCALE_DISABLE,\n\t\t\t\t\t pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.tcp_wsf);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv6_tcp_wsf);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tival = (ha->ip_config.tcp_options &\n\t\t\t\t\tTCPOPT_TIMER_SCALE) >> 1;\n\t\t\telse\n\t\t\t\tival = (ha->ip_config.ipv6_tcp_options &\n\t\t\t\t\tIPV6_TCPOPT_TIMER_SCALE) >> 1;\n\n\t\t\tlen = sprintf(buf, \"%d\\n\", ival);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_TIMESTAMP_ENABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_TIMESTAMP_EN, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_CACHE_ID:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv4_cache_id);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv6_cache_id);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\n\t\t\tOP_STATE(ha->ip_config.tcp_options,\n\t\t\t\t TCPOPT_DNS_SERVER_IP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\n\t\t\tOP_STATE(ha->ip_config.tcp_options,\n\t\t\t\t TCPOPT_SLP_DA_INFO_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_IPV4_TOS_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.ipv4_tos);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_GRAT_ARP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options, IPOPT_ALT_CID_EN,\n\t\t\t\t pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\n\t\t\tpval = (ha->ip_config.ipv4_alt_cid_len) ?\n\t\t\t       (char *)ha->ip_config.ipv4_alt_cid : \"\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_REQ_VID_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_USE_VID_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\n\t\t\tpval = (ha->ip_config.ipv4_vid_len) ?\n\t\t\t       (char *)ha->ip_config.ipv4_vid : \"\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_LEARN_IQN_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\n\t\t\tOP_STATE(~ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_FRAGMENTATION_DISABLE, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_IN_FORWARD_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t\t IPOPT_ARP_REDIRECT_EN, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t\t IPV6_OPT_REDIRECT_EN, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_TTL:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.ipv4_ttl);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t IPV6_OPT_GRAT_NEIGHBOR_ADV_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_MLD_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv6_addl_options,\n\t\t\t\t IPV6_ADDOPT_MLD_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\n\t\t\tlen = sprintf(buf, \"%u\\n\", ha->ip_config.ipv6_flow_lbl);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_traffic_class);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_hop_limit);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_nd_reach_time);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_nd_rexmit_timer);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_nd_stale_timeout);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_dup_addr_detect_count);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_gw_advrt_mtu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen = -ENOSYS;\n\t\t}\n\t} else if (param_type == ISCSI_IFACE_PARAM) {\n\t\tswitch (param) {\n\t\tcase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.def_timeout);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_HDRDGST_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_HEADER_DIGEST_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DATADGST_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DATA_DIGEST_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_IMM_DATA_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_IMMEDIATE_DATA_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_INITIAL_R2T_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DATA_SEQ_INORDER_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DATA_PDU_INORDER_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_ERL:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      (ha->ip_config.iscsi_options &\n\t\t\t\t       ISCSIOPTS_ERL));\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\n\t\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t\t      ha->ip_config.iscsi_max_pdu_size *\n\t\t\t\t      BYTE_UNITS);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_FIRST_BURST:\n\t\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t\t      ha->ip_config.iscsi_first_burst_len *\n\t\t\t\t      BYTE_UNITS);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_MAX_R2T:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.iscsi_max_outstnd_r2t);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_MAX_BURST:\n\t\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t\t      ha->ip_config.iscsi_max_burst_len *\n\t\t\t\t      BYTE_UNITS);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_CHAP_AUTH_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_BIDI_CHAP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DISCOVERY_AUTH_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DISCOVERY_LOGOUT_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_STRICT_LOGIN_COMP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_INITIATOR_NAME:\n\t\t\tlen = sprintf(buf, \"%s\\n\", ha->ip_config.iscsi_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen = -ENOSYS;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic struct iscsi_endpoint *\nqla4xxx_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\n\t\t   int non_blocking)\n{\n\tint ret;\n\tstruct iscsi_endpoint *ep;\n\tstruct qla_endpoint *qla_ep;\n\tstruct scsi_qla_host *ha;\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\n\tif (!shost) {\n\t\tret = -ENXIO;\n\t\tpr_err(\"%s: shost is NULL\\n\", __func__);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tha = iscsi_host_priv(shost);\n\tep = iscsi_create_endpoint(sizeof(struct qla_endpoint));\n\tif (!ep) {\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tqla_ep = ep->dd_data;\n\tmemset(qla_ep, 0, sizeof(struct qla_endpoint));\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tmemcpy(&qla_ep->dst_addr, dst_addr, sizeof(struct sockaddr_in));\n\t\taddr = (struct sockaddr_in *)&qla_ep->dst_addr;\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: %pI4\\n\", __func__,\n\t\t\t\t  (char *)&addr->sin_addr));\n\t} else if (dst_addr->sa_family == AF_INET6) {\n\t\tmemcpy(&qla_ep->dst_addr, dst_addr,\n\t\t       sizeof(struct sockaddr_in6));\n\t\taddr6 = (struct sockaddr_in6 *)&qla_ep->dst_addr;\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: %pI6\\n\", __func__,\n\t\t\t\t  (char *)&addr6->sin6_addr));\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha, \"%s: Invalid endpoint\\n\",\n\t\t\t   __func__);\n\t}\n\n\tqla_ep->host = shost;\n\n\treturn ep;\n}\n\nstatic int qla4xxx_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct qla_endpoint *qla_ep;\n\tstruct scsi_qla_host *ha;\n\tint ret = 0;\n\n\tqla_ep = ep->dd_data;\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(pr_info_ratelimited(\"%s: host: %ld\\n\", __func__, ha->host_no));\n\n\tif (adapter_up(ha) && !test_bit(AF_BUILD_DDB_LIST, &ha->flags))\n\t\tret = 1;\n\n\treturn ret;\n}\n\nstatic void qla4xxx_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct qla_endpoint *qla_ep;\n\tstruct scsi_qla_host *ha;\n\n\tqla_ep = ep->dd_data;\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\tiscsi_destroy_endpoint(ep);\n}\n\nstatic int qla4xxx_get_ep_param(struct iscsi_endpoint *ep,\n\t\t\t\tenum iscsi_param param,\n\t\t\t\tchar *buf)\n{\n\tstruct qla_endpoint *qla_ep = ep->dd_data;\n\tstruct sockaddr *dst_addr;\n\tstruct scsi_qla_host *ha;\n\n\tif (!qla_ep)\n\t\treturn -ENOTCONN;\n\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tdst_addr = (struct sockaddr *)&qla_ep->dst_addr;\n\t\tif (!dst_addr)\n\t\t\treturn -ENOTCONN;\n\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t &qla_ep->dst_addr, param, buf);\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\nstatic void qla4xxx_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t   struct iscsi_stats *stats)\n{\n\tstruct iscsi_session *sess;\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct ql_iscsi_stats *ql_iscsi_stats;\n\tint stats_size;\n\tint ret;\n\tdma_addr_t iscsi_stats_dma;\n\n\tcls_sess = iscsi_conn_to_session(cls_conn);\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\tstats_size = PAGE_ALIGN(sizeof(struct ql_iscsi_stats));\n\t/* Allocate memory */\n\tql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,\n\t\t\t\t\t    &iscsi_stats_dma, GFP_KERNEL);\n\tif (!ql_iscsi_stats) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to allocate memory for iscsi stats\\n\");\n\t\tgoto exit_get_stats;\n\t}\n\n\tret =  qla4xxx_get_mgmt_data(ha, ddb_entry->fw_ddb_index, stats_size,\n\t\t\t\t     iscsi_stats_dma);\n\tif (ret != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to retrieve iscsi stats\\n\");\n\t\tgoto free_stats;\n\t}\n\n\t/* octets */\n\tstats->txdata_octets = le64_to_cpu(ql_iscsi_stats->tx_data_octets);\n\tstats->rxdata_octets = le64_to_cpu(ql_iscsi_stats->rx_data_octets);\n\t/* xmit pdus */\n\tstats->noptx_pdus = le32_to_cpu(ql_iscsi_stats->tx_nopout_pdus);\n\tstats->scsicmd_pdus = le32_to_cpu(ql_iscsi_stats->tx_scsi_cmd_pdus);\n\tstats->tmfcmd_pdus = le32_to_cpu(ql_iscsi_stats->tx_tmf_cmd_pdus);\n\tstats->login_pdus = le32_to_cpu(ql_iscsi_stats->tx_login_cmd_pdus);\n\tstats->text_pdus = le32_to_cpu(ql_iscsi_stats->tx_text_cmd_pdus);\n\tstats->dataout_pdus = le32_to_cpu(ql_iscsi_stats->tx_scsi_write_pdus);\n\tstats->logout_pdus = le32_to_cpu(ql_iscsi_stats->tx_logout_cmd_pdus);\n\tstats->snack_pdus = le32_to_cpu(ql_iscsi_stats->tx_snack_req_pdus);\n\t/* recv pdus */\n\tstats->noprx_pdus = le32_to_cpu(ql_iscsi_stats->rx_nopin_pdus);\n\tstats->scsirsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_scsi_resp_pdus);\n\tstats->tmfrsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_tmf_resp_pdus);\n\tstats->textrsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_text_resp_pdus);\n\tstats->datain_pdus = le32_to_cpu(ql_iscsi_stats->rx_scsi_read_pdus);\n\tstats->logoutrsp_pdus =\n\t\t\tle32_to_cpu(ql_iscsi_stats->rx_logout_resp_pdus);\n\tstats->r2t_pdus = le32_to_cpu(ql_iscsi_stats->rx_r2t_pdus);\n\tstats->async_pdus = le32_to_cpu(ql_iscsi_stats->rx_async_pdus);\n\tstats->rjt_pdus = le32_to_cpu(ql_iscsi_stats->rx_reject_pdus);\n\nfree_stats:\n\tdma_free_coherent(&ha->pdev->dev, stats_size, ql_iscsi_stats,\n\t\t\t  iscsi_stats_dma);\nexit_get_stats:\n\treturn;\n}\n\nstatic enum blk_eh_timer_return qla4xxx_eh_cmd_timed_out(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *session;\n\tunsigned long flags;\n\tenum blk_eh_timer_return ret = BLK_EH_DONE;\n\n\tsession = starget_to_session(scsi_target(sc->device));\n\n\tspin_lock_irqsave(&session->lock, flags);\n\tif (session->state == ISCSI_SESSION_FAILED)\n\t\tret = BLK_EH_RESET_TIMER;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\n\treturn ret;\n}\n\nstatic void qla4xxx_set_port_speed(struct Scsi_Host *shost)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tuint32_t speed = ISCSI_PORT_SPEED_UNKNOWN;\n\n\tqla4xxx_get_firmware_state(ha);\n\n\tswitch (ha->addl_fw_state & 0x0F00) {\n\tcase FW_ADDSTATE_LINK_SPEED_10MBPS:\n\t\tspeed = ISCSI_PORT_SPEED_10MBPS;\n\t\tbreak;\n\tcase FW_ADDSTATE_LINK_SPEED_100MBPS:\n\t\tspeed = ISCSI_PORT_SPEED_100MBPS;\n\t\tbreak;\n\tcase FW_ADDSTATE_LINK_SPEED_1GBPS:\n\t\tspeed = ISCSI_PORT_SPEED_1GBPS;\n\t\tbreak;\n\tcase FW_ADDSTATE_LINK_SPEED_10GBPS:\n\t\tspeed = ISCSI_PORT_SPEED_10GBPS;\n\t\tbreak;\n\t}\n\tihost->port_speed = speed;\n}\n\nstatic void qla4xxx_set_port_state(struct Scsi_Host *shost)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tuint32_t state = ISCSI_PORT_STATE_DOWN;\n\n\tif (test_bit(AF_LINK_UP, &ha->flags))\n\t\tstate = ISCSI_PORT_STATE_UP;\n\n\tihost->port_state = state;\n}\n\nstatic int qla4xxx_host_get_param(struct Scsi_Host *shost,\n\t\t\t\t  enum iscsi_host_param param, char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint len;\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sysfs_format_mac(buf, ha->my_mac, MAC_ADDR_LEN);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tlen = sprintf(buf, \"%pI4\\n\", &ha->ip_config.ip_address);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", ha->name_string);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_PORT_STATE:\n\t\tqla4xxx_set_port_state(shost);\n\t\tlen = sprintf(buf, \"%s\\n\", iscsi_get_port_state_name(shost));\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_PORT_SPEED:\n\t\tqla4xxx_set_port_speed(shost);\n\t\tlen = sprintf(buf, \"%s\\n\", iscsi_get_port_speed_name(shost));\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}\n\nstatic void qla4xxx_create_ipv4_iface(struct scsi_qla_host *ha)\n{\n\tif (ha->iface_ipv4)\n\t\treturn;\n\n\t/* IPv4 */\n\tha->iface_ipv4 = iscsi_create_iface(ha->host,\n\t\t\t\t\t    &qla4xxx_iscsi_transport,\n\t\t\t\t\t    ISCSI_IFACE_TYPE_IPV4, 0, 0);\n\tif (!ha->iface_ipv4)\n\t\tql4_printk(KERN_ERR, ha, \"Could not create IPv4 iSCSI \"\n\t\t\t   \"iface0.\\n\");\n}\n\nstatic void qla4xxx_create_ipv6_iface(struct scsi_qla_host *ha)\n{\n\tif (!ha->iface_ipv6_0)\n\t\t/* IPv6 iface-0 */\n\t\tha->iface_ipv6_0 = iscsi_create_iface(ha->host,\n\t\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t\t      ISCSI_IFACE_TYPE_IPV6, 0,\n\t\t\t\t\t\t      0);\n\tif (!ha->iface_ipv6_0)\n\t\tql4_printk(KERN_ERR, ha, \"Could not create IPv6 iSCSI \"\n\t\t\t   \"iface0.\\n\");\n\n\tif (!ha->iface_ipv6_1)\n\t\t/* IPv6 iface-1 */\n\t\tha->iface_ipv6_1 = iscsi_create_iface(ha->host,\n\t\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t\t      ISCSI_IFACE_TYPE_IPV6, 1,\n\t\t\t\t\t\t      0);\n\tif (!ha->iface_ipv6_1)\n\t\tql4_printk(KERN_ERR, ha, \"Could not create IPv6 iSCSI \"\n\t\t\t   \"iface1.\\n\");\n}\n\nstatic void qla4xxx_create_ifaces(struct scsi_qla_host *ha)\n{\n\tif (ha->ip_config.ipv4_options & IPOPT_IPV4_PROTOCOL_ENABLE)\n\t\tqla4xxx_create_ipv4_iface(ha);\n\n\tif (ha->ip_config.ipv6_options & IPV6_OPT_IPV6_PROTOCOL_ENABLE)\n\t\tqla4xxx_create_ipv6_iface(ha);\n}\n\nstatic void qla4xxx_destroy_ipv4_iface(struct scsi_qla_host *ha)\n{\n\tif (ha->iface_ipv4) {\n\t\tiscsi_destroy_iface(ha->iface_ipv4);\n\t\tha->iface_ipv4 = NULL;\n\t}\n}\n\nstatic void qla4xxx_destroy_ipv6_iface(struct scsi_qla_host *ha)\n{\n\tif (ha->iface_ipv6_0) {\n\t\tiscsi_destroy_iface(ha->iface_ipv6_0);\n\t\tha->iface_ipv6_0 = NULL;\n\t}\n\tif (ha->iface_ipv6_1) {\n\t\tiscsi_destroy_iface(ha->iface_ipv6_1);\n\t\tha->iface_ipv6_1 = NULL;\n\t}\n}\n\nstatic void qla4xxx_destroy_ifaces(struct scsi_qla_host *ha)\n{\n\tqla4xxx_destroy_ipv4_iface(ha);\n\tqla4xxx_destroy_ipv6_iface(ha);\n}\n\nstatic void qla4xxx_set_ipv6(struct scsi_qla_host *ha,\n\t\t\t     struct iscsi_iface_param_info *iface_param,\n\t\t\t     struct addr_ctrl_blk *init_fw_cb)\n{\n\t/*\n\t * iface_num 0 is valid for IPv6 Addr, linklocal, router, autocfg.\n\t * iface_num 1 is valid only for IPv6 Addr.\n\t */\n\tswitch (iface_param->param) {\n\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\t/* IPv6 Addr 1 */\n\t\t\tmemcpy(init_fw_cb->ipv6_addr1, iface_param->value,\n\t\t\t       sizeof(init_fw_cb->ipv6_addr1));\n\t\telse\n\t\t\t/* IPv6 Addr 0 */\n\t\t\tmemcpy(init_fw_cb->ipv6_addr0, iface_param->value,\n\t\t\t       sizeof(init_fw_cb->ipv6_addr0));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv6_if_id, &iface_param->value[8],\n\t\t       sizeof(init_fw_cb->ipv6_if_id));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ROUTER:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv6_dflt_rtr_addr, iface_param->value,\n\t\t       sizeof(init_fw_cb->ipv6_dflt_rtr_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\n\t\t/* Autocfg applies to even interface */\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tif (iface_param->value[0] == ISCSI_IPV6_AUTOCFG_DISABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts &=\n\t\t\t\tcpu_to_le16(\n\t\t\t\t  ~IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE);\n\t\telse if (iface_param->value[0] == ISCSI_IPV6_AUTOCFG_ND_ENABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts |=\n\t\t\t\tcpu_to_le16(\n\t\t\t\t  IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE);\n\t\telse\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"Invalid autocfg setting for IPv6 addr\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\n\t\t/* Autocfg applies to even interface */\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tif (iface_param->value[0] ==\n\t\t    ISCSI_IPV6_LINKLOCAL_AUTOCFG_ENABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts |= cpu_to_le16(\n\t\t\t\t\tIPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR);\n\t\telse if (iface_param->value[0] ==\n\t\t\t ISCSI_IPV6_LINKLOCAL_AUTOCFG_DISABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts &= cpu_to_le16(\n\t\t\t\t       ~IPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR);\n\t\telse\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"Invalid autocfg setting for IPv6 linklocal addr\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ROUTER_AUTOCFG:\n\t\t/* Autocfg applies to even interface */\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tif (iface_param->value[0] == ISCSI_IPV6_ROUTER_AUTOCFG_ENABLE)\n\t\t\tmemset(init_fw_cb->ipv6_dflt_rtr_addr, 0,\n\t\t\t       sizeof(init_fw_cb->ipv6_dflt_rtr_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (iface_param->value[0] == ISCSI_IFACE_ENABLE) {\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_IPV6_PROTOCOL_ENABLE);\n\t\t\tqla4xxx_create_ipv6_iface(ha);\n\t\t} else {\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_IPV6_PROTOCOL_ENABLE &\n\t\t\t\t\t    0xFFFF);\n\t\t\tqla4xxx_destroy_ipv6_iface(ha);\n\t\t}\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_TAG:\n\t\tif (iface_param->len != sizeof(init_fw_cb->ipv6_vlan_tag))\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_vlan_tag =\n\t\t\t\tcpu_to_be16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tif (iface_param->value[0] == ISCSI_VLAN_ENABLE)\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_VLAN_TAGGING_ENABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_VLAN_TAGGING_ENABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_MTU:\n\t\tinit_fw_cb->eth_mtu_size =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_PORT:\n\t\t/* Autocfg applies to even interface */\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tinit_fw_cb->ipv6_port =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_DELAYED_ACK_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_DELAYED_ACK_DISABLE &\n\t\t\t\t\t    0xFFFF);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_NAGLE_ALGO_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_NAGLE_ALGO_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_WINDOW_SCALE_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_WINDOW_SCALE_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_tcp_wsf = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_TIMER_SCALE);\n\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16((iface_param->value[0] << 1) &\n\t\t\t\t\t    IPV6_TCPOPT_TIMER_SCALE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_TIMESTAMP_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_TIMESTAMP_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_GRAT_NEIGHBOR_ADV_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_GRAT_NEIGHBOR_ADV_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_REDIRECT_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_REDIRECT_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_MLD_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts |=\n\t\t\t\tcpu_to_le16(IPV6_ADDOPT_MLD_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_addtl_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_ADDOPT_MLD_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_flow_lbl =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_traffic_class = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_hop_limit = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_nd_reach_time =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_nd_rexmit_timer =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_nd_stale_timeout =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_dup_addr_detect_count = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_gw_advrt_mtu =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Unknown IPv6 param = %d\\n\",\n\t\t\t   iface_param->param);\n\t\tbreak;\n\t}\n}\n\nstatic void qla4xxx_set_ipv4(struct scsi_qla_host *ha,\n\t\t\t     struct iscsi_iface_param_info *iface_param,\n\t\t\t     struct addr_ctrl_blk *init_fw_cb)\n{\n\tswitch (iface_param->param) {\n\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tmemcpy(init_fw_cb->ipv4_addr, iface_param->value,\n\t\t       sizeof(init_fw_cb->ipv4_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\tmemcpy(init_fw_cb->ipv4_subnet,\tiface_param->value,\n\t\t       sizeof(init_fw_cb->ipv4_subnet));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tmemcpy(init_fw_cb->ipv4_gw_addr, iface_param->value,\n\t\t       sizeof(init_fw_cb->ipv4_gw_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tif (iface_param->value[0] == ISCSI_BOOTPROTO_DHCP)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\t\tcpu_to_le16(TCPOPT_DHCP_ENABLE);\n\t\telse if (iface_param->value[0] == ISCSI_BOOTPROTO_STATIC)\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\t\tcpu_to_le16(~TCPOPT_DHCP_ENABLE);\n\t\telse\n\t\t\tql4_printk(KERN_ERR, ha, \"Invalid IPv4 bootproto\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (iface_param->value[0] == ISCSI_IFACE_ENABLE) {\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_IPV4_PROTOCOL_ENABLE);\n\t\t\tqla4xxx_create_ipv4_iface(ha);\n\t\t} else {\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_IPV4_PROTOCOL_ENABLE &\n\t\t\t\t\t    0xFFFF);\n\t\t\tqla4xxx_destroy_ipv4_iface(ha);\n\t\t}\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_TAG:\n\t\tif (iface_param->len != sizeof(init_fw_cb->ipv4_vlan_tag))\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_vlan_tag =\n\t\t\t\tcpu_to_be16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tif (iface_param->value[0] == ISCSI_VLAN_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_VLAN_TAGGING_ENABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_VLAN_TAGGING_ENABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_MTU:\n\t\tinit_fw_cb->eth_mtu_size =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_PORT:\n\t\tinit_fw_cb->ipv4_port =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_DELAYED_ACK_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_DELAYED_ACK_DISABLE &\n\t\t\t\t\t    0xFFFF);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_NAGLE_ALGO_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_NAGLE_ALGO_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_WINDOW_SCALE_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_WINDOW_SCALE_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_tcp_wsf = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_tcp_opts &= cpu_to_le16(~TCPOPT_TIMER_SCALE);\n\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16((iface_param->value[0] << 1) &\n\t\t\t\t\t    TCPOPT_TIMER_SCALE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_TIMESTAMP_ENABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_TIMESTAMP_ENABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_DNS_SERVER_IP_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_DNS_SERVER_IP_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_SLP_DA_INFO_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_SLP_DA_INFO_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_TOS_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_IPV4_TOS_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_IPV4_TOS_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_TOS:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_tos = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_GRAT_ARP_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_GRAT_ARP_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_ALT_CID_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_ALT_CID_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv4_dhcp_alt_cid, iface_param->value,\n\t\t       (sizeof(init_fw_cb->ipv4_dhcp_alt_cid) - 1));\n\t\tinit_fw_cb->ipv4_dhcp_alt_cid_len =\n\t\t\t\t\tstrlen(init_fw_cb->ipv4_dhcp_alt_cid);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_REQ_VID_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_REQ_VID_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_USE_VID_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_USE_VID_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv4_dhcp_vid, iface_param->value,\n\t\t       (sizeof(init_fw_cb->ipv4_dhcp_vid) - 1));\n\t\tinit_fw_cb->ipv4_dhcp_vid_len =\n\t\t\t\t\tstrlen(init_fw_cb->ipv4_dhcp_vid);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_LEARN_IQN_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_LEARN_IQN_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_FRAGMENTATION_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_FRAGMENTATION_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_IN_FORWARD_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_IN_FORWARD_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_ARP_REDIRECT_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_ARP_REDIRECT_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_TTL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_ttl = iface_param->value[0];\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Unknown IPv4 param = %d\\n\",\n\t\t\t   iface_param->param);\n\t\tbreak;\n\t}\n}\n\nstatic void qla4xxx_set_iscsi_param(struct scsi_qla_host *ha,\n\t\t\t\t    struct iscsi_iface_param_info *iface_param,\n\t\t\t\t    struct addr_ctrl_blk *init_fw_cb)\n{\n\tswitch (iface_param->param) {\n\tcase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->def_timeout =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_HDRDGST_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_HEADER_DIGEST_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_HEADER_DIGEST_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DATADGST_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DATA_DIGEST_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DATA_DIGEST_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_IMM_DATA_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_IMMEDIATE_DATA_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_IMMEDIATE_DATA_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_INITIAL_R2T_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_INITIAL_R2T_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DATA_SEQ_INORDER_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DATA_SEQ_INORDER_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DATA_PDU_INORDER_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DATA_PDU_INORDER_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_ERL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_opts &= cpu_to_le16(~ISCSIOPTS_ERL);\n\t\tinit_fw_cb->iscsi_opts |= cpu_to_le16(iface_param->value[0] &\n\t\t\t\t\t\t      ISCSIOPTS_ERL);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_max_pdu_size =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value) /\n\t\t\t\tBYTE_UNITS;\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_FIRST_BURST:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_fburst_len =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value) /\n\t\t\t\tBYTE_UNITS;\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_MAX_R2T:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_max_outstnd_r2t =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_MAX_BURST:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_max_burst_len =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value) /\n\t\t\t\tBYTE_UNITS;\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_CHAP_AUTH_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_CHAP_AUTH_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_BIDI_CHAP_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_BIDI_CHAP_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DISCOVERY_AUTH_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DISCOVERY_AUTH_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DISCOVERY_LOGOUT_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DISCOVERY_LOGOUT_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_STRICT_LOGIN_COMP_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_STRICT_LOGIN_COMP_EN);\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Unknown iscsi param = %d\\n\",\n\t\t\t   iface_param->param);\n\t\tbreak;\n\t}\n}\n\nstatic void\nqla4xxx_initcb_to_acb(struct addr_ctrl_blk *init_fw_cb)\n{\n\tstruct addr_ctrl_blk_def *acb;\n\tacb = (struct addr_ctrl_blk_def *)init_fw_cb;\n\tmemset(acb->reserved1, 0, sizeof(acb->reserved1));\n\tmemset(acb->reserved2, 0, sizeof(acb->reserved2));\n\tmemset(acb->reserved3, 0, sizeof(acb->reserved3));\n\tmemset(acb->reserved4, 0, sizeof(acb->reserved4));\n\tmemset(acb->reserved5, 0, sizeof(acb->reserved5));\n\tmemset(acb->reserved6, 0, sizeof(acb->reserved6));\n\tmemset(acb->reserved7, 0, sizeof(acb->reserved7));\n\tmemset(acb->reserved8, 0, sizeof(acb->reserved8));\n\tmemset(acb->reserved9, 0, sizeof(acb->reserved9));\n\tmemset(acb->reserved10, 0, sizeof(acb->reserved10));\n\tmemset(acb->reserved11, 0, sizeof(acb->reserved11));\n\tmemset(acb->reserved12, 0, sizeof(acb->reserved12));\n\tmemset(acb->reserved13, 0, sizeof(acb->reserved13));\n\tmemset(acb->reserved14, 0, sizeof(acb->reserved14));\n\tmemset(acb->reserved15, 0, sizeof(acb->reserved15));\n}\n\nstatic int\nqla4xxx_iface_set_param(struct Scsi_Host *shost, void *data, uint32_t len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint rval = 0;\n\tstruct iscsi_iface_param_info *iface_param = NULL;\n\tstruct addr_ctrl_blk *init_fw_cb = NULL;\n\tdma_addr_t init_fw_cb_dma;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tuint32_t rem = len;\n\tstruct nlattr *attr;\n\n\tinit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\tsizeof(struct addr_ctrl_blk),\n\t\t\t\t\t&init_fw_cb_dma, GFP_KERNEL);\n\tif (!init_fw_cb) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Unable to alloc init_cb\\n\",\n\t\t\t   __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: get ifcb failed\\n\", __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\tnla_for_each_attr(attr, data, len, rem) {\n\t\tiface_param = nla_data(attr);\n\n\t\tif (iface_param->param_type == ISCSI_NET_PARAM) {\n\t\t\tswitch (iface_param->iface_type) {\n\t\t\tcase ISCSI_IFACE_TYPE_IPV4:\n\t\t\t\tswitch (iface_param->iface_num) {\n\t\t\t\tcase 0:\n\t\t\t\t\tqla4xxx_set_ipv4(ha, iface_param,\n\t\t\t\t\t\t\t init_fw_cb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t/* Cannot have more than one IPv4 interface */\n\t\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t\t   \"Invalid IPv4 iface number = %d\\n\",\n\t\t\t\t\t\t   iface_param->iface_num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISCSI_IFACE_TYPE_IPV6:\n\t\t\t\tswitch (iface_param->iface_num) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tqla4xxx_set_ipv6(ha, iface_param,\n\t\t\t\t\t\t\t init_fw_cb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t/* Cannot have more than two IPv6 interface */\n\t\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t\t   \"Invalid IPv6 iface number = %d\\n\",\n\t\t\t\t\t\t   iface_param->iface_num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t   \"Invalid iface type\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (iface_param->param_type == ISCSI_IFACE_PARAM) {\n\t\t\t\tqla4xxx_set_iscsi_param(ha, iface_param,\n\t\t\t\t\t\t\tinit_fw_cb);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tinit_fw_cb->cookie = cpu_to_le32(0x11BEAD5A);\n\n\trval = qla4xxx_set_flash(ha, init_fw_cb_dma, FLASH_SEGMENT_IFCB,\n\t\t\t\t sizeof(struct addr_ctrl_blk),\n\t\t\t\t FLASH_OPT_RMW_COMMIT);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set flash mbx failed\\n\",\n\t\t\t   __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\trval = qla4xxx_disable_acb(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: disable acb mbx failed\\n\",\n\t\t\t   __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\twait_for_completion_timeout(&ha->disable_acb_comp,\n\t\t\t\t    DISABLE_ACB_TOV * HZ);\n\n\tqla4xxx_initcb_to_acb(init_fw_cb);\n\n\trval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set acb mbx failed\\n\",\n\t\t\t   __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\tmemset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));\n\tqla4xxx_update_local_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb,\n\t\t\t\t  init_fw_cb_dma);\n\nexit_init_fw_cb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\n\t\t\t  init_fw_cb, init_fw_cb_dma);\n\n\treturn rval;\n}\n\nstatic int qla4xxx_session_get_param(struct iscsi_cls_session *cls_sess,\n\t\t\t\t     enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_session *sess = cls_sess->dd_data;\n\tstruct ddb_entry *ddb_entry = sess->dd_data;\n\tstruct scsi_qla_host *ha = ddb_entry->ha;\n\tstruct iscsi_cls_conn *cls_conn = ddb_entry->conn;\n\tstruct ql4_chap_table chap_tbl;\n\tint rval, len;\n\tuint16_t idx;\n\n\tmemset(&chap_tbl, 0, sizeof(chap_tbl));\n\tswitch (param) {\n\tcase ISCSI_PARAM_CHAP_IN_IDX:\n\t\trval = qla4xxx_get_chap_index(ha, sess->username_in,\n\t\t\t\t\t      sess->password_in, BIDI_CHAP,\n\t\t\t\t\t      &idx);\n\t\tif (rval)\n\t\t\tlen = sprintf(buf, \"\\n\");\n\t\telse\n\t\t\tlen = sprintf(buf, \"%hu\\n\", idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_CHAP_OUT_IDX:\n\t\tif (ddb_entry->ddb_type == FLASH_DDB) {\n\t\t\tif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {\n\t\t\t\tidx = ddb_entry->chap_tbl_idx;\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t} else {\n\t\t\t\trval = QLA_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\trval = qla4xxx_get_chap_index(ha, sess->username,\n\t\t\t\t\t\t      sess->password,\n\t\t\t\t\t\t      LOCAL_CHAP, &idx);\n\t\t}\n\t\tif (rval)\n\t\t\tlen = sprintf(buf, \"\\n\");\n\t\telse\n\t\t\tlen = sprintf(buf, \"%hu\\n\", idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME:\n\tcase ISCSI_PARAM_PASSWORD:\n\t\t/* First, populate session username and password for FLASH DDB,\n\t\t * if not already done. This happens when session login fails\n\t\t * for a FLASH DDB.\n\t\t */\n\t\tif (ddb_entry->ddb_type == FLASH_DDB &&\n\t\t    ddb_entry->chap_tbl_idx != INVALID_ENTRY &&\n\t\t    !sess->username && !sess->password) {\n\t\t\tidx = ddb_entry->chap_tbl_idx;\n\t\t\trval = qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,\n\t\t\t\t\t\t\t    chap_tbl.secret,\n\t\t\t\t\t\t\t    idx);\n\t\t\tif (!rval) {\n\t\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,\n\t\t\t\t\t\t(char *)chap_tbl.name,\n\t\t\t\t\t\tstrlen((char *)chap_tbl.name));\n\t\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,\n\t\t\t\t\t\t(char *)chap_tbl.secret,\n\t\t\t\t\t\tchap_tbl.secret_len);\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn iscsi_session_get_param(cls_sess, param, buf);\n\t}\n\n\treturn len;\n}\n\nstatic int qla4xxx_conn_get_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t  enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_conn *conn;\n\tstruct qla_conn *qla_conn;\n\tstruct sockaddr *dst_addr;\n\n\tconn = cls_conn->dd_data;\n\tqla_conn = conn->dd_data;\n\tdst_addr = (struct sockaddr *)&qla_conn->qla_ep->dst_addr;\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t dst_addr, param, buf);\n\tdefault:\n\t\treturn iscsi_conn_get_param(cls_conn, param, buf);\n\t}\n}\n\nint qla4xxx_get_ddb_index(struct scsi_qla_host *ha, uint16_t *ddb_index)\n{\n\tuint32_t mbx_sts = 0;\n\tuint16_t tmp_ddb_index;\n\tint ret;\n\nget_ddb_index:\n\ttmp_ddb_index = find_first_zero_bit(ha->ddb_idx_map, MAX_DDB_ENTRIES);\n\n\tif (tmp_ddb_index >= MAX_DDB_ENTRIES) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Free DDB index not available\\n\"));\n\t\tret = QLA_ERROR;\n\t\tgoto exit_get_ddb_index;\n\t}\n\n\tif (test_and_set_bit(tmp_ddb_index, ha->ddb_idx_map))\n\t\tgoto get_ddb_index;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Found a free DDB index at %d\\n\", tmp_ddb_index));\n\tret = qla4xxx_req_ddb_entry(ha, tmp_ddb_index, &mbx_sts);\n\tif (ret == QLA_ERROR) {\n\t\tif (mbx_sts == MBOX_STS_COMMAND_ERROR) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"DDB index = %d not available trying next\\n\",\n\t\t\t\t   tmp_ddb_index);\n\t\t\tgoto get_ddb_index;\n\t\t}\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Free FW DDB not available\\n\"));\n\t}\n\n\t*ddb_index = tmp_ddb_index;\n\nexit_get_ddb_index:\n\treturn ret;\n}\n\nstatic int qla4xxx_match_ipaddress(struct scsi_qla_host *ha,\n\t\t\t\t   struct ddb_entry *ddb_entry,\n\t\t\t\t   char *existing_ipaddr,\n\t\t\t\t   char *user_ipaddr)\n{\n\tuint8_t dst_ipaddr[IPv6_ADDR_LEN];\n\tchar formatted_ipaddr[DDB_IPADDR_LEN];\n\tint status = QLA_SUCCESS, ret = 0;\n\n\tif (ddb_entry->fw_ddb_entry.options & DDB_OPT_IPV6_DEVICE) {\n\t\tret = in6_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,\n\t\t\t       '\\0', NULL);\n\t\tif (ret == 0) {\n\t\t\tstatus = QLA_ERROR;\n\t\t\tgoto out_match;\n\t\t}\n\t\tret = sprintf(formatted_ipaddr, \"%pI6\", dst_ipaddr);\n\t} else {\n\t\tret = in4_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,\n\t\t\t       '\\0', NULL);\n\t\tif (ret == 0) {\n\t\t\tstatus = QLA_ERROR;\n\t\t\tgoto out_match;\n\t\t}\n\t\tret = sprintf(formatted_ipaddr, \"%pI4\", dst_ipaddr);\n\t}\n\n\tif (strcmp(existing_ipaddr, formatted_ipaddr))\n\t\tstatus = QLA_ERROR;\n\nout_match:\n\treturn status;\n}\n\nstatic int qla4xxx_match_fwdb_session(struct scsi_qla_host *ha,\n\t\t\t\t      struct iscsi_cls_conn *cls_conn)\n{\n\tint idx = 0, max_ddbs, rval;\n\tstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\n\tstruct iscsi_session *sess, *existing_sess;\n\tstruct iscsi_conn *conn, *existing_conn;\n\tstruct ddb_entry *ddb_entry;\n\n\tsess = cls_sess->dd_data;\n\tconn = cls_conn->dd_data;\n\n\tif (sess->targetname == NULL ||\n\t    conn->persistent_address == NULL ||\n\t    conn->persistent_port == 0)\n\t\treturn QLA_ERROR;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tif (ddb_entry->ddb_type != FLASH_DDB)\n\t\t\tcontinue;\n\n\t\texisting_sess = ddb_entry->sess->dd_data;\n\t\texisting_conn = ddb_entry->conn->dd_data;\n\n\t\tif (existing_sess->targetname == NULL ||\n\t\t    existing_conn->persistent_address == NULL ||\n\t\t    existing_conn->persistent_port == 0)\n\t\t\tcontinue;\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"IQN = %s User IQN = %s\\n\",\n\t\t\t\t  existing_sess->targetname,\n\t\t\t\t  sess->targetname));\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"IP = %s User IP = %s\\n\",\n\t\t\t\t  existing_conn->persistent_address,\n\t\t\t\t  conn->persistent_address));\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Port = %d User Port = %d\\n\",\n\t\t\t\t  existing_conn->persistent_port,\n\t\t\t\t  conn->persistent_port));\n\n\t\tif (strcmp(existing_sess->targetname, sess->targetname))\n\t\t\tcontinue;\n\t\trval = qla4xxx_match_ipaddress(ha, ddb_entry,\n\t\t\t\t\texisting_conn->persistent_address,\n\t\t\t\t\tconn->persistent_address);\n\t\tif (rval == QLA_ERROR)\n\t\t\tcontinue;\n\t\tif (existing_conn->persistent_port != conn->persistent_port)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (idx == max_ddbs)\n\t\treturn QLA_ERROR;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Match found in fwdb sessions\\n\"));\n\treturn QLA_SUCCESS;\n}\n\nstatic struct iscsi_cls_session *\nqla4xxx_session_create(struct iscsi_endpoint *ep,\n\t\t\tuint16_t cmds_max, uint16_t qdepth,\n\t\t\tuint32_t initial_cmdsn)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct scsi_qla_host *ha;\n\tstruct qla_endpoint *qla_ep;\n\tstruct ddb_entry *ddb_entry;\n\tuint16_t ddb_index;\n\tstruct iscsi_session *sess;\n\tint ret;\n\n\tif (!ep) {\n\t\tprintk(KERN_ERR \"qla4xxx: missing ep.\\n\");\n\t\treturn NULL;\n\t}\n\n\tqla_ep = ep->dd_data;\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\n\tret = qla4xxx_get_ddb_index(ha, &ddb_index);\n\tif (ret == QLA_ERROR)\n\t\treturn NULL;\n\n\tcls_sess = iscsi_session_setup(&qla4xxx_iscsi_transport, qla_ep->host,\n\t\t\t\t       cmds_max, sizeof(struct ddb_entry),\n\t\t\t\t       sizeof(struct ql4_task_data),\n\t\t\t\t       initial_cmdsn, ddb_index);\n\tif (!cls_sess)\n\t\treturn NULL;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->fw_ddb_index = ddb_index;\n\tddb_entry->fw_ddb_device_state = DDB_DS_NO_CONNECTION_ACTIVE;\n\tddb_entry->ha = ha;\n\tddb_entry->sess = cls_sess;\n\tddb_entry->unblock_sess = qla4xxx_unblock_ddb;\n\tddb_entry->ddb_change = qla4xxx_ddb_change;\n\tclear_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags);\n\tcls_sess->recovery_tmo = ql4xsess_recovery_tmo;\n\tha->fw_ddb_index_map[ddb_entry->fw_ddb_index] = ddb_entry;\n\tha->tot_ddbs++;\n\n\treturn cls_sess;\n}\n\nstatic void qla4xxx_session_destroy(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tunsigned long flags, wtime;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t ddb_state;\n\tint ret;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto destroy_session;\n\t}\n\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t      fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t      NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t      NULL, NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto destroy_session;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\tgoto destroy_session;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\ndestroy_session:\n\tqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\n\tif (test_and_clear_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags))\n\t\tclear_bit(ddb_entry->fw_ddb_index, ha->ddb_idx_map);\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqla4xxx_free_ddb(ha, ddb_entry);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tiscsi_session_teardown(cls_sess);\n\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\nstatic struct iscsi_cls_conn *\nqla4xxx_conn_create(struct iscsi_cls_session *cls_sess, uint32_t conn_idx)\n{\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tcls_conn = iscsi_conn_setup(cls_sess, sizeof(struct qla_conn),\n\t\t\t\t    conn_idx);\n\tif (!cls_conn) {\n\t\tpr_info(\"%s: Can not create connection for conn_idx = %u\\n\",\n\t\t\t__func__, conn_idx);\n\t\treturn NULL;\n\t}\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->conn = cls_conn;\n\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: conn_idx = %u\\n\", __func__,\n\t\t\t  conn_idx));\n\treturn cls_conn;\n}\n\nstatic int qla4xxx_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t     struct iscsi_cls_conn *cls_conn,\n\t\t\t     uint64_t transport_fd, int is_leading)\n{\n\tstruct iscsi_conn *conn;\n\tstruct qla_conn *qla_conn;\n\tstruct iscsi_endpoint *ep;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct iscsi_session *sess;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: sid = %d, cid = %d\\n\", __func__,\n\t\t\t  cls_session->sid, cls_conn->cid));\n\n\tif (iscsi_conn_bind(cls_session, cls_conn, is_leading))\n\t\treturn -EINVAL;\n\tep = iscsi_lookup_endpoint(transport_fd);\n\tif (!ep)\n\t\treturn -EINVAL;\n\tconn = cls_conn->dd_data;\n\tqla_conn = conn->dd_data;\n\tqla_conn->qla_ep = ep->dd_data;\n\treturn 0;\n}\n\nstatic int qla4xxx_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t mbx_sts = 0;\n\tint ret = 0;\n\tint status = QLA_SUCCESS;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: sid = %d, cid = %d\\n\", __func__,\n\t\t\t  cls_sess->sid, cls_conn->cid));\n\n\t/* Check if we have  matching FW DDB, if yes then do not\n\t * login to this target. This could cause target to logout previous\n\t * connection\n\t */\n\tret = qla4xxx_match_fwdb_session(ha, cls_conn);\n\tif (ret == QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"Session already exist in FW.\\n\");\n\t\tret = -EEXIST;\n\t\tgoto exit_conn_start;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_conn_start;\n\t}\n\n\tret = qla4xxx_set_param_ddbentry(ha, ddb_entry, cls_conn, &mbx_sts);\n\tif (ret) {\n\t\t/* If iscsid is stopped and started then no need to do\n\t\t* set param again since ddb state will be already\n\t\t* active and FW does not allow set ddb to an\n\t\t* active session.\n\t\t*/\n\t\tif (mbx_sts)\n\t\t\tif (ddb_entry->fw_ddb_device_state ==\n\t\t\t\t\t\tDDB_DS_SESSION_ACTIVE) {\n\t\t\t\tddb_entry->unblock_sess(ddb_entry->sess);\n\t\t\t\tgoto exit_set_param;\n\t\t\t}\n\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed set param for index[%d]\\n\",\n\t\t\t   __func__, ddb_entry->fw_ddb_index);\n\t\tgoto exit_conn_start;\n\t}\n\n\tstatus = qla4xxx_conn_open(ha, ddb_entry->fw_ddb_index);\n\tif (status == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Login failed: %s\\n\", __func__,\n\t\t\t   sess->targetname);\n\t\tret = -EINVAL;\n\t\tgoto exit_conn_start;\n\t}\n\n\tif (ddb_entry->fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE)\n\t\tddb_entry->fw_ddb_device_state = DDB_DS_LOGIN_IN_PROCESS;\n\n\tDEBUG2(printk(KERN_INFO \"%s: DDB state [%d]\\n\", __func__,\n\t\t      ddb_entry->fw_ddb_device_state));\n\nexit_set_param:\n\tret = 0;\n\nexit_conn_start:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\nstatic void qla4xxx_conn_destroy(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\n\tstruct iscsi_session *sess;\n\tstruct scsi_qla_host *ha;\n\tstruct ddb_entry *ddb_entry;\n\tint options;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: cid = %d\\n\", __func__,\n\t\t\t  cls_conn->cid));\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR)\n\t\tql4_printk(KERN_ERR, ha, \"%s: Logout failed\\n\", __func__);\n}\n\nstatic void qla4xxx_task_work(struct work_struct *wdata)\n{\n\tstruct ql4_task_data *task_data;\n\tstruct scsi_qla_host *ha;\n\tstruct passthru_status *sts;\n\tstruct iscsi_task *task;\n\tstruct iscsi_hdr *hdr;\n\tuint8_t *data;\n\tuint32_t data_len;\n\tstruct iscsi_conn *conn;\n\tint hdr_len;\n\titt_t itt;\n\n\ttask_data = container_of(wdata, struct ql4_task_data, task_work);\n\tha = task_data->ha;\n\ttask = task_data->task;\n\tsts = &task_data->sts;\n\thdr_len = sizeof(struct iscsi_hdr);\n\n\tDEBUG3(printk(KERN_INFO \"Status returned\\n\"));\n\tDEBUG3(qla4xxx_dump_buffer(sts, 64));\n\tDEBUG3(printk(KERN_INFO \"Response buffer\"));\n\tDEBUG3(qla4xxx_dump_buffer(task_data->resp_buffer, 64));\n\n\tconn = task->conn;\n\n\tswitch (sts->completionStatus) {\n\tcase PASSTHRU_STATUS_COMPLETE:\n\t\thdr = (struct iscsi_hdr *)task_data->resp_buffer;\n\t\t/* Assign back the itt in hdr, until we use the PREASSIGN_TAG */\n\t\titt = sts->handle;\n\t\thdr->itt = itt;\n\t\tdata = task_data->resp_buffer + hdr_len;\n\t\tdata_len = task_data->resp_len - hdr_len;\n\t\tiscsi_complete_pdu(conn, hdr, data, data_len);\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Passthru failed status = 0x%x\\n\",\n\t\t\t   sts->completionStatus);\n\t\tbreak;\n\t}\n\treturn;\n}\n\nstatic int qla4xxx_alloc_pdu(struct iscsi_task *task, uint8_t opcode)\n{\n\tstruct ql4_task_data *task_data;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tint hdr_len;\n\n\tsess = task->conn->session;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\ttask_data = task->dd_data;\n\tmemset(task_data, 0, sizeof(struct ql4_task_data));\n\n\tif (task->sc) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: SCSI Commands not implemented\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thdr_len = sizeof(struct iscsi_hdr);\n\ttask_data->ha = ha;\n\ttask_data->task = task;\n\n\tif (task->data_count) {\n\t\ttask_data->data_dma = dma_map_single(&ha->pdev->dev, task->data,\n\t\t\t\t\t\t     task->data_count,\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: MaxRecvLen %u, iscsi hrd %d\\n\",\n\t\t      __func__, task->conn->max_recv_dlength, hdr_len));\n\n\ttask_data->resp_len = task->conn->max_recv_dlength + hdr_len;\n\ttask_data->resp_buffer = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t\t    task_data->resp_len,\n\t\t\t\t\t\t    &task_data->resp_dma,\n\t\t\t\t\t\t    GFP_ATOMIC);\n\tif (!task_data->resp_buffer)\n\t\tgoto exit_alloc_pdu;\n\n\ttask_data->req_len = task->data_count + hdr_len;\n\ttask_data->req_buffer = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t\t   task_data->req_len,\n\t\t\t\t\t\t   &task_data->req_dma,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (!task_data->req_buffer)\n\t\tgoto exit_alloc_pdu;\n\n\ttask->hdr = task_data->req_buffer;\n\n\tINIT_WORK(&task_data->task_work, qla4xxx_task_work);\n\n\treturn 0;\n\nexit_alloc_pdu:\n\tif (task_data->resp_buffer)\n\t\tdma_free_coherent(&ha->pdev->dev, task_data->resp_len,\n\t\t\t\t  task_data->resp_buffer, task_data->resp_dma);\n\n\tif (task_data->req_buffer)\n\t\tdma_free_coherent(&ha->pdev->dev, task_data->req_len,\n\t\t\t\t  task_data->req_buffer, task_data->req_dma);\n\treturn -ENOMEM;\n}\n\nstatic void qla4xxx_task_cleanup(struct iscsi_task *task)\n{\n\tstruct ql4_task_data *task_data;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tint hdr_len;\n\n\thdr_len = sizeof(struct iscsi_hdr);\n\tsess = task->conn->session;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\ttask_data = task->dd_data;\n\n\tif (task->data_count) {\n\t\tdma_unmap_single(&ha->pdev->dev, task_data->data_dma,\n\t\t\t\t task->data_count, DMA_TO_DEVICE);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: MaxRecvLen %u, iscsi hrd %d\\n\",\n\t\t      __func__, task->conn->max_recv_dlength, hdr_len));\n\n\tdma_free_coherent(&ha->pdev->dev, task_data->resp_len,\n\t\t\t  task_data->resp_buffer, task_data->resp_dma);\n\tdma_free_coherent(&ha->pdev->dev, task_data->req_len,\n\t\t\t  task_data->req_buffer, task_data->req_dma);\n\treturn;\n}\n\nstatic int qla4xxx_task_xmit(struct iscsi_task *task)\n{\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct iscsi_session *sess = task->conn->session;\n\tstruct ddb_entry *ddb_entry = sess->dd_data;\n\tstruct scsi_qla_host *ha = ddb_entry->ha;\n\n\tif (!sc)\n\t\treturn qla4xxx_send_passthru0(task);\n\n\tql4_printk(KERN_INFO, ha, \"%s: scsi cmd xmit not implemented\\n\",\n\t\t   __func__);\n\treturn -ENOSYS;\n}\n\nstatic int qla4xxx_copy_from_fwddb_param(struct iscsi_bus_flash_session *sess,\n\t\t\t\t\t struct iscsi_bus_flash_conn *conn,\n\t\t\t\t\t struct dev_db_entry *fw_ddb_entry)\n{\n\tunsigned long options = 0;\n\tint rc = 0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tconn->is_fw_assigned_ipv6 = test_bit(OPT_IS_FW_ASSIGNED_IPV6, &options);\n\tif (test_bit(OPT_IPV6_DEVICE, &options)) {\n\t\trc = iscsi_switch_str_param(&sess->portal_type,\n\t\t\t\t\t    PORTAL_TYPE_IPV6);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t} else {\n\t\trc = iscsi_switch_str_param(&sess->portal_type,\n\t\t\t\t\t    PORTAL_TYPE_IPV4);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t}\n\n\tsess->auto_snd_tgt_disable = test_bit(OPT_AUTO_SENDTGTS_DISABLE,\n\t\t\t\t\t      &options);\n\tsess->discovery_sess = test_bit(OPT_DISC_SESSION, &options);\n\tsess->entry_state = test_bit(OPT_ENTRY_STATE, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tconn->hdrdgst_en = test_bit(ISCSIOPT_HEADER_DIGEST_EN, &options);\n\tconn->datadgst_en = test_bit(ISCSIOPT_DATA_DIGEST_EN, &options);\n\tsess->imm_data_en = test_bit(ISCSIOPT_IMMEDIATE_DATA_EN, &options);\n\tsess->initial_r2t_en = test_bit(ISCSIOPT_INITIAL_R2T_EN, &options);\n\tsess->dataseq_inorder_en = test_bit(ISCSIOPT_DATA_SEQ_IN_ORDER,\n\t\t\t\t\t    &options);\n\tsess->pdu_inorder_en = test_bit(ISCSIOPT_DATA_PDU_IN_ORDER, &options);\n\tsess->chap_auth_en = test_bit(ISCSIOPT_CHAP_AUTH_EN, &options);\n\tconn->snack_req_en = test_bit(ISCSIOPT_SNACK_REQ_EN, &options);\n\tsess->discovery_logout_en = test_bit(ISCSIOPT_DISCOVERY_LOGOUT_EN,\n\t\t\t\t\t     &options);\n\tsess->bidi_chap_en = test_bit(ISCSIOPT_BIDI_CHAP_EN, &options);\n\tsess->discovery_auth_optional =\n\t\t\ttest_bit(ISCSIOPT_DISCOVERY_AUTH_OPTIONAL, &options);\n\tif (test_bit(ISCSIOPT_ERL1, &options))\n\t\tsess->erl |= BIT_1;\n\tif (test_bit(ISCSIOPT_ERL0, &options))\n\t\tsess->erl |= BIT_0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->tcp_options);\n\tconn->tcp_timestamp_stat = test_bit(TCPOPT_TIMESTAMP_STAT, &options);\n\tconn->tcp_nagle_disable = test_bit(TCPOPT_NAGLE_DISABLE, &options);\n\tconn->tcp_wsf_disable = test_bit(TCPOPT_WSF_DISABLE, &options);\n\tif (test_bit(TCPOPT_TIMER_SCALE3, &options))\n\t\tconn->tcp_timer_scale |= BIT_3;\n\tif (test_bit(TCPOPT_TIMER_SCALE2, &options))\n\t\tconn->tcp_timer_scale |= BIT_2;\n\tif (test_bit(TCPOPT_TIMER_SCALE1, &options))\n\t\tconn->tcp_timer_scale |= BIT_1;\n\n\tconn->tcp_timer_scale >>= 1;\n\tconn->tcp_timestamp_en = test_bit(TCPOPT_TIMESTAMP_EN, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->ip_options);\n\tconn->fragment_disable = test_bit(IPOPT_FRAGMENT_DISABLE, &options);\n\n\tconn->max_recv_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_rcv_data_seg_len);\n\tconn->max_xmit_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_snd_data_seg_len);\n\tsess->first_burst = BYTE_UNITS *\n\t\t\t       le16_to_cpu(fw_ddb_entry->iscsi_first_burst_len);\n\tsess->max_burst = BYTE_UNITS *\n\t\t\t\t le16_to_cpu(fw_ddb_entry->iscsi_max_burst_len);\n\tsess->max_r2t = le16_to_cpu(fw_ddb_entry->iscsi_max_outsnd_r2t);\n\tsess->time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\n\tsess->time2retain = le16_to_cpu(fw_ddb_entry->iscsi_def_time2retain);\n\tsess->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\n\tconn->max_segment_size = le16_to_cpu(fw_ddb_entry->mss);\n\tconn->tcp_xmit_wsf = fw_ddb_entry->tcp_xmt_wsf;\n\tconn->tcp_recv_wsf = fw_ddb_entry->tcp_rcv_wsf;\n\tconn->ipv6_flow_label = le16_to_cpu(fw_ddb_entry->ipv6_flow_lbl);\n\tconn->keepalive_timeout = le16_to_cpu(fw_ddb_entry->ka_timeout);\n\tconn->local_port = le16_to_cpu(fw_ddb_entry->lcl_port);\n\tconn->statsn = le32_to_cpu(fw_ddb_entry->stat_sn);\n\tconn->exp_statsn = le32_to_cpu(fw_ddb_entry->exp_stat_sn);\n\tsess->discovery_parent_idx = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tsess->discovery_parent_type = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tsess->chap_out_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\tsess->tsid = le16_to_cpu(fw_ddb_entry->tsid);\n\n\tsess->default_taskmgmt_timeout =\n\t\t\t\tle16_to_cpu(fw_ddb_entry->def_timeout);\n\tconn->port = le16_to_cpu(fw_ddb_entry->port);\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tconn->ipaddress = kzalloc(IPv6_ADDR_LEN, GFP_KERNEL);\n\tif (!conn->ipaddress) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_copy;\n\t}\n\n\tconn->redirect_ipaddr = kzalloc(IPv6_ADDR_LEN, GFP_KERNEL);\n\tif (!conn->redirect_ipaddr) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_copy;\n\t}\n\n\tmemcpy(conn->ipaddress, fw_ddb_entry->ip_addr, IPv6_ADDR_LEN);\n\tmemcpy(conn->redirect_ipaddr, fw_ddb_entry->tgt_addr, IPv6_ADDR_LEN);\n\n\tif (test_bit(OPT_IPV6_DEVICE, &options)) {\n\t\tconn->ipv6_traffic_class = fw_ddb_entry->ipv4_tos;\n\n\t\tconn->link_local_ipv6_addr = kmemdup(\n\t\t\t\t\tfw_ddb_entry->link_local_ipv6_addr,\n\t\t\t\t\tIPv6_ADDR_LEN, GFP_KERNEL);\n\t\tif (!conn->link_local_ipv6_addr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit_copy;\n\t\t}\n\t} else {\n\t\tconn->ipv4_tos = fw_ddb_entry->ipv4_tos;\n\t}\n\n\tif (fw_ddb_entry->iscsi_name[0]) {\n\t\trc = iscsi_switch_str_param(&sess->targetname,\n\t\t\t\t\t    (char *)fw_ddb_entry->iscsi_name);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t}\n\n\tif (fw_ddb_entry->iscsi_alias[0]) {\n\t\trc = iscsi_switch_str_param(&sess->targetalias,\n\t\t\t\t\t    (char *)fw_ddb_entry->iscsi_alias);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t}\n\n\tCOPY_ISID(sess->isid, fw_ddb_entry->isid);\n\nexit_copy:\n\treturn rc;\n}\n\nstatic int qla4xxx_copy_to_fwddb_param(struct iscsi_bus_flash_session *sess,\n\t\t\t\t       struct iscsi_bus_flash_conn *conn,\n\t\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tuint16_t options;\n\tint rc = 0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tSET_BITVAL(conn->is_fw_assigned_ipv6,  options, BIT_11);\n\tif (!strncmp(sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\toptions |= BIT_8;\n\telse\n\t\toptions &= ~BIT_8;\n\n\tSET_BITVAL(sess->auto_snd_tgt_disable, options, BIT_6);\n\tSET_BITVAL(sess->discovery_sess, options, BIT_4);\n\tSET_BITVAL(sess->entry_state, options, BIT_3);\n\tfw_ddb_entry->options = cpu_to_le16(options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tSET_BITVAL(conn->hdrdgst_en, options, BIT_13);\n\tSET_BITVAL(conn->datadgst_en, options, BIT_12);\n\tSET_BITVAL(sess->imm_data_en, options, BIT_11);\n\tSET_BITVAL(sess->initial_r2t_en, options, BIT_10);\n\tSET_BITVAL(sess->dataseq_inorder_en, options, BIT_9);\n\tSET_BITVAL(sess->pdu_inorder_en, options, BIT_8);\n\tSET_BITVAL(sess->chap_auth_en, options, BIT_7);\n\tSET_BITVAL(conn->snack_req_en, options, BIT_6);\n\tSET_BITVAL(sess->discovery_logout_en, options, BIT_5);\n\tSET_BITVAL(sess->bidi_chap_en, options, BIT_4);\n\tSET_BITVAL(sess->discovery_auth_optional, options, BIT_3);\n\tSET_BITVAL(sess->erl & BIT_1, options, BIT_1);\n\tSET_BITVAL(sess->erl & BIT_0, options, BIT_0);\n\tfw_ddb_entry->iscsi_options = cpu_to_le16(options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->tcp_options);\n\tSET_BITVAL(conn->tcp_timestamp_stat, options, BIT_6);\n\tSET_BITVAL(conn->tcp_nagle_disable, options, BIT_5);\n\tSET_BITVAL(conn->tcp_wsf_disable, options, BIT_4);\n\tSET_BITVAL(conn->tcp_timer_scale & BIT_2, options, BIT_3);\n\tSET_BITVAL(conn->tcp_timer_scale & BIT_1, options, BIT_2);\n\tSET_BITVAL(conn->tcp_timer_scale & BIT_0, options, BIT_1);\n\tSET_BITVAL(conn->tcp_timestamp_en, options, BIT_0);\n\tfw_ddb_entry->tcp_options = cpu_to_le16(options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->ip_options);\n\tSET_BITVAL(conn->fragment_disable, options, BIT_4);\n\tfw_ddb_entry->ip_options = cpu_to_le16(options);\n\n\tfw_ddb_entry->iscsi_max_outsnd_r2t = cpu_to_le16(sess->max_r2t);\n\tfw_ddb_entry->iscsi_max_rcv_data_seg_len =\n\t\t\t       cpu_to_le16(conn->max_recv_dlength / BYTE_UNITS);\n\tfw_ddb_entry->iscsi_max_snd_data_seg_len =\n\t\t\t       cpu_to_le16(conn->max_xmit_dlength / BYTE_UNITS);\n\tfw_ddb_entry->iscsi_first_burst_len =\n\t\t\t\tcpu_to_le16(sess->first_burst / BYTE_UNITS);\n\tfw_ddb_entry->iscsi_max_burst_len = cpu_to_le16(sess->max_burst /\n\t\t\t\t\t    BYTE_UNITS);\n\tfw_ddb_entry->iscsi_def_time2wait = cpu_to_le16(sess->time2wait);\n\tfw_ddb_entry->iscsi_def_time2retain = cpu_to_le16(sess->time2retain);\n\tfw_ddb_entry->tgt_portal_grp = cpu_to_le16(sess->tpgt);\n\tfw_ddb_entry->mss = cpu_to_le16(conn->max_segment_size);\n\tfw_ddb_entry->tcp_xmt_wsf = (uint8_t) cpu_to_le32(conn->tcp_xmit_wsf);\n\tfw_ddb_entry->tcp_rcv_wsf = (uint8_t) cpu_to_le32(conn->tcp_recv_wsf);\n\tfw_ddb_entry->ipv6_flow_lbl = cpu_to_le16(conn->ipv6_flow_label);\n\tfw_ddb_entry->ka_timeout = cpu_to_le16(conn->keepalive_timeout);\n\tfw_ddb_entry->lcl_port = cpu_to_le16(conn->local_port);\n\tfw_ddb_entry->stat_sn = cpu_to_le32(conn->statsn);\n\tfw_ddb_entry->exp_stat_sn = cpu_to_le32(conn->exp_statsn);\n\tfw_ddb_entry->ddb_link = cpu_to_le16(sess->discovery_parent_idx);\n\tfw_ddb_entry->chap_tbl_idx = cpu_to_le16(sess->chap_out_idx);\n\tfw_ddb_entry->tsid = cpu_to_le16(sess->tsid);\n\tfw_ddb_entry->port = cpu_to_le16(conn->port);\n\tfw_ddb_entry->def_timeout =\n\t\t\t\tcpu_to_le16(sess->default_taskmgmt_timeout);\n\n\tif (!strncmp(sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\tfw_ddb_entry->ipv4_tos = conn->ipv6_traffic_class;\n\telse\n\t\tfw_ddb_entry->ipv4_tos = conn->ipv4_tos;\n\n\tif (conn->ipaddress)\n\t\tmemcpy(fw_ddb_entry->ip_addr, conn->ipaddress,\n\t\t       sizeof(fw_ddb_entry->ip_addr));\n\n\tif (conn->redirect_ipaddr)\n\t\tmemcpy(fw_ddb_entry->tgt_addr, conn->redirect_ipaddr,\n\t\t       sizeof(fw_ddb_entry->tgt_addr));\n\n\tif (conn->link_local_ipv6_addr)\n\t\tmemcpy(fw_ddb_entry->link_local_ipv6_addr,\n\t\t       conn->link_local_ipv6_addr,\n\t\t       sizeof(fw_ddb_entry->link_local_ipv6_addr));\n\n\tif (sess->targetname)\n\t\tmemcpy(fw_ddb_entry->iscsi_name, sess->targetname,\n\t\t       sizeof(fw_ddb_entry->iscsi_name));\n\n\tif (sess->targetalias)\n\t\tmemcpy(fw_ddb_entry->iscsi_alias, sess->targetalias,\n\t\t       sizeof(fw_ddb_entry->iscsi_alias));\n\n\tCOPY_ISID(fw_ddb_entry->isid, sess->isid);\n\n\treturn rc;\n}\n\nstatic void qla4xxx_copy_to_sess_conn_params(struct iscsi_conn *conn,\n\t\t\t\t\t     struct iscsi_session *sess,\n\t\t\t\t\t     struct dev_db_entry *fw_ddb_entry)\n{\n\tunsigned long options = 0;\n\tuint16_t ddb_link;\n\tuint16_t disc_parent;\n\tchar ip_addr[DDB_IPADDR_LEN];\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tconn->is_fw_assigned_ipv6 = test_bit(OPT_IS_FW_ASSIGNED_IPV6, &options);\n\tsess->auto_snd_tgt_disable = test_bit(OPT_AUTO_SENDTGTS_DISABLE,\n\t\t\t\t\t      &options);\n\tsess->discovery_sess = test_bit(OPT_DISC_SESSION, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tconn->hdrdgst_en = test_bit(ISCSIOPT_HEADER_DIGEST_EN, &options);\n\tconn->datadgst_en = test_bit(ISCSIOPT_DATA_DIGEST_EN, &options);\n\tsess->imm_data_en = test_bit(ISCSIOPT_IMMEDIATE_DATA_EN, &options);\n\tsess->initial_r2t_en = test_bit(ISCSIOPT_INITIAL_R2T_EN, &options);\n\tsess->dataseq_inorder_en = test_bit(ISCSIOPT_DATA_SEQ_IN_ORDER,\n\t\t\t\t\t    &options);\n\tsess->pdu_inorder_en = test_bit(ISCSIOPT_DATA_PDU_IN_ORDER, &options);\n\tsess->chap_auth_en = test_bit(ISCSIOPT_CHAP_AUTH_EN, &options);\n\tsess->discovery_logout_en = test_bit(ISCSIOPT_DISCOVERY_LOGOUT_EN,\n\t\t\t\t\t     &options);\n\tsess->bidi_chap_en = test_bit(ISCSIOPT_BIDI_CHAP_EN, &options);\n\tsess->discovery_auth_optional =\n\t\t\ttest_bit(ISCSIOPT_DISCOVERY_AUTH_OPTIONAL, &options);\n\tif (test_bit(ISCSIOPT_ERL1, &options))\n\t\tsess->erl |= BIT_1;\n\tif (test_bit(ISCSIOPT_ERL0, &options))\n\t\tsess->erl |= BIT_0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->tcp_options);\n\tconn->tcp_timestamp_stat = test_bit(TCPOPT_TIMESTAMP_STAT, &options);\n\tconn->tcp_nagle_disable = test_bit(TCPOPT_NAGLE_DISABLE, &options);\n\tconn->tcp_wsf_disable = test_bit(TCPOPT_WSF_DISABLE, &options);\n\tif (test_bit(TCPOPT_TIMER_SCALE3, &options))\n\t\tconn->tcp_timer_scale |= BIT_3;\n\tif (test_bit(TCPOPT_TIMER_SCALE2, &options))\n\t\tconn->tcp_timer_scale |= BIT_2;\n\tif (test_bit(TCPOPT_TIMER_SCALE1, &options))\n\t\tconn->tcp_timer_scale |= BIT_1;\n\n\tconn->tcp_timer_scale >>= 1;\n\tconn->tcp_timestamp_en = test_bit(TCPOPT_TIMESTAMP_EN, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->ip_options);\n\tconn->fragment_disable = test_bit(IPOPT_FRAGMENT_DISABLE, &options);\n\n\tconn->max_recv_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_rcv_data_seg_len);\n\tconn->max_xmit_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_snd_data_seg_len);\n\tsess->max_r2t = le16_to_cpu(fw_ddb_entry->iscsi_max_outsnd_r2t);\n\tsess->first_burst = BYTE_UNITS *\n\t\t\t       le16_to_cpu(fw_ddb_entry->iscsi_first_burst_len);\n\tsess->max_burst = BYTE_UNITS *\n\t\t\t\t le16_to_cpu(fw_ddb_entry->iscsi_max_burst_len);\n\tsess->time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\n\tsess->time2retain = le16_to_cpu(fw_ddb_entry->iscsi_def_time2retain);\n\tsess->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\n\tconn->max_segment_size = le16_to_cpu(fw_ddb_entry->mss);\n\tconn->tcp_xmit_wsf = fw_ddb_entry->tcp_xmt_wsf;\n\tconn->tcp_recv_wsf = fw_ddb_entry->tcp_rcv_wsf;\n\tconn->ipv4_tos = fw_ddb_entry->ipv4_tos;\n\tconn->keepalive_tmo = le16_to_cpu(fw_ddb_entry->ka_timeout);\n\tconn->local_port = le16_to_cpu(fw_ddb_entry->lcl_port);\n\tconn->statsn = le32_to_cpu(fw_ddb_entry->stat_sn);\n\tconn->exp_statsn = le32_to_cpu(fw_ddb_entry->exp_stat_sn);\n\tsess->tsid = le16_to_cpu(fw_ddb_entry->tsid);\n\tCOPY_ISID(sess->isid, fw_ddb_entry->isid);\n\n\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tif (ddb_link == DDB_ISNS)\n\t\tdisc_parent = ISCSI_DISC_PARENT_ISNS;\n\telse if (ddb_link == DDB_NO_LINK)\n\t\tdisc_parent = ISCSI_DISC_PARENT_UNKNOWN;\n\telse if (ddb_link < MAX_DDB_ENTRIES)\n\t\tdisc_parent = ISCSI_DISC_PARENT_SENDTGT;\n\telse\n\t\tdisc_parent = ISCSI_DISC_PARENT_UNKNOWN;\n\n\tiscsi_set_param(conn->cls_conn, ISCSI_PARAM_DISCOVERY_PARENT_TYPE,\n\t\t\tiscsi_get_discovery_parent_name(disc_parent), 0);\n\n\tiscsi_set_param(conn->cls_conn, ISCSI_PARAM_TARGET_ALIAS,\n\t\t\t(char *)fw_ddb_entry->iscsi_alias, 0);\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\tmemset(ip_addr, 0, sizeof(ip_addr));\n\t\tsprintf(ip_addr, \"%pI6\", fw_ddb_entry->link_local_ipv6_addr);\n\t\tiscsi_set_param(conn->cls_conn, ISCSI_PARAM_LOCAL_IPADDR,\n\t\t\t\t(char *)ip_addr, 0);\n\t}\n}\n\nstatic void qla4xxx_copy_fwddb_param(struct scsi_qla_host *ha,\n\t\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t     struct iscsi_cls_session *cls_sess,\n\t\t\t\t     struct iscsi_cls_conn *cls_conn)\n{\n\tint buflen = 0;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct ql4_chap_table chap_tbl;\n\tstruct iscsi_conn *conn;\n\tchar ip_addr[DDB_IPADDR_LEN];\n\tuint16_t options = 0;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tconn = cls_conn->dd_data;\n\tmemset(&chap_tbl, 0, sizeof(chap_tbl));\n\n\tddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\n\tqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);\n\n\tsess->def_taskmgmt_tmo = le16_to_cpu(fw_ddb_entry->def_timeout);\n\tconn->persistent_port = le16_to_cpu(fw_ddb_entry->port);\n\n\tmemset(ip_addr, 0, sizeof(ip_addr));\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, \"ipv6\", 4);\n\n\t\tmemset(ip_addr, 0, sizeof(ip_addr));\n\t\tsprintf(ip_addr, \"%pI6\", fw_ddb_entry->ip_addr);\n\t} else {\n\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, \"ipv4\", 4);\n\t\tsprintf(ip_addr, \"%pI4\", fw_ddb_entry->ip_addr);\n\t}\n\n\tiscsi_set_param(cls_conn, ISCSI_PARAM_PERSISTENT_ADDRESS,\n\t\t\t(char *)ip_addr, buflen);\n\tiscsi_set_param(cls_conn, ISCSI_PARAM_TARGET_NAME,\n\t\t\t(char *)fw_ddb_entry->iscsi_name, buflen);\n\tiscsi_set_param(cls_conn, ISCSI_PARAM_INITIATOR_NAME,\n\t\t\t(char *)ha->name_string, buflen);\n\n\tif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {\n\t\tif (!qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,\n\t\t\t\t\t\t   chap_tbl.secret,\n\t\t\t\t\t\t   ddb_entry->chap_tbl_idx)) {\n\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,\n\t\t\t\t\t(char *)chap_tbl.name,\n\t\t\t\t\tstrlen((char *)chap_tbl.name));\n\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,\n\t\t\t\t\t(char *)chap_tbl.secret,\n\t\t\t\t\tchap_tbl.secret_len);\n\t\t}\n\t}\n}\n\nvoid qla4xxx_update_session_conn_fwddb_param(struct scsi_qla_host *ha,\n\t\t\t\t\t     struct ddb_entry *ddb_entry)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tuint32_t ddb_state;\n\tdma_addr_t fw_ddb_entry_dma;\n\tstruct dev_db_entry *fw_ddb_entry;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto exit_session_conn_fwddb_param;\n\t}\n\n\tif (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, fw_ddb_entry,\n\t\t\t\t    fw_ddb_entry_dma, NULL, NULL, &ddb_state,\n\t\t\t\t    NULL, NULL, NULL) == QLA_ERROR) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"get_ddb_entry for fw_ddb_index %d\\n\",\n\t\t\t\t  ha->host_no, __func__,\n\t\t\t\t  ddb_entry->fw_ddb_index));\n\t\tgoto exit_session_conn_fwddb_param;\n\t}\n\n\tcls_sess = ddb_entry->sess;\n\n\tcls_conn = ddb_entry->conn;\n\n\t/* Update params */\n\tqla4xxx_copy_fwddb_param(ha, fw_ddb_entry, cls_sess, cls_conn);\n\nexit_session_conn_fwddb_param:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\nvoid qla4xxx_update_session_conn_param(struct scsi_qla_host *ha,\n\t\t\t\t       struct ddb_entry *ddb_entry)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_conn *conn;\n\tuint32_t ddb_state;\n\tdma_addr_t fw_ddb_entry_dma;\n\tstruct dev_db_entry *fw_ddb_entry;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto exit_session_conn_param;\n\t}\n\n\tif (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, fw_ddb_entry,\n\t\t\t\t    fw_ddb_entry_dma, NULL, NULL, &ddb_state,\n\t\t\t\t    NULL, NULL, NULL) == QLA_ERROR) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"get_ddb_entry for fw_ddb_index %d\\n\",\n\t\t\t\t  ha->host_no, __func__,\n\t\t\t\t  ddb_entry->fw_ddb_index));\n\t\tgoto exit_session_conn_param;\n\t}\n\n\tcls_sess = ddb_entry->sess;\n\tsess = cls_sess->dd_data;\n\n\tcls_conn = ddb_entry->conn;\n\tconn = cls_conn->dd_data;\n\n\t/* Update timers after login */\n\tddb_entry->default_relogin_timeout =\n\t\t(le16_to_cpu(fw_ddb_entry->def_timeout) > LOGIN_TOV) &&\n\t\t (le16_to_cpu(fw_ddb_entry->def_timeout) < LOGIN_TOV * 10) ?\n\t\t le16_to_cpu(fw_ddb_entry->def_timeout) : LOGIN_TOV;\n\tddb_entry->default_time2wait =\n\t\t\t\tle16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\n\n\t/* Update params */\n\tddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\tqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);\n\n\tmemcpy(sess->initiatorname, ha->name_string,\n\t       min(sizeof(ha->name_string), sizeof(sess->initiatorname)));\n\nexit_session_conn_param:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\n/*\n * Timer routines\n */\nstatic void qla4xxx_timer(struct timer_list *t);\n\nstatic void qla4xxx_start_timer(struct scsi_qla_host *ha,\n\t\t\t\tunsigned long interval)\n{\n\tDEBUG(printk(\"scsi: %s: Starting timer thread for adapter %d\\n\",\n\t\t     __func__, ha->host->host_no));\n\ttimer_setup(&ha->timer, qla4xxx_timer, 0);\n\tha->timer.expires = jiffies + interval * HZ;\n\tadd_timer(&ha->timer);\n\tha->timer_active = 1;\n}\n\nstatic void qla4xxx_stop_timer(struct scsi_qla_host *ha)\n{\n\tdel_timer_sync(&ha->timer);\n\tha->timer_active = 0;\n}\n\n/***\n * qla4xxx_mark_device_missing - blocks the session\n * @cls_session: Pointer to the session to be blocked\n * @ddb_entry: Pointer to device database entry\n *\n * This routine marks a device missing and close connection.\n **/\nvoid qla4xxx_mark_device_missing(struct iscsi_cls_session *cls_session)\n{\n\tiscsi_block_session(cls_session);\n}\n\n/**\n * qla4xxx_mark_all_devices_missing - mark all devices as missing.\n * @ha: Pointer to host adapter structure.\n *\n * This routine marks a device missing and resets the relogin retry count.\n **/\nvoid qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha)\n{\n\tiscsi_host_for_each_session(ha->host, qla4xxx_mark_device_missing);\n}\n\nstatic struct srb* qla4xxx_get_new_srb(struct scsi_qla_host *ha,\n\t\t\t\t       struct ddb_entry *ddb_entry,\n\t\t\t\t       struct scsi_cmnd *cmd)\n{\n\tstruct srb *srb;\n\n\tsrb = mempool_alloc(ha->srb_mempool, GFP_ATOMIC);\n\tif (!srb)\n\t\treturn srb;\n\n\tkref_init(&srb->srb_ref);\n\tsrb->ha = ha;\n\tsrb->ddb = ddb_entry;\n\tsrb->cmd = cmd;\n\tsrb->flags = 0;\n\tCMD_SP(cmd) = (void *)srb;\n\n\treturn srb;\n}\n\nstatic void qla4xxx_srb_free_dma(struct scsi_qla_host *ha, struct srb *srb)\n{\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\n\tif (srb->flags & SRB_DMA_VALID) {\n\t\tscsi_dma_unmap(cmd);\n\t\tsrb->flags &= ~SRB_DMA_VALID;\n\t}\n\tCMD_SP(cmd) = NULL;\n}\n\nvoid qla4xxx_srb_compl(struct kref *ref)\n{\n\tstruct srb *srb = container_of(ref, struct srb, srb_ref);\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tstruct scsi_qla_host *ha = srb->ha;\n\n\tqla4xxx_srb_free_dma(ha, srb);\n\n\tmempool_free(srb, ha->srb_mempool);\n\n\tcmd->scsi_done(cmd);\n}\n\n/**\n * qla4xxx_queuecommand - scsi layer issues scsi command to driver.\n * @host: scsi host\n * @cmd: Pointer to Linux's SCSI command structure\n *\n * Remarks:\n * This routine is invoked by Linux to send a SCSI command to the driver.\n * The mid-level driver tries to ensure that queuecommand never gets\n * invoked concurrently with itself or the interrupt handler (although\n * the interrupt handler may call this routine as part of request-\n * completion handling).   Unfortunely, it sometimes calls the scheduler\n * in interrupt context which is a big NO! NO!.\n **/\nstatic int qla4xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct ddb_entry *ddb_entry = cmd->device->hostdata;\n\tstruct iscsi_cls_session *sess = ddb_entry->sess;\n\tstruct srb *srb;\n\tint rval;\n\n\tif (test_bit(AF_EEH_BUSY, &ha->flags)) {\n\t\tif (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\telse\n\t\t\tcmd->result = DID_REQUEUE << 16;\n\t\tgoto qc_fail_command;\n\t}\n\n\tif (!sess) {\n\t\tcmd->result = DID_IMM_RETRY << 16;\n\t\tgoto qc_fail_command;\n\t}\n\n\trval = iscsi_session_chkready(sess);\n\tif (rval) {\n\t\tcmd->result = rval;\n\t\tgoto qc_fail_command;\n\t}\n\n\tif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t    test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\n\t    test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\n\t    !test_bit(AF_ONLINE, &ha->flags) ||\n\t    !test_bit(AF_LINK_UP, &ha->flags) ||\n\t    test_bit(AF_LOOPBACK, &ha->flags) ||\n\t    test_bit(DPC_POST_IDC_ACK, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESTORE_ACB, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))\n\t\tgoto qc_host_busy;\n\n\tsrb = qla4xxx_get_new_srb(ha, ddb_entry, cmd);\n\tif (!srb)\n\t\tgoto qc_host_busy;\n\n\trval = qla4xxx_send_command_to_isp(ha, srb);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto qc_host_busy_free_sp;\n\n\treturn 0;\n\nqc_host_busy_free_sp:\n\tqla4xxx_srb_free_dma(ha, srb);\n\tmempool_free(srb, ha->srb_mempool);\n\nqc_host_busy:\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n\nqc_fail_command:\n\tcmd->scsi_done(cmd);\n\n\treturn 0;\n}\n\n/**\n * qla4xxx_mem_free - frees memory allocated to adapter\n * @ha: Pointer to host adapter structure.\n *\n * Frees memory previously allocated by qla4xxx_mem_alloc\n **/\nstatic void qla4xxx_mem_free(struct scsi_qla_host *ha)\n{\n\tif (ha->queues)\n\t\tdma_free_coherent(&ha->pdev->dev, ha->queues_len, ha->queues,\n\t\t\t\t  ha->queues_dma);\n\n\tif (ha->fw_dump)\n\t\tvfree(ha->fw_dump);\n\n\tha->queues_len = 0;\n\tha->queues = NULL;\n\tha->queues_dma = 0;\n\tha->request_ring = NULL;\n\tha->request_dma = 0;\n\tha->response_ring = NULL;\n\tha->response_dma = 0;\n\tha->shadow_regs = NULL;\n\tha->shadow_regs_dma = 0;\n\tha->fw_dump = NULL;\n\tha->fw_dump_size = 0;\n\n\t/* Free srb pool. */\n\tmempool_destroy(ha->srb_mempool);\n\tha->srb_mempool = NULL;\n\n\tdma_pool_destroy(ha->chap_dma_pool);\n\n\tif (ha->chap_list)\n\t\tvfree(ha->chap_list);\n\tha->chap_list = NULL;\n\n\tdma_pool_destroy(ha->fw_ddb_dma_pool);\n\n\t/* release io space registers  */\n\tif (is_qla8022(ha)) {\n\t\tif (ha->nx_pcibase)\n\t\t\tiounmap(\n\t\t\t    (struct device_reg_82xx __iomem *)ha->nx_pcibase);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tif (ha->nx_pcibase)\n\t\t\tiounmap(\n\t\t\t    (struct device_reg_83xx __iomem *)ha->nx_pcibase);\n\t} else if (ha->reg) {\n\t\tiounmap(ha->reg);\n\t}\n\n\tif (ha->reset_tmplt.buff)\n\t\tvfree(ha->reset_tmplt.buff);\n\n\tpci_release_regions(ha->pdev);\n}\n\n/**\n * qla4xxx_mem_alloc - allocates memory for use by adapter.\n * @ha: Pointer to host adapter structure\n *\n * Allocates DMA memory for request and response queues. Also allocates memory\n * for srbs.\n **/\nstatic int qla4xxx_mem_alloc(struct scsi_qla_host *ha)\n{\n\tunsigned long align;\n\n\t/* Allocate contiguous block of DMA memory for queues. */\n\tha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\n\t\t\t  (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) +\n\t\t\t  sizeof(struct shadow_regs) +\n\t\t\t  MEM_ALIGN_VALUE +\n\t\t\t  (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n\tha->queues = dma_alloc_coherent(&ha->pdev->dev, ha->queues_len,\n\t\t\t\t\t&ha->queues_dma, GFP_KERNEL);\n\tif (ha->queues == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"Memory Allocation failed - queues.\\n\");\n\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\t/*\n\t * As per RISC alignment requirements -- the bus-address must be a\n\t * multiple of the request-ring size (in bytes).\n\t */\n\talign = 0;\n\tif ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1))\n\t\talign = MEM_ALIGN_VALUE - ((unsigned long)ha->queues_dma &\n\t\t\t\t\t   (MEM_ALIGN_VALUE - 1));\n\n\t/* Update request and response queue pointers. */\n\tha->request_dma = ha->queues_dma + align;\n\tha->request_ring = (struct queue_entry *) (ha->queues + align);\n\tha->response_dma = ha->queues_dma + align +\n\t\t(REQUEST_QUEUE_DEPTH * QUEUE_SIZE);\n\tha->response_ring = (struct queue_entry *) (ha->queues + align +\n\t\t\t\t\t\t    (REQUEST_QUEUE_DEPTH *\n\t\t\t\t\t\t     QUEUE_SIZE));\n\tha->shadow_regs_dma = ha->queues_dma + align +\n\t\t(REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\n\t\t(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);\n\tha->shadow_regs = (struct shadow_regs *) (ha->queues + align +\n\t\t\t\t\t\t  (REQUEST_QUEUE_DEPTH *\n\t\t\t\t\t\t   QUEUE_SIZE) +\n\t\t\t\t\t\t  (RESPONSE_QUEUE_DEPTH *\n\t\t\t\t\t\t   QUEUE_SIZE));\n\n\t/* Allocate memory for srb pool. */\n\tha->srb_mempool = mempool_create(SRB_MIN_REQ, mempool_alloc_slab,\n\t\t\t\t\t mempool_free_slab, srb_cachep);\n\tif (ha->srb_mempool == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"Memory Allocation failed - SRB Pool.\\n\");\n\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\tha->chap_dma_pool = dma_pool_create(\"ql4_chap\", &ha->pdev->dev,\n\t\t\t\t\t    CHAP_DMA_BLOCK_SIZE, 8, 0);\n\n\tif (ha->chap_dma_pool == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"%s: chap_dma_pool allocation failed..\\n\", __func__);\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\tha->fw_ddb_dma_pool = dma_pool_create(\"ql4_fw_ddb\", &ha->pdev->dev,\n\t\t\t\t\t      DDB_DMA_BLOCK_SIZE, 8, 0);\n\n\tif (ha->fw_ddb_dma_pool == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s: fw_ddb_dma_pool allocation failed..\\n\",\n\t\t\t   __func__);\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\treturn QLA_SUCCESS;\n\nmem_alloc_error_exit:\n\treturn QLA_ERROR;\n}\n\n/**\n * qla4_8xxx_check_temp - Check the ISP82XX temperature.\n * @ha: adapter block pointer.\n *\n * Note: The caller should not hold the idc lock.\n **/\nstatic int qla4_8xxx_check_temp(struct scsi_qla_host *ha)\n{\n\tuint32_t temp, temp_state, temp_val;\n\tint status = QLA_SUCCESS;\n\n\ttemp = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_TEMP_STATE);\n\n\ttemp_state = qla82xx_get_temp_state(temp);\n\ttemp_val = qla82xx_get_temp_val(temp);\n\n\tif (temp_state == QLA82XX_TEMP_PANIC) {\n\t\tql4_printk(KERN_WARNING, ha, \"Device temperature %d degrees C\"\n\t\t\t   \" exceeds maximum allowed. Hardware has been shut\"\n\t\t\t   \" down.\\n\", temp_val);\n\t\tstatus = QLA_ERROR;\n\t} else if (temp_state == QLA82XX_TEMP_WARN) {\n\t\tif (ha->temperature == QLA82XX_TEMP_NORMAL)\n\t\t\tql4_printk(KERN_WARNING, ha, \"Device temperature %d\"\n\t\t\t\t   \" degrees C exceeds operating range.\"\n\t\t\t\t   \" Immediate action needed.\\n\", temp_val);\n\t} else {\n\t\tif (ha->temperature == QLA82XX_TEMP_WARN)\n\t\t\tql4_printk(KERN_INFO, ha, \"Device temperature is\"\n\t\t\t\t   \" now %d degrees C in normal range.\\n\",\n\t\t\t\t   temp_val);\n\t}\n\tha->temperature = temp_state;\n\treturn status;\n}\n\n/**\n * qla4_8xxx_check_fw_alive  - Check firmware health\n * @ha: Pointer to host adapter structure.\n *\n * Context: Interrupt\n **/\nstatic int qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)\n{\n\tuint32_t fw_heartbeat_counter;\n\tint status = QLA_SUCCESS;\n\n\tfw_heartbeat_counter = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t   QLA8XXX_PEG_ALIVE_COUNTER);\n\t/* If PEG_ALIVE_COUNTER is 0xffffffff, AER/EEH is in progress, ignore */\n\tif (fw_heartbeat_counter == 0xffffffff) {\n\t\tDEBUG2(printk(KERN_WARNING \"scsi%ld: %s: Device in frozen \"\n\t\t    \"state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\\n\",\n\t\t    ha->host_no, __func__));\n\t\treturn status;\n\t}\n\n\tif (ha->fw_heartbeat_counter == fw_heartbeat_counter) {\n\t\tha->seconds_since_last_heartbeat++;\n\t\t/* FW not alive after 2 seconds */\n\t\tif (ha->seconds_since_last_heartbeat == 2) {\n\t\t\tha->seconds_since_last_heartbeat = 0;\n\t\t\tqla4_8xxx_dump_peg_reg(ha);\n\t\t\tstatus = QLA_ERROR;\n\t\t}\n\t} else\n\t\tha->seconds_since_last_heartbeat = 0;\n\n\tha->fw_heartbeat_counter = fw_heartbeat_counter;\n\treturn status;\n}\n\nstatic void qla4_8xxx_process_fw_error(struct scsi_qla_host *ha)\n{\n\tuint32_t halt_status;\n\tint halt_status_unrecoverable = 0;\n\n\thalt_status = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_HALT_STATUS1);\n\n\tif (is_qla8022(ha)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t   __func__);\n\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\n\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P0 |\n\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P1);\n\n\t\tif (QLA82XX_FWERROR_CODE(halt_status) == 0x67)\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Firmware aborted with error code 0x00006700. Device is being reset\\n\",\n\t\t\t\t   __func__);\n\t\tif (halt_status & HALT_STATUS_UNRECOVERABLE)\n\t\t\thalt_status_unrecoverable = 1;\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tif (halt_status & QLA83XX_HALT_STATUS_FW_RESET)\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Firmware error detected device is being reset\\n\",\n\t\t\t\t   __func__);\n\t\telse if (halt_status & QLA83XX_HALT_STATUS_UNRECOVERABLE)\n\t\t\thalt_status_unrecoverable = 1;\n\t}\n\n\t/*\n\t * Since we cannot change dev_state in interrupt context,\n\t * set appropriate DPC flag then wakeup DPC\n\t */\n\tif (halt_status_unrecoverable) {\n\t\tset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\n\t} else {\n\t\tql4_printk(KERN_INFO, ha, \"%s: detect abort needed!\\n\",\n\t\t\t   __func__);\n\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t}\n\tqla4xxx_mailbox_premature_completion(ha);\n\tqla4xxx_wake_dpc(ha);\n}\n\n/**\n * qla4_8xxx_watchdog - Poll dev state\n * @ha: Pointer to host adapter structure.\n *\n * Context: Interrupt\n **/\nvoid qla4_8xxx_watchdog(struct scsi_qla_host *ha)\n{\n\tuint32_t dev_state;\n\tuint32_t idc_ctrl;\n\n\tif (is_qla8032(ha) &&\n\t    (qla4_83xx_is_detached(ha) == QLA_SUCCESS))\n\t\tWARN_ONCE(1, \"%s: iSCSI function %d marked invisible\\n\",\n\t\t\t  __func__, ha->func_num);\n\n\t/* don't poll if reset is going on */\n\tif (!(test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t    test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags))) {\n\t\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\n\t\tif (qla4_8xxx_check_temp(ha)) {\n\t\t\tif (is_qla8022(ha)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"disabling pause transmit on port 0 & 1.\\n\");\n\t\t\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\n\t\t\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P0 |\n\t\t\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P1);\n\t\t\t}\n\t\t\tset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\n\t\t\tqla4xxx_wake_dpc(ha);\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\n\t\t\t   !test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: HW State: NEED RESET!\\n\",\n\t\t\t\t   __func__);\n\n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tidc_ctrl = qla4_83xx_rd_reg(ha,\n\t\t\t\t\t\t\tQLA83XX_IDC_DRV_CTRL);\n\t\t\t\tif (!(idc_ctrl & GRACEFUL_RESET_BIT1)) {\n\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: Graceful reset bit is not set\\n\",\n\t\t\t\t\t\t   __func__);\n\t\t\t\t\tqla4xxx_mailbox_premature_completion(\n\t\t\t\t\t\t\t\t\t    ha);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((is_qla8032(ha) || is_qla8042(ha)) ||\n\t\t\t    (is_qla8022(ha) && !ql4xdontresethba)) {\n\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tqla4xxx_wake_dpc(ha);\n\t\t\t}\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\n\t\t    !test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: HW State: NEED QUIES!\\n\",\n\t\t\t    __func__);\n\t\t\tset_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags);\n\t\t\tqla4xxx_wake_dpc(ha);\n\t\t} else  {\n\t\t\t/* Check firmware health */\n\t\t\tif (qla4_8xxx_check_fw_alive(ha))\n\t\t\t\tqla4_8xxx_process_fw_error(ha);\n\t\t}\n\t}\n}\n\nstatic void qla4xxx_check_relogin_flash_ddb(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tif (!(ddb_entry->ddb_type == FLASH_DDB))\n\t\treturn;\n\n\tif (adapter_up(ha) && !test_bit(DF_RELOGIN, &ddb_entry->flags) &&\n\t    !iscsi_is_session_online(cls_sess)) {\n\t\tif (atomic_read(&ddb_entry->retry_relogin_timer) !=\n\t\t    INVALID_ENTRY) {\n\t\t\tif (atomic_read(&ddb_entry->retry_relogin_timer) ==\n\t\t\t\t\t0) {\n\t\t\t\tatomic_set(&ddb_entry->retry_relogin_timer,\n\t\t\t\t\t   INVALID_ENTRY);\n\t\t\t\tset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\n\t\t\t\tset_bit(DF_RELOGIN, &ddb_entry->flags);\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t       \"%s: index [%d] login device\\n\",\n\t\t\t\t\t__func__, ddb_entry->fw_ddb_index));\n\t\t\t} else\n\t\t\t\tatomic_dec(&ddb_entry->retry_relogin_timer);\n\t\t}\n\t}\n\n\t/* Wait for relogin to timeout */\n\tif (atomic_read(&ddb_entry->relogin_timer) &&\n\t    (atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {\n\t\t/*\n\t\t * If the relogin times out and the device is\n\t\t * still NOT ONLINE then try and relogin again.\n\t\t */\n\t\tif (!iscsi_is_session_online(cls_sess)) {\n\t\t\t/* Reset retry relogin timer */\n\t\t\tatomic_inc(&ddb_entry->relogin_retry_count);\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\"%s: index[%d] relogin timed out-retrying\"\n\t\t\t\t\" relogin (%d), retry (%d)\\n\", __func__,\n\t\t\t\tddb_entry->fw_ddb_index,\n\t\t\t\tatomic_read(&ddb_entry->relogin_retry_count),\n\t\t\t\tddb_entry->default_time2wait + 4));\n\t\t\tset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\n\t\t\tatomic_set(&ddb_entry->retry_relogin_timer,\n\t\t\t\t   ddb_entry->default_time2wait + 4);\n\t\t}\n\t}\n}\n\n/**\n * qla4xxx_timer - checks every second for work to do.\n * @t: Context to obtain pointer to host adapter structure.\n **/\nstatic void qla4xxx_timer(struct timer_list *t)\n{\n\tstruct scsi_qla_host *ha = from_timer(ha, t, timer);\n\tint start_dpc = 0;\n\tuint16_t w;\n\n\tiscsi_host_for_each_session(ha->host, qla4xxx_check_relogin_flash_ddb);\n\n\t/* If we are in the middle of AER/EEH processing\n\t * skip any processing and reschedule the timer\n\t */\n\tif (test_bit(AF_EEH_BUSY, &ha->flags)) {\n\t\tmod_timer(&ha->timer, jiffies + HZ);\n\t\treturn;\n\t}\n\n\t/* Hardware read to trigger an EEH error during mailbox waits. */\n\tif (!pci_channel_offline(ha->pdev))\n\t\tpci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);\n\n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_watchdog(ha);\n\n\tif (is_qla40XX(ha)) {\n\t\t/* Check for heartbeat interval. */\n\t\tif (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&\n\t\t    ha->heartbeat_interval != 0) {\n\t\t\tha->seconds_since_last_heartbeat++;\n\t\t\tif (ha->seconds_since_last_heartbeat >\n\t\t\t    ha->heartbeat_interval + 2)\n\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t}\n\t}\n\n\t/* Process any deferred work. */\n\tif (!list_empty(&ha->work_list))\n\t\tstart_dpc++;\n\n\t/* Wakeup the dpc routine for this adapter, if needed. */\n\tif (start_dpc ||\n\t     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||\n\t     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||\n\t     test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\n\t     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t     test_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||\n\t     test_bit(DPC_LINK_CHANGED, &ha->dpc_flags) ||\n\t     test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\n\t     test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\n\t     test_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags) ||\n\t     test_bit(DPC_AEN, &ha->dpc_flags)) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: scheduling dpc routine\"\n\t\t\t      \" - dpc flags = 0x%lx\\n\",\n\t\t\t      ha->host_no, __func__, ha->dpc_flags));\n\t\tqla4xxx_wake_dpc(ha);\n\t}\n\n\t/* Reschedule timer thread to call us back in one second */\n\tmod_timer(&ha->timer, jiffies + HZ);\n\n\tDEBUG2(ha->seconds_since_last_intr++);\n}\n\n/**\n * qla4xxx_cmd_wait - waits for all outstanding commands to complete\n * @ha: Pointer to host adapter structure.\n *\n * This routine stalls the driver until all outstanding commands are returned.\n * Caller must release the Hardware Lock prior to calling this routine.\n **/\nstatic int qla4xxx_cmd_wait(struct scsi_qla_host *ha)\n{\n\tuint32_t index = 0;\n\tunsigned long flags;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long wtime;\n\tuint32_t wtmo;\n\n\tif (is_qla40XX(ha))\n\t\twtmo = WAIT_CMD_TOV;\n\telse\n\t\twtmo = ha->nx_reset_timeout / 2;\n\n\twtime = jiffies + (wtmo * HZ);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Wait up to %u seconds for cmds to complete\\n\",\n\t\t\t  wtmo));\n\n\twhile (!time_after_eq(jiffies, wtime)) {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t/* Find a command that hasn't completed. */\n\t\tfor (index = 0; index < ha->host->can_queue; index++) {\n\t\t\tcmd = scsi_host_find_tag(ha->host, index);\n\t\t\t/*\n\t\t\t * We cannot just check if the index is valid,\n\t\t\t * becase if we are run from the scsi eh, then\n\t\t\t * the scsi/block layer is going to prevent\n\t\t\t * the tag from being released.\n\t\t\t */\n\t\t\tif (cmd != NULL && CMD_SP(cmd))\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t/* If No Commands are pending, wait is complete */\n\t\tif (index == ha->host->can_queue)\n\t\t\treturn QLA_SUCCESS;\n\n\t\tmsleep(1000);\n\t}\n\t/* If we timed out on waiting for commands to come back\n\t * return ERROR. */\n\treturn QLA_ERROR;\n}\n\nint qla4xxx_hw_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t ctrl_status;\n\tunsigned long flags = 0;\n\n\tDEBUG2(printk(KERN_ERR \"scsi%ld: %s\\n\", ha->host_no, __func__));\n\n\tif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\n\t\treturn QLA_ERROR;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t/*\n\t * If the SCSI Reset Interrupt bit is set, clear it.\n\t * Otherwise, the Soft Reset won't work.\n\t */\n\tctrl_status = readw(&ha->reg->ctrl_status);\n\tif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)\n\t\twritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\n\n\t/* Issue Soft Reset */\n\twritel(set_rmask(CSR_SOFT_RESET), &ha->reg->ctrl_status);\n\treadl(&ha->reg->ctrl_status);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla4xxx_soft_reset - performs soft reset.\n * @ha: Pointer to host adapter structure.\n **/\nint qla4xxx_soft_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t max_wait_time;\n\tunsigned long flags = 0;\n\tint status;\n\tuint32_t ctrl_status;\n\n\tstatus = qla4xxx_hw_reset(ha);\n\tif (status != QLA_SUCCESS)\n\t\treturn status;\n\n\tstatus = QLA_ERROR;\n\t/* Wait until the Network Reset Intr bit is cleared */\n\tmax_wait_time = RESET_INTR_TOV;\n\tdo {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tif ((ctrl_status & CSR_NET_RESET_INTR) == 0)\n\t\t\tbreak;\n\n\t\tmsleep(1000);\n\t} while ((--max_wait_time));\n\n\tif ((ctrl_status & CSR_NET_RESET_INTR) != 0) {\n\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t      \"scsi%ld: Network Reset Intr not cleared by \"\n\t\t\t      \"Network function, clearing it now!\\n\",\n\t\t\t      ha->host_no));\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twritel(set_rmask(CSR_NET_RESET_INTR), &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\t/* Wait until the firmware tells us the Soft Reset is done */\n\tmax_wait_time = SOFT_RESET_TOV;\n\tdo {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tif ((ctrl_status & CSR_SOFT_RESET) == 0) {\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(1000);\n\t} while ((--max_wait_time));\n\n\t/*\n\t * Also, make sure that the SCSI Reset Interrupt bit has been cleared\n\t * after the soft reset has taken place.\n\t */\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tctrl_status = readw(&ha->reg->ctrl_status);\n\tif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {\n\t\twritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t/* If soft reset fails then most probably the bios on other\n\t * function is also enabled.\n\t * Since the initialization is sequential the other fn\n\t * wont be able to acknowledge the soft reset.\n\t * Issue a force soft reset to workaround this scenario.\n\t */\n\tif (max_wait_time == 0) {\n\t\t/* Issue Force Soft Reset */\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twritel(set_rmask(CSR_FORCE_SOFT_RESET), &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t/* Wait until the firmware tells us the Soft Reset is done */\n\t\tmax_wait_time = SOFT_RESET_TOV;\n\t\tdo {\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t\tif ((ctrl_status & CSR_FORCE_SOFT_RESET) == 0) {\n\t\t\t\tstatus = QLA_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsleep(1000);\n\t\t} while ((--max_wait_time));\n\t}\n\n\treturn status;\n}\n\n/**\n * qla4xxx_abort_active_cmds - returns all outstanding i/o requests to O.S.\n * @ha: Pointer to host adapter structure.\n * @res: returned scsi status\n *\n * This routine is called just prior to a HARD RESET to return all\n * outstanding commands back to the Operating System.\n * Caller should make sure that the following locks are released\n * before this calling routine: Hardware lock, and io_request_lock.\n **/\nstatic void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res)\n{\n\tstruct srb *srb;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (i = 0; i < ha->host->can_queue; i++) {\n\t\tsrb = qla4xxx_del_from_active_array(ha, i);\n\t\tif (srb != NULL) {\n\t\t\tsrb->cmd->result = res;\n\t\t\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nvoid qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha)\n{\n\tclear_bit(AF_ONLINE, &ha->flags);\n\n\t/* Disable the board */\n\tql4_printk(KERN_INFO, ha, \"Disabling the board\\n\");\n\n\tqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\n\tqla4xxx_mark_all_devices_missing(ha);\n\tclear_bit(AF_INIT_DONE, &ha->flags);\n}\n\nstatic void qla4xxx_fail_session(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->fw_ddb_device_state = DDB_DS_SESSION_FAILED;\n\n\tif (ddb_entry->ddb_type == FLASH_DDB)\n\t\tiscsi_block_session(ddb_entry->sess);\n\telse\n\t\tiscsi_session_failure(cls_session->dd_data,\n\t\t\t\t      ISCSI_ERR_CONN_FAILED);\n}\n\n/**\n * qla4xxx_recover_adapter - recovers adapter after a fatal error\n * @ha: Pointer to host adapter structure.\n **/\nstatic int qla4xxx_recover_adapter(struct scsi_qla_host *ha)\n{\n\tint status = QLA_ERROR;\n\tuint8_t reset_chip = 0;\n\tuint32_t dev_state;\n\tunsigned long wait;\n\n\t/* Stall incoming I/O until we are done */\n\tscsi_block_requests(ha->host);\n\tclear_bit(AF_ONLINE, &ha->flags);\n\tclear_bit(AF_LINK_UP, &ha->flags);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: adapter OFFLINE\\n\", __func__));\n\n\tset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\n\tif ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t    !test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t   __func__);\n\t\t/* disable pause frame for ISP83xx */\n\t\tqla4_83xx_disable_pause(ha);\n\t}\n\n\tiscsi_host_for_each_session(ha->host, qla4xxx_fail_session);\n\n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\treset_chip = 1;\n\n\t/* For the DPC_RESET_HA_INTR case (ISP-4xxx specific)\n\t * do not reset adapter, jump to initialize_adapter */\n\tif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\n\t\tstatus = QLA_SUCCESS;\n\t\tgoto recover_ha_init_adapter;\n\t}\n\n\t/* For the ISP-8xxx adapter, issue a stop_firmware if invoked\n\t * from eh_host_reset or ioctl module */\n\tif (is_qla80XX(ha) && !reset_chip &&\n\t    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"scsi%ld: %s - Performing stop_firmware...\\n\",\n\t\t    ha->host_no, __func__));\n\t\tstatus = ha->isp_ops->reset_firmware(ha);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\tha->isp_ops->disable_intrs(ha);\n\t\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t\t} else {\n\t\t\t/* If the stop_firmware fails then\n\t\t\t * reset the entire chip */\n\t\t\treset_chip = 1;\n\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t}\n\t}\n\n\t/* Issue full chip reset if recovering from a catastrophic error,\n\t * or if stop_firmware fails for ISP-8xxx.\n\t * This is the default case for ISP-4xxx */\n\tif (is_qla40XX(ha) || reset_chip) {\n\t\tif (is_qla40XX(ha))\n\t\t\tgoto chip_reset;\n\n\t\t/* Check if 8XXX firmware is alive or not\n\t\t * We may have arrived here from NEED_RESET\n\t\t * detection only */\n\t\tif (test_bit(AF_FW_RECOVERY, &ha->flags))\n\t\t\tgoto chip_reset;\n\n\t\twait = jiffies + (FW_ALIVE_WAIT_TOV * HZ);\n\t\twhile (time_before(jiffies, wait)) {\n\t\t\tif (qla4_8xxx_check_fw_alive(ha)) {\n\t\t\t\tqla4xxx_mailbox_premature_completion(ha);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(HZ);\n\t\t}\nchip_reset:\n\t\tif (!test_bit(AF_FW_RECOVERY, &ha->flags))\n\t\t\tqla4xxx_cmd_wait(ha);\n\n\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"scsi%ld: %s - Performing chip reset..\\n\",\n\t\t    ha->host_no, __func__));\n\t\tstatus = ha->isp_ops->reset_chip(ha);\n\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t}\n\n\t/* Flush any pending ddb changed AENs */\n\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\nrecover_ha_init_adapter:\n\t/* Upon successful firmware/chip reset, re-initialize the adapter */\n\tif (status == QLA_SUCCESS) {\n\t\t/* For ISP-4xxx, force function 1 to always initialize\n\t\t * before function 3 to prevent both funcions from\n\t\t * stepping on top of the other */\n\t\tif (is_qla40XX(ha) && (ha->mac_index == 3))\n\t\t\tssleep(6);\n\n\t\t/* NOTE: AF_ONLINE flag set upon successful completion of\n\t\t * qla4xxx_initialize_adapter */\n\t\tstatus = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\n\t\tif (is_qla80XX(ha) && (status == QLA_ERROR)) {\n\t\t\tstatus = qla4_8xxx_check_init_adapter_retry(ha);\n\t\t\tif (status == QLA_ERROR) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Don't retry recover adapter\\n\",\n\t\t\t\t\t   ha->host_no, __func__);\n\t\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t  &ha->dpc_flags);\n\t\t\t\tgoto exit_recover;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Retry failed adapter initialization, if necessary\n\t * Do not retry initialize_adapter for RESET_HA_INTR (ISP-4xxx specific)\n\t * case to prevent ping-pong resets between functions */\n\tif (!test_bit(AF_ONLINE, &ha->flags) &&\n\t    !test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\n\t\t/* Adapter initialization failed, see if we can retry\n\t\t * resetting the ha.\n\t\t * Since we don't want to block the DPC for too long\n\t\t * with multiple resets in the same thread,\n\t\t * utilize DPC to retry */\n\t\tif (is_qla80XX(ha)) {\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tdev_state = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DEV_STATE);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tif (dev_state == QLA8XXX_DEV_FAILED) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: don't retry \"\n\t\t\t\t\t   \"recover adapter. H/W is in Failed \"\n\t\t\t\t\t   \"state\\n\", __func__);\n\t\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t\t&ha->dpc_flags);\n\t\t\t\tstatus = QLA_ERROR;\n\n\t\t\t\tgoto exit_recover;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {\n\t\t\tha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;\n\t\t\tDEBUG2(printk(\"scsi%ld: recover adapter - retrying \"\n\t\t\t\t      \"(%d) more times\\n\", ha->host_no,\n\t\t\t\t      ha->retry_reset_ha_cnt));\n\t\t\tset_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\tstatus = QLA_ERROR;\n\t\t} else {\n\t\t\tif (ha->retry_reset_ha_cnt > 0) {\n\t\t\t\t/* Schedule another Reset HA--DPC will retry */\n\t\t\t\tha->retry_reset_ha_cnt--;\n\t\t\t\tDEBUG2(printk(\"scsi%ld: recover adapter - \"\n\t\t\t\t\t      \"retry remaining %d\\n\",\n\t\t\t\t\t      ha->host_no,\n\t\t\t\t\t      ha->retry_reset_ha_cnt));\n\t\t\t\tstatus = QLA_ERROR;\n\t\t\t}\n\n\t\t\tif (ha->retry_reset_ha_cnt == 0) {\n\t\t\t\t/* Recover adapter retries have been exhausted.\n\t\t\t\t * Adapter DEAD */\n\t\t\t\tDEBUG2(printk(\"scsi%ld: recover adapter \"\n\t\t\t\t\t      \"failed - board disabled\\n\",\n\t\t\t\t\t      ha->host_no));\n\t\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t  &ha->dpc_flags);\n\t\t\t\tstatus = QLA_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t}\n\nexit_recover:\n\tha->adapter_error_count++;\n\n\tif (test_bit(AF_ONLINE, &ha->flags))\n\t\tha->isp_ops->enable_intrs(ha);\n\n\tscsi_unblock_requests(ha->host);\n\n\tclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\tDEBUG2(printk(\"scsi%ld: recover adapter: %s\\n\", ha->host_no,\n\t    status == QLA_ERROR ? \"FAILED\" : \"SUCCEEDED\"));\n\n\treturn status;\n}\n\nstatic void qla4xxx_relogin_devices(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tif (!iscsi_is_session_online(cls_session)) {\n\t\tif (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t\t\t   \" unblock session\\n\", ha->host_no, __func__,\n\t\t\t\t   ddb_entry->fw_ddb_index);\n\t\t\tiscsi_unblock_session(ddb_entry->sess);\n\t\t} else {\n\t\t\t/* Trigger relogin */\n\t\t\tif (ddb_entry->ddb_type == FLASH_DDB) {\n\t\t\t\tif (!(test_bit(DF_RELOGIN, &ddb_entry->flags) ||\n\t\t\t\t      test_bit(DF_DISABLE_RELOGIN,\n\t\t\t\t\t       &ddb_entry->flags)))\n\t\t\t\t\tqla4xxx_arm_relogin_timer(ddb_entry);\n\t\t\t} else\n\t\t\t\tiscsi_session_failure(cls_session->dd_data,\n\t\t\t\t\t\t      ISCSI_ERR_CONN_FAILED);\n\t\t}\n\t}\n}\n\nint qla4xxx_unblock_flash_ddb(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t   \" unblock session\\n\", ha->host_no, __func__,\n\t\t   ddb_entry->fw_ddb_index);\n\n\tiscsi_unblock_session(ddb_entry->sess);\n\n\t/* Start scan target */\n\tif (test_bit(AF_ONLINE, &ha->flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t\t   \" start scan\\n\", ha->host_no, __func__,\n\t\t\t   ddb_entry->fw_ddb_index);\n\t\tscsi_queue_work(ha->host, &ddb_entry->sess->scan_work);\n\t}\n\treturn QLA_SUCCESS;\n}\n\nint qla4xxx_unblock_ddb(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tint status = QLA_SUCCESS;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t   \" unblock user space session\\n\", ha->host_no, __func__,\n\t\t   ddb_entry->fw_ddb_index);\n\n\tif (!iscsi_is_session_online(cls_session)) {\n\t\tiscsi_conn_start(ddb_entry->conn);\n\t\tiscsi_conn_login_event(ddb_entry->conn,\n\t\t\t\t       ISCSI_CONN_STATE_LOGGED_IN);\n\t} else {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi%ld: %s: ddb[%d] session [%d] already logged in\\n\",\n\t\t\t   ha->host_no, __func__, ddb_entry->fw_ddb_index,\n\t\t\t   cls_session->sid);\n\t\tstatus = QLA_ERROR;\n\t}\n\n\treturn status;\n}\n\nstatic void qla4xxx_relogin_all_devices(struct scsi_qla_host *ha)\n{\n\tiscsi_host_for_each_session(ha->host, qla4xxx_relogin_devices);\n}\n\nstatic void qla4xxx_relogin_flash_ddb(struct iscsi_cls_session *cls_sess)\n{\n\tuint16_t relogin_timer;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\trelogin_timer = max(ddb_entry->default_relogin_timeout,\n\t\t\t    (uint16_t)RELOGIN_TOV);\n\tatomic_set(&ddb_entry->relogin_timer, relogin_timer);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"scsi%ld: Relogin index [%d]. TOV=%d\\n\", ha->host_no,\n\t\t\t  ddb_entry->fw_ddb_index, relogin_timer));\n\n\tqla4xxx_login_flash_ddb(cls_sess);\n}\n\nstatic void qla4xxx_dpc_relogin(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tif (!(ddb_entry->ddb_type == FLASH_DDB))\n\t\treturn;\n\n\tif (test_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags))\n\t\treturn;\n\n\tif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags) &&\n\t    !iscsi_is_session_online(cls_sess)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"relogin issued\\n\"));\n\t\tqla4xxx_relogin_flash_ddb(cls_sess);\n\t}\n}\n\nvoid qla4xxx_wake_dpc(struct scsi_qla_host *ha)\n{\n\tif (ha->dpc_thread)\n\t\tqueue_work(ha->dpc_thread, &ha->dpc_work);\n}\n\nstatic struct qla4_work_evt *\nqla4xxx_alloc_work(struct scsi_qla_host *ha, uint32_t data_size,\n\t\t   enum qla4_work_type type)\n{\n\tstruct qla4_work_evt *e;\n\tuint32_t size = sizeof(struct qla4_work_evt) + data_size;\n\n\te = kzalloc(size, GFP_ATOMIC);\n\tif (!e)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&e->list);\n\te->type = type;\n\treturn e;\n}\n\nstatic void qla4xxx_post_work(struct scsi_qla_host *ha,\n\t\t\t     struct qla4_work_evt *e)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->work_lock, flags);\n\tlist_add_tail(&e->list, &ha->work_list);\n\tspin_unlock_irqrestore(&ha->work_lock, flags);\n\tqla4xxx_wake_dpc(ha);\n}\n\nint qla4xxx_post_aen_work(struct scsi_qla_host *ha,\n\t\t\t  enum iscsi_host_event_code aen_code,\n\t\t\t  uint32_t data_size, uint8_t *data)\n{\n\tstruct qla4_work_evt *e;\n\n\te = qla4xxx_alloc_work(ha, data_size, QLA4_EVENT_AEN);\n\tif (!e)\n\t\treturn QLA_ERROR;\n\n\te->u.aen.code = aen_code;\n\te->u.aen.data_size = data_size;\n\tmemcpy(e->u.aen.data, data, data_size);\n\n\tqla4xxx_post_work(ha, e);\n\n\treturn QLA_SUCCESS;\n}\n\nint qla4xxx_post_ping_evt_work(struct scsi_qla_host *ha,\n\t\t\t       uint32_t status, uint32_t pid,\n\t\t\t       uint32_t data_size, uint8_t *data)\n{\n\tstruct qla4_work_evt *e;\n\n\te = qla4xxx_alloc_work(ha, data_size, QLA4_EVENT_PING_STATUS);\n\tif (!e)\n\t\treturn QLA_ERROR;\n\n\te->u.ping.status = status;\n\te->u.ping.pid = pid;\n\te->u.ping.data_size = data_size;\n\tmemcpy(e->u.ping.data, data, data_size);\n\n\tqla4xxx_post_work(ha, e);\n\n\treturn QLA_SUCCESS;\n}\n\nstatic void qla4xxx_do_work(struct scsi_qla_host *ha)\n{\n\tstruct qla4_work_evt *e, *tmp;\n\tunsigned long flags;\n\tLIST_HEAD(work);\n\n\tspin_lock_irqsave(&ha->work_lock, flags);\n\tlist_splice_init(&ha->work_list, &work);\n\tspin_unlock_irqrestore(&ha->work_lock, flags);\n\n\tlist_for_each_entry_safe(e, tmp, &work, list) {\n\t\tlist_del_init(&e->list);\n\n\t\tswitch (e->type) {\n\t\tcase QLA4_EVENT_AEN:\n\t\t\tiscsi_post_host_event(ha->host_no,\n\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t      e->u.aen.code,\n\t\t\t\t\t      e->u.aen.data_size,\n\t\t\t\t\t      e->u.aen.data);\n\t\t\tbreak;\n\t\tcase QLA4_EVENT_PING_STATUS:\n\t\t\tiscsi_ping_comp_event(ha->host_no,\n\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t      e->u.ping.status,\n\t\t\t\t\t      e->u.ping.pid,\n\t\t\t\t\t      e->u.ping.data_size,\n\t\t\t\t\t      e->u.ping.data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_WARNING, ha, \"event type: 0x%x not \"\n\t\t\t\t   \"supported\", e->type);\n\t\t}\n\t\tkfree(e);\n\t}\n}\n\n/**\n * qla4xxx_do_dpc - dpc routine\n * @work: Context to obtain pointer to host adapter structure.\n *\n * This routine is a task that is schedule by the interrupt handler\n * to perform the background processing for interrupts.  We put it\n * on a task queue that is consumed whenever the scheduler runs; that's\n * so you can do anything (i.e. put the process to sleep etc).  In fact,\n * the mid-level tries to sleep when it reaches the driver threshold\n * \"host->can_queue\". This can cause a panic if we were in our interrupt code.\n **/\nstatic void qla4xxx_do_dpc(struct work_struct *work)\n{\n\tstruct scsi_qla_host *ha =\n\t\tcontainer_of(work, struct scsi_qla_host, dpc_work);\n\tint status = QLA_ERROR;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"scsi%ld: %s: DPC handler waking up. flags = 0x%08lx, dpc_flags = 0x%08lx\\n\",\n\t\t\t  ha->host_no, __func__, ha->flags, ha->dpc_flags));\n\n\t/* Initialization not yet finished. Don't do anything yet. */\n\tif (!test_bit(AF_INIT_DONE, &ha->flags))\n\t\treturn;\n\n\tif (test_bit(AF_EEH_BUSY, &ha->flags)) {\n\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: flags = %lx\\n\",\n\t\t    ha->host_no, __func__, ha->flags));\n\t\treturn;\n\t}\n\n\t/* post events to application */\n\tqla4xxx_do_work(ha);\n\n\tif (is_qla80XX(ha)) {\n\t\tif (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {\n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\t/* disable pause frame for ISP83xx */\n\t\t\t\tqla4_83xx_disable_pause(ha);\n\t\t\t}\n\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tql4_printk(KERN_INFO, ha, \"HW State: FAILED\\n\");\n\t\t\tqla4_8xxx_device_state_handler(ha);\n\t\t}\n\n\t\tif (test_bit(DPC_POST_IDC_ACK, &ha->dpc_flags)) {\n\t\t\tif (is_qla8042(ha)) {\n\t\t\t\tif (ha->idc_info.info2 &\n\t\t\t\t    ENABLE_INTERNAL_LOOPBACK) {\n\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: Disabling ACB\\n\",\n\t\t\t\t\t\t   __func__);\n\t\t\t\t\tstatus = qla4_84xx_config_acb(ha,\n\t\t\t\t\t\t\t    ACB_CONFIG_DISABLE);\n\t\t\t\t\tif (status != QLA_SUCCESS) {\n\t\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: ACB config failed\\n\",\n\t\t\t\t\t\t\t   __func__);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqla4_83xx_post_idc_ack(ha);\n\t\t\tclear_bit(DPC_POST_IDC_ACK, &ha->dpc_flags);\n\t\t}\n\n\t\tif (is_qla8042(ha) &&\n\t\t    test_bit(DPC_RESTORE_ACB, &ha->dpc_flags)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: Restoring ACB\\n\",\n\t\t\t\t   __func__);\n\t\t\tif (qla4_84xx_config_acb(ha, ACB_CONFIG_SET) !=\n\t\t\t    QLA_SUCCESS) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: ACB config failed \",\n\t\t\t\t\t   __func__);\n\t\t\t}\n\t\t\tclear_bit(DPC_RESTORE_ACB, &ha->dpc_flags);\n\t\t}\n\n\t\tif (test_and_clear_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\n\t\t\tqla4_8xxx_need_qsnt_handler(ha);\n\t\t}\n\t}\n\n\tif (!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) &&\n\t    (test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))) {\n\t\tif ((is_qla8022(ha) && ql4xdontresethba) ||\n\t\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t     qla4_83xx_idc_dontreset(ha))) {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Don't Reset HBA\\n\",\n\t\t\t    ha->host_no, __func__));\n\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\tclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\n\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\t\tgoto dpc_post_reset_ha;\n\t\t}\n\t\tif (test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\n\t\t    test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\t\tqla4xxx_recover_adapter(ha);\n\n\t\tif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\n\t\t\tuint8_t wait_time = RESET_INTR_TOV;\n\n\t\t\twhile ((readw(&ha->reg->ctrl_status) &\n\t\t\t\t(CSR_SOFT_RESET | CSR_FORCE_SOFT_RESET)) != 0) {\n\t\t\t\tif (--wait_time == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(1000);\n\t\t\t}\n\t\t\tif (wait_time == 0)\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: SR|FSR \"\n\t\t\t\t\t      \"bit not cleared-- resetting\\n\",\n\t\t\t\t\t      ha->host_no, __func__));\n\t\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t\t\tif (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS) {\n\t\t\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t\t\t\tstatus = qla4xxx_recover_adapter(ha);\n\t\t\t}\n\t\t\tclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\n\t\t\tif (status == QLA_SUCCESS)\n\t\t\t\tha->isp_ops->enable_intrs(ha);\n\t\t}\n\t}\n\ndpc_post_reset_ha:\n\t/* ---- process AEN? --- */\n\tif (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))\n\t\tqla4xxx_process_aen(ha, PROCESS_ALL_AENS);\n\n\t/* ---- Get DHCP IP Address? --- */\n\tif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))\n\t\tqla4xxx_get_dhcp_ip_address(ha);\n\n\t/* ---- relogin device? --- */\n\tif (adapter_up(ha) &&\n\t    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {\n\t\tiscsi_host_for_each_session(ha->host, qla4xxx_dpc_relogin);\n\t}\n\n\t/* ---- link change? --- */\n\tif (!test_bit(AF_LOOPBACK, &ha->flags) &&\n\t    test_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {\n\t\tif (!test_bit(AF_LINK_UP, &ha->flags)) {\n\t\t\t/* ---- link down? --- */\n\t\t\tqla4xxx_mark_all_devices_missing(ha);\n\t\t} else {\n\t\t\t/* ---- link up? --- *\n\t\t\t * F/W will auto login to all devices ONLY ONCE after\n\t\t\t * link up during driver initialization and runtime\n\t\t\t * fatal error recovery.  Therefore, the driver must\n\t\t\t * manually relogin to devices when recovering from\n\t\t\t * connection failures, logouts, expired KATO, etc. */\n\t\t\tif (test_and_clear_bit(AF_BUILD_DDB_LIST, &ha->flags)) {\n\t\t\t\tqla4xxx_build_ddb_list(ha, ha->is_reset);\n\t\t\t\tiscsi_host_for_each_session(ha->host,\n\t\t\t\t\t\tqla4xxx_login_flash_ddb);\n\t\t\t} else\n\t\t\t\tqla4xxx_relogin_all_devices(ha);\n\t\t}\n\t}\n\tif (test_and_clear_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags)) {\n\t\tif (qla4xxx_sysfs_ddb_export(ha))\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Error exporting ddb to sysfs\\n\",\n\t\t\t\t   __func__);\n\t}\n}\n\n/**\n * qla4xxx_free_adapter - release the adapter\n * @ha: pointer to adapter structure\n **/\nstatic void qla4xxx_free_adapter(struct scsi_qla_host *ha)\n{\n\tqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\n\n\t/* Turn-off interrupts on the card. */\n\tha->isp_ops->disable_intrs(ha);\n\n\tif (is_qla40XX(ha)) {\n\t\twritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\n\t\t       &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t} else if (is_qla8022(ha)) {\n\t\twritel(0, &ha->qla4_82xx_reg->host_int);\n\t\treadl(&ha->qla4_82xx_reg->host_int);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\twritel(0, &ha->qla4_83xx_reg->risc_intr);\n\t\treadl(&ha->qla4_83xx_reg->risc_intr);\n\t}\n\n\t/* Remove timer thread, if present */\n\tif (ha->timer_active)\n\t\tqla4xxx_stop_timer(ha);\n\n\t/* Kill the kernel thread for this host */\n\tif (ha->dpc_thread)\n\t\tdestroy_workqueue(ha->dpc_thread);\n\n\t/* Kill the kernel thread for this host */\n\tif (ha->task_wq)\n\t\tdestroy_workqueue(ha->task_wq);\n\n\t/* Put firmware in known state */\n\tha->isp_ops->reset_firmware(ha);\n\n\tif (is_qla80XX(ha)) {\n\t\tha->isp_ops->idc_lock(ha);\n\t\tqla4_8xxx_clear_drv_active(ha);\n\t\tha->isp_ops->idc_unlock(ha);\n\t}\n\n\t/* Detach interrupts */\n\tqla4xxx_free_irqs(ha);\n\n\t/* free extra memory */\n\tqla4xxx_mem_free(ha);\n}\n\nint qla4_8xxx_iospace_config(struct scsi_qla_host *ha)\n{\n\tint status = 0;\n\tunsigned long mem_base, mem_len;\n\tstruct pci_dev *pdev = ha->pdev;\n\n\tstatus = pci_request_regions(pdev, DRIVER_NAME);\n\tif (status) {\n\t\tprintk(KERN_WARNING\n\t\t    \"scsi(%ld) Failed to reserve PIO regions (%s) \"\n\t\t    \"status=%d\\n\", ha->host_no, pci_name(pdev), status);\n\t\tgoto iospace_error_exit;\n\t}\n\n\tDEBUG2(printk(KERN_INFO \"%s: revision-id=%d\\n\",\n\t    __func__, pdev->revision));\n\tha->revision_id = pdev->revision;\n\n\t/* remap phys address */\n\tmem_base = pci_resource_start(pdev, 0); /* 0 is for BAR 0 */\n\tmem_len = pci_resource_len(pdev, 0);\n\tDEBUG2(printk(KERN_INFO \"%s: ioremap from %lx a size of %lx\\n\",\n\t    __func__, mem_base, mem_len));\n\n\t/* mapping of pcibase pointer */\n\tha->nx_pcibase = (unsigned long)ioremap(mem_base, mem_len);\n\tif (!ha->nx_pcibase) {\n\t\tprintk(KERN_ERR\n\t\t    \"cannot remap MMIO (%s), aborting\\n\", pci_name(pdev));\n\t\tpci_release_regions(ha->pdev);\n\t\tgoto iospace_error_exit;\n\t}\n\n\t/* Mapping of IO base pointer, door bell read and write pointer */\n\n\t/* mapping of IO base pointer */\n\tif (is_qla8022(ha)) {\n\t\tha->qla4_82xx_reg = (struct device_reg_82xx  __iomem *)\n\t\t\t\t    ((uint8_t *)ha->nx_pcibase + 0xbc000 +\n\t\t\t\t     (ha->pdev->devfn << 11));\n\t\tha->nx_db_wr_ptr = (ha->pdev->devfn == 4 ? QLA82XX_CAM_RAM_DB1 :\n\t\t\t\t    QLA82XX_CAM_RAM_DB2);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tha->qla4_83xx_reg = (struct device_reg_83xx __iomem *)\n\t\t\t\t    ((uint8_t *)ha->nx_pcibase);\n\t}\n\n\treturn 0;\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\n/***\n * qla4xxx_iospace_config - maps registers\n * @ha: pointer to adapter structure\n *\n * This routines maps HBA's registers from the pci address space\n * into the kernel virtual address space for memory mapped i/o.\n **/\nint qla4xxx_iospace_config(struct scsi_qla_host *ha)\n{\n\tunsigned long pio, pio_len, pio_flags;\n\tunsigned long mmio, mmio_len, mmio_flags;\n\n\tpio = pci_resource_start(ha->pdev, 0);\n\tpio_len = pci_resource_len(ha->pdev, 0);\n\tpio_flags = pci_resource_flags(ha->pdev, 0);\n\tif (pio_flags & IORESOURCE_IO) {\n\t\tif (pio_len < MIN_IOBASE_LEN) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t\t\"Invalid PCI I/O region size\\n\");\n\t\t\tpio = 0;\n\t\t}\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha, \"region #0 not a PIO resource\\n\");\n\t\tpio = 0;\n\t}\n\n\t/* Use MMIO operations for all accesses. */\n\tmmio = pci_resource_start(ha->pdev, 1);\n\tmmio_len = pci_resource_len(ha->pdev, 1);\n\tmmio_flags = pci_resource_flags(ha->pdev, 1);\n\n\tif (!(mmio_flags & IORESOURCE_MEM)) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t    \"region #0 not an MMIO resource, aborting\\n\");\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\tif (mmio_len < MIN_IOBASE_LEN) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t    \"Invalid PCI mem region size, aborting\\n\");\n\t\tgoto iospace_error_exit;\n\t}\n\n\tif (pci_request_regions(ha->pdev, DRIVER_NAME)) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"Failed to reserve PIO/MMIO regions\\n\");\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\tha->pio_address = pio;\n\tha->pio_length = pio_len;\n\tha->reg = ioremap(mmio, MIN_IOBASE_LEN);\n\tif (!ha->reg) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t    \"cannot remap MMIO, aborting\\n\");\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\treturn 0;\n\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\nstatic struct isp_operations qla4xxx_isp_ops = {\n\t.iospace_config         = qla4xxx_iospace_config,\n\t.pci_config             = qla4xxx_pci_config,\n\t.disable_intrs          = qla4xxx_disable_intrs,\n\t.enable_intrs           = qla4xxx_enable_intrs,\n\t.start_firmware         = qla4xxx_start_firmware,\n\t.intr_handler           = qla4xxx_intr_handler,\n\t.interrupt_service_routine = qla4xxx_interrupt_service_routine,\n\t.reset_chip             = qla4xxx_soft_reset,\n\t.reset_firmware         = qla4xxx_hw_reset,\n\t.queue_iocb             = qla4xxx_queue_iocb,\n\t.complete_iocb          = qla4xxx_complete_iocb,\n\t.rd_shdw_req_q_out      = qla4xxx_rd_shdw_req_q_out,\n\t.rd_shdw_rsp_q_in       = qla4xxx_rd_shdw_rsp_q_in,\n\t.get_sys_info           = qla4xxx_get_sys_info,\n\t.queue_mailbox_command\t= qla4xxx_queue_mbox_cmd,\n\t.process_mailbox_interrupt = qla4xxx_process_mbox_intr,\n};\n\nstatic struct isp_operations qla4_82xx_isp_ops = {\n\t.iospace_config         = qla4_8xxx_iospace_config,\n\t.pci_config             = qla4_8xxx_pci_config,\n\t.disable_intrs          = qla4_82xx_disable_intrs,\n\t.enable_intrs           = qla4_82xx_enable_intrs,\n\t.start_firmware         = qla4_8xxx_load_risc,\n\t.restart_firmware\t= qla4_82xx_try_start_fw,\n\t.intr_handler           = qla4_82xx_intr_handler,\n\t.interrupt_service_routine = qla4_82xx_interrupt_service_routine,\n\t.need_reset\t\t= qla4_8xxx_need_reset,\n\t.reset_chip             = qla4_82xx_isp_reset,\n\t.reset_firmware         = qla4_8xxx_stop_firmware,\n\t.queue_iocb             = qla4_82xx_queue_iocb,\n\t.complete_iocb          = qla4_82xx_complete_iocb,\n\t.rd_shdw_req_q_out      = qla4_82xx_rd_shdw_req_q_out,\n\t.rd_shdw_rsp_q_in       = qla4_82xx_rd_shdw_rsp_q_in,\n\t.get_sys_info           = qla4_8xxx_get_sys_info,\n\t.rd_reg_direct\t\t= qla4_82xx_rd_32,\n\t.wr_reg_direct\t\t= qla4_82xx_wr_32,\n\t.rd_reg_indirect\t= qla4_82xx_md_rd_32,\n\t.wr_reg_indirect\t= qla4_82xx_md_wr_32,\n\t.idc_lock\t\t= qla4_82xx_idc_lock,\n\t.idc_unlock\t\t= qla4_82xx_idc_unlock,\n\t.rom_lock_recovery\t= qla4_82xx_rom_lock_recovery,\n\t.queue_mailbox_command\t= qla4_82xx_queue_mbox_cmd,\n\t.process_mailbox_interrupt = qla4_82xx_process_mbox_intr,\n};\n\nstatic struct isp_operations qla4_83xx_isp_ops = {\n\t.iospace_config\t\t= qla4_8xxx_iospace_config,\n\t.pci_config\t\t= qla4_8xxx_pci_config,\n\t.disable_intrs\t\t= qla4_83xx_disable_intrs,\n\t.enable_intrs\t\t= qla4_83xx_enable_intrs,\n\t.start_firmware\t\t= qla4_8xxx_load_risc,\n\t.restart_firmware\t= qla4_83xx_start_firmware,\n\t.intr_handler\t\t= qla4_83xx_intr_handler,\n\t.interrupt_service_routine = qla4_83xx_interrupt_service_routine,\n\t.need_reset\t\t= qla4_8xxx_need_reset,\n\t.reset_chip\t\t= qla4_83xx_isp_reset,\n\t.reset_firmware\t\t= qla4_8xxx_stop_firmware,\n\t.queue_iocb\t\t= qla4_83xx_queue_iocb,\n\t.complete_iocb\t\t= qla4_83xx_complete_iocb,\n\t.rd_shdw_req_q_out\t= qla4xxx_rd_shdw_req_q_out,\n\t.rd_shdw_rsp_q_in\t= qla4xxx_rd_shdw_rsp_q_in,\n\t.get_sys_info\t\t= qla4_8xxx_get_sys_info,\n\t.rd_reg_direct\t\t= qla4_83xx_rd_reg,\n\t.wr_reg_direct\t\t= qla4_83xx_wr_reg,\n\t.rd_reg_indirect\t= qla4_83xx_rd_reg_indirect,\n\t.wr_reg_indirect\t= qla4_83xx_wr_reg_indirect,\n\t.idc_lock\t\t= qla4_83xx_drv_lock,\n\t.idc_unlock\t\t= qla4_83xx_drv_unlock,\n\t.rom_lock_recovery\t= qla4_83xx_rom_lock_recovery,\n\t.queue_mailbox_command\t= qla4_83xx_queue_mbox_cmd,\n\t.process_mailbox_interrupt = qla4_83xx_process_mbox_intr,\n};\n\nuint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(ha->shadow_regs->req_q_out);\n}\n\nuint16_t qla4_82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(readl(&ha->qla4_82xx_reg->req_q_out));\n}\n\nuint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(ha->shadow_regs->rsp_q_in);\n}\n\nuint16_t qla4_82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(readl(&ha->qla4_82xx_reg->rsp_q_in));\n}\n\nstatic ssize_t qla4xxx_show_boot_eth_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tchar *str = buf;\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\t\trc = sprintf(str, \"%d\\n\", SYSFS_FLAG_FW_SEL_BOOT);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = sprintf(str, \"0\\n\");\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_MAC:\n\t\trc = sysfs_format_mac(str, ha->my_mac,\n\t\t\t\t      MAC_ADDR_LEN);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t qla4xxx_eth_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\tcase ISCSI_BOOT_ETH_MAC:\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t qla4xxx_show_boot_ini_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tchar *str = buf;\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = sprintf(str, \"%s\\n\", ha->name_string);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t qla4xxx_ini_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t\nqla4xxx_show_boot_tgt_info(struct ql4_boot_session_info *boot_sess, int type,\n\t\t\t   char *buf)\n{\n\tstruct ql4_conn_info *boot_conn = &boot_sess->conn_list[0];\n\tchar *str = buf;\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\t\trc = sprintf(buf, \"%s\\n\", (char *)&boot_sess->target_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\t\tif (boot_sess->conn_list[0].dest_ipaddr.ip_type == 0x1)\n\t\t\trc = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t     &boot_conn->dest_ipaddr.ip_address);\n\t\telse\n\t\t\trc = sprintf(str, \"%pI6\\n\",\n\t\t\t\t     &boot_conn->dest_ipaddr.ip_address);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_PORT:\n\t\t\trc = sprintf(str, \"%d\\n\", boot_conn->dest_port);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.target_chap_name_length,\n\t\t\t     (char *)&boot_conn->chap.target_chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.target_secret_length,\n\t\t\t     (char *)&boot_conn->chap.target_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.intr_chap_name_length,\n\t\t\t     (char *)&boot_conn->chap.intr_chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.intr_secret_length,\n\t\t\t     (char *)&boot_conn->chap.intr_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = sprintf(str, \"%d\\n\", SYSFS_FLAG_FW_SEL_BOOT);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\t\trc = sprintf(str, \"0\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t qla4xxx_show_boot_tgt_pri_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tstruct ql4_boot_session_info *boot_sess = &(ha->boot_tgt.boot_pri_sess);\n\n\treturn qla4xxx_show_boot_tgt_info(boot_sess, type, buf);\n}\n\nstatic ssize_t qla4xxx_show_boot_tgt_sec_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tstruct ql4_boot_session_info *boot_sess = &(ha->boot_tgt.boot_sec_sess);\n\n\treturn qla4xxx_show_boot_tgt_info(boot_sess, type, buf);\n}\n\nstatic umode_t qla4xxx_tgt_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\tcase ISCSI_BOOT_TGT_PORT:\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void qla4xxx_boot_release(void *data)\n{\n\tstruct scsi_qla_host *ha = data;\n\n\tscsi_host_put(ha->host);\n}\n\nstatic int get_fw_boot_info(struct scsi_qla_host *ha, uint16_t ddb_index[])\n{\n\tdma_addr_t buf_dma;\n\tuint32_t addr, pri_addr, sec_addr;\n\tuint32_t offset;\n\tuint16_t func_num;\n\tuint8_t val;\n\tuint8_t *buf = NULL;\n\tsize_t size = 13 * sizeof(uint8_t);\n\tint ret = QLA_SUCCESS;\n\n\tfunc_num = PCI_FUNC(ha->pdev->devfn);\n\n\tql4_printk(KERN_INFO, ha, \"%s: Get FW boot info for 0x%x func %d\\n\",\n\t\t   __func__, ha->pdev->device, func_num);\n\n\tif (is_qla40XX(ha)) {\n\t\tif (func_num == 1) {\n\t\t\taddr = NVRAM_PORT0_BOOT_MODE;\n\t\t\tpri_addr = NVRAM_PORT0_BOOT_PRI_TGT;\n\t\t\tsec_addr = NVRAM_PORT0_BOOT_SEC_TGT;\n\t\t} else if (func_num == 3) {\n\t\t\taddr = NVRAM_PORT1_BOOT_MODE;\n\t\t\tpri_addr = NVRAM_PORT1_BOOT_PRI_TGT;\n\t\t\tsec_addr = NVRAM_PORT1_BOOT_SEC_TGT;\n\t\t} else {\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info;\n\t\t}\n\n\t\t/* Check Boot Mode */\n\t\tval = rd_nvram_byte(ha, addr);\n\t\tif (!(val & 0x07)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Adapter boot \"\n\t\t\t\t\t  \"options : 0x%x\\n\", __func__, val));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info;\n\t\t}\n\n\t\t/* get primary valid target index */\n\t\tval = rd_nvram_byte(ha, pri_addr);\n\t\tif (val & BIT_7)\n\t\t\tddb_index[0] = (val & 0x7f);\n\n\t\t/* get secondary valid target index */\n\t\tval = rd_nvram_byte(ha, sec_addr);\n\t\tif (val & BIT_7)\n\t\t\tddb_index[1] = (val & 0x7f);\n\t\tgoto exit_boot_info;\n\t} else if (is_qla80XX(ha)) {\n\t\tbuf = dma_alloc_coherent(&ha->pdev->dev, size,\n\t\t\t\t\t &buf_dma, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t\t   __func__));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info;\n\t\t}\n\n\t\tif (ha->port_num == 0)\n\t\t\toffset = BOOT_PARAM_OFFSET_PORT0;\n\t\telse if (ha->port_num == 1)\n\t\t\toffset = BOOT_PARAM_OFFSET_PORT1;\n\t\telse {\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info_free;\n\t\t}\n\t\taddr = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_iscsi_param * 4) +\n\t\t       offset;\n\t\tif (qla4xxx_get_flash(ha, buf_dma, addr,\n\t\t\t\t      13 * sizeof(uint8_t)) != QLA_SUCCESS) {\n\t\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: Get Flash\"\n\t\t\t\t\t  \" failed\\n\", ha->host_no, __func__));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info_free;\n\t\t}\n\t\t/* Check Boot Mode */\n\t\tif (!(buf[1] & 0x07)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Firmware boot options\"\n\t\t\t\t\t  \" : 0x%x\\n\", buf[1]));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info_free;\n\t\t}\n\n\t\t/* get primary valid target index */\n\t\tif (buf[2] & BIT_7)\n\t\t\tddb_index[0] = buf[2] & 0x7f;\n\n\t\t/* get secondary valid target index */\n\t\tif (buf[11] & BIT_7)\n\t\t\tddb_index[1] = buf[11] & 0x7f;\n\t} else {\n\t\tret = QLA_ERROR;\n\t\tgoto exit_boot_info;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Primary target ID %d, Secondary\"\n\t\t\t  \" target ID %d\\n\", __func__, ddb_index[0],\n\t\t\t  ddb_index[1]));\n\nexit_boot_info_free:\n\tdma_free_coherent(&ha->pdev->dev, size, buf, buf_dma);\nexit_boot_info:\n\tha->pri_ddb_idx = ddb_index[0];\n\tha->sec_ddb_idx = ddb_index[1];\n\treturn ret;\n}\n\n/**\n * qla4xxx_get_bidi_chap - Get a BIDI CHAP user and password\n * @ha: pointer to adapter structure\n * @username: CHAP username to be returned\n * @password: CHAP password to be returned\n *\n * If a boot entry has BIDI CHAP enabled then we need to set the BIDI CHAP\n * user and password in the sysfs entry in /sys/firmware/iscsi_boot#/.\n * So from the CHAP cache find the first BIDI CHAP entry and set it\n * to the boot record in sysfs.\n **/\nstatic int qla4xxx_get_bidi_chap(struct scsi_qla_host *ha, char *username,\n\t\t\t    char *password)\n{\n\tint i, ret = -EINVAL;\n\tint max_chap_entries = 0;\n\tstruct ql4_chap_table *chap_table;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"Do not have CHAP table cache\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&ha->chap_sem);\n\tfor (i = 0; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\t\tif (chap_table->cookie !=\n\t\t    __constant_cpu_to_le16(CHAP_VALID_COOKIE)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chap_table->flags & BIT_7) /* local */\n\t\t\tcontinue;\n\n\t\tif (!(chap_table->flags & BIT_6)) /* Not BIDI */\n\t\t\tcontinue;\n\n\t\tstrlcpy(password, chap_table->secret, QL4_CHAP_MAX_SECRET_LEN);\n\t\tstrlcpy(username, chap_table->name, QL4_CHAP_MAX_NAME_LEN);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ha->chap_sem);\n\n\treturn ret;\n}\n\n\nstatic int qla4xxx_get_boot_target(struct scsi_qla_host *ha,\n\t\t\t\t   struct ql4_boot_session_info *boot_sess,\n\t\t\t\t   uint16_t ddb_index)\n{\n\tstruct ql4_conn_info *boot_conn = &boot_sess->conn_list[0];\n\tstruct dev_db_entry *fw_ddb_entry;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint16_t idx;\n\tuint16_t options;\n\tint ret = QLA_SUCCESS;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer.\\n\",\n\t\t\t\t  __func__));\n\t\tret = QLA_ERROR;\n\t\treturn ret;\n\t}\n\n\tif (qla4xxx_bootdb_by_index(ha, fw_ddb_entry,\n\t\t\t\t   fw_ddb_entry_dma, ddb_index)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: No Flash DDB found at \"\n\t\t\t\t  \"index [%d]\\n\", __func__, ddb_index));\n\t\tret = QLA_ERROR;\n\t\tgoto exit_boot_target;\n\t}\n\n\t/* Update target name and IP from DDB */\n\tmemcpy(boot_sess->target_name, fw_ddb_entry->iscsi_name,\n\t       min(sizeof(boot_sess->target_name),\n\t\t   sizeof(fw_ddb_entry->iscsi_name)));\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\tmemcpy(&boot_conn->dest_ipaddr.ip_address,\n\t\t       &fw_ddb_entry->ip_addr[0], IPv6_ADDR_LEN);\n\t} else {\n\t\tboot_conn->dest_ipaddr.ip_type = 0x1;\n\t\tmemcpy(&boot_conn->dest_ipaddr.ip_address,\n\t\t       &fw_ddb_entry->ip_addr[0], IP_ADDR_LEN);\n\t}\n\n\tboot_conn->dest_port = le16_to_cpu(fw_ddb_entry->port);\n\n\t/* update chap information */\n\tidx = __le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\n\tif (BIT_7 & le16_to_cpu(fw_ddb_entry->iscsi_options))\t{\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Setting chap\\n\"));\n\n\t\tret = qla4xxx_get_chap(ha, (char *)&boot_conn->chap.\n\t\t\t\t       target_chap_name,\n\t\t\t\t       (char *)&boot_conn->chap.target_secret,\n\t\t\t\t       idx);\n\t\tif (ret) {\n\t\t\tql4_printk(KERN_ERR, ha, \"Failed to set chap\\n\");\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_target;\n\t\t}\n\n\t\tboot_conn->chap.target_chap_name_length = QL4_CHAP_MAX_NAME_LEN;\n\t\tboot_conn->chap.target_secret_length = QL4_CHAP_MAX_SECRET_LEN;\n\t}\n\n\tif (BIT_4 & le16_to_cpu(fw_ddb_entry->iscsi_options)) {\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Setting BIDI chap\\n\"));\n\n\t\tret = qla4xxx_get_bidi_chap(ha,\n\t\t\t\t    (char *)&boot_conn->chap.intr_chap_name,\n\t\t\t\t    (char *)&boot_conn->chap.intr_secret);\n\n\t\tif (ret) {\n\t\t\tql4_printk(KERN_ERR, ha, \"Failed to set BIDI chap\\n\");\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_target;\n\t\t}\n\n\t\tboot_conn->chap.intr_chap_name_length = QL4_CHAP_MAX_NAME_LEN;\n\t\tboot_conn->chap.intr_secret_length = QL4_CHAP_MAX_SECRET_LEN;\n\t}\n\nexit_boot_target:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\nstatic int qla4xxx_get_boot_info(struct scsi_qla_host *ha)\n{\n\tuint16_t ddb_index[2];\n\tint ret = QLA_ERROR;\n\tint rval;\n\n\tmemset(ddb_index, 0, sizeof(ddb_index));\n\tddb_index[0] = 0xffff;\n\tddb_index[1] = 0xffff;\n\tret = get_fw_boot_info(ha, ddb_index);\n\tif (ret != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\"%s: No boot target configured.\\n\", __func__));\n\t\treturn ret;\n\t}\n\n\tif (ql4xdisablesysfsboot)\n\t\treturn QLA_SUCCESS;\n\n\tif (ddb_index[0] == 0xffff)\n\t\tgoto sec_target;\n\n\trval = qla4xxx_get_boot_target(ha, &(ha->boot_tgt.boot_pri_sess),\n\t\t\t\t      ddb_index[0]);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Primary boot target not \"\n\t\t\t\t  \"configured\\n\", __func__));\n\t} else\n\t\tret = QLA_SUCCESS;\n\nsec_target:\n\tif (ddb_index[1] == 0xffff)\n\t\tgoto exit_get_boot_info;\n\n\trval = qla4xxx_get_boot_target(ha, &(ha->boot_tgt.boot_sec_sess),\n\t\t\t\t      ddb_index[1]);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Secondary boot target not\"\n\t\t\t\t  \" configured\\n\", __func__));\n\t} else\n\t\tret = QLA_SUCCESS;\n\nexit_get_boot_info:\n\treturn ret;\n}\n\nstatic int qla4xxx_setup_boot_info(struct scsi_qla_host *ha)\n{\n\tstruct iscsi_boot_kobj *boot_kobj;\n\n\tif (qla4xxx_get_boot_info(ha) != QLA_SUCCESS)\n\t\treturn QLA_ERROR;\n\n\tif (ql4xdisablesysfsboot) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: syfsboot disabled - driver will trigger login \"\n\t\t\t   \"and publish session for discovery .\\n\", __func__);\n\t\treturn QLA_SUCCESS;\n\t}\n\n\n\tha->boot_kset = iscsi_boot_create_host_kset(ha->host->host_no);\n\tif (!ha->boot_kset)\n\t\tgoto kset_free;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_target(ha->boot_kset, 0, ha,\n\t\t\t\t\t     qla4xxx_show_boot_tgt_pri_info,\n\t\t\t\t\t     qla4xxx_tgt_get_attr_visibility,\n\t\t\t\t\t     qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_target(ha->boot_kset, 1, ha,\n\t\t\t\t\t     qla4xxx_show_boot_tgt_sec_info,\n\t\t\t\t\t     qla4xxx_tgt_get_attr_visibility,\n\t\t\t\t\t     qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_initiator(ha->boot_kset, 0, ha,\n\t\t\t\t\t       qla4xxx_show_boot_ini_info,\n\t\t\t\t\t       qla4xxx_ini_get_attr_visibility,\n\t\t\t\t\t       qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_ethernet(ha->boot_kset, 0, ha,\n\t\t\t\t\t       qla4xxx_show_boot_eth_info,\n\t\t\t\t\t       qla4xxx_eth_get_attr_visibility,\n\t\t\t\t\t       qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\treturn QLA_SUCCESS;\n\nput_host:\n\tscsi_host_put(ha->host);\nkset_free:\n\tiscsi_boot_destroy_kset(ha->boot_kset);\n\treturn -ENOMEM;\n}\n\n\nstatic void qla4xxx_get_param_ddb(struct ddb_entry *ddb_entry,\n\t\t\t\t  struct ql4_tuple_ddb *tddb)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_conn *conn;\n\n\tDEBUG2(printk(KERN_INFO \"Func: %s\\n\", __func__));\n\tcls_sess = ddb_entry->sess;\n\tsess = cls_sess->dd_data;\n\tcls_conn = ddb_entry->conn;\n\tconn = cls_conn->dd_data;\n\n\ttddb->tpgt = sess->tpgt;\n\ttddb->port = conn->persistent_port;\n\tstrlcpy(tddb->iscsi_name, sess->targetname, ISCSI_NAME_SIZE);\n\tstrlcpy(tddb->ip_addr, conn->persistent_address, DDB_IPADDR_LEN);\n}\n\nstatic void qla4xxx_convert_param_ddb(struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t      struct ql4_tuple_ddb *tddb,\n\t\t\t\t      uint8_t *flash_isid)\n{\n\tuint16_t options = 0;\n\n\ttddb->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\n\tmemcpy(&tddb->iscsi_name[0], &fw_ddb_entry->iscsi_name[0],\n\t       min(sizeof(tddb->iscsi_name), sizeof(fw_ddb_entry->iscsi_name)));\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE)\n\t\tsprintf(tddb->ip_addr, \"%pI6\", fw_ddb_entry->ip_addr);\n\telse\n\t\tsprintf(tddb->ip_addr, \"%pI4\", fw_ddb_entry->ip_addr);\n\n\ttddb->port = le16_to_cpu(fw_ddb_entry->port);\n\n\tif (flash_isid == NULL)\n\t\tmemcpy(&tddb->isid[0], &fw_ddb_entry->isid[0],\n\t\t       sizeof(tddb->isid));\n\telse\n\t\tmemcpy(&tddb->isid[0], &flash_isid[0], sizeof(tddb->isid));\n}\n\nstatic int qla4xxx_compare_tuple_ddb(struct scsi_qla_host *ha,\n\t\t\t\t     struct ql4_tuple_ddb *old_tddb,\n\t\t\t\t     struct ql4_tuple_ddb *new_tddb,\n\t\t\t\t     uint8_t is_isid_compare)\n{\n\tif (strcmp(old_tddb->iscsi_name, new_tddb->iscsi_name))\n\t\treturn QLA_ERROR;\n\n\tif (strcmp(old_tddb->ip_addr, new_tddb->ip_addr))\n\t\treturn QLA_ERROR;\n\n\tif (old_tddb->port != new_tddb->port)\n\t\treturn QLA_ERROR;\n\n\t/* For multi sessions, driver generates the ISID, so do not compare\n\t * ISID in reset path since it would be a comparison between the\n\t * driver generated ISID and firmware generated ISID. This could\n\t * lead to adding duplicated DDBs in the list as driver generated\n\t * ISID would not match firmware generated ISID.\n\t */\n\tif (is_isid_compare) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\"%s: old ISID [%pmR] New ISID [%pmR]\\n\",\n\t\t\t__func__, old_tddb->isid, new_tddb->isid));\n\n\t\tif (memcmp(&old_tddb->isid[0], &new_tddb->isid[0],\n\t\t\t   sizeof(old_tddb->isid)))\n\t\t\treturn QLA_ERROR;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Match Found, fw[%d,%d,%s,%s], [%d,%d,%s,%s]\",\n\t\t\t  old_tddb->port, old_tddb->tpgt, old_tddb->ip_addr,\n\t\t\t  old_tddb->iscsi_name, new_tddb->port, new_tddb->tpgt,\n\t\t\t  new_tddb->ip_addr, new_tddb->iscsi_name));\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int qla4xxx_is_session_exists(struct scsi_qla_host *ha,\n\t\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t     uint32_t *index)\n{\n\tstruct ddb_entry *ddb_entry;\n\tstruct ql4_tuple_ddb *fw_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tint idx;\n\tint ret = QLA_ERROR;\n\n\tfw_tddb = vzalloc(sizeof(*fw_tddb));\n\tif (!fw_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\tqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tqla4xxx_get_param_ddb(ddb_entry, tmp_tddb);\n\t\tif (!qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, false)) {\n\t\t\tret = QLA_SUCCESS; /* found */\n\t\t\tif (index != NULL)\n\t\t\t\t*index = idx;\n\t\t\tgoto exit_check;\n\t\t}\n\t}\n\nexit_check:\n\tif (fw_tddb)\n\t\tvfree(fw_tddb);\n\tif (tmp_tddb)\n\t\tvfree(tmp_tddb);\n\treturn ret;\n}\n\n/**\n * qla4xxx_check_existing_isid - check if target with same isid exist\n *\t\t\t\t in target list\n * @list_nt: list of target\n * @isid: isid to check\n *\n * This routine return QLA_SUCCESS if target with same isid exist\n **/\nstatic int qla4xxx_check_existing_isid(struct list_head *list_nt, uint8_t *isid)\n{\n\tstruct qla_ddb_index *nt_ddb_idx, *nt_ddb_idx_tmp;\n\tstruct dev_db_entry *fw_ddb_entry;\n\n\tlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\n\t\tfw_ddb_entry = &nt_ddb_idx->fw_ddb;\n\n\t\tif (memcmp(&fw_ddb_entry->isid[0], &isid[0],\n\t\t\t   sizeof(nt_ddb_idx->fw_ddb.isid)) == 0) {\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t}\n\treturn QLA_ERROR;\n}\n\n/**\n * qla4xxx_update_isid - compare ddbs and updated isid\n * @ha: Pointer to host adapter structure.\n * @list_nt: list of nt target\n * @fw_ddb_entry: firmware ddb entry\n *\n * This routine update isid if ddbs have same iqn, same isid and\n * different IP addr.\n * Return QLA_SUCCESS if isid is updated.\n **/\nstatic int qla4xxx_update_isid(struct scsi_qla_host *ha,\n\t\t\t       struct list_head *list_nt,\n\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tuint8_t base_value, i;\n\n\tbase_value = fw_ddb_entry->isid[1] & 0x1f;\n\tfor (i = 0; i < 8; i++) {\n\t\tfw_ddb_entry->isid[1] = (base_value | (i << 5));\n\t\tif (qla4xxx_check_existing_isid(list_nt, fw_ddb_entry->isid))\n\t\t\tbreak;\n\t}\n\n\tif (!qla4xxx_check_existing_isid(list_nt, fw_ddb_entry->isid))\n\t\treturn QLA_ERROR;\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla4xxx_should_update_isid - check if isid need to update\n * @ha: Pointer to host adapter structure.\n * @old_tddb: ddb tuple\n * @new_tddb: ddb tuple\n *\n * Return QLA_SUCCESS if different IP, different PORT, same iqn,\n * same isid\n **/\nstatic int qla4xxx_should_update_isid(struct scsi_qla_host *ha,\n\t\t\t\t      struct ql4_tuple_ddb *old_tddb,\n\t\t\t\t      struct ql4_tuple_ddb *new_tddb)\n{\n\tif (strcmp(old_tddb->ip_addr, new_tddb->ip_addr) == 0) {\n\t\t/* Same ip */\n\t\tif (old_tddb->port == new_tddb->port)\n\t\t\treturn QLA_ERROR;\n\t}\n\n\tif (strcmp(old_tddb->iscsi_name, new_tddb->iscsi_name))\n\t\t/* different iqn */\n\t\treturn QLA_ERROR;\n\n\tif (memcmp(&old_tddb->isid[0], &new_tddb->isid[0],\n\t\t   sizeof(old_tddb->isid)))\n\t\t/* different isid */\n\t\treturn QLA_ERROR;\n\n\treturn QLA_SUCCESS;\n}\n\n/**\n * qla4xxx_is_flash_ddb_exists - check if fw_ddb_entry already exists in list_nt\n * @ha: Pointer to host adapter structure.\n * @list_nt: list of nt target.\n * @fw_ddb_entry: firmware ddb entry.\n *\n * This routine check if fw_ddb_entry already exists in list_nt to avoid\n * duplicate ddb in list_nt.\n * Return QLA_SUCCESS if duplicate ddb exit in list_nl.\n * Note: This function also update isid of DDB if required.\n **/\n\nstatic int qla4xxx_is_flash_ddb_exists(struct scsi_qla_host *ha,\n\t\t\t\t       struct list_head *list_nt,\n\t\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tstruct qla_ddb_index  *nt_ddb_idx, *nt_ddb_idx_tmp;\n\tstruct ql4_tuple_ddb *fw_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tint rval, ret = QLA_ERROR;\n\n\tfw_tddb = vzalloc(sizeof(*fw_tddb));\n\tif (!fw_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\tqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\n\n\tlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\n\t\tqla4xxx_convert_param_ddb(&nt_ddb_idx->fw_ddb, tmp_tddb,\n\t\t\t\t\t  nt_ddb_idx->flash_isid);\n\t\tret = qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, true);\n\t\t/* found duplicate ddb */\n\t\tif (ret == QLA_SUCCESS)\n\t\t\tgoto exit_check;\n\t}\n\n\tlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\n\t\tqla4xxx_convert_param_ddb(&nt_ddb_idx->fw_ddb, tmp_tddb, NULL);\n\n\t\tret = qla4xxx_should_update_isid(ha, tmp_tddb, fw_tddb);\n\t\tif (ret == QLA_SUCCESS) {\n\t\t\trval = qla4xxx_update_isid(ha, list_nt, fw_ddb_entry);\n\t\t\tif (rval == QLA_SUCCESS)\n\t\t\t\tret = QLA_ERROR;\n\t\t\telse\n\t\t\t\tret = QLA_SUCCESS;\n\n\t\t\tgoto exit_check;\n\t\t}\n\t}\n\nexit_check:\n\tif (fw_tddb)\n\t\tvfree(fw_tddb);\n\tif (tmp_tddb)\n\t\tvfree(tmp_tddb);\n\treturn ret;\n}\n\nstatic void qla4xxx_free_ddb_list(struct list_head *list_ddb)\n{\n\tstruct qla_ddb_index  *ddb_idx, *ddb_idx_tmp;\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\n\t\tlist_del_init(&ddb_idx->list);\n\t\tvfree(ddb_idx);\n\t}\n}\n\nstatic struct iscsi_endpoint *qla4xxx_get_ep_fwdb(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct dev_db_entry *fw_ddb_entry)\n{\n\tstruct iscsi_endpoint *ep;\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tstruct sockaddr *t_addr;\n\tstruct sockaddr_storage *dst_addr;\n\tchar *ip;\n\n\t/* TODO: need to destroy on unload iscsi_endpoint*/\n\tdst_addr = vmalloc(sizeof(*dst_addr));\n\tif (!dst_addr)\n\t\treturn NULL;\n\n\tif (fw_ddb_entry->options & DDB_OPT_IPV6_DEVICE) {\n\t\tt_addr = (struct sockaddr *)dst_addr;\n\t\tt_addr->sa_family = AF_INET6;\n\t\taddr6 = (struct sockaddr_in6 *)dst_addr;\n\t\tip = (char *)&addr6->sin6_addr;\n\t\tmemcpy(ip, fw_ddb_entry->ip_addr, IPv6_ADDR_LEN);\n\t\taddr6->sin6_port = htons(le16_to_cpu(fw_ddb_entry->port));\n\n\t} else {\n\t\tt_addr = (struct sockaddr *)dst_addr;\n\t\tt_addr->sa_family = AF_INET;\n\t\taddr = (struct sockaddr_in *)dst_addr;\n\t\tip = (char *)&addr->sin_addr;\n\t\tmemcpy(ip, fw_ddb_entry->ip_addr, IP_ADDR_LEN);\n\t\taddr->sin_port = htons(le16_to_cpu(fw_ddb_entry->port));\n\t}\n\n\tep = qla4xxx_ep_connect(ha->host, (struct sockaddr *)dst_addr, 0);\n\tvfree(dst_addr);\n\treturn ep;\n}\n\nstatic int qla4xxx_verify_boot_idx(struct scsi_qla_host *ha, uint16_t idx)\n{\n\tif (ql4xdisablesysfsboot)\n\t\treturn QLA_SUCCESS;\n\tif (idx == ha->pri_ddb_idx || idx == ha->sec_ddb_idx)\n\t\treturn QLA_ERROR;\n\treturn QLA_SUCCESS;\n}\n\nstatic void qla4xxx_setup_flash_ddb_entry(struct scsi_qla_host *ha,\n\t\t\t\t\t  struct ddb_entry *ddb_entry,\n\t\t\t\t\t  uint16_t idx)\n{\n\tuint16_t def_timeout;\n\n\tddb_entry->ddb_type = FLASH_DDB;\n\tddb_entry->fw_ddb_index = INVALID_ENTRY;\n\tddb_entry->fw_ddb_device_state = DDB_DS_NO_CONNECTION_ACTIVE;\n\tddb_entry->ha = ha;\n\tddb_entry->unblock_sess = qla4xxx_unblock_flash_ddb;\n\tddb_entry->ddb_change = qla4xxx_flash_ddb_change;\n\tddb_entry->chap_tbl_idx = INVALID_ENTRY;\n\n\tatomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\n\tatomic_set(&ddb_entry->relogin_timer, 0);\n\tatomic_set(&ddb_entry->relogin_retry_count, 0);\n\tdef_timeout = le16_to_cpu(ddb_entry->fw_ddb_entry.def_timeout);\n\tddb_entry->default_relogin_timeout =\n\t\t(def_timeout > LOGIN_TOV) && (def_timeout < LOGIN_TOV * 10) ?\n\t\tdef_timeout : LOGIN_TOV;\n\tddb_entry->default_time2wait =\n\t\tle16_to_cpu(ddb_entry->fw_ddb_entry.iscsi_def_time2wait);\n\n\tif (ql4xdisablesysfsboot &&\n\t    (idx == ha->pri_ddb_idx || idx == ha->sec_ddb_idx))\n\t\tset_bit(DF_BOOT_TGT, &ddb_entry->flags);\n}\n\nstatic void qla4xxx_wait_for_ip_configuration(struct scsi_qla_host *ha)\n{\n\tuint32_t idx = 0;\n\tuint32_t ip_idx[IP_ADDR_COUNT] = {0, 1, 2, 3}; /* 4 IP interfaces */\n\tuint32_t sts[MBOX_REG_COUNT];\n\tuint32_t ip_state;\n\tunsigned long wtime;\n\tint ret;\n\n\twtime = jiffies + (HZ * IP_CONFIG_TOV);\n\tdo {\n\t\tfor (idx = 0; idx < IP_ADDR_COUNT; idx++) {\n\t\t\tif (ip_idx[idx] == -1)\n\t\t\t\tcontinue;\n\n\t\t\tret = qla4xxx_get_ip_state(ha, 0, ip_idx[idx], sts);\n\n\t\t\tif (ret == QLA_ERROR) {\n\t\t\t\tip_idx[idx] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tip_state = (sts[1] & IP_STATE_MASK) >> IP_STATE_SHIFT;\n\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Waiting for IP state for idx = %d, state = 0x%x\\n\",\n\t\t\t\t\t  ip_idx[idx], ip_state));\n\t\t\tif (ip_state == IP_ADDRSTATE_UNCONFIGURED ||\n\t\t\t    ip_state == IP_ADDRSTATE_INVALID ||\n\t\t\t    ip_state == IP_ADDRSTATE_PREFERRED ||\n\t\t\t    ip_state == IP_ADDRSTATE_DEPRICATED ||\n\t\t\t    ip_state == IP_ADDRSTATE_DISABLING)\n\t\t\t\tip_idx[idx] = -1;\n\t\t}\n\n\t\t/* Break if all IP states checked */\n\t\tif ((ip_idx[0] == -1) &&\n\t\t    (ip_idx[1] == -1) &&\n\t\t    (ip_idx[2] == -1) &&\n\t\t    (ip_idx[3] == -1))\n\t\t\tbreak;\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while (time_after(wtime, jiffies));\n}\n\nstatic int qla4xxx_cmp_fw_stentry(struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t  struct dev_db_entry *flash_ddb_entry)\n{\n\tuint16_t options = 0;\n\tsize_t ip_len = IP_ADDR_LEN;\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE)\n\t\tip_len = IPv6_ADDR_LEN;\n\n\tif (memcmp(fw_ddb_entry->ip_addr, flash_ddb_entry->ip_addr, ip_len))\n\t\treturn QLA_ERROR;\n\n\tif (memcmp(&fw_ddb_entry->isid[0], &flash_ddb_entry->isid[0],\n\t\t   sizeof(fw_ddb_entry->isid)))\n\t\treturn QLA_ERROR;\n\n\tif (memcmp(&fw_ddb_entry->port, &flash_ddb_entry->port,\n\t\t   sizeof(fw_ddb_entry->port)))\n\t\treturn QLA_ERROR;\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int qla4xxx_find_flash_st_idx(struct scsi_qla_host *ha,\n\t\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t     uint32_t fw_idx, uint32_t *flash_index)\n{\n\tstruct dev_db_entry *flash_ddb_entry;\n\tdma_addr_t flash_ddb_entry_dma;\n\tuint32_t idx = 0;\n\tint max_ddbs;\n\tint ret = QLA_ERROR, status;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tflash_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t\t &flash_ddb_entry_dma);\n\tif (flash_ddb_entry == NULL || fw_ddb_entry == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"Out of memory\\n\");\n\t\tgoto exit_find_st_idx;\n\t}\n\n\tstatus = qla4xxx_flashdb_by_index(ha, flash_ddb_entry,\n\t\t\t\t\t  flash_ddb_entry_dma, fw_idx);\n\tif (status == QLA_SUCCESS) {\n\t\tstatus = qla4xxx_cmp_fw_stentry(fw_ddb_entry, flash_ddb_entry);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\t*flash_index = fw_idx;\n\t\t\tret = QLA_SUCCESS;\n\t\t\tgoto exit_find_st_idx;\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tstatus = qla4xxx_flashdb_by_index(ha, flash_ddb_entry,\n\t\t\t\t\t\t  flash_ddb_entry_dma, idx);\n\t\tif (status == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tstatus = qla4xxx_cmp_fw_stentry(fw_ddb_entry, flash_ddb_entry);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\t*flash_index = idx;\n\t\t\tret = QLA_SUCCESS;\n\t\t\tgoto exit_find_st_idx;\n\t\t}\n\t}\n\n\tif (idx == max_ddbs)\n\t\tql4_printk(KERN_ERR, ha, \"Failed to find ST [%d] in flash\\n\",\n\t\t\t   fw_idx);\n\nexit_find_st_idx:\n\tif (flash_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, flash_ddb_entry,\n\t\t\t      flash_ddb_entry_dma);\n\n\treturn ret;\n}\n\nstatic void qla4xxx_build_st_list(struct scsi_qla_host *ha,\n\t\t\t\t  struct list_head *list_st)\n{\n\tstruct qla_ddb_index  *st_ddb_idx;\n\tint max_ddbs;\n\tint fw_idx_size;\n\tstruct dev_db_entry *fw_ddb_entry;\n\tdma_addr_t fw_ddb_dma;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint32_t flash_index = -1;\n\tuint16_t conn_id = 0;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_st_list;\n\t}\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\tfw_idx_size = sizeof(struct qla_ddb_index);\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\n\t\t\t\t\t      NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, &conn_id);\n\t\tif (ret == QLA_ERROR)\n\t\t\tbreak;\n\n\t\t/* Ignore DDB if invalid state (unassigned) */\n\t\tif (state == DDB_DS_UNASSIGNED)\n\t\t\tgoto continue_next_st;\n\n\t\t/* Check if ST, add to the list_st */\n\t\tif (strlen((char *) fw_ddb_entry->iscsi_name) != 0)\n\t\t\tgoto continue_next_st;\n\n\t\tst_ddb_idx = vzalloc(fw_idx_size);\n\t\tif (!st_ddb_idx)\n\t\t\tbreak;\n\n\t\tret = qla4xxx_find_flash_st_idx(ha, fw_ddb_entry, idx,\n\t\t\t\t\t\t&flash_index);\n\t\tif (ret == QLA_ERROR) {\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"No flash entry for ST at idx [%d]\\n\", idx);\n\t\t\tst_ddb_idx->flash_ddb_idx = idx;\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"ST at idx [%d] is stored at flash [%d]\\n\",\n\t\t\t\t   idx, flash_index);\n\t\t\tst_ddb_idx->flash_ddb_idx = flash_index;\n\t\t}\n\n\t\tst_ddb_idx->fw_ddb_idx = idx;\n\n\t\tlist_add_tail(&st_ddb_idx->list, list_st);\ncontinue_next_st:\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n\nexit_st_list:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\n/**\n * qla4xxx_remove_failed_ddb - Remove inactive or failed ddb from list\n * @ha: pointer to adapter structure\n * @list_ddb: List from which failed ddb to be removed\n *\n * Iterate over the list of DDBs and find and remove DDBs that are either in\n * no connection active state or failed state\n **/\nstatic void qla4xxx_remove_failed_ddb(struct scsi_qla_host *ha,\n\t\t\t\t      struct list_head *list_ddb)\n{\n\tstruct qla_ddb_index  *ddb_idx, *ddb_idx_tmp;\n\tuint32_t next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tint ret;\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, ddb_idx->fw_ddb_idx,\n\t\t\t\t\t      NULL, 0, NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED) {\n\t\t\tlist_del_init(&ddb_idx->list);\n\t\t\tvfree(ddb_idx);\n\t\t}\n\t}\n}\n\nstatic void qla4xxx_update_sess_disc_idx(struct scsi_qla_host *ha,\n\t\t\t\t\t struct ddb_entry *ddb_entry,\n\t\t\t\t\t struct dev_db_entry *fw_ddb_entry)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_session *sess;\n\tuint32_t max_ddbs = 0;\n\tuint16_t ddb_link = -1;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tcls_sess = ddb_entry->sess;\n\tsess = cls_sess->dd_data;\n\n\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tif (ddb_link < max_ddbs)\n\t\tsess->discovery_parent_idx = ddb_link;\n\telse\n\t\tsess->discovery_parent_idx = DDB_NO_LINK;\n}\n\nstatic int qla4xxx_sess_conn_setup(struct scsi_qla_host *ha,\n\t\t\t\t   struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t   int is_reset, uint16_t idx)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_endpoint *ep;\n\tuint16_t cmds_max = 32;\n\tuint16_t conn_id = 0;\n\tuint32_t initial_cmdsn = 0;\n\tint ret = QLA_SUCCESS;\n\n\tstruct ddb_entry *ddb_entry = NULL;\n\n\t/* Create session object, with INVALID_ENTRY,\n\t * the targer_id would get set when we issue the login\n\t */\n\tcls_sess = iscsi_session_setup(&qla4xxx_iscsi_transport, ha->host,\n\t\t\t\t       cmds_max, sizeof(struct ddb_entry),\n\t\t\t\t       sizeof(struct ql4_task_data),\n\t\t\t\t       initial_cmdsn, INVALID_ENTRY);\n\tif (!cls_sess) {\n\t\tret = QLA_ERROR;\n\t\tgoto exit_setup;\n\t}\n\n\t/*\n\t * so calling module_put function to decrement the\n\t * reference count.\n\t **/\n\tmodule_put(qla4xxx_iscsi_transport.owner);\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->sess = cls_sess;\n\n\tcls_sess->recovery_tmo = ql4xsess_recovery_tmo;\n\tmemcpy(&ddb_entry->fw_ddb_entry, fw_ddb_entry,\n\t       sizeof(struct dev_db_entry));\n\n\tqla4xxx_setup_flash_ddb_entry(ha, ddb_entry, idx);\n\n\tcls_conn = iscsi_conn_setup(cls_sess, sizeof(struct qla_conn), conn_id);\n\n\tif (!cls_conn) {\n\t\tret = QLA_ERROR;\n\t\tgoto exit_setup;\n\t}\n\n\tddb_entry->conn = cls_conn;\n\n\t/* Setup ep, for displaying attributes in sysfs */\n\tep = qla4xxx_get_ep_fwdb(ha, fw_ddb_entry);\n\tif (ep) {\n\t\tep->conn = cls_conn;\n\t\tcls_conn->ep = ep;\n\t} else {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Unable to get ep\\n\"));\n\t\tret = QLA_ERROR;\n\t\tgoto exit_setup;\n\t}\n\n\t/* Update sess/conn params */\n\tqla4xxx_copy_fwddb_param(ha, fw_ddb_entry, cls_sess, cls_conn);\n\tqla4xxx_update_sess_disc_idx(ha, ddb_entry, fw_ddb_entry);\n\n\tif (is_reset == RESET_ADAPTER) {\n\t\tiscsi_block_session(cls_sess);\n\t\t/* Use the relogin path to discover new devices\n\t\t *  by short-circuiting the logic of setting\n\t\t *  timer to relogin - instead set the flags\n\t\t *  to initiate login right away.\n\t\t */\n\t\tset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\n\t\tset_bit(DF_RELOGIN, &ddb_entry->flags);\n\t}\n\nexit_setup:\n\treturn ret;\n}\n\nstatic void qla4xxx_update_fw_ddb_link(struct scsi_qla_host *ha,\n\t\t\t\t       struct list_head *list_ddb,\n\t\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tstruct qla_ddb_index  *ddb_idx, *ddb_idx_tmp;\n\tuint16_t ddb_link;\n\n\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\n\t\tif (ddb_idx->fw_ddb_idx == ddb_link) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Updating NT parent idx from [%d] to [%d]\\n\",\n\t\t\t\t\t  ddb_link, ddb_idx->flash_ddb_idx));\n\t\t\tfw_ddb_entry->ddb_link =\n\t\t\t\t\t    cpu_to_le16(ddb_idx->flash_ddb_idx);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void qla4xxx_build_nt_list(struct scsi_qla_host *ha,\n\t\t\t\t  struct list_head *list_nt,\n\t\t\t\t  struct list_head *list_st,\n\t\t\t\t  int is_reset)\n{\n\tstruct dev_db_entry *fw_ddb_entry;\n\tstruct ddb_entry *ddb_entry = NULL;\n\tdma_addr_t fw_ddb_dma;\n\tint max_ddbs;\n\tint fw_idx_size;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint32_t ddb_idx = -1;\n\tuint16_t conn_id = 0;\n\tuint16_t ddb_link = -1;\n\tstruct qla_ddb_index  *nt_ddb_idx;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_nt_list;\n\t}\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\tfw_idx_size = sizeof(struct qla_ddb_index);\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\n\t\t\t\t\t      NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, &conn_id);\n\t\tif (ret == QLA_ERROR)\n\t\t\tbreak;\n\n\t\tif (qla4xxx_verify_boot_idx(ha, idx) != QLA_SUCCESS)\n\t\t\tgoto continue_next_nt;\n\n\t\t/* Check if NT, then add to list it */\n\t\tif (strlen((char *) fw_ddb_entry->iscsi_name) == 0)\n\t\t\tgoto continue_next_nt;\n\n\t\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\t\tif (ddb_link < max_ddbs)\n\t\t\tqla4xxx_update_fw_ddb_link(ha, list_st, fw_ddb_entry);\n\n\t\tif (!(state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED) &&\n\t\t    (is_reset == INIT_ADAPTER))\n\t\t\tgoto continue_next_nt;\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Adding  DDB to session = 0x%x\\n\", idx));\n\n\t\tif (is_reset == INIT_ADAPTER) {\n\t\t\tnt_ddb_idx = vmalloc(fw_idx_size);\n\t\t\tif (!nt_ddb_idx)\n\t\t\t\tbreak;\n\n\t\t\tnt_ddb_idx->fw_ddb_idx = idx;\n\n\t\t\t/* Copy original isid as it may get updated in function\n\t\t\t * qla4xxx_update_isid(). We need original isid in\n\t\t\t * function qla4xxx_compare_tuple_ddb to find duplicate\n\t\t\t * target */\n\t\t\tmemcpy(&nt_ddb_idx->flash_isid[0],\n\t\t\t       &fw_ddb_entry->isid[0],\n\t\t\t       sizeof(nt_ddb_idx->flash_isid));\n\n\t\t\tret = qla4xxx_is_flash_ddb_exists(ha, list_nt,\n\t\t\t\t\t\t\t  fw_ddb_entry);\n\t\t\tif (ret == QLA_SUCCESS) {\n\t\t\t\t/* free nt_ddb_idx and do not add to list_nt */\n\t\t\t\tvfree(nt_ddb_idx);\n\t\t\t\tgoto continue_next_nt;\n\t\t\t}\n\n\t\t\t/* Copy updated isid */\n\t\t\tmemcpy(&nt_ddb_idx->fw_ddb, fw_ddb_entry,\n\t\t\t       sizeof(struct dev_db_entry));\n\n\t\t\tlist_add_tail(&nt_ddb_idx->list, list_nt);\n\t\t} else if (is_reset == RESET_ADAPTER) {\n\t\t\tret = qla4xxx_is_session_exists(ha, fw_ddb_entry,\n\t\t\t\t\t\t\t&ddb_idx);\n\t\t\tif (ret == QLA_SUCCESS) {\n\t\t\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha,\n\t\t\t\t\t\t\t\t       ddb_idx);\n\t\t\t\tif (ddb_entry != NULL)\n\t\t\t\t\tqla4xxx_update_sess_disc_idx(ha,\n\t\t\t\t\t\t\t\t     ddb_entry,\n\t\t\t\t\t\t\t\t  fw_ddb_entry);\n\t\t\t\tgoto continue_next_nt;\n\t\t\t}\n\t\t}\n\n\t\tret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, is_reset, idx);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto exit_nt_list;\n\ncontinue_next_nt:\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n\nexit_nt_list:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\nstatic void qla4xxx_build_new_nt_list(struct scsi_qla_host *ha,\n\t\t\t\t      struct list_head *list_nt,\n\t\t\t\t      uint16_t target_id)\n{\n\tstruct dev_db_entry *fw_ddb_entry;\n\tdma_addr_t fw_ddb_dma;\n\tint max_ddbs;\n\tint fw_idx_size;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint16_t conn_id = 0;\n\tstruct qla_ddb_index  *nt_ddb_idx;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_new_nt_list;\n\t}\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\tfw_idx_size = sizeof(struct qla_ddb_index);\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\n\t\t\t\t\t      NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, &conn_id);\n\t\tif (ret == QLA_ERROR)\n\t\t\tbreak;\n\n\t\t/* Check if NT, then add it to list */\n\t\tif (strlen((char *)fw_ddb_entry->iscsi_name) == 0)\n\t\t\tgoto continue_next_new_nt;\n\n\t\tif (!(state == DDB_DS_NO_CONNECTION_ACTIVE))\n\t\t\tgoto continue_next_new_nt;\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Adding  DDB to session = 0x%x\\n\", idx));\n\n\t\tnt_ddb_idx = vmalloc(fw_idx_size);\n\t\tif (!nt_ddb_idx)\n\t\t\tbreak;\n\n\t\tnt_ddb_idx->fw_ddb_idx = idx;\n\n\t\tret = qla4xxx_is_session_exists(ha, fw_ddb_entry, NULL);\n\t\tif (ret == QLA_SUCCESS) {\n\t\t\t/* free nt_ddb_idx and do not add to list_nt */\n\t\t\tvfree(nt_ddb_idx);\n\t\t\tgoto continue_next_new_nt;\n\t\t}\n\n\t\tif (target_id < max_ddbs)\n\t\t\tfw_ddb_entry->ddb_link = cpu_to_le16(target_id);\n\n\t\tlist_add_tail(&nt_ddb_idx->list, list_nt);\n\n\t\tret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, RESET_ADAPTER,\n\t\t\t\t\t      idx);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto exit_new_nt_list;\n\ncontinue_next_new_nt:\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n\nexit_new_nt_list:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\n/**\n * qla4xxx_sysfs_ddb_is_non_persistent - check for non-persistence of ddb entry\n * @dev: dev associated with the sysfs entry\n * @data: pointer to flashnode session object\n *\n * Returns:\n *\t1: if flashnode entry is non-persistent\n *\t0: if flashnode entry is persistent\n **/\nstatic int qla4xxx_sysfs_ddb_is_non_persistent(struct device *dev, void *data)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\n\tif (!iscsi_flashnode_bus_match(dev, NULL))\n\t\treturn 0;\n\n\tfnode_sess = iscsi_dev_to_flash_session(dev);\n\n\treturn (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT);\n}\n\n/**\n * qla4xxx_sysfs_ddb_tgt_create - Create sysfs entry for target\n * @ha: pointer to host\n * @fw_ddb_entry: flash ddb data\n * @idx: target index\n * @user: if set then this call is made from userland else from kernel\n *\n * Returns:\n * On sucess: QLA_SUCCESS\n * On failure: QLA_ERROR\n *\n * This create separate sysfs entries for session and connection attributes of\n * the given fw ddb entry.\n * If this is invoked as a result of a userspace call then the entry is marked\n * as nonpersistent using flash_state field.\n **/\nstatic int qla4xxx_sysfs_ddb_tgt_create(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct dev_db_entry *fw_ddb_entry,\n\t\t\t\t\tuint16_t *idx, int user)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess = NULL;\n\tstruct iscsi_bus_flash_conn *fnode_conn = NULL;\n\tint rc = QLA_ERROR;\n\n\tfnode_sess = iscsi_create_flashnode_sess(ha->host, *idx,\n\t\t\t\t\t\t &qla4xxx_iscsi_transport, 0);\n\tif (!fnode_sess) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to create session sysfs entry for flashnode %d of host%lu\\n\",\n\t\t\t   __func__, *idx, ha->host_no);\n\t\tgoto exit_tgt_create;\n\t}\n\n\tfnode_conn = iscsi_create_flashnode_conn(ha->host, fnode_sess,\n\t\t\t\t\t\t &qla4xxx_iscsi_transport, 0);\n\tif (!fnode_conn) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to create conn sysfs entry for flashnode %d of host%lu\\n\",\n\t\t\t   __func__, *idx, ha->host_no);\n\t\tgoto free_sess;\n\t}\n\n\tif (user) {\n\t\tfnode_sess->flash_state = DEV_DB_NON_PERSISTENT;\n\t} else {\n\t\tfnode_sess->flash_state = DEV_DB_PERSISTENT;\n\n\t\tif (*idx == ha->pri_ddb_idx || *idx == ha->sec_ddb_idx)\n\t\t\tfnode_sess->is_boot_target = 1;\n\t\telse\n\t\t\tfnode_sess->is_boot_target = 0;\n\t}\n\n\trc = qla4xxx_copy_from_fwddb_param(fnode_sess, fnode_conn,\n\t\t\t\t\t   fw_ddb_entry);\n\tif (rc)\n\t\tgoto free_sess;\n\n\tql4_printk(KERN_INFO, ha, \"%s: sysfs entry %s created\\n\",\n\t\t   __func__, fnode_sess->dev.kobj.name);\n\n\tql4_printk(KERN_INFO, ha, \"%s: sysfs entry %s created\\n\",\n\t\t   __func__, fnode_conn->dev.kobj.name);\n\n\treturn QLA_SUCCESS;\n\nfree_sess:\n\tiscsi_destroy_flashnode_sess(fnode_sess);\n\nexit_tgt_create:\n\treturn QLA_ERROR;\n}\n\n/**\n * qla4xxx_sysfs_ddb_add - Add new ddb entry in flash\n * @shost: pointer to host\n * @buf: type of ddb entry (ipv4/ipv6)\n * @len: length of buf\n *\n * This creates new ddb entry in the flash by finding first free index and\n * storing default ddb there. And then create sysfs entry for the new ddb entry.\n **/\nstatic int qla4xxx_sysfs_ddb_add(struct Scsi_Host *shost, const char *buf,\n\t\t\t\t int len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tstruct device *dev;\n\tuint16_t idx = 0;\n\tuint16_t max_ddbs = 0;\n\tuint32_t options = 0;\n\tuint32_t rval = QLA_ERROR;\n\n\tif (strncasecmp(PORTAL_TYPE_IPV4, buf, 4) &&\n\t    strncasecmp(PORTAL_TYPE_IPV6, buf, 4)) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: Invalid portal type\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_add;\n\t}\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_PRST_DEV_DB_ENTRIES :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_add;\n\t}\n\n\tdev = iscsi_find_flashnode_sess(ha->host, NULL,\n\t\t\t\t\tqla4xxx_sysfs_ddb_is_non_persistent);\n\tif (dev) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: A non-persistent entry %s found\\n\",\n\t\t\t   __func__, dev->kobj.name);\n\t\tput_device(dev);\n\t\tgoto exit_ddb_add;\n\t}\n\n\t/* Index 0 and 1 are reserved for boot target entries */\n\tfor (idx = 2; idx < max_ddbs; idx++) {\n\t\tif (qla4xxx_flashdb_by_index(ha, fw_ddb_entry,\n\t\t\t\t\t     fw_ddb_entry_dma, idx))\n\t\t\tbreak;\n\t}\n\n\tif (idx == max_ddbs)\n\t\tgoto exit_ddb_add;\n\n\tif (!strncasecmp(\"ipv6\", buf, 4))\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\trval = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (rval == QLA_ERROR)\n\t\tgoto exit_ddb_add;\n\n\trval = qla4xxx_sysfs_ddb_tgt_create(ha, fw_ddb_entry, &idx, 1);\n\nexit_ddb_add:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\tif (rval == QLA_SUCCESS)\n\t\treturn idx;\n\telse\n\t\treturn -EIO;\n}\n\n/**\n * qla4xxx_sysfs_ddb_apply - write the target ddb contents to Flash\n * @fnode_sess: pointer to session attrs of flash ddb entry\n * @fnode_conn: pointer to connection attrs of flash ddb entry\n *\n * This writes the contents of target ddb buffer to Flash with a valid cookie\n * value in order to make the ddb entry persistent.\n **/\nstatic int  qla4xxx_sysfs_ddb_apply(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t    struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tuint32_t dev_db_start_offset = FLASH_OFFSET_DB_INFO;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t options = 0;\n\tint rval = 0;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\trval = -ENOMEM;\n\t\tgoto exit_ddb_apply;\n\t}\n\n\tif (!strncasecmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\trval = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (rval == QLA_ERROR)\n\t\tgoto exit_ddb_apply;\n\n\tdev_db_start_offset += (fnode_sess->target_id *\n\t\t\t\tsizeof(*fw_ddb_entry));\n\n\tqla4xxx_copy_to_fwddb_param(fnode_sess, fnode_conn, fw_ddb_entry);\n\tfw_ddb_entry->cookie = DDB_VALID_COOKIE;\n\n\trval = qla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\n\t\t\t\t sizeof(*fw_ddb_entry), FLASH_OPT_RMW_COMMIT);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tfnode_sess->flash_state = DEV_DB_PERSISTENT;\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: flash node %u of host %lu written to flash\\n\",\n\t\t\t   __func__, fnode_sess->target_id, ha->host_no);\n\t} else {\n\t\trval = -EIO;\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Error while writing flash node %u of host %lu to flash\\n\",\n\t\t\t   __func__, fnode_sess->target_id, ha->host_no);\n\t}\n\nexit_ddb_apply:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn rval;\n}\n\nstatic ssize_t qla4xxx_sysfs_ddb_conn_open(struct scsi_qla_host *ha,\n\t\t\t\t\t   struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t\t   uint16_t idx)\n{\n\tstruct dev_db_entry *ddb_entry = NULL;\n\tdma_addr_t ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t mbx_sts = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint16_t tmo = 0;\n\tint ret = 0;\n\n\tddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*ddb_entry),\n\t\t\t\t       &ddb_entry_dma, GFP_KERNEL);\n\tif (!ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\treturn QLA_ERROR;\n\t}\n\n\tmemcpy(ddb_entry, fw_ddb_entry, sizeof(*ddb_entry));\n\n\tret = qla4xxx_set_ddb_entry(ha, idx, ddb_entry_dma, &mbx_sts);\n\tif (ret != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to set ddb entry for index %d\\n\",\n\t\t\t\t  __func__, idx));\n\t\tgoto exit_ddb_conn_open;\n\t}\n\n\tqla4xxx_conn_open(ha, idx);\n\n\t/* To ensure that sendtargets is done, wait for at least 12 secs */\n\ttmo = ((ha->def_timeout > LOGIN_TOV) &&\n\t       (ha->def_timeout < LOGIN_TOV * 10) ?\n\t       ha->def_timeout : LOGIN_TOV);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Default time to wait for login to ddb %d\\n\", tmo));\n\n\twtime = jiffies + (HZ * tmo);\n\tdo {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, NULL, 0, NULL,\n\t\t\t\t\t      NULL, &state, &conn_err, NULL,\n\t\t\t\t\t      NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED)\n\t\t\tbreak;\n\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t} while (time_after(wtime, jiffies));\n\nexit_ddb_conn_open:\n\tif (ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*ddb_entry),\n\t\t\t\t  ddb_entry, ddb_entry_dma);\n\treturn ret;\n}\n\nstatic int qla4xxx_ddb_login_st(struct scsi_qla_host *ha,\n\t\t\t\tstruct dev_db_entry *fw_ddb_entry,\n\t\t\t\tuint16_t target_id)\n{\n\tstruct qla_ddb_index *ddb_idx, *ddb_idx_tmp;\n\tstruct list_head list_nt;\n\tuint16_t ddb_index;\n\tint ret = 0;\n\n\tif (test_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags)) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s: A discovery already in progress!\\n\", __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\tINIT_LIST_HEAD(&list_nt);\n\n\tset_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags);\n\n\tret = qla4xxx_get_ddb_index(ha, &ddb_index);\n\tif (ret == QLA_ERROR)\n\t\tgoto exit_login_st_clr_bit;\n\n\tret = qla4xxx_sysfs_ddb_conn_open(ha, fw_ddb_entry, ddb_index);\n\tif (ret == QLA_ERROR)\n\t\tgoto exit_login_st;\n\n\tqla4xxx_build_new_nt_list(ha, &list_nt, target_id);\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, &list_nt, list) {\n\t\tlist_del_init(&ddb_idx->list);\n\t\tqla4xxx_clear_ddb_entry(ha, ddb_idx->fw_ddb_idx);\n\t\tvfree(ddb_idx);\n\t}\n\nexit_login_st:\n\tif (qla4xxx_clear_ddb_entry(ha, ddb_index) == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to clear DDB index = 0x%x\\n\", ddb_index);\n\t}\n\n\tclear_bit(ddb_index, ha->ddb_idx_map);\n\nexit_login_st_clr_bit:\n\tclear_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags);\n\treturn ret;\n}\n\nstatic int qla4xxx_ddb_login_nt(struct scsi_qla_host *ha,\n\t\t\t\tstruct dev_db_entry *fw_ddb_entry,\n\t\t\t\tuint16_t idx)\n{\n\tint ret = QLA_ERROR;\n\n\tret = qla4xxx_is_session_exists(ha, fw_ddb_entry, NULL);\n\tif (ret != QLA_SUCCESS)\n\t\tret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, RESET_ADAPTER,\n\t\t\t\t\t      idx);\n\telse\n\t\tret = -EPERM;\n\n\treturn ret;\n}\n\n/**\n * qla4xxx_sysfs_ddb_login - Login to the specified target\n * @fnode_sess: pointer to session attrs of flash ddb entry\n * @fnode_conn: pointer to connection attrs of flash ddb entry\n *\n * This logs in to the specified target\n **/\nstatic int qla4xxx_sysfs_ddb_login(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t   struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t options = 0;\n\tint ret = 0;\n\n\tif (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Target info is not persistent\\n\", __func__);\n\t\tret = -EIO;\n\t\tgoto exit_ddb_login;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_login;\n\t}\n\n\tif (!strncasecmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\tret = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (ret == QLA_ERROR)\n\t\tgoto exit_ddb_login;\n\n\tqla4xxx_copy_to_fwddb_param(fnode_sess, fnode_conn, fw_ddb_entry);\n\tfw_ddb_entry->cookie = DDB_VALID_COOKIE;\n\n\tif (strlen((char *)fw_ddb_entry->iscsi_name) == 0)\n\t\tret = qla4xxx_ddb_login_st(ha, fw_ddb_entry,\n\t\t\t\t\t   fnode_sess->target_id);\n\telse\n\t\tret = qla4xxx_ddb_login_nt(ha, fw_ddb_entry,\n\t\t\t\t\t   fnode_sess->target_id);\n\n\tif (ret > 0)\n\t\tret = -EIO;\n\nexit_ddb_login:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\n/**\n * qla4xxx_sysfs_ddb_logout_sid - Logout session for the specified target\n * @cls_sess: pointer to session to be logged out\n *\n * This performs session log out from the specified target\n **/\nstatic int qla4xxx_sysfs_ddb_logout_sid(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry = NULL;\n\tstruct scsi_qla_host *ha;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long flags;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint options;\n\tint ret = 0;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tif (ddb_entry->ddb_type != FLASH_DDB) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Not a flash node session\\n\",\n\t\t\t   __func__);\n\t\tret = -ENXIO;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (test_bit(DF_BOOT_TGT, &ddb_entry->flags)) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Logout from boot target entry is not permitted.\\n\",\n\t\t\t   __func__);\n\t\tret = -EPERM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (test_and_set_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags))\n\t\tgoto ddb_logout_init;\n\n\tret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t      fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t      NULL, NULL, &ddb_state, NULL,\n\t\t\t\t      NULL, NULL);\n\tif (ret == QLA_ERROR)\n\t\tgoto ddb_logout_init;\n\n\tif (ddb_state == DDB_DS_SESSION_ACTIVE)\n\t\tgoto ddb_logout_init;\n\n\t/* wait until next relogin is triggered using DF_RELOGIN and\n\t * clear DF_RELOGIN to avoid invocation of further relogin\n\t */\n\twtime = jiffies + (HZ * RELOGIN_TOV);\n\tdo {\n\t\tif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags))\n\t\t\tgoto ddb_logout_init;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\nddb_logout_init:\n\tatomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\n\tatomic_set(&ddb_entry->relogin_timer, 0);\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tqla4xxx_session_logout_ddb(ha, ddb_entry, options);\n\n\tmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t      fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t      NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t      NULL, NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto ddb_logout_clr_sess;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\tgoto ddb_logout_clr_sess;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\nddb_logout_clr_sess:\n\tqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\n\t/*\n\t * we have decremented the reference count of the driver\n\t * when we setup the session to have the driver unload\n\t * to be seamless without actually destroying the\n\t * session\n\t **/\n\ttry_module_get(qla4xxx_iscsi_transport.owner);\n\tiscsi_destroy_endpoint(ddb_entry->conn->ep);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqla4xxx_free_ddb(ha, ddb_entry);\n\tclear_bit(ddb_entry->fw_ddb_index, ha->ddb_idx_map);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tiscsi_session_teardown(ddb_entry->sess);\n\n\tclear_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags);\n\tret = QLA_SUCCESS;\n\nexit_ddb_logout:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\n/**\n * qla4xxx_sysfs_ddb_logout - Logout from the specified target\n * @fnode_sess: pointer to session attrs of flash ddb entry\n * @fnode_conn: pointer to connection attrs of flash ddb entry\n *\n * This performs log out from the specified target\n **/\nstatic int qla4xxx_sysfs_ddb_logout(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t    struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct ql4_tuple_ddb *flash_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tstruct ddb_entry *ddb_entry = NULL;\n\tdma_addr_t fw_ddb_dma;\n\tuint32_t next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint16_t conn_id = 0;\n\tint idx, index;\n\tint status, ret = 0;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s:Out of memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tflash_tddb = vzalloc(sizeof(*flash_tddb));\n\tif (!flash_tddb) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s:Memory Allocation failed.\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s:Memory Allocation failed.\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (!fnode_sess->targetname) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s:Cannot logout from SendTarget entry\\n\",\n\t\t\t   __func__);\n\t\tret = -EPERM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (fnode_sess->is_boot_target) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Logout from boot target entry is not permitted.\\n\",\n\t\t\t   __func__);\n\t\tret = -EPERM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tstrlcpy(flash_tddb->iscsi_name, fnode_sess->targetname,\n\t\tISCSI_NAME_SIZE);\n\n\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\tsprintf(flash_tddb->ip_addr, \"%pI6\", fnode_conn->ipaddress);\n\telse\n\t\tsprintf(flash_tddb->ip_addr, \"%pI4\", fnode_conn->ipaddress);\n\n\tflash_tddb->tpgt = fnode_sess->tpgt;\n\tflash_tddb->port = fnode_conn->port;\n\n\tCOPY_ISID(flash_tddb->isid, fnode_sess->isid);\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tif (ddb_entry->ddb_type != FLASH_DDB)\n\t\t\tcontinue;\n\n\t\tindex = ddb_entry->sess->target_id;\n\t\tstatus = qla4xxx_get_fwddb_entry(ha, index, fw_ddb_entry,\n\t\t\t\t\t\t fw_ddb_dma, NULL, &next_idx,\n\t\t\t\t\t\t &state, &conn_err, NULL,\n\t\t\t\t\t\t &conn_id);\n\t\tif (status == QLA_ERROR) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tqla4xxx_convert_param_ddb(fw_ddb_entry, tmp_tddb, NULL);\n\n\t\tstatus = qla4xxx_compare_tuple_ddb(ha, flash_tddb, tmp_tddb,\n\t\t\t\t\t\t   true);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\tret = qla4xxx_sysfs_ddb_logout_sid(ddb_entry->sess);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx == MAX_DDB_ENTRIES)\n\t\tret = -ESRCH;\n\nexit_ddb_logout:\n\tif (flash_tddb)\n\t\tvfree(flash_tddb);\n\tif (tmp_tddb)\n\t\tvfree(tmp_tddb);\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n\n\treturn ret;\n}\n\nstatic int\nqla4xxx_sysfs_ddb_get_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    int param, char *buf)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_bus_flash_conn *fnode_conn;\n\tstruct ql4_chap_table chap_tbl;\n\tstruct device *dev;\n\tint parent_type;\n\tint rc = 0;\n\n\tdev = iscsi_find_flashnode_conn(fnode_sess);\n\tif (!dev)\n\t\treturn -EIO;\n\n\tfnode_conn = iscsi_dev_to_flash_conn(dev);\n\n\tswitch (param) {\n\tcase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->is_fw_assigned_ipv6);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PORTAL_TYPE:\n\t\trc = sprintf(buf, \"%s\\n\", fnode_sess->portal_type);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->auto_snd_tgt_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_SESS:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_sess);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ENTRY_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->entry_state);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_HDR_DGST_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->hdrdgst_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DATA_DGST_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IMM_DATA_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->imm_data_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_INITIAL_R2T_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->initial_r2t_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DATASEQ_INORDER:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->dataseq_inorder_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PDU_INORDER:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->pdu_inorder_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_CHAP_AUTH_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->chap_auth_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_SNACK_REQ_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->snack_req_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_logout_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_BIDI_CHAP_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->bidi_chap_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_auth_optional);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ERL:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->erl);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_timestamp_stat);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_nagle_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_wsf_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_timer_scale);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_timestamp_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->fragment_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->max_recv_dlength);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->max_xmit_dlength);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_FIRST_BURST:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->first_burst);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DEF_TIME2WAIT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->time2wait);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->time2retain);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_R2T:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->max_r2t);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_KEEPALIVE_TMO:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->keepalive_timeout);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ISID:\n\t\trc = sprintf(buf, \"%pm\\n\", fnode_sess->isid);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TSID:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->tsid);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PORT:\n\t\trc = sprintf(buf, \"%d\\n\", fnode_conn->port);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_BURST:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->max_burst);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\n\t\trc = sprintf(buf, \"%u\\n\",\n\t\t\t     fnode_sess->default_taskmgmt_timeout);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPADDR:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%pI6\\n\", fnode_conn->ipaddress);\n\t\telse\n\t\t\trc = sprintf(buf, \"%pI4\\n\", fnode_conn->ipaddress);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ALIAS:\n\t\tif (fnode_sess->targetalias)\n\t\t\trc = sprintf(buf, \"%s\\n\", fnode_sess->targetalias);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_REDIRECT_IPADDR:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t     fnode_conn->redirect_ipaddr);\n\t\telse\n\t\t\trc = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t     fnode_conn->redirect_ipaddr);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->max_segment_size);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_LOCAL_PORT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->local_port);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPV4_TOS:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->ipv4_tos);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPV6_TC:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%u\\n\",\n\t\t\t\t     fnode_conn->ipv6_traffic_class);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->ipv6_flow_label);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t     fnode_conn->link_local_ipv6_addr);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_parent_idx);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE:\n\t\tif (fnode_sess->discovery_parent_type == DDB_ISNS)\n\t\t\tparent_type = ISCSI_DISC_PARENT_ISNS;\n\t\telse if (fnode_sess->discovery_parent_type == DDB_NO_LINK)\n\t\t\tparent_type = ISCSI_DISC_PARENT_UNKNOWN;\n\t\telse if (fnode_sess->discovery_parent_type < MAX_DDB_ENTRIES)\n\t\t\tparent_type = ISCSI_DISC_PARENT_SENDTGT;\n\t\telse\n\t\t\tparent_type = ISCSI_DISC_PARENT_UNKNOWN;\n\n\t\trc = sprintf(buf, \"%s\\n\",\n\t\t\t     iscsi_get_discovery_parent_name(parent_type));\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_NAME:\n\t\tif (fnode_sess->targetname)\n\t\t\trc = sprintf(buf, \"%s\\n\", fnode_sess->targetname);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TPGT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->tpgt);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_XMIT_WSF:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_xmit_wsf);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_RECV_WSF:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_recv_wsf);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_CHAP_OUT_IDX:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->chap_out_idx);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_USERNAME:\n\t\tif (fnode_sess->chap_auth_en) {\n\t\t\tqla4xxx_get_uni_chap_at_index(ha,\n\t\t\t\t\t\t      chap_tbl.name,\n\t\t\t\t\t\t      chap_tbl.secret,\n\t\t\t\t\t\t      fnode_sess->chap_out_idx);\n\t\t\trc = sprintf(buf, \"%s\\n\", chap_tbl.name);\n\t\t} else {\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\t}\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PASSWORD:\n\t\tif (fnode_sess->chap_auth_en) {\n\t\t\tqla4xxx_get_uni_chap_at_index(ha,\n\t\t\t\t\t\t      chap_tbl.name,\n\t\t\t\t\t\t      chap_tbl.secret,\n\t\t\t\t\t\t      fnode_sess->chap_out_idx);\n\t\t\trc = sprintf(buf, \"%s\\n\", chap_tbl.secret);\n\t\t} else {\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\t}\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_STATSN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->statsn);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_EXP_STATSN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->exp_statsn);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IS_BOOT_TGT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->is_boot_target);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tput_device(dev);\n\treturn rc;\n}\n\n/**\n * qla4xxx_sysfs_ddb_set_param - Set parameter for firmware DDB entry\n * @fnode_sess: pointer to session attrs of flash ddb entry\n * @fnode_conn: pointer to connection attrs of flash ddb entry\n * @data: Parameters and their values to update\n * @len: len of data\n *\n * This sets the parameter of flash ddb entry and writes them to flash\n **/\nstatic int\nqla4xxx_sysfs_ddb_set_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    struct iscsi_bus_flash_conn *fnode_conn,\n\t\t\t    void *data, int len)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_flashnode_param_info *fnode_param;\n\tstruct ql4_chap_table chap_tbl;\n\tstruct nlattr *attr;\n\tuint16_t chap_out_idx = INVALID_ENTRY;\n\tint rc = QLA_ERROR;\n\tuint32_t rem = len;\n\n\tmemset((void *)&chap_tbl, 0, sizeof(chap_tbl));\n\tnla_for_each_attr(attr, data, len, rem) {\n\t\tfnode_param = nla_data(attr);\n\n\t\tswitch (fnode_param->param) {\n\t\tcase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\n\t\t\tfnode_conn->is_fw_assigned_ipv6 = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_PORTAL_TYPE:\n\t\t\tmemcpy(fnode_sess->portal_type, fnode_param->value,\n\t\t\t       strlen(fnode_sess->portal_type));\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\n\t\t\tfnode_sess->auto_snd_tgt_disable =\n\t\t\t\t\t\t\tfnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_SESS:\n\t\t\tfnode_sess->discovery_sess = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ENTRY_EN:\n\t\t\tfnode_sess->entry_state = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_HDR_DGST_EN:\n\t\t\tfnode_conn->hdrdgst_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DATA_DGST_EN:\n\t\t\tfnode_conn->datadgst_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IMM_DATA_EN:\n\t\t\tfnode_sess->imm_data_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_INITIAL_R2T_EN:\n\t\t\tfnode_sess->initial_r2t_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DATASEQ_INORDER:\n\t\t\tfnode_sess->dataseq_inorder_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_PDU_INORDER:\n\t\t\tfnode_sess->pdu_inorder_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_CHAP_AUTH_EN:\n\t\t\tfnode_sess->chap_auth_en = fnode_param->value[0];\n\t\t\t/* Invalidate chap index if chap auth is disabled */\n\t\t\tif (!fnode_sess->chap_auth_en)\n\t\t\t\tfnode_sess->chap_out_idx = INVALID_ENTRY;\n\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_SNACK_REQ_EN:\n\t\t\tfnode_conn->snack_req_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\n\t\t\tfnode_sess->discovery_logout_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_BIDI_CHAP_EN:\n\t\t\tfnode_sess->bidi_chap_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\n\t\t\tfnode_sess->discovery_auth_optional =\n\t\t\t\t\t\t\tfnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ERL:\n\t\t\tfnode_sess->erl = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\n\t\t\tfnode_conn->tcp_timestamp_stat = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\n\t\t\tfnode_conn->tcp_nagle_disable = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\n\t\t\tfnode_conn->tcp_wsf_disable = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\n\t\t\tfnode_conn->tcp_timer_scale = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\n\t\t\tfnode_conn->tcp_timestamp_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\n\t\t\tfnode_conn->fragment_disable = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\n\t\t\tfnode_conn->max_recv_dlength =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\n\t\t\tfnode_conn->max_xmit_dlength =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_FIRST_BURST:\n\t\t\tfnode_sess->first_burst =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2WAIT:\n\t\t\tfnode_sess->time2wait = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\n\t\t\tfnode_sess->time2retain =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_R2T:\n\t\t\tfnode_sess->max_r2t =\n\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_KEEPALIVE_TMO:\n\t\t\tfnode_conn->keepalive_timeout =\n\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ISID:\n\t\t\tmemcpy(fnode_sess->isid, fnode_param->value,\n\t\t\t       sizeof(fnode_sess->isid));\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TSID:\n\t\t\tfnode_sess->tsid = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_PORT:\n\t\t\tfnode_conn->port = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_BURST:\n\t\t\tfnode_sess->max_burst = *(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\n\t\t\tfnode_sess->default_taskmgmt_timeout =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPADDR:\n\t\t\tmemcpy(fnode_conn->ipaddress, fnode_param->value,\n\t\t\t       IPv6_ADDR_LEN);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ALIAS:\n\t\t\trc = iscsi_switch_str_param(&fnode_sess->targetalias,\n\t\t\t\t\t\t    (char *)fnode_param->value);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_REDIRECT_IPADDR:\n\t\t\tmemcpy(fnode_conn->redirect_ipaddr, fnode_param->value,\n\t\t\t       IPv6_ADDR_LEN);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\n\t\t\tfnode_conn->max_segment_size =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_LOCAL_PORT:\n\t\t\tfnode_conn->local_port =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPV4_TOS:\n\t\t\tfnode_conn->ipv4_tos = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPV6_TC:\n\t\t\tfnode_conn->ipv6_traffic_class = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\n\t\t\tfnode_conn->ipv6_flow_label = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_NAME:\n\t\t\trc = iscsi_switch_str_param(&fnode_sess->targetname,\n\t\t\t\t\t\t    (char *)fnode_param->value);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TPGT:\n\t\t\tfnode_sess->tpgt = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\n\t\t\tmemcpy(fnode_conn->link_local_ipv6_addr,\n\t\t\t       fnode_param->value, IPv6_ADDR_LEN);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\n\t\t\tfnode_sess->discovery_parent_idx =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_XMIT_WSF:\n\t\t\tfnode_conn->tcp_xmit_wsf =\n\t\t\t\t\t\t*(uint8_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_RECV_WSF:\n\t\t\tfnode_conn->tcp_recv_wsf =\n\t\t\t\t\t\t*(uint8_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_STATSN:\n\t\t\tfnode_conn->statsn = *(uint32_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_EXP_STATSN:\n\t\t\tfnode_conn->exp_statsn =\n\t\t\t\t\t\t*(uint32_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_CHAP_OUT_IDX:\n\t\t\tchap_out_idx = *(uint16_t *)fnode_param->value;\n\t\t\tif (!qla4xxx_get_uni_chap_at_index(ha,\n\t\t\t\t\t\t\t   chap_tbl.name,\n\t\t\t\t\t\t\t   chap_tbl.secret,\n\t\t\t\t\t\t\t   chap_out_idx)) {\n\t\t\t\tfnode_sess->chap_out_idx = chap_out_idx;\n\t\t\t\t/* Enable chap auth if chap index is valid */\n\t\t\t\tfnode_sess->chap_auth_en = QL4_PARAM_ENABLE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"%s: No such sysfs attribute\\n\", __func__);\n\t\t\trc = -ENOSYS;\n\t\t\tgoto exit_set_param;\n\t\t}\n\t}\n\n\trc = qla4xxx_sysfs_ddb_apply(fnode_sess, fnode_conn);\n\nexit_set_param:\n\treturn rc;\n}\n\n/**\n * qla4xxx_sysfs_ddb_delete - Delete firmware DDB entry\n * @fnode_sess: pointer to session attrs of flash ddb entry\n *\n * This invalidates the flash ddb entry at the given index\n **/\nstatic int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tuint32_t dev_db_start_offset;\n\tuint32_t dev_db_end_offset;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint16_t *ddb_cookie = NULL;\n\tsize_t ddb_size = 0;\n\tvoid *pddb = NULL;\n\tint target_id;\n\tint rc = 0;\n\n\tif (fnode_sess->is_boot_target) {\n\t\trc = -EPERM;\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Deletion of boot target entry is not permitted.\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_del;\n\t}\n\n\tif (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT)\n\t\tgoto sysfs_ddb_del;\n\n\tif (is_qla40XX(ha)) {\n\t\tdev_db_start_offset = FLASH_OFFSET_DB_INFO;\n\t\tdev_db_end_offset = FLASH_OFFSET_DB_END;\n\t\tdev_db_start_offset += (fnode_sess->target_id *\n\t\t\t\t       sizeof(*fw_ddb_entry));\n\t\tddb_size = sizeof(*fw_ddb_entry);\n\t} else {\n\t\tdev_db_start_offset = FLASH_RAW_ACCESS_ADDR +\n\t\t\t\t      (ha->hw.flt_region_ddb << 2);\n\t\t/* flt_ddb_size is DDB table size for both ports\n\t\t * so divide it by 2 to calculate the offset for second port\n\t\t */\n\t\tif (ha->port_num == 1)\n\t\t\tdev_db_start_offset += (ha->hw.flt_ddb_size / 2);\n\n\t\tdev_db_end_offset = dev_db_start_offset +\n\t\t\t\t    (ha->hw.flt_ddb_size / 2);\n\n\t\tdev_db_start_offset += (fnode_sess->target_id *\n\t\t\t\t       sizeof(*fw_ddb_entry));\n\t\tdev_db_start_offset += offsetof(struct dev_db_entry, cookie);\n\n\t\tddb_size = sizeof(*ddb_cookie);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: start offset=%u, end offset=%u\\n\",\n\t\t\t  __func__, dev_db_start_offset, dev_db_end_offset));\n\n\tif (dev_db_start_offset > dev_db_end_offset) {\n\t\trc = -EIO;\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s:Invalid DDB index %u\\n\",\n\t\t\t\t  __func__, fnode_sess->target_id));\n\t\tgoto exit_ddb_del;\n\t}\n\n\tpddb = dma_alloc_coherent(&ha->pdev->dev, ddb_size,\n\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!pddb) {\n\t\trc = -ENOMEM;\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_del;\n\t}\n\n\tif (is_qla40XX(ha)) {\n\t\tfw_ddb_entry = pddb;\n\t\tmemset(fw_ddb_entry, 0, ddb_size);\n\t\tddb_cookie = &fw_ddb_entry->cookie;\n\t} else {\n\t\tddb_cookie = pddb;\n\t}\n\n\t/* invalidate the cookie */\n\t*ddb_cookie = 0xFFEE;\n\tqla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\n\t\t\t  ddb_size, FLASH_OPT_RMW_COMMIT);\n\nsysfs_ddb_del:\n\ttarget_id = fnode_sess->target_id;\n\tiscsi_destroy_flashnode_sess(fnode_sess);\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"%s: session and conn entries for flashnode %u of host %lu deleted\\n\",\n\t\t   __func__, target_id, ha->host_no);\nexit_ddb_del:\n\tif (pddb)\n\t\tdma_free_coherent(&ha->pdev->dev, ddb_size, pddb,\n\t\t\t\t  fw_ddb_entry_dma);\n\treturn rc;\n}\n\n/**\n * qla4xxx_sysfs_ddb_export - Create sysfs entries for firmware DDBs\n * @ha: pointer to adapter structure\n *\n * Export the firmware DDB for all send targets and normal targets to sysfs.\n **/\nint qla4xxx_sysfs_ddb_export(struct scsi_qla_host *ha)\n{\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint16_t max_ddbs;\n\tuint16_t idx = 0;\n\tint ret = QLA_SUCCESS;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t  sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\treturn -ENOMEM;\n\t}\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_PRST_DEV_DB_ENTRIES :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tif (qla4xxx_flashdb_by_index(ha, fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t     idx))\n\t\t\tcontinue;\n\n\t\tret = qla4xxx_sysfs_ddb_tgt_create(ha, fw_ddb_entry, &idx, 0);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,\n\t\t\t  fw_ddb_entry_dma);\n\n\treturn ret;\n}\n\nstatic void qla4xxx_sysfs_ddb_remove(struct scsi_qla_host *ha)\n{\n\tiscsi_destroy_all_flashnode(ha->host);\n}\n\n/**\n * qla4xxx_build_ddb_list - Build ddb list and setup sessions\n * @ha: pointer to adapter structure\n * @is_reset: Is this init path or reset path\n *\n * Create a list of sendtargets (st) from firmware DDBs, issue send targets\n * using connection open, then create the list of normal targets (nt)\n * from firmware DDBs. Based on the list of nt setup session and connection\n * objects.\n **/\nvoid qla4xxx_build_ddb_list(struct scsi_qla_host *ha, int is_reset)\n{\n\tuint16_t tmo = 0;\n\tstruct list_head list_st, list_nt;\n\tstruct qla_ddb_index  *st_ddb_idx, *st_ddb_idx_tmp;\n\tunsigned long wtime;\n\n\tif (!test_bit(AF_LINK_UP, &ha->flags)) {\n\t\tset_bit(AF_BUILD_DDB_LIST, &ha->flags);\n\t\tha->is_reset = is_reset;\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&list_st);\n\tINIT_LIST_HEAD(&list_nt);\n\n\tqla4xxx_build_st_list(ha, &list_st);\n\n\t/* Before issuing conn open mbox, ensure all IPs states are configured\n\t * Note, conn open fails if IPs are not configured\n\t */\n\tqla4xxx_wait_for_ip_configuration(ha);\n\n\t/* Go thru the STs and fire the sendtargets by issuing conn open mbx */\n\tlist_for_each_entry_safe(st_ddb_idx, st_ddb_idx_tmp, &list_st, list) {\n\t\tqla4xxx_conn_open(ha, st_ddb_idx->fw_ddb_idx);\n\t}\n\n\t/* Wait to ensure all sendtargets are done for min 12 sec wait */\n\ttmo = ((ha->def_timeout > LOGIN_TOV) &&\n\t       (ha->def_timeout < LOGIN_TOV * 10) ?\n\t       ha->def_timeout : LOGIN_TOV);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Default time to wait for build ddb %d\\n\", tmo));\n\n\twtime = jiffies + (HZ * tmo);\n\tdo {\n\t\tif (list_empty(&list_st))\n\t\t\tbreak;\n\n\t\tqla4xxx_remove_failed_ddb(ha, &list_st);\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t} while (time_after(wtime, jiffies));\n\n\n\tqla4xxx_build_nt_list(ha, &list_nt, &list_st, is_reset);\n\n\tqla4xxx_free_ddb_list(&list_st);\n\tqla4xxx_free_ddb_list(&list_nt);\n\n\tqla4xxx_free_ddb_index(ha);\n}\n\n/**\n * qla4xxx_wait_login_resp_boot_tgt -  Wait for iSCSI boot target login\n * response.\n * @ha: pointer to adapter structure\n *\n * When the boot entry is normal iSCSI target then DF_BOOT_TGT flag will be\n * set in DDB and we will wait for login response of boot targets during\n * probe.\n **/\nstatic void qla4xxx_wait_login_resp_boot_tgt(struct scsi_qla_host *ha)\n{\n\tstruct ddb_entry *ddb_entry;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint max_ddbs, idx, ret;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto exit_login_resp;\n\t}\n\n\twtime = jiffies + (HZ * BOOT_LOGIN_RESP_TOV);\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tif (test_bit(DF_BOOT_TGT, &ddb_entry->flags)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: DDB index [%d]\\n\", __func__,\n\t\t\t\t\t  ddb_entry->fw_ddb_index));\n\t\t\tdo {\n\t\t\t\tret = qla4xxx_get_fwddb_entry(ha,\n\t\t\t\t\t\tddb_entry->fw_ddb_index,\n\t\t\t\t\t\tfw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t\tNULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t\tNULL, NULL);\n\t\t\t\tif (ret == QLA_ERROR)\n\t\t\t\t\tgoto exit_login_resp;\n\n\t\t\t\tif ((ddb_state == DDB_DS_SESSION_ACTIVE) ||\n\t\t\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\t\t\tbreak;\n\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n\n\t\t\t} while ((time_after(wtime, jiffies)));\n\n\t\t\tif (!time_after(wtime, jiffies)) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"%s: Login response wait timer expired\\n\",\n\t\t\t\t\t\t  __func__));\n\t\t\t\t goto exit_login_resp;\n\t\t\t}\n\t\t}\n\t}\n\nexit_login_resp:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\n/**\n * qla4xxx_probe_adapter - callback function to probe HBA\n * @pdev: pointer to pci_dev structure\n * @ent: pointer to pci_device entry\n *\n * This routine will probe for Qlogic 4xxx iSCSI host adapters.\n * It returns zero if successful. It also initializes all data necessary for\n * the driver.\n **/\nstatic int qla4xxx_probe_adapter(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent)\n{\n\tint ret = -ENODEV, status;\n\tstruct Scsi_Host *host;\n\tstruct scsi_qla_host *ha;\n\tuint8_t init_retry_count = 0;\n\tchar buf[34];\n\tstruct qla4_8xxx_legacy_intr_set *nx_legacy_intr;\n\tuint32_t dev_state;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -1;\n\n\thost = iscsi_host_alloc(&qla4xxx_driver_template, sizeof(*ha), 0);\n\tif (host == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t       \"qla4xxx: Couldn't allocate host from scsi layer!\\n\");\n\t\tgoto probe_disable_device;\n\t}\n\n\t/* Clear our data area */\n\tha = to_qla_host(host);\n\tmemset(ha, 0, sizeof(*ha));\n\n\t/* Save the information from PCI BIOS.\t*/\n\tha->pdev = pdev;\n\tha->host = host;\n\tha->host_no = host->host_no;\n\tha->func_num = PCI_FUNC(ha->pdev->devfn);\n\n\tpci_enable_pcie_error_reporting(pdev);\n\n\t/* Setup Runtime configurable options */\n\tif (is_qla8022(ha)) {\n\t\tha->isp_ops = &qla4_82xx_isp_ops;\n\t\tha->reg_tbl = (uint32_t *) qla4_82xx_reg_tbl;\n\t\tha->qdr_sn_window = -1;\n\t\tha->ddr_mn_window = -1;\n\t\tha->curr_window = 255;\n\t\tnx_legacy_intr = &legacy_intr[ha->func_num];\n\t\tha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;\n\t\tha->nx_legacy_intr.tgt_status_reg =\n\t\t\tnx_legacy_intr->tgt_status_reg;\n\t\tha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;\n\t\tha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tha->isp_ops = &qla4_83xx_isp_ops;\n\t\tha->reg_tbl = (uint32_t *)qla4_83xx_reg_tbl;\n\t} else {\n\t\tha->isp_ops = &qla4xxx_isp_ops;\n\t}\n\n\tif (is_qla80XX(ha)) {\n\t\trwlock_init(&ha->hw_lock);\n\t\tha->pf_bit = ha->func_num << 16;\n\t\t/* Set EEH reset type to fundamental if required by hba */\n\t\tpdev->needs_freset = 1;\n\t}\n\n\t/* Configure PCI I/O space. */\n\tret = ha->isp_ops->iospace_config(ha);\n\tif (ret)\n\t\tgoto probe_failed_ioconfig;\n\n\tql4_printk(KERN_INFO, ha, \"Found an ISP%04x, irq %d, iobase 0x%p\\n\",\n\t\t   pdev->device, pdev->irq, ha->reg);\n\n\tqla4xxx_config_dma_addressing(ha);\n\n\t/* Initialize lists and spinlocks. */\n\tINIT_LIST_HEAD(&ha->free_srb_q);\n\n\tmutex_init(&ha->mbox_sem);\n\tmutex_init(&ha->chap_sem);\n\tinit_completion(&ha->mbx_intr_comp);\n\tinit_completion(&ha->disable_acb_comp);\n\tinit_completion(&ha->idc_comp);\n\tinit_completion(&ha->link_up_comp);\n\n\tspin_lock_init(&ha->hardware_lock);\n\tspin_lock_init(&ha->work_lock);\n\n\t/* Initialize work list */\n\tINIT_LIST_HEAD(&ha->work_list);\n\n\t/* Allocate dma buffers */\n\tif (qla4xxx_mem_alloc(ha)) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"[ERROR] Failed to allocate memory for adapter\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto probe_failed;\n\t}\n\n\thost->cmd_per_lun = 3;\n\thost->max_channel = 0;\n\thost->max_lun = MAX_LUNS - 1;\n\thost->max_id = MAX_TARGETS;\n\thost->max_cmd_len = IOCB_MAX_CDB_LEN;\n\thost->can_queue = MAX_SRBS ;\n\thost->transportt = qla4xxx_scsi_transport;\n\n\tpci_set_drvdata(pdev, ha);\n\n\tret = scsi_add_host(host, &pdev->dev);\n\tif (ret)\n\t\tgoto probe_failed;\n\n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_get_flash_info(ha);\n\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tqla4_83xx_read_reset_template(ha);\n\t\t/*\n\t\t * NOTE: If ql4dontresethba==1, set IDC_CTRL DONTRESET_BIT0.\n\t\t * If DONRESET_BIT0 is set, drivers should not set dev_state\n\t\t * to NEED_RESET. But if NEED_RESET is set, drivers should\n\t\t * should honor the reset.\n\t\t */\n\t\tif (ql4xdontresethba == 1)\n\t\t\tqla4_83xx_set_idc_dontreset(ha);\n\t}\n\n\t/*\n\t * Initialize the Host adapter request/response queues and\n\t * firmware\n\t * NOTE: interrupts enabled upon successful completion\n\t */\n\tstatus = qla4xxx_initialize_adapter(ha, INIT_ADAPTER);\n\n\t/* Dont retry adapter initialization if IRQ allocation failed */\n\tif (is_qla80XX(ha) && (status == QLA_ERROR))\n\t\tgoto skip_retry_init;\n\n\twhile ((!test_bit(AF_ONLINE, &ha->flags)) &&\n\t    init_retry_count++ < MAX_INIT_RETRIES) {\n\n\t\tif (is_qla80XX(ha)) {\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tdev_state = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DEV_STATE);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tif (dev_state == QLA8XXX_DEV_FAILED) {\n\t\t\t\tql4_printk(KERN_WARNING, ha, \"%s: don't retry \"\n\t\t\t\t    \"initialize adapter. H/W is in failed state\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDEBUG2(printk(\"scsi: %s: retrying adapter initialization \"\n\t\t\t      \"(%d)\\n\", __func__, init_retry_count));\n\n\t\tif (ha->isp_ops->reset_chip(ha) == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tstatus = qla4xxx_initialize_adapter(ha, INIT_ADAPTER);\n\t\tif (is_qla80XX(ha) && (status == QLA_ERROR)) {\n\t\t\tif (qla4_8xxx_check_init_adapter_retry(ha) == QLA_ERROR)\n\t\t\t\tgoto skip_retry_init;\n\t\t}\n\t}\n\nskip_retry_init:\n\tif (!test_bit(AF_ONLINE, &ha->flags)) {\n\t\tql4_printk(KERN_WARNING, ha, \"Failed to initialize adapter\\n\");\n\n\t\tif ((is_qla8022(ha) && ql4xdontresethba) ||\n\t\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t     qla4_83xx_idc_dontreset(ha))) {\n\t\t\t/* Put the device in failed state. */\n\t\t\tDEBUG2(printk(KERN_ERR \"HW STATE: FAILED\\n\"));\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t}\n\t\tret = -ENODEV;\n\t\tgoto remove_host;\n\t}\n\n\t/* Startup the kernel thread for this host adapter. */\n\tDEBUG2(printk(\"scsi: %s: Starting kernel thread for \"\n\t\t      \"qla4xxx_dpc\\n\", __func__));\n\tsprintf(buf, \"qla4xxx_%lu_dpc\", ha->host_no);\n\tha->dpc_thread = create_singlethread_workqueue(buf);\n\tif (!ha->dpc_thread) {\n\t\tql4_printk(KERN_WARNING, ha, \"Unable to start DPC thread!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_host;\n\t}\n\tINIT_WORK(&ha->dpc_work, qla4xxx_do_dpc);\n\n\tha->task_wq = alloc_workqueue(\"qla4xxx_%lu_task\", WQ_MEM_RECLAIM, 1,\n\t\t\t\t      ha->host_no);\n\tif (!ha->task_wq) {\n\t\tql4_printk(KERN_WARNING, ha, \"Unable to start task thread!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_host;\n\t}\n\n\t/*\n\t * For ISP-8XXX, request_irqs is called in qla4_8xxx_load_risc\n\t * (which is called indirectly by qla4xxx_initialize_adapter),\n\t * so that irqs will be registered after crbinit but before\n\t * mbx_intr_enable.\n\t */\n\tif (is_qla40XX(ha)) {\n\t\tret = qla4xxx_request_irqs(ha);\n\t\tif (ret) {\n\t\t\tql4_printk(KERN_WARNING, ha, \"Failed to reserve \"\n\t\t\t    \"interrupt %d already in use.\\n\", pdev->irq);\n\t\t\tgoto remove_host;\n\t\t}\n\t}\n\n\tpci_save_state(ha->pdev);\n\tha->isp_ops->enable_intrs(ha);\n\n\t/* Start timer thread. */\n\tqla4xxx_start_timer(ha, 1);\n\n\tset_bit(AF_INIT_DONE, &ha->flags);\n\n\tqla4_8xxx_alloc_sysfs_attr(ha);\n\n\tprintk(KERN_INFO\n\t       \" QLogic iSCSI HBA Driver version: %s\\n\"\n\t       \"  QLogic ISP%04x @ %s, host#=%ld, fw=%02d.%02d.%02d.%02d\\n\",\n\t       qla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev),\n\t       ha->host_no, ha->fw_info.fw_major, ha->fw_info.fw_minor,\n\t       ha->fw_info.fw_patch, ha->fw_info.fw_build);\n\n\t/* Set the driver version */\n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_set_param(ha, SET_DRVR_VERSION);\n\n\tif (qla4xxx_setup_boot_info(ha))\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: No iSCSI boot target configured\\n\", __func__);\n\n\tset_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags);\n\t/* Perform the build ddb list and login to each */\n\tqla4xxx_build_ddb_list(ha, INIT_ADAPTER);\n\tiscsi_host_for_each_session(ha->host, qla4xxx_login_flash_ddb);\n\tqla4xxx_wait_login_resp_boot_tgt(ha);\n\n\tqla4xxx_create_chap_list(ha);\n\n\tqla4xxx_create_ifaces(ha);\n\treturn 0;\n\nremove_host:\n\tscsi_remove_host(ha->host);\n\nprobe_failed:\n\tqla4xxx_free_adapter(ha);\n\nprobe_failed_ioconfig:\n\tpci_disable_pcie_error_reporting(pdev);\n\tscsi_host_put(ha->host);\n\nprobe_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn ret;\n}\n\n/**\n * qla4xxx_prevent_other_port_reinit - prevent other port from re-initialize\n * @ha: pointer to adapter structure\n *\n * Mark the other ISP-4xxx port to indicate that the driver is being removed,\n * so that the other port will not re-initialize while in the process of\n * removing the ha due to driver unload or hba hotplug.\n **/\nstatic void qla4xxx_prevent_other_port_reinit(struct scsi_qla_host *ha)\n{\n\tstruct scsi_qla_host *other_ha = NULL;\n\tstruct pci_dev *other_pdev = NULL;\n\tint fn = ISP4XXX_PCI_FN_2;\n\n\t/*iscsi function numbers for ISP4xxx is 1 and 3*/\n\tif (PCI_FUNC(ha->pdev->devfn) & BIT_1)\n\t\tfn = ISP4XXX_PCI_FN_1;\n\n\tother_pdev =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),\n\t\tha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\n\t\tfn));\n\n\t/* Get other_ha if other_pdev is valid and state is enable*/\n\tif (other_pdev) {\n\t\tif (atomic_read(&other_pdev->enable_cnt)) {\n\t\t\tother_ha = pci_get_drvdata(other_pdev);\n\t\t\tif (other_ha) {\n\t\t\t\tset_bit(AF_HA_REMOVAL, &other_ha->flags);\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: \"\n\t\t\t\t    \"Prevent %s reinit\\n\", __func__,\n\t\t\t\t    dev_name(&other_ha->pdev->dev)));\n\t\t\t}\n\t\t}\n\t\tpci_dev_put(other_pdev);\n\t}\n}\n\nstatic void qla4xxx_destroy_ddb(struct scsi_qla_host *ha,\n\t\tstruct ddb_entry *ddb_entry)\n{\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint options;\n\tint status;\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Logout failed\\n\", __func__);\n\t\tgoto clear_ddb;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto clear_ddb;\n\t}\n\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tstatus = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t\t fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t\t NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t\t NULL, NULL);\n\t\tif (status == QLA_ERROR)\n\t\t\tgoto free_ddb;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\tgoto free_ddb;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\nfree_ddb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\nclear_ddb:\n\tqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\n}\n\nstatic void qla4xxx_destroy_fw_ddb_session(struct scsi_qla_host *ha)\n{\n\tstruct ddb_entry *ddb_entry;\n\tint idx;\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif ((ddb_entry != NULL) &&\n\t\t    (ddb_entry->ddb_type == FLASH_DDB)) {\n\n\t\t\tqla4xxx_destroy_ddb(ha, ddb_entry);\n\t\t\t/*\n\t\t\t * we have decremented the reference count of the driver\n\t\t\t * when we setup the session to have the driver unload\n\t\t\t * to be seamless without actually destroying the\n\t\t\t * session\n\t\t\t **/\n\t\t\ttry_module_get(qla4xxx_iscsi_transport.owner);\n\t\t\tiscsi_destroy_endpoint(ddb_entry->conn->ep);\n\t\t\tqla4xxx_free_ddb(ha, ddb_entry);\n\t\t\tiscsi_session_teardown(ddb_entry->sess);\n\t\t}\n\t}\n}\n/**\n * qla4xxx_remove_adapter - callback function to remove adapter.\n * @pdev: PCI device pointer\n **/\nstatic void qla4xxx_remove_adapter(struct pci_dev *pdev)\n{\n\tstruct scsi_qla_host *ha;\n\n\t/*\n\t * If the PCI device is disabled then it means probe_adapter had\n\t * failed and resources already cleaned up on probe_adapter exit.\n\t */\n\tif (!pci_is_enabled(pdev))\n\t\treturn;\n\n\tha = pci_get_drvdata(pdev);\n\n\tif (is_qla40XX(ha))\n\t\tqla4xxx_prevent_other_port_reinit(ha);\n\n\t/* destroy iface from sysfs */\n\tqla4xxx_destroy_ifaces(ha);\n\n\tif ((!ql4xdisablesysfsboot) && ha->boot_kset)\n\t\tiscsi_boot_destroy_kset(ha->boot_kset);\n\n\tqla4xxx_destroy_fw_ddb_session(ha);\n\tqla4_8xxx_free_sysfs_attr(ha);\n\n\tqla4xxx_sysfs_ddb_remove(ha);\n\tscsi_remove_host(ha->host);\n\n\tqla4xxx_free_adapter(ha);\n\n\tscsi_host_put(ha->host);\n\n\tpci_disable_pcie_error_reporting(pdev);\n\tpci_disable_device(pdev);\n}\n\n/**\n * qla4xxx_config_dma_addressing() - Configure OS DMA addressing method.\n * @ha: HA context\n */\nstatic void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha)\n{\n\t/* Update our PCI device dma_mask for full 64 bit mask */\n\tif (dma_set_mask_and_coherent(&ha->pdev->dev, DMA_BIT_MASK(64))) {\n\t\tdev_dbg(&ha->pdev->dev,\n\t\t\t  \"Failed to set 64 bit PCI consistent mask; \"\n\t\t\t   \"using 32 bit.\\n\");\n\t\tdma_set_mask_and_coherent(&ha->pdev->dev, DMA_BIT_MASK(32));\n\t}\n}\n\nstatic int qla4xxx_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb;\n\tint queue_depth = QL4_DEF_QDEPTH;\n\n\tcls_sess = starget_to_session(sdev->sdev_target);\n\tsess = cls_sess->dd_data;\n\tddb = sess->dd_data;\n\n\tsdev->hostdata = ddb;\n\n\tif (ql4xmaxqdepth != 0 && ql4xmaxqdepth <= 0xffffU)\n\t\tqueue_depth = ql4xmaxqdepth;\n\n\tscsi_change_queue_depth(sdev, queue_depth);\n\treturn 0;\n}\n\n/**\n * qla4xxx_del_from_active_array - returns an active srb\n * @ha: Pointer to host adapter structure.\n * @index: index into the active_array\n *\n * This routine removes and returns the srb at the specified index\n **/\nstruct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,\n    uint32_t index)\n{\n\tstruct srb *srb = NULL;\n\tstruct scsi_cmnd *cmd = NULL;\n\n\tcmd = scsi_host_find_tag(ha->host, index);\n\tif (!cmd)\n\t\treturn srb;\n\n\tsrb = (struct srb *)CMD_SP(cmd);\n\tif (!srb)\n\t\treturn srb;\n\n\t/* update counters */\n\tif (srb->flags & SRB_DMA_VALID) {\n\t\tha->iocb_cnt -= srb->iocb_cnt;\n\t\tif (srb->cmd)\n\t\t\tsrb->cmd->host_scribble =\n\t\t\t\t(unsigned char *)(unsigned long) MAX_SRBS;\n\t}\n\treturn srb;\n}\n\n/**\n * qla4xxx_eh_wait_on_command - waits for command to be returned by firmware\n * @ha: Pointer to host adapter structure.\n * @cmd: Scsi Command to wait on.\n *\n * This routine waits for the command to be returned by the Firmware\n * for some max time.\n **/\nstatic int qla4xxx_eh_wait_on_command(struct scsi_qla_host *ha,\n\t\t\t\t      struct scsi_cmnd *cmd)\n{\n\tint done = 0;\n\tstruct srb *rp;\n\tuint32_t max_wait_time = EH_WAIT_CMD_TOV;\n\tint ret = SUCCESS;\n\n\t/* Dont wait on command if PCI error is being handled\n\t * by PCI AER driver\n\t */\n\tif (unlikely(pci_channel_offline(ha->pdev)) ||\n\t    (test_bit(AF_EEH_BUSY, &ha->flags))) {\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: Return from %s\\n\",\n\t\t    ha->host_no, __func__);\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\t/* Checking to see if its returned to OS */\n\t\trp = (struct srb *) CMD_SP(cmd);\n\t\tif (rp == NULL) {\n\t\t\tdone++;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(2000);\n\t} while (max_wait_time--);\n\n\treturn done;\n}\n\n/**\n * qla4xxx_wait_for_hba_online - waits for HBA to come online\n * @ha: Pointer to host adapter structure\n **/\nstatic int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha)\n{\n\tunsigned long wait_online;\n\n\twait_online = jiffies + (HBA_ONLINE_TOV * HZ);\n\twhile (time_before(jiffies, wait_online)) {\n\n\t\tif (adapter_up(ha))\n\t\t\treturn QLA_SUCCESS;\n\n\t\tmsleep(2000);\n\t}\n\n\treturn QLA_ERROR;\n}\n\n/**\n * qla4xxx_eh_wait_for_commands - wait for active cmds to finish.\n * @ha: pointer to HBA\n * @stgt: pointer to SCSI target\n * @sdev: pointer to SCSI device\n *\n * This function waits for all outstanding commands to a lun to complete. It\n * returns 0 if all pending commands are returned and 1 otherwise.\n **/\nstatic int qla4xxx_eh_wait_for_commands(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct scsi_target *stgt,\n\t\t\t\t\tstruct scsi_device *sdev)\n{\n\tint cnt;\n\tint status = 0;\n\tstruct scsi_cmnd *cmd;\n\n\t/*\n\t * Waiting for all commands for the designated target or dev\n\t * in the active array\n\t */\n\tfor (cnt = 0; cnt < ha->host->can_queue; cnt++) {\n\t\tcmd = scsi_host_find_tag(ha->host, cnt);\n\t\tif (cmd && stgt == scsi_target(cmd->device) &&\n\t\t    (!sdev || sdev == cmd->device)) {\n\t\t\tif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\n\t\t\t\tstatus++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn status;\n}\n\n/**\n * qla4xxx_eh_abort - callback for abort task.\n * @cmd: Pointer to Linux's SCSI command structure\n *\n * This routine is called by the Linux OS to abort the specified\n * command.\n **/\nstatic int qla4xxx_eh_abort(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\n\tunsigned int id = cmd->device->id;\n\tuint64_t lun = cmd->device->lun;\n\tunsigned long flags;\n\tstruct srb *srb = NULL;\n\tint ret = SUCCESS;\n\tint wait = 0;\n\tint rval;\n\n\tql4_printk(KERN_INFO, ha, \"scsi%ld:%d:%llu: Abort command issued cmd=%p, cdb=0x%x\\n\",\n\t\t   ha->host_no, id, lun, cmd, cmd->cmnd[0]);\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tsrb = (struct srb *) CMD_SP(cmd);\n\tif (!srb) {\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld:%d:%llu: Specified command has already completed.\\n\",\n\t\t\t   ha->host_no, id, lun);\n\t\treturn SUCCESS;\n\t}\n\tkref_get(&srb->srb_ref);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (qla4xxx_abort_task(ha, srb) != QLA_SUCCESS) {\n\t\tDEBUG3(printk(\"scsi%ld:%d:%llu: Abort_task mbx failed.\\n\",\n\t\t    ha->host_no, id, lun));\n\t\tret = FAILED;\n\t} else {\n\t\tDEBUG3(printk(\"scsi%ld:%d:%llu: Abort_task mbx success.\\n\",\n\t\t    ha->host_no, id, lun));\n\t\twait = 1;\n\t}\n\n\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n\n\t/* Wait for command to complete */\n\tif (wait) {\n\t\tif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\n\t\t\tDEBUG2(printk(\"scsi%ld:%d:%llu: Abort handler timed out\\n\",\n\t\t\t    ha->host_no, id, lun));\n\t\t\tret = FAILED;\n\t\t}\n\t}\n\n\tql4_printk(KERN_INFO, ha,\n\t    \"scsi%ld:%d:%llu: Abort command - %s\\n\",\n\t    ha->host_no, id, lun, (ret == SUCCESS) ? \"succeeded\" : \"failed\");\n\n\treturn ret;\n}\n\n/**\n * qla4xxx_eh_device_reset - callback for target reset.\n * @cmd: Pointer to Linux's SCSI command structure\n *\n * This routine is called by the Linux OS to reset all luns on the\n * specified target.\n **/\nstatic int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\n\tstruct ddb_entry *ddb_entry = cmd->device->hostdata;\n\tint ret = FAILED, stat;\n\tint rval;\n\n\tif (!ddb_entry)\n\t\treturn ret;\n\n\tret = iscsi_block_scsi_eh(cmd);\n\tif (ret)\n\t\treturn ret;\n\tret = FAILED;\n\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"scsi%ld:%d:%d:%llu: DEVICE RESET ISSUED.\\n\", ha->host_no,\n\t\t   cmd->device->channel, cmd->device->id, cmd->device->lun);\n\n\tDEBUG2(printk(KERN_INFO\n\t\t      \"scsi%ld: DEVICE_RESET cmd=%p jiffies = 0x%lx, to=%x,\"\n\t\t      \"dpc_flags=%lx, status=%x allowed=%d\\n\", ha->host_no,\n\t\t      cmd, jiffies, cmd->request->timeout / HZ,\n\t\t      ha->dpc_flags, cmd->result, cmd->allowed));\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\t/* FIXME: wait for hba to go online */\n\tstat = qla4xxx_reset_lun(ha, ddb_entry, cmd->device->lun);\n\tif (stat != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"DEVICE RESET FAILED. %d\\n\", stat);\n\t\tgoto eh_dev_reset_done;\n\t}\n\n\tif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\n\t\t\t\t\t cmd->device)) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"DEVICE RESET FAILED - waiting for \"\n\t\t\t   \"commands.\\n\");\n\t\tgoto eh_dev_reset_done;\n\t}\n\n\t/* Send marker. */\n\tif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\n\t\tMM_LUN_RESET) != QLA_SUCCESS)\n\t\tgoto eh_dev_reset_done;\n\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"scsi(%ld:%d:%d:%llu): DEVICE RESET SUCCEEDED.\\n\",\n\t\t   ha->host_no, cmd->device->channel, cmd->device->id,\n\t\t   cmd->device->lun);\n\n\tret = SUCCESS;\n\neh_dev_reset_done:\n\n\treturn ret;\n}\n\n/**\n * qla4xxx_eh_target_reset - callback for target reset.\n * @cmd: Pointer to Linux's SCSI command structure\n *\n * This routine is called by the Linux OS to reset the target.\n **/\nstatic int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\n\tstruct ddb_entry *ddb_entry = cmd->device->hostdata;\n\tint stat, ret;\n\tint rval;\n\n\tif (!ddb_entry)\n\t\treturn FAILED;\n\n\tret = iscsi_block_scsi_eh(cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t       \"WARM TARGET RESET ISSUED.\\n\");\n\n\tDEBUG2(printk(KERN_INFO\n\t\t      \"scsi%ld: TARGET_DEVICE_RESET cmd=%p jiffies = 0x%lx, \"\n\t\t      \"to=%x,dpc_flags=%lx, status=%x allowed=%d\\n\",\n\t\t      ha->host_no, cmd, jiffies, cmd->request->timeout / HZ,\n\t\t      ha->dpc_flags, cmd->result, cmd->allowed));\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tstat = qla4xxx_reset_target(ha, ddb_entry);\n\tif (stat != QLA_SUCCESS) {\n\t\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t\t       \"WARM TARGET RESET FAILED.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\n\t\t\t\t\t NULL)) {\n\t\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t\t       \"WARM TARGET DEVICE RESET FAILED - \"\n\t\t\t       \"waiting for commands.\\n\");\n\t\treturn FAILED;\n\t}\n\n\t/* Send marker. */\n\tif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\n\t\tMM_TGT_WARM_RESET) != QLA_SUCCESS) {\n\t\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t\t       \"WARM TARGET DEVICE RESET FAILED - \"\n\t\t\t       \"marker iocb failed.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t       \"WARM TARGET RESET SUCCEEDED.\\n\");\n\treturn SUCCESS;\n}\n\n/**\n * qla4xxx_is_eh_active - check if error handler is running\n * @shost: Pointer to SCSI Host struct\n *\n * This routine finds that if reset host is called in EH\n * scenario or from some application like sg_reset\n **/\nstatic int qla4xxx_is_eh_active(struct Scsi_Host *shost)\n{\n\tif (shost->shost_state == SHOST_RECOVERY)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * qla4xxx_eh_host_reset - kernel callback\n * @cmd: Pointer to Linux's SCSI command structure\n *\n * This routine is invoked by the Linux kernel to perform fatal error\n * recovery on the specified adapter.\n **/\nstatic int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)\n{\n\tint return_status = FAILED;\n\tstruct scsi_qla_host *ha;\n\tint rval;\n\n\tha = to_qla_host(cmd->device->host);\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tif ((is_qla8032(ha) || is_qla8042(ha)) && ql4xdontresethba)\n\t\tqla4_83xx_set_idc_dontreset(ha);\n\n\t/*\n\t * For ISP8324 and ISP8042, if IDC_CTRL DONTRESET_BIT0 is set by other\n\t * protocol drivers, we should not set device_state to NEED_RESET\n\t */\n\tif (ql4xdontresethba ||\n\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t     qla4_83xx_idc_dontreset(ha))) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Don't Reset HBA\\n\",\n\t\t     ha->host_no, __func__));\n\n\t\t/* Clear outstanding srb in queues */\n\t\tif (qla4xxx_is_eh_active(cmd->device->host))\n\t\t\tqla4xxx_abort_active_cmds(ha, DID_ABORT << 16);\n\n\t\treturn FAILED;\n\t}\n\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"scsi(%ld:%d:%d:%llu): HOST RESET ISSUED.\\n\", ha->host_no,\n\t\t   cmd->device->channel, cmd->device->id, cmd->device->lun);\n\n\tif (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld:%d: %s: Unable to reset host.  Adapter \"\n\t\t\t      \"DEAD.\\n\", ha->host_no, cmd->device->channel,\n\t\t\t      __func__));\n\n\t\treturn FAILED;\n\t}\n\n\tif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\tif (is_qla80XX(ha))\n\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\telse\n\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t}\n\n\tif (qla4xxx_recover_adapter(ha) == QLA_SUCCESS)\n\t\treturn_status = SUCCESS;\n\n\tql4_printk(KERN_INFO, ha, \"HOST RESET %s.\\n\",\n\t\t   return_status == FAILED ? \"FAILED\" : \"SUCCEEDED\");\n\n\treturn return_status;\n}\n\nstatic int qla4xxx_context_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct addr_ctrl_blk_def *acb = NULL;\n\tuint32_t acb_len = sizeof(struct addr_ctrl_blk_def);\n\tint rval = QLA_SUCCESS;\n\tdma_addr_t acb_dma;\n\n\tacb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t sizeof(struct addr_ctrl_blk_def),\n\t\t\t\t &acb_dma, GFP_KERNEL);\n\tif (!acb) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Unable to alloc acb\\n\",\n\t\t\t   __func__);\n\t\trval = -ENOMEM;\n\t\tgoto exit_port_reset;\n\t}\n\n\tmemset(acb, 0, acb_len);\n\n\trval = qla4xxx_get_acb(ha, acb_dma, PRIMARI_ACB, acb_len);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = -EIO;\n\t\tgoto exit_free_acb;\n\t}\n\n\trval = qla4xxx_disable_acb(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = -EIO;\n\t\tgoto exit_free_acb;\n\t}\n\n\twait_for_completion_timeout(&ha->disable_acb_comp,\n\t\t\t\t    DISABLE_ACB_TOV * HZ);\n\n\trval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], acb_dma);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = -EIO;\n\t\tgoto exit_free_acb;\n\t}\n\nexit_free_acb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk_def),\n\t\t\t  acb, acb_dma);\nexit_port_reset:\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s %s\\n\", __func__,\n\t\t\t  rval == QLA_SUCCESS ? \"SUCCEEDED\" : \"FAILED\"));\n\treturn rval;\n}\n\nstatic int qla4xxx_host_reset(struct Scsi_Host *shost, int reset_type)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint rval = QLA_SUCCESS;\n\tuint32_t idc_ctrl;\n\n\tif (ql4xdontresethba) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Don't Reset HBA\\n\",\n\t\t\t\t  __func__));\n\t\trval = -EPERM;\n\t\tgoto exit_host_reset;\n\t}\n\n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\tgoto recover_adapter;\n\n\tswitch (reset_type) {\n\tcase SCSI_ADAPTER_RESET:\n\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\tbreak;\n\tcase SCSI_FIRMWARE_RESET:\n\t\tif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\t\tif (is_qla80XX(ha))\n\t\t\t\t/* set firmware context reset */\n\t\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t&ha->dpc_flags);\n\t\t\telse {\n\t\t\t\trval = qla4xxx_context_reset(ha);\n\t\t\t\tgoto exit_host_reset;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\nrecover_adapter:\n\t/* For ISP8324 and ISP8042 set graceful reset bit in IDC_DRV_CTRL if\n\t * reset is issued by application */\n\tif ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t    test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\tidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\n\t\tqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL,\n\t\t\t\t (idc_ctrl | GRACEFUL_RESET_BIT1));\n\t}\n\n\trval = qla4xxx_recover_adapter(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: recover adapter fail\\n\",\n\t\t\t\t  __func__));\n\t\trval = -EIO;\n\t}\n\nexit_host_reset:\n\treturn rval;\n}\n\n/* PCI AER driver recovers from all correctable errors w/o\n * driver intervention. For uncorrectable errors PCI AER\n * driver calls the following device driver's callbacks\n *\n * - Fatal Errors - link_reset\n * - Non-Fatal Errors - driver's error_detected() which\n * returns CAN_RECOVER, NEED_RESET or DISCONNECT.\n *\n * PCI AER driver calls\n * CAN_RECOVER - driver's mmio_enabled(), mmio_enabled()\n *               returns RECOVERED or NEED_RESET if fw_hung\n * NEED_RESET - driver's slot_reset()\n * DISCONNECT - device is dead & cannot recover\n * RECOVERED - driver's resume()\n */\nstatic pci_ers_result_t\nqla4xxx_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: error detected:state %x\\n\",\n\t    ha->host_no, __func__, state);\n\n\tif (!is_aer_supported(ha))\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tclear_bit(AF_EEH_BUSY, &ha->flags);\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_frozen:\n\t\tset_bit(AF_EEH_BUSY, &ha->flags);\n\t\tqla4xxx_mailbox_premature_completion(ha);\n\t\tqla4xxx_free_irqs(ha);\n\t\tpci_disable_device(pdev);\n\t\t/* Return back all IOs */\n\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\tcase pci_channel_io_perm_failure:\n\t\tset_bit(AF_EEH_BUSY, &ha->flags);\n\t\tset_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags);\n\t\tqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * qla4xxx_pci_mmio_enabled() - gets called if\n * qla4xxx_pci_error_detected() returns PCI_ERS_RESULT_CAN_RECOVER\n * and read/write to the device still works.\n * @pdev: PCI device pointer\n **/\nstatic pci_ers_result_t\nqla4xxx_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\n\tif (!is_aer_supported(ha))\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic uint32_t qla4_8xxx_error_recovery(struct scsi_qla_host *ha)\n{\n\tuint32_t rval = QLA_ERROR;\n\tint fn;\n\tstruct pci_dev *other_pdev = NULL;\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: In %s\\n\", ha->host_no, __func__);\n\n\tset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\n\tif (test_bit(AF_ONLINE, &ha->flags)) {\n\t\tclear_bit(AF_ONLINE, &ha->flags);\n\t\tclear_bit(AF_LINK_UP, &ha->flags);\n\t\tiscsi_host_for_each_session(ha->host, qla4xxx_fail_session);\n\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t}\n\n\tfn = PCI_FUNC(ha->pdev->devfn);\n\tif (is_qla8022(ha)) {\n\t\twhile (fn > 0) {\n\t\t\tfn--;\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Finding PCI device at func %x\\n\",\n\t\t\t\t   ha->host_no, __func__, fn);\n\t\t\t/* Get the pci device given the domain, bus,\n\t\t\t * slot/function number */\n\t\t\tother_pdev = pci_get_domain_bus_and_slot(\n\t\t\t\t\t   pci_domain_nr(ha->pdev->bus),\n\t\t\t\t\t   ha->pdev->bus->number,\n\t\t\t\t\t   PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\n\t\t\t\t\t   fn));\n\n\t\t\tif (!other_pdev)\n\t\t\t\tcontinue;\n\n\t\t\tif (atomic_read(&other_pdev->enable_cnt)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Found PCI func in enabled state%x\\n\",\n\t\t\t\t\t   ha->host_no, __func__, fn);\n\t\t\t\tpci_dev_put(other_pdev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_dev_put(other_pdev);\n\t\t}\n\t} else {\n\t\t/* this case is meant for ISP83xx/ISP84xx only */\n\t\tif (qla4_83xx_can_perform_reset(ha)) {\n\t\t\t/* reset fn as iSCSI is going to perform the reset */\n\t\t\tfn = 0;\n\t\t}\n\t}\n\n\t/* The first function on the card, the reset owner will\n\t * start & initialize the firmware. The other functions\n\t * on the card will reset the firmware context\n\t */\n\tif (!fn) {\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: devfn being reset \"\n\t\t    \"0x%x is the owner\\n\", ha->host_no, __func__,\n\t\t    ha->pdev->devfn);\n\n\t\tha->isp_ops->idc_lock(ha);\n\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t    QLA8XXX_DEV_COLD);\n\t\tha->isp_ops->idc_unlock(ha);\n\n\t\trval = qla4_8xxx_update_idc_reg(ha);\n\t\tif (rval == QLA_ERROR) {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: HW State: FAILED\\n\",\n\t\t\t\t   ha->host_no, __func__);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tgoto exit_error_recovery;\n\t\t}\n\n\t\tclear_bit(AF_FW_RECOVERY, &ha->flags);\n\t\trval = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\n\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: HW State: \"\n\t\t\t    \"FAILED\\n\", ha->host_no, __func__);\n\t\t\tqla4xxx_free_irqs(ha);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_clear_drv_active(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: HW State: \"\n\t\t\t    \"READY\\n\", ha->host_no, __func__);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_READY);\n\t\t\t/* Clear driver state register */\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, 0);\n\t\t\tqla4_8xxx_set_drv_active(ha);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tha->isp_ops->enable_intrs(ha);\n\t\t}\n\t} else {\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: devfn 0x%x is not \"\n\t\t    \"the reset owner\\n\", ha->host_no, __func__,\n\t\t    ha->pdev->devfn);\n\t\tif ((qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE) ==\n\t\t     QLA8XXX_DEV_READY)) {\n\t\t\tclear_bit(AF_FW_RECOVERY, &ha->flags);\n\t\t\trval = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\n\t\t\tif (rval == QLA_SUCCESS)\n\t\t\t\tha->isp_ops->enable_intrs(ha);\n\t\t\telse\n\t\t\t\tqla4xxx_free_irqs(ha);\n\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_set_drv_active(ha);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t}\n\t}\nexit_error_recovery:\n\tclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\treturn rval;\n}\n\nstatic pci_ers_result_t\nqla4xxx_pci_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t ret = PCI_ERS_RESULT_DISCONNECT;\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\tint rc;\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: slot_reset\\n\",\n\t    ha->host_no, __func__);\n\n\tif (!is_aer_supported(ha))\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\t/* Restore the saved state of PCIe device -\n\t * BAR registers, PCI Config space, PCIX, MSI,\n\t * IOV states\n\t */\n\tpci_restore_state(pdev);\n\n\t/* pci_restore_state() clears the saved_state flag of the device\n\t * save restored state which resets saved_state flag\n\t */\n\tpci_save_state(pdev);\n\n\t/* Initialize device or resume if in suspended state */\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: Can't re-enable \"\n\t\t    \"device after reset\\n\", ha->host_no, __func__);\n\t\tgoto exit_slot_reset;\n\t}\n\n\tha->isp_ops->disable_intrs(ha);\n\n\tif (is_qla80XX(ha)) {\n\t\tif (qla4_8xxx_error_recovery(ha) == QLA_SUCCESS) {\n\t\t\tret = PCI_ERS_RESULT_RECOVERED;\n\t\t\tgoto exit_slot_reset;\n\t\t} else\n\t\t\tgoto exit_slot_reset;\n\t}\n\nexit_slot_reset:\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: Return=%x\\n\"\n\t    \"device after reset\\n\", ha->host_no, __func__, ret);\n\treturn ret;\n}\n\nstatic void\nqla4xxx_pci_resume(struct pci_dev *pdev)\n{\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\tint ret;\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: pci_resume\\n\",\n\t    ha->host_no, __func__);\n\n\tret = qla4xxx_wait_for_hba_online(ha);\n\tif (ret != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"scsi%ld: %s: the device failed to \"\n\t\t    \"resume I/O from slot/link_reset\\n\", ha->host_no,\n\t\t     __func__);\n\t}\n\n\tclear_bit(AF_EEH_BUSY, &ha->flags);\n}\n\nstatic const struct pci_error_handlers qla4xxx_err_handler = {\n\t.error_detected = qla4xxx_pci_error_detected,\n\t.mmio_enabled = qla4xxx_pci_mmio_enabled,\n\t.slot_reset = qla4xxx_pci_slot_reset,\n\t.resume = qla4xxx_pci_resume,\n};\n\nstatic struct pci_device_id qla4xxx_pci_tbl[] = {\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP4010,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP4022,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP4032,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor         = PCI_VENDOR_ID_QLOGIC,\n\t\t.device         = PCI_DEVICE_ID_QLOGIC_ISP8022,\n\t\t.subvendor      = PCI_ANY_ID,\n\t\t.subdevice      = PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP8324,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP8042,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{0, 0},\n};\nMODULE_DEVICE_TABLE(pci, qla4xxx_pci_tbl);\n\nstatic struct pci_driver qla4xxx_pci_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= qla4xxx_pci_tbl,\n\t.probe\t\t= qla4xxx_probe_adapter,\n\t.remove\t\t= qla4xxx_remove_adapter,\n\t.err_handler = &qla4xxx_err_handler,\n};\n\nstatic int __init qla4xxx_module_init(void)\n{\n\tint ret;\n\n\tif (ql4xqfulltracking)\n\t\tqla4xxx_driver_template.track_queue_depth = 1;\n\n\t/* Allocate cache for SRBs. */\n\tsrb_cachep = kmem_cache_create(\"qla4xxx_srbs\", sizeof(struct srb), 0,\n\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (srb_cachep == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Unable to allocate SRB cache...\"\n\t\t       \"Failing load!\\n\", DRIVER_NAME);\n\t\tret = -ENOMEM;\n\t\tgoto no_srp_cache;\n\t}\n\n\t/* Derive version string. */\n\tstrcpy(qla4xxx_version_str, QLA4XXX_DRIVER_VERSION);\n\tif (ql4xextended_error_logging)\n\t\tstrcat(qla4xxx_version_str, \"-debug\");\n\n\tqla4xxx_scsi_transport =\n\t\tiscsi_register_transport(&qla4xxx_iscsi_transport);\n\tif (!qla4xxx_scsi_transport){\n\t\tret = -ENODEV;\n\t\tgoto release_srb_cache;\n\t}\n\n\tret = pci_register_driver(&qla4xxx_pci_driver);\n\tif (ret)\n\t\tgoto unregister_transport;\n\n\tprintk(KERN_INFO \"QLogic iSCSI HBA Driver\\n\");\n\treturn 0;\n\nunregister_transport:\n\tiscsi_unregister_transport(&qla4xxx_iscsi_transport);\nrelease_srb_cache:\n\tkmem_cache_destroy(srb_cachep);\nno_srp_cache:\n\treturn ret;\n}\n\nstatic void __exit qla4xxx_module_exit(void)\n{\n\tpci_unregister_driver(&qla4xxx_pci_driver);\n\tiscsi_unregister_transport(&qla4xxx_iscsi_transport);\n\tkmem_cache_destroy(srb_cachep);\n}\n\nmodule_init(qla4xxx_module_init);\nmodule_exit(qla4xxx_module_exit);\n\nMODULE_AUTHOR(\"QLogic Corporation\");\nMODULE_DESCRIPTION(\"QLogic iSCSI HBA Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(QLA4XXX_DRIVER_VERSION);\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 6555}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "df98c300788d2db66729a18ccae3ee94", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 6557}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "0fcb1e4765a9b383d2c81264ecbc97e1", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 6400}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "df98c300788d2db66729a18ccae3ee94", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 6402}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "0fcb1e4765a9b383d2c81264ecbc97e1", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 4175}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "431f902c9ab20a86c1013086600b1caf", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 4196}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "aafdf6b1839b0e75ef6cf9a9a4f5bf0e", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 4215}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "ff946f05595ee188be9e54381580e6da", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 7838}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "57e0dde31a99ec17e1bcd9eb8fe61ad5", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 0, "line": 7840}, "message": "WARNING: NULL check before some freeing functions is not needed."}], "macros": [], "notes": [], "path": "/src/drivers/scsi/qla4xxx/ql4_os.c", "reportHash": "0fcb1e4765a9b383d2c81264ecbc97e1", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
