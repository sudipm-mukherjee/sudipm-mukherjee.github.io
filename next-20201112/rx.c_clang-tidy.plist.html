<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/mac80211/rx.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright 2006-2007\tJiri Benc <jbenc@suse.cz>\n * Copyright 2007-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n * Copyright(c) 2015 - 2017 Intel Deutschland GmbH\n * Copyright (C) 2018-2020 Intel Corporation\n */\n\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include <asm/unaligned.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"tkip.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\nstatic inline void ieee80211_rx_stats(struct net_device *dev, u32 len)\n{\n\tstruct pcpu_sw_netstats *tstats = this_cpu_ptr(dev->tstats);\n\n\tu64_stats_update_begin(&tstats->syncp);\n\ttstats->rx_packets++;\n\ttstats->rx_bytes += len;\n\tu64_stats_update_end(&tstats->syncp);\n}\n\n/*\n * monitor mode reception\n *\n * This function cleans up the SKB, i.e. it removes all the stuff\n * only useful for monitoring.\n */\nstatic struct sk_buff *ieee80211_clean_skb(struct sk_buff *skb,\n\t\t\t\t\t   unsigned int present_fcs_len,\n\t\t\t\t\t   unsigned int rtap_space)\n{\n\tstruct ieee80211_hdr *hdr;\n\tunsigned int hdrlen;\n\t__le16 fc;\n\n\tif (present_fcs_len)\n\t\t__pskb_trim(skb, skb->len - present_fcs_len);\n\t__pskb_pull(skb, rtap_space);\n\n\thdr = (void *)skb->data;\n\tfc = hdr->frame_control;\n\n\t/*\n\t * Remove the HT-Control field (if present) on management\n\t * frames after we've sent the frame to monitoring. We\n\t * (currently) don't need it, and don't properly parse\n\t * frames with it present, due to the assumption of a\n\t * fixed management header length.\n\t */\n\tif (likely(!ieee80211_is_mgmt(fc) || !ieee80211_has_order(fc)))\n\t\treturn skb;\n\n\thdrlen = ieee80211_hdrlen(fc);\n\thdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_ORDER);\n\n\tif (!pskb_may_pull(skb, hdrlen)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tmemmove(skb->data + IEEE80211_HT_CTL_LEN, skb->data,\n\t\thdrlen - IEEE80211_HT_CTL_LEN);\n\t__pskb_pull(skb, IEEE80211_HT_CTL_LEN);\n\n\treturn skb;\n}\n\nstatic inline bool should_drop_frame(struct sk_buff *skb, int present_fcs_len,\n\t\t\t\t     unsigned int rtap_space)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\n\thdr = (void *)(skb->data + rtap_space);\n\n\tif (status->flag & (RX_FLAG_FAILED_FCS_CRC |\n\t\t\t    RX_FLAG_FAILED_PLCP_CRC |\n\t\t\t    RX_FLAG_ONLY_MONITOR |\n\t\t\t    RX_FLAG_NO_PSDU))\n\t\treturn true;\n\n\tif (unlikely(skb->len < 16 + present_fcs_len + rtap_space))\n\t\treturn true;\n\n\tif (ieee80211_is_ctl(hdr->frame_control) &&\n\t    !ieee80211_is_pspoll(hdr->frame_control) &&\n\t    !ieee80211_is_back_req(hdr->frame_control))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\nieee80211_rx_radiotap_hdrlen(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t     struct sk_buff *skb)\n{\n\tint len;\n\n\t/* always present fields */\n\tlen = sizeof(struct ieee80211_radiotap_header) + 8;\n\n\t/* allocate extra bitmaps */\n\tif (status->chains)\n\t\tlen += 4 * hweight8(status->chains);\n\t/* vendor presence bitmap */\n\tif (status->flag & RX_FLAG_RADIOTAP_VENDOR_DATA)\n\t\tlen += 4;\n\n\tif (ieee80211_have_rx_timestamp(status)) {\n\t\tlen = ALIGN(len, 8);\n\t\tlen += 8;\n\t}\n\tif (ieee80211_hw_check(&local->hw, SIGNAL_DBM))\n\t\tlen += 1;\n\n\t/* antenna field, if we don't have per-chain info */\n\tif (!status->chains)\n\t\tlen += 1;\n\n\t/* padding for RX_FLAGS if necessary */\n\tlen = ALIGN(len, 2);\n\n\tif (status->encoding == RX_ENC_HT) /* HT info */\n\t\tlen += 3;\n\n\tif (status->flag & RX_FLAG_AMPDU_DETAILS) {\n\t\tlen = ALIGN(len, 4);\n\t\tlen += 8;\n\t}\n\n\tif (status->encoding == RX_ENC_VHT) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 12;\n\t}\n\n\tif (local->hw.radiotap_timestamp.units_pos >= 0) {\n\t\tlen = ALIGN(len, 8);\n\t\tlen += 12;\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 12;\n\t\tBUILD_BUG_ON(sizeof(struct ieee80211_radiotap_he) != 12);\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE_MU) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 12;\n\t\tBUILD_BUG_ON(sizeof(struct ieee80211_radiotap_he_mu) != 12);\n\t}\n\n\tif (status->flag & RX_FLAG_NO_PSDU)\n\t\tlen += 1;\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 4;\n\t\tBUILD_BUG_ON(sizeof(struct ieee80211_radiotap_lsig) != 4);\n\t}\n\n\tif (status->chains) {\n\t\t/* antenna and antenna signal fields */\n\t\tlen += 2 * hweight8(status->chains);\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_VENDOR_DATA) {\n\t\tstruct ieee80211_vendor_radiotap *rtap;\n\t\tint vendor_data_offset = 0;\n\n\t\t/*\n\t\t * The position to look at depends on the existence (or non-\n\t\t * existence) of other elements, so take that into account...\n\t\t */\n\t\tif (status->flag & RX_FLAG_RADIOTAP_HE)\n\t\t\tvendor_data_offset +=\n\t\t\t\tsizeof(struct ieee80211_radiotap_he);\n\t\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU)\n\t\t\tvendor_data_offset +=\n\t\t\t\tsizeof(struct ieee80211_radiotap_he_mu);\n\t\tif (status->flag & RX_FLAG_RADIOTAP_LSIG)\n\t\t\tvendor_data_offset +=\n\t\t\t\tsizeof(struct ieee80211_radiotap_lsig);\n\n\t\trtap = (void *)&skb->data[vendor_data_offset];\n\n\t\t/* alignment for fixed 6-byte vendor data header */\n\t\tlen = ALIGN(len, 2);\n\t\t/* vendor data header */\n\t\tlen += 6;\n\t\tif (WARN_ON(rtap->align == 0))\n\t\t\trtap->align = 1;\n\t\tlen = ALIGN(len, rtap->align);\n\t\tlen += rtap->len + rtap->pad;\n\t}\n\n\treturn len;\n}\n\nstatic void ieee80211_handle_mu_mimo_mon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t int rtap_space)\n{\n\tstruct {\n\t\tstruct ieee80211_hdr_3addr hdr;\n\t\tu8 category;\n\t\tu8 action_code;\n\t} __packed __aligned(2) action;\n\n\tif (!sdata)\n\t\treturn;\n\n\tBUILD_BUG_ON(sizeof(action) != IEEE80211_MIN_ACTION_SIZE + 1);\n\n\tif (skb->len < rtap_space + sizeof(action) +\n\t\t       VHT_MUMIMO_GROUPS_DATA_LEN)\n\t\treturn;\n\n\tif (!is_valid_ether_addr(sdata->u.mntr.mu_follow_addr))\n\t\treturn;\n\n\tskb_copy_bits(skb, rtap_space, &action, sizeof(action));\n\n\tif (!ieee80211_is_action(action.hdr.frame_control))\n\t\treturn;\n\n\tif (action.category != WLAN_CATEGORY_VHT)\n\t\treturn;\n\n\tif (action.action_code != WLAN_VHT_ACTION_GROUPID_MGMT)\n\t\treturn;\n\n\tif (!ether_addr_equal(action.hdr.addr1, sdata->u.mntr.mu_follow_addr))\n\t\treturn;\n\n\tskb = skb_copy(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_queue_tail(&sdata->skb_queue, skb);\n\tieee80211_queue_work(&sdata->local->hw, &sdata->work);\n}\n\n/*\n * ieee80211_add_rx_radiotap_header - add radiotap header\n *\n * add a radiotap header containing all the fields which the hardware provided.\n */\nstatic void\nieee80211_add_rx_radiotap_header(struct ieee80211_local *local,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct ieee80211_rate *rate,\n\t\t\t\t int rtap_len, bool has_fcs)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_radiotap_header *rthdr;\n\tunsigned char *pos;\n\t__le32 *it_present;\n\tu32 it_present_val;\n\tu16 rx_flags = 0;\n\tu16 channel_flags = 0;\n\tint mpdulen, chain;\n\tunsigned long chains = status->chains;\n\tstruct ieee80211_vendor_radiotap rtap = {};\n\tstruct ieee80211_radiotap_he he = {};\n\tstruct ieee80211_radiotap_he_mu he_mu = {};\n\tstruct ieee80211_radiotap_lsig lsig = {};\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE) {\n\t\the = *(struct ieee80211_radiotap_he *)skb->data;\n\t\tskb_pull(skb, sizeof(he));\n\t\tWARN_ON_ONCE(status->encoding != RX_ENC_HE);\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU) {\n\t\the_mu = *(struct ieee80211_radiotap_he_mu *)skb->data;\n\t\tskb_pull(skb, sizeof(he_mu));\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG) {\n\t\tlsig = *(struct ieee80211_radiotap_lsig *)skb->data;\n\t\tskb_pull(skb, sizeof(lsig));\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_VENDOR_DATA) {\n\t\trtap = *(struct ieee80211_vendor_radiotap *)skb->data;\n\t\t/* rtap.len and rtap.pad are undone immediately */\n\t\tskb_pull(skb, sizeof(rtap) + rtap.len + rtap.pad);\n\t}\n\n\tmpdulen = skb->len;\n\tif (!(has_fcs && ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)))\n\t\tmpdulen += FCS_LEN;\n\n\trthdr = skb_push(skb, rtap_len);\n\tmemset(rthdr, 0, rtap_len - rtap.len - rtap.pad);\n\tit_present = &rthdr->it_present;\n\n\t/* radiotap header, set always present flags */\n\trthdr->it_len = cpu_to_le16(rtap_len);\n\tit_present_val = BIT(IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t BIT(IEEE80211_RADIOTAP_CHANNEL) |\n\t\t\t BIT(IEEE80211_RADIOTAP_RX_FLAGS);\n\n\tif (!status->chains)\n\t\tit_present_val |= BIT(IEEE80211_RADIOTAP_ANTENNA);\n\n\tfor_each_set_bit(chain, &chains, IEEE80211_MAX_CHAINS) {\n\t\tit_present_val |=\n\t\t\tBIT(IEEE80211_RADIOTAP_EXT) |\n\t\t\tBIT(IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE);\n\t\tput_unaligned_le32(it_present_val, it_present);\n\t\tit_present++;\n\t\tit_present_val = BIT(IEEE80211_RADIOTAP_ANTENNA) |\n\t\t\t\t BIT(IEEE80211_RADIOTAP_DBM_ANTSIGNAL);\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_VENDOR_DATA) {\n\t\tit_present_val |= BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE) |\n\t\t\t\t  BIT(IEEE80211_RADIOTAP_EXT);\n\t\tput_unaligned_le32(it_present_val, it_present);\n\t\tit_present++;\n\t\tit_present_val = rtap.present;\n\t}\n\n\tput_unaligned_le32(it_present_val, it_present);\n\n\tpos = (void *)(it_present + 1);\n\n\t/* the order of the following fields is important */\n\n\t/* IEEE80211_RADIOTAP_TSFT */\n\tif (ieee80211_have_rx_timestamp(status)) {\n\t\t/* padding */\n\t\twhile ((pos - (u8 *)rthdr) & 7)\n\t\t\t*pos++ = 0;\n\t\tput_unaligned_le64(\n\t\t\tieee80211_calculate_rx_timestamp(local, status,\n\t\t\t\t\t\t\t mpdulen, 0),\n\t\t\tpos);\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_TSFT);\n\t\tpos += 8;\n\t}\n\n\t/* IEEE80211_RADIOTAP_FLAGS */\n\tif (has_fcs && ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS))\n\t\t*pos |= IEEE80211_RADIOTAP_F_FCS;\n\tif (status->flag & (RX_FLAG_FAILED_FCS_CRC | RX_FLAG_FAILED_PLCP_CRC))\n\t\t*pos |= IEEE80211_RADIOTAP_F_BADFCS;\n\tif (status->enc_flags & RX_ENC_FLAG_SHORTPRE)\n\t\t*pos |= IEEE80211_RADIOTAP_F_SHORTPRE;\n\tpos++;\n\n\t/* IEEE80211_RADIOTAP_RATE */\n\tif (!rate || status->encoding != RX_ENC_LEGACY) {\n\t\t/*\n\t\t * Without rate information don't add it. If we have,\n\t\t * MCS information is a separate field in radiotap,\n\t\t * added below. The byte here is needed as padding\n\t\t * for the channel though, so initialise it to 0.\n\t\t */\n\t\t*pos = 0;\n\t} else {\n\t\tint shift = 0;\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);\n\t\tif (status->bw == RATE_INFO_BW_10)\n\t\t\tshift = 1;\n\t\telse if (status->bw == RATE_INFO_BW_5)\n\t\t\tshift = 2;\n\t\t*pos = DIV_ROUND_UP(rate->bitrate, 5 * (1 << shift));\n\t}\n\tpos++;\n\n\t/* IEEE80211_RADIOTAP_CHANNEL */\n\t/* TODO: frequency offset in KHz */\n\tput_unaligned_le16(status->freq, pos);\n\tpos += 2;\n\tif (status->bw == RATE_INFO_BW_10)\n\t\tchannel_flags |= IEEE80211_CHAN_HALF;\n\telse if (status->bw == RATE_INFO_BW_5)\n\t\tchannel_flags |= IEEE80211_CHAN_QUARTER;\n\n\tif (status->band == NL80211_BAND_5GHZ ||\n\t    status->band == NL80211_BAND_6GHZ)\n\t\tchannel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ;\n\telse if (status->encoding != RX_ENC_LEGACY)\n\t\tchannel_flags |= IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;\n\telse if (rate && rate->flags & IEEE80211_RATE_ERP_G)\n\t\tchannel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ;\n\telse if (rate)\n\t\tchannel_flags |= IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ;\n\telse\n\t\tchannel_flags |= IEEE80211_CHAN_2GHZ;\n\tput_unaligned_le16(channel_flags, pos);\n\tpos += 2;\n\n\t/* IEEE80211_RADIOTAP_DBM_ANTSIGNAL */\n\tif (ieee80211_hw_check(&local->hw, SIGNAL_DBM) &&\n\t    !(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\t*pos = status->signal;\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL);\n\t\tpos++;\n\t}\n\n\t/* IEEE80211_RADIOTAP_LOCK_QUALITY is missing */\n\n\tif (!status->chains) {\n\t\t/* IEEE80211_RADIOTAP_ANTENNA */\n\t\t*pos = status->antenna;\n\t\tpos++;\n\t}\n\n\t/* IEEE80211_RADIOTAP_DB_ANTNOISE is not used */\n\n\t/* IEEE80211_RADIOTAP_RX_FLAGS */\n\t/* ensure 2 byte alignment for the 2 byte field as required */\n\tif ((pos - (u8 *)rthdr) & 1)\n\t\t*pos++ = 0;\n\tif (status->flag & RX_FLAG_FAILED_PLCP_CRC)\n\t\trx_flags |= IEEE80211_RADIOTAP_F_RX_BADPLCP;\n\tput_unaligned_le16(rx_flags, pos);\n\tpos += 2;\n\n\tif (status->encoding == RX_ENC_HT) {\n\t\tunsigned int stbc;\n\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_MCS);\n\t\t*pos++ = local->hw.radiotap_mcs_details;\n\t\t*pos = 0;\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_SGI;\n\t\tif (status->bw == RATE_INFO_BW_40)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_BW_40;\n\t\tif (status->enc_flags & RX_ENC_FLAG_HT_GF)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_FMT_GF;\n\t\tif (status->enc_flags & RX_ENC_FLAG_LDPC)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_FEC_LDPC;\n\t\tstbc = (status->enc_flags & RX_ENC_FLAG_STBC_MASK) >> RX_ENC_FLAG_STBC_SHIFT;\n\t\t*pos |= stbc << IEEE80211_RADIOTAP_MCS_STBC_SHIFT;\n\t\tpos++;\n\t\t*pos++ = status->rate_idx;\n\t}\n\n\tif (status->flag & RX_FLAG_AMPDU_DETAILS) {\n\t\tu16 flags = 0;\n\n\t\t/* ensure 4 byte alignment */\n\t\twhile ((pos - (u8 *)rthdr) & 3)\n\t\t\tpos++;\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(1 << IEEE80211_RADIOTAP_AMPDU_STATUS);\n\t\tput_unaligned_le32(status->ampdu_reference, pos);\n\t\tpos += 4;\n\t\tif (status->flag & RX_FLAG_AMPDU_LAST_KNOWN)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_LAST_KNOWN;\n\t\tif (status->flag & RX_FLAG_AMPDU_IS_LAST)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_IS_LAST;\n\t\tif (status->flag & RX_FLAG_AMPDU_DELIM_CRC_ERROR)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR;\n\t\tif (status->flag & RX_FLAG_AMPDU_DELIM_CRC_KNOWN)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN;\n\t\tif (status->flag & RX_FLAG_AMPDU_EOF_BIT_KNOWN)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_EOF_KNOWN;\n\t\tif (status->flag & RX_FLAG_AMPDU_EOF_BIT)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_EOF;\n\t\tput_unaligned_le16(flags, pos);\n\t\tpos += 2;\n\t\tif (status->flag & RX_FLAG_AMPDU_DELIM_CRC_KNOWN)\n\t\t\t*pos++ = status->ampdu_delimiter_crc;\n\t\telse\n\t\t\t*pos++ = 0;\n\t\t*pos++ = 0;\n\t}\n\n\tif (status->encoding == RX_ENC_VHT) {\n\t\tu16 known = local->hw.radiotap_vht_details;\n\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_VHT);\n\t\tput_unaligned_le16(known, pos);\n\t\tpos += 2;\n\t\t/* flags */\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;\n\t\t/* in VHT, STBC is binary */\n\t\tif (status->enc_flags & RX_ENC_FLAG_STBC_MASK)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_STBC;\n\t\tif (status->enc_flags & RX_ENC_FLAG_BF)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED;\n\t\tpos++;\n\t\t/* bandwidth */\n\t\tswitch (status->bw) {\n\t\tcase RATE_INFO_BW_80:\n\t\t\t*pos++ = 4;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_160:\n\t\t\t*pos++ = 11;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\t*pos++ = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*pos++ = 0;\n\t\t}\n\t\t/* MCS/NSS */\n\t\t*pos = (status->rate_idx << 4) | status->nss;\n\t\tpos += 4;\n\t\t/* coding field */\n\t\tif (status->enc_flags & RX_ENC_FLAG_LDPC)\n\t\t\t*pos |= IEEE80211_RADIOTAP_CODING_LDPC_USER0;\n\t\tpos++;\n\t\t/* group ID */\n\t\tpos++;\n\t\t/* partial_aid */\n\t\tpos += 2;\n\t}\n\n\tif (local->hw.radiotap_timestamp.units_pos >= 0) {\n\t\tu16 accuracy = 0;\n\t\tu8 flags = IEEE80211_RADIOTAP_TIMESTAMP_FLAG_32BIT;\n\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(1 << IEEE80211_RADIOTAP_TIMESTAMP);\n\n\t\t/* ensure 8 byte alignment */\n\t\twhile ((pos - (u8 *)rthdr) & 7)\n\t\t\tpos++;\n\n\t\tput_unaligned_le64(status->device_timestamp, pos);\n\t\tpos += sizeof(u64);\n\n\t\tif (local->hw.radiotap_timestamp.accuracy >= 0) {\n\t\t\taccuracy = local->hw.radiotap_timestamp.accuracy;\n\t\t\tflags |= IEEE80211_RADIOTAP_TIMESTAMP_FLAG_ACCURACY;\n\t\t}\n\t\tput_unaligned_le16(accuracy, pos);\n\t\tpos += sizeof(u16);\n\n\t\t*pos++ = local->hw.radiotap_timestamp.units_pos;\n\t\t*pos++ = flags;\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE) {\n#define HE_PREP(f, val)\tle16_encode_bits(val, IEEE80211_RADIOTAP_HE_##f)\n\n\t\tif (status->enc_flags & RX_ENC_FLAG_STBC_MASK) {\n\t\t\the.data6 |= HE_PREP(DATA6_NSTS,\n\t\t\t\t\t    FIELD_GET(RX_ENC_FLAG_STBC_MASK,\n\t\t\t\t\t\t      status->enc_flags));\n\t\t\the.data3 |= HE_PREP(DATA3_STBC, 1);\n\t\t} else {\n\t\t\the.data6 |= HE_PREP(DATA6_NSTS, status->nss);\n\t\t}\n\n#define CHECK_GI(s) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA5_GI_##s != \\\n\t\t     (int)NL80211_RATE_INFO_HE_GI_##s)\n\n\t\tCHECK_GI(0_8);\n\t\tCHECK_GI(1_6);\n\t\tCHECK_GI(3_2);\n\n\t\the.data3 |= HE_PREP(DATA3_DATA_MCS, status->rate_idx);\n\t\the.data3 |= HE_PREP(DATA3_DATA_DCM, status->he_dcm);\n\t\the.data3 |= HE_PREP(DATA3_CODING,\n\t\t\t\t    !!(status->enc_flags & RX_ENC_FLAG_LDPC));\n\n\t\the.data5 |= HE_PREP(DATA5_GI, status->he_gi);\n\n\t\tswitch (status->bw) {\n\t\tcase RATE_INFO_BW_20:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_40MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_80MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_160:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_160MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_HE_RU:\n#define CHECK_RU_ALLOC(s) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_##s##T != \\\n\t\t     NL80211_RATE_INFO_HE_RU_ALLOC_##s + 4)\n\n\t\t\tCHECK_RU_ALLOC(26);\n\t\t\tCHECK_RU_ALLOC(52);\n\t\t\tCHECK_RU_ALLOC(106);\n\t\t\tCHECK_RU_ALLOC(242);\n\t\t\tCHECK_RU_ALLOC(484);\n\t\t\tCHECK_RU_ALLOC(996);\n\t\t\tCHECK_RU_ALLOC(2x996);\n\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    status->he_ru + 4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"Invalid SU BW %d\\n\", status->bw);\n\t\t}\n\n\t\t/* ensure 2 byte alignment */\n\t\twhile ((pos - (u8 *)rthdr) & 1)\n\t\t\tpos++;\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_HE);\n\t\tmemcpy(pos, &he, sizeof(he));\n\t\tpos += sizeof(he);\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE_MU) {\n\t\t/* ensure 2 byte alignment */\n\t\twhile ((pos - (u8 *)rthdr) & 1)\n\t\t\tpos++;\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_HE_MU);\n\t\tmemcpy(pos, &he_mu, sizeof(he_mu));\n\t\tpos += sizeof(he_mu);\n\t}\n\n\tif (status->flag & RX_FLAG_NO_PSDU) {\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(1 << IEEE80211_RADIOTAP_ZERO_LEN_PSDU);\n\t\t*pos++ = status->zero_length_psdu_type;\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG) {\n\t\t/* ensure 2 byte alignment */\n\t\twhile ((pos - (u8 *)rthdr) & 1)\n\t\t\tpos++;\n\t\trthdr->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_LSIG);\n\t\tmemcpy(pos, &lsig, sizeof(lsig));\n\t\tpos += sizeof(lsig);\n\t}\n\n\tfor_each_set_bit(chain, &chains, IEEE80211_MAX_CHAINS) {\n\t\t*pos++ = status->chain_signal[chain];\n\t\t*pos++ = chain;\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_VENDOR_DATA) {\n\t\t/* ensure 2 byte alignment for the vendor field as required */\n\t\tif ((pos - (u8 *)rthdr) & 1)\n\t\t\t*pos++ = 0;\n\t\t*pos++ = rtap.oui[0];\n\t\t*pos++ = rtap.oui[1];\n\t\t*pos++ = rtap.oui[2];\n\t\t*pos++ = rtap.subns;\n\t\tput_unaligned_le16(rtap.len, pos);\n\t\tpos += 2;\n\t\t/* align the actual payload as requested */\n\t\twhile ((pos - (u8 *)rthdr) & (rtap.align - 1))\n\t\t\t*pos++ = 0;\n\t\t/* data (and possible padding) already follows */\n\t}\n}\n\nstatic struct sk_buff *\nieee80211_make_monitor_skb(struct ieee80211_local *local,\n\t\t\t   struct sk_buff **origskb,\n\t\t\t   struct ieee80211_rate *rate,\n\t\t\t   int rtap_space, bool use_origskb)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(*origskb);\n\tint rt_hdrlen, needed_headroom;\n\tstruct sk_buff *skb;\n\n\t/* room for the radiotap header based on driver features */\n\trt_hdrlen = ieee80211_rx_radiotap_hdrlen(local, status, *origskb);\n\tneeded_headroom = rt_hdrlen - rtap_space;\n\n\tif (use_origskb) {\n\t\t/* only need to expand headroom if necessary */\n\t\tskb = *origskb;\n\t\t*origskb = NULL;\n\n\t\t/*\n\t\t * This shouldn't trigger often because most devices have an\n\t\t * RX header they pull before we get here, and that should\n\t\t * be big enough for our radiotap information. We should\n\t\t * probably export the length to drivers so that we can have\n\t\t * them allocate enough headroom to start with.\n\t\t */\n\t\tif (skb_headroom(skb) < needed_headroom &&\n\t\t    pskb_expand_head(skb, needed_headroom, 0, GFP_ATOMIC)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Need to make a copy and possibly remove radiotap header\n\t\t * and FCS from the original.\n\t\t */\n\t\tskb = skb_copy_expand(*origskb, needed_headroom, 0, GFP_ATOMIC);\n\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\t/* prepend radiotap information */\n\tieee80211_add_rx_radiotap_header(local, skb, rate, rt_hdrlen, true);\n\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\n\treturn skb;\n}\n\n/*\n * This function copies a received frame to all monitor interfaces and\n * returns a cleaned-up SKB that no longer includes the FCS nor the\n * radiotap header the driver might have added.\n */\nstatic struct sk_buff *\nieee80211_rx_monitor(struct ieee80211_local *local, struct sk_buff *origskb,\n\t\t     struct ieee80211_rate *rate)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(origskb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sk_buff *monskb = NULL;\n\tint present_fcs_len = 0;\n\tunsigned int rtap_space = 0;\n\tstruct ieee80211_sub_if_data *monitor_sdata =\n\t\trcu_dereference(local->monitor_sdata);\n\tbool only_monitor = false;\n\tunsigned int min_head_len;\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_he);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_he_mu);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_lsig);\n\n\tif (unlikely(status->flag & RX_FLAG_RADIOTAP_VENDOR_DATA)) {\n\t\tstruct ieee80211_vendor_radiotap *rtap =\n\t\t\t(void *)(origskb->data + rtap_space);\n\n\t\trtap_space += sizeof(*rtap) + rtap->len + rtap->pad;\n\t}\n\n\tmin_head_len = rtap_space;\n\n\t/*\n\t * First, we may need to make a copy of the skb because\n\t *  (1) we need to modify it for radiotap (if not present), and\n\t *  (2) the other RX handlers will modify the skb we got.\n\t *\n\t * We don't need to, of course, if we aren't going to return\n\t * the SKB because it has a bad FCS/PLCP checksum.\n\t */\n\n\tif (!(status->flag & RX_FLAG_NO_PSDU)) {\n\t\tif (ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)) {\n\t\t\tif (unlikely(origskb->len <= FCS_LEN + rtap_space)) {\n\t\t\t\t/* driver bug */\n\t\t\t\tWARN_ON(1);\n\t\t\t\tdev_kfree_skb(origskb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpresent_fcs_len = FCS_LEN;\n\t\t}\n\n\t\t/* also consider the hdr->frame_control */\n\t\tmin_head_len += 2;\n\t}\n\n\t/* ensure that the expected data elements are in skb head */\n\tif (!pskb_may_pull(origskb, min_head_len)) {\n\t\tdev_kfree_skb(origskb);\n\t\treturn NULL;\n\t}\n\n\tonly_monitor = should_drop_frame(origskb, present_fcs_len, rtap_space);\n\n\tif (!local->monitors || (status->flag & RX_FLAG_SKIP_MONITOR)) {\n\t\tif (only_monitor) {\n\t\t\tdev_kfree_skb(origskb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn ieee80211_clean_skb(origskb, present_fcs_len,\n\t\t\t\t\t   rtap_space);\n\t}\n\n\tieee80211_handle_mu_mimo_mon(monitor_sdata, origskb, rtap_space);\n\n\tlist_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list) {\n\t\tbool last_monitor = list_is_last(&sdata->u.mntr.list,\n\t\t\t\t\t\t &local->mon_list);\n\n\t\tif (!monskb)\n\t\t\tmonskb = ieee80211_make_monitor_skb(local, &origskb,\n\t\t\t\t\t\t\t    rate, rtap_space,\n\t\t\t\t\t\t\t    only_monitor &&\n\t\t\t\t\t\t\t    last_monitor);\n\n\t\tif (monskb) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (last_monitor) {\n\t\t\t\tskb = monskb;\n\t\t\t\tmonskb = NULL;\n\t\t\t} else {\n\t\t\t\tskb = skb_clone(monskb, GFP_ATOMIC);\n\t\t\t}\n\n\t\t\tif (skb) {\n\t\t\t\tskb->dev = sdata->dev;\n\t\t\t\tieee80211_rx_stats(skb->dev, skb->len);\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tif (last_monitor)\n\t\t\tbreak;\n\t}\n\n\t/* this happens if last_monitor was erroneously false */\n\tdev_kfree_skb(monskb);\n\n\t/* ditto */\n\tif (!origskb)\n\t\treturn NULL;\n\n\treturn ieee80211_clean_skb(origskb, present_fcs_len, rtap_space);\n}\n\nstatic void ieee80211_parse_qos(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tint tid, seqno_idx, security_idx;\n\n\t/* does the frame have a qos control field? */\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\t/* frame has qos control */\n\t\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\t\tif (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)\n\t\t\tstatus->rx_flags |= IEEE80211_RX_AMSDU;\n\n\t\tseqno_idx = tid;\n\t\tsecurity_idx = tid;\n\t} else {\n\t\t/*\n\t\t * IEEE 802.11-2007, 7.1.3.4.1 (\"Sequence Number field\"):\n\t\t *\n\t\t *\tSequence numbers for management frames, QoS data\n\t\t *\tframes with a broadcast/multicast address in the\n\t\t *\tAddress 1 field, and all non-QoS data frames sent\n\t\t *\tby QoS STAs are assigned using an additional single\n\t\t *\tmodulo-4096 counter, [...]\n\t\t *\n\t\t * We also use that counter for non-QoS STAs.\n\t\t */\n\t\tseqno_idx = IEEE80211_NUM_TIDS;\n\t\tsecurity_idx = 0;\n\t\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\t\tsecurity_idx = IEEE80211_NUM_TIDS;\n\t\ttid = 0;\n\t}\n\n\trx->seqno_idx = seqno_idx;\n\trx->security_idx = security_idx;\n\t/* Set skb->priority to 1d tag if highest order bit of TID is not set.\n\t * For now, set skb->priority to 0 for other cases. */\n\trx->skb->priority = (tid > 7) ? 0 : tid;\n}\n\n/**\n * DOC: Packet alignment\n *\n * Drivers always need to pass packets that are aligned to two-byte boundaries\n * to the stack.\n *\n * Additionally, should, if possible, align the payload data in a way that\n * guarantees that the contained IP header is aligned to a four-byte\n * boundary. In the case of regular frames, this simply means aligning the\n * payload to a four-byte boundary (because either the IP header is directly\n * contained, or IV/RFC1042 headers that have a length divisible by four are\n * in front of it).  If the payload data is not properly aligned and the\n * architecture doesn't support efficient unaligned operations, mac80211\n * will align the data.\n *\n * With A-MSDU frames, however, the payload data address must yield two modulo\n * four because there are 14-byte 802.3 headers within the A-MSDU frames that\n * push the IP header further back to a multiple of four again. Thankfully, the\n * specs were sane enough this time around to require padding each A-MSDU\n * subframe to a length that is a multiple of four.\n *\n * Padding like Atheros hardware adds which is between the 802.11 header and\n * the payload is not supported, the driver is required to move the 802.11\n * header to be directly in front of the payload in that case.\n */\nstatic void ieee80211_verify_alignment(struct ieee80211_rx_data *rx)\n{\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\tWARN_ON_ONCE((unsigned long)rx->skb->data & 1);\n#endif\n}\n\n\n/* rx handlers */\n\nstatic int ieee80211_is_unicast_robust_mgmt_frame(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn 0;\n\n\treturn ieee80211_is_robust_mgmt_frame(skb);\n}\n\n\nstatic int ieee80211_is_multicast_robust_mgmt_frame(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (!is_multicast_ether_addr(hdr->addr1))\n\t\treturn 0;\n\n\treturn ieee80211_is_robust_mgmt_frame(skb);\n}\n\n\n/* Get the BIP key index from MMIE; return -1 if this is not a BIP frame */\nstatic int ieee80211_get_mmie_keyidx(struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *hdr = (struct ieee80211_mgmt *) skb->data;\n\tstruct ieee80211_mmie *mmie;\n\tstruct ieee80211_mmie_16 *mmie16;\n\n\tif (skb->len < 24 + sizeof(*mmie) || !is_multicast_ether_addr(hdr->da))\n\t\treturn -1;\n\n\tif (!ieee80211_is_robust_mgmt_frame(skb) &&\n\t    !ieee80211_is_beacon(hdr->frame_control))\n\t\treturn -1; /* not a robust management frame */\n\n\tmmie = (struct ieee80211_mmie *)\n\t\t(skb->data + skb->len - sizeof(*mmie));\n\tif (mmie->element_id == WLAN_EID_MMIE &&\n\t    mmie->length == sizeof(*mmie) - 2)\n\t\treturn le16_to_cpu(mmie->key_id);\n\n\tmmie16 = (struct ieee80211_mmie_16 *)\n\t\t(skb->data + skb->len - sizeof(*mmie16));\n\tif (skb->len >= 24 + sizeof(*mmie16) &&\n\t    mmie16->element_id == WLAN_EID_MMIE &&\n\t    mmie16->length == sizeof(*mmie16) - 2)\n\t\treturn le16_to_cpu(mmie16->key_id);\n\n\treturn -1;\n}\n\nstatic int ieee80211_get_keyid(struct sk_buff *skb,\n\t\t\t       const struct ieee80211_cipher_scheme *cs)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc;\n\tint hdrlen;\n\tint minlen;\n\tu8 key_idx_off;\n\tu8 key_idx_shift;\n\tu8 keyid;\n\n\tfc = hdr->frame_control;\n\thdrlen = ieee80211_hdrlen(fc);\n\n\tif (cs) {\n\t\tminlen = hdrlen + cs->hdr_len;\n\t\tkey_idx_off = hdrlen + cs->key_idx_off;\n\t\tkey_idx_shift = cs->key_idx_shift;\n\t} else {\n\t\t/* WEP, TKIP, CCMP and GCMP */\n\t\tminlen = hdrlen + IEEE80211_WEP_IV_LEN;\n\t\tkey_idx_off = hdrlen + 3;\n\t\tkey_idx_shift = 6;\n\t}\n\n\tif (unlikely(skb->len < minlen))\n\t\treturn -EINVAL;\n\n\tskb_copy_bits(skb, key_idx_off, &keyid, 1);\n\n\tif (cs)\n\t\tkeyid &= cs->key_idx_mask;\n\tkeyid >>= key_idx_shift;\n\n\t/* cs could use more than the usual two bits for the keyid */\n\tif (unlikely(keyid >= NUM_DEFAULT_KEYS))\n\t\treturn -EINVAL;\n\n\treturn keyid;\n}\n\nstatic ieee80211_rx_result ieee80211_rx_mesh_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tchar *dev_addr = rx->sdata->vif.addr;\n\n\tif (ieee80211_is_data(hdr->frame_control)) {\n\t\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\tif (ieee80211_has_tods(hdr->frame_control) ||\n\t\t\t    !ieee80211_has_fromds(hdr->frame_control))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tif (ether_addr_equal(hdr->addr3, dev_addr))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t} else {\n\t\t\tif (!ieee80211_has_a4(hdr->frame_control))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tif (ether_addr_equal(hdr->addr4, dev_addr))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t}\n\t}\n\n\t/* If there is not an established peer link and this is not a peer link\n\t * establisment frame, beacon or probe, drop the frame.\n\t */\n\n\tif (!rx->sta || sta_plink_state(rx->sta) != NL80211_PLINK_ESTAB) {\n\t\tstruct ieee80211_mgmt *mgmt;\n\n\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\tif (ieee80211_is_action(hdr->frame_control)) {\n\t\t\tu8 category;\n\n\t\t\t/* make sure category field is present */\n\t\t\tif (rx->skb->len < IEEE80211_MIN_ACTION_SIZE)\n\t\t\t\treturn RX_DROP_MONITOR;\n\n\t\t\tmgmt = (struct ieee80211_mgmt *)hdr;\n\t\t\tcategory = mgmt->u.action.category;\n\t\t\tif (category != WLAN_CATEGORY_MESH_ACTION &&\n\t\t\t    category != WLAN_CATEGORY_SELF_PROTECTED)\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\treturn RX_CONTINUE;\n\t\t}\n\n\t\tif (ieee80211_is_probe_req(hdr->frame_control) ||\n\t\t    ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t    ieee80211_is_beacon(hdr->frame_control) ||\n\t\t    ieee80211_is_auth(hdr->frame_control))\n\t\t\treturn RX_CONTINUE;\n\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic inline bool ieee80211_rx_reorder_ready(struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t      int index)\n{\n\tstruct sk_buff_head *frames = &tid_agg_rx->reorder_buf[index];\n\tstruct sk_buff *tail = skb_peek_tail(frames);\n\tstruct ieee80211_rx_status *status;\n\n\tif (tid_agg_rx->reorder_buf_filtered & BIT_ULL(index))\n\t\treturn true;\n\n\tif (!tail)\n\t\treturn false;\n\n\tstatus = IEEE80211_SKB_RXCB(tail);\n\tif (status->flag & RX_FLAG_AMSDU_MORE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ieee80211_release_reorder_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t    int index,\n\t\t\t\t\t    struct sk_buff_head *frames)\n{\n\tstruct sk_buff_head *skb_list = &tid_agg_rx->reorder_buf[index];\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rx_status *status;\n\n\tlockdep_assert_held(&tid_agg_rx->reorder_lock);\n\n\tif (skb_queue_empty(skb_list))\n\t\tgoto no_frame;\n\n\tif (!ieee80211_rx_reorder_ready(tid_agg_rx, index)) {\n\t\t__skb_queue_purge(skb_list);\n\t\tgoto no_frame;\n\t}\n\n\t/* release frames from the reorder ring buffer */\n\ttid_agg_rx->stored_mpdu_num--;\n\twhile ((skb = __skb_dequeue(skb_list))) {\n\t\tstatus = IEEE80211_SKB_RXCB(skb);\n\t\tstatus->rx_flags |= IEEE80211_RX_DEFERRED_RELEASE;\n\t\t__skb_queue_tail(frames, skb);\n\t}\n\nno_frame:\n\ttid_agg_rx->reorder_buf_filtered &= ~BIT_ULL(index);\n\ttid_agg_rx->head_seq_num = ieee80211_sn_inc(tid_agg_rx->head_seq_num);\n}\n\nstatic void ieee80211_release_reorder_frames(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t     struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t     u16 head_seq_num,\n\t\t\t\t\t     struct sk_buff_head *frames)\n{\n\tint index;\n\n\tlockdep_assert_held(&tid_agg_rx->reorder_lock);\n\n\twhile (ieee80211_sn_less(tid_agg_rx->head_seq_num, head_seq_num)) {\n\t\tindex = tid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\t\tieee80211_release_reorder_frame(sdata, tid_agg_rx, index,\n\t\t\t\t\t\tframes);\n\t}\n}\n\n/*\n * Timeout (in jiffies) for skb's that are waiting in the RX reorder buffer. If\n * the skb was added to the buffer longer than this time ago, the earlier\n * frames that have not yet been received are assumed to be lost and the skb\n * can be released for processing. This may also release other skb's from the\n * reorder buffer if there are no additional gaps between the frames.\n *\n * Callers must hold tid_agg_rx->reorder_lock.\n */\n#define HT_RX_REORDER_BUF_TIMEOUT (HZ / 10)\n\nstatic void ieee80211_sta_reorder_release(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t  struct sk_buff_head *frames)\n{\n\tint index, i, j;\n\n\tlockdep_assert_held(&tid_agg_rx->reorder_lock);\n\n\t/* release the buffer until next missing frame */\n\tindex = tid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\tif (!ieee80211_rx_reorder_ready(tid_agg_rx, index) &&\n\t    tid_agg_rx->stored_mpdu_num) {\n\t\t/*\n\t\t * No buffers ready to be released, but check whether any\n\t\t * frames in the reorder buffer have timed out.\n\t\t */\n\t\tint skipped = 1;\n\t\tfor (j = (index + 1) % tid_agg_rx->buf_size; j != index;\n\t\t     j = (j + 1) % tid_agg_rx->buf_size) {\n\t\t\tif (!ieee80211_rx_reorder_ready(tid_agg_rx, j)) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (skipped &&\n\t\t\t    !time_after(jiffies, tid_agg_rx->reorder_time[j] +\n\t\t\t\t\tHT_RX_REORDER_BUF_TIMEOUT))\n\t\t\t\tgoto set_release_timer;\n\n\t\t\t/* don't leave incomplete A-MSDUs around */\n\t\t\tfor (i = (index + 1) % tid_agg_rx->buf_size; i != j;\n\t\t\t     i = (i + 1) % tid_agg_rx->buf_size)\n\t\t\t\t__skb_queue_purge(&tid_agg_rx->reorder_buf[i]);\n\n\t\t\tht_dbg_ratelimited(sdata,\n\t\t\t\t\t   \"release an RX reorder frame due to timeout on earlier frames\\n\");\n\t\t\tieee80211_release_reorder_frame(sdata, tid_agg_rx, j,\n\t\t\t\t\t\t\tframes);\n\n\t\t\t/*\n\t\t\t * Increment the head seq# also for the skipped slots.\n\t\t\t */\n\t\t\ttid_agg_rx->head_seq_num =\n\t\t\t\t(tid_agg_rx->head_seq_num +\n\t\t\t\t skipped) & IEEE80211_SN_MASK;\n\t\t\tskipped = 0;\n\t\t}\n\t} else while (ieee80211_rx_reorder_ready(tid_agg_rx, index)) {\n\t\tieee80211_release_reorder_frame(sdata, tid_agg_rx, index,\n\t\t\t\t\t\tframes);\n\t\tindex =\ttid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\t}\n\n\tif (tid_agg_rx->stored_mpdu_num) {\n\t\tj = index = tid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\n\t\tfor (; j != (index - 1) % tid_agg_rx->buf_size;\n\t\t     j = (j + 1) % tid_agg_rx->buf_size) {\n\t\t\tif (ieee80211_rx_reorder_ready(tid_agg_rx, j))\n\t\t\t\tbreak;\n\t\t}\n\n set_release_timer:\n\n\t\tif (!tid_agg_rx->removed)\n\t\t\tmod_timer(&tid_agg_rx->reorder_timer,\n\t\t\t\t  tid_agg_rx->reorder_time[j] + 1 +\n\t\t\t\t  HT_RX_REORDER_BUF_TIMEOUT);\n\t} else {\n\t\tdel_timer(&tid_agg_rx->reorder_timer);\n\t}\n}\n\n/*\n * As this function belongs to the RX path it must be under\n * rcu_read_lock protection. It returns false if the frame\n * can be processed immediately, true if it was consumed.\n */\nstatic bool ieee80211_sta_manage_reorder_buf(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t     struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct sk_buff_head *frames)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tu16 sc = le16_to_cpu(hdr->seq_ctrl);\n\tu16 mpdu_seq_num = (sc & IEEE80211_SCTL_SEQ) >> 4;\n\tu16 head_seq_num, buf_size;\n\tint index;\n\tbool ret = true;\n\n\tspin_lock(&tid_agg_rx->reorder_lock);\n\n\t/*\n\t * Offloaded BA sessions have no known starting sequence number so pick\n\t * one from first Rxed frame for this tid after BA was started.\n\t */\n\tif (unlikely(tid_agg_rx->auto_seq)) {\n\t\ttid_agg_rx->auto_seq = false;\n\t\ttid_agg_rx->ssn = mpdu_seq_num;\n\t\ttid_agg_rx->head_seq_num = mpdu_seq_num;\n\t}\n\n\tbuf_size = tid_agg_rx->buf_size;\n\thead_seq_num = tid_agg_rx->head_seq_num;\n\n\t/*\n\t * If the current MPDU's SN is smaller than the SSN, it shouldn't\n\t * be reordered.\n\t */\n\tif (unlikely(!tid_agg_rx->started)) {\n\t\tif (ieee80211_sn_less(mpdu_seq_num, head_seq_num)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\ttid_agg_rx->started = true;\n\t}\n\n\t/* frame with out of date sequence number */\n\tif (ieee80211_sn_less(mpdu_seq_num, head_seq_num)) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If frame the sequence number exceeds our buffering window\n\t * size release some previous frames to make room for this one.\n\t */\n\tif (!ieee80211_sn_less(mpdu_seq_num, head_seq_num + buf_size)) {\n\t\thead_seq_num = ieee80211_sn_inc(\n\t\t\t\tieee80211_sn_sub(mpdu_seq_num, buf_size));\n\t\t/* release stored frames up to new head to stack */\n\t\tieee80211_release_reorder_frames(sdata, tid_agg_rx,\n\t\t\t\t\t\t head_seq_num, frames);\n\t}\n\n\t/* Now the new frame is always in the range of the reordering buffer */\n\n\tindex = mpdu_seq_num % tid_agg_rx->buf_size;\n\n\t/* check if we already stored this frame */\n\tif (ieee80211_rx_reorder_ready(tid_agg_rx, index)) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the current MPDU is in the right order and nothing else\n\t * is stored we can process it directly, no need to buffer it.\n\t * If it is first but there's something stored, we may be able\n\t * to release frames after this one.\n\t */\n\tif (mpdu_seq_num == tid_agg_rx->head_seq_num &&\n\t    tid_agg_rx->stored_mpdu_num == 0) {\n\t\tif (!(status->flag & RX_FLAG_AMSDU_MORE))\n\t\t\ttid_agg_rx->head_seq_num =\n\t\t\t\tieee80211_sn_inc(tid_agg_rx->head_seq_num);\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\t/* put the frame in the reordering buffer */\n\t__skb_queue_tail(&tid_agg_rx->reorder_buf[index], skb);\n\tif (!(status->flag & RX_FLAG_AMSDU_MORE)) {\n\t\ttid_agg_rx->reorder_time[index] = jiffies;\n\t\ttid_agg_rx->stored_mpdu_num++;\n\t\tieee80211_sta_reorder_release(sdata, tid_agg_rx, frames);\n\t}\n\n out:\n\tspin_unlock(&tid_agg_rx->reorder_lock);\n\treturn ret;\n}\n\n/*\n * Reorder MPDUs from A-MPDUs, keeping them on a buffer. Returns\n * true if the MPDU was buffered, false if it should be processed.\n */\nstatic void ieee80211_rx_reorder_ampdu(struct ieee80211_rx_data *rx,\n\t\t\t\t       struct sk_buff_head *frames)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct sta_info *sta = rx->sta;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tu16 sc;\n\tu8 tid, ack_policy;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1))\n\t\tgoto dont_reorder;\n\n\t/*\n\t * filter the QoS data rx stream according to\n\t * STA/TID and check if this STA/TID is on aggregation\n\t */\n\n\tif (!sta)\n\t\tgoto dont_reorder;\n\n\tack_policy = *ieee80211_get_qos_ctl(hdr) &\n\t\t     IEEE80211_QOS_CTL_ACK_POLICY_MASK;\n\ttid = ieee80211_get_tid(hdr);\n\n\ttid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\tif (!tid_agg_rx) {\n\t\tif (ack_policy == IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK &&\n\t\t    !test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&\n\t\t    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))\n\t\t\tieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,\n\t\t\t\t\t     WLAN_BACK_RECIPIENT,\n\t\t\t\t\t     WLAN_REASON_QSTA_REQUIRE_SETUP);\n\t\tgoto dont_reorder;\n\t}\n\n\t/* qos null data frames are excluded */\n\tif (unlikely(hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_NULLFUNC)))\n\t\tgoto dont_reorder;\n\n\t/* not part of a BA session */\n\tif (ack_policy != IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK &&\n\t    ack_policy != IEEE80211_QOS_CTL_ACK_POLICY_NORMAL)\n\t\tgoto dont_reorder;\n\n\t/* new, potentially un-ordered, ampdu frame - process it */\n\n\t/* reset session timer */\n\tif (tid_agg_rx->timeout)\n\t\ttid_agg_rx->last_rx = jiffies;\n\n\t/* if this mpdu is fragmented - terminate rx aggregation session */\n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tif (sc & IEEE80211_SCTL_FRAG) {\n\t\tskb_queue_tail(&rx->sdata->skb_queue, skb);\n\t\tieee80211_queue_work(&local->hw, &rx->sdata->work);\n\t\treturn;\n\t}\n\n\t/*\n\t * No locking needed -- we will only ever process one\n\t * RX packet at a time, and thus own tid_agg_rx. All\n\t * other code manipulating it needs to (and does) make\n\t * sure that we cannot get to it any more before doing\n\t * anything with it.\n\t */\n\tif (ieee80211_sta_manage_reorder_buf(rx->sdata, tid_agg_rx, skb,\n\t\t\t\t\t     frames))\n\t\treturn;\n\n dont_reorder:\n\t__skb_queue_tail(frames, skb);\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_check_dup(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (status->flag & RX_FLAG_DUP_VALIDATED)\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Drop duplicate 802.11 retransmissions\n\t * (IEEE 802.11-2012: 9.3.2.10 \"Duplicate detection and recovery\")\n\t */\n\n\tif (rx->skb->len < 24)\n\t\treturn RX_CONTINUE;\n\n\tif (ieee80211_is_ctl(hdr->frame_control) ||\n\t    ieee80211_is_any_nullfunc(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1))\n\t\treturn RX_CONTINUE;\n\n\tif (!rx->sta)\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(ieee80211_has_retry(hdr->frame_control) &&\n\t\t     rx->sta->last_seq_ctrl[rx->seqno_idx] == hdr->seq_ctrl)) {\n\t\tI802_DEBUG_INC(rx->local->dot11FrameDuplicateCount);\n\t\trx->sta->rx_stats.num_duplicates++;\n\t\treturn RX_DROP_UNUSABLE;\n\t} else if (!(status->flag & RX_FLAG_AMSDU_MORE)) {\n\t\trx->sta->last_seq_ctrl[rx->seqno_idx] = hdr->seq_ctrl;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\n\t/* Drop disallowed frame classes based on STA auth/assoc state;\n\t * IEEE 802.11, Chap 5.5.\n\t *\n\t * mac80211 filters only based on association state, i.e. it drops\n\t * Class 3 frames from not associated stations. hostapd sends\n\t * deauth/disassoc frames when needed. In addition, hostapd is\n\t * responsible for filtering on both auth and assoc states.\n\t */\n\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\treturn ieee80211_rx_mesh_check(rx);\n\n\tif (unlikely((ieee80211_is_data(hdr->frame_control) ||\n\t\t      ieee80211_is_pspoll(hdr->frame_control)) &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {\n\t\t/*\n\t\t * accept port control frames from the AP even when it's not\n\t\t * yet marked ASSOC to prevent a race where we don't set the\n\t\t * assoc bit quickly enough before it sends the first frame\n\t\t */\n\t\tif (rx->sta && rx->sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    ieee80211_is_data_present(hdr->frame_control)) {\n\t\t\tunsigned int hdrlen;\n\t\t\t__be16 ethertype;\n\n\t\t\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t\t\tif (rx->skb->len < hdrlen + 8)\n\t\t\t\treturn RX_DROP_MONITOR;\n\n\t\t\tskb_copy_bits(rx->skb, hdrlen + 6, &ethertype, 2);\n\t\t\tif (ethertype == rx->sdata->control_port_protocol)\n\t\t\t\treturn RX_CONTINUE;\n\t\t}\n\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t    cfg80211_rx_spurious_frame(rx->sdata->dev,\n\t\t\t\t\t       hdr->addr2,\n\t\t\t\t\t       GFP_ATOMIC))\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_check_more_data(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tlocal = rx->local;\n\tskb = rx->skb;\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (!local->pspolling)\n\t\treturn RX_CONTINUE;\n\n\tif (!ieee80211_has_fromds(hdr->frame_control))\n\t\t/* this is not from AP */\n\t\treturn RX_CONTINUE;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (!ieee80211_has_moredata(hdr->frame_control)) {\n\t\t/* AP has no more frames buffered for us */\n\t\tlocal->pspolling = false;\n\t\treturn RX_CONTINUE;\n\t}\n\n\t/* more data bit is set, let's request a new frame from the AP */\n\tieee80211_send_pspoll(local, rx->sdata);\n\n\treturn RX_CONTINUE;\n}\n\nstatic void sta_ps_start(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ps_data *ps;\n\tint tid;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tps = &sdata->bss->ps;\n\telse\n\t\treturn;\n\n\tatomic_inc(&ps->num_sta_ps);\n\tset_sta_flag(sta, WLAN_STA_PS_STA);\n\tif (!ieee80211_hw_check(&local->hw, AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_SLEEP, &sta->sta);\n\tps_dbg(sdata, \"STA %pM aid %d enters power save mode\\n\",\n\t       sta->sta.addr, sta->sta.aid);\n\n\tieee80211_clear_fast_xmit(sta);\n\n\tif (!sta->sta.txq[0])\n\t\treturn;\n\n\tfor (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {\n\t\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\t\tstruct txq_info *txqi = to_txq_info(txq);\n\n\t\tspin_lock(&local->active_txq_lock[txq->ac]);\n\t\tif (!list_empty(&txqi->schedule_order))\n\t\t\tlist_del_init(&txqi->schedule_order);\n\t\tspin_unlock(&local->active_txq_lock[txq->ac]);\n\n\t\tif (txq_has_queue(txq))\n\t\t\tset_bit(tid, &sta->txq_buffered_tids);\n\t\telse\n\t\t\tclear_bit(tid, &sta->txq_buffered_tids);\n\t}\n}\n\nstatic void sta_ps_end(struct sta_info *sta)\n{\n\tps_dbg(sta->sdata, \"STA %pM aid %d exits power save mode\\n\",\n\t       sta->sta.addr, sta->sta.aid);\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {\n\t\t/*\n\t\t * Clear the flag only if the other one is still set\n\t\t * so that the TX path won't start TX'ing new frames\n\t\t * directly ... In the case that the driver flag isn't\n\t\t * set ieee80211_sta_ps_deliver_wakeup() will clear it.\n\t\t */\n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d driver-ps-blocked\\n\",\n\t\t       sta->sta.addr, sta->sta.aid);\n\t\treturn;\n\t}\n\n\tset_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\tieee80211_sta_ps_deliver_wakeup(sta);\n}\n\nint ieee80211_sta_ps_transition(struct ieee80211_sta *pubsta, bool start)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tbool in_ps;\n\n\tWARN_ON(!ieee80211_hw_check(&sta->local->hw, AP_LINK_PS));\n\n\t/* Don't let the same PS state be set twice */\n\tin_ps = test_sta_flag(sta, WLAN_STA_PS_STA);\n\tif ((start && in_ps) || (!start && !in_ps))\n\t\treturn -EINVAL;\n\n\tif (start)\n\t\tsta_ps_start(sta);\n\telse\n\t\tsta_ps_end(sta);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_sta_ps_transition);\n\nvoid ieee80211_sta_pspoll(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\tif (test_sta_flag(sta, WLAN_STA_SP))\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_sta_ps_deliver_poll_response(sta);\n\telse\n\t\tset_sta_flag(sta, WLAN_STA_PSPOLL);\n}\nEXPORT_SYMBOL(ieee80211_sta_pspoll);\n\nvoid ieee80211_sta_uapsd_trigger(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tint ac = ieee80211_ac_from_tid(tid);\n\n\t/*\n\t * If this AC is not trigger-enabled do nothing unless the\n\t * driver is calling us after it already checked.\n\t *\n\t * NB: This could/should check a separate bitmap of trigger-\n\t * enabled queues, but for now we only implement uAPSD w/o\n\t * TSPEC changes to the ACs, so they're always the same.\n\t */\n\tif (!(sta->sta.uapsd_queues & ieee80211_ac_to_qos_mask[ac]) &&\n\t    tid != IEEE80211_NUM_TIDS)\n\t\treturn;\n\n\t/* if we are in a service period, do nothing */\n\tif (test_sta_flag(sta, WLAN_STA_SP))\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_sta_ps_deliver_uapsd(sta);\n\telse\n\t\tset_sta_flag(sta, WLAN_STA_UAPSD);\n}\nEXPORT_SYMBOL(ieee80211_sta_uapsd_trigger);\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_uapsd_and_pspoll(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (!rx->sta)\n\t\treturn RX_CONTINUE;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN)\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * The device handles station powersave, so don't do anything about\n\t * uAPSD and PS-Poll frames (the latter shouldn't even come up from\n\t * it to mac80211 since they're handled.)\n\t */\n\tif (ieee80211_hw_check(&sdata->local->hw, AP_LINK_PS))\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Don't do anything if the station isn't already asleep. In\n\t * the uAPSD case, the station will probably be marked asleep,\n\t * in the PS-Poll case the station must be confused ...\n\t */\n\tif (!test_sta_flag(rx->sta, WLAN_STA_PS_STA))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control))) {\n\t\tieee80211_sta_pspoll(&rx->sta->sta);\n\n\t\t/* Free PS Poll skb here instead of returning RX_DROP that would\n\t\t * count as an dropped frame. */\n\t\tdev_kfree_skb(rx->skb);\n\n\t\treturn RX_QUEUED;\n\t} else if (!ieee80211_has_morefrags(hdr->frame_control) &&\n\t\t   !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&\n\t\t   ieee80211_has_pm(hdr->frame_control) &&\n\t\t   (ieee80211_is_data_qos(hdr->frame_control) ||\n\t\t    ieee80211_is_qos_nullfunc(hdr->frame_control))) {\n\t\tu8 tid = ieee80211_get_tid(hdr);\n\n\t\tieee80211_sta_uapsd_trigger(&rx->sta->sta, tid);\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)\n{\n\tstruct sta_info *sta = rx->sta;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint i;\n\n\tif (!sta)\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Update last_rx only for IBSS packets which are for the current\n\t * BSSID and for station already AUTHORIZED to avoid keeping the\n\t * current IBSS network alive in cases where other STAs start\n\t * using different BSSID. This will also give the station another\n\t * chance to restart the authentication/authorization in case\n\t * something went wrong the first time.\n\t */\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tu8 *bssid = ieee80211_get_bssid(hdr, rx->skb->len,\n\t\t\t\t\t\tNL80211_IFTYPE_ADHOC);\n\t\tif (ether_addr_equal(bssid, rx->sdata->u.ibss.bssid) &&\n\t\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tsta->rx_stats.last_rx = jiffies;\n\t\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !is_multicast_ether_addr(hdr->addr1))\n\t\t\t\tsta->rx_stats.last_rate =\n\t\t\t\t\tsta_stats_encode_rate(status);\n\t\t}\n\t} else if (rx->sdata->vif.type == NL80211_IFTYPE_OCB) {\n\t\tsta->rx_stats.last_rx = jiffies;\n\t} else if (!ieee80211_is_s1g_beacon(hdr->frame_control) &&\n\t\t   is_multicast_ether_addr(hdr->addr1)) {\n\t\t/*\n\t\t * Mesh beacons will update last_rx when if they are found to\n\t\t * match the current local configuration when processed.\n\t\t */\n\t\tsta->rx_stats.last_rx = jiffies;\n\t\tif (ieee80211_is_data(hdr->frame_control))\n\t\t\tsta->rx_stats.last_rate = sta_stats_encode_rate(status);\n\t}\n\n\tsta->rx_stats.fragments++;\n\n\tu64_stats_update_begin(&rx->sta->rx_stats.syncp);\n\tsta->rx_stats.bytes += rx->skb->len;\n\tu64_stats_update_end(&rx->sta->rx_stats.syncp);\n\n\tif (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\tsta->rx_stats.last_signal = status->signal;\n\t\tewma_signal_add(&sta->rx_stats_avg.signal, -status->signal);\n\t}\n\n\tif (status->chains) {\n\t\tsta->rx_stats.chains = status->chains;\n\t\tfor (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {\n\t\t\tint signal = status->chain_signal[i];\n\n\t\t\tif (!(status->chains & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tsta->rx_stats.chain_signal_last[i] = signal;\n\t\t\tewma_signal_add(&sta->rx_stats_avg.chain_signal[i],\n\t\t\t\t\t-signal);\n\t\t}\n\t}\n\n\tif (ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Change STA power saving mode only at the end of a frame\n\t * exchange sequence, and only for a data or management\n\t * frame as specified in IEEE 802.11-2016 11.2.3.2\n\t */\n\tif (!ieee80211_hw_check(&sta->local->hw, AP_LINK_PS) &&\n\t    !ieee80211_has_morefrags(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(hdr->addr1) &&\n\t    (ieee80211_is_mgmt(hdr->frame_control) ||\n\t     ieee80211_is_data(hdr->frame_control)) &&\n\t    !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&\n\t    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)) {\n\t\tif (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\t\tif (!ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsta_ps_end(sta);\n\t\t} else {\n\t\t\tif (ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsta_ps_start(sta);\n\t\t}\n\t}\n\n\t/* mesh power save support */\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\tieee80211_mps_rx_h_sta_process(sta, hdr);\n\n\t/*\n\t * Drop (qos-)data::nullfunc frames silently, since they\n\t * are used only to control station power saving mode.\n\t */\n\tif (ieee80211_is_any_nullfunc(hdr->frame_control)) {\n\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_nullfunc);\n\n\t\t/*\n\t\t * If we receive a 4-addr nullfunc frame from a STA\n\t\t * that was not moved to a 4-addr STA vlan yet send\n\t\t * the event to userspace and for older hostapd drop\n\t\t * the frame to the monitor interface.\n\t\t */\n\t\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t\t    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t     (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t      !rx->sdata->u.vlan.sta))) {\n\t\t\tif (!test_and_set_sta_flag(sta, WLAN_STA_4ADDR_EVENT))\n\t\t\t\tcfg80211_rx_unexpected_4addr_frame(\n\t\t\t\t\trx->sdata->dev, sta->sta.addr,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\treturn RX_DROP_MONITOR;\n\t\t}\n\t\t/*\n\t\t * Update counter and free packet here to avoid\n\t\t * counting this as a dropped packed.\n\t\t */\n\t\tsta->rx_stats.packets++;\n\t\tdev_kfree_skb(rx->skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\treturn RX_CONTINUE;\n} /* ieee80211_rx_h_sta_process */\n\nstatic struct ieee80211_key *\nieee80211_rx_get_bigtk(struct ieee80211_rx_data *rx, int idx)\n{\n\tstruct ieee80211_key *key = NULL;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tint idx2;\n\n\t/* Make sure key gets set if either BIGTK key index is set so that\n\t * ieee80211_drop_unencrypted_mgmt() can properly drop both unprotected\n\t * Beacon frames and Beacon frames that claim to use another BIGTK key\n\t * index (i.e., a key that we do not have).\n\t */\n\n\tif (idx < 0) {\n\t\tidx = NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS;\n\t\tidx2 = idx + 1;\n\t} else {\n\t\tif (idx == NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)\n\t\t\tidx2 = idx + 1;\n\t\telse\n\t\t\tidx2 = idx - 1;\n\t}\n\n\tif (rx->sta)\n\t\tkey = rcu_dereference(rx->sta->gtk[idx]);\n\tif (!key)\n\t\tkey = rcu_dereference(sdata->keys[idx]);\n\tif (!key && rx->sta)\n\t\tkey = rcu_dereference(rx->sta->gtk[idx2]);\n\tif (!key)\n\t\tkey = rcu_dereference(sdata->keys[idx2]);\n\n\treturn key;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint keyidx;\n\tieee80211_rx_result result = RX_DROP_UNUSABLE;\n\tstruct ieee80211_key *sta_ptk = NULL;\n\tstruct ieee80211_key *ptk_idx = NULL;\n\tint mmie_keyidx = -1;\n\t__le16 fc;\n\tconst struct ieee80211_cipher_scheme *cs = NULL;\n\n\tif (ieee80211_is_ext(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Key selection 101\n\t *\n\t * There are five types of keys:\n\t *  - GTK (group keys)\n\t *  - IGTK (group keys for management frames)\n\t *  - BIGTK (group keys for Beacon frames)\n\t *  - PTK (pairwise keys)\n\t *  - STK (station-to-station pairwise keys)\n\t *\n\t * When selecting a key, we have to distinguish between multicast\n\t * (including broadcast) and unicast frames, the latter can only\n\t * use PTKs and STKs while the former always use GTKs, IGTKs, and\n\t * BIGTKs. Unless, of course, actual WEP keys (\"pre-RSNA\") are used,\n\t * then unicast frames can also use key indices like GTKs. Hence, if we\n\t * don't have a PTK/STK we check the key index for a WEP key.\n\t *\n\t * Note that in a regular BSS, multicast frames are sent by the\n\t * AP only, associated stations unicast the frame to the AP first\n\t * which then multicasts it on their behalf.\n\t *\n\t * There is also a slight problem in IBSS mode: GTKs are negotiated\n\t * with each station, that is something we don't currently handle.\n\t * The spec seems to expect that one negotiates the same key with\n\t * every station but there's no such requirement; VLANs could be\n\t * possible.\n\t */\n\n\t/* start without a key */\n\trx->key = NULL;\n\tfc = hdr->frame_control;\n\n\tif (rx->sta) {\n\t\tint keyid = rx->sta->ptk_idx;\n\t\tsta_ptk = rcu_dereference(rx->sta->ptk[keyid]);\n\n\t\tif (ieee80211_has_protected(fc)) {\n\t\t\tcs = rx->sta->cipher_scheme;\n\t\t\tkeyid = ieee80211_get_keyid(rx->skb, cs);\n\n\t\t\tif (unlikely(keyid < 0))\n\t\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\t\tptk_idx = rcu_dereference(rx->sta->ptk[keyid]);\n\t\t}\n\t}\n\n\tif (!ieee80211_has_protected(fc))\n\t\tmmie_keyidx = ieee80211_get_mmie_keyidx(rx->skb);\n\n\tif (!is_multicast_ether_addr(hdr->addr1) && sta_ptk) {\n\t\trx->key = ptk_idx ? ptk_idx : sta_ptk;\n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\t\t/* Skip decryption if the frame is not protected. */\n\t\tif (!ieee80211_has_protected(fc))\n\t\t\treturn RX_CONTINUE;\n\t} else if (mmie_keyidx >= 0 && ieee80211_is_beacon(fc)) {\n\t\t/* Broadcast/multicast robust management frame / BIP */\n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\n\t\tif (mmie_keyidx < NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS ||\n\t\t    mmie_keyidx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS +\n\t\t    NUM_DEFAULT_BEACON_KEYS) {\n\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t     skb->len);\n\t\t\treturn RX_DROP_MONITOR; /* unexpected BIP keyidx */\n\t\t}\n\n\t\trx->key = ieee80211_rx_get_bigtk(rx, mmie_keyidx);\n\t\tif (!rx->key)\n\t\t\treturn RX_CONTINUE; /* Beacon protection not in use */\n\t} else if (mmie_keyidx >= 0) {\n\t\t/* Broadcast/multicast robust management frame / BIP */\n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\n\t\tif (mmie_keyidx < NUM_DEFAULT_KEYS ||\n\t\t    mmie_keyidx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)\n\t\t\treturn RX_DROP_MONITOR; /* unexpected BIP keyidx */\n\t\tif (rx->sta) {\n\t\t\tif (ieee80211_is_group_privacy_action(skb) &&\n\t\t\t    test_sta_flag(rx->sta, WLAN_STA_MFP))\n\t\t\t\treturn RX_DROP_MONITOR;\n\n\t\t\trx->key = rcu_dereference(rx->sta->gtk[mmie_keyidx]);\n\t\t}\n\t\tif (!rx->key)\n\t\t\trx->key = rcu_dereference(rx->sdata->keys[mmie_keyidx]);\n\t} else if (!ieee80211_has_protected(fc)) {\n\t\t/*\n\t\t * The frame was not protected, so skip decryption. However, we\n\t\t * need to set rx->key if there is a key that could have been\n\t\t * used so that the frame may be dropped if encryption would\n\t\t * have been expected.\n\t\t */\n\t\tstruct ieee80211_key *key = NULL;\n\t\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\t\tint i;\n\n\t\tif (ieee80211_is_beacon(fc)) {\n\t\t\tkey = ieee80211_rx_get_bigtk(rx, -1);\n\t\t} else if (ieee80211_is_mgmt(fc) &&\n\t\t\t   is_multicast_ether_addr(hdr->addr1)) {\n\t\t\tkey = rcu_dereference(rx->sdata->default_mgmt_key);\n\t\t} else {\n\t\t\tif (rx->sta) {\n\t\t\t\tfor (i = 0; i < NUM_DEFAULT_KEYS; i++) {\n\t\t\t\t\tkey = rcu_dereference(rx->sta->gtk[i]);\n\t\t\t\t\tif (key)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\tfor (i = 0; i < NUM_DEFAULT_KEYS; i++) {\n\t\t\t\t\tkey = rcu_dereference(sdata->keys[i]);\n\t\t\t\t\tif (key)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (key)\n\t\t\trx->key = key;\n\t\treturn RX_CONTINUE;\n\t} else {\n\t\t/*\n\t\t * The device doesn't give us the IV so we won't be\n\t\t * able to look up the key. That's ok though, we\n\t\t * don't need to decrypt the frame, we just won't\n\t\t * be able to keep statistics accurate.\n\t\t * Except for key threshold notifications, should\n\t\t * we somehow allow the driver to tell us which key\n\t\t * the hardware used if this flag is set?\n\t\t */\n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\n\t\tkeyidx = ieee80211_get_keyid(rx->skb, cs);\n\n\t\tif (unlikely(keyidx < 0))\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\t/* check per-station GTK first, if multicast packet */\n\t\tif (is_multicast_ether_addr(hdr->addr1) && rx->sta)\n\t\t\trx->key = rcu_dereference(rx->sta->gtk[keyidx]);\n\n\t\t/* if not found, try default key */\n\t\tif (!rx->key) {\n\t\t\trx->key = rcu_dereference(rx->sdata->keys[keyidx]);\n\n\t\t\t/*\n\t\t\t * RSNA-protected unicast frames should always be\n\t\t\t * sent with pairwise or station-to-station keys,\n\t\t\t * but for WEP we allow using a key index as well.\n\t\t\t */\n\t\t\tif (rx->key &&\n\t\t\t    rx->key->conf.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t\t    rx->key->conf.cipher != WLAN_CIPHER_SUITE_WEP104 &&\n\t\t\t    !is_multicast_ether_addr(hdr->addr1))\n\t\t\t\trx->key = NULL;\n\t\t}\n\t}\n\n\tif (rx->key) {\n\t\tif (unlikely(rx->key->flags & KEY_FLAG_TAINTED))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\t/* TODO: add threshold stuff again */\n\t} else {\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\tswitch (rx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tresult = ieee80211_crypto_wep_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tresult = ieee80211_crypto_tkip_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tresult = ieee80211_crypto_ccmp_decrypt(\n\t\t\trx, IEEE80211_CCMP_MIC_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tresult = ieee80211_crypto_ccmp_decrypt(\n\t\t\trx, IEEE80211_CCMP_256_MIC_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tresult = ieee80211_crypto_aes_cmac_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tresult = ieee80211_crypto_aes_cmac_256_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tresult = ieee80211_crypto_aes_gmac_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tresult = ieee80211_crypto_gcmp_decrypt(rx);\n\t\tbreak;\n\tdefault:\n\t\tresult = ieee80211_crypto_hw_decrypt(rx);\n\t}\n\n\t/* the hdr variable is invalid after the decrypt handlers */\n\n\t/* either the frame has been decrypted or will be dropped */\n\tstatus->flag |= RX_FLAG_DECRYPTED;\n\n\tif (unlikely(ieee80211_is_beacon(fc) && result == RX_DROP_UNUSABLE))\n\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t     skb->data, skb->len);\n\n\treturn result;\n}\n\nstatic inline struct ieee80211_fragment_entry *\nieee80211_reassemble_add(struct ieee80211_sub_if_data *sdata,\n\t\t\t unsigned int frag, unsigned int seq, int rx_queue,\n\t\t\t struct sk_buff **skb)\n{\n\tstruct ieee80211_fragment_entry *entry;\n\n\tentry = &sdata->fragments[sdata->fragment_next++];\n\tif (sdata->fragment_next >= IEEE80211_FRAGMENT_MAX)\n\t\tsdata->fragment_next = 0;\n\n\tif (!skb_queue_empty(&entry->skb_list))\n\t\t__skb_queue_purge(&entry->skb_list);\n\n\t__skb_queue_tail(&entry->skb_list, *skb); /* no need for locking */\n\t*skb = NULL;\n\tentry->first_frag_time = jiffies;\n\tentry->seq = seq;\n\tentry->rx_queue = rx_queue;\n\tentry->last_frag = frag;\n\tentry->check_sequential_pn = false;\n\tentry->extra_len = 0;\n\n\treturn entry;\n}\n\nstatic inline struct ieee80211_fragment_entry *\nieee80211_reassemble_find(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned int frag, unsigned int seq,\n\t\t\t  int rx_queue, struct ieee80211_hdr *hdr)\n{\n\tstruct ieee80211_fragment_entry *entry;\n\tint i, idx;\n\n\tidx = sdata->fragment_next;\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++) {\n\t\tstruct ieee80211_hdr *f_hdr;\n\t\tstruct sk_buff *f_skb;\n\n\t\tidx--;\n\t\tif (idx < 0)\n\t\t\tidx = IEEE80211_FRAGMENT_MAX - 1;\n\n\t\tentry = &sdata->fragments[idx];\n\t\tif (skb_queue_empty(&entry->skb_list) || entry->seq != seq ||\n\t\t    entry->rx_queue != rx_queue ||\n\t\t    entry->last_frag + 1 != frag)\n\t\t\tcontinue;\n\n\t\tf_skb = __skb_peek(&entry->skb_list);\n\t\tf_hdr = (struct ieee80211_hdr *) f_skb->data;\n\n\t\t/*\n\t\t * Check ftype and addresses are equal, else check next fragment\n\t\t */\n\t\tif (((hdr->frame_control ^ f_hdr->frame_control) &\n\t\t     cpu_to_le16(IEEE80211_FCTL_FTYPE)) ||\n\t\t    !ether_addr_equal(hdr->addr1, f_hdr->addr1) ||\n\t\t    !ether_addr_equal(hdr->addr2, f_hdr->addr2))\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, entry->first_frag_time + 2 * HZ)) {\n\t\t\t__skb_queue_purge(&entry->skb_list);\n\t\t\tcontinue;\n\t\t}\n\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_defragment(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu16 sc;\n\t__le16 fc;\n\tunsigned int frag, seq;\n\tstruct ieee80211_fragment_entry *entry;\n\tstruct sk_buff *skb;\n\n\thdr = (struct ieee80211_hdr *)rx->skb->data;\n\tfc = hdr->frame_control;\n\n\tif (ieee80211_is_ctl(fc) || ieee80211_is_ext(fc))\n\t\treturn RX_CONTINUE;\n\n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tfrag = sc & IEEE80211_SCTL_FRAG;\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\tI802_DEBUG_INC(rx->local->dot11MulticastReceivedFrameCount);\n\t\tgoto out_no_led;\n\t}\n\n\tif (likely(!ieee80211_has_morefrags(fc) && frag == 0))\n\t\tgoto out;\n\n\tI802_DEBUG_INC(rx->local->rx_handlers_fragments);\n\n\tif (skb_linearize(rx->skb))\n\t\treturn RX_DROP_UNUSABLE;\n\n\t/*\n\t *  skb_linearize() might change the skb->data and\n\t *  previously cached variables (in this case, hdr) need to\n\t *  be refreshed with the new data.\n\t */\n\thdr = (struct ieee80211_hdr *)rx->skb->data;\n\tseq = (sc & IEEE80211_SCTL_SEQ) >> 4;\n\n\tif (frag == 0) {\n\t\t/* This is the first fragment of a new frame. */\n\t\tentry = ieee80211_reassemble_add(rx->sdata, frag, seq,\n\t\t\t\t\t\t rx->seqno_idx, &(rx->skb));\n\t\tif (rx->key &&\n\t\t    (rx->key->conf.cipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\t     rx->key->conf.cipher == WLAN_CIPHER_SUITE_CCMP_256 ||\n\t\t     rx->key->conf.cipher == WLAN_CIPHER_SUITE_GCMP ||\n\t\t     rx->key->conf.cipher == WLAN_CIPHER_SUITE_GCMP_256) &&\n\t\t    ieee80211_has_protected(fc)) {\n\t\t\tint queue = rx->security_idx;\n\n\t\t\t/* Store CCMP/GCMP PN so that we can verify that the\n\t\t\t * next fragment has a sequential PN value.\n\t\t\t */\n\t\t\tentry->check_sequential_pn = true;\n\t\t\tmemcpy(entry->last_pn,\n\t\t\t       rx->key->u.ccmp.rx_pn[queue],\n\t\t\t       IEEE80211_CCMP_PN_LEN);\n\t\t\tBUILD_BUG_ON(offsetof(struct ieee80211_key,\n\t\t\t\t\t      u.ccmp.rx_pn) !=\n\t\t\t\t     offsetof(struct ieee80211_key,\n\t\t\t\t\t      u.gcmp.rx_pn));\n\t\t\tBUILD_BUG_ON(sizeof(rx->key->u.ccmp.rx_pn[queue]) !=\n\t\t\t\t     sizeof(rx->key->u.gcmp.rx_pn[queue]));\n\t\t\tBUILD_BUG_ON(IEEE80211_CCMP_PN_LEN !=\n\t\t\t\t     IEEE80211_GCMP_PN_LEN);\n\t\t}\n\t\treturn RX_QUEUED;\n\t}\n\n\t/* This is a fragment for a frame that should already be pending in\n\t * fragment cache. Add this fragment to the end of the pending entry.\n\t */\n\tentry = ieee80211_reassemble_find(rx->sdata, frag, seq,\n\t\t\t\t\t  rx->seqno_idx, hdr);\n\tif (!entry) {\n\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_defrag);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\t/* \"The receiver shall discard MSDUs and MMPDUs whose constituent\n\t *  MPDU PN values are not incrementing in steps of 1.\"\n\t * see IEEE P802.11-REVmc/D5.0, 12.5.3.4.4, item d (for CCMP)\n\t * and IEEE P802.11-REVmc/D5.0, 12.5.5.4.4, item d (for GCMP)\n\t */\n\tif (entry->check_sequential_pn) {\n\t\tint i;\n\t\tu8 pn[IEEE80211_CCMP_PN_LEN], *rpn;\n\t\tint queue;\n\n\t\tif (!rx->key ||\n\t\t    (rx->key->conf.cipher != WLAN_CIPHER_SUITE_CCMP &&\n\t\t     rx->key->conf.cipher != WLAN_CIPHER_SUITE_CCMP_256 &&\n\t\t     rx->key->conf.cipher != WLAN_CIPHER_SUITE_GCMP &&\n\t\t     rx->key->conf.cipher != WLAN_CIPHER_SUITE_GCMP_256))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tmemcpy(pn, entry->last_pn, IEEE80211_CCMP_PN_LEN);\n\t\tfor (i = IEEE80211_CCMP_PN_LEN - 1; i >= 0; i--) {\n\t\t\tpn[i]++;\n\t\t\tif (pn[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tqueue = rx->security_idx;\n\t\trpn = rx->key->u.ccmp.rx_pn[queue];\n\t\tif (memcmp(pn, rpn, IEEE80211_CCMP_PN_LEN))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tmemcpy(entry->last_pn, pn, IEEE80211_CCMP_PN_LEN);\n\t}\n\n\tskb_pull(rx->skb, ieee80211_hdrlen(fc));\n\t__skb_queue_tail(&entry->skb_list, rx->skb);\n\tentry->last_frag = frag;\n\tentry->extra_len += rx->skb->len;\n\tif (ieee80211_has_morefrags(fc)) {\n\t\trx->skb = NULL;\n\t\treturn RX_QUEUED;\n\t}\n\n\trx->skb = __skb_dequeue(&entry->skb_list);\n\tif (skb_tailroom(rx->skb) < entry->extra_len) {\n\t\tI802_DEBUG_INC(rx->local->rx_expand_skb_head_defrag);\n\t\tif (unlikely(pskb_expand_head(rx->skb, 0, entry->extra_len,\n\t\t\t\t\t      GFP_ATOMIC))) {\n\t\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_defrag);\n\t\t\t__skb_queue_purge(&entry->skb_list);\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\t}\n\t}\n\twhile ((skb = __skb_dequeue(&entry->skb_list))) {\n\t\tskb_put_data(rx->skb, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t}\n\n out:\n\tieee80211_led_rx(rx->local);\n out_no_led:\n\tif (rx->sta)\n\t\trx->sta->rx_stats.packets++;\n\treturn RX_CONTINUE;\n}\n\nstatic int ieee80211_802_1x_port_control(struct ieee80211_rx_data *rx)\n{\n\tif (unlikely(!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_AUTHORIZED)))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int ieee80211_drop_unencrypted(struct ieee80211_rx_data *rx, __le16 fc)\n{\n\tstruct ieee80211_hdr *hdr = (void *)rx->skb->data;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\n\t/*\n\t * Pass through unencrypted frames if the hardware has\n\t * decrypted them already.\n\t */\n\tif (status->flag & RX_FLAG_DECRYPTED)\n\t\treturn 0;\n\n\t/* check mesh EAPOL frames first */\n\tif (unlikely(rx->sta && ieee80211_vif_is_mesh(&rx->sdata->vif) &&\n\t\t     ieee80211_is_data(fc))) {\n\t\tstruct ieee80211s_hdr *mesh_hdr;\n\t\tu16 hdr_len = ieee80211_hdrlen(fc);\n\t\tu16 ethertype_offset;\n\t\t__be16 ethertype;\n\n\t\tif (!ether_addr_equal(hdr->addr1, rx->sdata->vif.addr))\n\t\t\tgoto drop_check;\n\n\t\t/* make sure fixed part of mesh header is there, also checks skb len */\n\t\tif (!pskb_may_pull(rx->skb, hdr_len + 6))\n\t\t\tgoto drop_check;\n\n\t\tmesh_hdr = (struct ieee80211s_hdr *)(skb->data + hdr_len);\n\t\tethertype_offset = hdr_len + ieee80211_get_mesh_hdrlen(mesh_hdr) +\n\t\t\t\t   sizeof(rfc1042_header);\n\n\t\tif (skb_copy_bits(rx->skb, ethertype_offset, &ethertype, 2) == 0 &&\n\t\t    ethertype == rx->sdata->control_port_protocol)\n\t\t\treturn 0;\n\t}\n\ndrop_check:\n\t/* Drop unencrypted frames if key is set. */\n\tif (unlikely(!ieee80211_has_protected(fc) &&\n\t\t     !ieee80211_is_any_nullfunc(fc) &&\n\t\t     ieee80211_is_data(fc) && rx->key))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int ieee80211_drop_unencrypted_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\t__le16 fc = hdr->frame_control;\n\n\t/*\n\t * Pass through unencrypted frames if the hardware has\n\t * decrypted them already.\n\t */\n\tif (status->flag & RX_FLAG_DECRYPTED)\n\t\treturn 0;\n\n\tif (rx->sta && test_sta_flag(rx->sta, WLAN_STA_MFP)) {\n\t\tif (unlikely(!ieee80211_has_protected(fc) &&\n\t\t\t     ieee80211_is_unicast_robust_mgmt_frame(rx->skb) &&\n\t\t\t     rx->key)) {\n\t\t\tif (ieee80211_is_deauth(fc) ||\n\t\t\t    ieee80211_is_disassoc(fc))\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* BIP does not use Protected field, so need to check MMIE */\n\t\tif (unlikely(ieee80211_is_multicast_robust_mgmt_frame(rx->skb) &&\n\t\t\t     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {\n\t\t\tif (ieee80211_is_deauth(fc) ||\n\t\t\t    ieee80211_is_disassoc(fc))\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (unlikely(ieee80211_is_beacon(fc) && rx->key &&\n\t\t\t     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {\n\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/*\n\t\t * When using MFP, Action frames are not allowed prior to\n\t\t * having configured keys.\n\t\t */\n\t\tif (unlikely(ieee80211_is_action(fc) && !rx->key &&\n\t\t\t     ieee80211_is_robust_mgmt_frame(rx->skb)))\n\t\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__ieee80211_data_to_8023(struct ieee80211_rx_data *rx, bool *port_control)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tbool check_port_control = false;\n\tstruct ethhdr *ehdr;\n\tint ret;\n\n\t*port_control = false;\n\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && !sdata->u.vlan.sta)\n\t\treturn -1;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !!sdata->u.mgd.use_4addr != !!ieee80211_has_a4(hdr->frame_control)) {\n\n\t\tif (!sdata->u.mgd.use_4addr)\n\t\t\treturn -1;\n\t\telse if (!ether_addr_equal(hdr->addr1, sdata->vif.addr))\n\t\t\tcheck_port_control = true;\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && sdata->u.vlan.sta)\n\t\treturn -1;\n\n\tret = ieee80211_data_to_8023(rx->skb, sdata->vif.addr, sdata->vif.type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tehdr = (struct ethhdr *) rx->skb->data;\n\tif (ehdr->h_proto == rx->sdata->control_port_protocol)\n\t\t*port_control = true;\n\telse if (check_port_control)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * requires that rx->skb is a frame with ethernet header\n */\nstatic bool ieee80211_frame_allowed(struct ieee80211_rx_data *rx, __le16 fc)\n{\n\tstatic const u8 pae_group_addr[ETH_ALEN] __aligned(2)\n\t\t= { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };\n\tstruct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;\n\n\t/*\n\t * Allow EAPOL frames to us/the PAE group address regardless\n\t * of whether the frame was encrypted or not.\n\t */\n\tif (ehdr->h_proto == rx->sdata->control_port_protocol &&\n\t    (ether_addr_equal(ehdr->h_dest, rx->sdata->vif.addr) ||\n\t     ether_addr_equal(ehdr->h_dest, pae_group_addr)))\n\t\treturn true;\n\n\tif (ieee80211_802_1x_port_control(rx) ||\n\t    ieee80211_drop_unencrypted(rx, fc))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ieee80211_deliver_skb_to_local_stack(struct sk_buff *skb,\n\t\t\t\t\t\t struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct net_device *dev = sdata->dev;\n\n\tif (unlikely((skb->protocol == sdata->control_port_protocol ||\n\t\t     (skb->protocol == cpu_to_be16(ETH_P_PREAUTH) &&\n\t\t      !sdata->control_port_no_preauth)) &&\n\t\t     sdata->control_port_over_nl80211)) {\n\t\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\t\tbool noencrypt = !(status->flag & RX_FLAG_DECRYPTED);\n\n\t\tcfg80211_rx_control_port(dev, skb, noencrypt);\n\t\tdev_kfree_skb(skb);\n\t} else {\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\t\t/* deliver to local stack */\n\t\tif (rx->list)\n\t\t\tlist_add_tail(&skb->list, rx->list);\n\t\telse\n\t\t\tnetif_receive_skb(skb);\n\t}\n}\n\n/*\n * requires that rx->skb is a frame with ethernet header\n */\nstatic void\nieee80211_deliver_skb(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct net_device *dev = sdata->dev;\n\tstruct sk_buff *skb, *xmit_skb;\n\tstruct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;\n\tstruct sta_info *dsta;\n\n\tskb = rx->skb;\n\txmit_skb = NULL;\n\n\tieee80211_rx_stats(dev, skb->len);\n\n\tif (rx->sta) {\n\t\t/* The seqno index has the same property as needed\n\t\t * for the rx_msdu field, i.e. it is IEEE80211_NUM_TIDS\n\t\t * for non-QoS-data frames. Here we know it's a data\n\t\t * frame, so count MSDUs.\n\t\t */\n\t\tu64_stats_update_begin(&rx->sta->rx_stats.syncp);\n\t\trx->sta->rx_stats.msdu[rx->seqno_idx]++;\n\t\tu64_stats_update_end(&rx->sta->rx_stats.syncp);\n\t}\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    !(sdata->flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS) &&\n\t    (sdata->vif.type != NL80211_IFTYPE_AP_VLAN || !sdata->u.vlan.sta)) {\n\t\tif (is_multicast_ether_addr(ehdr->h_dest) &&\n\t\t    ieee80211_vif_get_num_mcast_if(sdata) != 0) {\n\t\t\t/*\n\t\t\t * send multicast frames both to higher layers in\n\t\t\t * local net stack and back to the wireless medium\n\t\t\t */\n\t\t\txmit_skb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!xmit_skb)\n\t\t\t\tnet_info_ratelimited(\"%s: failed to clone multicast frame\\n\",\n\t\t\t\t\t\t    dev->name);\n\t\t} else if (!is_multicast_ether_addr(ehdr->h_dest) &&\n\t\t\t   !ether_addr_equal(ehdr->h_dest, ehdr->h_source)) {\n\t\t\tdsta = sta_info_get(sdata, ehdr->h_dest);\n\t\t\tif (dsta) {\n\t\t\t\t/*\n\t\t\t\t * The destination station is associated to\n\t\t\t\t * this AP (in this VLAN), so send the frame\n\t\t\t\t * directly to it and do not pass it to local\n\t\t\t\t * net stack.\n\t\t\t\t */\n\t\t\t\txmit_skb = skb;\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (skb) {\n\t\t/* 'align' will only take the values 0 or 2 here since all\n\t\t * frames are required to be aligned to 2-byte boundaries\n\t\t * when being passed to mac80211; the code here works just\n\t\t * as well if that isn't true, but mac80211 assumes it can\n\t\t * access fields as 2-byte aligned (e.g. for ether_addr_equal)\n\t\t */\n\t\tint align;\n\n\t\talign = (unsigned long)(skb->data + sizeof(struct ethhdr)) & 3;\n\t\tif (align) {\n\t\t\tif (WARN_ON(skb_headroom(skb) < 3)) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\tu8 *data = skb->data;\n\t\t\t\tsize_t len = skb_headlen(skb);\n\t\t\t\tskb->data -= align;\n\t\t\t\tmemmove(skb->data, data, len);\n\t\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tieee80211_deliver_skb_to_local_stack(skb, rx);\n\t}\n\n\tif (xmit_skb) {\n\t\t/*\n\t\t * Send to wireless media and increase priority by 256 to\n\t\t * keep the received priority instead of reclassifying\n\t\t * the frame (see cfg80211_classify8021d).\n\t\t */\n\t\txmit_skb->priority += 256;\n\t\txmit_skb->protocol = htons(ETH_P_802_3);\n\t\tskb_reset_network_header(xmit_skb);\n\t\tskb_reset_mac_header(xmit_skb);\n\t\tdev_queue_xmit(xmit_skb);\n\t}\n}\n\nstatic ieee80211_rx_result debug_noinline\n__ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx, u8 data_offset)\n{\n\tstruct net_device *dev = rx->sdata->dev;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tstruct sk_buff_head frame_list;\n\tstruct ethhdr ethhdr;\n\tconst u8 *check_da = ethhdr.h_dest, *check_sa = ethhdr.h_source;\n\n\tif (unlikely(ieee80211_has_a4(hdr->frame_control))) {\n\t\tcheck_da = NULL;\n\t\tcheck_sa = NULL;\n\t} else switch (rx->sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\tcheck_da = NULL;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!rx->sta ||\n\t\t\t    !test_sta_flag(rx->sta, WLAN_STA_TDLS_PEER))\n\t\t\t\tcheck_sa = NULL;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tcheck_sa = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tskb->dev = dev;\n\t__skb_queue_head_init(&frame_list);\n\n\tif (ieee80211_data_to_8023_exthdr(skb, &ethhdr,\n\t\t\t\t\t  rx->sdata->vif.addr,\n\t\t\t\t\t  rx->sdata->vif.type,\n\t\t\t\t\t  data_offset))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,\n\t\t\t\t rx->sdata->vif.type,\n\t\t\t\t rx->local->hw.extra_tx_headroom,\n\t\t\t\t check_da, check_sa);\n\n\twhile (!skb_queue_empty(&frame_list)) {\n\t\trx->skb = __skb_dequeue(&frame_list);\n\n\t\tif (!ieee80211_frame_allowed(rx, fc)) {\n\t\t\tdev_kfree_skb(rx->skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tieee80211_deliver_skb(rx);\n\t}\n\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\tif (!(status->rx_flags & IEEE80211_RX_AMSDU))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data(fc)))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data_present(fc)))\n\t\treturn RX_DROP_MONITOR;\n\n\tif (unlikely(ieee80211_has_a4(hdr->frame_control))) {\n\t\tswitch (rx->sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\tif (!rx->sdata->u.vlan.sta)\n\t\t\t\treturn RX_DROP_UNUSABLE;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!rx->sdata->u.mgd.use_4addr)\n\t\t\t\treturn RX_DROP_UNUSABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn RX_DROP_UNUSABLE;\n\n\treturn __ieee80211_rx_h_amsdu(rx, 0);\n}\n\n#ifdef CONFIG_MAC80211_MESH\nstatic ieee80211_rx_result\nieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *fwd_hdr, *hdr;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211s_hdr *mesh_hdr;\n\tstruct sk_buff *skb = rx->skb, *fwd_skb;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu16 ac, q, hdrlen;\n\tint tailroom = 0;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t/* make sure fixed part of mesh header is there, also checks skb len */\n\tif (!pskb_may_pull(rx->skb, hdrlen + 6))\n\t\treturn RX_DROP_MONITOR;\n\n\tmesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);\n\n\t/* make sure full mesh header is there, also checks skb len */\n\tif (!pskb_may_pull(rx->skb,\n\t\t\t   hdrlen + ieee80211_get_mesh_hdrlen(mesh_hdr)))\n\t\treturn RX_DROP_MONITOR;\n\n\t/* reload pointers */\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmesh_hdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);\n\n\tif (ieee80211_drop_unencrypted(rx, hdr->frame_control))\n\t\treturn RX_DROP_MONITOR;\n\n\t/* frame is in RMC, don't forward */\n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    is_multicast_ether_addr(hdr->addr1) &&\n\t    mesh_rmc_check(rx->sdata, hdr->addr3, mesh_hdr))\n\t\treturn RX_DROP_MONITOR;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (!mesh_hdr->ttl)\n\t\treturn RX_DROP_MONITOR;\n\n\tif (mesh_hdr->flags & MESH_FLAGS_AE) {\n\t\tstruct mesh_path *mppath;\n\t\tchar *proxied_addr;\n\t\tchar *mpp_addr;\n\n\t\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\tmpp_addr = hdr->addr3;\n\t\t\tproxied_addr = mesh_hdr->eaddr1;\n\t\t} else if ((mesh_hdr->flags & MESH_FLAGS_AE) ==\n\t\t\t    MESH_FLAGS_AE_A5_A6) {\n\t\t\t/* has_a4 already checked in ieee80211_rx_mesh_check */\n\t\t\tmpp_addr = hdr->addr4;\n\t\t\tproxied_addr = mesh_hdr->eaddr2;\n\t\t} else {\n\t\t\treturn RX_DROP_MONITOR;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tmppath = mpp_path_lookup(sdata, proxied_addr);\n\t\tif (!mppath) {\n\t\t\tmpp_path_add(sdata, proxied_addr, mpp_addr);\n\t\t} else {\n\t\t\tspin_lock_bh(&mppath->state_lock);\n\t\t\tif (!ether_addr_equal(mppath->mpp, mpp_addr))\n\t\t\t\tmemcpy(mppath->mpp, mpp_addr, ETH_ALEN);\n\t\t\tmppath->exp_time = jiffies;\n\t\t\tspin_unlock_bh(&mppath->state_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* Frame has reached destination.  Don't forward */\n\tif (!is_multicast_ether_addr(hdr->addr1) &&\n\t    ether_addr_equal(sdata->vif.addr, hdr->addr3))\n\t\treturn RX_CONTINUE;\n\n\tac = ieee80211_select_queue_80211(sdata, skb, hdr);\n\tq = sdata->vif.hw_queue[ac];\n\tif (ieee80211_queue_stopped(&local->hw, q)) {\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_congestion);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\tskb_set_queue_mapping(skb, q);\n\n\tif (!--mesh_hdr->ttl) {\n\t\tif (!is_multicast_ether_addr(hdr->addr1))\n\t\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh,\n\t\t\t\t\t\t     dropped_frames_ttl);\n\t\tgoto out;\n\t}\n\n\tif (!ifmsh->mshcfg.dot11MeshForwarding)\n\t\tgoto out;\n\n\tif (sdata->crypto_tx_tailroom_needed_cnt)\n\t\ttailroom = IEEE80211_ENCRYPT_TAILROOM;\n\n\tfwd_skb = skb_copy_expand(skb, local->tx_headroom +\n\t\t\t\t       sdata->encrypt_headroom,\n\t\t\t\t  tailroom, GFP_ATOMIC);\n\tif (!fwd_skb)\n\t\tgoto out;\n\n\tfwd_hdr =  (struct ieee80211_hdr *) fwd_skb->data;\n\tfwd_hdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_RETRY);\n\tinfo = IEEE80211_SKB_CB(fwd_skb);\n\tmemset(info, 0, sizeof(*info));\n\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\tinfo->control.vif = &rx->sdata->vif;\n\tinfo->control.jiffies = jiffies;\n\tif (is_multicast_ether_addr(fwd_hdr->addr1)) {\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_mcast);\n\t\tmemcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t/* update power mode indication when forwarding */\n\t\tieee80211_mps_set_frame_flags(sdata, NULL, fwd_hdr);\n\t} else if (!mesh_nexthop_lookup(sdata, fwd_skb)) {\n\t\t/* mesh power mode flags updated in mesh_nexthop_lookup */\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);\n\t} else {\n\t\t/* unable to resolve next hop */\n\t\tmesh_path_error_tx(sdata, ifmsh->mshcfg.element_ttl,\n\t\t\t\t   fwd_hdr->addr3, 0,\n\t\t\t\t   WLAN_REASON_MESH_PATH_NOFORWARD,\n\t\t\t\t   fwd_hdr->addr2);\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_no_route);\n\t\tkfree_skb(fwd_skb);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);\n\tieee80211_add_pending_skb(local, fwd_skb);\n out:\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn RX_CONTINUE;\n\treturn RX_DROP_MONITOR;\n}\n#endif\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_data(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct net_device *dev = sdata->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\t__le16 fc = hdr->frame_control;\n\tbool port_control;\n\tint err;\n\n\tif (unlikely(!ieee80211_is_data(hdr->frame_control)))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn RX_DROP_MONITOR;\n\n\t/*\n\t * Send unexpected-4addr-frame event to hostapd. For older versions,\n\t * also drop the frame to cooked monitor interfaces.\n\t */\n\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tif (rx->sta &&\n\t\t    !test_and_set_sta_flag(rx->sta, WLAN_STA_4ADDR_EVENT))\n\t\t\tcfg80211_rx_unexpected_4addr_frame(\n\t\t\t\trx->sdata->dev, rx->sta->sta.addr, GFP_ATOMIC);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\terr = __ieee80211_data_to_8023(rx, &port_control);\n\tif (unlikely(err))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (!ieee80211_frame_allowed(rx, fc))\n\t\treturn RX_DROP_MONITOR;\n\n\t/* directly handle TDLS channel switch requests/responses */\n\tif (unlikely(((struct ethhdr *)rx->skb->data)->h_proto ==\n\t\t\t\t\t\tcpu_to_be16(ETH_P_TDLS))) {\n\t\tstruct ieee80211_tdls_data *tf = (void *)rx->skb->data;\n\n\t\tif (pskb_may_pull(rx->skb,\n\t\t\t\t  offsetof(struct ieee80211_tdls_data, u)) &&\n\t\t    tf->payload_type == WLAN_TDLS_SNAP_RFTYPE &&\n\t\t    tf->category == WLAN_CATEGORY_TDLS &&\n\t\t    (tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST ||\n\t\t     tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_RESPONSE)) {\n\t\t\tskb_queue_tail(&local->skb_queue_tdls_chsw, rx->skb);\n\t\t\tschedule_work(&local->tdls_chsw_work);\n\t\t\tif (rx->sta)\n\t\t\t\trx->sta->rx_stats.packets++;\n\n\t\t\treturn RX_QUEUED;\n\t\t}\n\t}\n\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    unlikely(port_control) && sdata->bss) {\n\t\tsdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t     u.ap);\n\t\tdev = sdata->dev;\n\t\trx->sdata = sdata;\n\t}\n\n\trx->skb->dev = dev;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS) &&\n\t    local->ps_sdata && local->hw.conf.dynamic_ps_timeout > 0 &&\n\t    !is_multicast_ether_addr(\n\t\t    ((struct ethhdr *)rx->skb->data)->h_dest) &&\n\t    (!local->scanning &&\n\t     !test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state)))\n\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\tieee80211_deliver_skb(rx);\n\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tu16 start_seq_num;\n\tu16 tid;\n\n\tif (likely(!ieee80211_is_ctl(bar->frame_control)))\n\t\treturn RX_CONTINUE;\n\n\tif (ieee80211_is_back_req(bar->frame_control)) {\n\t\tstruct {\n\t\t\t__le16 control, start_seq_num;\n\t\t} __packed bar_data;\n\t\tstruct ieee80211_event event = {\n\t\t\t.type = BAR_RX_EVENT,\n\t\t};\n\n\t\tif (!rx->sta)\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\tif (skb_copy_bits(skb, offsetof(struct ieee80211_bar, control),\n\t\t\t\t  &bar_data, sizeof(bar_data)))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\ttid = le16_to_cpu(bar_data.control) >> 12;\n\n\t\tif (!test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&\n\t\t    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))\n\t\t\tieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,\n\t\t\t\t\t     WLAN_BACK_RECIPIENT,\n\t\t\t\t\t     WLAN_REASON_QSTA_REQUIRE_SETUP);\n\n\t\ttid_agg_rx = rcu_dereference(rx->sta->ampdu_mlme.tid_rx[tid]);\n\t\tif (!tid_agg_rx)\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\tstart_seq_num = le16_to_cpu(bar_data.start_seq_num) >> 4;\n\t\tevent.u.ba.tid = tid;\n\t\tevent.u.ba.ssn = start_seq_num;\n\t\tevent.u.ba.sta = &rx->sta->sta;\n\n\t\t/* reset session timer */\n\t\tif (tid_agg_rx->timeout)\n\t\t\tmod_timer(&tid_agg_rx->session_timer,\n\t\t\t\t  TU_TO_EXP_TIME(tid_agg_rx->timeout));\n\n\t\tspin_lock(&tid_agg_rx->reorder_lock);\n\t\t/* release stored frames up to start of BAR */\n\t\tieee80211_release_reorder_frames(rx->sdata, tid_agg_rx,\n\t\t\t\t\t\t start_seq_num, frames);\n\t\tspin_unlock(&tid_agg_rx->reorder_lock);\n\n\t\tdrv_event_callback(rx->local, rx->sdata, &event);\n\n\t\tkfree_skb(skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\t/*\n\t * After this point, we only want management frames,\n\t * so we can drop all remaining control frames to\n\t * cooked monitor interfaces.\n\t */\n\treturn RX_DROP_MONITOR;\n}\n\nstatic void ieee80211_process_sa_query_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_mgmt *mgmt,\n\t\t\t\t\t   size_t len)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *resp;\n\n\tif (!ether_addr_equal(mgmt->da, sdata->vif.addr)) {\n\t\t/* Not to own unicast address */\n\t\treturn;\n\t}\n\n\tif (!ether_addr_equal(mgmt->sa, sdata->u.mgd.bssid) ||\n\t    !ether_addr_equal(mgmt->bssid, sdata->u.mgd.bssid)) {\n\t\t/* Not from the current AP or not associated yet. */\n\t\treturn;\n\t}\n\n\tif (len < 24 + 1 + sizeof(resp->u.action.u.sa_query)) {\n\t\t/* Too short SA Query request frame */\n\t\treturn;\n\t}\n\n\tskb = dev_alloc_skb(sizeof(*resp) + local->hw.extra_tx_headroom);\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tresp = skb_put_zero(skb, 24);\n\tmemcpy(resp->da, mgmt->sa, ETH_ALEN);\n\tmemcpy(resp->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(resp->bssid, sdata->u.mgd.bssid, ETH_ALEN);\n\tresp->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\tskb_put(skb, 1 + sizeof(resp->u.action.u.sa_query));\n\tresp->u.action.category = WLAN_CATEGORY_SA_QUERY;\n\tresp->u.action.u.sa_query.action = WLAN_ACTION_SA_QUERY_RESPONSE;\n\tmemcpy(resp->u.action.u.sa_query.trans_id,\n\t       mgmt->u.action.u.sa_query.trans_id,\n\t       WLAN_SA_QUERY_TR_ID_LEN);\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_mgmt_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * From here on, look only at management frames.\n\t * Data and control frames are already handled,\n\t * and unknown (reserved) frames are useless.\n\t */\n\tif (rx->skb->len < 24)\n\t\treturn RX_DROP_MONITOR;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control))\n\t\treturn RX_DROP_MONITOR;\n\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t    ieee80211_is_beacon(mgmt->frame_control) &&\n\t    !(rx->flags & IEEE80211_RX_BEACON_REPORTED)) {\n\t\tint sig = 0;\n\n\t\tif (ieee80211_hw_check(&rx->local->hw, SIGNAL_DBM) &&\n\t\t    !(status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\t\tsig = status->signal;\n\n\t\tcfg80211_report_obss_beacon_khz(rx->local->hw.wiphy,\n\t\t\t\t\t\trx->skb->data, rx->skb->len,\n\t\t\t\t\t\tieee80211_rx_status_to_khz(status),\n\t\t\t\t\t\tsig);\n\t\trx->flags |= IEEE80211_RX_BEACON_REPORTED;\n\t}\n\n\tif (ieee80211_drop_unencrypted_mgmt(rx))\n\t\treturn RX_DROP_UNUSABLE;\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_action(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tint len = rx->skb->len;\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t/* drop too small frames */\n\tif (len < IEEE80211_MIN_ACTION_SIZE)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (!rx->sta && mgmt->u.action.category != WLAN_CATEGORY_PUBLIC &&\n\t    mgmt->u.action.category != WLAN_CATEGORY_SELF_PROTECTED &&\n\t    mgmt->u.action.category != WLAN_CATEGORY_SPECTRUM_MGMT)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tswitch (mgmt->u.action.category) {\n\tcase WLAN_CATEGORY_HT:\n\t\t/* reject HT action frames from stations not supporting HT */\n\t\tif (!rx->sta->sta.ht_cap.ht_supported)\n\t\t\tgoto invalid;\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tbreak;\n\n\t\t/* verify action & smps_control/chanwidth are present */\n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 2)\n\t\t\tgoto invalid;\n\n\t\tswitch (mgmt->u.action.u.ht_smps.action) {\n\t\tcase WLAN_HT_ACTION_SMPS: {\n\t\t\tstruct ieee80211_supported_band *sband;\n\t\t\tenum ieee80211_smps_mode smps_mode;\n\t\t\tstruct sta_opmode_info sta_opmode = {};\n\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN)\n\t\t\t\tgoto handled;\n\n\t\t\t/* convert to HT capability */\n\t\t\tswitch (mgmt->u.action.u.ht_smps.smps_control) {\n\t\t\tcase WLAN_HT_SMPS_CONTROL_DISABLED:\n\t\t\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\t\t\t\tbreak;\n\t\t\tcase WLAN_HT_SMPS_CONTROL_STATIC:\n\t\t\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\t\t\t\tbreak;\n\t\t\tcase WLAN_HT_SMPS_CONTROL_DYNAMIC:\n\t\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto invalid;\n\t\t\t}\n\n\t\t\t/* if no change do nothing */\n\t\t\tif (rx->sta->sta.smps_mode == smps_mode)\n\t\t\t\tgoto handled;\n\t\t\trx->sta->sta.smps_mode = smps_mode;\n\t\t\tsta_opmode.smps_mode =\n\t\t\t\tieee80211_smps_mode_to_smps_mode(smps_mode);\n\t\t\tsta_opmode.changed = STA_OPMODE_SMPS_MODE_CHANGED;\n\n\t\t\tsband = rx->local->hw.wiphy->bands[status->band];\n\n\t\t\trate_control_rate_update(local, sband, rx->sta,\n\t\t\t\t\t\t IEEE80211_RC_SMPS_CHANGED);\n\t\t\tcfg80211_sta_opmode_change_notify(sdata->dev,\n\t\t\t\t\t\t\t  rx->sta->addr,\n\t\t\t\t\t\t\t  &sta_opmode,\n\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tgoto handled;\n\t\t}\n\t\tcase WLAN_HT_ACTION_NOTIFY_CHANWIDTH: {\n\t\t\tstruct ieee80211_supported_band *sband;\n\t\t\tu8 chanwidth = mgmt->u.action.u.ht_notify_cw.chanwidth;\n\t\t\tenum ieee80211_sta_rx_bandwidth max_bw, new_bw;\n\t\t\tstruct sta_opmode_info sta_opmode = {};\n\n\t\t\t/* If it doesn't support 40 MHz it can't change ... */\n\t\t\tif (!(rx->sta->sta.ht_cap.cap &\n\t\t\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\t\t\tgoto handled;\n\n\t\t\tif (chanwidth == IEEE80211_HT_CHANWIDTH_20MHZ)\n\t\t\t\tmax_bw = IEEE80211_STA_RX_BW_20;\n\t\t\telse\n\t\t\t\tmax_bw = ieee80211_sta_cap_rx_bw(rx->sta);\n\n\t\t\t/* set cur_max_bandwidth and recalc sta bw */\n\t\t\trx->sta->cur_max_bandwidth = max_bw;\n\t\t\tnew_bw = ieee80211_sta_cur_vht_bw(rx->sta);\n\n\t\t\tif (rx->sta->sta.bandwidth == new_bw)\n\t\t\t\tgoto handled;\n\n\t\t\trx->sta->sta.bandwidth = new_bw;\n\t\t\tsband = rx->local->hw.wiphy->bands[status->band];\n\t\t\tsta_opmode.bw =\n\t\t\t\tieee80211_sta_rx_bw_to_chan_width(rx->sta);\n\t\t\tsta_opmode.changed = STA_OPMODE_MAX_BW_CHANGED;\n\n\t\t\trate_control_rate_update(local, sband, rx->sta,\n\t\t\t\t\t\t IEEE80211_RC_BW_CHANGED);\n\t\t\tcfg80211_sta_opmode_change_notify(sdata->dev,\n\t\t\t\t\t\t\t  rx->sta->addr,\n\t\t\t\t\t\t\t  &sta_opmode,\n\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tgoto handled;\n\t\t}\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\n\t\tbreak;\n\tcase WLAN_CATEGORY_PUBLIC:\n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tgoto invalid;\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\tbreak;\n\t\tif (!rx->sta)\n\t\t\tbreak;\n\t\tif (!ether_addr_equal(mgmt->bssid, sdata->u.mgd.bssid))\n\t\t\tbreak;\n\t\tif (mgmt->u.action.u.ext_chan_switch.action_code !=\n\t\t\t\tWLAN_PUB_ACTION_EXT_CHANSW_ANN)\n\t\t\tbreak;\n\t\tif (len < offsetof(struct ieee80211_mgmt,\n\t\t\t\t   u.action.u.ext_chan_switch.variable))\n\t\t\tgoto invalid;\n\t\tgoto queue;\n\tcase WLAN_CATEGORY_VHT:\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tbreak;\n\n\t\t/* verify action code is present */\n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tgoto invalid;\n\n\t\tswitch (mgmt->u.action.u.vht_opmode_notif.action_code) {\n\t\tcase WLAN_VHT_ACTION_OPMODE_NOTIF: {\n\t\t\t/* verify opmode is present */\n\t\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 2)\n\t\t\t\tgoto invalid;\n\t\t\tgoto queue;\n\t\t}\n\t\tcase WLAN_VHT_ACTION_GROUPID_MGMT: {\n\t\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 25)\n\t\t\t\tgoto invalid;\n\t\t\tgoto queue;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_BACK:\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tbreak;\n\n\t\t/* verify action_code is present */\n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.addba_req.action_code) {\n\t\tcase WLAN_ACTION_ADDBA_REQ:\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.addba_req)))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase WLAN_ACTION_ADDBA_RESP:\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.addba_resp)))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase WLAN_ACTION_DELBA:\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.delba)))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\n\t\tgoto queue;\n\tcase WLAN_CATEGORY_SPECTRUM_MGMT:\n\t\t/* verify action_code is present */\n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.measurement.action_code) {\n\t\tcase WLAN_ACTION_SPCT_MSR_REQ:\n\t\t\tif (status->band != NL80211_BAND_5GHZ)\n\t\t\t\tbreak;\n\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.measurement)))\n\t\t\t\tbreak;\n\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\t\tbreak;\n\n\t\t\tieee80211_process_measurement_req(sdata, mgmt, len);\n\t\t\tgoto handled;\n\t\tcase WLAN_ACTION_SPCT_CHL_SWITCH: {\n\t\t\tu8 *bssid;\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.chan_switch)))\n\t\t\t\tbreak;\n\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT)\n\t\t\t\tbreak;\n\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\t\tbssid = sdata->u.mgd.bssid;\n\t\t\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\t\tbssid = sdata->u.ibss.bssid;\n\t\t\telse if (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\t\t\tbssid = mgmt->sa;\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t\tif (!ether_addr_equal(mgmt->bssid, bssid))\n\t\t\t\tbreak;\n\n\t\t\tgoto queue;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_SELF_PROTECTED:\n\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t   sizeof(mgmt->u.action.u.self_prot.action_code)))\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.self_prot.action_code) {\n\t\tcase WLAN_SP_MESH_PEERING_OPEN:\n\t\tcase WLAN_SP_MESH_PEERING_CLOSE:\n\t\tcase WLAN_SP_MESH_PEERING_CONFIRM:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tgoto invalid;\n\t\t\tif (sdata->u.mesh.user_mpm)\n\t\t\t\t/* userspace handles this frame */\n\t\t\t\tbreak;\n\t\t\tgoto queue;\n\t\tcase WLAN_SP_MGK_INFORM:\n\t\tcase WLAN_SP_MGK_ACK:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_MESH_ACTION:\n\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t   sizeof(mgmt->u.action.u.mesh_action.action_code)))\n\t\t\tbreak;\n\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tif (mesh_action_is_path_sel(mgmt) &&\n\t\t    !mesh_path_sel_is_hwmp(sdata))\n\t\t\tbreak;\n\t\tgoto queue;\n\t}\n\n\treturn RX_CONTINUE;\n\n invalid:\n\tstatus->rx_flags |= IEEE80211_RX_MALFORMED_ACTION_FRM;\n\t/* will return in the next handlers */\n\treturn RX_CONTINUE;\n\n handled:\n\tif (rx->sta)\n\t\trx->sta->rx_stats.packets++;\n\tdev_kfree_skb(rx->skb);\n\treturn RX_QUEUED;\n\n queue:\n\tskb_queue_tail(&sdata->skb_queue, rx->skb);\n\tieee80211_queue_work(&local->hw, &sdata->work);\n\tif (rx->sta)\n\t\trx->sta->rx_stats.packets++;\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_userspace_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tint sig = 0;\n\n\t/* skip known-bad action frames and return them in the next handler */\n\tif (status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM)\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Getting here means the kernel doesn't know how to handle\n\t * it, but maybe userspace does ... include returned frames\n\t * so userspace can register for those to know whether ones\n\t * it transmitted were processed or returned.\n\t */\n\n\tif (ieee80211_hw_check(&rx->local->hw, SIGNAL_DBM) &&\n\t    !(status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\tsig = status->signal;\n\n\tif (cfg80211_rx_mgmt_khz(&rx->sdata->wdev,\n\t\t\t\t ieee80211_rx_status_to_khz(status), sig,\n\t\t\t\t rx->skb->data, rx->skb->len, 0)) {\n\t\tif (rx->sta)\n\t\t\trx->sta->rx_stats.packets++;\n\t\tdev_kfree_skb(rx->skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_action_post_userspace(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tint len = rx->skb->len;\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tswitch (mgmt->u.action.category) {\n\tcase WLAN_CATEGORY_SA_QUERY:\n\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t   sizeof(mgmt->u.action.u.sa_query)))\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.sa_query.action) {\n\t\tcase WLAN_ACTION_SA_QUERY_REQUEST:\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\t\tbreak;\n\t\t\tieee80211_process_sa_query_req(sdata, mgmt, len);\n\t\t\tgoto handled;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn RX_CONTINUE;\n\n handled:\n\tif (rx->sta)\n\t\trx->sta->rx_stats.packets++;\n\tdev_kfree_skb(rx->skb);\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_action_return(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tstruct sk_buff *nskb;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * For AP mode, hostapd is responsible for handling any action\n\t * frames that we didn't handle, including returning unknown\n\t * ones. For all other modes we will return them to the sender,\n\t * setting the 0x80 bit in the action category, as required by\n\t * 802.11-2012 9.24.4.\n\t * Newer versions of hostapd shall also use the management frame\n\t * registration mechanisms, but older ones still use cooked\n\t * monitor interfaces so push all frames there.\n\t */\n\tif (!(status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM) &&\n\t    (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN))\n\t\treturn RX_DROP_MONITOR;\n\n\tif (is_multicast_ether_addr(mgmt->da))\n\t\treturn RX_DROP_MONITOR;\n\n\t/* do not return rejected action frames */\n\tif (mgmt->u.action.category & 0x80)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tnskb = skb_copy_expand(rx->skb, local->hw.extra_tx_headroom, 0,\n\t\t\t       GFP_ATOMIC);\n\tif (nskb) {\n\t\tstruct ieee80211_mgmt *nmgmt = (void *)nskb->data;\n\n\t\tnmgmt->u.action.category |= 0x80;\n\t\tmemcpy(nmgmt->da, nmgmt->sa, ETH_ALEN);\n\t\tmemcpy(nmgmt->sa, rx->sdata->vif.addr, ETH_ALEN);\n\n\t\tmemset(nskb->cb, 0, sizeof(nskb->cb));\n\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(nskb);\n\n\t\t\tinfo->flags = IEEE80211_TX_CTL_TX_OFFCHAN |\n\t\t\t\t      IEEE80211_TX_INTFL_OFFCHAN_TX_OK |\n\t\t\t\t      IEEE80211_TX_CTL_NO_CCK_RATE;\n\t\t\tif (ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\t\t\tinfo->hw_queue =\n\t\t\t\t\tlocal->hw.offchannel_tx_hw_queue;\n\t\t}\n\n\t\t__ieee80211_tx_skb_tid_band(rx->sdata, nskb, 7,\n\t\t\t\t\t    status->band);\n\t}\n\tdev_kfree_skb(rx->skb);\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_ext(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)rx->skb->data;\n\n\tif (!ieee80211_is_ext(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn RX_DROP_MONITOR;\n\n\t/* for now only beacons are ext, so queue them */\n\tskb_queue_tail(&sdata->skb_queue, rx->skb);\n\tieee80211_queue_work(&rx->local->hw, &sdata->work);\n\tif (rx->sta)\n\t\trx->sta->rx_stats.packets++;\n\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_mgmt *mgmt = (void *)rx->skb->data;\n\t__le16 stype;\n\n\tstype = mgmt->frame_control & cpu_to_le16(IEEE80211_FCTL_STYPE);\n\n\tif (!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t    sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t    sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t    sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn RX_DROP_MONITOR;\n\n\tswitch (stype) {\n\tcase cpu_to_le16(IEEE80211_STYPE_AUTH):\n\tcase cpu_to_le16(IEEE80211_STYPE_BEACON):\n\tcase cpu_to_le16(IEEE80211_STYPE_PROBE_RESP):\n\t\t/* process for all: mesh, mlme, ibss */\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_STYPE_DEAUTH):\n\t\tif (is_multicast_ether_addr(mgmt->da) &&\n\t\t    !is_broadcast_ether_addr(mgmt->da))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\t/* process only for station/IBSS */\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\treturn RX_DROP_MONITOR;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP):\n\tcase cpu_to_le16(IEEE80211_STYPE_REASSOC_RESP):\n\tcase cpu_to_le16(IEEE80211_STYPE_DISASSOC):\n\t\tif (is_multicast_ether_addr(mgmt->da) &&\n\t\t    !is_broadcast_ether_addr(mgmt->da))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\t/* process only for station */\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\treturn RX_DROP_MONITOR;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_STYPE_PROBE_REQ):\n\t\t/* process only for ibss and mesh */\n\t\tif (sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn RX_DROP_MONITOR;\n\t\tbreak;\n\tdefault:\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\t/* queue up frame and kick off work to process it */\n\tskb_queue_tail(&sdata->skb_queue, rx->skb);\n\tieee80211_queue_work(&rx->local->hw, &sdata->work);\n\tif (rx->sta)\n\t\trx->sta->rx_stats.packets++;\n\n\treturn RX_QUEUED;\n}\n\nstatic void ieee80211_rx_cooked_monitor(struct ieee80211_rx_data *rx,\n\t\t\t\t\tstruct ieee80211_rate *rate)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct sk_buff *skb = rx->skb, *skb2;\n\tstruct net_device *prev_dev = NULL;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tint needed_headroom;\n\n\t/*\n\t * If cooked monitor has been processed already, then\n\t * don't do it again. If not, set the flag.\n\t */\n\tif (rx->flags & IEEE80211_RX_CMNTR)\n\t\tgoto out_free_skb;\n\trx->flags |= IEEE80211_RX_CMNTR;\n\n\t/* If there are no cooked monitor interfaces, just free the SKB */\n\tif (!local->cooked_mntrs)\n\t\tgoto out_free_skb;\n\n\t/* vendor data is long removed here */\n\tstatus->flag &= ~RX_FLAG_RADIOTAP_VENDOR_DATA;\n\t/* room for the radiotap header based on driver features */\n\tneeded_headroom = ieee80211_rx_radiotap_hdrlen(local, status, skb);\n\n\tif (skb_headroom(skb) < needed_headroom &&\n\t    pskb_expand_head(skb, needed_headroom, 0, GFP_ATOMIC))\n\t\tgoto out_free_skb;\n\n\t/* prepend radiotap information */\n\tieee80211_add_rx_radiotap_header(local, skb, rate, needed_headroom,\n\t\t\t\t\t false);\n\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_MONITOR ||\n\t\t    !(sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES))\n\t\t\tcontinue;\n\n\t\tif (prev_dev) {\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2) {\n\t\t\t\tskb2->dev = prev_dev;\n\t\t\t\tnetif_receive_skb(skb2);\n\t\t\t}\n\t\t}\n\n\t\tprev_dev = sdata->dev;\n\t\tieee80211_rx_stats(sdata->dev, skb->len);\n\t}\n\n\tif (prev_dev) {\n\t\tskb->dev = prev_dev;\n\t\tnetif_receive_skb(skb);\n\t\treturn;\n\t}\n\n out_free_skb:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ieee80211_rx_handlers_result(struct ieee80211_rx_data *rx,\n\t\t\t\t\t ieee80211_rx_result res)\n{\n\tswitch (res) {\n\tcase RX_DROP_MONITOR:\n\t\tI802_DEBUG_INC(rx->sdata->local->rx_handlers_drop);\n\t\tif (rx->sta)\n\t\t\trx->sta->rx_stats.dropped++;\n\t\tfallthrough;\n\tcase RX_CONTINUE: {\n\t\tstruct ieee80211_rate *rate = NULL;\n\t\tstruct ieee80211_supported_band *sband;\n\t\tstruct ieee80211_rx_status *status;\n\n\t\tstatus = IEEE80211_SKB_RXCB((rx->skb));\n\n\t\tsband = rx->local->hw.wiphy->bands[status->band];\n\t\tif (status->encoding == RX_ENC_LEGACY)\n\t\t\trate = &sband->bitrates[status->rate_idx];\n\n\t\tieee80211_rx_cooked_monitor(rx, rate);\n\t\tbreak;\n\t\t}\n\tcase RX_DROP_UNUSABLE:\n\t\tI802_DEBUG_INC(rx->sdata->local->rx_handlers_drop);\n\t\tif (rx->sta)\n\t\t\trx->sta->rx_stats.dropped++;\n\t\tdev_kfree_skb(rx->skb);\n\t\tbreak;\n\tcase RX_QUEUED:\n\t\tI802_DEBUG_INC(rx->sdata->local->rx_handlers_queued);\n\t\tbreak;\n\t}\n}\n\nstatic void ieee80211_rx_handlers(struct ieee80211_rx_data *rx,\n\t\t\t\t  struct sk_buff_head *frames)\n{\n\tieee80211_rx_result res = RX_DROP_MONITOR;\n\tstruct sk_buff *skb;\n\n#define CALL_RXH(rxh)\t\t\t\\\n\tdo {\t\t\t\t\\\n\t\tres = rxh(rx);\t\t\\\n\t\tif (res != RX_CONTINUE)\t\\\n\t\t\tgoto rxh_next;  \\\n\t} while (0)\n\n\t/* Lock here to avoid hitting all of the data used in the RX\n\t * path (e.g. key data, station data, ...) concurrently when\n\t * a frame is released from the reorder buffer due to timeout\n\t * from the timer, potentially concurrently with RX from the\n\t * driver.\n\t */\n\tspin_lock_bh(&rx->local->rx_path_lock);\n\n\twhile ((skb = __skb_dequeue(frames))) {\n\t\t/*\n\t\t * all the other fields are valid across frames\n\t\t * that belong to an aMPDU since they are on the\n\t\t * same TID from the same station\n\t\t */\n\t\trx->skb = skb;\n\n\t\tCALL_RXH(ieee80211_rx_h_check_more_data);\n\t\tCALL_RXH(ieee80211_rx_h_uapsd_and_pspoll);\n\t\tCALL_RXH(ieee80211_rx_h_sta_process);\n\t\tCALL_RXH(ieee80211_rx_h_decrypt);\n\t\tCALL_RXH(ieee80211_rx_h_defragment);\n\t\tCALL_RXH(ieee80211_rx_h_michael_mic_verify);\n\t\t/* must be after MMIC verify so header is counted in MPDU mic */\n#ifdef CONFIG_MAC80211_MESH\n\t\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\t\tCALL_RXH(ieee80211_rx_h_mesh_fwding);\n#endif\n\t\tCALL_RXH(ieee80211_rx_h_amsdu);\n\t\tCALL_RXH(ieee80211_rx_h_data);\n\n\t\t/* special treatment -- needs the queue */\n\t\tres = ieee80211_rx_h_ctrl(rx, frames);\n\t\tif (res != RX_CONTINUE)\n\t\t\tgoto rxh_next;\n\n\t\tCALL_RXH(ieee80211_rx_h_mgmt_check);\n\t\tCALL_RXH(ieee80211_rx_h_action);\n\t\tCALL_RXH(ieee80211_rx_h_userspace_mgmt);\n\t\tCALL_RXH(ieee80211_rx_h_action_post_userspace);\n\t\tCALL_RXH(ieee80211_rx_h_action_return);\n\t\tCALL_RXH(ieee80211_rx_h_ext);\n\t\tCALL_RXH(ieee80211_rx_h_mgmt);\n\n rxh_next:\n\t\tieee80211_rx_handlers_result(rx, res);\n\n#undef CALL_RXH\n\t}\n\n\tspin_unlock_bh(&rx->local->rx_path_lock);\n}\n\nstatic void ieee80211_invoke_rx_handlers(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff_head reorder_release;\n\tieee80211_rx_result res = RX_DROP_MONITOR;\n\n\t__skb_queue_head_init(&reorder_release);\n\n#define CALL_RXH(rxh)\t\t\t\\\n\tdo {\t\t\t\t\\\n\t\tres = rxh(rx);\t\t\\\n\t\tif (res != RX_CONTINUE)\t\\\n\t\t\tgoto rxh_next;  \\\n\t} while (0)\n\n\tCALL_RXH(ieee80211_rx_h_check_dup);\n\tCALL_RXH(ieee80211_rx_h_check);\n\n\tieee80211_rx_reorder_ampdu(rx, &reorder_release);\n\n\tieee80211_rx_handlers(rx, &reorder_release);\n\treturn;\n\n rxh_next:\n\tieee80211_rx_handlers_result(rx, res);\n\n#undef CALL_RXH\n}\n\n/*\n * This function makes calls into the RX path, therefore\n * it has to be invoked under RCU read lock.\n */\nvoid ieee80211_release_reorder_timeout(struct sta_info *sta, int tid)\n{\n\tstruct sk_buff_head frames;\n\tstruct ieee80211_rx_data rx = {\n\t\t.sta = sta,\n\t\t.sdata = sta->sdata,\n\t\t.local = sta->local,\n\t\t/* This is OK -- must be QoS data frame */\n\t\t.security_idx = tid,\n\t\t.seqno_idx = tid,\n\t};\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\n\ttid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\tif (!tid_agg_rx)\n\t\treturn;\n\n\t__skb_queue_head_init(&frames);\n\n\tspin_lock(&tid_agg_rx->reorder_lock);\n\tieee80211_sta_reorder_release(sta->sdata, tid_agg_rx, &frames);\n\tspin_unlock(&tid_agg_rx->reorder_lock);\n\n\tif (!skb_queue_empty(&frames)) {\n\t\tstruct ieee80211_event event = {\n\t\t\t.type = BA_FRAME_TIMEOUT,\n\t\t\t.u.ba.tid = tid,\n\t\t\t.u.ba.sta = &sta->sta,\n\t\t};\n\t\tdrv_event_callback(rx.local, rx.sdata, &event);\n\t}\n\n\tieee80211_rx_handlers(&rx, &frames);\n}\n\nvoid ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t\t  u16 ssn, u64 filtered,\n\t\t\t\t\t  u16 received_mpdus)\n{\n\tstruct sta_info *sta;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tstruct sk_buff_head frames;\n\tstruct ieee80211_rx_data rx = {\n\t\t/* This is OK -- must be QoS data frame */\n\t\t.security_idx = tid,\n\t\t.seqno_idx = tid,\n\t};\n\tint i, diff;\n\n\tif (WARN_ON(!pubsta || tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\n\t__skb_queue_head_init(&frames);\n\n\tsta = container_of(pubsta, struct sta_info, sta);\n\n\trx.sta = sta;\n\trx.sdata = sta->sdata;\n\trx.local = sta->local;\n\n\trcu_read_lock();\n\ttid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\tif (!tid_agg_rx)\n\t\tgoto out;\n\n\tspin_lock_bh(&tid_agg_rx->reorder_lock);\n\n\tif (received_mpdus >= IEEE80211_SN_MODULO >> 1) {\n\t\tint release;\n\n\t\t/* release all frames in the reorder buffer */\n\t\trelease = (tid_agg_rx->head_seq_num + tid_agg_rx->buf_size) %\n\t\t\t   IEEE80211_SN_MODULO;\n\t\tieee80211_release_reorder_frames(sta->sdata, tid_agg_rx,\n\t\t\t\t\t\t release, &frames);\n\t\t/* update ssn to match received ssn */\n\t\ttid_agg_rx->head_seq_num = ssn;\n\t} else {\n\t\tieee80211_release_reorder_frames(sta->sdata, tid_agg_rx, ssn,\n\t\t\t\t\t\t &frames);\n\t}\n\n\t/* handle the case that received ssn is behind the mac ssn.\n\t * it can be tid_agg_rx->buf_size behind and still be valid */\n\tdiff = (tid_agg_rx->head_seq_num - ssn) & IEEE80211_SN_MASK;\n\tif (diff >= tid_agg_rx->buf_size) {\n\t\ttid_agg_rx->reorder_buf_filtered = 0;\n\t\tgoto release;\n\t}\n\tfiltered = filtered >> diff;\n\tssn += diff;\n\n\t/* update bitmap */\n\tfor (i = 0; i < tid_agg_rx->buf_size; i++) {\n\t\tint index = (ssn + i) % tid_agg_rx->buf_size;\n\n\t\ttid_agg_rx->reorder_buf_filtered &= ~BIT_ULL(index);\n\t\tif (filtered & BIT_ULL(i))\n\t\t\ttid_agg_rx->reorder_buf_filtered |= BIT_ULL(index);\n\t}\n\n\t/* now process also frames that the filter marking released */\n\tieee80211_sta_reorder_release(sta->sdata, tid_agg_rx, &frames);\n\nrelease:\n\tspin_unlock_bh(&tid_agg_rx->reorder_lock);\n\n\tieee80211_rx_handlers(&rx, &frames);\n\n out:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_mark_rx_ba_filtered_frames);\n\n/* main receive path */\n\nstatic bool ieee80211_accept_frame(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tu8 *bssid = ieee80211_get_bssid(hdr, skb->len, sdata->vif.type);\n\tbool multicast = is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t ieee80211_is_s1g_beacon(hdr->frame_control);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!bssid && !sdata->u.mgd.use_4addr)\n\t\t\treturn false;\n\t\tif (ieee80211_is_robust_mgmt_frame(skb) && !rx->sta)\n\t\t\treturn false;\n\t\tif (multicast)\n\t\t\treturn true;\n\t\treturn ether_addr_equal(sdata->vif.addr, hdr->addr1);\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!bssid)\n\t\t\treturn false;\n\t\tif (ether_addr_equal(sdata->vif.addr, hdr->addr2) ||\n\t\t    ether_addr_equal(sdata->u.ibss.bssid, hdr->addr2))\n\t\t\treturn false;\n\t\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\t\treturn true;\n\t\tif (!ieee80211_bssid_match(bssid, sdata->u.ibss.bssid))\n\t\t\treturn false;\n\t\tif (!multicast &&\n\t\t    !ether_addr_equal(sdata->vif.addr, hdr->addr1))\n\t\t\treturn false;\n\t\tif (!rx->sta) {\n\t\t\tint rate_idx;\n\t\t\tif (status->encoding != RX_ENC_LEGACY)\n\t\t\t\trate_idx = 0; /* TODO: HT/VHT rates */\n\t\t\telse\n\t\t\t\trate_idx = status->rate_idx;\n\t\t\tieee80211_ibss_rx_no_sta(sdata, bssid, hdr->addr2,\n\t\t\t\t\t\t BIT(rate_idx));\n\t\t}\n\t\treturn true;\n\tcase NL80211_IFTYPE_OCB:\n\t\tif (!bssid)\n\t\t\treturn false;\n\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\treturn false;\n\t\tif (!is_broadcast_ether_addr(bssid))\n\t\t\treturn false;\n\t\tif (!multicast &&\n\t\t    !ether_addr_equal(sdata->dev->dev_addr, hdr->addr1))\n\t\t\treturn false;\n\t\tif (!rx->sta) {\n\t\t\tint rate_idx;\n\t\t\tif (status->encoding != RX_ENC_LEGACY)\n\t\t\t\trate_idx = 0; /* TODO: HT rates */\n\t\t\telse\n\t\t\t\trate_idx = status->rate_idx;\n\t\t\tieee80211_ocb_rx_no_sta(sdata, bssid, hdr->addr2,\n\t\t\t\t\t\tBIT(rate_idx));\n\t\t}\n\t\treturn true;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ether_addr_equal(sdata->vif.addr, hdr->addr2))\n\t\t\treturn false;\n\t\tif (multicast)\n\t\t\treturn true;\n\t\treturn ether_addr_equal(sdata->vif.addr, hdr->addr1);\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!bssid)\n\t\t\treturn ether_addr_equal(sdata->vif.addr, hdr->addr1);\n\n\t\tif (!ieee80211_bssid_match(bssid, sdata->vif.addr)) {\n\t\t\t/*\n\t\t\t * Accept public action frames even when the\n\t\t\t * BSSID doesn't match, this is used for P2P\n\t\t\t * and location updates. Note that mac80211\n\t\t\t * itself never looks at these frames.\n\t\t\t */\n\t\t\tif (!multicast &&\n\t\t\t    !ether_addr_equal(sdata->vif.addr, hdr->addr1))\n\t\t\t\treturn false;\n\t\t\tif (ieee80211_is_public_action(hdr, skb->len))\n\t\t\t\treturn true;\n\t\t\treturn ieee80211_is_beacon(hdr->frame_control);\n\t\t}\n\n\t\tif (!ieee80211_has_tods(hdr->frame_control)) {\n\t\t\t/* ignore data frames to TDLS-peers */\n\t\t\tif (ieee80211_is_data(hdr->frame_control))\n\t\t\t\treturn false;\n\t\t\t/* ignore action frames to TDLS-peers */\n\t\t\tif (ieee80211_is_action(hdr->frame_control) &&\n\t\t\t    !is_broadcast_ether_addr(bssid) &&\n\t\t\t    !ether_addr_equal(bssid, hdr->addr1))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * 802.11-2016 Table 9-26 says that for data frames, A1 must be\n\t\t * the BSSID - we've checked that already but may have accepted\n\t\t * the wildcard (ff:ff:ff:ff:ff:ff).\n\t\t *\n\t\t * It also says:\n\t\t *\tThe BSSID of the Data frame is determined as follows:\n\t\t *\ta) If the STA is contained within an AP or is associated\n\t\t *\t   with an AP, the BSSID is the address currently in use\n\t\t *\t   by the STA contained in the AP.\n\t\t *\n\t\t * So we should not accept data frames with an address that's\n\t\t * multicast.\n\t\t *\n\t\t * Accepting it also opens a security problem because stations\n\t\t * could encrypt it with the GTK and inject traffic that way.\n\t\t */\n\t\tif (ieee80211_is_data(hdr->frame_control) && multicast)\n\t\t\treturn false;\n\n\t\treturn true;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn ieee80211_is_public_action(hdr, skb->len) ||\n\t\t       ieee80211_is_probe_req(hdr->frame_control) ||\n\t\t       ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t       ieee80211_is_beacon(hdr->frame_control);\n\tcase NL80211_IFTYPE_NAN:\n\t\t/* Currently no frames on NAN interface are allowed */\n\t\treturn false;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nvoid ieee80211_check_fast_rx(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_fast_rx fastrx = {\n\t\t.dev = sdata->dev,\n\t\t.vif_type = sdata->vif.type,\n\t\t.control_port_protocol = sdata->control_port_protocol,\n\t}, *old, *new = NULL;\n\tbool assign = false;\n\n\t/* use sparse to check that we don't return without updating */\n\t__acquire(check_fast_rx);\n\n\tBUILD_BUG_ON(sizeof(fastrx.rfc1042_hdr) != sizeof(rfc1042_header));\n\tBUILD_BUG_ON(sizeof(fastrx.rfc1042_hdr) != ETH_ALEN);\n\tether_addr_copy(fastrx.rfc1042_hdr, rfc1042_header);\n\tether_addr_copy(fastrx.vif_addr, sdata->vif.addr);\n\n\tfastrx.uses_rss = ieee80211_hw_check(&local->hw, USES_RSS);\n\n\t/* fast-rx doesn't do reordering */\n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_REORDERING_BUFFER))\n\t\tgoto clear;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sta->sta.tdls) {\n\t\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\t\tfastrx.expected_ds_bits = 0;\n\t\t} else {\n\t\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tfastrx.expected_ds_bits =\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t}\n\n\t\tif (sdata->u.mgd.use_4addr && !sta->sta.tdls) {\n\t\t\tfastrx.expected_ds_bits |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t}\n\n\t\tif (!sdata->u.mgd.powersave)\n\t\t\tbreak;\n\n\t\t/* software powersave is a huge mess, avoid all of it */\n\t\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK))\n\t\t\tgoto clear;\n\t\tif (ieee80211_hw_check(&local->hw, SUPPORTS_PS) &&\n\t\t    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))\n\t\t\tgoto clear;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_AP:\n\t\t/* parallel-rx requires this, at least with calls to\n\t\t * ieee80211_sta_ps_transition()\n\t\t */\n\t\tif (!ieee80211_hw_check(&local->hw, AP_LINK_PS))\n\t\t\tgoto clear;\n\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tfastrx.expected_ds_bits = cpu_to_le16(IEEE80211_FCTL_TODS);\n\n\t\tfastrx.internal_forward =\n\t\t\t!(sdata->flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS) &&\n\t\t\t(sdata->vif.type != NL80211_IFTYPE_AP_VLAN ||\n\t\t\t !sdata->u.vlan.sta);\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->u.vlan.sta) {\n\t\t\tfastrx.expected_ds_bits |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tfastrx.internal_forward = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tgoto clear;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\tgoto clear;\n\n\trcu_read_lock();\n\tkey = rcu_dereference(sta->ptk[sta->ptk_idx]);\n\tif (key) {\n\t\tswitch (key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\t/* we don't want to deal with MMIC in fast-rx */\n\t\t\tgoto clear_rcu;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* We also don't want to deal with\n\t\t\t * WEP or cipher scheme.\n\t\t\t */\n\t\t\tgoto clear_rcu;\n\t\t}\n\n\t\tfastrx.key = true;\n\t\tfastrx.icv_len = key->conf.icv_len;\n\t}\n\n\tassign = true;\n clear_rcu:\n\trcu_read_unlock();\n clear:\n\t__release(check_fast_rx);\n\n\tif (assign)\n\t\tnew = kmemdup(&fastrx, sizeof(fastrx), GFP_KERNEL);\n\n\tspin_lock_bh(&sta->lock);\n\told = rcu_dereference_protected(sta->fast_rx, true);\n\trcu_assign_pointer(sta->fast_rx, new);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n}\n\nvoid ieee80211_clear_fast_rx(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_rx *old;\n\n\tspin_lock_bh(&sta->lock);\n\told = rcu_dereference_protected(sta->fast_rx, true);\n\tRCU_INIT_POINTER(sta->fast_rx, NULL);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n}\n\nvoid __ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata &&\n\t\t    (!sta->sdata->bss || sta->sdata->bss != sdata->bss))\n\t\t\tcontinue;\n\t\tieee80211_check_fast_rx(sta);\n\t}\n}\n\nvoid ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tmutex_lock(&local->sta_mtx);\n\t__ieee80211_check_fast_rx_iface(sdata);\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstatic bool ieee80211_invoke_fast_rx(struct ieee80211_rx_data *rx,\n\t\t\t\t     struct ieee80211_fast_rx *fast_rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct sta_info *sta = rx->sta;\n\tint orig_len = skb->len;\n\tint hdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tint snap_offs = hdrlen;\n\tstruct {\n\t\tu8 snap[sizeof(rfc1042_header)];\n\t\t__be16 proto;\n\t} *payload __aligned(2);\n\tstruct {\n\t\tu8 da[ETH_ALEN];\n\t\tu8 sa[ETH_ALEN];\n\t} addrs __aligned(2);\n\tstruct ieee80211_sta_rx_stats *stats = &sta->rx_stats;\n\n\tif (fast_rx->uses_rss)\n\t\tstats = this_cpu_ptr(sta->pcpu_rx_stats);\n\n\t/* for parallel-rx, we need to have DUP_VALIDATED, otherwise we write\n\t * to a common data structure; drivers can implement that per queue\n\t * but we don't have that information in mac80211\n\t */\n\tif (!(status->flag & RX_FLAG_DUP_VALIDATED))\n\t\treturn false;\n\n#define FAST_RX_CRYPT_FLAGS\t(RX_FLAG_PN_VALIDATED | RX_FLAG_DECRYPTED)\n\n\t/* If using encryption, we also need to have:\n\t *  - PN_VALIDATED: similar, but the implementation is tricky\n\t *  - DECRYPTED: necessary for PN_VALIDATED\n\t */\n\tif (fast_rx->key &&\n\t    (status->flag & FAST_RX_CRYPT_FLAGS) != FAST_RX_CRYPT_FLAGS)\n\t\treturn false;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn false;\n\n\tif (unlikely(ieee80211_is_frag(hdr)))\n\t\treturn false;\n\n\t/* Since our interface address cannot be multicast, this\n\t * implicitly also rejects multicast frames without the\n\t * explicit check.\n\t *\n\t * We shouldn't get any *data* frames not addressed to us\n\t * (AP mode will accept multicast *management* frames), but\n\t * punting here will make it go through the full checks in\n\t * ieee80211_accept_frame().\n\t */\n\tif (!ether_addr_equal(fast_rx->vif_addr, hdr->addr1))\n\t\treturn false;\n\n\tif ((hdr->frame_control & cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t      IEEE80211_FCTL_TODS)) !=\n\t    fast_rx->expected_ds_bits)\n\t\treturn false;\n\n\t/* assign the key to drop unencrypted frames (later)\n\t * and strip the IV/MIC if necessary\n\t */\n\tif (fast_rx->key && !(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\t/* GCMP header length is the same */\n\t\tsnap_offs += IEEE80211_CCMP_HDR_LEN;\n\t}\n\n\tif (!(status->rx_flags & IEEE80211_RX_AMSDU)) {\n\t\tif (!pskb_may_pull(skb, snap_offs + sizeof(*payload)))\n\t\t\tgoto drop;\n\n\t\tpayload = (void *)(skb->data + snap_offs);\n\n\t\tif (!ether_addr_equal(payload->snap, fast_rx->rfc1042_hdr))\n\t\t\treturn false;\n\n\t\t/* Don't handle these here since they require special code.\n\t\t * Accept AARP and IPX even though they should come with a\n\t\t * bridge-tunnel header - but if we get them this way then\n\t\t * there's little point in discarding them.\n\t\t */\n\t\tif (unlikely(payload->proto == cpu_to_be16(ETH_P_TDLS) ||\n\t\t\t     payload->proto == fast_rx->control_port_protocol))\n\t\t\treturn false;\n\t}\n\n\t/* after this point, don't punt to the slowpath! */\n\n\tif (rx->key && !(status->flag & RX_FLAG_MIC_STRIPPED) &&\n\t    pskb_trim(skb, skb->len - fast_rx->icv_len))\n\t\tgoto drop;\n\n\t/* statistics part of ieee80211_rx_h_sta_process() */\n\tif (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\tstats->last_signal = status->signal;\n\t\tif (!fast_rx->uses_rss)\n\t\t\tewma_signal_add(&sta->rx_stats_avg.signal,\n\t\t\t\t\t-status->signal);\n\t}\n\n\tif (status->chains) {\n\t\tint i;\n\n\t\tstats->chains = status->chains;\n\t\tfor (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {\n\t\t\tint signal = status->chain_signal[i];\n\n\t\t\tif (!(status->chains & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tstats->chain_signal_last[i] = signal;\n\t\t\tif (!fast_rx->uses_rss)\n\t\t\t\tewma_signal_add(&sta->rx_stats_avg.chain_signal[i],\n\t\t\t\t\t\t-signal);\n\t\t}\n\t}\n\t/* end of statistics */\n\n\tif (rx->key && !ieee80211_has_protected(hdr->frame_control))\n\t\tgoto drop;\n\n\tif (status->rx_flags & IEEE80211_RX_AMSDU) {\n\t\tif (__ieee80211_rx_h_amsdu(rx, snap_offs - hdrlen) !=\n\t\t    RX_QUEUED)\n\t\t\tgoto drop;\n\n\t\treturn true;\n\t}\n\n\tstats->last_rx = jiffies;\n\tstats->last_rate = sta_stats_encode_rate(status);\n\n\tstats->fragments++;\n\tstats->packets++;\n\n\t/* do the header conversion - first grab the addresses */\n\tether_addr_copy(addrs.da, skb->data + fast_rx->da_offs);\n\tether_addr_copy(addrs.sa, skb->data + fast_rx->sa_offs);\n\t/* remove the SNAP but leave the ethertype */\n\tskb_pull(skb, snap_offs + sizeof(rfc1042_header));\n\t/* push the addresses in front */\n\tmemcpy(skb_push(skb, sizeof(addrs)), &addrs, sizeof(addrs));\n\n\tskb->dev = fast_rx->dev;\n\n\tieee80211_rx_stats(fast_rx->dev, skb->len);\n\n\t/* The seqno index has the same property as needed\n\t * for the rx_msdu field, i.e. it is IEEE80211_NUM_TIDS\n\t * for non-QoS-data frames. Here we know it's a data\n\t * frame, so count MSDUs.\n\t */\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->msdu[rx->seqno_idx]++;\n\tstats->bytes += orig_len;\n\tu64_stats_update_end(&stats->syncp);\n\n\tif (fast_rx->internal_forward) {\n\t\tstruct sk_buff *xmit_skb = NULL;\n\t\tif (is_multicast_ether_addr(addrs.da)) {\n\t\t\txmit_skb = skb_copy(skb, GFP_ATOMIC);\n\t\t} else if (!ether_addr_equal(addrs.da, addrs.sa) &&\n\t\t\t   sta_info_get(rx->sdata, addrs.da)) {\n\t\t\txmit_skb = skb;\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (xmit_skb) {\n\t\t\t/*\n\t\t\t * Send to wireless media and increase priority by 256\n\t\t\t * to keep the received priority instead of\n\t\t\t * reclassifying the frame (see cfg80211_classify8021d).\n\t\t\t */\n\t\t\txmit_skb->priority += 256;\n\t\t\txmit_skb->protocol = htons(ETH_P_802_3);\n\t\t\tskb_reset_network_header(xmit_skb);\n\t\t\tskb_reset_mac_header(xmit_skb);\n\t\t\tdev_queue_xmit(xmit_skb);\n\t\t}\n\n\t\tif (!skb)\n\t\t\treturn true;\n\t}\n\n\t/* deliver to local stack */\n\tskb->protocol = eth_type_trans(skb, fast_rx->dev);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tif (rx->list)\n\t\tlist_add_tail(&skb->list, rx->list);\n\telse\n\t\tnetif_receive_skb(skb);\n\n\treturn true;\n drop:\n\tdev_kfree_skb(skb);\n\tstats->dropped++;\n\treturn true;\n}\n\n/*\n * This function returns whether or not the SKB\n * was destined for RX processing or not, which,\n * if consume is true, is equivalent to whether\n * or not the skb was consumed.\n */\nstatic bool ieee80211_prepare_and_rx_handle(struct ieee80211_rx_data *rx,\n\t\t\t\t\t    struct sk_buff *skb, bool consume)\n{\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\n\trx->skb = skb;\n\n\t/* See if we can do fast-rx; if we have to copy we already lost,\n\t * so punt in that case. We should never have to deliver a data\n\t * frame to multiple interfaces anyway.\n\t *\n\t * We skip the ieee80211_accept_frame() call and do the necessary\n\t * checking inside ieee80211_invoke_fast_rx().\n\t */\n\tif (consume && rx->sta) {\n\t\tstruct ieee80211_fast_rx *fast_rx;\n\n\t\tfast_rx = rcu_dereference(rx->sta->fast_rx);\n\t\tif (fast_rx && ieee80211_invoke_fast_rx(rx, fast_rx))\n\t\t\treturn true;\n\t}\n\n\tif (!ieee80211_accept_frame(rx))\n\t\treturn false;\n\n\tif (!consume) {\n\t\tskb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tif (net_ratelimit())\n\t\t\t\twiphy_debug(local->hw.wiphy,\n\t\t\t\t\t\"failed to copy skb for %s\\n\",\n\t\t\t\t\tsdata->name);\n\t\t\treturn true;\n\t\t}\n\n\t\trx->skb = skb;\n\t}\n\n\tieee80211_invoke_rx_handlers(rx);\n\treturn true;\n}\n\n/*\n * This is the actual Rx frames handler. as it belongs to Rx path it must\n * be called with rcu_read_lock protection.\n */\nstatic void __ieee80211_rx_handle_packet(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_sta *pubsta,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct list_head *list)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_hdr *hdr;\n\t__le16 fc;\n\tstruct ieee80211_rx_data rx;\n\tstruct ieee80211_sub_if_data *prev;\n\tstruct rhlist_head *tmp;\n\tint err = 0;\n\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tmemset(&rx, 0, sizeof(rx));\n\trx.skb = skb;\n\trx.local = local;\n\trx.list = list;\n\n\tif (ieee80211_is_data(fc) || ieee80211_is_mgmt(fc))\n\t\tI802_DEBUG_INC(local->dot11ReceivedFragmentCount);\n\n\tif (ieee80211_is_mgmt(fc)) {\n\t\t/* drop frame if too short for header */\n\t\tif (skb->len < ieee80211_hdrlen(fc))\n\t\t\terr = -ENOBUFS;\n\t\telse\n\t\t\terr = skb_linearize(skb);\n\t} else {\n\t\terr = !pskb_may_pull(skb, ieee80211_hdrlen(fc));\n\t}\n\n\tif (err) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tieee80211_parse_qos(&rx);\n\tieee80211_verify_alignment(&rx);\n\n\tif (unlikely(ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t     ieee80211_is_beacon(hdr->frame_control) ||\n\t\t     ieee80211_is_s1g_beacon(hdr->frame_control)))\n\t\tieee80211_scan_rx(local, skb);\n\n\tif (ieee80211_is_data(fc)) {\n\t\tstruct sta_info *sta, *prev_sta;\n\n\t\tif (pubsta) {\n\t\t\trx.sta = container_of(pubsta, struct sta_info, sta);\n\t\t\trx.sdata = rx.sta->sdata;\n\t\t\tif (ieee80211_prepare_and_rx_handle(&rx, skb, true))\n\t\t\t\treturn;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_sta = NULL;\n\n\t\tfor_each_sta_info(local, hdr->addr2, sta, tmp) {\n\t\t\tif (!prev_sta) {\n\t\t\t\tprev_sta = sta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trx.sta = prev_sta;\n\t\t\trx.sdata = prev_sta->sdata;\n\t\t\tieee80211_prepare_and_rx_handle(&rx, skb, false);\n\n\t\t\tprev_sta = sta;\n\t\t}\n\n\t\tif (prev_sta) {\n\t\t\trx.sta = prev_sta;\n\t\t\trx.sdata = prev_sta->sdata;\n\n\t\t\tif (ieee80211_prepare_and_rx_handle(&rx, skb, true))\n\t\t\t\treturn;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tprev = NULL;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * frame is destined for this interface, but if it's\n\t\t * not also for the previous one we handle that after\n\t\t * the loop to avoid copying the SKB once too much\n\t\t */\n\n\t\tif (!prev) {\n\t\t\tprev = sdata;\n\t\t\tcontinue;\n\t\t}\n\n\t\trx.sta = sta_info_get_bss(prev, hdr->addr2);\n\t\trx.sdata = prev;\n\t\tieee80211_prepare_and_rx_handle(&rx, skb, false);\n\n\t\tprev = sdata;\n\t}\n\n\tif (prev) {\n\t\trx.sta = sta_info_get_bss(prev, hdr->addr2);\n\t\trx.sdata = prev;\n\n\t\tif (ieee80211_prepare_and_rx_handle(&rx, skb, true))\n\t\t\treturn;\n\t}\n\n out:\n\tdev_kfree_skb(skb);\n}\n\n/*\n * This is the receive path handler. It is called by a low level driver when an\n * 802.11 MPDU is received from the hardware.\n */\nvoid ieee80211_rx_list(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta,\n\t\t       struct sk_buff *skb, struct list_head *list)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_rate *rate = NULL;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\n\tWARN_ON_ONCE(softirq_count() == 0);\n\n\tif (WARN_ON(status->band >= NUM_NL80211_BANDS))\n\t\tgoto drop;\n\n\tsband = local->hw.wiphy->bands[status->band];\n\tif (WARN_ON(!sband))\n\t\tgoto drop;\n\n\t/*\n\t * If we're suspending, it is possible although not too likely\n\t * that we'd be receiving frames after having already partially\n\t * quiesced the stack. We can't process such frames then since\n\t * that might, for example, cause stations to be added or other\n\t * driver callbacks be invoked.\n\t */\n\tif (unlikely(local->quiescing || local->suspended))\n\t\tgoto drop;\n\n\t/* We might be during a HW reconfig, prevent Rx for the same reason */\n\tif (unlikely(local->in_reconfig))\n\t\tgoto drop;\n\n\t/*\n\t * The same happens when we're not even started,\n\t * but that's worth a warning.\n\t */\n\tif (WARN_ON(!local->started))\n\t\tgoto drop;\n\n\tif (likely(!(status->flag & RX_FLAG_FAILED_PLCP_CRC))) {\n\t\t/*\n\t\t * Validate the rate, unless a PLCP error means that\n\t\t * we probably can't have a valid rate here anyway.\n\t\t */\n\n\t\tswitch (status->encoding) {\n\t\tcase RX_ENC_HT:\n\t\t\t/*\n\t\t\t * rate_idx is MCS index, which can be [0-76]\n\t\t\t * as documented on:\n\t\t\t *\n\t\t\t * https://wireless.wiki.kernel.org/en/developers/Documentation/ieee80211/802.11n\n\t\t\t *\n\t\t\t * Anything else would be some sort of driver or\n\t\t\t * hardware error. The driver should catch hardware\n\t\t\t * errors.\n\t\t\t */\n\t\t\tif (WARN(status->rate_idx > 76,\n\t\t\t\t \"Rate marked as an HT rate but passed \"\n\t\t\t\t \"status->rate_idx is not \"\n\t\t\t\t \"an MCS index [0-76]: %d (0x%02x)\\n\",\n\t\t\t\t status->rate_idx,\n\t\t\t\t status->rate_idx))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tcase RX_ENC_VHT:\n\t\t\tif (WARN_ONCE(status->rate_idx > 9 ||\n\t\t\t\t      !status->nss ||\n\t\t\t\t      status->nss > 8,\n\t\t\t\t      \"Rate marked as a VHT rate but data is invalid: MCS: %d, NSS: %d\\n\",\n\t\t\t\t      status->rate_idx, status->nss))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tcase RX_ENC_HE:\n\t\t\tif (WARN_ONCE(status->rate_idx > 11 ||\n\t\t\t\t      !status->nss ||\n\t\t\t\t      status->nss > 8,\n\t\t\t\t      \"Rate marked as an HE rate but data is invalid: MCS: %d, NSS: %d\\n\",\n\t\t\t\t      status->rate_idx, status->nss))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tfallthrough;\n\t\tcase RX_ENC_LEGACY:\n\t\t\tif (WARN_ON(status->rate_idx >= sband->n_bitrates))\n\t\t\t\tgoto drop;\n\t\t\trate = &sband->bitrates[status->rate_idx];\n\t\t}\n\t}\n\n\tstatus->rx_flags = 0;\n\n\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\t/*\n\t * Frames with failed FCS/PLCP checksum are not returned,\n\t * all other frames are returned without radiotap header\n\t * if it was previously present.\n\t * Also, frames with less than 16 bytes are dropped.\n\t */\n\tskb = ieee80211_rx_monitor(local, skb, rate);\n\tif (skb) {\n\t\tieee80211_tpt_led_trig_rx(local,\n\t\t\t\t\t  ((struct ieee80211_hdr *)skb->data)->frame_control,\n\t\t\t\t\t  skb->len);\n\n\t\t__ieee80211_rx_handle_packet(hw, pubsta, skb, list);\n\t}\n\n\tkcov_remote_stop();\n\treturn;\n drop:\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL(ieee80211_rx_list);\n\nvoid ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta,\n\t\t       struct sk_buff *skb, struct napi_struct *napi)\n{\n\tstruct sk_buff *tmp;\n\tLIST_HEAD(list);\n\n\n\t/*\n\t * key references and virtual interfaces are protected using RCU\n\t * and this requires that we are in a read-side RCU section during\n\t * receive processing\n\t */\n\trcu_read_lock();\n\tieee80211_rx_list(hw, pubsta, skb, &list);\n\trcu_read_unlock();\n\n\tif (!napi) {\n\t\tnetif_receive_skb_list(&list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(skb, tmp, &list, list) {\n\t\tskb_list_del_init(skb);\n\t\tnapi_gro_receive(napi, skb);\n\t}\n}\nEXPORT_SYMBOL(ieee80211_rx_napi);\n\n/* This is a version of the rx handler that can be called from hard irq\n * context. Post the skb on the queue and schedule the tasklet */\nvoid ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tBUILD_BUG_ON(sizeof(struct ieee80211_rx_status) > sizeof(skb->cb));\n\n\tskb->pkt_type = IEEE80211_RX_MSG;\n\tskb_queue_tail(&local->skb_queue, skb);\n\ttasklet_schedule(&local->tasklet);\n}\nEXPORT_SYMBOL(ieee80211_rx_irqsafe);\n"}, "1": {"id": 1, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}, "2": {"id": 2, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n\n#include <asm/byteorder.h>\n\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\nextern int _cond_resched(void);\n# define might_resched() _cond_resched()\n#else\n# define might_resched() do { } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#ifndef CONFIG_PREEMPT_RT\n# define cant_migrate()\t\tcant_sleep()\n#else\n  /* Placeholder for now */\n# define cant_migrate()\t\tdo { } while (0)\n#endif\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_max_rcu_stall_to_panic;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}, "3": {"id": 3, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Builtins */\n\n/*\n * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.\n * In the meantime, to support gcc < 10, we implement __has_builtin\n * by hand.\n */\n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#ifdef CONFIG_ENABLE_MUST_CHECK\n#define __must_check\t\t__attribute__((__warn_unused_result__))\n#else\n#define __must_check\n#endif\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}, "5": {"id": 5, "path": "/src/include/linux/rcupdate.h", "content": "/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Read-Copy Update mechanism for mutual exclusion\n *\n * Copyright IBM Corporation, 2001\n *\n * Author: Dipankar Sarma <dipankar@in.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@vnet.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n * Papers:\n * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf\n * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\t\thttp://lse.sourceforge.net/locking/rcupdate.html\n *\n */\n\n#ifndef __LINUX_RCUPDATE_H\n#define __LINUX_RCUPDATE_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/processor.h>\n#include <linux/cpumask.h>\n\n#define ULONG_CMP_GE(a, b)\t(ULONG_MAX / 2 >= (a) - (b))\n#define ULONG_CMP_LT(a, b)\t(ULONG_MAX / 2 < (a) - (b))\n#define ulong2long(a)\t\t(*(long *)(&(a)))\n\n/* Exported common interfaces */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func);\nvoid rcu_barrier_tasks(void);\nvoid rcu_barrier_tasks_rude(void);\nvoid synchronize_rcu(void);\n\n#ifdef CONFIG_PREEMPT_RCU\n\nvoid __rcu_read_lock(void);\nvoid __rcu_read_unlock(void);\n\n/*\n * Defined as a macro as it is a very low level header included from\n * areas that don't even know about current.  This gives the rcu_read_lock()\n * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other\n * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.\n */\n#define rcu_preempt_depth() (current->rcu_read_lock_nesting)\n\n#else /* #ifdef CONFIG_PREEMPT_RCU */\n\n#ifdef CONFIG_TINY_RCU\n#define rcu_read_unlock_strict() do { } while (0)\n#else\nvoid rcu_read_unlock_strict(void);\n#endif\n\nstatic inline void __rcu_read_lock(void)\n{\n\tpreempt_disable();\n}\n\nstatic inline void __rcu_read_unlock(void)\n{\n\tpreempt_enable();\n\trcu_read_unlock_strict();\n}\n\nstatic inline int rcu_preempt_depth(void)\n{\n\treturn 0;\n}\n\n#endif /* #else #ifdef CONFIG_PREEMPT_RCU */\n\n/* Internal to kernel */\nvoid rcu_init(void);\nextern int rcu_scheduler_active __read_mostly;\nvoid rcu_sched_clock_irq(int user);\nvoid rcu_report_dead(unsigned int cpu);\nvoid rcutree_migrate_callbacks(int cpu);\n\n#ifdef CONFIG_RCU_STALL_COMMON\nvoid rcu_sysrq_start(void);\nvoid rcu_sysrq_end(void);\n#else /* #ifdef CONFIG_RCU_STALL_COMMON */\nstatic inline void rcu_sysrq_start(void) { }\nstatic inline void rcu_sysrq_end(void) { }\n#endif /* #else #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nvoid rcu_user_enter(void);\nvoid rcu_user_exit(void);\n#else\nstatic inline void rcu_user_enter(void) { }\nstatic inline void rcu_user_exit(void) { }\n#endif /* CONFIG_NO_HZ_FULL */\n\n#ifdef CONFIG_RCU_NOCB_CPU\nvoid rcu_init_nohz(void);\n#else /* #ifdef CONFIG_RCU_NOCB_CPU */\nstatic inline void rcu_init_nohz(void) { }\n#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */\n\n/**\n * RCU_NONIDLE - Indicate idle-loop code that needs RCU readers\n * @a: Code that RCU needs to pay attention to.\n *\n * RCU read-side critical sections are forbidden in the inner idle loop,\n * that is, between the rcu_idle_enter() and the rcu_idle_exit() -- RCU\n * will happily ignore any such read-side critical sections.  However,\n * things like powertop need tracepoints in the inner idle loop.\n *\n * This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())\n * will tell RCU that it needs to pay attention, invoke its argument\n * (in this example, calling the do_something_with_RCU() function),\n * and then tell RCU to go back to ignoring this CPU.  It is permissible\n * to nest RCU_NONIDLE() wrappers, but not indefinitely (but the limit is\n * on the order of a million or so, even on 32-bit systems).  It is\n * not legal to block within RCU_NONIDLE(), nor is it permissible to\n * transfer control either into or out of RCU_NONIDLE()'s statement.\n */\n#define RCU_NONIDLE(a) \\\n\tdo { \\\n\t\trcu_irq_enter_irqson(); \\\n\t\tdo { a; } while (0); \\\n\t\trcu_irq_exit_irqson(); \\\n\t} while (0)\n\n/*\n * Note a quasi-voluntary context switch for RCU-tasks's benefit.\n * This is a macro rather than an inline function to avoid #include hell.\n */\n#ifdef CONFIG_TASKS_RCU_GENERIC\n\n# ifdef CONFIG_TASKS_RCU\n# define rcu_tasks_classic_qs(t, preempt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(preempt) && READ_ONCE((t)->rcu_tasks_holdout))\t\\\n\t\t\tWRITE_ONCE((t)->rcu_tasks_holdout, false);\t\\\n\t} while (0)\nvoid call_rcu_tasks(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks(void);\n# else\n# define rcu_tasks_classic_qs(t, preempt) do { } while (0)\n# define call_rcu_tasks call_rcu\n# define synchronize_rcu_tasks synchronize_rcu\n# endif\n\n# ifdef CONFIG_TASKS_RCU_TRACE\n# define rcu_tasks_trace_qs(t)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!likely(READ_ONCE((t)->trc_reader_checked)) &&\t\\\n\t\t    !unlikely(READ_ONCE((t)->trc_reader_nesting))) {\t\\\n\t\t\tsmp_store_release(&(t)->trc_reader_checked, true); \\\n\t\t\tsmp_mb(); /* Readers partitioned by store. */\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n# else\n# define rcu_tasks_trace_qs(t) do { } while (0)\n# endif\n\n#define rcu_tasks_qs(t, preempt)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_tasks_classic_qs((t), (preempt));\t\t\t\t\\\n\trcu_tasks_trace_qs((t));\t\t\t\t\t\\\n} while (0)\n\n# ifdef CONFIG_TASKS_RUDE_RCU\nvoid call_rcu_tasks_rude(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks_rude(void);\n# endif\n\n#define rcu_note_voluntary_context_switch(t) rcu_tasks_qs(t, false)\nvoid exit_tasks_rcu_start(void);\nvoid exit_tasks_rcu_finish(void);\n#else /* #ifdef CONFIG_TASKS_RCU_GENERIC */\n#define rcu_tasks_qs(t, preempt) do { } while (0)\n#define rcu_note_voluntary_context_switch(t) do { } while (0)\n#define call_rcu_tasks call_rcu\n#define synchronize_rcu_tasks synchronize_rcu\nstatic inline void exit_tasks_rcu_start(void) { }\nstatic inline void exit_tasks_rcu_finish(void) { }\n#endif /* #else #ifdef CONFIG_TASKS_RCU_GENERIC */\n\n/**\n * cond_resched_tasks_rcu_qs - Report potential quiescent states to RCU\n *\n * This macro resembles cond_resched(), except that it is defined to\n * report potential quiescent states to RCU-tasks even if the cond_resched()\n * machinery were to be shut off, as some advocate for PREEMPTION kernels.\n */\n#define cond_resched_tasks_rcu_qs() \\\ndo { \\\n\trcu_tasks_qs(current, false); \\\n\tcond_resched(); \\\n} while (0)\n\n/*\n * Infrastructure to implement the synchronize_() primitives in\n * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.\n */\n\n#if defined(CONFIG_TREE_RCU)\n#include <linux/rcutree.h>\n#elif defined(CONFIG_TINY_RCU)\n#include <linux/rcutiny.h>\n#else\n#error \"Unknown RCU implementation specified to kernel configuration\"\n#endif\n\n/*\n * The init_rcu_head_on_stack() and destroy_rcu_head_on_stack() calls\n * are needed for dynamic initialization and destruction of rcu_head\n * on the stack, and init_rcu_head()/destroy_rcu_head() are needed for\n * dynamic initialization and destruction of statically allocated rcu_head\n * structures.  However, rcu_head structures allocated dynamically in the\n * heap don't need any initialization.\n */\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\nvoid init_rcu_head(struct rcu_head *head);\nvoid destroy_rcu_head(struct rcu_head *head);\nvoid init_rcu_head_on_stack(struct rcu_head *head);\nvoid destroy_rcu_head_on_stack(struct rcu_head *head);\n#else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\nstatic inline void init_rcu_head(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head(struct rcu_head *head) { }\nstatic inline void init_rcu_head_on_stack(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head_on_stack(struct rcu_head *head) { }\n#endif\t/* #else !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\n#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU)\nbool rcu_lockdep_current_cpu_online(void);\n#else /* #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\nstatic inline bool rcu_lockdep_current_cpu_online(void) { return true; }\n#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\n\nextern struct lockdep_map rcu_lock_map;\nextern struct lockdep_map rcu_bh_lock_map;\nextern struct lockdep_map rcu_sched_lock_map;\nextern struct lockdep_map rcu_callback_map;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nstatic inline void rcu_lock_acquire(struct lockdep_map *map)\n{\n\tlock_acquire(map, 0, 0, 2, 0, NULL, _THIS_IP_);\n}\n\nstatic inline void rcu_lock_release(struct lockdep_map *map)\n{\n\tlock_release(map, _THIS_IP_);\n}\n\nint debug_lockdep_rcu_enabled(void);\nint rcu_read_lock_held(void);\nint rcu_read_lock_bh_held(void);\nint rcu_read_lock_sched_held(void);\nint rcu_read_lock_any_held(void);\n\n#else /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n# define rcu_lock_acquire(a)\t\tdo { } while (0)\n# define rcu_lock_release(a)\t\tdo { } while (0)\n\nstatic inline int rcu_read_lock_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_bh_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_sched_held(void)\n{\n\treturn !preemptible();\n}\n\nstatic inline int rcu_read_lock_any_held(void)\n{\n\treturn !preemptible();\n}\n\n#endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n#ifdef CONFIG_PROVE_RCU\n\n/**\n * RCU_LOCKDEP_WARN - emit lockdep splat if specified condition is met\n * @c: condition to check\n * @s: informative message\n */\n#define RCU_LOCKDEP_WARN(c, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic bool __section(\".data.unlikely\") __warned;\t\\\n\t\tif (debug_lockdep_rcu_enabled() && !__warned && (c)) {\t\\\n\t\t\t__warned = true;\t\t\t\t\\\n\t\t\tlockdep_rcu_suspicious(__FILE__, __LINE__, s);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#if defined(CONFIG_PROVE_RCU) && !defined(CONFIG_PREEMPT_RCU)\nstatic inline void rcu_preempt_sleep_check(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_lock_map),\n\t\t\t \"Illegal context switch in RCU read-side critical section\");\n}\n#else /* #ifdef CONFIG_PROVE_RCU */\nstatic inline void rcu_preempt_sleep_check(void) { }\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n#define rcu_sleep_check()\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trcu_preempt_sleep_check();\t\t\t\t\\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-bh read-side critical section\"); \\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-sched read-side critical section\"); \\\n\t} while (0)\n\n#else /* #ifdef CONFIG_PROVE_RCU */\n\n#define RCU_LOCKDEP_WARN(c, s) do { } while (0 && (c))\n#define rcu_sleep_check() do { } while (0)\n\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Helper functions for rcu_dereference_check(), rcu_dereference_protected()\n * and rcu_assign_pointer().  Some of these could be folded into their\n * callers, but they are left separate in order to ease introduction of\n * multiple pointers markings to match different RCU implementations\n * (e.g., __srcu), should this make sense in the future.\n */\n\n#ifdef __CHECKER__\n#define rcu_check_sparse(p, space) \\\n\t((void)(((typeof(*p) space *)p) == p))\n#else /* #ifdef __CHECKER__ */\n#define rcu_check_sparse(p, space)\n#endif /* #else #ifdef __CHECKER__ */\n\n#define __rcu_access_pointer(p, space) \\\n({ \\\n\ttypeof(*p) *_________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(_________p1)); \\\n})\n#define __rcu_dereference_check(p, c, space) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(*p) *________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_check() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n#define __rcu_dereference_protected(p, c, space) \\\n({ \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_protected() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(p)); \\\n})\n#define rcu_dereference_raw(p) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(p) ________p1 = READ_ONCE(p); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n\n/**\n * RCU_INITIALIZER() - statically initialize an RCU-protected global variable\n * @v: The value to statically initialize with.\n */\n#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)\n\n/**\n * rcu_assign_pointer() - assign to RCU-protected pointer\n * @p: pointer to assign to\n * @v: value to assign (publish)\n *\n * Assigns the specified value to the specified RCU-protected\n * pointer, ensuring that any concurrent RCU readers will see\n * any prior initialization.\n *\n * Inserts memory barriers on architectures that require them\n * (which is most of them), and also prevents the compiler from\n * reordering the code that initializes the structure after the pointer\n * assignment.  More importantly, this call documents which pointers\n * will be dereferenced by RCU read-side code.\n *\n * In some special cases, you may use RCU_INIT_POINTER() instead\n * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due\n * to the fact that it does not constrain either the CPU or the compiler.\n * That said, using RCU_INIT_POINTER() when you should have used\n * rcu_assign_pointer() is a very bad thing that results in\n * impossible-to-diagnose memory corruption.  So please be careful.\n * See the RCU_INIT_POINTER() comment header for details.\n *\n * Note that rcu_assign_pointer() evaluates each of its arguments only\n * once, appearances notwithstanding.  One of the \"extra\" evaluations\n * is in typeof() and the other visible only to sparse (__CHECKER__),\n * neither of which actually execute the argument.  As with most cpp\n * macros, this execute-arguments-only-once property is important, so\n * please be careful when making changes to rcu_assign_pointer() and the\n * other macros that it invokes.\n */\n#define rcu_assign_pointer(p, v)\t\t\t\t\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tuintptr_t _r_a_p__v = (uintptr_t)(v);\t\t\t\t      \\\n\trcu_check_sparse(p, __rcu);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)\t      \\\n\t\tWRITE_ONCE((p), (typeof(p))(_r_a_p__v));\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t\tsmp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \\\n} while (0)\n\n/**\n * rcu_replace_pointer() - replace an RCU pointer, returning its old value\n * @rcu_ptr: RCU pointer, whose old value is returned\n * @ptr: regular pointer\n * @c: the lockdep conditions under which the dereference will take place\n *\n * Perform a replacement, where @rcu_ptr is an RCU-annotated\n * pointer and @c is the lockdep argument that is passed to the\n * rcu_dereference_protected() call used to read that pointer.  The old\n * value of @rcu_ptr is returned, and @rcu_ptr is set to @ptr.\n */\n#define rcu_replace_pointer(rcu_ptr, ptr, c)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c));\t\\\n\trcu_assign_pointer((rcu_ptr), (ptr));\t\t\t\t\\\n\t__tmp;\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * rcu_access_pointer() - fetch RCU pointer with no dereferencing\n * @p: The pointer to read\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * lockdep checks for being in an RCU read-side critical section.  This is\n * useful when the value of this pointer is accessed, but the pointer is\n * not dereferenced, for example, when testing an RCU-protected pointer\n * against NULL.  Although rcu_access_pointer() may also be used in cases\n * where update-side locks prevent the value of the pointer from changing,\n * you should instead use rcu_dereference_protected() for this use case.\n *\n * It is also permissible to use rcu_access_pointer() when read-side\n * access to the pointer was removed at least one grace period ago, as\n * is the case in the context of the RCU callback that is freeing up\n * the data, or after a synchronize_rcu() returns.  This can be useful\n * when tearing down multi-linked structures after a grace period\n * has elapsed.\n */\n#define rcu_access_pointer(p) __rcu_access_pointer((p), __rcu)\n\n/**\n * rcu_dereference_check() - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Do an rcu_dereference(), but check that the conditions under which the\n * dereference will take place are correct.  Typically the conditions\n * indicate the various locking conditions that should be held at that\n * point.  The check should return true if the conditions are satisfied.\n * An implicit check for being in an RCU read-side critical section\n * (rcu_read_lock()) is included.\n *\n * For example:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock));\n *\n * could be used to indicate to lockdep that foo->bar may only be dereferenced\n * if either rcu_read_lock() is held, or that the lock required to replace\n * the bar struct at foo->bar is held.\n *\n * Note that the list of conditions may also include indications of when a lock\n * need not be held, for example during initialisation or destruction of the\n * target struct:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock) ||\n *\t\t\t\t\t      atomic_read(&foo->usage) == 0);\n *\n * Inserts memory barriers on architectures that require them\n * (currently only the Alpha), prevents the compiler from refetching\n * (and from merging fetches), and, more importantly, documents exactly\n * which pointers are protected by RCU and checks that the pointer is\n * annotated as __rcu.\n */\n#define rcu_dereference_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_held(), __rcu)\n\n/**\n * rcu_dereference_bh_check() - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-bh counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_bh_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_bh_held(), __rcu)\n\n/**\n * rcu_dereference_sched_check() - rcu_dereference_sched with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-sched counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_sched_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_sched_held(), \\\n\t\t\t\t__rcu)\n\n/*\n * The tracing infrastructure traces RCU (we want that), but unfortunately\n * some of the RCU checks causes tracing to lock up the system.\n *\n * The no-tracing version of rcu_dereference_raw() must not call\n * rcu_read_lock_held().\n */\n#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), 1, __rcu)\n\n/**\n * rcu_dereference_protected() - fetch RCU pointer when updates prevented\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE().  This is useful in cases where update-side locks\n * prevent the value of the pointer from changing.  Please note that this\n * primitive does *not* prevent the compiler from repeating this reference\n * or combining it with other references, so it should not be used without\n * protection of appropriate locks.\n *\n * This function is only for update-side use.  Using this function\n * when protected only by rcu_read_lock() will result in infrequent\n * but very ugly failures.\n */\n#define rcu_dereference_protected(p, c) \\\n\t__rcu_dereference_protected((p), (c), __rcu)\n\n\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n\n/**\n * rcu_dereference_bh() - fetch an RCU-bh-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)\n\n/**\n * rcu_dereference_sched() - fetch RCU-sched-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)\n\n/**\n * rcu_pointer_handoff() - Hand off a pointer from RCU to other mechanism\n * @p: The pointer to hand off\n *\n * This is simply an identity function, but it documents where a pointer\n * is handed off from RCU to some other synchronization mechanism, for\n * example, reference counting or locking.  In C11, it would map to\n * kill_dependency().  It could be used as follows::\n *\n *\trcu_read_lock();\n *\tp = rcu_dereference(gp);\n *\tlong_lived = is_long_lived(p);\n *\tif (long_lived) {\n *\t\tif (!atomic_inc_not_zero(p->refcnt))\n *\t\t\tlong_lived = false;\n *\t\telse\n *\t\t\tp = rcu_pointer_handoff(p);\n *\t}\n *\trcu_read_unlock();\n */\n#define rcu_pointer_handoff(p) (p)\n\n/**\n * rcu_read_lock() - mark the beginning of an RCU read-side critical section\n *\n * When synchronize_rcu() is invoked on one CPU while other CPUs\n * are within RCU read-side critical sections, then the\n * synchronize_rcu() is guaranteed to block until after all the other\n * CPUs exit their critical sections.  Similarly, if call_rcu() is invoked\n * on one CPU while other CPUs are within RCU read-side critical\n * sections, invocation of the corresponding RCU callback is deferred\n * until after the all the other CPUs exit their critical sections.\n *\n * Note, however, that RCU callbacks are permitted to run concurrently\n * with new RCU read-side critical sections.  One way that this can happen\n * is via the following sequence of events: (1) CPU 0 enters an RCU\n * read-side critical section, (2) CPU 1 invokes call_rcu() to register\n * an RCU callback, (3) CPU 0 exits the RCU read-side critical section,\n * (4) CPU 2 enters a RCU read-side critical section, (5) the RCU\n * callback is invoked.  This is legal, because the RCU read-side critical\n * section that was running concurrently with the call_rcu() (and which\n * therefore might be referencing something that the corresponding RCU\n * callback would free up) has completed before the corresponding\n * RCU callback is invoked.\n *\n * RCU read-side critical sections may be nested.  Any deferred actions\n * will be deferred until the outermost RCU read-side critical section\n * completes.\n *\n * You can avoid reading and understanding the next paragraph by\n * following this rule: don't put anything in an rcu_read_lock() RCU\n * read-side critical section that would block in a !PREEMPTION kernel.\n * But if you want the full story, read on!\n *\n * In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),\n * it is illegal to block while in an RCU read-side critical section.\n * In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION\n * kernel builds, RCU read-side critical sections may be preempted,\n * but explicit blocking is illegal.  Finally, in preemptible RCU\n * implementations in real-time (with -rt patchset) kernel builds, RCU\n * read-side critical sections may be preempted and they may also block, but\n * only when acquiring spinlocks that are subject to priority inheritance.\n */\nstatic __always_inline void rcu_read_lock(void)\n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_lock_acquire(&rcu_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock() used illegally while idle\");\n}\n\n/*\n * So where is rcu_write_lock()?  It does not exist, as there is no\n * way for writers to lock out RCU readers.  This is a feature, not\n * a bug -- this property is what provides RCU's performance benefits.\n * Of course, writers must coordinate with each other.  The normal\n * spinlock primitives work well for this, but any other technique may be\n * used as well.  RCU does not care how the writers keep out of each\n * others' way, as long as they do so.\n */\n\n/**\n * rcu_read_unlock() - marks the end of an RCU read-side critical section.\n *\n * In most situations, rcu_read_unlock() is immune from deadlock.\n * However, in kernels built with CONFIG_RCU_BOOST, rcu_read_unlock()\n * is responsible for deboosting, which it does via rt_mutex_unlock().\n * Unfortunately, this function acquires the scheduler's runqueue and\n * priority-inheritance spinlocks.  This means that deadlock could result\n * if the caller of rcu_read_unlock() already holds one of these locks or\n * any lock that is ever acquired while holding them.\n *\n * That said, RCU readers are never priority boosted unless they were\n * preempted.  Therefore, one way to avoid deadlock is to make sure\n * that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with one of\n * rt_mutex_unlock()'s locks held.  Such preemption can be avoided in\n * a number of ways, for example, by invoking preempt_disable() before\n * critical section's outermost rcu_read_lock().\n *\n * Given that the set of locks acquired by rt_mutex_unlock() might change\n * at any time, a somewhat more future-proofed approach is to make sure\n * that that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with irqs disabled.\n * This approach relies on the fact that rt_mutex_unlock() currently only\n * acquires irq-disabled locks.\n *\n * The second of these two approaches is best in most situations,\n * however, the first approach can also be useful, at least to those\n * developers willing to keep abreast of the set of locks acquired by\n * rt_mutex_unlock().\n *\n * See rcu_read_lock() for more information.\n */\nstatic inline void rcu_read_unlock(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock() used illegally while idle\");\n\t__release(RCU);\n\t__rcu_read_unlock();\n\trcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */\n}\n\n/**\n * rcu_read_lock_bh() - mark the beginning of an RCU-bh critical section\n *\n * This is equivalent of rcu_read_lock(), but also disables softirqs.\n * Note that anything else that disables softirqs can also serve as\n * an RCU read-side critical section.\n *\n * Note that rcu_read_lock_bh() and the matching rcu_read_unlock_bh()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_bh() from one task if the matching rcu_read_lock_bh()\n * was invoked from some other task.\n */\nstatic inline void rcu_read_lock_bh(void)\n{\n\tlocal_bh_disable();\n\t__acquire(RCU_BH);\n\trcu_lock_acquire(&rcu_bh_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_bh() used illegally while idle\");\n}\n\n/**\n * rcu_read_unlock_bh() - marks the end of a softirq-only RCU critical section\n *\n * See rcu_read_lock_bh() for more information.\n */\nstatic inline void rcu_read_unlock_bh(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_bh() used illegally while idle\");\n\trcu_lock_release(&rcu_bh_lock_map);\n\t__release(RCU_BH);\n\tlocal_bh_enable();\n}\n\n/**\n * rcu_read_lock_sched() - mark the beginning of a RCU-sched critical section\n *\n * This is equivalent of rcu_read_lock(), but disables preemption.\n * Read-side critical sections can also be introduced by anything else\n * that disables preemption, including local_irq_disable() and friends.\n *\n * Note that rcu_read_lock_sched() and the matching rcu_read_unlock_sched()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_sched() from process context if the matching\n * rcu_read_lock_sched() was invoked from an NMI handler.\n */\nstatic inline void rcu_read_lock_sched(void)\n{\n\tpreempt_disable();\n\t__acquire(RCU_SCHED);\n\trcu_lock_acquire(&rcu_sched_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_sched() used illegally while idle\");\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_lock_sched_notrace(void)\n{\n\tpreempt_disable_notrace();\n\t__acquire(RCU_SCHED);\n}\n\n/**\n * rcu_read_unlock_sched() - marks the end of a RCU-classic critical section\n *\n * See rcu_read_lock_sched() for more information.\n */\nstatic inline void rcu_read_unlock_sched(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_sched() used illegally while idle\");\n\trcu_lock_release(&rcu_sched_lock_map);\n\t__release(RCU_SCHED);\n\tpreempt_enable();\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_unlock_sched_notrace(void)\n{\n\t__release(RCU_SCHED);\n\tpreempt_enable_notrace();\n}\n\n/**\n * RCU_INIT_POINTER() - initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * Initialize an RCU-protected pointer in special cases where readers\n * do not need ordering constraints on the CPU or the compiler.  These\n * special cases are:\n *\n * 1.\tThis use of RCU_INIT_POINTER() is NULLing out the pointer *or*\n * 2.\tThe caller has taken whatever steps are required to prevent\n *\tRCU readers from concurrently accessing this pointer *or*\n * 3.\tThe referenced data structure has already been exposed to\n *\treaders either at compile time or via rcu_assign_pointer() *and*\n *\n *\ta.\tYou have not made *any* reader-visible changes to\n *\t\tthis structure since then *or*\n *\tb.\tIt is OK for readers accessing this structure from its\n *\t\tnew location to see the old state of the structure.  (For\n *\t\texample, the changes were to statistical counters or to\n *\t\tother state where exact synchronization is not required.)\n *\n * Failure to follow these rules governing use of RCU_INIT_POINTER() will\n * result in impossible-to-diagnose memory corruption.  As in the structures\n * will look OK in crash dumps, but any concurrent RCU readers might\n * see pre-initialized values of the referenced data structure.  So\n * please be very careful how you use RCU_INIT_POINTER()!!!\n *\n * If you are creating an RCU-protected linked structure that is accessed\n * by a single external-to-structure RCU-protected pointer, then you may\n * use RCU_INIT_POINTER() to initialize the internal RCU-protected\n * pointers, but you must use rcu_assign_pointer() to initialize the\n * external-to-structure pointer *after* you have completely initialized\n * the reader-accessible portions of the linked structure.\n *\n * Note that unlike rcu_assign_pointer(), RCU_INIT_POINTER() provides no\n * ordering guarantees for either the CPU or the compiler.\n */\n#define RCU_INIT_POINTER(p, v) \\\n\tdo { \\\n\t\trcu_check_sparse(p, __rcu); \\\n\t\tWRITE_ONCE(p, RCU_INITIALIZER(v)); \\\n\t} while (0)\n\n/**\n * RCU_POINTER_INITIALIZER() - statically initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * GCC-style initialization for an RCU-protected pointer in a structure field.\n */\n#define RCU_POINTER_INITIALIZER(p, v) \\\n\t\t.p = RCU_INITIALIZER(v)\n\n/*\n * Does the specified offset indicate that the corresponding rcu_head\n * structure can be handled by kvfree_rcu()?\n */\n#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)\n\n/*\n * Helper macro for kfree_rcu() to prevent argument-expansion eyestrain.\n */\n#define __kvfree_rcu(head, offset) \\\n\tdo { \\\n\t\tBUILD_BUG_ON(!__is_kvfree_rcu_offset(offset)); \\\n\t\tkvfree_call_rcu(head, (rcu_callback_t)(unsigned long)(offset)); \\\n\t} while (0)\n\n/**\n * kfree_rcu() - kfree an object after a grace period.\n * @ptr:\tpointer to kfree\n * @rhf:\tthe name of the struct rcu_head within the type of @ptr.\n *\n * Many rcu callbacks functions just call kfree() on the base structure.\n * These functions are trivial, but their size adds up, and furthermore\n * when they are used in a kernel module, that module must invoke the\n * high-latency rcu_barrier() function at module-unload time.\n *\n * The kfree_rcu() function handles this issue.  Rather than encoding a\n * function address in the embedded rcu_head structure, kfree_rcu() instead\n * encodes the offset of the rcu_head structure within the base structure.\n * Because the functions are not allowed in the low-order 4096 bytes of\n * kernel virtual memory, offsets up to 4095 bytes can be accommodated.\n * If the offset is larger than 4095 bytes, a compile-time error will\n * be generated in __kvfree_rcu(). If this error is triggered, you can\n * either fall back to use of call_rcu() or rearrange the structure to\n * position the rcu_head structure into the first 4096 bytes.\n *\n * Note that the allowable offset might decrease in the future, for example,\n * to allow something like kmem_cache_free_rcu().\n *\n * The BUILD_BUG_ON check must not involve any function calls, hence the\n * checks are done in macros here.\n */\n#define kfree_rcu(ptr, rhf)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof (ptr) ___p = (ptr);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\t\\\n\t\t__kvfree_rcu(&((___p)->rhf), offsetof(typeof(*(ptr)), rhf)); \\\n} while (0)\n\n/**\n * kvfree_rcu() - kvfree an object after a grace period.\n *\n * This macro consists of one or two arguments and it is\n * based on whether an object is head-less or not. If it\n * has a head then a semantic stays the same as it used\n * to be before:\n *\n *     kvfree_rcu(ptr, rhf);\n *\n * where @ptr is a pointer to kvfree(), @rhf is the name\n * of the rcu_head structure within the type of @ptr.\n *\n * When it comes to head-less variant, only one argument\n * is passed and that is just a pointer which has to be\n * freed after a grace period. Therefore the semantic is\n *\n *     kvfree_rcu(ptr);\n *\n * where @ptr is a pointer to kvfree().\n *\n * Please note, head-less way of freeing is permitted to\n * use from a context that has to follow might_sleep()\n * annotation. Otherwise, please switch and embed the\n * rcu_head structure within the type of @ptr.\n */\n#define kvfree_rcu(...) KVFREE_GET_MACRO(__VA_ARGS__,\t\t\\\n\tkvfree_rcu_arg_2, kvfree_rcu_arg_1)(__VA_ARGS__)\n\n#define KVFREE_GET_MACRO(_1, _2, NAME, ...) NAME\n#define kvfree_rcu_arg_2(ptr, rhf) kfree_rcu(ptr, rhf)\n#define kvfree_rcu_arg_1(ptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) ___p = (ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\\\n\t\tkvfree_call_rcu(NULL, (rcu_callback_t) (___p));\t\\\n} while (0)\n\n/*\n * Place this after a lock-acquisition primitive to guarantee that\n * an UNLOCK+LOCK pair acts as a full barrier.  This guarantee applies\n * if the UNLOCK and LOCK are executed by the same CPU or if the\n * UNLOCK and LOCK operate on the same lock variable.\n */\n#ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE\n#define smp_mb__after_unlock_lock()\tsmp_mb()  /* Full ordering for lock. */\n#else /* #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n#define smp_mb__after_unlock_lock()\tdo { } while (0)\n#endif /* #else #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n\n\n/* Has the specified rcu_head structure been handed to call_rcu()? */\n\n/**\n * rcu_head_init - Initialize rcu_head for rcu_head_after_call_rcu()\n * @rhp: The rcu_head structure to initialize.\n *\n * If you intend to invoke rcu_head_after_call_rcu() to test whether a\n * given rcu_head structure has already been passed to call_rcu(), then\n * you must also invoke this rcu_head_init() function on it just after\n * allocating that structure.  Calls to this function must not race with\n * calls to call_rcu(), rcu_head_after_call_rcu(), or callback invocation.\n */\nstatic inline void rcu_head_init(struct rcu_head *rhp)\n{\n\trhp->func = (rcu_callback_t)~0L;\n}\n\n/**\n * rcu_head_after_call_rcu() - Has this rcu_head been passed to call_rcu()?\n * @rhp: The rcu_head structure to test.\n * @f: The function passed to call_rcu() along with @rhp.\n *\n * Returns @true if the @rhp has been passed to call_rcu() with @func,\n * and @false otherwise.  Emits a warning in any other case, including\n * the case where @rhp has already been invoked after a grace period.\n * Calls to this function must not race with callback invocation.  One way\n * to avoid such races is to enclose the call to rcu_head_after_call_rcu()\n * in an RCU read-side critical section that includes a read-side fetch\n * of the pointer to the structure containing @rhp.\n */\nstatic inline bool\nrcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)\n{\n\trcu_callback_t func = READ_ONCE(rhp->func);\n\n\tif (func == f)\n\t\treturn true;\n\tWARN_ON_ONCE(func != (rcu_callback_t)~0L);\n\treturn false;\n}\n\n/* kernel/ksysfs.c definitions */\nextern int rcu_expedited;\nextern int rcu_normal;\n\n#endif /* __LINUX_RCUPDATE_H */\n"}, "6": {"id": 6, "path": "/src/include/asm-generic/rwonce.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Prevent the compiler from merging or refetching reads or writes. The\n * compiler is also forbidden from reordering successive instances of\n * READ_ONCE and WRITE_ONCE, but only when the compiler is aware of some\n * particular ordering. One way to make the compiler aware of ordering is to\n * put the two invocations of READ_ONCE or WRITE_ONCE in different C\n * statements.\n *\n * These two macros will also work on aggregate data types like structs or\n * unions.\n *\n * Their two major use cases are: (1) Mediating communication between\n * process-level code and irq/NMI handlers, all running on the same CPU,\n * and (2) Ensuring that the compiler does not fold, spindle, or otherwise\n * mutilate accesses that either do not require ordering or that interact\n * with an explicit memory barrier or atomic instruction that provides the\n * required ordering.\n */\n#ifndef __ASM_GENERIC_RWONCE_H\n#define __ASM_GENERIC_RWONCE_H\n\n#ifndef __ASSEMBLY__\n\n#include <linux/compiler_types.h>\n#include <linux/kasan-checks.h>\n#include <linux/kcsan-checks.h>\n\n/*\n * Yes, this permits 64-bit accesses on 32-bit architectures. These will\n * actually be atomic in some cases (namely Armv7 + LPAE), but for others we\n * rely on the access being split into 2x32-bit accesses for a 32-bit quantity\n * (e.g. a virtual address) and a strong prevailing wind.\n */\n#define compiletime_assert_rwonce_type(t)\t\t\t\t\t\\\n\tcompiletime_assert(__native_word(t) || sizeof(t) == sizeof(long long),\t\\\n\t\t\"Unsupported access size for {READ,WRITE}_ONCE().\")\n\n/*\n * Use __READ_ONCE() instead of READ_ONCE() if you do not require any\n * atomicity. Note that this may result in tears!\n */\n#ifndef __READ_ONCE\n#define __READ_ONCE(x)\t(*(const volatile __unqual_scalar_typeof(x) *)&(x))\n#endif\n\n#define READ_ONCE(x)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert_rwonce_type(x);\t\t\t\t\\\n\t__READ_ONCE(x);\t\t\t\t\t\t\t\\\n})\n\n#define __WRITE_ONCE(x, val)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t*(volatile typeof(x) *)&(x) = (val);\t\t\t\t\\\n} while (0)\n\n#define WRITE_ONCE(x, val)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert_rwonce_type(x);\t\t\t\t\\\n\t__WRITE_ONCE(x, val);\t\t\t\t\t\t\\\n} while (0)\n\nstatic __no_sanitize_or_inline\nunsigned long __read_once_word_nocheck(const void *addr)\n{\n\treturn __READ_ONCE(*(unsigned long *)addr);\n}\n\n/*\n * Use READ_ONCE_NOCHECK() instead of READ_ONCE() if you need to load a\n * word from memory atomically but without telling KASAN/KCSAN. This is\n * usually used by unwinding code when walking the stack of a running process.\n */\n#define READ_ONCE_NOCHECK(x)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tcompiletime_assert(sizeof(x) == sizeof(unsigned long),\t\t\\\n\t\t\"Unsupported access size for READ_ONCE_NOCHECK().\");\t\\\n\t(typeof(x))__read_once_word_nocheck(&(x));\t\t\t\\\n})\n\nstatic __no_kasan_or_inline\nunsigned long read_word_at_a_time(const void *addr)\n{\n\tkasan_check_read(addr, 1);\n\treturn *(unsigned long *)addr;\n}\n\n#endif /* __ASSEMBLY__ */\n#endif\t/* __ASM_GENERIC_RWONCE_H */\n"}}, "reports": [{"events": [{"location": {"col": 14, "file": 0, "line": 3895}, "message": "Assuming 'pubsta' is non-null"}, {"location": {"col": 25, "file": 1, "line": 119}, "message": "expanded from macro 'WARN_ON'"}, {"location": {"col": 14, "file": 0, "line": 3895}, "message": "Left side of '||' is false"}, {"location": {"col": 25, "file": 0, "line": 3895}, "message": "Assuming 'tid' is < 16"}, {"location": {"col": 25, "file": 1, "line": 119}, "message": "expanded from macro 'WARN_ON'"}, {"location": {"col": 6, "file": 0, "line": 3895}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 1, "line": 120}, "message": "expanded from macro 'WARN_ON'"}, {"location": {"col": 2, "file": 0, "line": 3895}, "message": "Taking false branch"}, {"location": {"col": 8, "file": 0, "line": 3900}, "message": "Left side of '&&' is false"}, {"location": {"col": 61, "file": 2, "line": 687}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 8, "file": 0, "line": 3900}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 2, "line": 687}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 326}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 314}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 4, "line": 306}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 8, "file": 0, "line": 3900}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 2, "file": 2, "line": 687}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 3, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 4, "line": 326}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 314}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 4, "line": 304}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 15, "file": 0, "line": 3907}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 557}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 5, "line": 499}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 5, "line": 360}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 6, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 21, "file": 6, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 3, "file": 4, "line": 288}, "message": "expanded from macro '__native_word'"}, {"location": {"col": 15, "file": 0, "line": 3907}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 557}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 5, "line": 499}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 5, "line": 360}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 6, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 21, "file": 6, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 3, "file": 4, "line": 288}, "message": "expanded from macro '__native_word'"}, {"location": {"col": 15, "file": 0, "line": 3907}, "message": "Left side of '||' is false"}, {"location": {"col": 28, "file": 5, "line": 557}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 5, "line": 499}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 5, "line": 360}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 6, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 21, "file": 6, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 3, "file": 4, "line": 288}, "message": "expanded from macro '__native_word'"}, {"location": {"col": 15, "file": 0, "line": 3907}, "message": "Left side of '||' is true"}, {"location": {"col": 28, "file": 5, "line": 557}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 5, "line": 499}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 5, "line": 360}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 2, "file": 6, "line": 49}, "message": "expanded from macro 'READ_ONCE'"}, {"location": {"col": 38, "file": 6, "line": 36}, "message": "expanded from macro 'compiletime_assert_rwonce_type'"}, {"location": {"col": 15, "file": 0, "line": 3907}, "message": "Taking false branch"}, {"location": {"col": 28, "file": 5, "line": 557}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 5, "line": 499}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 48, "file": 5, "line": 360}, "message": "expanded from macro '__rcu_dereference_check'"}, {"location": {"col": 35, "file": 0, "line": 1179}, "message": "Division by zero"}], "macros": [], "notes": [], "path": "/src/net/mac80211/rx.c", "reportHash": "360cb4a261d6fc9338cdcfc031ddb798", "checkerName": "clang-analyzer-core.DivideZero", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
