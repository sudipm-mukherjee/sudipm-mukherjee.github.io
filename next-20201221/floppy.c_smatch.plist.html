<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/block/floppy.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/drivers/block/floppy.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *  Copyright (C) 1993, 1994  Alain Knaff\n *  Copyright (C) 1998 Alan Cox\n */\n\n/*\n * 02.12.91 - Changed to static variables to indicate need for reset\n * and recalibrate. This makes some things easier (output_byte reset\n * checking etc), and means less interrupt jumping in case of errors,\n * so the code is hopefully easier to understand.\n */\n\n/*\n * This file is certainly a mess. I've tried my best to get it working,\n * but I don't like programming floppies, and I have only one anyway.\n * Urgel. I should check for more errors, and do more graceful error\n * recovery. Seems there are problems with several drives. I've tried to\n * correct them. No promises.\n */\n\n/*\n * As with hd.c, all routines within this file can (and will) be called\n * by interrupts, so extreme caution is needed. A hardware interrupt\n * handler may not sleep, or a kernel panic will happen. Thus I cannot\n * call \"floppy-on\" directly, but have to set a special timer interrupt\n * etc.\n */\n\n/*\n * 28.02.92 - made track-buffering routines, based on the routines written\n * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.\n */\n\n/*\n * Automatic floppy-detection and formatting written by Werner Almesberger\n * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with\n * the floppy-change signal detection.\n */\n\n/*\n * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed\n * FDC data overrun bug, added some preliminary stuff for vertical\n * recording support.\n *\n * 1992/9/17: Added DMA allocation & DMA functions. -- hhb.\n *\n * TODO: Errors are still not counted properly.\n */\n\n/* 1992/9/20\n * Modifications for ``Sector Shifting'' by Rob Hooft (hooft@chem.ruu.nl)\n * modeled after the freeware MS-DOS program fdformat/88 V1.8 by\n * Christoph H. Hochst\\\"atter.\n * I have fixed the shift values to the ones I always use. Maybe a new\n * ioctl() should be created to be able to modify them.\n * There is a bug in the driver that makes it impossible to format a\n * floppy as the first thing after bootup.\n */\n\n/*\n * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and\n * this helped the floppy driver as well. Much cleaner, and still seems to\n * work.\n */\n\n/* 1994/6/24 --bbroad-- added the floppy table entries and made\n * minor modifications to allow 2.88 floppies to be run.\n */\n\n/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more\n * disk types.\n */\n\n/*\n * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger\n * format bug fixes, but unfortunately some new bugs too...\n */\n\n/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write\n * errors to allow safe writing by specialized programs.\n */\n\n/* 1995/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5\" disks\n * by defining bit 1 of the \"stretch\" parameter to mean put sectors on the\n * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore's\n * drives are \"upside-down\").\n */\n\n/*\n * 1995/8/26 -- Andreas Busse -- added Mips support.\n */\n\n/*\n * 1995/10/18 -- Ralf Baechle -- Portability cleanup; move machine dependent\n * features to asm/floppy.h.\n */\n\n/*\n * 1998/1/21 -- Richard Gooch <rgooch@atnf.csiro.au> -- devfs support\n */\n\n/*\n * 1998/05/07 -- Russell King -- More portability cleanups; moved definition of\n * interrupt and dma channel to asm/floppy.h. Cleaned up some formatting &\n * use of '0' for NULL.\n */\n\n/*\n * 1998/06/07 -- Alan Cox -- Merged the 2.0.34 fixes for resource allocation\n * failures.\n */\n\n/*\n * 1998/09/20 -- David Weinehall -- Added slow-down code for buggy PS/2-drives.\n */\n\n/*\n * 1999/08/13 -- Paul Slootman -- floppy stopped working on Alpha after 24\n * days, 6 hours, 32 minutes and 32 seconds (i.e. MAXINT jiffies; ints were\n * being used to store jiffies, which are unsigned longs).\n */\n\n/*\n * 2000/08/28 -- Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - get rid of check_region\n * - s/suser/capable/\n */\n\n/*\n * 2001/08/26 -- Paul Gortmaker - fix insmod oops on machines with no\n * floppy controller (lingering task on list after module is gone... boom.)\n */\n\n/*\n * 2002/02/07 -- Anton Altaparmakov - Fix io ports reservation to correct range\n * (0x3f2-0x3f5, 0x3f7). This fix is a bit of a hack but the proper fix\n * requires many non-obvious changes in arch dependent code.\n */\n\n/* 2003/07/28 -- Daniele Bellucci <bellucda@tiscali.it>.\n * Better audit of register_blkdev.\n */\n\n#undef  FLOPPY_SILENT_DCL_CLEAR\n\n#define REALLY_SLOW_IO\n\n#define DEBUGT 2\n\n#define DPRINT(format, args...) \\\n\tpr_info(\"floppy%d: \" format, current_drive, ##args)\n\n#define DCL_DEBUG\t\t/* debug disk change line */\n#ifdef DCL_DEBUG\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if ((test) & FD_DEBUG) DPRINT(fmt, ##args); } while (0)\n#else\n#define debug_dcl(test, fmt, args...) \\\n\tdo { if (0) DPRINT(fmt, ##args); } while (0)\n#endif\n\n/* do print messages for unexpected interrupts */\nstatic int print_unex = 1;\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/fdreg.h>\n#include <linux/fd.h>\n#include <linux/hdreg.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mc146818rtc.h>\t/* CMOS defines */\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/compat.h>\n\n/*\n * PS/2 floppies have much slower step rates than regular floppies.\n * It's been recommended that take about 1/4 of the default speed\n * in some more extreme cases.\n */\nstatic DEFINE_MUTEX(floppy_mutex);\nstatic int slow_floppy;\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n\nstatic int FLOPPY_IRQ = 6;\nstatic int FLOPPY_DMA = 2;\nstatic int can_use_virtual_dma = 2;\n/* =======\n * can use virtual DMA:\n * 0 = use of virtual DMA disallowed by config\n * 1 = use of virtual DMA prescribed by config\n * 2 = no virtual DMA preference configured.  By default try hard DMA,\n * but fall back on virtual DMA when not enough memory available\n */\n\nstatic int use_virtual_dma;\n/* =======\n * use virtual DMA\n * 0 using hard DMA\n * 1 using virtual DMA\n * This variable is set to virtual when a DMA mem problem arises, and\n * reset back in floppy_grab_irq_and_dma.\n * It is not safe to reset it in other circumstances, because the floppy\n * driver may have several buffers in use at once, and we do currently not\n * record each buffers capabilities\n */\n\nstatic DEFINE_SPINLOCK(floppy_lock);\n\nstatic unsigned short virtual_dma_port = 0x3f0;\nirqreturn_t floppy_interrupt(int irq, void *dev_id);\nstatic int set_dor(int fdc, char mask, char data);\n\n#define K_64\t0x10000\t\t/* 64KB */\n\n/* the following is the mask of allowed drives. By default units 2 and\n * 3 of both floppy controllers are disabled, because switching on the\n * motor of these drives causes system hangs on some PCI computers. drive\n * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if\n * a drive is allowed.\n *\n * NOTE: This must come before we include the arch floppy header because\n *       some ports reference this variable from there. -DaveM\n */\n\nstatic int allowed_drive_mask = 0x33;\n\n#include <asm/floppy.h>\n\nstatic int irqdma_allocated;\n\n#include <linux/blk-mq.h>\n#include <linux/blkpg.h>\n#include <linux/cdrom.h>\t/* for the compatibility eject ioctl */\n#include <linux/completion.h>\n\nstatic LIST_HEAD(floppy_reqs);\nstatic struct request *current_req;\nstatic int set_next_request(void);\n\n#ifndef fd_get_dma_residue\n#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)\n#endif\n\n/* Dma Memory related stuff */\n\n#ifndef fd_dma_mem_free\n#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))\n#endif\n\n#ifndef fd_dma_mem_alloc\n#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL, get_order(size))\n#endif\n\n#ifndef fd_cacheflush\n#define fd_cacheflush(addr, size) /* nothing... */\n#endif\n\nstatic inline void fallback_on_nodma_alloc(char **addr, size_t l)\n{\n#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA\n\tif (*addr)\n\t\treturn;\t\t/* we have the memory */\n\tif (can_use_virtual_dma != 2)\n\t\treturn;\t\t/* no fallback allowed */\n\tpr_info(\"DMA memory shortage. Temporarily falling back on virtual DMA\\n\");\n\t*addr = (char *)nodma_mem_alloc(l);\n#else\n\treturn;\n#endif\n}\n\n/* End dma memory related stuff */\n\nstatic unsigned long fake_change;\nstatic bool initialized;\n\n#define ITYPE(x)\t(((x) >> 2) & 0x1f)\n#define TOMINOR(x)\t((x & 3) | ((x & 4) << 5))\n#define UNIT(x)\t\t((x) & 0x03)\t\t/* drive on fdc */\n#define FDC(x)\t\t(((x) & 0x04) >> 2)\t/* fdc of drive */\n\t/* reverse mapping from unit and fdc to drive */\n#define REVDRIVE(fdc, unit) ((unit) + ((fdc) << 2))\n\n#define PH_HEAD(floppy, head) (((((floppy)->stretch & 2) >> 1) ^ head) << 2)\n#define STRETCH(floppy)\t((floppy)->stretch & FD_STRETCH)\n\n/* read/write commands */\n#define COMMAND\t\t\t0\n#define DR_SELECT\t\t1\n#define TRACK\t\t\t2\n#define HEAD\t\t\t3\n#define SECTOR\t\t\t4\n#define SIZECODE\t\t5\n#define SECT_PER_TRACK\t\t6\n#define GAP\t\t\t7\n#define SIZECODE2\t\t8\n#define NR_RW 9\n\n/* format commands */\n#define F_SIZECODE\t\t2\n#define F_SECT_PER_TRACK\t3\n#define F_GAP\t\t\t4\n#define F_FILL\t\t\t5\n#define NR_F 6\n\n/*\n * Maximum disk size (in kilobytes).\n * This default is used whenever the current disk size is unknown.\n * [Now it is rather a minimum]\n */\n#define MAX_DISK_SIZE 4\t\t/* 3984 */\n\n/*\n * globals used by 'result()'\n */\nstatic unsigned char reply_buffer[FD_RAW_REPLY_SIZE];\nstatic int inr;\t\t/* size of reply buffer, when called from interrupt */\n#define ST0\t\t0\n#define ST1\t\t1\n#define ST2\t\t2\n#define ST3\t\t0\t/* result of GETSTATUS */\n#define R_TRACK\t\t3\n#define R_HEAD\t\t4\n#define R_SECTOR\t5\n#define R_SIZECODE\t6\n\n#define SEL_DLY\t\t(2 * HZ / 100)\n\n/*\n * this struct defines the different floppy drive types.\n */\nstatic struct {\n\tstruct floppy_drive_params params;\n\tconst char *name;\t/* name printed while booting */\n} default_drive_params[] = {\n/* NOTE: the time values in jiffies should be in msec!\n CMOS drive type\n  |     Maximum data rate supported by drive type\n  |     |   Head load time, msec\n  |     |   |   Head unload time, msec (not used)\n  |     |   |   |     Step rate interval, usec\n  |     |   |   |     |       Time needed for spinup time (jiffies)\n  |     |   |   |     |       |      Timeout for spinning down (jiffies)\n  |     |   |   |     |       |      |   Spindown offset (where disk stops)\n  |     |   |   |     |       |      |   |     Select delay\n  |     |   |   |     |       |      |   |     |     RPS\n  |     |   |   |     |       |      |   |     |     |    Max number of tracks\n  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout\n  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors\n  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */\n{{0,  500, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  80, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4, 8, 2, 1, 5, 3,10}, 3*HZ/2, 0 }, \"unknown\" },\n\n{{1,  300, 16, 16, 8000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  40, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 1, 0, 0, 0, 0, 0, 0, 0}, 3*HZ/2, 1 }, \"360K PC\" }, /*5 1/4 360 KB PC*/\n\n{{2,  500, 16, 16, 6000, 4*HZ/10, 3*HZ, 14, SEL_DLY, 6,  83, 3*HZ, 17, {3,1,2,0,2}, 0,\n      0, { 2, 5, 6,23,10,20,12, 0}, 3*HZ/2, 2 }, \"1.2M\" }, /*5 1/4 HD AT*/\n\n{{3,  250, 16, 16, 3000,    1*HZ, 3*HZ,  0, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 4,22,21,30, 3, 0, 0, 0}, 3*HZ/2, 4 }, \"720k\" }, /*3 1/2 DD*/\n\n{{4,  500, 16, 16, 4000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 20, {3,1,2,0,2}, 0,\n      0, { 7, 4,25,22,31,21,29,11}, 3*HZ/2, 7 }, \"1.44M\" }, /*3 1/2 HD*/\n\n{{5, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M AMI BIOS\" }, /*3 1/2 ED*/\n\n{{6, 1000, 15,  8, 3000, 4*HZ/10, 3*HZ, 10, SEL_DLY, 5,  83, 3*HZ, 40, {3,1,2,0,2}, 0,\n      0, { 7, 8, 4,25,28,22,31,21}, 3*HZ/2, 8 }, \"2.88M\" } /*3 1/2 ED*/\n/*    |  --autodetected formats---    |      |      |\n *    read_track                      |      |    Name printed when booting\n *\t\t\t\t      |     Native format\n *\t            Frequency of disk change checks */\n};\n\nstatic struct floppy_drive_params drive_params[N_DRIVE];\nstatic struct floppy_drive_struct drive_state[N_DRIVE];\nstatic struct floppy_write_errors write_errors[N_DRIVE];\nstatic struct timer_list motor_off_timer[N_DRIVE];\nstatic struct blk_mq_tag_set tag_sets[N_DRIVE];\nstatic struct block_device *opened_bdev[N_DRIVE];\nstatic DEFINE_MUTEX(open_lock);\nstatic struct floppy_raw_cmd *raw_cmd, default_raw_cmd;\n\n/*\n * This struct defines the different floppy types.\n *\n * Bit 0 of 'stretch' tells if the tracks need to be doubled for some\n * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of 'stretch'\n * tells if the disk is in Commodore 1581 format, which means side 0 sectors\n * are located on side 1 of the disk but with a side 0 ID, and vice-versa.\n * This is the same as the Sharp MZ-80 5.25\" CP/M disk format, except that the\n * 1581's logical side 0 is on physical side 1, whereas the Sharp's logical\n * side 0 is on physical side 0 (but with the misnamed sector IDs).\n * 'stretch' should probably be renamed to something more general, like\n * 'options'.\n *\n * Bits 2 through 9 of 'stretch' tell the number of the first sector.\n * The LSB (bit 2) is flipped. For most disks, the first sector\n * is 1 (represented by 0x00<<2).  For some CP/M and music sampler\n * disks (such as Ensoniq EPS 16plus) it is 0 (represented as 0x01<<2).\n * For Amstrad CPC disks it is 0xC1 (represented as 0xC0<<2).\n *\n * Other parameters should be self-explanatory (see also setfdprm(8)).\n */\n/*\n\t    Size\n\t     |  Sectors per track\n\t     |  | Head\n\t     |  | |  Tracks\n\t     |  | |  | Stretch\n\t     |  | |  | |  Gap 1 size\n\t     |  | |  | |    |  Data rate, | 0x40 for perp\n\t     |  | |  | |    |    |  Spec1 (stepping rate, head unload\n\t     |  | |  | |    |    |    |    /fmt gap (gap2) */\nstatic struct floppy_struct floppy_type[32] = {\n\t{    0, 0,0, 0,0,0x00,0x00,0x00,0x00,NULL    },\t/*  0 no testing    */\n\t{  720, 9,2,40,0,0x2A,0x02,0xDF,0x50,\"d360\"  }, /*  1 360KB PC      */\n\t{ 2400,15,2,80,0,0x1B,0x00,0xDF,0x54,\"h1200\" },\t/*  2 1.2MB AT      */\n\t{  720, 9,1,80,0,0x2A,0x02,0xDF,0x50,\"D360\"  },\t/*  3 360KB SS 3.5\" */\n\t{ 1440, 9,2,80,0,0x2A,0x02,0xDF,0x50,\"D720\"  },\t/*  4 720KB 3.5\"    */\n\t{  720, 9,2,40,1,0x23,0x01,0xDF,0x50,\"h360\"  },\t/*  5 360KB AT      */\n\t{ 1440, 9,2,80,0,0x23,0x01,0xDF,0x50,\"h720\"  },\t/*  6 720KB AT      */\n\t{ 2880,18,2,80,0,0x1B,0x00,0xCF,0x6C,\"H1440\" },\t/*  7 1.44MB 3.5\"   */\n\t{ 5760,36,2,80,0,0x1B,0x43,0xAF,0x54,\"E2880\" },\t/*  8 2.88MB 3.5\"   */\n\t{ 6240,39,2,80,0,0x1B,0x43,0xAF,0x28,\"E3120\" },\t/*  9 3.12MB 3.5\"   */\n\n\t{ 2880,18,2,80,0,0x25,0x00,0xDF,0x02,\"h1440\" }, /* 10 1.44MB 5.25\"  */\n\t{ 3360,21,2,80,0,0x1C,0x00,0xCF,0x0C,\"H1680\" }, /* 11 1.68MB 3.5\"   */\n\t{  820,10,2,41,1,0x25,0x01,0xDF,0x2E,\"h410\"  },\t/* 12 410KB 5.25\"   */\n\t{ 1640,10,2,82,0,0x25,0x02,0xDF,0x2E,\"H820\"  },\t/* 13 820KB 3.5\"    */\n\t{ 2952,18,2,82,0,0x25,0x00,0xDF,0x02,\"h1476\" },\t/* 14 1.48MB 5.25\"  */\n\t{ 3444,21,2,82,0,0x25,0x00,0xDF,0x0C,\"H1722\" },\t/* 15 1.72MB 3.5\"   */\n\t{  840,10,2,42,1,0x25,0x01,0xDF,0x2E,\"h420\"  },\t/* 16 420KB 5.25\"   */\n\t{ 1660,10,2,83,0,0x25,0x02,0xDF,0x2E,\"H830\"  },\t/* 17 830KB 3.5\"    */\n\t{ 2988,18,2,83,0,0x25,0x00,0xDF,0x02,\"h1494\" },\t/* 18 1.49MB 5.25\"  */\n\t{ 3486,21,2,83,0,0x25,0x00,0xDF,0x0C,\"H1743\" }, /* 19 1.74 MB 3.5\"  */\n\n\t{ 1760,11,2,80,0,0x1C,0x09,0xCF,0x00,\"h880\"  }, /* 20 880KB 5.25\"   */\n\t{ 2080,13,2,80,0,0x1C,0x01,0xCF,0x00,\"D1040\" }, /* 21 1.04MB 3.5\"   */\n\t{ 2240,14,2,80,0,0x1C,0x19,0xCF,0x00,\"D1120\" }, /* 22 1.12MB 3.5\"   */\n\t{ 3200,20,2,80,0,0x1C,0x20,0xCF,0x2C,\"h1600\" }, /* 23 1.6MB 5.25\"   */\n\t{ 3520,22,2,80,0,0x1C,0x08,0xCF,0x2e,\"H1760\" }, /* 24 1.76MB 3.5\"   */\n\t{ 3840,24,2,80,0,0x1C,0x20,0xCF,0x00,\"H1920\" }, /* 25 1.92MB 3.5\"   */\n\t{ 6400,40,2,80,0,0x25,0x5B,0xCF,0x00,\"E3200\" }, /* 26 3.20MB 3.5\"   */\n\t{ 7040,44,2,80,0,0x25,0x5B,0xCF,0x00,\"E3520\" }, /* 27 3.52MB 3.5\"   */\n\t{ 7680,48,2,80,0,0x25,0x63,0xCF,0x00,\"E3840\" }, /* 28 3.84MB 3.5\"   */\n\t{ 3680,23,2,80,0,0x1C,0x10,0xCF,0x00,\"H1840\" }, /* 29 1.84MB 3.5\"   */\n\n\t{ 1600,10,2,80,0,0x25,0x02,0xDF,0x2E,\"D800\"  },\t/* 30 800KB 3.5\"    */\n\t{ 3200,20,2,80,0,0x1C,0x00,0xCF,0x2C,\"H1600\" }, /* 31 1.6MB 3.5\"    */\n};\n\nstatic struct gendisk *disks[N_DRIVE][ARRAY_SIZE(floppy_type)];\n\n#define SECTSIZE (_FD_SECTSIZE(*floppy))\n\n/* Auto-detection: Disk type used until the next media change occurs. */\nstatic struct floppy_struct *current_type[N_DRIVE];\n\n/*\n * User-provided type information. current_type points to\n * the respective entry of this array.\n */\nstatic struct floppy_struct user_params[N_DRIVE];\n\nstatic sector_t floppy_sizes[256];\n\nstatic char floppy_device_name[] = \"floppy\";\n\n/*\n * The driver is trying to determine the correct media format\n * while probing is set. rw_interrupt() clears it after a\n * successful access.\n */\nstatic int probing;\n\n/* Synchronization of FDC access. */\n#define FD_COMMAND_NONE\t\t-1\n#define FD_COMMAND_ERROR\t2\n#define FD_COMMAND_OKAY\t\t3\n\nstatic volatile int command_status = FD_COMMAND_NONE;\nstatic unsigned long fdc_busy;\nstatic DECLARE_WAIT_QUEUE_HEAD(fdc_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(command_done);\n\n/* Errors during formatting are counted here. */\nstatic int format_errors;\n\n/* Format request descriptor. */\nstatic struct format_descr format_req;\n\n/*\n * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps\n * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),\n * H is head unload time (1=16ms, 2=32ms, etc)\n */\n\n/*\n * Track buffer\n * Because these are written to by the DMA controller, they must\n * not contain a 64k byte boundary crossing, or data will be\n * corrupted/lost.\n */\nstatic char *floppy_track_buffer;\nstatic int max_buffer_sectors;\n\nstatic int *errors;\ntypedef void (*done_f)(int);\nstatic const struct cont_t {\n\tvoid (*interrupt)(void);\n\t\t\t\t/* this is called after the interrupt of the\n\t\t\t\t * main command */\n\tvoid (*redo)(void);\t/* this is called to retry the operation */\n\tvoid (*error)(void);\t/* this is called to tally an error */\n\tdone_f done;\t\t/* this is called to say if the operation has\n\t\t\t\t * succeeded/failed */\n} *cont;\n\nstatic void floppy_ready(void);\nstatic void floppy_start(void);\nstatic void process_fd_request(void);\nstatic void recalibrate_floppy(void);\nstatic void floppy_shutdown(struct work_struct *);\n\nstatic int floppy_request_regions(int);\nstatic void floppy_release_regions(int);\nstatic int floppy_grab_irq_and_dma(void);\nstatic void floppy_release_irq_and_dma(void);\n\n/*\n * The \"reset\" variable should be tested whenever an interrupt is scheduled,\n * after the commands have been sent. This is to ensure that the driver doesn't\n * get wedged when the interrupt doesn't come because of a failed command.\n * reset doesn't need to be tested before sending commands, because\n * output_byte is automatically disabled when reset is set.\n */\nstatic void reset_fdc(void);\nstatic int floppy_revalidate(struct gendisk *disk);\n\n/*\n * These are global variables, as that's the easiest way to give\n * information to interrupts. They are the data used for the current\n * request.\n */\n#define NO_TRACK\t-1\n#define NEED_1_RECAL\t-2\n#define NEED_2_RECAL\t-3\n\nstatic atomic_t usage_count = ATOMIC_INIT(0);\n\n/* buffer related variables */\nstatic int buffer_track = -1;\nstatic int buffer_drive = -1;\nstatic int buffer_min = -1;\nstatic int buffer_max = -1;\n\n/* fdc related variables, should end up in a struct */\nstatic struct floppy_fdc_state fdc_state[N_FDC];\nstatic int current_fdc;\t\t\t/* current fdc */\n\nstatic struct workqueue_struct *floppy_wq;\n\nstatic struct floppy_struct *_floppy = floppy_type;\nstatic unsigned char current_drive;\nstatic long current_count_sectors;\nstatic unsigned char fsector_t;\t/* sector in track */\nstatic unsigned char in_sector_offset;\t/* offset within physical sector,\n\t\t\t\t\t * expressed in units of 512 bytes */\n\nstatic inline unsigned char fdc_inb(int fdc, int reg)\n{\n\treturn fd_inb(fdc_state[fdc].address, reg);\n}\n\nstatic inline void fdc_outb(unsigned char value, int fdc, int reg)\n{\n\tfd_outb(value, fdc_state[fdc].address, reg);\n}\n\nstatic inline bool drive_no_geom(int drive)\n{\n\treturn !current_type[drive] && !ITYPE(drive_state[drive].fd_device);\n}\n\n#ifndef fd_eject\nstatic inline int fd_eject(int drive)\n{\n\treturn -EINVAL;\n}\n#endif\n\n/*\n * Debugging\n * =========\n */\n#ifdef DEBUGT\nstatic long unsigned debugtimer;\n\nstatic inline void set_debugt(void)\n{\n\tdebugtimer = jiffies;\n}\n\nstatic inline void debugt(const char *func, const char *msg)\n{\n\tif (drive_params[current_drive].flags & DEBUGT)\n\t\tpr_info(\"%s:%s dtime=%lu\\n\", func, msg, jiffies - debugtimer);\n}\n#else\nstatic inline void set_debugt(void) { }\nstatic inline void debugt(const char *func, const char *msg) { }\n#endif /* DEBUGT */\n\n\nstatic DECLARE_DELAYED_WORK(fd_timeout, floppy_shutdown);\nstatic const char *timeout_message;\n\nstatic void is_alive(const char *func, const char *message)\n{\n\t/* this routine checks whether the floppy driver is \"alive\" */\n\tif (test_bit(0, &fdc_busy) && command_status < 2 &&\n\t    !delayed_work_pending(&fd_timeout)) {\n\t\tDPRINT(\"%s: timeout handler died.  %s\\n\", func, message);\n\t}\n}\n\nstatic void (*do_floppy)(void) = NULL;\n\n#define OLOGSIZE 20\n\nstatic void (*lasthandler)(void);\nstatic unsigned long interruptjiffies;\nstatic unsigned long resultjiffies;\nstatic int resultsize;\nstatic unsigned long lastredo;\n\nstatic struct output_log {\n\tunsigned char data;\n\tunsigned char status;\n\tunsigned long jiffies;\n} output_log[OLOGSIZE];\n\nstatic int output_log_pos;\n\n#define MAXTIMEOUT -2\n\nstatic void __reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long delay;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tdelay = 20UL * HZ;\n\t\tdrive = 0;\n\t} else\n\t\tdelay = drive_params[drive].timeout;\n\n\tmod_delayed_work(floppy_wq, &fd_timeout, delay);\n\tif (drive_params[drive].flags & FD_DEBUG)\n\t\tDPRINT(\"reschedule timeout %s\\n\", message);\n\ttimeout_message = message;\n}\n\nstatic void reschedule_timeout(int drive, const char *message)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&floppy_lock, flags);\n\t__reschedule_timeout(drive, message);\n\tspin_unlock_irqrestore(&floppy_lock, flags);\n}\n\n#define INFBOUND(a, b) (a) = max_t(int, a, b)\n#define SUPBOUND(a, b) (a) = min_t(int, a, b)\n\n/*\n * Bottom half floppy driver.\n * ==========================\n *\n * This part of the file contains the code talking directly to the hardware,\n * and also the main service loop (seek-configure-spinup-command)\n */\n\n/*\n * disk change.\n * This routine is responsible for maintaining the FD_DISK_CHANGE flag,\n * and the last_checked date.\n *\n * last_checked is the date of the last check which showed 'no disk change'\n * FD_DISK_CHANGE is set under two conditions:\n * 1. The floppy has been changed after some i/o to that floppy already\n *    took place.\n * 2. No floppy disk is in the drive. This is done in order to ensure that\n *    requests are quickly flushed in case there is no disk in the drive. It\n *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in\n *    the drive.\n *\n * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.\n * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on\n *  each seek. If a disk is present, the disk change line should also be\n *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk\n *  change line is set, this means either that no disk is in the drive, or\n *  that it has been removed since the last seek.\n *\n * This means that we really have a third possibility too:\n *  The floppy has been changed after the last seek.\n */\n\nstatic int disk_change(int drive)\n{\n\tint fdc = FDC(drive);\n\n\tif (time_before(jiffies, drive_state[drive].select_date + drive_params[drive].select_delay))\n\t\tDPRINT(\"WARNING disk change called early\\n\");\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))) ||\n\t    (fdc_state[fdc].dor & 3) != UNIT(drive) || fdc != FDC(drive)) {\n\t\tDPRINT(\"probing disk change on unselected drive\\n\");\n\t\tDPRINT(\"drive=%d fdc=%d dor=%x\\n\", drive, FDC(drive),\n\t\t       (unsigned int)fdc_state[fdc].dor);\n\t}\n\n\tdebug_dcl(drive_params[drive].flags,\n\t\t  \"checking disk change line for drive %d\\n\", drive);\n\tdebug_dcl(drive_params[drive].flags, \"jiffies=%lu\\n\", jiffies);\n\tdebug_dcl(drive_params[drive].flags, \"disk change line=%x\\n\",\n\t\t  fdc_inb(fdc, FD_DIR) & 0x80);\n\tdebug_dcl(drive_params[drive].flags, \"flags=%lx\\n\",\n\t\t  drive_state[drive].flags);\n\n\tif (drive_params[drive].flags & FD_BROKEN_DCL)\n\t\treturn test_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\tif ((fdc_inb(fdc, FD_DIR) ^ drive_params[drive].flags) & 0x80) {\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\t\t\t\t/* verify write protection */\n\n\t\tif (drive_state[drive].maxblock)\t/* mark it changed */\n\t\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\n\t\t/* invalidate its geometry */\n\t\tif (drive_state[drive].keep_data >= 0) {\n\t\t\tif ((drive_params[drive].flags & FTD_MSG) &&\n\t\t\t    current_type[drive] != NULL)\n\t\t\t\tDPRINT(\"Disk type is undefined after disk change\\n\");\n\t\t\tcurrent_type[drive] = NULL;\n\t\t\tfloppy_sizes[TOMINOR(drive)] = MAX_DISK_SIZE << 1;\n\t\t}\n\n\t\treturn 1;\n\t} else {\n\t\tdrive_state[drive].last_checked = jiffies;\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t}\n\treturn 0;\n}\n\nstatic inline int is_selected(int dor, int unit)\n{\n\treturn ((dor & (0x10 << unit)) && (dor & 3) == unit);\n}\n\nstatic bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}\n\nstatic int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (fdc_state[fdc].address == -1)\n\t\treturn -1;\n\n\tolddor = fdc_state[fdc].dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tfdc_state[fdc].dor = newdor;\n\t\tfdc_outb(newdor, fdc, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdrive_state[drive].select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n\nstatic void twaddle(int fdc, int drive)\n{\n\tif (drive_params[drive].select_delay)\n\t\treturn;\n\tfdc_outb(fdc_state[fdc].dor & ~(0x10 << UNIT(drive)),\n\t\t fdc, FD_DOR);\n\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\tdrive_state[drive].select_date = jiffies;\n}\n\n/*\n * Reset all driver information about the specified fdc.\n * This is needed after a reset, and after a raw command.\n */\nstatic void reset_fdc_info(int fdc, int mode)\n{\n\tint drive;\n\n\tfdc_state[fdc].spec1 = fdc_state[fdc].spec2 = -1;\n\tfdc_state[fdc].need_configure = 1;\n\tfdc_state[fdc].perp_mode = 1;\n\tfdc_state[fdc].rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc &&\n\t\t    (mode || drive_state[drive].track != NEED_1_RECAL))\n\t\t\tdrive_state[drive].track = NEED_2_RECAL;\n}\n\n/*\n * selects the fdc and drive, and enables the fdc's input/dma.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic void set_fdc(int drive)\n{\n\tunsigned int fdc;\n\n\tif (drive < 0 || drive >= N_DRIVE) {\n\t\tpr_info(\"bad drive value %d\\n\", drive);\n\t\treturn;\n\t}\n\n\tfdc = FDC(drive);\n\tif (fdc >= N_FDC) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (fdc_state[fdc].rawcmd == 2)\n\t\treset_fdc_info(fdc, 1);\n\tif (fdc_inb(fdc, FD_STATUS) != STATUS_READY)\n\t\tfdc_state[fdc].reset = 1;\n\n\tcurrent_drive = drive;\n\tcurrent_fdc = fdc;\n}\n\n/*\n * locks the driver.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic int lock_fdc(int drive)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"Trying to lock fdc while usage count=0\\n\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"lock fdc\");\n\tset_fdc(drive);\n\treturn 0;\n}\n\n/* unlocks the driver */\nstatic void unlock_fdc(void)\n{\n\tif (!test_bit(0, &fdc_busy))\n\t\tDPRINT(\"FDC access conflict!\\n\");\n\n\traw_cmd = NULL;\n\tcommand_status = FD_COMMAND_NONE;\n\tcancel_delayed_work(&fd_timeout);\n\tdo_floppy = NULL;\n\tcont = NULL;\n\tclear_bit(0, &fdc_busy);\n\twake_up(&fdc_wait);\n}\n\n/* switches the motor off after a given timeout */\nstatic void motor_off_callback(struct timer_list *t)\n{\n\tunsigned long nr = t - motor_off_timer;\n\tunsigned char mask = ~(0x10 << UNIT(nr));\n\n\tif (WARN_ON_ONCE(nr >= N_DRIVE))\n\t\treturn;\n\n\tset_dor(FDC(nr), mask, 0);\n}\n\n/* schedules motor off */\nstatic void floppy_off(unsigned int drive)\n{\n\tunsigned long volatile delta;\n\tint fdc = FDC(drive);\n\n\tif (!(fdc_state[fdc].dor & (0x10 << UNIT(drive))))\n\t\treturn;\n\n\tdel_timer(motor_off_timer + drive);\n\n\t/* make spindle stop in a position which minimizes spinup time\n\t * next time */\n\tif (drive_params[drive].rps) {\n\t\tdelta = jiffies - drive_state[drive].first_read_date + HZ -\n\t\t    drive_params[drive].spindown_offset;\n\t\tdelta = ((delta * drive_params[drive].rps) % HZ) / drive_params[drive].rps;\n\t\tmotor_off_timer[drive].expires =\n\t\t    jiffies + drive_params[drive].spindown - delta;\n\t}\n\tadd_timer(motor_off_timer + drive);\n}\n\n/*\n * cycle through all N_DRIVE floppy drives, for disk change testing.\n * stopping at current drive. This is done before any long operation, to\n * be sure to have up to date disk change information.\n */\nstatic void scandrives(void)\n{\n\tint i;\n\tint drive;\n\tint saved_drive;\n\n\tif (drive_params[current_drive].select_delay)\n\t\treturn;\n\n\tsaved_drive = current_drive;\n\tfor (i = 0; i < N_DRIVE; i++) {\n\t\tdrive = (saved_drive + i + 1) % N_DRIVE;\n\t\tif (drive_state[drive].fd_ref == 0 || drive_params[drive].select_delay != 0)\n\t\t\tcontinue;\t/* skip closed drives */\n\t\tset_fdc(drive);\n\t\tif (!(set_dor(current_fdc, ~3, UNIT(drive) | (0x10 << UNIT(drive))) &\n\t\t      (0x10 << UNIT(drive))))\n\t\t\t/* switch the motor off again, if it was off to\n\t\t\t * begin with */\n\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(drive)), 0);\n\t}\n\tset_fdc(saved_drive);\n}\n\nstatic void empty(void)\n{\n}\n\nstatic void (*floppy_work_fn)(void);\n\nstatic void floppy_work_workfn(struct work_struct *work)\n{\n\tfloppy_work_fn();\n}\n\nstatic DECLARE_WORK(floppy_work, floppy_work_workfn);\n\nstatic void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}\n\nstatic void (*fd_timer_fn)(void) = NULL;\n\nstatic void fd_timer_workfn(struct work_struct *work)\n{\n\tfd_timer_fn();\n}\n\nstatic DECLARE_DELAYED_WORK(fd_timer, fd_timer_workfn);\n\nstatic void cancel_activity(void)\n{\n\tdo_floppy = NULL;\n\tcancel_delayed_work_sync(&fd_timer);\n\tcancel_work_sync(&floppy_work);\n}\n\n/* this function makes sure that the disk stays in the drive during the\n * transfer */\nstatic void fd_watchdog(void)\n{\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from watchdog\\n\");\n\n\tif (disk_change(current_drive)) {\n\t\tDPRINT(\"disk removed during i/o\\n\");\n\t\tcancel_activity();\n\t\tcont->done(0);\n\t\treset_fdc();\n\t} else {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = fd_watchdog;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, HZ / 10);\n\t}\n}\n\nstatic void main_command_interrupt(void)\n{\n\tcancel_delayed_work(&fd_timer);\n\tcont->interrupt();\n}\n\n/* waits for a delay (spinup or select) to pass */\nstatic int fd_wait_for_completion(unsigned long expires,\n\t\t\t\t  void (*function)(void))\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\t/* do the reset during sleep to win time\n\t\t\t\t * if we don't need to sleep, it's a good\n\t\t\t\t * occasion anyways */\n\t\treturn 1;\n\t}\n\n\tif (time_before(jiffies, expires)) {\n\t\tcancel_delayed_work(&fd_timer);\n\t\tfd_timer_fn = function;\n\t\tqueue_delayed_work(floppy_wq, &fd_timer, expires - jiffies);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void setup_DMA(void)\n{\n\tunsigned long f;\n\n\tif (raw_cmd->length == 0) {\n\t\tprint_hex_dump(KERN_INFO, \"zero dma transfer size: \",\n\t\t\t       DUMP_PREFIX_NONE, 16, 1,\n\t\t\t       raw_cmd->fullcmd, raw_cmd->cmd_count, false);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE,\n\t\t\t fdc_state[current_fdc].address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = fdc_state[current_fdc].address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}\n\nstatic void show_floppy(int fdc);\n\n/* waits until the fdc becomes ready */\nstatic int wait_til_ready(int fdc)\n{\n\tint status;\n\tint counter;\n\n\tif (fdc_state[fdc].reset)\n\t\treturn -1;\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tstatus = fdc_inb(fdc, FD_STATUS);\n\t\tif (status & STATUS_READY)\n\t\t\treturn status;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"Getstatus times out (%x) on fdc %d\\n\", status, fdc);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n/* sends a command byte to the fdc */\nstatic int output_byte(int fdc, char byte)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status)) {\n\t\tfdc_outb(byte, fdc, FD_DATA);\n\t\toutput_log[output_log_pos].data = byte;\n\t\toutput_log[output_log_pos].status = status;\n\t\toutput_log[output_log_pos].jiffies = jiffies;\n\t\toutput_log_pos = (output_log_pos + 1) % OLOGSIZE;\n\t\treturn 0;\n\t}\n\tfdc_state[fdc].reset = 1;\n\tif (initialized) {\n\t\tDPRINT(\"Unable to send byte %x to FDC. Fdc=%x Status=%x\\n\",\n\t\t       byte, fdc, status);\n\t\tshow_floppy(fdc);\n\t}\n\treturn -1;\n}\n\n/* gets the response from the fdc */\nstatic int result(int fdc)\n{\n\tint i;\n\tint status = 0;\n\n\tfor (i = 0; i < FD_RAW_REPLY_SIZE; i++) {\n\t\tstatus = wait_til_ready(fdc);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fdc_inb(fdc, FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy(fdc);\n\t}\n\tfdc_state[fdc].reset = 1;\n\treturn -1;\n}\n\n#define MORE_OUTPUT -2\n/* does the fdc need more output? */\nstatic int need_more_output(int fdc)\n{\n\tint status = wait_til_ready(fdc);\n\n\tif (status < 0)\n\t\treturn -1;\n\n\tif (is_ready_state(status))\n\t\treturn MORE_OUTPUT;\n\n\treturn result(fdc);\n}\n\n/* Set perpendicular mode as required, based on data rate, if supported.\n * 82077 Now tested. 1Mbps data rate only possible with 82077-1.\n */\nstatic void perpendicular_mode(int fdc)\n{\n\tunsigned char perp_mode;\n\n\tif (raw_cmd->rate & 0x40) {\n\t\tswitch (raw_cmd->rate & 3) {\n\t\tcase 0:\n\t\t\tperp_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tperp_mode = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDPRINT(\"Invalid data rate for perpendicular mode!\\n\");\n\t\t\tcont->done(0);\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\t\t\t/*\n\t\t\t\t\t * convenient way to return to\n\t\t\t\t\t * redo without too much hassle\n\t\t\t\t\t * (deep stack et al.)\n\t\t\t\t\t */\n\t\t\treturn;\n\t\t}\n\t} else\n\t\tperp_mode = 0;\n\n\tif (fdc_state[fdc].perp_mode == perp_mode)\n\t\treturn;\n\tif (fdc_state[fdc].version >= FDC_82077_ORIG) {\n\t\toutput_byte(fdc, FD_PERPENDICULAR);\n\t\toutput_byte(fdc, perp_mode);\n\t\tfdc_state[fdc].perp_mode = perp_mode;\n\t} else if (perp_mode) {\n\t\tDPRINT(\"perpendicular mode not supported by this FDC.\\n\");\n\t}\n}\t\t\t\t/* perpendicular_mode */\n\nstatic int fifo_depth = 0xa;\nstatic int no_fifo;\n\nstatic int fdc_configure(int fdc)\n{\n\t/* Turn on FIFO */\n\toutput_byte(fdc, FD_CONFIGURE);\n\tif (need_more_output(fdc) != MORE_OUTPUT)\n\t\treturn 0;\n\toutput_byte(fdc, 0);\n\toutput_byte(fdc, 0x10 | (no_fifo & 0x20) | (fifo_depth & 0xf));\n\toutput_byte(fdc, 0);    /* pre-compensation from track 0 upwards */\n\treturn 1;\n}\n\n#define NOMINAL_DTR 500\n\n/* Issue a \"SPECIFY\" command to set the step rate time, head unload time,\n * head load time, and DMA disable flag to values needed by floppy.\n *\n * The value \"dtr\" is the data transfer rate in Kbps.  It is needed\n * to account for the data rate-based scaling done by the 82072 and 82077\n * FDC types.  This parameter is ignored for other types of FDCs (i.e.\n * 8272a).\n *\n * Note that changing the data transfer rate has a (probably deleterious)\n * effect on the parameters subject to scaling for 82072/82077 FDCs, so\n * fdc_specify is called again after each data transfer rate\n * change.\n *\n * srt: 1000 to 16000 in microseconds\n * hut: 16 to 240 milliseconds\n * hlt: 2 to 254 milliseconds\n *\n * These values are rounded up to the next highest available delay time.\n */\nstatic void fdc_specify(int fdc, int drive)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\n\tif (fdc_state[fdc].need_configure &&\n\t    fdc_state[fdc].version >= FDC_82072A) {\n\t\tfdc_configure(fdc);\n\t\tfdc_state[fdc].need_configure = 0;\n\t}\n\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (fdc_state[fdc].version >= FDC_82078) {\n\t\t\t/* chose the default rate table, not the one\n\t\t\t * where 1 = 2 Mbps */\n\t\t\toutput_byte(fdc, FD_DRIVESPEC);\n\t\t\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\t\t\toutput_byte(fdc, UNIT(drive));\n\t\t\t\toutput_byte(fdc, 0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\n\tif (fdc_state[fdc].version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t\thut_max_code = 0x0;\t/* 0==256msec*dtr0/dtr (not linear!) */\n\t}\n\n\t/* Convert step rate from microseconds to milliseconds and 4 bits */\n\tsrt = 16 - DIV_ROUND_UP(drive_params[drive].srt * scale_dtr / 1000,\n\t\t\t\tNOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\n\thlt = DIV_ROUND_UP(drive_params[drive].hlt * scale_dtr / 2,\n\t\t\t   NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\n\thut = DIV_ROUND_UP(drive_params[drive].hut * scale_dtr / 16,\n\t\t\t   NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\n\t/* If these parameters did not change, just return with success */\n\tif (fdc_state[fdc].spec1 != spec1 ||\n\t    fdc_state[fdc].spec2 != spec2) {\n\t\t/* Go ahead and set spec1 and spec2 */\n\t\toutput_byte(fdc, FD_SPECIFY);\n\t\toutput_byte(fdc, fdc_state[fdc].spec1 = spec1);\n\t\toutput_byte(fdc, fdc_state[fdc].spec2 = spec2);\n\t}\n}\t\t\t\t/* fdc_specify */\n\n/* Set the FDC's data transfer rate on behalf of the specified drive.\n * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue\n * of the specify command (i.e. using the fdc_specify function).\n */\nstatic int fdc_dtr(void)\n{\n\t/* If data rate not already set to desired value, set it. */\n\tif ((raw_cmd->rate & 3) == fdc_state[current_fdc].dtr)\n\t\treturn 0;\n\n\t/* Set dtr */\n\tfdc_outb(raw_cmd->rate & 3, current_fdc, FD_DCR);\n\n\t/* TODO: some FDC/drive combinations (C&T 82C711 with TEAC 1.2MB)\n\t * need a stabilization period of several milliseconds to be\n\t * enforced after data rate changes before R/W operations.\n\t * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)\n\t */\n\tfdc_state[current_fdc].dtr = raw_cmd->rate & 3;\n\treturn fd_wait_for_completion(jiffies + 2UL * HZ / 100, floppy_ready);\n}\t\t\t\t/* fdc_dtr */\n\nstatic void tell_sector(void)\n{\n\tpr_cont(\": track %d, head %d, sector %d, size %d\",\n\t\treply_buffer[R_TRACK], reply_buffer[R_HEAD],\n\t\treply_buffer[R_SECTOR],\n\t\treply_buffer[R_SIZECODE]);\n}\t\t\t\t/* tell_sector */\n\nstatic void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (reply_buffer[ST0] & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (reply_buffer[ST2] & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (reply_buffer[ST1] & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((reply_buffer[ST1] & (ST1_MAM | ST1_ND)) ||\n\t\t   (reply_buffer[ST2] & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (reply_buffer[ST2] & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (reply_buffer[ST2] & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\treply_buffer[ST0], reply_buffer[ST1],\n\t\t\treply_buffer[ST2]);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n\n/*\n * OK, this error interpreting routine is called after a\n * DMA read/write has succeeded\n * or failed, so we check the results, and copy any buffers.\n * hhb: Added better error reporting.\n * ak: Made this into a separate routine.\n */\nstatic int interpret_errors(void)\n{\n\tchar bad;\n\n\tif (inr != 7) {\n\t\tDPRINT(\"-- FDC reply error\\n\");\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn 1;\n\t}\n\n\t/* check IC to find cause of interrupt */\n\tswitch (reply_buffer[ST0] & ST0_INTR) {\n\tcase 0x40:\t\t/* error occurred during command execution */\n\t\tif (reply_buffer[ST1] & ST1_EOC)\n\t\t\treturn 0;\t/* occurs with pseudo-DMA */\n\t\tbad = 1;\n\t\tif (reply_buffer[ST1] & ST1_WP) {\n\t\t\tDPRINT(\"Drive is write protected\\n\");\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tcont->done(0);\n\t\t\tbad = 2;\n\t\t} else if (reply_buffer[ST1] & ST1_ND) {\n\t\t\tset_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t\t&drive_state[current_drive].flags);\n\t\t} else if (reply_buffer[ST1] & ST1_OR) {\n\t\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\t\tDPRINT(\"Over/Underrun - retrying\\n\");\n\t\t\tbad = 0;\n\t\t} else if (*errors >= drive_params[current_drive].max_errors.reporting) {\n\t\t\tprint_errors();\n\t\t}\n\t\tif (reply_buffer[ST2] & ST2_WC || reply_buffer[ST2] & ST2_BC)\n\t\t\t/* wrong cylinder => recal */\n\t\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\treturn bad;\n\tcase 0x80:\t\t/* invalid command given */\n\t\tDPRINT(\"Invalid FDC command given!\\n\");\n\t\tcont->done(0);\n\t\treturn 2;\n\tcase 0xc0:\n\t\tDPRINT(\"Abnormal termination caused by polling\\n\");\n\t\tcont->error();\n\t\treturn 2;\n\tdefault:\t\t/* (0) Normal command termination */\n\t\treturn 0;\n\t}\n}\n\n/*\n * This routine is called when everything should be correctly set up\n * for the transfer (i.e. floppy motor is on, the correct floppy is\n * selected, and the head is sitting on the right track).\n */\nstatic void setup_rw_floppy(void)\n{\n\tint i;\n\tint r;\n\tint flags;\n\tunsigned long ready_date;\n\tvoid (*function)(void);\n\n\tflags = raw_cmd->flags;\n\tif (flags & (FD_RAW_READ | FD_RAW_WRITE))\n\t\tflags |= FD_RAW_INTR;\n\n\tif ((flags & FD_RAW_SPIN) && !(flags & FD_RAW_NO_MOTOR)) {\n\t\tready_date = drive_state[current_drive].spinup_date + drive_params[current_drive].spinup;\n\t\t/* If spinup will take a long time, rerun scandrives\n\t\t * again just before spinup completion. Beware that\n\t\t * after scandrives, we must again wait for selection.\n\t\t */\n\t\tif (time_after(ready_date, jiffies + drive_params[current_drive].select_delay)) {\n\t\t\tready_date -= drive_params[current_drive].select_delay;\n\t\t\tfunction = floppy_start;\n\t\t} else\n\t\t\tfunction = setup_rw_floppy;\n\n\t\t/* wait until the floppy is spinning fast enough */\n\t\tif (fd_wait_for_completion(ready_date, function))\n\t\t\treturn;\n\t}\n\tif ((flags & FD_RAW_READ) || (flags & FD_RAW_WRITE))\n\t\tsetup_DMA();\n\n\tif (flags & FD_RAW_INTR)\n\t\tdo_floppy = main_command_interrupt;\n\n\tr = 0;\n\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\tr |= output_byte(current_fdc, raw_cmd->fullcmd[i]);\n\n\tdebugt(__func__, \"rw_command\");\n\n\tif (r) {\n\t\tcont->error();\n\t\treset_fdc();\n\t\treturn;\n\t}\n\n\tif (!(flags & FD_RAW_INTR)) {\n\t\tinr = result(current_fdc);\n\t\tcont->interrupt();\n\t} else if (flags & FD_RAW_NEED_DISK)\n\t\tfd_watchdog();\n}\n\nstatic int blind_seek;\n\n/*\n * This is the routine called after every seek (or recalibrate) interrupt\n * from the floppy controller.\n */\nstatic void seek_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2 || (reply_buffer[ST0] & 0xF8) != 0x20) {\n\t\tDPRINT(\"seek failed\\n\");\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n\t\tcont->error();\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track >= 0 &&\n\t    drive_state[current_drive].track != reply_buffer[ST1] &&\n\t    !blind_seek) {\n\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t  \"clearing NEWCHANGE flag because of effective seek\\n\");\n\t\tdebug_dcl(drive_params[current_drive].flags, \"jiffies=%lu\\n\",\n\t\t\t  jiffies);\n\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t  &drive_state[current_drive].flags);\n\t\t\t\t\t/* effective seek */\n\t\tdrive_state[current_drive].select_date = jiffies;\n\t}\n\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void check_wp(int fdc, int drive)\n{\n\tif (test_bit(FD_VERIFY_BIT, &drive_state[drive].flags)) {\n\t\t\t\t\t/* check write protection */\n\t\toutput_byte(fdc, FD_GETSTATUS);\n\t\toutput_byte(fdc, UNIT(drive));\n\t\tif (result(fdc) != 1) {\n\t\t\tfdc_state[fdc].reset = 1;\n\t\t\treturn;\n\t\t}\n\t\tclear_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tclear_bit(FD_NEED_TWADDLE_BIT,\n\t\t\t  &drive_state[drive].flags);\n\t\tdebug_dcl(drive_params[drive].flags,\n\t\t\t  \"checking whether disk is write protected\\n\");\n\t\tdebug_dcl(drive_params[drive].flags, \"wp=%x\\n\",\n\t\t\t  reply_buffer[ST3] & 0x40);\n\t\tif (!(reply_buffer[ST3] & 0x40))\n\t\t\tset_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t&drive_state[drive].flags);\n\t\telse\n\t\t\tclear_bit(FD_DISK_WRITABLE_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t}\n}\n\nstatic void seek_floppy(void)\n{\n\tint track;\n\n\tblind_seek = 0;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from %s\\n\", __func__);\n\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\t/* the media changed flag should be cleared after the seek.\n\t\t * If it isn't, this means that there is really no disk in\n\t\t * the drive.\n\t\t */\n\t\tset_bit(FD_DISK_CHANGED_BIT,\n\t\t\t&drive_state[current_drive].flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (drive_state[current_drive].track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (drive_state[current_drive].track <= NO_TRACK || drive_state[current_drive].track == raw_cmd->track)) {\n\t\t/* we seek to clear the media-changed condition. Does anybody\n\t\t * know a more elegant way, which works on all drives? */\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (drive_params[current_drive].flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(current_fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp(current_fdc, current_drive);\n\t\tif (raw_cmd->track != drive_state[current_drive].track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdo_floppy = seek_interrupt;\n\toutput_byte(current_fdc, FD_SEEK);\n\toutput_byte(current_fdc, UNIT(current_drive));\n\tif (output_byte(current_fdc, track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}\n\nstatic void recal_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tif (inr != 2)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (reply_buffer[ST0] & ST0_ECE) {\n\t\tswitch (drive_state[current_drive].track) {\n\t\tcase NEED_1_RECAL:\n\t\t\tdebugt(__func__, \"need 1 recal\");\n\t\t\t/* after a second recalibrate, we still haven't\n\t\t\t * reached track 0. Probably no drive. Raise an\n\t\t\t * error, as failing immediately might upset\n\t\t\t * computers possessed by the Devil :-) */\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\tcase NEED_2_RECAL:\n\t\t\tdebugt(__func__, \"need 2 recal\");\n\t\t\t/* If we already did a recalibrate,\n\t\t\t * and we are not at track 0, this\n\t\t\t * means we have moved. (The only way\n\t\t\t * not to move at recalibration is to\n\t\t\t * be already at track 0.) Clear the\n\t\t\t * new change flag */\n\t\t\tdebug_dcl(drive_params[current_drive].flags,\n\t\t\t\t  \"clearing NEWCHANGE flag because of second recalibrate\\n\");\n\n\t\t\tclear_bit(FD_DISK_NEWCHANGE_BIT,\n\t\t\t\t  &drive_state[current_drive].flags);\n\t\t\tdrive_state[current_drive].select_date = jiffies;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tdebugt(__func__, \"default\");\n\t\t\t/* Recalibrate moves the head by at\n\t\t\t * most 80 steps. If after one\n\t\t\t * recalibrate we don't have reached\n\t\t\t * track 0, this might mean that we\n\t\t\t * started beyond track 80.  Try\n\t\t\t * again.  */\n\t\t\tdrive_state[current_drive].track = NEED_1_RECAL;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tdrive_state[current_drive].track = reply_buffer[ST1];\n\tfloppy_ready();\n}\n\nstatic void print_result(char *message, int inr)\n{\n\tint i;\n\n\tDPRINT(\"%s \", message);\n\tif (inr >= 0)\n\t\tfor (i = 0; i < inr; i++)\n\t\t\tpr_cont(\"repl[%d]=%x \", i, reply_buffer[i]);\n\tpr_cont(\"\\n\");\n}\n\n/* interrupt handler. Note that this can be called externally on the Sparc */\nirqreturn_t floppy_interrupt(int irq, void *dev_id)\n{\n\tint do_print;\n\tunsigned long f;\n\tvoid (*handler)(void) = do_floppy;\n\n\tlasthandler = handler;\n\tinterruptjiffies = jiffies;\n\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(f);\n\n\tdo_floppy = NULL;\n\tif (current_fdc >= N_FDC || fdc_state[current_fdc].address == -1) {\n\t\t/* we don't even know which FDC is the culprit */\n\t\tpr_info(\"DOR0=%x\\n\", fdc_state[0].dor);\n\t\tpr_info(\"floppy interrupt on bizarre fdc %d\\n\", current_fdc);\n\t\tpr_info(\"handler=%ps\\n\", handler);\n\t\tis_alive(__func__, \"bizarre fdc\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tfdc_state[current_fdc].reset = 0;\n\t/* We have to clear the reset flag here, because apparently on boxes\n\t * with level triggered interrupts (PS/2, Sparc, ...), it is needed to\n\t * emit SENSEI's to clear the interrupt line. And fdc_state[fdc].reset\n\t * blocks the emission of the SENSEI's.\n\t * It is OK to emit floppy commands because we are in an interrupt\n\t * handler here, and thus we have to fear no interference of other\n\t * activity.\n\t */\n\n\tdo_print = !handler && print_unex && initialized;\n\n\tinr = result(current_fdc);\n\tif (do_print)\n\t\tprint_result(\"unexpected interrupt\", inr);\n\tif (inr == 0) {\n\t\tint max_sensei = 4;\n\t\tdo {\n\t\t\toutput_byte(current_fdc, FD_SENSEI);\n\t\t\tinr = result(current_fdc);\n\t\t\tif (do_print)\n\t\t\t\tprint_result(\"sensei\", inr);\n\t\t\tmax_sensei--;\n\t\t} while ((reply_buffer[ST0] & 0x83) != UNIT(current_drive) &&\n\t\t\t inr == 2 && max_sensei);\n\t}\n\tif (!handler) {\n\t\tfdc_state[current_fdc].reset = 1;\n\t\treturn IRQ_NONE;\n\t}\n\tschedule_bh(handler);\n\tis_alive(__func__, \"normal interrupt end\");\n\n\t/* FIXME! Was it really for us? */\n\treturn IRQ_HANDLED;\n}\n\nstatic void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(current_fdc, FD_RECALIBRATE);\n\tif (output_byte(current_fdc, UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}\n\n/*\n * Must do 4 FD_SENSEIs after reset because of ``drive polling''.\n */\nstatic void reset_interrupt(void)\n{\n\tdebugt(__func__, \"\");\n\tresult(current_fdc);\t\t/* get the status ready for set_fdc */\n\tif (fdc_state[current_fdc].reset) {\n\t\tpr_info(\"reset set in interrupt, calling %ps\\n\", cont->error);\n\t\tcont->error();\t/* a reset just after a reset. BAD! */\n\t}\n\tcont->redo();\n}\n\n/*\n * reset is done by pulling bit 2 of DOR low for a while (old FDCs),\n * or by setting the self clearing bit 7 of STATUS (newer FDCs).\n * This WILL trigger an interrupt, causing the handlers in the current\n * cont's ->redo() to be called via reset_interrupt().\n */\nstatic void reset_fdc(void)\n{\n\tunsigned long flags;\n\n\tdo_floppy = reset_interrupt;\n\tfdc_state[current_fdc].reset = 0;\n\treset_fdc_info(current_fdc, 0);\n\n\t/* Pseudo-DMA may intercept 'reset finished' interrupt.  */\n\t/* Irrelevant for systems with true DMA (i386).          */\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\tif (fdc_state[current_fdc].version >= FDC_82072A)\n\t\tfdc_outb(0x80 | (fdc_state[current_fdc].dtr & 3),\n\t\t\t current_fdc, FD_STATUS);\n\telse {\n\t\tfdc_outb(fdc_state[current_fdc].dor & ~0x04, current_fdc, FD_DOR);\n\t\tudelay(FD_RESET_DELAY);\n\t\tfdc_outb(fdc_state[current_fdc].dor, current_fdc, FD_DOR);\n\t}\n}\n\nstatic void show_floppy(int fdc)\n{\n\tint i;\n\n\tpr_info(\"\\n\");\n\tpr_info(\"floppy driver state\\n\");\n\tpr_info(\"-------------------\\n\");\n\tpr_info(\"now=%lu last interrupt=%lu diff=%lu last called handler=%ps\\n\",\n\t\tjiffies, interruptjiffies, jiffies - interruptjiffies,\n\t\tlasthandler);\n\n\tpr_info(\"timeout_message=%s\\n\", timeout_message);\n\tpr_info(\"last output bytes:\\n\");\n\tfor (i = 0; i < OLOGSIZE; i++)\n\t\tpr_info(\"%2x %2x %lu\\n\",\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].data,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].status,\n\t\t\toutput_log[(i + output_log_pos) % OLOGSIZE].jiffies);\n\tpr_info(\"last result at %lu\\n\", resultjiffies);\n\tpr_info(\"last redo_fd_request at %lu\\n\", lastredo);\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1,\n\t\t       reply_buffer, resultsize, true);\n\n\tpr_info(\"status=%x\\n\", fdc_inb(fdc, FD_STATUS));\n\tpr_info(\"fdc_busy=%lu\\n\", fdc_busy);\n\tif (do_floppy)\n\t\tpr_info(\"do_floppy=%ps\\n\", do_floppy);\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"floppy_work.func=%ps\\n\", floppy_work.func);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"delayed work.function=%p expires=%ld\\n\",\n\t\t       fd_timer.work.func,\n\t\t       fd_timer.timer.expires - jiffies);\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"timer_function=%p expires=%ld\\n\",\n\t\t       fd_timeout.work.func,\n\t\t       fd_timeout.timer.expires - jiffies);\n\n\tpr_info(\"cont=%p\\n\", cont);\n\tpr_info(\"current_req=%p\\n\", current_req);\n\tpr_info(\"command_status=%d\\n\", command_status);\n\tpr_info(\"\\n\");\n}\n\nstatic void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\n\tif (initialized)\n\t\tshow_floppy(current_fdc);\n\tcancel_activity();\n\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\n\t/* avoid dma going to a random drive after shutdown */\n\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tfdc_state[current_fdc].reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t/* this will recall reset when needed */\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}\n\n/* start motor, check media-changed condition and write protection */\nstatic int start_motor(void (*function)(void))\n{\n\tint mask;\n\tint data;\n\n\tmask = 0xfc;\n\tdata = UNIT(current_drive);\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR)) {\n\t\tif (!(fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))) {\n\t\t\tset_debugt();\n\t\t\t/* no read since this drive is running */\n\t\t\tdrive_state[current_drive].first_read_date = 0;\n\t\t\t/* note motor start time if motor is not yet running */\n\t\t\tdrive_state[current_drive].spinup_date = jiffies;\n\t\t\tdata |= (0x10 << UNIT(current_drive));\n\t\t}\n\t} else if (fdc_state[current_fdc].dor & (0x10 << UNIT(current_drive)))\n\t\tmask &= ~(0x10 << UNIT(current_drive));\n\n\t/* starts motor and selects floppy */\n\tdel_timer(motor_off_timer + current_drive);\n\tset_dor(current_fdc, mask, data);\n\n\t/* wait_for_completion also schedules reset if needed. */\n\treturn fd_wait_for_completion(drive_state[current_drive].select_date + drive_params[current_drive].select_delay,\n\t\t\t\t      function);\n}\n\nstatic void floppy_ready(void)\n{\n\tif (fdc_state[current_fdc].reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !drive_params[current_drive].select_delay)\n\t\ttwaddle(current_fdc, current_drive);\t/* this clears the dcl on certain\n\t\t\t\t * drive/controller combinations */\n\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode(current_fdc);\n\t\tfdc_specify(current_fdc, current_drive); /* must be done here because of hut, hlt ... */\n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify(current_fdc, current_drive);\n\t\tsetup_rw_floppy();\n\t}\n}\n\nstatic void floppy_start(void)\n{\n\treschedule_timeout(current_drive, \"floppy start\");\n\n\tscandrives();\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in floppy_start\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\tfloppy_ready();\n}\n\n/*\n * ========================================================================\n * here ends the bottom half. Exported routines are:\n * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,\n * start_motor, reset_fdc, reset_fdc_info, interpret_errors.\n * Initialization also uses output_byte, result, set_dor, floppy_interrupt\n * and set_dor.\n * ========================================================================\n */\n/*\n * General purpose continuations.\n * ==============================\n */\n\nstatic void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}\n\nstatic const struct cont_t wakeup_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= do_wakeup,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\nstatic const struct cont_t intr_cont = {\n\t.interrupt\t= empty,\n\t.redo\t\t= process_fd_request,\n\t.error\t\t= empty,\n\t.done\t\t= (done_f)empty\n};\n\n/* schedules handler, waiting for completion. May be interrupted, will then\n * return -EINTR, in which case the driver will automatically be unlocked.\n */\nstatic int wait_til_done(void (*handler)(void), bool interruptible)\n{\n\tint ret;\n\n\tschedule_bh(handler);\n\n\tif (interruptible)\n\t\twait_event_interruptible(command_done, command_status >= 2);\n\telse\n\t\twait_event(command_done, command_status >= 2);\n\n\tif (command_status < 2) {\n\t\tcancel_activity();\n\t\tcont = &intr_cont;\n\t\treset_fdc();\n\t\treturn -EINTR;\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\tcommand_status = FD_COMMAND_ERROR;\n\tif (command_status == FD_COMMAND_OKAY)\n\t\tret = 0;\n\telse\n\t\tret = -EIO;\n\tcommand_status = FD_COMMAND_NONE;\n\treturn ret;\n}\n\nstatic void generic_done(int result)\n{\n\tcommand_status = result;\n\tcont = &wakeup_cont;\n}\n\nstatic void generic_success(void)\n{\n\tcont->done(1);\n}\n\nstatic void generic_failure(void)\n{\n\tcont->done(0);\n}\n\nstatic void success_and_wakeup(void)\n{\n\tgeneric_success();\n\tcont->redo();\n}\n\n/*\n * formatting and rw support.\n * ==========================\n */\n\nstatic int next_valid_format(int drive)\n{\n\tint probed_format;\n\n\tprobed_format = drive_state[drive].probed_format;\n\twhile (1) {\n\t\tif (probed_format >= FD_AUTODETECT_SIZE ||\n\t\t    !drive_params[drive].autodetect[probed_format]) {\n\t\t\tdrive_state[drive].probed_format = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tif (floppy_type[drive_params[drive].autodetect[probed_format]].sect) {\n\t\t\tdrive_state[drive].probed_format = probed_format;\n\t\t\treturn 0;\n\t\t}\n\t\tprobed_format++;\n\t}\n}\n\nstatic void bad_flp_intr(void)\n{\n\tint err_count;\n\n\tif (probing) {\n\t\tdrive_state[current_drive].probed_format++;\n\t\tif (!next_valid_format(current_drive))\n\t\t\treturn;\n\t}\n\terr_count = ++(*errors);\n\tINFBOUND(write_errors[current_drive].badness, err_count);\n\tif (err_count > drive_params[current_drive].max_errors.abort)\n\t\tcont->done(0);\n\tif (err_count > drive_params[current_drive].max_errors.reset)\n\t\tfdc_state[current_fdc].reset = 1;\n\telse if (err_count > drive_params[current_drive].max_errors.recal)\n\t\tdrive_state[current_drive].track = NEED_2_RECAL;\n}\n\nstatic void set_floppy(int drive)\n{\n\tint type = ITYPE(drive_state[drive].fd_device);\n\n\tif (type)\n\t\t_floppy = floppy_type + type;\n\telse\n\t\t_floppy = current_type[drive];\n}\n\n/*\n * formatting support.\n * ===================\n */\nstatic void format_interrupt(void)\n{\n\tswitch (interpret_errors()) {\n\tcase 1:\n\t\tcont->error();\n\tcase 2:\n\t\tbreak;\n\tcase 0:\n\t\tcont->done(1);\n\t}\n\tcont->redo();\n}\n\n#define FM_MODE(x, y) ((y) & ~(((x)->rate & 0x80) >> 1))\n#define CT(x) ((x) | 0xc0)\n\nstatic void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_FORMAT);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\traw_cmd->cmd[F_SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->cmd[F_SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[F_SIZECODE];\n\traw_cmd->cmd[F_GAP] = _floppy->fmt_gap;\n\traw_cmd->cmd[F_FILL] = FD_FILL_BYTE;\n\n\traw_cmd->kernel_data = floppy_track_buffer;\n\traw_cmd->length = 4 * raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\tif (!raw_cmd->cmd[F_SECT_PER_TRACK])\n\t\treturn;\n\n\t/* allow for about 30ms for data transport per track */\n\thead_shift = (raw_cmd->cmd[F_SECT_PER_TRACK] + 5) / 6;\n\n\t/* a ``cylinder'' is two tracks plus a little stepping time */\n\ttrack_shift = 2 * head_shift + 3;\n\n\t/* position of logical sector 1 on this track */\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % raw_cmd->cmd[F_SECT_PER_TRACK];\n\n\t/* determine interleave */\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\n\t/* initialize field */\n\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = raw_cmd->cmd[F_SIZECODE];\n\t}\n\t/* place logical sectors */\n\tfor (count = 1; count <= raw_cmd->cmd[F_SECT_PER_TRACK]; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\tif (here[n].sect) {\t/* sector busy, find next free sector */\n\t\t\t++n;\n\t\t\tif (n >= raw_cmd->cmd[F_SECT_PER_TRACK]) {\n\t\t\t\tn -= raw_cmd->cmd[F_SECT_PER_TRACK];\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < raw_cmd->cmd[F_SECT_PER_TRACK]; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}\n\nstatic void redo_format(void)\n{\n\tbuffer_track = -1;\n\tsetup_format_params(format_req.track << STRETCH(_floppy));\n\tfloppy_start();\n\tdebugt(__func__, \"queue format request\");\n}\n\nstatic const struct cont_t format_cont = {\n\t.interrupt\t= format_interrupt,\n\t.redo\t\t= redo_format,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= generic_done\n};\n\nstatic int do_format(int drive, struct format_descr *tmp_format_req)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tset_floppy(drive);\n\tif (!_floppy ||\n\t    _floppy->track > drive_params[current_drive].tracks ||\n\t    tmp_format_req->track >= _floppy->track ||\n\t    tmp_format_req->head >= _floppy->head ||\n\t    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||\n\t    !_floppy->fmt_gap) {\n\t\tprocess_fd_request();\n\t\treturn -EINVAL;\n\t}\n\tformat_req = *tmp_format_req;\n\tformat_errors = 0;\n\tcont = &format_cont;\n\terrors = &format_errors;\n\tret = wait_til_done(redo_format, true);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}\n\n/*\n * Buffer read/write and support\n * =============================\n */\n\nstatic void floppy_end_request(struct request *req, blk_status_t error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->rq_disk->private_data;\n\n\t/* current_count_sectors can be zero if transfer failed */\n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (blk_update_request(req, error, nr_sectors << 9))\n\t\treturn;\n\t__blk_mq_end_request(req, error);\n\n\t/* We're done with the request */\n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}\n\n/* new request_done. Can handle physical sectors which are smaller than a\n * logical buffer */\nstatic void request_done(int uptodate)\n{\n\tstruct request *req = current_req;\n\tint block;\n\tchar msg[sizeof(\"request done \") + sizeof(int) * 3];\n\n\tprobing = 0;\n\tsnprintf(msg, sizeof(msg), \"request done %d\", uptodate);\n\treschedule_timeout(MAXTIMEOUT, msg);\n\n\tif (!req) {\n\t\tpr_info(\"floppy.c: no request in request_done\\n\");\n\t\treturn;\n\t}\n\n\tif (uptodate) {\n\t\t/* maintain values for invalidation on geometry\n\t\t * change */\n\t\tblock = current_count_sectors + blk_rq_pos(req);\n\t\tINFBOUND(drive_state[current_drive].maxblock, block);\n\t\tif (block > _floppy->sect)\n\t\t\tdrive_state[current_drive].maxtrack = 1;\n\n\t\tfloppy_end_request(req, 0);\n\t} else {\n\t\tif (rq_data_dir(req) == WRITE) {\n\t\t\t/* record write error information */\n\t\t\twrite_errors[current_drive].write_errors++;\n\t\t\tif (write_errors[current_drive].write_errors == 1) {\n\t\t\t\twrite_errors[current_drive].first_error_sector = blk_rq_pos(req);\n\t\t\t\twrite_errors[current_drive].first_error_generation = drive_state[current_drive].generation;\n\t\t\t}\n\t\t\twrite_errors[current_drive].last_error_sector = blk_rq_pos(req);\n\t\t\twrite_errors[current_drive].last_error_generation = drive_state[current_drive].generation;\n\t\t}\n\t\tfloppy_end_request(req, BLK_STS_IOERR);\n\t}\n}\n\n/* Interrupt handler evaluating the result of the r/w operation */\nstatic void rw_interrupt(void)\n{\n\tint eoc;\n\tint ssize;\n\tint heads;\n\tint nr_sectors;\n\n\tif (reply_buffer[R_HEAD] >= 2) {\n\t\t/* some Toshiba floppy controllers occasionnally seem to\n\t\t * return bogus interrupts after read/write operations, which\n\t\t * can be recognized by a bad head number (>= 2) */\n\t\treturn;\n\t}\n\n\tif (!drive_state[current_drive].first_read_date)\n\t\tdrive_state[current_drive].first_read_date = jiffies;\n\n\tnr_sectors = 0;\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\n\tif (reply_buffer[ST1] & ST1_EOC)\n\t\teoc = 1;\n\telse\n\t\teoc = 0;\n\n\tif (raw_cmd->cmd[COMMAND] & 0x80)\n\t\theads = 2;\n\telse\n\t\theads = 1;\n\n\tnr_sectors = (((reply_buffer[R_TRACK] - raw_cmd->cmd[TRACK]) * heads +\n\t\t       reply_buffer[R_HEAD] - raw_cmd->cmd[HEAD]) * raw_cmd->cmd[SECT_PER_TRACK] +\n\t\t      reply_buffer[R_SECTOR] - raw_cmd->cmd[SECTOR] + eoc) << raw_cmd->cmd[SIZECODE] >> 2;\n\n\tif (nr_sectors / ssize >\n\t    DIV_ROUND_UP(in_sector_offset + current_count_sectors, ssize)) {\n\t\tDPRINT(\"long rw: %x instead of %lx\\n\",\n\t\t       nr_sectors, current_count_sectors);\n\t\tpr_info(\"rs=%d s=%d\\n\", reply_buffer[R_SECTOR],\n\t\t\traw_cmd->cmd[SECTOR]);\n\t\tpr_info(\"rh=%d h=%d\\n\", reply_buffer[R_HEAD],\n\t\t\traw_cmd->cmd[HEAD]);\n\t\tpr_info(\"rt=%d t=%d\\n\", reply_buffer[R_TRACK],\n\t\t\traw_cmd->cmd[TRACK]);\n\t\tpr_info(\"heads=%d eoc=%d\\n\", heads, eoc);\n\t\tpr_info(\"spt=%d st=%d ss=%d\\n\",\n\t\t\traw_cmd->cmd[SECT_PER_TRACK], fsector_t, ssize);\n\t\tpr_info(\"in_sector_offset=%d\\n\", in_sector_offset);\n\t}\n\n\tnr_sectors -= in_sector_offset;\n\tINFBOUND(nr_sectors, 0);\n\tSUPBOUND(current_count_sectors, nr_sectors);\n\n\tswitch (interpret_errors()) {\n\tcase 2:\n\t\tcont->redo();\n\t\treturn;\n\tcase 1:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->error();\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase 0:\n\t\tif (!current_count_sectors) {\n\t\t\tcont->redo();\n\t\t\treturn;\n\t\t}\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tbreak;\n\t}\n\n\tif (probing) {\n\t\tif (drive_params[current_drive].flags & FTD_MSG)\n\t\t\tDPRINT(\"Auto-detected floppy type %s in fd%d\\n\",\n\t\t\t       _floppy->name, current_drive);\n\t\tcurrent_type[current_drive] = _floppy;\n\t\tfloppy_sizes[TOMINOR(current_drive)] = _floppy->size;\n\t\tprobing = 0;\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) != FD_READ ||\n\t    raw_cmd->kernel_data == bio_data(current_req->bio)) {\n\t\t/* transfer directly from buffer */\n\t\tcont->done(1);\n\t} else if (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tINFBOUND(buffer_max, nr_sectors + fsector_t);\n\t}\n\tcont->redo();\n}\n\n/* Compute maximal contiguous buffer size. */\nstatic int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\n\t\tsize += bv.bv_len;\n\t}\n\n\treturn size >> 9;\n}\n\n/* Compute the maximal transfer size */\nstatic int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t/* alignment */\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t/* transfer size, beginning not aligned */\n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n\n/*\n * Move data from/to the track buffer to/from the buffer cache.\n */\nstatic void copy_buffer(int ssize, int max_sector, int max_sector_2)\n{\n\tint remaining;\t\t/* number of transferred 512-byte sectors */\n\tstruct bio_vec bv;\n\tchar *buffer;\n\tchar *dma_buffer;\n\tint size;\n\tstruct req_iterator iter;\n\n\tmax_sector = transfer_size(ssize,\n\t\t\t\t   min(max_sector, max_sector_2),\n\t\t\t\t   blk_rq_sectors(current_req));\n\n\tif (current_count_sectors <= 0 && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t    buffer_max > fsector_t + blk_rq_sectors(current_req))\n\t\tcurrent_count_sectors = min_t(int, buffer_max - fsector_t,\n\t\t\t\t\t      blk_rq_sectors(current_req));\n\n\tremaining = current_count_sectors << 9;\n\tif (remaining > blk_rq_bytes(current_req) && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\tDPRINT(\"in copy buffer\\n\");\n\t\tpr_info(\"current_count_sectors=%ld\\n\", current_count_sectors);\n\t\tpr_info(\"remaining=%d\\n\", remaining >> 9);\n\t\tpr_info(\"current_req->nr_sectors=%u\\n\",\n\t\t\tblk_rq_sectors(current_req));\n\t\tpr_info(\"current_req->current_nr_sectors=%u\\n\",\n\t\t\tblk_rq_cur_sectors(current_req));\n\t\tpr_info(\"max_sector=%d\\n\", max_sector);\n\t\tpr_info(\"ssize=%d\\n\", ssize);\n\t}\n\n\tbuffer_max = max(max_sector, buffer_max);\n\n\tdma_buffer = floppy_track_buffer + ((fsector_t - buffer_min) << 9);\n\n\tsize = blk_rq_cur_bytes(current_req);\n\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (!remaining)\n\t\t\tbreak;\n\n\t\tsize = bv.bv_len;\n\t\tSUPBOUND(size, remaining);\n\n\t\tbuffer = page_address(bv.bv_page) + bv.bv_offset;\n\t\tif (dma_buffer + size >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10) ||\n\t\t    dma_buffer < floppy_track_buffer) {\n\t\t\tDPRINT(\"buffer overrun in copy buffer %d\\n\",\n\t\t\t       (int)((floppy_track_buffer - dma_buffer) >> 9));\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d\\n\",\n\t\t\t\tfsector_t, buffer_min);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (((unsigned long)buffer) % 512)\n\t\t\tDPRINT(\"%p buffer not aligned\\n\", buffer);\n\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\tmemcpy(buffer, dma_buffer, size);\n\t\telse\n\t\t\tmemcpy(dma_buffer, buffer, size);\n\n\t\tremaining -= size;\n\t\tdma_buffer += size;\n\t}\n\tif (remaining) {\n\t\tif (remaining > 0)\n\t\t\tmax_sector -= remaining >> 9;\n\t\tDPRINT(\"weirdness: remaining %d\\n\", remaining >> 9);\n\t}\n}\n\n/* work around a bug in pseudo DMA\n * (on some FDCs) pseudo DMA does not stop when the CPU stops\n * sending data.  Hence we need a different way to signal the\n * transfer length:  We use raw_cmd->cmd[SECT_PER_TRACK].  Unfortunately, this\n * does not work with MT, hence we can only transfer one head at\n * a time\n */\nstatic void virtualdmabug_workaround(void)\n{\n\tint hard_sectors;\n\tint end_sector;\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\traw_cmd->cmd[COMMAND] &= ~0x80;\t/* switch off multiple track mode */\n\n\t\thard_sectors = raw_cmd->length >> (7 + raw_cmd->cmd[SIZECODE]);\n\t\tend_sector = raw_cmd->cmd[SECTOR] + hard_sectors - 1;\n\t\tif (end_sector > raw_cmd->cmd[SECT_PER_TRACK]) {\n\t\t\tpr_info(\"too many sectors %d > %d\\n\",\n\t\t\t\tend_sector, raw_cmd->cmd[SECT_PER_TRACK]);\n\t\t\treturn;\n\t\t}\n\t\traw_cmd->cmd[SECT_PER_TRACK] = end_sector;\n\t\t\t\t\t/* make sure raw_cmd->cmd[SECT_PER_TRACK]\n\t\t\t\t\t * points to end of transfer */\n\t}\n}\n\n/*\n * Formulate a read/write request.\n * this routine decides where to load the data (directly to buffer, or to\n * tmp floppy area), how much data to load (the size of the buffer, the whole\n * track, or a single sector)\n * All floppy_track_buffer handling goes in here. If we ever add track buffer\n * allocation on the fly, it should be done here. No other part should need\n * modification.\n */\n\nstatic int make_raw_rw_request(void)\n{\n\tint aligned_sector_t;\n\tint max_sector;\n\tint max_size;\n\tint tracksize;\n\tint ssize;\n\n\tif (WARN(max_buffer_sectors == 0, \"VFS: Block I/O scheduled on unopened device\\n\"))\n\t\treturn 0;\n\n\tset_fdc((long)current_req->rq_disk->private_data);\n\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK;\n\traw_cmd->cmd_count = NR_RW;\n\tif (rq_data_dir(current_req) == READ) {\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t} else if (rq_data_dir(current_req) == WRITE) {\n\t\traw_cmd->flags |= FD_RAW_WRITE;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_WRITE);\n\t} else {\n\t\tDPRINT(\"%s: unknown command\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmax_sector = _floppy->sect * _floppy->head;\n\n\traw_cmd->cmd[TRACK] = (int)blk_rq_pos(current_req) / max_sector;\n\tfsector_t = (int)blk_rq_pos(current_req) % max_sector;\n\tif (_floppy->track && raw_cmd->cmd[TRACK] >= _floppy->track) {\n\t\tif (blk_rq_cur_sectors(current_req) & 1) {\n\t\t\tcurrent_count_sectors = 1;\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\traw_cmd->cmd[HEAD] = fsector_t / _floppy->sect;\n\n\tif (((_floppy->stretch & (FD_SWAPSIDES | FD_SECTBASEMASK)) ||\n\t     test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags)) &&\n\t    fsector_t < _floppy->sect)\n\t\tmax_sector = _floppy->sect;\n\n\t/* 2M disks have phantom sectors on the first track */\n\tif ((_floppy->rate & FD_2M) && (!raw_cmd->cmd[TRACK]) && (!raw_cmd->cmd[HEAD])) {\n\t\tmax_sector = 2 * _floppy->sect / 3;\n\t\tif (fsector_t >= max_sector) {\n\t\t\tcurrent_count_sectors =\n\t\t\t    min_t(int, _floppy->sect - fsector_t,\n\t\t\t\t  blk_rq_sectors(current_req));\n\t\t\treturn 1;\n\t\t}\n\t\traw_cmd->cmd[SIZECODE] = 2;\n\t} else\n\t\traw_cmd->cmd[SIZECODE] = FD_SIZECODE(_floppy);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\tif ((_floppy->rate & FD_2M) &&\n\t    (raw_cmd->cmd[TRACK] || raw_cmd->cmd[HEAD]) && raw_cmd->rate == 2)\n\t\traw_cmd->rate = 1;\n\n\tif (raw_cmd->cmd[SIZECODE])\n\t\traw_cmd->cmd[SIZECODE2] = 0xff;\n\telse\n\t\traw_cmd->cmd[SIZECODE2] = 0x80;\n\traw_cmd->track = raw_cmd->cmd[TRACK] << STRETCH(_floppy);\n\traw_cmd->cmd[DR_SELECT] = UNIT(current_drive) + PH_HEAD(_floppy, raw_cmd->cmd[HEAD]);\n\traw_cmd->cmd[GAP] = _floppy->gap;\n\tssize = DIV_ROUND_UP(1 << raw_cmd->cmd[SIZECODE], 4);\n\traw_cmd->cmd[SECT_PER_TRACK] = _floppy->sect << 2 >> raw_cmd->cmd[SIZECODE];\n\traw_cmd->cmd[SECTOR] = ((fsector_t % _floppy->sect) << 2 >> raw_cmd->cmd[SIZECODE]) +\n\t    FD_SECTBASE(_floppy);\n\n\t/* tracksize describes the size which can be filled up with sectors\n\t * of size ssize.\n\t */\n\ttracksize = _floppy->sect - _floppy->sect % ssize;\n\tif (tracksize < _floppy->sect) {\n\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\tif (tracksize <= fsector_t % _floppy->sect)\n\t\t\traw_cmd->cmd[SECTOR]--;\n\n\t\t/* if we are beyond tracksize, fill up using smaller sectors */\n\t\twhile (tracksize <= fsector_t % _floppy->sect) {\n\t\t\twhile (tracksize + ssize > _floppy->sect) {\n\t\t\t\traw_cmd->cmd[SIZECODE]--;\n\t\t\t\tssize >>= 1;\n\t\t\t}\n\t\t\traw_cmd->cmd[SECTOR]++;\n\t\t\traw_cmd->cmd[SECT_PER_TRACK]++;\n\t\t\ttracksize += ssize;\n\t\t}\n\t\tmax_sector = raw_cmd->cmd[HEAD] * _floppy->sect + tracksize;\n\t} else if (!raw_cmd->cmd[TRACK] && !raw_cmd->cmd[HEAD] && !(_floppy->rate & FD_2M) && probing) {\n\t\tmax_sector = _floppy->sect;\n\t} else if (!raw_cmd->cmd[HEAD] && CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t/* for virtual DMA bug workaround */\n\t\tmax_sector = _floppy->sect;\n\t}\n\n\tin_sector_offset = (fsector_t % _floppy->sect) % ssize;\n\taligned_sector_t = fsector_t - in_sector_offset;\n\tmax_size = blk_rq_sectors(current_req);\n\tif ((raw_cmd->track == buffer_track) &&\n\t    (current_drive == buffer_drive) &&\n\t    (fsector_t >= buffer_min) && (fsector_t < buffer_max)) {\n\t\t/* data already in track buffer */\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ) {\n\t\t\tcopy_buffer(1, max_sector, buffer_max);\n\t\t\treturn 1;\n\t\t}\n\t} else if (in_sector_offset || blk_rq_sectors(current_req) < ssize) {\n\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t\tunsigned int sectors;\n\n\t\t\tsectors = fsector_t + blk_rq_sectors(current_req);\n\t\t\tif (sectors > ssize && sectors < ssize + ssize)\n\t\t\t\tmax_size = ssize + ssize;\n\t\t\telse\n\t\t\t\tmax_size = ssize;\n\t\t}\n\t\traw_cmd->flags &= ~FD_RAW_WRITE;\n\t\traw_cmd->flags |= FD_RAW_READ;\n\t\traw_cmd->cmd[COMMAND] = FM_MODE(_floppy, FD_READ);\n\t} else if ((unsigned long)bio_data(current_req->bio) < MAX_DMA_ADDRESS) {\n\t\tunsigned long dma_limit;\n\t\tint direct, indirect;\n\n\t\tindirect =\n\t\t    transfer_size(ssize, max_sector,\n\t\t\t\t  max_buffer_sectors * 2) - fsector_t;\n\n\t\t/*\n\t\t * Do NOT use minimum() here---MAX_DMA_ADDRESS is 64 bits wide\n\t\t * on a 64 bit machine!\n\t\t */\n\t\tmax_size = buffer_chain_size();\n\t\tdma_limit = (MAX_DMA_ADDRESS -\n\t\t\t     ((unsigned long)bio_data(current_req->bio))) >> 9;\n\t\tif ((unsigned long)max_size > dma_limit)\n\t\t\tmax_size = dma_limit;\n\t\t/* 64 kb boundaries */\n\t\tif (CROSS_64KB(bio_data(current_req->bio), max_size << 9))\n\t\t\tmax_size = (K_64 -\n\t\t\t\t    ((unsigned long)bio_data(current_req->bio)) %\n\t\t\t\t    K_64) >> 9;\n\t\tdirect = transfer_size(ssize, max_sector, max_size) - fsector_t;\n\t\t/*\n\t\t * We try to read tracks, but if we get too many errors, we\n\t\t * go back to reading just one sector at a time.\n\t\t *\n\t\t * This means we should be able to read a sector even if there\n\t\t * are other bad sectors on this track.\n\t\t */\n\t\tif (!direct ||\n\t\t    (indirect * 2 > direct * 3 &&\n\t\t     *errors < drive_params[current_drive].max_errors.read_track &&\n\t\t     ((!probing ||\n\t\t       (drive_params[current_drive].read_track & (1 << drive_state[current_drive].probed_format)))))) {\n\t\t\tmax_size = blk_rq_sectors(current_req);\n\t\t} else {\n\t\t\traw_cmd->kernel_data = bio_data(current_req->bio);\n\t\t\traw_cmd->length = current_count_sectors << 9;\n\t\t\tif (raw_cmd->length == 0) {\n\t\t\t\tDPRINT(\"%s: zero dma transfer attempted\\n\", __func__);\n\t\t\t\tDPRINT(\"indirect=%d direct=%d fsector_t=%d\\n\",\n\t\t\t\t       indirect, direct, fsector_t);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvirtualdmabug_workaround();\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\tmax_size = max_sector;\t/* unbounded */\n\n\t/* claim buffer track if needed */\n\tif (buffer_track != raw_cmd->track ||\t/* bad track */\n\t    buffer_drive != current_drive ||\t/* bad drive */\n\t    fsector_t > buffer_max ||\n\t    fsector_t < buffer_min ||\n\t    ((CT(raw_cmd->cmd[COMMAND]) == FD_READ ||\n\t      (!in_sector_offset && blk_rq_sectors(current_req) >= ssize)) &&\n\t     max_sector > 2 * max_buffer_sectors + buffer_min &&\n\t     max_size + fsector_t > 2 * max_buffer_sectors + buffer_min)) {\n\t\t/* not enough space */\n\t\tbuffer_track = -1;\n\t\tbuffer_drive = current_drive;\n\t\tbuffer_max = buffer_min = aligned_sector_t;\n\t}\n\traw_cmd->kernel_data = floppy_track_buffer +\n\t\t((aligned_sector_t - buffer_min) << 9);\n\n\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE) {\n\t\t/* copy write buffer to track buffer.\n\t\t * if we get here, we know that the write\n\t\t * is either aligned or the data already in the buffer\n\t\t * (buffer will be overwritten) */\n\t\tif (in_sector_offset && buffer_track == -1)\n\t\t\tDPRINT(\"internal error offset !=0 on write\\n\");\n\t\tbuffer_track = raw_cmd->track;\n\t\tbuffer_drive = current_drive;\n\t\tcopy_buffer(ssize, max_sector,\n\t\t\t    2 * max_buffer_sectors + buffer_min);\n\t} else\n\t\ttransfer_size(ssize, max_sector,\n\t\t\t      2 * max_buffer_sectors + buffer_min -\n\t\t\t      aligned_sector_t);\n\n\t/* round up current_count_sectors to get dma xfer size */\n\traw_cmd->length = in_sector_offset + current_count_sectors;\n\traw_cmd->length = ((raw_cmd->length - 1) | (ssize - 1)) + 1;\n\traw_cmd->length <<= 9;\n\tif ((raw_cmd->length < current_count_sectors << 9) ||\n\t    (raw_cmd->kernel_data != bio_data(current_req->bio) &&\n\t     CT(raw_cmd->cmd[COMMAND]) == FD_WRITE &&\n\t     (aligned_sector_t + (raw_cmd->length >> 9) > buffer_max ||\n\t      aligned_sector_t < buffer_min)) ||\n\t    raw_cmd->length % (128 << raw_cmd->cmd[SIZECODE]) ||\n\t    raw_cmd->length <= 0 || current_count_sectors <= 0) {\n\t\tDPRINT(\"fractionary current count b=%lx s=%lx\\n\",\n\t\t       raw_cmd->length, current_count_sectors);\n\t\tif (raw_cmd->kernel_data != bio_data(current_req->bio))\n\t\t\tpr_info(\"addr=%d, length=%ld\\n\",\n\t\t\t\t(int)((raw_cmd->kernel_data -\n\t\t\t\t       floppy_track_buffer) >> 9),\n\t\t\t\tcurrent_count_sectors);\n\t\tpr_info(\"st=%d ast=%d mse=%d msi=%d\\n\",\n\t\t\tfsector_t, aligned_sector_t, max_sector, max_size);\n\t\tpr_info(\"ssize=%x SIZECODE=%d\\n\", ssize, raw_cmd->cmd[SIZECODE]);\n\t\tpr_info(\"command=%x SECTOR=%d HEAD=%d, TRACK=%d\\n\",\n\t\t\traw_cmd->cmd[COMMAND], raw_cmd->cmd[SECTOR],\n\t\t\traw_cmd->cmd[HEAD], raw_cmd->cmd[TRACK]);\n\t\tpr_info(\"buffer drive=%d\\n\", buffer_drive);\n\t\tpr_info(\"buffer track=%d\\n\", buffer_track);\n\t\tpr_info(\"buffer_min=%d\\n\", buffer_min);\n\t\tpr_info(\"buffer_max=%d\\n\", buffer_max);\n\t\treturn 0;\n\t}\n\n\tif (raw_cmd->kernel_data != bio_data(current_req->bio)) {\n\t\tif (raw_cmd->kernel_data < floppy_track_buffer ||\n\t\t    current_count_sectors < 0 ||\n\t\t    raw_cmd->length < 0 ||\n\t\t    raw_cmd->kernel_data + raw_cmd->length >\n\t\t    floppy_track_buffer + (max_buffer_sectors << 10)) {\n\t\t\tDPRINT(\"buffer overrun in schedule dma\\n\");\n\t\t\tpr_info(\"fsector_t=%d buffer_min=%d current_count=%ld\\n\",\n\t\t\t\tfsector_t, buffer_min, raw_cmd->length >> 9);\n\t\t\tpr_info(\"current_count_sectors=%ld\\n\",\n\t\t\t\tcurrent_count_sectors);\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_READ)\n\t\t\t\tpr_info(\"read\\n\");\n\t\t\tif (CT(raw_cmd->cmd[COMMAND]) == FD_WRITE)\n\t\t\t\tpr_info(\"write\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else if (raw_cmd->length > blk_rq_bytes(current_req) ||\n\t\t   current_count_sectors > blk_rq_sectors(current_req)) {\n\t\tDPRINT(\"buffer overrun in direct transfer\\n\");\n\t\treturn 0;\n\t} else if (raw_cmd->length < current_count_sectors << 9) {\n\t\tDPRINT(\"more sectors than bytes\\n\");\n\t\tpr_info(\"bytes=%ld\\n\", raw_cmd->length >> 9);\n\t\tpr_info(\"sectors=%ld\\n\", current_count_sectors);\n\t}\n\tif (raw_cmd->length == 0) {\n\t\tDPRINT(\"zero dma transfer attempted from make_raw_request\\n\");\n\t\treturn 0;\n\t}\n\n\tvirtualdmabug_workaround();\n\treturn 2;\n}\n\nstatic int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}\n\n/* Starts or continues processing request. Will automatically unlock the\n * driver at end of request.\n */\nstatic void redo_fd_request(void)\n{\n\tint drive;\n\tint tmp;\n\n\tlastredo = jiffies;\n\tif (current_drive < N_DRIVE)\n\t\tfloppy_off(current_drive);\n\ndo_request:\n\tif (!current_req) {\n\t\tint pending;\n\n\t\tspin_lock_irq(&floppy_lock);\n\t\tpending = set_next_request();\n\t\tspin_unlock_irq(&floppy_lock);\n\t\tif (!pending) {\n\t\t\tdo_floppy = NULL;\n\t\t\tunlock_fdc();\n\t\t\treturn;\n\t\t}\n\t}\n\tdrive = (long)current_req->rq_disk->private_data;\n\tset_fdc(drive);\n\treschedule_timeout(current_drive, \"redo fd request\");\n\n\tset_floppy(drive);\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = 0;\n\tif (start_motor(redo_fd_request))\n\t\treturn;\n\n\tdisk_change(current_drive);\n\tif (test_bit(current_drive, &fake_change) ||\n\t    test_bit(FD_DISK_CHANGED_BIT, &drive_state[current_drive].flags)) {\n\t\tDPRINT(\"disk absent or changed during operation\\n\");\n\t\trequest_done(0);\n\t\tgoto do_request;\n\t}\n\tif (!_floppy) {\t/* Autodetection */\n\t\tif (!probing) {\n\t\t\tdrive_state[current_drive].probed_format = 0;\n\t\t\tif (next_valid_format(current_drive)) {\n\t\t\t\tDPRINT(\"no autodetectable formats\\n\");\n\t\t\t\t_floppy = NULL;\n\t\t\t\trequest_done(0);\n\t\t\t\tgoto do_request;\n\t\t\t}\n\t\t}\n\t\tprobing = 1;\n\t\t_floppy = floppy_type + drive_params[current_drive].autodetect[drive_state[current_drive].probed_format];\n\t} else\n\t\tprobing = 0;\n\terrors = &(current_req->error_count);\n\ttmp = make_raw_rw_request();\n\tif (tmp < 2) {\n\t\trequest_done(tmp);\n\t\tgoto do_request;\n\t}\n\n\tif (test_bit(FD_NEED_TWADDLE_BIT, &drive_state[current_drive].flags))\n\t\ttwaddle(current_fdc, current_drive);\n\tschedule_bh(floppy_start);\n\tdebugt(__func__, \"queue fd request\");\n\treturn;\n}\n\nstatic const struct cont_t rw_cont = {\n\t.interrupt\t= rw_interrupt,\n\t.redo\t\t= redo_fd_request,\n\t.error\t\t= bad_flp_intr,\n\t.done\t\t= request_done\n};\n\n/* schedule the request and automatically unlock the driver on completion */\nstatic void process_fd_request(void)\n{\n\tcont = &rw_cont;\n\tschedule_bh(redo_fd_request);\n}\n\nstatic blk_status_t floppy_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t    const struct blk_mq_queue_data *bd)\n{\n\tblk_mq_start_request(bd->rq);\n\n\tif (WARN(max_buffer_sectors == 0,\n\t\t \"VFS: %s called on non-open device\\n\", __func__))\n\t\treturn BLK_STS_IOERR;\n\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"warning: usage count=0, current_req=%p sect=%ld flags=%llx\\n\",\n\t\t current_req, (long)blk_rq_pos(current_req),\n\t\t (unsigned long long) current_req->cmd_flags))\n\t\treturn BLK_STS_IOERR;\n\n\tif (test_and_set_bit(0, &fdc_busy)) {\n\t\t/* fdc busy, this new request will be treated when the\n\t\t   current one is done */\n\t\tis_alive(__func__, \"old request running\");\n\t\treturn BLK_STS_RESOURCE;\n\t}\n\n\tspin_lock_irq(&floppy_lock);\n\tlist_add_tail(&bd->rq->queuelist, &floppy_reqs);\n\tspin_unlock_irq(&floppy_lock);\n\n\tcommand_status = FD_COMMAND_NONE;\n\t__reschedule_timeout(MAXTIMEOUT, \"fd_request\");\n\tset_fdc(0);\n\tprocess_fd_request();\n\tis_alive(__func__, \"\");\n\treturn BLK_STS_OK;\n}\n\nstatic const struct cont_t poll_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_ready,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\nstatic int poll_drive(bool interruptible, int flag)\n{\n\t/* no auto-sense, just clear dcl */\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->flags = flag;\n\traw_cmd->track = 0;\n\traw_cmd->cmd_count = 0;\n\tcont = &poll_cont;\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"setting NEWCHANGE in poll_drive\\n\");\n\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[current_drive].flags);\n\n\treturn wait_til_done(floppy_ready, interruptible);\n}\n\n/*\n * User triggered reset\n * ====================\n */\n\nstatic void reset_intr(void)\n{\n\tpr_info(\"weird, reset interrupt called\\n\");\n}\n\nstatic const struct cont_t reset_cont = {\n\t.interrupt\t= reset_intr,\n\t.redo\t\t= success_and_wakeup,\n\t.error\t\t= generic_failure,\n\t.done\t\t= generic_done\n};\n\n/*\n * Resets the FDC connected to drive <drive>.\n * Both current_drive and current_fdc are changed to match the new drive.\n */\nstatic int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tfdc_state[current_fdc].reset = 1;\n\tif (fdc_state[current_fdc].reset) {\n\t\t/* note: reset_fdc will take care of unlocking the driver\n\t\t * on completion.\n\t\t */\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}\n\n/*\n * Misc Ioctl's and support\n * ========================\n */\nstatic inline int fd_copyout(void __user *param, const void *address,\n\t\t\t     unsigned long size)\n{\n\treturn copy_to_user(param, address, size) ? -EFAULT : 0;\n}\n\nstatic inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}\n\nstatic const char *drive_name(int type, int drive)\n{\n\tstruct floppy_struct *floppy;\n\n\tif (type)\n\t\tfloppy = floppy_type + type;\n\telse {\n\t\tif (drive_params[drive].native_format)\n\t\t\tfloppy = floppy_type + drive_params[drive].native_format;\n\t\telse\n\t\t\treturn \"(null)\";\n\t}\n\tif (floppy->name)\n\t\treturn floppy->name;\n\telse\n\t\treturn \"(null)\";\n}\n\n/* raw commands */\nstatic void raw_cmd_done(int flag)\n{\n\tint i;\n\n\tif (!flag) {\n\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\t\traw_cmd->flags |= FD_RAW_HARDFAILURE;\n\t} else {\n\t\traw_cmd->reply_count = inr;\n\t\tif (raw_cmd->reply_count > FD_RAW_REPLY_SIZE)\n\t\t\traw_cmd->reply_count = 0;\n\t\tfor (i = 0; i < raw_cmd->reply_count; i++)\n\t\t\traw_cmd->reply[i] = reply_buffer[i];\n\n\t\tif (raw_cmd->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\t\tunsigned long flags;\n\t\t\tflags = claim_dma_lock();\n\t\t\traw_cmd->length = fd_get_dma_residue();\n\t\t\trelease_dma_lock(flags);\n\t\t}\n\n\t\tif ((raw_cmd->flags & FD_RAW_SOFTFAILURE) &&\n\t\t    (!raw_cmd->reply_count || (raw_cmd->reply[0] & 0xc0)))\n\t\t\traw_cmd->flags |= FD_RAW_FAILURE;\n\n\t\tif (disk_change(current_drive))\n\t\t\traw_cmd->flags |= FD_RAW_DISK_CHANGE;\n\t\telse\n\t\t\traw_cmd->flags &= ~FD_RAW_DISK_CHANGE;\n\t\tif (raw_cmd->flags & FD_RAW_NO_MOTOR_AFTER)\n\t\t\tmotor_off_callback(&motor_off_timer[current_drive]);\n\n\t\tif (raw_cmd->next &&\n\t\t    (!(raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_FAILURE)) &&\n\t\t    ((raw_cmd->flags & FD_RAW_FAILURE) ||\n\t\t     !(raw_cmd->flags & FD_RAW_STOP_IF_SUCCESS))) {\n\t\t\traw_cmd = raw_cmd->next;\n\t\t\treturn;\n\t\t}\n\t}\n\tgeneric_done(flag);\n}\n\nstatic const struct cont_t raw_cmd_cont = {\n\t.interrupt\t= success_and_wakeup,\n\t.redo\t\t= floppy_start,\n\t.error\t\t= generic_failure,\n\t.done\t\t= raw_cmd_done\n};\n\nstatic int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n\nstatic int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > FD_RAW_CMD_FULLSIZE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < FD_RAW_REPLY_SIZE; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\n\treturn 0;\n}\n\nstatic int raw_cmd_ioctl(int cmd, void __user *param)\n{\n\tstruct floppy_raw_cmd *my_raw_cmd;\n\tint drive;\n\tint ret2;\n\tint ret;\n\n\tif (fdc_state[current_fdc].rawcmd <= 1)\n\t\tfdc_state[current_fdc].rawcmd = 1;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (FDC(drive) != current_fdc)\n\t\t\tcontinue;\n\t\tif (drive == current_drive) {\n\t\t\tif (drive_state[drive].fd_ref > 1) {\n\t\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (drive_state[drive].fd_ref) {\n\t\t\tfdc_state[current_fdc].rawcmd = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fdc_state[current_fdc].reset)\n\t\treturn -EIO;\n\n\tret = raw_cmd_copyin(cmd, param, &my_raw_cmd);\n\tif (ret) {\n\t\traw_cmd_free(&my_raw_cmd);\n\t\treturn ret;\n\t}\n\n\traw_cmd = my_raw_cmd;\n\tcont = &raw_cmd_cont;\n\tret = wait_til_done(floppy_start, true);\n\tdebug_dcl(drive_params[current_drive].flags,\n\t\t  \"calling disk change from raw_cmd ioctl\\n\");\n\n\tif (ret != -EINTR && fdc_state[current_fdc].reset)\n\t\tret = -EIO;\n\n\tdrive_state[current_drive].track = NO_TRACK;\n\n\tret2 = raw_cmd_copyout(cmd, param, my_raw_cmd);\n\tif (!ret)\n\t\tret = ret2;\n\traw_cmd_free(&my_raw_cmd);\n\treturn ret;\n}\n\nstatic int invalidate_drive(struct block_device *bdev)\n{\n\t/* invalidate the buffer track to force a reread */\n\tset_bit((long)bdev->bd_disk->private_data, &fake_change);\n\tprocess_fd_request();\n\tif (bdev_check_media_change(bdev))\n\t\tfloppy_revalidate(bdev->bd_disk);\n\treturn 0;\n}\n\nstatic int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif ((int)g->sect <= 0 ||\n\t    (int)g->head <= 0 ||\n\t    /* check for overflow in max_sector */\n\t    (int)(g->sect * g->head) <= 0 ||\n\t    /* check for zero in raw_cmd->cmd[F_SECT_PER_TRACK] */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > drive_params[drive].tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = \"user format\";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tdrive_state[current_drive].keep_data = -1;\n\t\telse\n\t\t\tdrive_state[current_drive].keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (drive_state[current_drive].maxblock > user_params[drive].sect ||\n\t\t    drive_state[current_drive].maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}\n\n/* handle obsolete ioctl's */\nstatic unsigned int ioctl_table[] = {\n\tFDCLRPRM,\n\tFDSETPRM,\n\tFDDEFPRM,\n\tFDGETPRM,\n\tFDMSGON,\n\tFDMSGOFF,\n\tFDFMTBEG,\n\tFDFMTTRK,\n\tFDFMTEND,\n\tFDSETEMSGTRESH,\n\tFDFLUSH,\n\tFDSETMAXERRS,\n\tFDGETMAXERRS,\n\tFDGETDRVTYP,\n\tFDSETDRVPRM,\n\tFDGETDRVPRM,\n\tFDGETDRVSTAT,\n\tFDPOLLDRVSTAT,\n\tFDRESET,\n\tFDGETFDCSTAT,\n\tFDWERRORCLR,\n\tFDWERRORGET,\n\tFDRAWCMD,\n\tFDEJECT,\n\tFDTWADDLE\n};\n\nstatic int normalize_ioctl(unsigned int *cmd, int *size)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ioctl_table); i++) {\n\t\tif ((*cmd & 0xffff) == (ioctl_table[i] & 0xffff)) {\n\t\t\t*size = _IOC_SIZE(*cmd);\n\t\t\t*cmd = ioctl_table[i];\n\t\t\tif (*size > _IOC_SIZE(*cmd)) {\n\t\t\t\tpr_info(\"ioctl not yet supported\\n\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_floppy_geometry(int drive, int type, struct floppy_struct **g)\n{\n\tif (type)\n\t\t*g = &floppy_type[type];\n\telse {\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(false, 0) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\t*g = current_type[drive];\n\t}\n\tif (!*g)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}\n\nstatic bool valid_floppy_drive_params(const short autodetect[FD_AUTODETECT_SIZE],\n\t\tint native_format)\n{\n\tsize_t floppy_type_size = ARRAY_SIZE(floppy_type);\n\tsize_t i = 0;\n\n\tfor (i = 0; i < FD_AUTODETECT_SIZE; ++i) {\n\t\tif (autodetect[i] < 0 ||\n\t\t    autodetect[i] >= floppy_type_size)\n\t\t\treturn false;\n\t}\n\n\tif (native_format < 0 || native_format >= floppy_type_size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int fd_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tint i;\n\tint ret;\n\tint size;\n\tunion inparam {\n\t\tstruct floppy_struct g;\t/* geometry */\n\t\tstruct format_descr f;\n\t\tstruct floppy_max_errors max_errors;\n\t\tstruct floppy_drive_params dp;\n\t} inparam;\t\t/* parameters coming from user space */\n\tconst void *outparam;\t/* parameters passed back to user space */\n\n\t/* convert compatibility eject ioctls into floppy eject ioctl.\n\t * We do this in order to provide a means to eject floppy disks before\n\t * installing the new fdutils package */\n\tif (cmd == CDROMEJECT ||\t/* CD-ROM eject */\n\t    cmd == 0x6470) {\t\t/* SunOS floppy eject */\n\t\tDPRINT(\"obsolete eject ioctl\\n\");\n\t\tDPRINT(\"please use floppycontrol --eject\\n\");\n\t\tcmd = FDEJECT;\n\t}\n\n\tif (!((cmd & 0xff00) == 0x0200))\n\t\treturn -EINVAL;\n\n\t/* convert the old style command into a new style command */\n\tret = normalize_ioctl(&cmd, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t/* permission checks */\n\tif (((cmd & 0x40) && !(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||\n\t    ((cmd & 0x80) && !capable(CAP_SYS_ADMIN)))\n\t\treturn -EPERM;\n\n\tif (WARN_ON(size < 0 || size > sizeof(inparam)))\n\t\treturn -EINVAL;\n\n\t/* copyin */\n\tmemset(&inparam, 0, sizeof(inparam));\n\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\tret = fd_copyin((void __user *)param, &inparam, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase FDEJECT:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\t/* somebody else has this drive open */\n\t\t\treturn -EBUSY;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\n\t\t/* do the actual eject. Fails on\n\t\t * non-Sparc architectures */\n\t\tret = fd_eject(UNIT(drive));\n\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tprocess_fd_request();\n\t\treturn ret;\n\tcase FDCLRPRM:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tcurrent_type[drive] = NULL;\n\t\tfloppy_sizes[drive] = MAX_DISK_SIZE << 1;\n\t\tdrive_state[drive].keep_data = 0;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETPRM:\n\tcase FDDEFPRM:\n\t\treturn set_geometry(cmd, &inparam.g, drive, type, bdev);\n\tcase FDGETPRM:\n\t\tret = get_floppy_geometry(drive, type,\n\t\t\t\t\t  (struct floppy_struct **)&outparam);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&inparam.g, outparam,\n\t\t\t\toffsetof(struct floppy_struct, name));\n\t\toutparam = &inparam.g;\n\t\tbreak;\n\tcase FDMSGON:\n\t\tdrive_params[drive].flags |= FTD_MSG;\n\t\treturn 0;\n\tcase FDMSGOFF:\n\t\tdrive_params[drive].flags &= ~FTD_MSG;\n\t\treturn 0;\n\tcase FDFMTBEG:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tret = drive_state[drive].flags;\n\t\tprocess_fd_request();\n\t\tif (ret & FD_VERIFY)\n\t\t\treturn -ENODEV;\n\t\tif (!(ret & FD_DISK_WRITABLE))\n\t\t\treturn -EROFS;\n\t\treturn 0;\n\tcase FDFMTTRK:\n\t\tif (drive_state[drive].fd_ref != 1)\n\t\t\treturn -EBUSY;\n\t\treturn do_format(drive, &inparam.f);\n\tcase FDFMTEND:\n\tcase FDFLUSH:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\treturn invalidate_drive(bdev);\n\tcase FDSETEMSGTRESH:\n\t\tdrive_params[drive].max_errors.reporting = (unsigned short)(param & 0x0f);\n\t\treturn 0;\n\tcase FDGETMAXERRS:\n\t\toutparam = &drive_params[drive].max_errors;\n\t\tbreak;\n\tcase FDSETMAXERRS:\n\t\tdrive_params[drive].max_errors = inparam.max_errors;\n\t\tbreak;\n\tcase FDGETDRVTYP:\n\t\toutparam = drive_name(type, drive);\n\t\tSUPBOUND(size, strlen((const char *)outparam) + 1);\n\t\tbreak;\n\tcase FDSETDRVPRM:\n\t\tif (!valid_floppy_drive_params(inparam.dp.autodetect,\n\t\t\t\tinparam.dp.native_format))\n\t\t\treturn -EINVAL;\n\t\tdrive_params[drive] = inparam.dp;\n\t\tbreak;\n\tcase FDGETDRVPRM:\n\t\toutparam = &drive_params[drive];\n\t\tbreak;\n\tcase FDPOLLDRVSTAT:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\tfallthrough;\n\tcase FDGETDRVSTAT:\n\t\toutparam = &drive_state[drive];\n\t\tbreak;\n\tcase FDRESET:\n\t\treturn user_reset_fdc(drive, (int)param, true);\n\tcase FDGETFDCSTAT:\n\t\toutparam = &fdc_state[FDC(drive)];\n\t\tbreak;\n\tcase FDWERRORCLR:\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\treturn 0;\n\tcase FDWERRORGET:\n\t\toutparam = &write_errors[drive];\n\t\tbreak;\n\tcase FDRAWCMD:\n\t\tif (type)\n\t\t\treturn -EINVAL;\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tset_floppy(drive);\n\t\ti = raw_cmd_ioctl(cmd, (void __user *)param);\n\t\tif (i == -EINTR)\n\t\t\treturn -EINTR;\n\t\tprocess_fd_request();\n\t\treturn i;\n\tcase FDTWADDLE:\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\ttwaddle(current_fdc, current_drive);\n\t\tprocess_fd_request();\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (_IOC_DIR(cmd) & _IOC_READ)\n\t\treturn fd_copyout((void __user *)param, outparam, size);\n\n\treturn 0;\n}\n\nstatic int fd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t     unsigned int cmd, unsigned long param)\n{\n\tint ret;\n\n\tmutex_lock(&floppy_mutex);\n\tret = fd_locked_ioctl(bdev, mode, cmd, param);\n\tmutex_unlock(&floppy_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_floppy_drive_params {\n\tchar\t\tcmos;\n\tcompat_ulong_t\tmax_dtr;\n\tcompat_ulong_t\thlt;\n\tcompat_ulong_t\thut;\n\tcompat_ulong_t\tsrt;\n\tcompat_ulong_t\tspinup;\n\tcompat_ulong_t\tspindown;\n\tunsigned char\tspindown_offset;\n\tunsigned char\tselect_delay;\n\tunsigned char\trps;\n\tunsigned char\ttracks;\n\tcompat_ulong_t\ttimeout;\n\tunsigned char\tinterleave_sect;\n\tstruct floppy_max_errors max_errors;\n\tchar\t\tflags;\n\tchar\t\tread_track;\n\tshort\t\tautodetect[FD_AUTODETECT_SIZE];\n\tcompat_int_t\tcheckfreq;\n\tcompat_int_t\tnative_format;\n};\n\nstruct compat_floppy_drive_struct {\n\tsigned char\tflags;\n\tcompat_ulong_t\tspinup_date;\n\tcompat_ulong_t\tselect_date;\n\tcompat_ulong_t\tfirst_read_date;\n\tshort\t\tprobed_format;\n\tshort\t\ttrack;\n\tshort\t\tmaxblock;\n\tshort\t\tmaxtrack;\n\tcompat_int_t\tgeneration;\n\tcompat_int_t\tkeep_data;\n\tcompat_int_t\tfd_ref;\n\tcompat_int_t\tfd_device;\n\tcompat_int_t\tlast_checked;\n\tcompat_caddr_t dmabuf;\n\tcompat_int_t\tbufblocks;\n};\n\nstruct compat_floppy_fdc_state {\n\tcompat_int_t\tspec1;\n\tcompat_int_t\tspec2;\n\tcompat_int_t\tdtr;\n\tunsigned char\tversion;\n\tunsigned char\tdor;\n\tcompat_ulong_t\taddress;\n\tunsigned int\trawcmd:2;\n\tunsigned int\treset:1;\n\tunsigned int\tneed_configure:1;\n\tunsigned int\tperp_mode:2;\n\tunsigned int\thas_fifo:1;\n\tunsigned int\tdriver_version;\n\tunsigned char\ttrack[4];\n};\n\nstruct compat_floppy_write_errors {\n\tunsigned int\twrite_errors;\n\tcompat_ulong_t\tfirst_error_sector;\n\tcompat_int_t\tfirst_error_generation;\n\tcompat_ulong_t\tlast_error_sector;\n\tcompat_int_t\tlast_error_generation;\n\tcompat_uint_t\tbadness;\n};\n\n#define FDSETPRM32 _IOW(2, 0x42, struct compat_floppy_struct)\n#define FDDEFPRM32 _IOW(2, 0x43, struct compat_floppy_struct)\n#define FDSETDRVPRM32 _IOW(2, 0x90, struct compat_floppy_drive_params)\n#define FDGETDRVPRM32 _IOR(2, 0x11, struct compat_floppy_drive_params)\n#define FDGETDRVSTAT32 _IOR(2, 0x12, struct compat_floppy_drive_struct)\n#define FDPOLLDRVSTAT32 _IOR(2, 0x13, struct compat_floppy_drive_struct)\n#define FDGETFDCSTAT32 _IOR(2, 0x15, struct compat_floppy_fdc_state)\n#define FDWERRORGET32  _IOR(2, 0x17, struct compat_floppy_write_errors)\n\nstatic int compat_set_geometry(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    struct compat_floppy_struct __user *arg)\n{\n\tstruct floppy_struct v;\n\tint drive, type;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct floppy_struct, name) !=\n\t\t     offsetof(struct compat_floppy_struct, name));\n\n\tif (!(mode & (FMODE_WRITE | FMODE_WRITE_IOCTL)))\n\t\treturn -EPERM;\n\n\tmemset(&v, 0, sizeof(struct floppy_struct));\n\tif (copy_from_user(&v, arg, offsetof(struct floppy_struct, name)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&floppy_mutex);\n\tdrive = (long)bdev->bd_disk->private_data;\n\ttype = ITYPE(drive_state[drive].fd_device);\n\terr = set_geometry(cmd == FDSETPRM32 ? FDSETPRM : FDDEFPRM,\n\t\t\t&v, drive, type, bdev);\n\tmutex_unlock(&floppy_mutex);\n\treturn err;\n}\n\nstatic int compat_get_prm(int drive,\n\t\t\t  struct compat_floppy_struct __user *arg)\n{\n\tstruct compat_floppy_struct v;\n\tstruct floppy_struct *p;\n\tint err;\n\n\tmemset(&v, 0, sizeof(v));\n\tmutex_lock(&floppy_mutex);\n\terr = get_floppy_geometry(drive, ITYPE(drive_state[drive].fd_device),\n\t\t\t\t  &p);\n\tif (err) {\n\t\tmutex_unlock(&floppy_mutex);\n\t\treturn err;\n\t}\n\tmemcpy(&v, p, offsetof(struct floppy_struct, name));\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tif (!valid_floppy_drive_params(v.autodetect, v.native_format))\n\t\treturn -EINVAL;\n\tmutex_lock(&floppy_mutex);\n\tdrive_params[drive].cmos = v.cmos;\n\tdrive_params[drive].max_dtr = v.max_dtr;\n\tdrive_params[drive].hlt = v.hlt;\n\tdrive_params[drive].hut = v.hut;\n\tdrive_params[drive].srt = v.srt;\n\tdrive_params[drive].spinup = v.spinup;\n\tdrive_params[drive].spindown = v.spindown;\n\tdrive_params[drive].spindown_offset = v.spindown_offset;\n\tdrive_params[drive].select_delay = v.select_delay;\n\tdrive_params[drive].rps = v.rps;\n\tdrive_params[drive].tracks = v.tracks;\n\tdrive_params[drive].timeout = v.timeout;\n\tdrive_params[drive].interleave_sect = v.interleave_sect;\n\tdrive_params[drive].max_errors = v.max_errors;\n\tdrive_params[drive].flags = v.flags;\n\tdrive_params[drive].read_track = v.read_track;\n\tmemcpy(drive_params[drive].autodetect, v.autodetect,\n\t       sizeof(v.autodetect));\n\tdrive_params[drive].checkfreq = v.checkfreq;\n\tdrive_params[drive].native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}\n\nstatic int compat_getdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_params));\n\tmutex_lock(&floppy_mutex);\n\tv.cmos = drive_params[drive].cmos;\n\tv.max_dtr = drive_params[drive].max_dtr;\n\tv.hlt = drive_params[drive].hlt;\n\tv.hut = drive_params[drive].hut;\n\tv.srt = drive_params[drive].srt;\n\tv.spinup = drive_params[drive].spinup;\n\tv.spindown = drive_params[drive].spindown;\n\tv.spindown_offset = drive_params[drive].spindown_offset;\n\tv.select_delay = drive_params[drive].select_delay;\n\tv.rps = drive_params[drive].rps;\n\tv.tracks = drive_params[drive].tracks;\n\tv.timeout = drive_params[drive].timeout;\n\tv.interleave_sect = drive_params[drive].interleave_sect;\n\tv.max_errors = drive_params[drive].max_errors;\n\tv.flags = drive_params[drive].flags;\n\tv.read_track = drive_params[drive].read_track;\n\tmemcpy(v.autodetect, drive_params[drive].autodetect,\n\t       sizeof(v.autodetect));\n\tv.checkfreq = drive_params[drive].checkfreq;\n\tv.native_format = drive_params[drive].native_format;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = drive_state[drive].spinup_date;\n\tv.select_date = drive_state[drive].select_date;\n\tv.first_read_date = drive_state[drive].first_read_date;\n\tv.probed_format = drive_state[drive].probed_format;\n\tv.track = drive_state[drive].track;\n\tv.maxblock = drive_state[drive].maxblock;\n\tv.maxtrack = drive_state[drive].maxtrack;\n\tv.generation = drive_state[drive].generation;\n\tv.keep_data = drive_state[drive].keep_data;\n\tv.fd_ref = drive_state[drive].fd_ref;\n\tv.fd_device = drive_state[drive].fd_device;\n\tv.last_checked = drive_state[drive].last_checked;\n\tv.dmabuf = (uintptr_t) drive_state[drive].dmabuf;\n\tv.bufblocks = drive_state[drive].bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\n\tif (copy_to_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}\n\nstatic int compat_getfdcstat(int drive,\n\t\t\t    struct compat_floppy_fdc_state __user *arg)\n{\n\tstruct compat_floppy_fdc_state v32;\n\tstruct floppy_fdc_state v;\n\n\tmutex_lock(&floppy_mutex);\n\tv = fdc_state[FDC(drive)];\n\tmutex_unlock(&floppy_mutex);\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_fdc_state));\n\tv32.spec1 = v.spec1;\n\tv32.spec2 = v.spec2;\n\tv32.dtr = v.dtr;\n\tv32.version = v.version;\n\tv32.dor = v.dor;\n\tv32.address = v.address;\n\tv32.rawcmd = v.rawcmd;\n\tv32.reset = v.reset;\n\tv32.need_configure = v.need_configure;\n\tv32.perp_mode = v.perp_mode;\n\tv32.has_fifo = v.has_fifo;\n\tv32.driver_version = v.driver_version;\n\tmemcpy(v32.track, v.track, 4);\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_fdc_state)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_werrorget(int drive,\n\t\t\t    struct compat_floppy_write_errors __user *arg)\n{\n\tstruct compat_floppy_write_errors v32;\n\tstruct floppy_write_errors v;\n\n\tmemset(&v32, 0, sizeof(struct compat_floppy_write_errors));\n\tmutex_lock(&floppy_mutex);\n\tv = write_errors[drive];\n\tmutex_unlock(&floppy_mutex);\n\tv32.write_errors = v.write_errors;\n\tv32.first_error_sector = v.first_error_sector;\n\tv32.first_error_generation = v.first_error_generation;\n\tv32.last_error_sector = v.last_error_sector;\n\tv32.last_error_generation = v.last_error_generation;\n\tv32.badness = v.badness;\n\tif (copy_to_user(arg, &v32, sizeof(struct compat_floppy_write_errors)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int fd_compat_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\n\t\t    unsigned long param)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tswitch (cmd) {\n\tcase CDROMEJECT: /* CD-ROM eject */\n\tcase 0x6470:\t /* SunOS floppy eject */\n\n\tcase FDMSGON:\n\tcase FDMSGOFF:\n\tcase FDSETEMSGTRESH:\n\tcase FDFLUSH:\n\tcase FDWERRORCLR:\n\tcase FDEJECT:\n\tcase FDCLRPRM:\n\tcase FDFMTBEG:\n\tcase FDRESET:\n\tcase FDTWADDLE:\n\t\treturn fd_ioctl(bdev, mode, cmd, param);\n\tcase FDSETMAXERRS:\n\tcase FDGETMAXERRS:\n\tcase FDGETDRVTYP:\n\tcase FDFMTEND:\n\tcase FDFMTTRK:\n\tcase FDRAWCMD:\n\t\treturn fd_ioctl(bdev, mode, cmd,\n\t\t\t\t(unsigned long)compat_ptr(param));\n\tcase FDSETPRM32:\n\tcase FDDEFPRM32:\n\t\treturn compat_set_geometry(bdev, mode, cmd, compat_ptr(param));\n\tcase FDGETPRM32:\n\t\treturn compat_get_prm(drive, compat_ptr(param));\n\tcase FDSETDRVPRM32:\n\t\treturn compat_setdrvprm(drive, compat_ptr(param));\n\tcase FDGETDRVPRM32:\n\t\treturn compat_getdrvprm(drive, compat_ptr(param));\n\tcase FDPOLLDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, true, compat_ptr(param));\n\tcase FDGETDRVSTAT32:\n\t\treturn compat_getdrvstat(drive, false, compat_ptr(param));\n\tcase FDGETFDCSTAT32:\n\t\treturn compat_getfdcstat(drive, compat_ptr(param));\n\tcase FDWERRORGET32:\n\t\treturn compat_werrorget(drive, compat_ptr(param));\n\t}\n\treturn -EINVAL;\n}\n#endif\n\nstatic void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\n\t/* read drive info out of physical CMOS */\n\tdrive = 0;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!drive_params[drive].cmos)\n\t\tdrive_params[drive].cmos = FLOPPY1_TYPE;\n\n\t/* FIXME: additional physical CMOS drive detection should go here */\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = drive_params[drive].cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\tdrive_params[drive] = *params;\n\t}\n\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}\n\nstatic void floppy_release(struct gendisk *disk, fmode_t mode)\n{\n\tint drive = (long)disk->private_data;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\tif (!drive_state[drive].fd_ref--) {\n\t\tDPRINT(\"floppy_release with fd_ref == 0\");\n\t\tdrive_state[drive].fd_ref = 0;\n\t}\n\tif (!drive_state[drive].fd_ref)\n\t\topened_bdev[drive] = NULL;\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n}\n\n/*\n * floppy_open check for aliasing (/dev/fd0 can be the same as\n * /dev/PS0 etc), and disallows simultaneous access to the same\n * drive with different device numbers.\n */\nstatic int floppy_open(struct block_device *bdev, fmode_t mode)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint old_dev, new_dev;\n\tint try;\n\tint res = -EBUSY;\n\tchar *tmp;\n\n\tmutex_lock(&floppy_mutex);\n\tmutex_lock(&open_lock);\n\told_dev = drive_state[drive].fd_device;\n\tif (opened_bdev[drive] && opened_bdev[drive] != bdev)\n\t\tgoto out2;\n\n\tif (!drive_state[drive].fd_ref && (drive_params[drive].flags & FD_BROKEN_DCL)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t}\n\n\tdrive_state[drive].fd_ref++;\n\n\topened_bdev[drive] = bdev;\n\n\tres = -ENXIO;\n\n\tif (!floppy_track_buffer) {\n\t\t/* if opening an ED drive, reserve a big buffer,\n\t\t * else reserve a small one */\n\t\tif ((drive_params[drive].cmos == 6) || (drive_params[drive].cmos == 5))\n\t\t\ttry = 64;\t/* Only 48 actually useful */\n\t\telse\n\t\t\ttry = 32;\t/* Only 24 actually useful */\n\n\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\ttry >>= 1;\t/* buffer only one side */\n\t\t\tINFBOUND(try, 16);\n\t\t\ttmp = (char *)fd_dma_mem_alloc(1024 * try);\n\t\t}\n\t\tif (!tmp && !floppy_track_buffer)\n\t\t\tfallback_on_nodma_alloc(&tmp, 2048 * try);\n\t\tif (!tmp && !floppy_track_buffer) {\n\t\t\tDPRINT(\"Unable to allocate DMA memory\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (floppy_track_buffer) {\n\t\t\tif (tmp)\n\t\t\t\tfd_dma_mem_free((unsigned long)tmp, try * 1024);\n\t\t} else {\n\t\t\tbuffer_min = buffer_max = -1;\n\t\t\tfloppy_track_buffer = tmp;\n\t\t\tmax_buffer_sectors = try;\n\t\t}\n\t}\n\n\tnew_dev = MINOR(bdev->bd_dev);\n\tdrive_state[drive].fd_device = new_dev;\n\tset_capacity(disks[drive][ITYPE(new_dev)], floppy_sizes[new_dev]);\n\tif (old_dev != -1 && old_dev != new_dev) {\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t}\n\n\tif (fdc_state[FDC(drive)].rawcmd == 1)\n\t\tfdc_state[FDC(drive)].rawcmd = 2;\n\n\tif (!(mode & FMODE_NDELAY)) {\n\t\tif (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\t\tdrive_state[drive].last_checked = 0;\n\t\t\tclear_bit(FD_OPEN_SHOULD_FAIL_BIT,\n\t\t\t\t  &drive_state[drive].flags);\n\t\t\tif (bdev_check_media_change(bdev))\n\t\t\t\tfloppy_revalidate(bdev->bd_disk);\n\t\t\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t\tif (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags))\n\t\t\t\tgoto out;\n\t\t}\n\t\tres = -EROFS;\n\t\tif ((mode & FMODE_WRITE) &&\n\t\t    !test_bit(FD_DISK_WRITABLE_BIT, &drive_state[drive].flags))\n\t\t\tgoto out;\n\t}\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\nout:\n\tdrive_state[drive].fd_ref--;\n\n\tif (!drive_state[drive].fd_ref)\n\t\topened_bdev[drive] = NULL;\nout2:\n\tmutex_unlock(&open_lock);\n\tmutex_unlock(&floppy_mutex);\n\treturn res;\n}\n\n/*\n * Check if the disk has been changed or if a change has been faked.\n */\nstatic unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\n\tif (time_after(jiffies, drive_state[drive].last_checked + drive_params[drive].checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}\n\n/*\n * This implements \"read block 0\" for floppy_revalidate().\n * Needed for format autodetection, checking whether there is\n * a disk in the drive, and whether that disk is writable.\n */\n\nstruct rb0_cbdata {\n\tint drive;\n\tstruct completion complete;\n};\n\nstatic void floppy_rb0_cb(struct bio *bio)\n{\n\tstruct rb0_cbdata *cbdata = (struct rb0_cbdata *)bio->bi_private;\n\tint drive = cbdata->drive;\n\n\tif (bio->bi_status) {\n\t\tpr_info(\"floppy: error %d while reading block 0\\n\",\n\t\t\tbio->bi_status);\n\t\tset_bit(FD_OPEN_SHOULD_FAIL_BIT, &drive_state[drive].flags);\n\t}\n\tcomplete(&cbdata->complete);\n}\n\nstatic int __floppy_read_block_0(struct block_device *bdev, int drive)\n{\n\tstruct bio bio;\n\tstruct bio_vec bio_vec;\n\tstruct page *page;\n\tstruct rb0_cbdata cbdata;\n\n\tpage = alloc_page(GFP_NOIO);\n\tif (!page) {\n\t\tprocess_fd_request();\n\t\treturn -ENOMEM;\n\t}\n\n\tcbdata.drive = drive;\n\n\tbio_init(&bio, &bio_vec, 1);\n\tbio_set_dev(&bio, bdev);\n\tbio_add_page(&bio, page, block_size(bdev), 0);\n\n\tbio.bi_iter.bi_sector = 0;\n\tbio.bi_flags |= (1 << BIO_QUIET);\n\tbio.bi_private = &cbdata;\n\tbio.bi_end_io = floppy_rb0_cb;\n\tbio_set_op_attrs(&bio, REQ_OP_READ, 0);\n\n\tinit_completion(&cbdata.complete);\n\n\tsubmit_bio(&bio);\n\tprocess_fd_request();\n\n\twait_for_completion(&cbdata.complete);\n\n\t__free_page(page);\n\n\treturn 0;\n}\n\n/* revalidate the floppy disk, i.e. trigger format autodetection by reading\n * the bootblock (block 0). \"Autodetection\" is also needed to check whether\n * there is a disk in the drive at all... Thus we also do it for fixed\n * geometry formats */\nstatic int floppy_revalidate(struct gendisk *disk)\n{\n\tint drive = (long)disk->private_data;\n\tint cf;\n\tint res = 0;\n\n\tif (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t    test_bit(FD_VERIFY_BIT, &drive_state[drive].flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive)) {\n\t\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t\t \"VFS: revalidate called on non-open device.\\n\"))\n\t\t\treturn -EFAULT;\n\n\t\tres = lock_fdc(drive);\n\t\tif (res)\n\t\t\treturn res;\n\t\tcf = (test_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags) ||\n\t\t      test_bit(FD_VERIFY_BIT, &drive_state[drive].flags));\n\t\tif (!(cf || test_bit(drive, &fake_change) || drive_no_geom(drive))) {\n\t\t\tprocess_fd_request();\t/*already done by another thread */\n\t\t\treturn 0;\n\t\t}\n\t\tdrive_state[drive].maxblock = 0;\n\t\tdrive_state[drive].maxtrack = 0;\n\t\tif (buffer_drive == drive)\n\t\t\tbuffer_track = -1;\n\t\tclear_bit(drive, &fake_change);\n\t\tclear_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tif (cf)\n\t\t\tdrive_state[drive].generation++;\n\t\tif (drive_no_geom(drive)) {\n\t\t\t/* auto-sensing */\n\t\t\tres = __floppy_read_block_0(opened_bdev[drive], drive);\n\t\t} else {\n\t\t\tif (cf)\n\t\t\t\tpoll_drive(false, FD_RAW_NEED_DISK);\n\t\t\tprocess_fd_request();\n\t\t}\n\t}\n\tset_capacity(disk, floppy_sizes[drive_state[drive].fd_device]);\n\treturn res;\n}\n\nstatic const struct block_device_operations floppy_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= floppy_open,\n\t.release\t\t= floppy_release,\n\t.ioctl\t\t\t= fd_ioctl,\n\t.getgeo\t\t\t= fd_getgeo,\n\t.check_events\t\t= floppy_check_events,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= fd_compat_ioctl,\n#endif\n};\n\n/*\n * Floppy Driver initialization\n * =============================\n */\n\n/* Determine the floppy disk controller type */\n/* This routine was written by David C. Niemi */\nstatic char __init get_fdc_version(int fdc)\n{\n\tint r;\n\n\toutput_byte(fdc, FD_DUMPREGS);\t/* 82072 and better know DUMPREGS */\n\tif (fdc_state[fdc].reset)\n\t\treturn FDC_NONE;\n\tr = result(fdc);\n\tif (r <= 0x00)\n\t\treturn FDC_NONE;\t/* No FDC present ??? */\n\tif ((r == 1) && (reply_buffer[0] == 0x80)) {\n\t\tpr_info(\"FDC %d is an 8272A\\n\", fdc);\n\t\treturn FDC_8272A;\t/* 8272a/765 don't know DUMPREGS */\n\t}\n\tif (r != 10) {\n\t\tpr_info(\"FDC %d init: DUMPREGS: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\n\tif (!fdc_configure(fdc)) {\n\t\tpr_info(\"FDC %d is an 82072\\n\", fdc);\n\t\treturn FDC_82072;\t/* 82072 doesn't know CONFIGURE */\n\t}\n\n\toutput_byte(fdc, FD_PERPENDICULAR);\n\tif (need_more_output(fdc) == MORE_OUTPUT) {\n\t\toutput_byte(fdc, 0);\n\t} else {\n\t\tpr_info(\"FDC %d is an 82072A\\n\", fdc);\n\t\treturn FDC_82072A;\t/* 82072A as found on Sparcs. */\n\t}\n\n\toutput_byte(fdc, FD_UNLOCK);\n\tr = result(fdc);\n\tif ((r == 1) && (reply_buffer[0] == 0x80)) {\n\t\tpr_info(\"FDC %d is a pre-1991 82077\\n\", fdc);\n\t\treturn FDC_82077_ORIG;\t/* Pre-1991 82077, doesn't know\n\t\t\t\t\t * LOCK/UNLOCK */\n\t}\n\tif ((r != 1) || (reply_buffer[0] != 0x00)) {\n\t\tpr_info(\"FDC %d init: UNLOCK: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\toutput_byte(fdc, FD_PARTID);\n\tr = result(fdc);\n\tif (r != 1) {\n\t\tpr_info(\"FDC %d init: PARTID: unexpected return of %d bytes.\\n\",\n\t\t\tfdc, r);\n\t\treturn FDC_UNKNOWN;\n\t}\n\tif (reply_buffer[0] == 0x80) {\n\t\tpr_info(\"FDC %d is a post-1991 82077\\n\", fdc);\n\t\treturn FDC_82077;\t/* Revised 82077AA passes all the tests */\n\t}\n\tswitch (reply_buffer[0] >> 5) {\n\tcase 0x0:\n\t\t/* Either a 82078-1 or a 82078SL running at 5Volt */\n\t\tpr_info(\"FDC %d is an 82078.\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x1:\n\t\tpr_info(\"FDC %d is a 44pin 82078\\n\", fdc);\n\t\treturn FDC_82078;\n\tcase 0x2:\n\t\tpr_info(\"FDC %d is a S82078B\\n\", fdc);\n\t\treturn FDC_S82078B;\n\tcase 0x3:\n\t\tpr_info(\"FDC %d is a National Semiconductor PC87306\\n\", fdc);\n\t\treturn FDC_87306;\n\tdefault:\n\t\tpr_info(\"FDC %d init: 82078 variant with unknown PARTID=%d.\\n\",\n\t\t\tfdc, reply_buffer[0] >> 5);\n\t\treturn FDC_82078_UNKN;\n\t}\n}\t\t\t\t/* get_fdc_version */\n\n/* lilo configuration */\n\nstatic void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}\n\nstatic void __init daring(int *ints, int param, int param2)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param) {\n\t\t\tdefault_drive_params[i].params.select_delay = 0;\n\t\t\tdefault_drive_params[i].params.flags |=\n\t\t\t    FD_SILENT_DCL_CLEAR;\n\t\t} else {\n\t\t\tdefault_drive_params[i].params.select_delay =\n\t\t\t    2 * HZ / 100;\n\t\t\tdefault_drive_params[i].params.flags &=\n\t\t\t    ~FD_SILENT_DCL_CLEAR;\n\t\t}\n\t}\n\tDPRINT(\"Assuming %s floppy hardware\\n\", param ? \"standard\" : \"broken\");\n}\n\nstatic void __init set_cmos(int *ints, int dummy, int dummy2)\n{\n\tint current_drive = 0;\n\n\tif (ints[0] != 2) {\n\t\tDPRINT(\"wrong number of parameters for CMOS\\n\");\n\t\treturn;\n\t}\n\tcurrent_drive = ints[1];\n\tif (current_drive < 0 || current_drive >= 8) {\n\t\tDPRINT(\"bad drive for set_cmos\\n\");\n\t\treturn;\n\t}\n#if N_FDC > 1\n\tif (current_drive >= 4 && !FDC2)\n\t\tFDC2 = 0x370;\n#endif\n\tdrive_params[current_drive].cmos = ints[2];\n\tDPRINT(\"setting CMOS code to %d\\n\", ints[2]);\n}\n\nstatic struct param_table {\n\tconst char *name;\n\tvoid (*fn) (int *ints, int param, int param2);\n\tint *var;\n\tint def_param;\n\tint param2;\n} config_params[] __initdata = {\n\t{\"allowed_drive_mask\", NULL, &allowed_drive_mask, 0xff, 0}, /* obsolete */\n\t{\"all_drives\", NULL, &allowed_drive_mask, 0xff, 0},\t/* obsolete */\n\t{\"asus_pci\", NULL, &allowed_drive_mask, 0x33, 0},\n\t{\"irq\", NULL, &FLOPPY_IRQ, 6, 0},\n\t{\"dma\", NULL, &FLOPPY_DMA, 2, 0},\n\t{\"daring\", daring, NULL, 1, 0},\n#if N_FDC > 1\n\t{\"two_fdc\", NULL, &FDC2, 0x370, 0},\n\t{\"one_fdc\", NULL, &FDC2, 0, 0},\n#endif\n\t{\"thinkpad\", floppy_set_flags, NULL, 1, FD_INVERTED_DCL},\n\t{\"broken_dcl\", floppy_set_flags, NULL, 1, FD_BROKEN_DCL},\n\t{\"messages\", floppy_set_flags, NULL, 1, FTD_MSG},\n\t{\"silent_dcl_clear\", floppy_set_flags, NULL, 1, FD_SILENT_DCL_CLEAR},\n\t{\"debug\", floppy_set_flags, NULL, 1, FD_DEBUG},\n\t{\"nodma\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"omnibook\", NULL, &can_use_virtual_dma, 1, 0},\n\t{\"yesdma\", NULL, &can_use_virtual_dma, 0, 0},\n\t{\"fifo_depth\", NULL, &fifo_depth, 0xa, 0},\n\t{\"nofifo\", NULL, &no_fifo, 0x20, 0},\n\t{\"usefifo\", NULL, &no_fifo, 0, 0},\n\t{\"cmos\", set_cmos, NULL, 0, 0},\n\t{\"slow\", NULL, &slow_floppy, 1, 0},\n\t{\"unexpected_interrupts\", NULL, &print_unex, 1, 0},\n\t{\"no_unexpected_interrupts\", NULL, &print_unex, 0, 0},\n\t{\"L40SX\", NULL, &print_unex, 0, 0}\n\n\tEXTRA_FLOPPY_PARAMS\n};\n\nstatic int __init floppy_setup(char *str)\n{\n\tint i;\n\tint param;\n\tint ints[11];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (str) {\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++) {\n\t\t\tif (strcmp(str, config_params[i].name) == 0) {\n\t\t\t\tif (ints[0])\n\t\t\t\t\tparam = ints[1];\n\t\t\t\telse\n\t\t\t\t\tparam = config_params[i].def_param;\n\t\t\t\tif (config_params[i].fn)\n\t\t\t\t\tconfig_params[i].fn(ints, param,\n\t\t\t\t\t\t\t    config_params[i].\n\t\t\t\t\t\t\t    param2);\n\t\t\t\tif (config_params[i].var) {\n\t\t\t\t\tDPRINT(\"%s=%d\\n\", str, param);\n\t\t\t\t\t*config_params[i].var = param;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (str) {\n\t\tDPRINT(\"unknown floppy option [%s]\\n\", str);\n\n\t\tDPRINT(\"allowed options are:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(config_params); i++)\n\t\t\tpr_cont(\" %s\", config_params[i].name);\n\t\tpr_cont(\"\\n\");\n\t} else\n\t\tDPRINT(\"botched floppy option\\n\");\n\tDPRINT(\"Read Documentation/admin-guide/blockdev/floppy.rst\\n\");\n\treturn 0;\n}\n\nstatic int have_no_fdc = -ENODEV;\n\nstatic ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", drive_params[drive].cmos);\n}\n\nstatic DEVICE_ATTR(cmos, 0444, floppy_cmos_show, NULL);\n\nstatic struct attribute *floppy_dev_attrs[] = {\n\t&dev_attr_cmos.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(floppy_dev);\n\nstatic void floppy_device_release(struct device *dev)\n{\n}\n\nstatic int floppy_resume(struct device *dev)\n{\n\tint fdc;\n\tint saved_drive;\n\n\tsaved_drive = current_drive;\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tuser_reset_fdc(REVDRIVE(fdc, 0), FD_RESET_ALWAYS, false);\n\tset_fdc(saved_drive);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops floppy_pm_ops = {\n\t.resume = floppy_resume,\n\t.restore = floppy_resume,\n};\n\nstatic struct platform_driver floppy_driver = {\n\t.driver = {\n\t\t   .name = \"floppy\",\n\t\t   .pm = &floppy_pm_ops,\n\t},\n};\n\nstatic const struct blk_mq_ops floppy_mq_ops = {\n\t.queue_rq = floppy_queue_rq,\n};\n\nstatic struct platform_device floppy_device[N_DRIVE];\n\nstatic bool floppy_available(int drive)\n{\n\tif (!(allowed_drive_mask & (1 << drive)))\n\t\treturn false;\n\tif (fdc_state[FDC(drive)].version == FDC_NONE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int floppy_alloc_disk(unsigned int drive, unsigned int type)\n{\n\tstruct gendisk *disk;\n\tint err;\n\n\tdisk = alloc_disk(1);\n\tif (!disk)\n\t\treturn -ENOMEM;\n\n\tdisk->queue = blk_mq_init_queue(&tag_sets[drive]);\n\tif (IS_ERR(disk->queue)) {\n\t\terr = PTR_ERR(disk->queue);\n\t\tdisk->queue = NULL;\n\t\tput_disk(disk);\n\t\treturn err;\n\t}\n\n\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\tblk_queue_max_hw_sectors(disk->queue, 64);\n\tdisk->major = FLOPPY_MAJOR;\n\tdisk->first_minor = TOMINOR(drive) | (type << 2);\n\tdisk->fops = &floppy_fops;\n\tdisk->events = DISK_EVENT_MEDIA_CHANGE;\n\tif (type)\n\t\tsprintf(disk->disk_name, \"fd%d_type%d\", drive, type);\n\telse\n\t\tsprintf(disk->disk_name, \"fd%d\", drive);\n\t/* to be cleaned up... */\n\tdisk->private_data = (void *)(long)drive;\n\tdisk->flags |= GENHD_FL_REMOVABLE;\n\n\tdisks[drive][type] = disk;\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(floppy_probe_lock);\n\nstatic void floppy_probe(dev_t dev)\n{\n\tunsigned int drive = (MINOR(dev) & 3) | ((MINOR(dev) & 0x80) >> 5);\n\tunsigned int type = (MINOR(dev) >> 2) & 0x1f;\n\n\tif (drive >= N_DRIVE || !floppy_available(drive) ||\n\t    type >= ARRAY_SIZE(floppy_type))\n\t\treturn;\n\n\tmutex_lock(&floppy_probe_lock);\n\tif (!disks[drive][type]) {\n\t\tif (floppy_alloc_disk(drive, type) == 0)\n\t\t\tadd_disk(disks[drive][type]);\n\t}\n\tmutex_unlock(&floppy_probe_lock);\n}\n\nstatic int __init do_floppy_init(void)\n{\n\tint i, unit, drive, err;\n\n\tset_debugt();\n\tinterruptjiffies = resultjiffies = jiffies;\n\n#if defined(CONFIG_PPC)\n\tif (check_legacy_ioport(FDC1))\n\t\treturn -ENODEV;\n#endif\n\n\traw_cmd = NULL;\n\n\tfloppy_wq = alloc_ordered_workqueue(\"floppy\", 0);\n\tif (!floppy_wq)\n\t\treturn -ENOMEM;\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&tag_sets[drive], 0, sizeof(tag_sets[drive]));\n\t\ttag_sets[drive].ops = &floppy_mq_ops;\n\t\ttag_sets[drive].nr_hw_queues = 1;\n\t\ttag_sets[drive].nr_maps = 1;\n\t\ttag_sets[drive].queue_depth = 2;\n\t\ttag_sets[drive].numa_node = NUMA_NO_NODE;\n\t\ttag_sets[drive].flags = BLK_MQ_F_SHOULD_MERGE;\n\t\terr = blk_mq_alloc_tag_set(&tag_sets[drive]);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\terr = floppy_alloc_disk(drive, 0);\n\t\tif (err)\n\t\t\tgoto out_put_disk;\n\n\t\ttimer_setup(&motor_off_timer[drive], motor_off_callback, 0);\n\t}\n\n\terr = __register_blkdev(FLOPPY_MAJOR, \"fd\", floppy_probe);\n\tif (err)\n\t\tgoto out_put_disk;\n\n\terr = platform_driver_register(&floppy_driver);\n\tif (err)\n\t\tgoto out_unreg_blkdev;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (ITYPE(i))\n\t\t\tfloppy_sizes[i] = floppy_type[ITYPE(i)].size;\n\t\telse\n\t\t\tfloppy_sizes[i] = MAX_DISK_SIZE << 1;\n\n\treschedule_timeout(MAXTIMEOUT, \"floppy init\");\n\tconfig_types();\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tmemset(&fdc_state[i], 0, sizeof(*fdc_state));\n\t\tfdc_state[i].dtr = -1;\n\t\tfdc_state[i].dor = 0x4;\n#if defined(__sparc__) || defined(__mc68000__)\n\t/*sparcs/sun3x don't have a DOR reset which we can fall back on to */\n#ifdef __mc68000__\n\t\tif (MACH_IS_SUN3X)\n#endif\n\t\t\tfdc_state[i].version = FDC_82072A;\n#endif\n\t}\n\n\tuse_virtual_dma = can_use_virtual_dma & 1;\n\tfdc_state[0].address = FDC1;\n\tif (fdc_state[0].address == -1) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -ENODEV;\n\t\tgoto out_unreg_driver;\n\t}\n#if N_FDC > 1\n\tfdc_state[1].address = FDC2;\n#endif\n\n\tcurrent_fdc = 0;\t/* reset fdc in case of unexpected interrupt */\n\terr = floppy_grab_irq_and_dma();\n\tif (err) {\n\t\tcancel_delayed_work(&fd_timeout);\n\t\terr = -EBUSY;\n\t\tgoto out_unreg_driver;\n\t}\n\n\t/* initialise drive state */\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tmemset(&drive_state[drive], 0, sizeof(drive_state[drive]));\n\t\tmemset(&write_errors[drive], 0, sizeof(write_errors[drive]));\n\t\tset_bit(FD_DISK_NEWCHANGE_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_DISK_CHANGED_BIT, &drive_state[drive].flags);\n\t\tset_bit(FD_VERIFY_BIT, &drive_state[drive].flags);\n\t\tdrive_state[drive].fd_device = -1;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t}\n\t/*\n\t * Small 10 msec delay to let through any interrupt that\n\t * initialization might have triggered, to not\n\t * confuse detection:\n\t */\n\tmsleep(10);\n\n\tfor (i = 0; i < N_FDC; i++) {\n\t\tfdc_state[i].driver_version = FD_DRIVER_VERSION;\n\t\tfor (unit = 0; unit < 4; unit++)\n\t\t\tfdc_state[i].track[unit] = 0;\n\t\tif (fdc_state[i].address == -1)\n\t\t\tcontinue;\n\t\tfdc_state[i].rawcmd = 2;\n\t\tif (user_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false)) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tfdc_state[i].version = FDC_NONE;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Try to determine the floppy controller type */\n\t\tfdc_state[i].version = get_fdc_version(i);\n\t\tif (fdc_state[i].version == FDC_NONE) {\n\t\t\t/* free ioports reserved by floppy_grab_irq_and_dma() */\n\t\t\tfloppy_release_regions(i);\n\t\t\tfdc_state[i].address = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (can_use_virtual_dma == 2 &&\n\t\t    fdc_state[i].version < FDC_82072A)\n\t\t\tcan_use_virtual_dma = 0;\n\n\t\thave_no_fdc = 0;\n\t\t/* Not all FDCs seem to be able to handle the version command\n\t\t * properly, so force a reset for the standard FDC clones,\n\t\t * to avoid interrupt garbage.\n\t\t */\n\t\tuser_reset_fdc(REVDRIVE(i, 0), FD_RESET_ALWAYS, false);\n\t}\n\tcurrent_fdc = 0;\n\tcancel_delayed_work(&fd_timeout);\n\tcurrent_drive = 0;\n\tinitialized = true;\n\tif (have_no_fdc) {\n\t\tDPRINT(\"no floppy controllers found\\n\");\n\t\terr = have_no_fdc;\n\t\tgoto out_release_dma;\n\t}\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!floppy_available(drive))\n\t\t\tcontinue;\n\n\t\tfloppy_device[drive].name = floppy_device_name;\n\t\tfloppy_device[drive].id = drive;\n\t\tfloppy_device[drive].dev.release = floppy_device_release;\n\t\tfloppy_device[drive].dev.groups = floppy_dev_groups;\n\n\t\terr = platform_device_register(&floppy_device[drive]);\n\t\tif (err)\n\t\t\tgoto out_remove_drives;\n\n\t\tdevice_add_disk(&floppy_device[drive].dev, disks[drive][0],\n\t\t\t\tNULL);\n\t}\n\n\treturn 0;\n\nout_remove_drives:\n\twhile (drive--) {\n\t\tif (floppy_available(drive)) {\n\t\t\tdel_gendisk(disks[drive][0]);\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t}\nout_release_dma:\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\nout_unreg_driver:\n\tplatform_driver_unregister(&floppy_driver);\nout_unreg_blkdev:\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\nout_put_disk:\n\tdestroy_workqueue(floppy_wq);\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tif (!disks[drive][0])\n\t\t\tbreak;\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\t\tblk_cleanup_queue(disks[drive][0]->queue);\n\t\tdisks[drive][0]->queue = NULL;\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\t\tput_disk(disks[drive][0]);\n\t}\n\treturn err;\n}\n\n#ifndef MODULE\nstatic __init void floppy_async_init(void *data, async_cookie_t cookie)\n{\n\tdo_floppy_init();\n}\n#endif\n\nstatic int __init floppy_init(void)\n{\n#ifdef MODULE\n\treturn do_floppy_init();\n#else\n\t/* Don't hold up the bootup by the floppy initialization */\n\tasync_schedule(floppy_async_init, NULL);\n\treturn 0;\n#endif\n}\n\nstatic const struct io_region {\n\tint offset;\n\tint size;\n} io_regions[] = {\n\t{ 2, 1 },\n\t/* address + 3 is sometimes reserved by pnp bios for motherboard */\n\t{ 4, 2 },\n\t/* address + 6 is reserved, and may be taken by IDE.\n\t * Unfortunately, Adaptec doesn't know this :-(, */\n\t{ 7, 1 },\n};\n\nstatic void floppy_release_allocated_regions(int fdc, const struct io_region *p)\n{\n\twhile (p != io_regions) {\n\t\tp--;\n\t\trelease_region(fdc_state[fdc].address + p->offset, p->size);\n\t}\n}\n\n#define ARRAY_END(X) (&((X)[ARRAY_SIZE(X)]))\n\nstatic int floppy_request_regions(int fdc)\n{\n\tconst struct io_region *p;\n\n\tfor (p = io_regions; p < ARRAY_END(io_regions); p++) {\n\t\tif (!request_region(fdc_state[fdc].address + p->offset,\n\t\t\t\t    p->size, \"floppy\")) {\n\t\t\tDPRINT(\"Floppy io-port 0x%04lx in use\\n\",\n\t\t\t       fdc_state[fdc].address + p->offset);\n\t\t\tfloppy_release_allocated_regions(fdc, p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void floppy_release_regions(int fdc)\n{\n\tfloppy_release_allocated_regions(fdc, ARRAY_END(io_regions));\n}\n\nstatic int floppy_grab_irq_and_dma(void)\n{\n\tint fdc;\n\n\tif (atomic_inc_return(&usage_count) > 1)\n\t\treturn 0;\n\n\t/*\n\t * We might have scheduled a free_irq(), wait it to\n\t * drain first:\n\t */\n\tflush_workqueue(floppy_wq);\n\n\tif (fd_request_irq()) {\n\t\tDPRINT(\"Unable to grab IRQ%d for the floppy driver\\n\",\n\t\t       FLOPPY_IRQ);\n\t\tatomic_dec(&usage_count);\n\t\treturn -1;\n\t}\n\tif (fd_request_dma()) {\n\t\tDPRINT(\"Unable to grab DMA%d for the floppy driver\\n\",\n\t\t       FLOPPY_DMA);\n\t\tif (can_use_virtual_dma & 2)\n\t\t\tuse_virtual_dma = can_use_virtual_dma = 1;\n\t\tif (!(can_use_virtual_dma & 1)) {\n\t\t\tfd_free_irq();\n\t\t\tatomic_dec(&usage_count);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\tif (floppy_request_regions(fdc))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (fdc = 0; fdc < N_FDC; fdc++) {\n\t\tif (fdc_state[fdc].address != -1) {\n\t\t\treset_fdc_info(fdc, 1);\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t\t}\n\t}\n\n\tset_dor(0, ~0, 8);\t/* avoid immediate interrupt */\n\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfdc_outb(fdc_state[fdc].dor, fdc, FD_DOR);\n\t/*\n\t * The driver will try and free resources and relies on us\n\t * to know if they were allocated or not.\n\t */\n\tcurrent_fdc = 0;\n\tirqdma_allocated = 1;\n\treturn 0;\ncleanup:\n\tfd_free_irq();\n\tfd_free_dma();\n\twhile (--fdc >= 0)\n\t\tfloppy_release_regions(fdc);\n\tcurrent_fdc = 0;\n\tatomic_dec(&usage_count);\n\treturn -1;\n}\n\nstatic void floppy_release_irq_and_dma(void)\n{\n\tint fdc;\n#ifndef __sparc__\n\tint drive;\n#endif\n\tlong tmpsize;\n\tunsigned long tmpaddr;\n\n\tif (!atomic_dec_and_test(&usage_count))\n\t\treturn;\n\n\tif (irqdma_allocated) {\n\t\tfd_disable_dma();\n\t\tfd_free_dma();\n\t\tfd_free_irq();\n\t\tirqdma_allocated = 0;\n\t}\n\tset_dor(0, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1, ~8, 0);\n#endif\n\n\tif (floppy_track_buffer && max_buffer_sectors) {\n\t\ttmpsize = max_buffer_sectors * 1024;\n\t\ttmpaddr = (unsigned long)floppy_track_buffer;\n\t\tfloppy_track_buffer = NULL;\n\t\tmax_buffer_sectors = 0;\n\t\tbuffer_min = buffer_max = -1;\n\t\tfd_dma_mem_free(tmpaddr, tmpsize);\n\t}\n#ifndef __sparc__\n\tfor (drive = 0; drive < N_FDC * 4; drive++)\n\t\tif (timer_pending(motor_off_timer + drive))\n\t\t\tpr_info(\"motor off timer %d still active\\n\", drive);\n#endif\n\n\tif (delayed_work_pending(&fd_timeout))\n\t\tpr_info(\"floppy timer still active:%s\\n\", timeout_message);\n\tif (delayed_work_pending(&fd_timer))\n\t\tpr_info(\"auxiliary floppy timer still active\\n\");\n\tif (work_pending(&floppy_work))\n\t\tpr_info(\"work still pending\\n\");\n\tfor (fdc = 0; fdc < N_FDC; fdc++)\n\t\tif (fdc_state[fdc].address != -1)\n\t\t\tfloppy_release_regions(fdc);\n}\n\n#ifdef MODULE\n\nstatic char *floppy;\n\nstatic void __init parse_floppy_cfg_string(char *cfg)\n{\n\tchar *ptr;\n\n\twhile (*cfg) {\n\t\tptr = cfg;\n\t\twhile (*cfg && *cfg != ' ' && *cfg != '\\t')\n\t\t\tcfg++;\n\t\tif (*cfg) {\n\t\t\t*cfg = '\\0';\n\t\t\tcfg++;\n\t\t}\n\t\tif (*ptr)\n\t\t\tfloppy_setup(ptr);\n\t}\n}\n\nstatic int __init floppy_module_init(void)\n{\n\tif (floppy)\n\t\tparse_floppy_cfg_string(floppy);\n\treturn floppy_init();\n}\nmodule_init(floppy_module_init);\n\nstatic void __exit floppy_module_exit(void)\n{\n\tint drive, i;\n\n\tunregister_blkdev(FLOPPY_MAJOR, \"fd\");\n\tplatform_driver_unregister(&floppy_driver);\n\n\tdestroy_workqueue(floppy_wq);\n\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tdel_timer_sync(&motor_off_timer[drive]);\n\n\t\tif (floppy_available(drive)) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\t\tif (disks[drive][i])\n\t\t\t\t\tdel_gendisk(disks[drive][i]);\n\t\t\t}\n\t\t\tplatform_device_unregister(&floppy_device[drive]);\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\tif (disks[drive][i])\n\t\t\t\tblk_cleanup_queue(disks[drive][i]->queue);\n\t\t}\n\t\tblk_mq_free_tag_set(&tag_sets[drive]);\n\n\t\t/*\n\t\t * These disks have not called add_disk().  Don't put down\n\t\t * queue reference in put_disk().\n\t\t */\n\t\tif (!(allowed_drive_mask & (1 << drive)) ||\n\t\t    fdc_state[FDC(drive)].version == FDC_NONE) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\t\tif (disks[drive][i])\n\t\t\t\t\tdisks[drive][i]->queue = NULL;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(floppy_type); i++) {\n\t\t\tif (disks[drive][i])\n\t\t\t\tput_disk(disks[drive][i]);\n\t\t}\n\t}\n\n\tcancel_delayed_work_sync(&fd_timeout);\n\tcancel_delayed_work_sync(&fd_timer);\n\n\tif (atomic_read(&usage_count))\n\t\tfloppy_release_irq_and_dma();\n\n\t/* eject disk, if any */\n\tfd_eject(0);\n}\n\nmodule_exit(floppy_module_exit);\n\nmodule_param(floppy, charp, 0);\nmodule_param(FLOPPY_IRQ, int, 0);\nmodule_param(FLOPPY_DMA, int, 0);\nMODULE_AUTHOR(\"Alain L. Knaff\");\nMODULE_SUPPORTED_DEVICE(\"fd\");\nMODULE_LICENSE(\"GPL\");\n\n/* This doesn't actually get used other than for module information */\nstatic const struct pnp_device_id floppy_pnpids[] = {\n\t{\"PNP0700\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pnp, floppy_pnpids);\n\n#else\n\n__setup(\"floppy=\", floppy_setup);\nmodule_init(floppy_init)\n#endif\n\nMODULE_ALIAS_BLOCKDEV_MAJOR(FLOPPY_MAJOR);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 2881}, "message": "error: we previously assumed 'current_req' could be null (see line 2869)"}], "macros": [], "notes": [], "path": "/src/drivers/block/floppy.c", "reportHash": "ea69fa6d996319031328057b238d2c6e", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3134}, "message": "warn: check that 'cmd' doesn't leak information (struct has a hole after 'flags')"}], "macros": [], "notes": [], "path": "/src/drivers/block/floppy.c", "reportHash": "3dbe2e36cb0eb72cc914a8dc37fbf1c9", "checkerName": "smatch.check_rosenberg", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3635}, "message": "error: uninitialized symbol 'outparam'."}], "macros": [], "notes": [], "path": "/src/drivers/block/floppy.c", "reportHash": "f6483eba679d76a234d04cdac430934f", "checkerName": "smatch.check_uninitialized", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 4632}, "message": "warn: potential spectre issue 'disks' [w] (local cap)"}], "macros": [], "notes": [], "path": "/src/drivers/block/floppy.c", "reportHash": "c96f696f191b36e26ef8a1d5bbf08aef", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
