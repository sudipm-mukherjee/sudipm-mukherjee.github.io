<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/lpfc/lpfc_attr.c", "content": "/*******************************************************************\n * This file is part of the Emulex Linux Device Driver for         *\n * Fibre Channel Host Bus Adapters.                                *\n * Copyright (C) 2017-2020 Broadcom. All Rights Reserved. The term *\n * \u201cBroadcom\u201d refers to Broadcom Inc. and/or its subsidiaries.  *\n * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *\n * EMULEX and SLI are trademarks of Emulex.                        *\n * www.broadcom.com                                                *\n * Portions Copyright (C) 2004-2005 Christoph Hellwig              *\n *                                                                 *\n * This program is free software; you can redistribute it and/or   *\n * modify it under the terms of version 2 of the GNU General       *\n * Public License as published by the Free Software Foundation.    *\n * This program is distributed in the hope that it will be useful. *\n * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *\n * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *\n * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *\n * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *\n * TO BE LEGALLY INVALID.  See the GNU General Public License for  *\n * more details, a copy of which can be found in the file COPYING  *\n * included with this package.                                     *\n *******************************************************************/\n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/aer.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_nvme.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_version.h\"\n#include \"lpfc_compat.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_attr.h\"\n\n#define LPFC_DEF_DEVLOSS_TMO\t30\n#define LPFC_MIN_DEVLOSS_TMO\t1\n#define LPFC_MAX_DEVLOSS_TMO\t255\n\n/*\n * Write key size should be multiple of 4. If write key is changed\n * make sure that library write key is also changed.\n */\n#define LPFC_REG_WRITE_KEY_SIZE\t4\n#define LPFC_REG_WRITE_KEY\t\"EMLX\"\n\nconst char *const trunk_errmsg[] = {\t/* map errcode */\n\t\"\",\t/* There is no such error code at index 0*/\n\t\"link negotiated speed does not match existing\"\n\t\t\" trunk - link was \\\"low\\\" speed\",\n\t\"link negotiated speed does not match\"\n\t\t\" existing trunk - link was \\\"middle\\\" speed\",\n\t\"link negotiated speed does not match existing\"\n\t\t\" trunk - link was \\\"high\\\" speed\",\n\t\"Attached to non-trunking port - F_Port\",\n\t\"Attached to non-trunking port - N_Port\",\n\t\"FLOGI response timeout\",\n\t\"non-FLOGI frame received\",\n\t\"Invalid FLOGI response\",\n\t\"Trunking initialization protocol\",\n\t\"Trunk peer device mismatch\",\n};\n\n/**\n * lpfc_jedec_to_ascii - Hex to ascii convertor according to JEDEC rules\n * @incr: integer to convert.\n * @hdw: ascii string holding converted integer plus a string terminator.\n *\n * Description:\n * JEDEC Joint Electron Device Engineering Council.\n * Convert a 32 bit integer composed of 8 nibbles into an 8 byte ascii\n * character string. The string is then terminated with a NULL in byte 9.\n * Hex 0-9 becomes ascii '0' to '9'.\n * Hex a-f becomes ascii '=' to 'B' capital B.\n *\n * Notes:\n * Coded for 32 bit integers only.\n **/\nstatic void\nlpfc_jedec_to_ascii(int incr, char hdw[])\n{\n\tint i, j;\n\tfor (i = 0; i < 8; i++) {\n\t\tj = (incr & 0xf);\n\t\tif (j <= 9)\n\t\t\thdw[7 - i] = 0x30 +  j;\n\t\t else\n\t\t\thdw[7 - i] = 0x61 + j - 10;\n\t\tincr = (incr >> 4);\n\t}\n\thdw[8] = 0;\n\treturn;\n}\n\n/**\n * lpfc_drvr_version_show - Return the Emulex driver string with version number\n * @dev: class unused variable.\n * @attr: device attribute, not used.\n * @buf: on return contains the module description text.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_drvr_version_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, LPFC_MODULE_DESC \"\\n\");\n}\n\n/**\n * lpfc_enable_fip_show - Return the fip mode of the HBA\n * @dev: class unused variable.\n * @attr: device attribute, not used.\n * @buf: on return contains the module description text.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_enable_fip_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->hba_flag & HBA_FIP_SUPPORT)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"1\\n\");\n\telse\n\t\treturn scnprintf(buf, PAGE_SIZE, \"0\\n\");\n}\n\nstatic ssize_t\nlpfc_nvme_info_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_nvmet_tgtport *tgtp;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct nvme_fc_remote_port *nrport;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tuint64_t data1, data2, data3;\n\tuint64_t totin, totout, tot;\n\tchar *statep;\n\tint i;\n\tint len = 0;\n\tchar tmp[LPFC_MAX_NVME_INFO_TMP_LEN] = {0};\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_NVME)) {\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"NVME Disabled\\n\");\n\t\treturn len;\n\t}\n\tif (phba->nvmet_support) {\n\t\tif (!phba->targetport) {\n\t\t\tlen = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"NVME Target: x%llx is not allocated\\n\",\n\t\t\t\t\twwn_to_u64(vport->fc_portname.u.wwn));\n\t\t\treturn len;\n\t\t}\n\t\t/* Port state is only one of two values for now. */\n\t\tif (phba->targetport->port_id)\n\t\t\tstatep = \"REGISTERED\";\n\t\telse\n\t\t\tstatep = \"INIT\";\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"NVME Target Enabled  State %s\\n\",\n\t\t\t  statep);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"%s%d WWPN x%llx WWNN x%llx DID x%06x\\n\",\n\t\t\t  \"NVME Target: lpfc\",\n\t\t\t  phba->brd_no,\n\t\t\t  wwn_to_u64(vport->fc_portname.u.wwn),\n\t\t\t  wwn_to_u64(vport->fc_nodename.u.wwn),\n\t\t\t  phba->targetport->port_id);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tif (strlcat(buf, \"\\nNVME Target: Statistics\\n\", PAGE_SIZE)\n\t\t    >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\ttgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"LS: Rcv %08x Drop %08x Abort %08x\\n\",\n\t\t\t  atomic_read(&tgtp->rcv_ls_req_in),\n\t\t\t  atomic_read(&tgtp->rcv_ls_req_drop),\n\t\t\t  atomic_read(&tgtp->xmt_ls_abort));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tif (atomic_read(&tgtp->rcv_ls_req_in) !=\n\t\t    atomic_read(&tgtp->rcv_ls_req_out)) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \"Rcv LS: in %08x != out %08x\\n\",\n\t\t\t\t  atomic_read(&tgtp->rcv_ls_req_in),\n\t\t\t\t  atomic_read(&tgtp->rcv_ls_req_out));\n\t\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"LS: Xmt %08x Drop %08x Cmpl %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_ls_drop),\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_cmpl));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"LS: RSP Abort %08x xb %08x Err %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_aborted),\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_xb_set),\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_error));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP: Rcv %08x Defer %08x Release %08x \"\n\t\t\t  \"Drop %08x\\n\",\n\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_in),\n\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_defer),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_release),\n\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_drop));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tif (atomic_read(&tgtp->rcv_fcp_cmd_in) !=\n\t\t    atomic_read(&tgtp->rcv_fcp_cmd_out)) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \"Rcv FCP: in %08x != out %08x\\n\",\n\t\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_in),\n\t\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_out));\n\t\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP Rsp: RD %08x rsp %08x WR %08x rsp %08x \"\n\t\t\t  \"drop %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_read),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_read_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_write),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_drop));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP Rsp Cmpl: %08x err %08x drop %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_cmpl),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_error),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_drop));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP Rsp Abort: %08x xb %08x xricqe  %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_aborted),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_xb_set),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_xri_abort_cqe));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"ABORT: Xmt %08x Cmpl %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_abort),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_abort_cmpl));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_abort_sol),\n\t\t\t  atomic_read(&tgtp->xmt_abort_unsol),\n\t\t\t  atomic_read(&tgtp->xmt_abort_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_abort_rsp_error));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"DELAY: ctx %08x  fod %08x wqfull %08x\\n\",\n\t\t\t  atomic_read(&tgtp->defer_ctx),\n\t\t\t  atomic_read(&tgtp->defer_fod),\n\t\t\t  atomic_read(&tgtp->defer_wqfull));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\t/* Calculate outstanding IOs */\n\t\ttot = atomic_read(&tgtp->rcv_fcp_cmd_drop);\n\t\ttot += atomic_read(&tgtp->xmt_fcp_release);\n\t\ttot = atomic_read(&tgtp->rcv_fcp_cmd_in) - tot;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"IO_CTX: %08x  WAIT: cur %08x tot %08x\\n\"\n\t\t\t  \"CTX Outstanding %08llx\\n\\n\",\n\t\t\t  phba->sli4_hba.nvmet_xri_cnt,\n\t\t\t  phba->sli4_hba.nvmet_io_wait_cnt,\n\t\t\t  phba->sli4_hba.nvmet_io_wait_total,\n\t\t\t  tot);\n\t\tstrlcat(buf, tmp, PAGE_SIZE);\n\t\tgoto buffer_done;\n\t}\n\n\tlocalport = vport->localport;\n\tif (!localport) {\n\t\tlen = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\"NVME Initiator x%llx is not allocated\\n\",\n\t\t\t\twwn_to_u64(vport->fc_portname.u.wwn));\n\t\treturn len;\n\t}\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\tif (strlcat(buf, \"\\nNVME Initiator Enabled\\n\", PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"XRI Dist lpfc%d Total %d IO %d ELS %d\\n\",\n\t\t  phba->brd_no,\n\t\t  phba->sli4_hba.max_cfg_param.max_xri,\n\t\t  phba->sli4_hba.io_xri_max,\n\t\t  lpfc_sli4_get_els_iocb_cnt(phba));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\t/* Port state is only one of two values for now. */\n\tif (localport->port_id)\n\t\tstatep = \"ONLINE\";\n\telse\n\t\tstatep = \"UNKNOWN \";\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"%s%d WWPN x%llx WWNN x%llx DID x%06x %s\\n\",\n\t\t  \"NVME LPORT lpfc\",\n\t\t  phba->brd_no,\n\t\t  wwn_to_u64(vport->fc_portname.u.wwn),\n\t\t  wwn_to_u64(vport->fc_nodename.u.wwn),\n\t\t  localport->port_id, statep);\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tnrport = NULL;\n\t\tspin_lock(&ndlp->lock);\n\t\trport = lpfc_ndlp_get_nrport(ndlp);\n\t\tif (rport)\n\t\t\tnrport = rport->remoteport;\n\t\tspin_unlock(&ndlp->lock);\n\t\tif (!nrport)\n\t\t\tcontinue;\n\n\t\t/* Port state is only one of two values for now. */\n\t\tswitch (nrport->port_state) {\n\t\tcase FC_OBJSTATE_ONLINE:\n\t\t\tstatep = \"ONLINE\";\n\t\t\tbreak;\n\t\tcase FC_OBJSTATE_UNKNOWN:\n\t\t\tstatep = \"UNKNOWN \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatep = \"UNSUPPORTED\";\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Tab in to show lport ownership. */\n\t\tif (strlcat(buf, \"NVME RPORT       \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\t\tif (phba->brd_no >= 10) {\n\t\t\tif (strlcat(buf, \" \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp), \"WWPN x%llx \",\n\t\t\t  nrport->port_name);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"WWNN x%llx \",\n\t\t\t  nrport->node_name);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"DID x%06x \",\n\t\t\t  nrport->port_id);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\n\t\t/* An NVME rport can have multiple roles. */\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_INITIATOR) {\n\t\t\tif (strlcat(buf, \"INITIATOR \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_TARGET) {\n\t\t\tif (strlcat(buf, \"TARGET \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_DISCOVERY) {\n\t\t\tif (strlcat(buf, \"DISCSRVC \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\t\tif (nrport->port_role & ~(FC_PORT_ROLE_NVME_INITIATOR |\n\t\t\t\t\t  FC_PORT_ROLE_NVME_TARGET |\n\t\t\t\t\t  FC_PORT_ROLE_NVME_DISCOVERY)) {\n\t\t\tscnprintf(tmp, sizeof(tmp), \"UNKNOWN ROLE x%x\",\n\t\t\t\t  nrport->port_role);\n\t\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp), \"%s\\n\", statep);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (!lport)\n\t\tgoto buffer_done;\n\n\tif (strlcat(buf, \"\\nNVME Statistics\\n\", PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"LS: Xmt %010x Cmpl %010x Abort %08x\\n\",\n\t\t  atomic_read(&lport->fc4NvmeLsRequests),\n\t\t  atomic_read(&lport->fc4NvmeLsCmpls),\n\t\t  atomic_read(&lport->xmt_ls_abort));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"LS XMIT: Err %08x  CMPL: xb %08x Err %08x\\n\",\n\t\t  atomic_read(&lport->xmt_ls_err),\n\t\t  atomic_read(&lport->cmpl_ls_xb),\n\t\t  atomic_read(&lport->cmpl_ls_err));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\ttotin = 0;\n\ttotout = 0;\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tcstat = &phba->sli4_hba.hdwq[i].nvme_cstat;\n\t\ttot = cstat->io_cmpls;\n\t\ttotin += tot;\n\t\tdata1 = cstat->input_requests;\n\t\tdata2 = cstat->output_requests;\n\t\tdata3 = cstat->control_requests;\n\t\ttotout += (data1 + data2 + data3);\n\t}\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"Total FCP Cmpl %016llx Issue %016llx \"\n\t\t  \"OutIO %016llx\\n\",\n\t\t  totin, totout, totout - totin);\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"\\tabort %08x noxri %08x nondlp %08x qdepth %08x \"\n\t\t  \"wqerr %08x err %08x\\n\",\n\t\t  atomic_read(&lport->xmt_fcp_abort),\n\t\t  atomic_read(&lport->xmt_fcp_noxri),\n\t\t  atomic_read(&lport->xmt_fcp_bad_ndlp),\n\t\t  atomic_read(&lport->xmt_fcp_qdepth),\n\t\t  atomic_read(&lport->xmt_fcp_err),\n\t\t  atomic_read(&lport->xmt_fcp_wqerr));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"FCP CMPL: xb %08x Err %08x\\n\",\n\t\t  atomic_read(&lport->cmpl_fcp_xb),\n\t\t  atomic_read(&lport->cmpl_fcp_err));\n\tstrlcat(buf, tmp, PAGE_SIZE);\n\n\t/* host_lock is already unlocked. */\n\tgoto buffer_done;\n\n unlock_buf_done:\n\tspin_unlock_irq(shost->host_lock);\n\n buffer_done:\n\tlen = strnlen(buf, PAGE_SIZE);\n\n\tif (unlikely(len >= (PAGE_SIZE - 1))) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME,\n\t\t\t\t\"6314 Catching potential buffer \"\n\t\t\t\t\"overflow > PAGE_SIZE = %lu bytes\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tstrlcpy(buf + PAGE_SIZE - 1 -\n\t\t\tstrnlen(LPFC_NVME_INFO_MORE_STR, PAGE_SIZE - 1),\n\t\t\tLPFC_NVME_INFO_MORE_STR,\n\t\t\tstrnlen(LPFC_NVME_INFO_MORE_STR, PAGE_SIZE - 1)\n\t\t\t+ 1);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t\nlpfc_scsi_stat_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba *phba = vport->phba;\n\tint len;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tu64 data1, data2, data3;\n\tu64 tot, totin, totout;\n\tint i;\n\tchar tmp[LPFC_MAX_SCSI_INFO_TMP_LEN] = {0};\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_FCP) ||\n\t    (phba->sli_rev != LPFC_SLI_REV4))\n\t\treturn 0;\n\n\tscnprintf(buf, PAGE_SIZE, \"SCSI HDWQ Statistics\\n\");\n\n\ttotin = 0;\n\ttotout = 0;\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tcstat = &phba->sli4_hba.hdwq[i].scsi_cstat;\n\t\ttot = cstat->io_cmpls;\n\t\ttotin += tot;\n\t\tdata1 = cstat->input_requests;\n\t\tdata2 = cstat->output_requests;\n\t\tdata3 = cstat->control_requests;\n\t\ttotout += (data1 + data2 + data3);\n\n\t\tscnprintf(tmp, sizeof(tmp), \"HDWQ (%d): Rd %016llx Wr %016llx \"\n\t\t\t  \"IO %016llx \", i, data1, data2, data3);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"Cmpl %016llx OutIO %016llx\\n\",\n\t\t\t  tot, ((data1 + data2 + data3) - tot));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\t}\n\tscnprintf(tmp, sizeof(tmp), \"Total FCP Cmpl %016llx Issue %016llx \"\n\t\t  \"OutIO %016llx\\n\", totin, totout, totout - totin);\n\tstrlcat(buf, tmp, PAGE_SIZE);\n\nbuffer_done:\n\tlen = strnlen(buf, PAGE_SIZE);\n\n\treturn len;\n}\n\nstatic ssize_t\nlpfc_bg_info_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->cfg_enable_bg) {\n\t\tif (phba->sli3_options & LPFC_SLI3_BG_ENABLED)\n\t\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"BlockGuard Enabled\\n\");\n\t\telse\n\t\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"BlockGuard Not Supported\\n\");\n\t} else\n\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"BlockGuard Disabled\\n\");\n}\n\nstatic ssize_t\nlpfc_bg_guard_err_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)phba->bg_guard_err_cnt);\n}\n\nstatic ssize_t\nlpfc_bg_apptag_err_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)phba->bg_apptag_err_cnt);\n}\n\nstatic ssize_t\nlpfc_bg_reftag_err_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)phba->bg_reftag_err_cnt);\n}\n\n/**\n * lpfc_info_show - Return some pci info about the host in ascii\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the formatted text from lpfc_info().\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_info_show(struct device *dev, struct device_attribute *attr,\n\t       char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", lpfc_info(host));\n}\n\n/**\n * lpfc_serialnum_show - Return the hba serial number in ascii\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the formatted text serial number.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_serialnum_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->SerialNumber);\n}\n\n/**\n * lpfc_temp_sensor_show - Return the temperature sensor level\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the formatted support level.\n *\n * Description:\n * Returns a number indicating the temperature sensor level currently\n * supported, zero or one in ascii.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_temp_sensor_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->temp_sensor_support);\n}\n\n/**\n * lpfc_modeldesc_show - Return the model description of the hba\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the scsi vpd model description.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_modeldesc_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->ModelDesc);\n}\n\n/**\n * lpfc_modelname_show - Return the model name of the hba\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the scsi vpd model name.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_modelname_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->ModelName);\n}\n\n/**\n * lpfc_programtype_show - Return the program type of the hba\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the scsi vpd program type.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_programtype_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->ProgramType);\n}\n\n/**\n * lpfc_mlomgmt_show - Return the Menlo Maintenance sli flag\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the Menlo Maintenance sli flag.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_mlomgmt_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t(phba->sli.sli_flag & LPFC_MENLO_MAINT));\n}\n\n/**\n * lpfc_vportnum_show - Return the port number in ascii of the hba\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains scsi vpd program type.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_vportnum_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->Port);\n}\n\n/**\n * lpfc_fwrev_show - Return the firmware rev running in the hba\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the scsi vpd program type.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_fwrev_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t if_type;\n\tuint8_t sli_family;\n\tchar fwrev[FW_REV_STR_SIZE];\n\tint len;\n\n\tlpfc_decode_firmware_rev(phba, fwrev, 1);\n\tif_type = phba->sli4_hba.pc_sli4_params.if_type;\n\tsli_family = phba->sli4_hba.pc_sli4_params.sli_family;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%s, sli-%d\\n\",\n\t\t\t       fwrev, phba->sli_rev);\n\telse\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%s, sli-%d:%d:%x\\n\",\n\t\t\t       fwrev, phba->sli_rev, if_type, sli_family);\n\n\treturn len;\n}\n\n/**\n * lpfc_hdw_show - Return the jedec information about the hba\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the scsi vpd program type.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_hdw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tchar hdw[9];\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tlpfc_vpd_t *vp = &phba->vpd;\n\n\tlpfc_jedec_to_ascii(vp->rev.biuRev, hdw);\n\treturn scnprintf(buf, PAGE_SIZE, \"%s %08x %08x\\n\", hdw,\n\t\t\t vp->rev.smRev, vp->rev.smFwRev);\n}\n\n/**\n * lpfc_option_rom_version_show - Return the adapter ROM FCode version\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the ROM and FCode ascii strings.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_option_rom_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tchar fwrev[FW_REV_STR_SIZE];\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t\tphba->OptionROMVersion);\n\n\tlpfc_decode_firmware_rev(phba, fwrev, 1);\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", fwrev);\n}\n\n/**\n * lpfc_state_show - Return the link state of the port\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains text describing the state of the link.\n *\n * Notes:\n * The switch statement has no default so zero will be returned.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_link_state_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint  len = 0;\n\n\tswitch (phba->link_state) {\n\tcase LPFC_LINK_UNKNOWN:\n\tcase LPFC_WARM_START:\n\tcase LPFC_INIT_START:\n\tcase LPFC_INIT_MBX_CMDS:\n\tcase LPFC_LINK_DOWN:\n\tcase LPFC_HBA_ERROR:\n\t\tif (phba->hba_flag & LINK_DISABLED)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"Link Down - User disabled\\n\");\n\t\telse\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"Link Down\\n\");\n\t\tbreak;\n\tcase LPFC_LINK_UP:\n\tcase LPFC_CLEAR_LA:\n\tcase LPFC_HBA_READY:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Link Up - \");\n\n\t\tswitch (vport->port_state) {\n\t\tcase LPFC_LOCAL_CFG_LINK:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\"Configuring Link\\n\");\n\t\t\tbreak;\n\t\tcase LPFC_FDISC:\n\t\tcase LPFC_FLOGI:\n\t\tcase LPFC_FABRIC_CFG_LINK:\n\t\tcase LPFC_NS_REG:\n\t\tcase LPFC_NS_QRY:\n\t\tcase LPFC_BUILD_DISC_LIST:\n\t\tcase LPFC_DISC_AUTH:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Discovery\\n\");\n\t\t\tbreak;\n\t\tcase LPFC_VPORT_READY:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Ready\\n\");\n\t\t\tbreak;\n\n\t\tcase LPFC_VPORT_FAILED:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Failed\\n\");\n\t\t\tbreak;\n\n\t\tcase LPFC_VPORT_UNKNOWN:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Unknown\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (phba->sli.sli_flag & LPFC_MENLO_MAINT)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\"   Menlo Maint Mode\\n\");\n\t\telse if (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\tif (vport->fc_flag & FC_PUBLIC_LOOP)\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Public Loop\\n\");\n\t\t\telse\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Private Loop\\n\");\n\t\t} else {\n\t\t\tif (vport->fc_flag & FC_FABRIC)\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Fabric\\n\");\n\t\t\telse\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Point-2-Point\\n\");\n\t\t}\n\t}\n\n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    ((bf_get(lpfc_sli_intf_if_type,\n\t     &phba->sli4_hba.sli_intf) ==\n\t     LPFC_SLI_INTF_IF_TYPE_6))) {\n\t\tstruct lpfc_trunk_link link = phba->trunk_link;\n\n\t\tif (bf_get(lpfc_conf_trunk_port0, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 0: Link %s %s\\n\",\n\t\t\t\t(link.link0.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link0.fault]);\n\n\t\tif (bf_get(lpfc_conf_trunk_port1, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 1: Link %s %s\\n\",\n\t\t\t\t(link.link1.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link1.fault]);\n\n\t\tif (bf_get(lpfc_conf_trunk_port2, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 2: Link %s %s\\n\",\n\t\t\t\t(link.link2.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link2.fault]);\n\n\t\tif (bf_get(lpfc_conf_trunk_port3, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 3: Link %s %s\\n\",\n\t\t\t\t(link.link3.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link3.fault]);\n\n\t}\n\n\treturn len;\n}\n\n/**\n * lpfc_sli4_protocol_show - Return the fip mode of the HBA\n * @dev: class unused variable.\n * @attr: device attribute, not used.\n * @buf: on return contains the module description text.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_sli4_protocol_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"fc\\n\");\n\n\tif (phba->sli4_hba.lnk_info.lnk_dv == LPFC_LNK_DAT_VAL) {\n\t\tif (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_GE)\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"fcoe\\n\");\n\t\tif (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_FC)\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"fc\\n\");\n\t}\n\treturn scnprintf(buf, PAGE_SIZE, \"unknown\\n\");\n}\n\n/**\n * lpfc_oas_supported_show - Return whether or not Optimized Access Storage\n *\t\t\t    (OAS) is supported.\n * @dev: class unused variable.\n * @attr: device attribute, not used.\n * @buf: on return contains the module description text.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_oas_supported_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tphba->sli4_hba.pc_sli4_params.oas_supported);\n}\n\n/**\n * lpfc_link_state_store - Transition the link_state on an HBA port\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: one or more lpfc_polling_flags values.\n * @count: not used.\n *\n * Returns:\n * -EINVAL if the buffer is not \"up\" or \"down\"\n * return from link state change function if non-zero\n * length of the buf on success\n **/\nstatic ssize_t\nlpfc_link_state_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tint status = -EINVAL;\n\n\tif ((strncmp(buf, \"up\", sizeof(\"up\") - 1) == 0) &&\n\t\t\t(phba->link_state == LPFC_LINK_DOWN))\n\t\tstatus = phba->lpfc_hba_init_link(phba, MBX_NOWAIT);\n\telse if ((strncmp(buf, \"down\", sizeof(\"down\") - 1) == 0) &&\n\t\t\t(phba->link_state >= LPFC_LINK_UP))\n\t\tstatus = phba->lpfc_hba_down_link(phba, MBX_NOWAIT);\n\n\tif (status == 0)\n\t\treturn strlen(buf);\n\telse\n\t\treturn status;\n}\n\n/**\n * lpfc_num_discovered_ports_show - Return sum of mapped and unmapped vports\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the sum of fc mapped and unmapped.\n *\n * Description:\n * Returns the ascii text number of the sum of the fc mapped and unmapped\n * vport counts.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_num_discovered_ports_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tvport->fc_map_cnt + vport->fc_unmap_cnt);\n}\n\n/**\n * lpfc_issue_lip - Misnomer, name carried over from long ago\n * @shost: Scsi_Host pointer.\n *\n * Description:\n * Bring the link down gracefully then re-init the link. The firmware will\n * re-init the fiber channel interface as required. Does not issue a LIP.\n *\n * Returns:\n * -EPERM port offline or management commands are being blocked\n * -ENOMEM cannot allocate memory for the mailbox command\n * -EIO error sending the mailbox command\n * zero for success\n **/\nstatic int\nlpfc_issue_lip(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tLPFC_MBOXQ_t *pmboxq;\n\tint mbxstatus = MBXERR_ERROR;\n\n\t/*\n\t * If the link is offline, disabled or BLOCK_MGMT_IO\n\t * it doesn't make any sense to allow issue_lip\n\t */\n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t    (phba->hba_flag & LINK_DISABLED) ||\n\t    (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO))\n\t\treturn -EPERM;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool,GFP_KERNEL);\n\n\tif (!pmboxq)\n\t\treturn -ENOMEM;\n\n\tmemset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\tpmboxq->u.mb.mbxCommand = MBX_DOWN_LINK;\n\tpmboxq->u.mb.mbxOwner = OWN_HOST;\n\n\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO * 2);\n\n\tif ((mbxstatus == MBX_SUCCESS) &&\n\t    (pmboxq->u.mb.mbxStatus == 0 ||\n\t     pmboxq->u.mb.mbxStatus == MBXERR_LINK_DOWN)) {\n\t\tmemset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\t\tlpfc_init_link(phba, pmboxq, phba->cfg_topology,\n\t\t\t       phba->cfg_link_speed);\n\t\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq,\n\t\t\t\t\t\t     phba->fc_ratov * 2);\n\t\tif ((mbxstatus == MBX_SUCCESS) &&\n\t\t    (pmboxq->u.mb.mbxStatus == MBXERR_SEC_NO_PERMISSION))\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,\n\t\t\t\t\t\"2859 SLI authentication is required \"\n\t\t\t\t\t\"for INIT_LINK but has not done yet\\n\");\n\t}\n\n\tlpfc_set_loopback_flag(phba);\n\tif (mbxstatus != MBX_TIMEOUT)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\tif (mbxstatus == MBXERR_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint\nlpfc_emptyq_wait(struct lpfc_hba *phba, struct list_head *q, spinlock_t *lock)\n{\n\tint cnt = 0;\n\n\tspin_lock_irq(lock);\n\twhile (!list_empty(q)) {\n\t\tspin_unlock_irq(lock);\n\t\tmsleep(20);\n\t\tif (cnt++ > 250) {  /* 5 secs */\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\n\t\t\t\t\t\"0466 %s %s\\n\",\n\t\t\t\t\t\"Outstanding IO when \",\n\t\t\t\t\t\"bringing Adapter offline\\n\");\n\t\t\t\treturn 0;\n\t\t}\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\treturn 1;\n}\n\n/**\n * lpfc_do_offline - Issues a mailbox command to bring the link down\n * @phba: lpfc_hba pointer.\n * @type: LPFC_EVT_OFFLINE, LPFC_EVT_WARM_START, LPFC_EVT_KILL.\n *\n * Notes:\n * Assumes any error from lpfc_do_offline() will be negative.\n * Can wait up to 5 seconds for the port ring buffers count\n * to reach zero, prints a warning if it is not zero and continues.\n * lpfc_workq_post_event() returns a non-zero return code if call fails.\n *\n * Returns:\n * -EIO error posting the event\n * zero for success\n **/\nstatic int\nlpfc_do_offline(struct lpfc_hba *phba, uint32_t type)\n{\n\tstruct completion online_compl;\n\tstruct lpfc_queue *qp = NULL;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_sli *psli;\n\tint status = 0;\n\tint i;\n\tint rc;\n\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t      LPFC_EVT_OFFLINE_PREP);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\n\tif (status != 0)\n\t\treturn -EIO;\n\n\tpsli = &phba->sli;\n\n\t/*\n\t * If freeing the queues have already started, don't access them.\n\t * Otherwise set FREE_WAIT to indicate that queues are being used\n\t * to hold the freeing process until we finish.\n\t */\n\tspin_lock_irq(&phba->hbalock);\n\tif (!(psli->sli_flag & LPFC_QUEUE_FREE_INIT)) {\n\t\tpsli->sli_flag |= LPFC_QUEUE_FREE_WAIT;\n\t} else {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tgoto skip_wait;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t/* Wait a little for things to settle down, but not\n\t * long enough for dev loss timeout to expire.\n\t */\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tfor (i = 0; i < psli->num_rings; i++) {\n\t\t\tpring = &psli->sli3_ring[i];\n\t\t\tif (!lpfc_emptyq_wait(phba, &pring->txcmplq,\n\t\t\t\t\t      &phba->hbalock))\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(qp, &phba->sli4_hba.lpfc_wq_list, wq_list) {\n\t\t\tpring = qp->pring;\n\t\t\tif (!pring)\n\t\t\t\tcontinue;\n\t\t\tif (!lpfc_emptyq_wait(phba, &pring->txcmplq,\n\t\t\t\t\t      &pring->ring_lock))\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tspin_lock_irq(&phba->hbalock);\n\tpsli->sli_flag &= ~LPFC_QUEUE_FREE_WAIT;\n\tspin_unlock_irq(&phba->hbalock);\n\nskip_wait:\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &status, &online_compl, type);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\n\tif (status != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/**\n * lpfc_reset_pci_bus - resets PCI bridge controller's secondary bus of an HBA\n * @phba: lpfc_hba pointer.\n *\n * Description:\n * Issues a PCI secondary bus reset for the phba->pcidev.\n *\n * Notes:\n * First walks the bus_list to ensure only PCI devices with Emulex\n * vendor id, device ids that support hot reset, only one occurrence\n * of function 0, and all ports on the bus are in offline mode to ensure the\n * hot reset only affects one valid HBA.\n *\n * Returns:\n * -ENOTSUPP, cfg_enable_hba_reset must be of value 2\n * -ENODEV,   NULL ptr to pcidev\n * -EBADSLT,  detected invalid device\n * -EBUSY,    port is not in offline state\n *      0,    successful\n */\nstatic int\nlpfc_reset_pci_bus(struct lpfc_hba *phba)\n{\n\tstruct pci_dev *pdev = phba->pcidev;\n\tstruct Scsi_Host *shost = NULL;\n\tstruct lpfc_hba *phba_other = NULL;\n\tstruct pci_dev *ptr = NULL;\n\tint res;\n\n\tif (phba->cfg_enable_hba_reset != 2)\n\t\treturn -ENOTSUPP;\n\n\tif (!pdev) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT, \"8345 pdev NULL!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = lpfc_check_pci_resettable(phba);\n\tif (res)\n\t\treturn res;\n\n\t/* Walk the list of devices on the pci_dev's bus */\n\tlist_for_each_entry(ptr, &pdev->bus->devices, bus_list) {\n\t\t/* Check port is offline */\n\t\tshost = pci_get_drvdata(ptr);\n\t\tif (shost) {\n\t\t\tphba_other =\n\t\t\t\t((struct lpfc_vport *)shost->hostdata)->phba;\n\t\t\tif (!(phba_other->pport->fc_flag & FC_OFFLINE_MODE)) {\n\t\t\t\tlpfc_printf_log(phba_other, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\t\"8349 WWPN = 0x%02x%02x%02x%02x\"\n\t\t\t\t\t\t\"%02x%02x%02x%02x is not \"\n\t\t\t\t\t\t\"offline!\\n\",\n\t\t\t\t\t\tphba_other->wwpn[0],\n\t\t\t\t\t\tphba_other->wwpn[1],\n\t\t\t\t\t\tphba_other->wwpn[2],\n\t\t\t\t\t\tphba_other->wwpn[3],\n\t\t\t\t\t\tphba_other->wwpn[4],\n\t\t\t\t\t\tphba_other->wwpn[5],\n\t\t\t\t\t\tphba_other->wwpn[6],\n\t\t\t\t\t\tphba_other->wwpn[7]);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Issue PCI bus reset */\n\tres = pci_reset_bus(pdev);\n\tif (res) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"8350 PCI reset bus failed: %d\\n\", res);\n\t}\n\n\treturn res;\n}\n\n/**\n * lpfc_selective_reset - Offline then onlines the port\n * @phba: lpfc_hba pointer.\n *\n * Description:\n * If the port is configured to allow a reset then the hba is brought\n * offline then online.\n *\n * Notes:\n * Assumes any error from lpfc_do_offline() will be negative.\n * Do not make this function static.\n *\n * Returns:\n * lpfc_do_offline() return code if not zero\n * -EIO reset not configured or error posting the event\n * zero for success\n **/\nint\nlpfc_selective_reset(struct lpfc_hba *phba)\n{\n\tstruct completion online_compl;\n\tint status = 0;\n\tint rc;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\n\tif (!(phba->pport->fc_flag & FC_OFFLINE_MODE)) {\n\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t      LPFC_EVT_ONLINE);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\n\tif (status != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/**\n * lpfc_issue_reset - Selectively resets an adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing the string \"selective\".\n * @count: unused variable.\n *\n * Description:\n * If the buf contains the string \"selective\" then lpfc_selective_reset()\n * is called to perform the reset.\n *\n * Notes:\n * Assumes any error from lpfc_selective_reset() will be negative.\n * If lpfc_selective_reset() returns zero then the length of the buffer\n * is returned which indicates success\n *\n * Returns:\n * -EINVAL if the buffer does not contain the string \"selective\"\n * length of buf if lpfc-selective_reset() if the call succeeds\n * return value of lpfc_selective_reset() if the call fails\n**/\nstatic ssize_t\nlpfc_issue_reset(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint status = -EINVAL;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\n\tif (strncmp(buf, \"selective\", sizeof(\"selective\") - 1) == 0)\n\t\tstatus = phba->lpfc_selective_reset(phba);\n\n\tif (status == 0)\n\t\treturn strlen(buf);\n\telse\n\t\treturn status;\n}\n\n/**\n * lpfc_sli4_pdev_status_reg_wait - Wait for pdev status register for readyness\n * @phba: lpfc_hba pointer.\n *\n * Description:\n * SLI4 interface type-2 device to wait on the sliport status register for\n * the readyness after performing a firmware reset.\n *\n * Returns:\n * zero for success, -EPERM when port does not have privilege to perform the\n * reset, -EIO when port timeout from recovering from the reset.\n *\n * Note:\n * As the caller will interpret the return code by value, be careful in making\n * change or addition to return codes.\n **/\nint\nlpfc_sli4_pdev_status_reg_wait(struct lpfc_hba *phba)\n{\n\tstruct lpfc_register portstat_reg = {0};\n\tint i;\n\n\tmsleep(100);\n\tif (lpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\n\t\t       &portstat_reg.word0))\n\t\treturn -EIO;\n\n\t/* verify if privileged for the request operation */\n\tif (!bf_get(lpfc_sliport_status_rn, &portstat_reg) &&\n\t    !bf_get(lpfc_sliport_status_err, &portstat_reg))\n\t\treturn -EPERM;\n\n\t/* wait for the SLI port firmware ready after firmware reset */\n\tfor (i = 0; i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT; i++) {\n\t\tmsleep(10);\n\t\tif (lpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\n\t\t\t       &portstat_reg.word0))\n\t\t\tcontinue;\n\t\tif (!bf_get(lpfc_sliport_status_err, &portstat_reg))\n\t\t\tcontinue;\n\t\tif (!bf_get(lpfc_sliport_status_rn, &portstat_reg))\n\t\t\tcontinue;\n\t\tif (!bf_get(lpfc_sliport_status_rdy, &portstat_reg))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT)\n\t\treturn 0;\n\telse\n\t\treturn -EIO;\n}\n\n/**\n * lpfc_sli4_pdev_reg_request - Request physical dev to perform a register acc\n * @phba: lpfc_hba pointer.\n * @opcode: The sli4 config command opcode.\n *\n * Description:\n * Request SLI4 interface type-2 device to perform a physical register set\n * access.\n *\n * Returns:\n * zero for success\n **/\nstatic ssize_t\nlpfc_sli4_pdev_reg_request(struct lpfc_hba *phba, uint32_t opcode)\n{\n\tstruct completion online_compl;\n\tstruct pci_dev *pdev = phba->pcidev;\n\tuint32_t before_fc_flag;\n\tuint32_t sriov_nr_virtfn;\n\tuint32_t reg_val;\n\tint status = 0, rc = 0;\n\tint job_posted = 1, sriov_err;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\n\tif ((phba->sli_rev < LPFC_SLI_REV4) ||\n\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t     LPFC_SLI_INTF_IF_TYPE_2))\n\t\treturn -EPERM;\n\n\t/* Keep state if we need to restore back */\n\tbefore_fc_flag = phba->pport->fc_flag;\n\tsriov_nr_virtfn = phba->cfg_sriov_nr_virtfn;\n\n\t/* Disable SR-IOV virtual functions if enabled */\n\tif (phba->cfg_sriov_nr_virtfn) {\n\t\tpci_disable_sriov(pdev);\n\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t}\n\n\tif (opcode == LPFC_FW_DUMP)\n\t\tphba->hba_flag |= HBA_FW_DUMP_OP;\n\n\tstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\n\tif (status != 0) {\n\t\tphba->hba_flag &= ~HBA_FW_DUMP_OP;\n\t\treturn status;\n\t}\n\n\t/* wait for the device to be quiesced before firmware reset */\n\tmsleep(100);\n\n\treg_val = readl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\tLPFC_CTL_PDEV_CTL_OFFSET);\n\n\tif (opcode == LPFC_FW_DUMP)\n\t\treg_val |= LPFC_FW_DUMP_REQUEST;\n\telse if (opcode == LPFC_FW_RESET)\n\t\treg_val |= LPFC_CTL_PDEV_CTL_FRST;\n\telse if (opcode == LPFC_DV_RESET)\n\t\treg_val |= LPFC_CTL_PDEV_CTL_DRST;\n\n\twritel(reg_val, phba->sli4_hba.conf_regs_memmap_p +\n\t       LPFC_CTL_PDEV_CTL_OFFSET);\n\t/* flush */\n\treadl(phba->sli4_hba.conf_regs_memmap_p + LPFC_CTL_PDEV_CTL_OFFSET);\n\n\t/* delay driver action following IF_TYPE_2 reset */\n\trc = lpfc_sli4_pdev_status_reg_wait(phba);\n\n\tif (rc == -EPERM) {\n\t\t/* no privilege for reset */\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\n\t\t\t\t\"3150 No privilege to perform the requested \"\n\t\t\t\t\"access: x%x\\n\", reg_val);\n\t} else if (rc == -EIO) {\n\t\t/* reset failed, there is nothing more we can do */\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\n\t\t\t\t\"3153 Fail to perform the requested \"\n\t\t\t\t\"access: x%x\\n\", reg_val);\n\t\treturn rc;\n\t}\n\n\t/* keep the original port state */\n\tif (before_fc_flag & FC_OFFLINE_MODE)\n\t\tgoto out;\n\n\tinit_completion(&online_compl);\n\tjob_posted = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t\t\t   LPFC_EVT_ONLINE);\n\tif (!job_posted)\n\t\tgoto out;\n\n\twait_for_completion(&online_compl);\n\nout:\n\t/* in any case, restore the virtual functions enabled as before */\n\tif (sriov_nr_virtfn) {\n\t\tsriov_err =\n\t\t\tlpfc_sli_probe_sriov_nr_virtfn(phba, sriov_nr_virtfn);\n\t\tif (!sriov_err)\n\t\t\tphba->cfg_sriov_nr_virtfn = sriov_nr_virtfn;\n\t}\n\n\t/* return proper error code */\n\tif (!rc) {\n\t\tif (!job_posted)\n\t\t\trc = -ENOMEM;\n\t\telse if (status)\n\t\t\trc = -EIO;\n\t}\n\treturn rc;\n}\n\n/**\n * lpfc_nport_evt_cnt_show - Return the number of nport events\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the ascii number of nport events.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_nport_evt_cnt_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->nport_event_cnt);\n}\n\nstatic int\nlpfc_set_trunking(struct lpfc_hba *phba, char *buff_out)\n{\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tunsigned long val = 0;\n\tchar *pval = NULL;\n\tint rc = 0;\n\n\tif (!strncmp(\"enable\", buff_out,\n\t\t\t\t strlen(\"enable\"))) {\n\t\tpval = buff_out + strlen(\"enable\") + 1;\n\t\trc = kstrtoul(pval, 0, &val);\n\t\tif (rc)\n\t\t\treturn rc; /* Invalid  number */\n\t} else if (!strncmp(\"disable\", buff_out,\n\t\t\t\t strlen(\"disable\"))) {\n\t\tval = 0;\n\t} else {\n\t\treturn -EINVAL;  /* Invalid command */\n\t}\n\n\tswitch (val) {\n\tcase 0:\n\t\tval = 0x0; /* Disable */\n\t\tbreak;\n\tcase 2:\n\t\tval = 0x1; /* Enable two port trunk */\n\t\tbreak;\n\tcase 4:\n\t\tval = 0x2; /* Enable four port trunk */\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\"0070 Set trunk mode with val %ld \", val);\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tlpfc_sli4_config(phba, mbox, LPFC_MBOX_SUBSYSTEM_FCOE,\n\t\t\t LPFC_MBOX_OPCODE_FCOE_FC_SET_TRUNK_MODE,\n\t\t\t 12, LPFC_SLI4_MBX_EMBED);\n\n\tbf_set(lpfc_mbx_set_trunk_mode,\n\t       &mbox->u.mqe.un.set_trunk_mode,\n\t       val);\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_POLL);\n\tif (rc)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\t\"0071 Set trunk mode failed with status: %d\",\n\t\t\t\trc);\n\tif (rc != MBX_TIMEOUT)\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\treturn 0;\n}\n\n/**\n * lpfc_board_mode_show - Return the state of the board\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the state of the adapter.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_board_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tchar  * state;\n\n\tif (phba->link_state == LPFC_HBA_ERROR)\n\t\tstate = \"error\";\n\telse if (phba->link_state == LPFC_WARM_START)\n\t\tstate = \"warm start\";\n\telse if (phba->link_state == LPFC_INIT_START)\n\t\tstate = \"offline\";\n\telse\n\t\tstate = \"online\";\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}\n\n/**\n * lpfc_board_mode_store - Puts the hba in online, offline, warm or error state\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing one of the strings \"online\", \"offline\", \"warm\" or \"error\".\n * @count: unused variable.\n *\n * Returns:\n * -EACCES if enable hba reset not enabled\n * -EINVAL if the buffer does not contain a valid string (see above)\n * -EIO if lpfc_workq_post_event() or lpfc_do_offline() fails\n * buf length greater than zero indicates success\n **/\nstatic ssize_t\nlpfc_board_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct completion online_compl;\n\tchar *board_mode_str = NULL;\n\tint status = 0;\n\tint rc;\n\n\tif (!phba->cfg_enable_hba_reset) {\n\t\tstatus = -EACCES;\n\t\tgoto board_mode_out;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"3050 lpfc_board_mode set to %s\\n\", buf);\n\n\tinit_completion(&online_compl);\n\n\tif(strncmp(buf, \"online\", sizeof(\"online\") - 1) == 0) {\n\t\trc = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t\t      LPFC_EVT_ONLINE);\n\t\tif (rc == 0) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto board_mode_out;\n\t\t}\n\t\twait_for_completion(&online_compl);\n\t\tif (status)\n\t\t\tstatus = -EIO;\n\t} else if (strncmp(buf, \"offline\", sizeof(\"offline\") - 1) == 0)\n\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\telse if (strncmp(buf, \"warm\", sizeof(\"warm\") - 1) == 0)\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tstatus = -EINVAL;\n\t\telse\n\t\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_WARM_START);\n\telse if (strncmp(buf, \"error\", sizeof(\"error\") - 1) == 0)\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tstatus = -EINVAL;\n\t\telse\n\t\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_KILL);\n\telse if (strncmp(buf, \"dump\", sizeof(\"dump\") - 1) == 0)\n\t\tstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_FW_DUMP);\n\telse if (strncmp(buf, \"fw_reset\", sizeof(\"fw_reset\") - 1) == 0)\n\t\tstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_FW_RESET);\n\telse if (strncmp(buf, \"dv_reset\", sizeof(\"dv_reset\") - 1) == 0)\n\t\tstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_DV_RESET);\n\telse if (strncmp(buf, \"pci_bus_reset\", sizeof(\"pci_bus_reset\") - 1)\n\t\t == 0)\n\t\tstatus = lpfc_reset_pci_bus(phba);\n\telse if (strncmp(buf, \"heartbeat\", sizeof(\"heartbeat\") - 1) == 0)\n\t\tlpfc_issue_hb_tmo(phba);\n\telse if (strncmp(buf, \"trunk\", sizeof(\"trunk\") - 1) == 0)\n\t\tstatus = lpfc_set_trunking(phba, (char *)buf + sizeof(\"trunk\"));\n\telse\n\t\tstatus = -EINVAL;\n\nboard_mode_out:\n\tif (!status)\n\t\treturn strlen(buf);\n\telse {\n\t\tboard_mode_str = strchr(buf, '\\n');\n\t\tif (board_mode_str)\n\t\t\t*board_mode_str = '\\0';\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"3097 Failed \\\"%s\\\", status(%d), \"\n\t\t\t\t \"fc_flag(x%x)\\n\",\n\t\t\t\t buf, status, phba->pport->fc_flag);\n\t\treturn status;\n\t}\n}\n\n/**\n * lpfc_get_hba_info - Return various bits of informaton about the adapter\n * @phba: pointer to the adapter structure.\n * @mxri: max xri count.\n * @axri: available xri count.\n * @mrpi: max rpi count.\n * @arpi: available rpi count.\n * @mvpi: max vpi count.\n * @avpi: available vpi count.\n *\n * Description:\n * If an integer pointer for an count is not null then the value for the\n * count is returned.\n *\n * Returns:\n * zero on error\n * one for success\n **/\nstatic int\nlpfc_get_hba_info(struct lpfc_hba *phba,\n\t\t  uint32_t *mxri, uint32_t *axri,\n\t\t  uint32_t *mrpi, uint32_t *arpi,\n\t\t  uint32_t *mvpi, uint32_t *avpi)\n{\n\tstruct lpfc_mbx_read_config *rd_config;\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *pmb;\n\tint rc = 0;\n\tuint32_t max_vpi;\n\n\t/*\n\t * prevent udev from issuing mailbox commands until the port is\n\t * configured.\n\t */\n\tif (phba->link_state < LPFC_LINK_DOWN ||\n\t    !phba->mbox_mem_pool ||\n\t    (phba->sli.sli_flag & LPFC_SLI_ACTIVE) == 0)\n\t\treturn 0;\n\n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\n\t\treturn 0;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn 0;\n\tmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tpmb->mbxCommand = MBX_READ_CONFIG;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\n\tif (phba->pport->fc_flag & FC_OFFLINE_MODE)\n\t\trc = MBX_NOT_FINISHED;\n\telse\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\n\tif (rc != MBX_SUCCESS) {\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\treturn 0;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\trd_config = &pmboxq->u.mqe.un.rd_config;\n\t\tif (mrpi)\n\t\t\t*mrpi = bf_get(lpfc_mbx_rd_conf_rpi_count, rd_config);\n\t\tif (arpi)\n\t\t\t*arpi = bf_get(lpfc_mbx_rd_conf_rpi_count, rd_config) -\n\t\t\t\t\tphba->sli4_hba.max_cfg_param.rpi_used;\n\t\tif (mxri)\n\t\t\t*mxri = bf_get(lpfc_mbx_rd_conf_xri_count, rd_config);\n\t\tif (axri)\n\t\t\t*axri = bf_get(lpfc_mbx_rd_conf_xri_count, rd_config) -\n\t\t\t\t\tphba->sli4_hba.max_cfg_param.xri_used;\n\n\t\t/* Account for differences with SLI-3.  Get vpi count from\n\t\t * mailbox data and subtract one for max vpi value.\n\t\t */\n\t\tmax_vpi = (bf_get(lpfc_mbx_rd_conf_vpi_count, rd_config) > 0) ?\n\t\t\t(bf_get(lpfc_mbx_rd_conf_vpi_count, rd_config) - 1) : 0;\n\n\t\t/* Limit the max we support */\n\t\tif (max_vpi > LPFC_MAX_VPI)\n\t\t\tmax_vpi = LPFC_MAX_VPI;\n\t\tif (mvpi)\n\t\t\t*mvpi = max_vpi;\n\t\tif (avpi)\n\t\t\t*avpi = max_vpi - phba->sli4_hba.max_cfg_param.vpi_used;\n\t} else {\n\t\tif (mrpi)\n\t\t\t*mrpi = pmb->un.varRdConfig.max_rpi;\n\t\tif (arpi)\n\t\t\t*arpi = pmb->un.varRdConfig.avail_rpi;\n\t\tif (mxri)\n\t\t\t*mxri = pmb->un.varRdConfig.max_xri;\n\t\tif (axri)\n\t\t\t*axri = pmb->un.varRdConfig.avail_xri;\n\t\tif (mvpi)\n\t\t\t*mvpi = pmb->un.varRdConfig.max_vpi;\n\t\tif (avpi) {\n\t\t\t/* avail_vpi is only valid if link is up and ready */\n\t\t\tif (phba->link_state == LPFC_HBA_READY)\n\t\t\t\t*avpi = pmb->un.varRdConfig.avail_vpi;\n\t\t\telse\n\t\t\t\t*avpi = pmb->un.varRdConfig.max_vpi;\n\t\t}\n\t}\n\n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\treturn 1;\n}\n\n/**\n * lpfc_max_rpi_show - Return maximum rpi\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the maximum rpi count in decimal or \"Unknown\".\n *\n * Description:\n * Calls lpfc_get_hba_info() asking for just the mrpi count.\n * If lpfc_get_hba_info() returns zero (failure) the buffer text is set\n * to \"Unknown\" and the buffer length is returned, therefore the caller\n * must check for \"Unknown\" in the buffer to detect a failure.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_max_rpi_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, &cnt, NULL, NULL, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", cnt);\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n/**\n * lpfc_used_rpi_show - Return maximum rpi minus available rpi\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing the used rpi count in decimal or \"Unknown\".\n *\n * Description:\n * Calls lpfc_get_hba_info() asking for just the mrpi and arpi counts.\n * If lpfc_get_hba_info() returns zero (failure) the buffer text is set\n * to \"Unknown\" and the buffer length is returned, therefore the caller\n * must check for \"Unknown\" in the buffer to detect a failure.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_used_rpi_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt, acnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, &cnt, &acnt, NULL, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (cnt - acnt));\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n/**\n * lpfc_max_xri_show - Return maximum xri\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the maximum xri count in decimal or \"Unknown\".\n *\n * Description:\n * Calls lpfc_get_hba_info() asking for just the mrpi count.\n * If lpfc_get_hba_info() returns zero (failure) the buffer text is set\n * to \"Unknown\" and the buffer length is returned, therefore the caller\n * must check for \"Unknown\" in the buffer to detect a failure.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_max_xri_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, &cnt, NULL, NULL, NULL, NULL, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", cnt);\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n/**\n * lpfc_used_xri_show - Return maximum xpi minus the available xpi\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the used xri count in decimal or \"Unknown\".\n *\n * Description:\n * Calls lpfc_get_hba_info() asking for just the mxri and axri counts.\n * If lpfc_get_hba_info() returns zero (failure) the buffer text is set\n * to \"Unknown\" and the buffer length is returned, therefore the caller\n * must check for \"Unknown\" in the buffer to detect a failure.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_used_xri_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt, acnt;\n\n\tif (lpfc_get_hba_info(phba, &cnt, &acnt, NULL, NULL, NULL, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (cnt - acnt));\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n/**\n * lpfc_max_vpi_show - Return maximum vpi\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the maximum vpi count in decimal or \"Unknown\".\n *\n * Description:\n * Calls lpfc_get_hba_info() asking for just the mvpi count.\n * If lpfc_get_hba_info() returns zero (failure) the buffer text is set\n * to \"Unknown\" and the buffer length is returned, therefore the caller\n * must check for \"Unknown\" in the buffer to detect a failure.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_max_vpi_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", cnt);\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n/**\n * lpfc_used_vpi_show - Return maximum vpi minus the available vpi\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the used vpi count in decimal or \"Unknown\".\n *\n * Description:\n * Calls lpfc_get_hba_info() asking for just the mvpi and avpi counts.\n * If lpfc_get_hba_info() returns zero (failure) the buffer text is set\n * to \"Unknown\" and the buffer length is returned, therefore the caller\n * must check for \"Unknown\" in the buffer to detect a failure.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_used_vpi_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt, acnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, &acnt))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (cnt - acnt));\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n/**\n * lpfc_npiv_info_show - Return text about NPIV support for the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: text that must be interpreted to determine if npiv is supported.\n *\n * Description:\n * Buffer will contain text indicating npiv is not suppoerted on the port,\n * the port is an NPIV physical port, or it is an npiv virtual port with\n * the id of the vport.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_npiv_info_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (!(phba->max_vpi))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"NPIV Not Supported\\n\");\n\tif (vport->port_type == LPFC_PHYSICAL_PORT)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"NPIV Physical\\n\");\n\treturn scnprintf(buf, PAGE_SIZE, \"NPIV Virtual (VPI %d)\\n\", vport->vpi);\n}\n\n/**\n * lpfc_poll_show - Return text about poll support for the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the cfg_poll in hex.\n *\n * Notes:\n * cfg_poll should be a lpfc_polling_flags type.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_poll_show(struct device *dev, struct device_attribute *attr,\n\t       char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#x\\n\", phba->cfg_poll);\n}\n\n/**\n * lpfc_poll_store - Set the value of cfg_poll for the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: one or more lpfc_polling_flags values.\n * @count: not used.\n *\n * Notes:\n * buf contents converted to integer and checked for a valid value.\n *\n * Returns:\n * -EINVAL if the buffer connot be converted or is out of range\n * length of the buf on success\n **/\nstatic ssize_t\nlpfc_poll_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t creg_val;\n\tuint32_t old_val;\n\tint val=0;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif ((val & 0x3) != val)\n\t\treturn -EINVAL;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tval = 0;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\"3051 lpfc_poll changed from %d to %d\\n\",\n\t\tphba->cfg_poll, val);\n\n\tspin_lock_irq(&phba->hbalock);\n\n\told_val = phba->cfg_poll;\n\n\tif (val & ENABLE_FCP_RING_POLLING) {\n\t\tif ((val & DISABLE_FCP_RING_INT) &&\n\t\t    !(old_val & DISABLE_FCP_RING_INT)) {\n\t\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcreg_val &= ~(HC_R0INT_ENA << LPFC_FCP_RING);\n\t\t\twritel(creg_val, phba->HCregaddr);\n\t\t\treadl(phba->HCregaddr); /* flush */\n\n\t\t\tlpfc_poll_start_timer(phba);\n\t\t}\n\t} else if (val != 0x0) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(val & DISABLE_FCP_RING_INT) &&\n\t    (old_val & DISABLE_FCP_RING_INT))\n\t{\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tdel_timer(&phba->fcp_poll_timer);\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\n\t\twritel(creg_val, phba->HCregaddr);\n\t\treadl(phba->HCregaddr); /* flush */\n\t}\n\n\tphba->cfg_poll = val;\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn strlen(buf);\n}\n\n/**\n * lpfc_sriov_hw_max_virtfn_show - Return maximum number of virtual functions\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the formatted support level.\n *\n * Description:\n * Returns the maximum number of virtual functions a physical function can\n * support, 0 will be returned if called on virtual function.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_sriov_hw_max_virtfn_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint16_t max_nr_virtfn;\n\n\tmax_nr_virtfn = lpfc_sli_sriov_nr_virtfn_get(phba);\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", max_nr_virtfn);\n}\n\nstatic inline bool lpfc_rangecheck(uint val, uint min, uint max)\n{\n\treturn val >= min && val <= max;\n}\n\n/**\n * lpfc_enable_bbcr_set: Sets an attribute value.\n * @phba: pointer the the adapter structure.\n * @val: integer attribute value.\n *\n * Description:\n * Validates the min and max values then sets the\n * adapter config field if in the valid range. prints error message\n * and does not set the parameter if invalid.\n *\n * Returns:\n * zero on success\n * -EINVAL if val is invalid\n */\nstatic ssize_t\nlpfc_enable_bbcr_set(struct lpfc_hba *phba, uint val)\n{\n\tif (lpfc_rangecheck(val, 0, 1) && phba->sli_rev == LPFC_SLI_REV4) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3068 %s_enable_bbcr changed from %d to %d\\n\",\n\t\t\t\tLPFC_DRIVER_NAME, phba->cfg_enable_bbcr, val);\n\t\tphba->cfg_enable_bbcr = val;\n\t\treturn 0;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0451 %s_enable_bbcr cannot set to %d, range is 0, 1\\n\",\n\t\t\tLPFC_DRIVER_NAME, val);\n\treturn -EINVAL;\n}\n\n/*\n * lpfc_param_show - Return a cfg attribute value in decimal\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_show.\n *\n * lpfc_##attr##_show: Return the decimal value of an adapters cfg_xxx field.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the attribute value in decimal.\n *\n * Returns: size of formatted string.\n **/\n#define lpfc_param_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tstruct lpfc_hba   *phba = vport->phba;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\\\n\t\t\tphba->cfg_##attr);\\\n}\n\n/*\n * lpfc_param_hex_show - Return a cfg attribute value in hex\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_show\n *\n * lpfc_##attr##_show: Return the hex value of an adapters cfg_xxx field.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the attribute value in hexadecimal.\n *\n * Returns: size of formatted string.\n **/\n#define lpfc_param_hex_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tstruct lpfc_hba   *phba = vport->phba;\\\n\tuint val = 0;\\\n\tval = phba->cfg_##attr;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%#x\\n\",\\\n\t\t\tphba->cfg_##attr);\\\n}\n\n/*\n * lpfc_param_init - Initializes a cfg attribute\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_init. The macro also\n * takes a default argument, a minimum and maximum argument.\n *\n * lpfc_##attr##_init: Initializes an attribute.\n * @phba: pointer the the adapter structure.\n * @val: integer attribute value.\n *\n * Validates the min and max values then sets the adapter config field\n * accordingly, or uses the default if out of range and prints an error message.\n *\n * Returns:\n * zero on success\n * -EINVAL if default used\n **/\n#define lpfc_param_init(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_init(struct lpfc_hba *phba, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tphba->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT, \\\n\t\t\t\"0449 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t\"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\tphba->cfg_##attr = default;\\\n\treturn -EINVAL;\\\n}\n\n/*\n * lpfc_param_set - Set a cfg attribute value\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_set\n *\n * lpfc_##attr##_set: Sets an attribute value.\n * @phba: pointer the the adapter structure.\n * @val: integer attribute value.\n *\n * Description:\n * Validates the min and max values then sets the\n * adapter config field if in the valid range. prints error message\n * and does not set the parameter if invalid.\n *\n * Returns:\n * zero on success\n * -EINVAL if val is invalid\n **/\n#define lpfc_param_set(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_set(struct lpfc_hba *phba, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT, \\\n\t\t\t\"3052 lpfc_\" #attr \" changed from %d to %d\\n\", \\\n\t\t\tphba->cfg_##attr, val); \\\n\t\tphba->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT, \\\n\t\t\t\"0450 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t\"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\treturn -EINVAL;\\\n}\n\n/*\n * lpfc_param_store - Set a vport attribute value\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_store.\n *\n * lpfc_##attr##_store: Set an sttribute value.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: contains the attribute value in ascii.\n * @count: not used.\n *\n * Description:\n * Convert the ascii text number to an integer, then\n * use the lpfc_##attr##_set function to set the value.\n *\n * Returns:\n * -EINVAL if val is invalid or lpfc_##attr##_set() fails\n * length of buffer upon success.\n **/\n#define lpfc_param_store(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_store(struct device *dev, struct device_attribute *attr, \\\n\t\t    const char *buf, size_t count) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tstruct lpfc_hba   *phba = vport->phba;\\\n\tuint val = 0;\\\n\tif (!isdigit(buf[0]))\\\n\t\treturn -EINVAL;\\\n\tif (sscanf(buf, \"%i\", &val) != 1)\\\n\t\treturn -EINVAL;\\\n\tif (lpfc_##attr##_set(phba, val) == 0) \\\n\t\treturn strlen(buf);\\\n\telse \\\n\t\treturn -EINVAL;\\\n}\n\n/*\n * lpfc_vport_param_show - Return decimal formatted cfg attribute value\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_show\n *\n * lpfc_##attr##_show: prints the attribute value in decimal.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the attribute value in decimal.\n *\n * Returns: length of formatted string.\n **/\n#define lpfc_vport_param_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", vport->cfg_##attr);\\\n}\n\n/*\n * lpfc_vport_param_hex_show - Return hex formatted attribute value\n *\n * Description:\n * Macro that given an attr e.g.\n * hba_queue_depth expands into a function with the name\n * lpfc_hba_queue_depth_show\n *\n * lpfc_##attr##_show: prints the attribute value in hexadecimal.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the attribute value in hexadecimal.\n *\n * Returns: length of formatted string.\n **/\n#define lpfc_vport_param_hex_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%#x\\n\", vport->cfg_##attr);\\\n}\n\n/*\n * lpfc_vport_param_init - Initialize a vport cfg attribute\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_init. The macro also\n * takes a default argument, a minimum and maximum argument.\n *\n * lpfc_##attr##_init: validates the min and max values then sets the\n * adapter config field accordingly, or uses the default if out of range\n * and prints an error message.\n * @phba: pointer the the adapter structure.\n * @val: integer attribute value.\n *\n * Returns:\n * zero on success\n * -EINVAL if default used\n **/\n#define lpfc_vport_param_init(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_init(struct lpfc_vport *vport, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tvport->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \\\n\t\t\t \"0423 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t \"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\tvport->cfg_##attr = default;\\\n\treturn -EINVAL;\\\n}\n\n/*\n * lpfc_vport_param_set - Set a vport cfg attribute\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth expands\n * into a function with the name lpfc_hba_queue_depth_set\n *\n * lpfc_##attr##_set: validates the min and max values then sets the\n * adapter config field if in the valid range. prints error message\n * and does not set the parameter if invalid.\n * @phba: pointer the the adapter structure.\n * @val:\tinteger attribute value.\n *\n * Returns:\n * zero on success\n * -EINVAL if val is invalid\n **/\n#define lpfc_vport_param_set(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_set(struct lpfc_vport *vport, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \\\n\t\t\t\"3053 lpfc_\" #attr \\\n\t\t\t\" changed from %d (x%x) to %d (x%x)\\n\", \\\n\t\t\tvport->cfg_##attr, vport->cfg_##attr, \\\n\t\t\tval, val); \\\n\t\tvport->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \\\n\t\t\t \"0424 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t \"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\treturn -EINVAL;\\\n}\n\n/*\n * lpfc_vport_param_store - Set a vport attribute\n *\n * Description:\n * Macro that given an attr e.g. hba_queue_depth\n * expands into a function with the name lpfc_hba_queue_depth_store\n *\n * lpfc_##attr##_store: convert the ascii text number to an integer, then\n * use the lpfc_##attr##_set function to set the value.\n * @cdev: class device that is converted into a Scsi_host.\n * @buf:\tcontains the attribute value in decimal.\n * @count: not used.\n *\n * Returns:\n * -EINVAL if val is invalid or lpfc_##attr##_set() fails\n * length of buffer upon success.\n **/\n#define lpfc_vport_param_store(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_store(struct device *dev, struct device_attribute *attr, \\\n\t\t    const char *buf, size_t count) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tuint val = 0;\\\n\tif (!isdigit(buf[0]))\\\n\t\treturn -EINVAL;\\\n\tif (sscanf(buf, \"%i\", &val) != 1)\\\n\t\treturn -EINVAL;\\\n\tif (lpfc_##attr##_set(vport, val) == 0) \\\n\t\treturn strlen(buf);\\\n\telse \\\n\t\treturn -EINVAL;\\\n}\n\n\nstatic DEVICE_ATTR(nvme_info, 0444, lpfc_nvme_info_show, NULL);\nstatic DEVICE_ATTR(scsi_stat, 0444, lpfc_scsi_stat_show, NULL);\nstatic DEVICE_ATTR(bg_info, S_IRUGO, lpfc_bg_info_show, NULL);\nstatic DEVICE_ATTR(bg_guard_err, S_IRUGO, lpfc_bg_guard_err_show, NULL);\nstatic DEVICE_ATTR(bg_apptag_err, S_IRUGO, lpfc_bg_apptag_err_show, NULL);\nstatic DEVICE_ATTR(bg_reftag_err, S_IRUGO, lpfc_bg_reftag_err_show, NULL);\nstatic DEVICE_ATTR(info, S_IRUGO, lpfc_info_show, NULL);\nstatic DEVICE_ATTR(serialnum, S_IRUGO, lpfc_serialnum_show, NULL);\nstatic DEVICE_ATTR(modeldesc, S_IRUGO, lpfc_modeldesc_show, NULL);\nstatic DEVICE_ATTR(modelname, S_IRUGO, lpfc_modelname_show, NULL);\nstatic DEVICE_ATTR(programtype, S_IRUGO, lpfc_programtype_show, NULL);\nstatic DEVICE_ATTR(portnum, S_IRUGO, lpfc_vportnum_show, NULL);\nstatic DEVICE_ATTR(fwrev, S_IRUGO, lpfc_fwrev_show, NULL);\nstatic DEVICE_ATTR(hdw, S_IRUGO, lpfc_hdw_show, NULL);\nstatic DEVICE_ATTR(link_state, S_IRUGO | S_IWUSR, lpfc_link_state_show,\n\t\tlpfc_link_state_store);\nstatic DEVICE_ATTR(option_rom_version, S_IRUGO,\n\t\t   lpfc_option_rom_version_show, NULL);\nstatic DEVICE_ATTR(num_discovered_ports, S_IRUGO,\n\t\t   lpfc_num_discovered_ports_show, NULL);\nstatic DEVICE_ATTR(menlo_mgmt_mode, S_IRUGO, lpfc_mlomgmt_show, NULL);\nstatic DEVICE_ATTR(nport_evt_cnt, S_IRUGO, lpfc_nport_evt_cnt_show, NULL);\nstatic DEVICE_ATTR_RO(lpfc_drvr_version);\nstatic DEVICE_ATTR_RO(lpfc_enable_fip);\nstatic DEVICE_ATTR(board_mode, S_IRUGO | S_IWUSR,\n\t\t   lpfc_board_mode_show, lpfc_board_mode_store);\nstatic DEVICE_ATTR(issue_reset, S_IWUSR, NULL, lpfc_issue_reset);\nstatic DEVICE_ATTR(max_vpi, S_IRUGO, lpfc_max_vpi_show, NULL);\nstatic DEVICE_ATTR(used_vpi, S_IRUGO, lpfc_used_vpi_show, NULL);\nstatic DEVICE_ATTR(max_rpi, S_IRUGO, lpfc_max_rpi_show, NULL);\nstatic DEVICE_ATTR(used_rpi, S_IRUGO, lpfc_used_rpi_show, NULL);\nstatic DEVICE_ATTR(max_xri, S_IRUGO, lpfc_max_xri_show, NULL);\nstatic DEVICE_ATTR(used_xri, S_IRUGO, lpfc_used_xri_show, NULL);\nstatic DEVICE_ATTR(npiv_info, S_IRUGO, lpfc_npiv_info_show, NULL);\nstatic DEVICE_ATTR_RO(lpfc_temp_sensor);\nstatic DEVICE_ATTR_RO(lpfc_sriov_hw_max_virtfn);\nstatic DEVICE_ATTR(protocol, S_IRUGO, lpfc_sli4_protocol_show, NULL);\nstatic DEVICE_ATTR(lpfc_xlane_supported, S_IRUGO, lpfc_oas_supported_show,\n\t\t   NULL);\n\nstatic char *lpfc_soft_wwn_key = \"C99G71SL8032A\";\n#define WWN_SZ 8\n/**\n * lpfc_wwn_set - Convert string to the 8 byte WWN value.\n * @buf: WWN string.\n * @cnt: Length of string.\n * @wwn: Array to receive converted wwn value.\n *\n * Returns:\n * -EINVAL if the buffer does not contain a valid wwn\n * 0 success\n **/\nstatic size_t\nlpfc_wwn_set(const char *buf, size_t cnt, char wwn[])\n{\n\tunsigned int i, j;\n\n\t/* Count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tif ((cnt < 16) || (cnt > 18) || ((cnt == 17) && (*buf++ != 'x')) ||\n\t    ((cnt == 18) && ((*buf++ != '0') || (*buf++ != 'x'))))\n\t\treturn -EINVAL;\n\n\tmemset(wwn, 0, WWN_SZ);\n\n\t/* Validate and store the new name */\n\tfor (i = 0, j = 0; i < 16; i++) {\n\t\tif ((*buf >= 'a') && (*buf <= 'f'))\n\t\t\tj = ((j << 4) | ((*buf++ - 'a') + 10));\n\t\telse if ((*buf >= 'A') && (*buf <= 'F'))\n\t\t\tj = ((j << 4) | ((*buf++ - 'A') + 10));\n\t\telse if ((*buf >= '0') && (*buf <= '9'))\n\t\t\tj = ((j << 4) | (*buf++ - '0'));\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n/**\n * lpfc_soft_wwn_enable_store - Allows setting of the wwn if the key is valid\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing the string lpfc_soft_wwn_key.\n * @count: must be size of lpfc_soft_wwn_key.\n *\n * Returns:\n * -EINVAL if the buffer does not contain lpfc_soft_wwn_key\n * length of buf indicates success\n **/\nstatic ssize_t\nlpfc_soft_wwn_enable_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned int cnt = count;\n\tuint8_t vvvl = vport->fc_sparam.cmn.valid_vendor_ver_level;\n\tu32 *fawwpn_key = (uint32_t *)&vport->fc_sparam.un.vendorVersion[0];\n\n\t/*\n\t * We're doing a simple sanity check for soft_wwpn setting.\n\t * We require that the user write a specific key to enable\n\t * the soft_wwpn attribute to be settable. Once the attribute\n\t * is written, the enable key resets. If further updates are\n\t * desired, the key must be written again to re-enable the\n\t * attribute.\n\t *\n\t * The \"key\" is not secret - it is a hardcoded string shown\n\t * here. The intent is to protect against the random user or\n\t * application that is just writing attributes.\n\t */\n\tif (vvvl == 1 && cpu_to_be32(*fawwpn_key) == FAPWWN_KEY_VENDOR) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0051 \"LPFC_DRIVER_NAME\" soft wwpn can not\"\n\t\t\t\t \" be enabled: fawwpn is enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tif ((cnt != strlen(lpfc_soft_wwn_key)) ||\n\t    (strncmp(buf, lpfc_soft_wwn_key, strlen(lpfc_soft_wwn_key)) != 0))\n\t\treturn -EINVAL;\n\n\tphba->soft_wwn_enable = 1;\n\n\tdev_printk(KERN_WARNING, &phba->pcidev->dev,\n\t\t   \"lpfc%d: soft_wwpn assignment has been enabled.\\n\",\n\t\t   phba->brd_no);\n\tdev_printk(KERN_WARNING, &phba->pcidev->dev,\n\t\t   \"  The soft_wwpn feature is not supported by Broadcom.\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(lpfc_soft_wwn_enable);\n\n/**\n * lpfc_soft_wwpn_show - Return the cfg soft ww port name of the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the wwpn in hexadecimal.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_soft_wwpn_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t\t(unsigned long long)phba->cfg_soft_wwpn);\n}\n\n/**\n * lpfc_soft_wwpn_store - Set the ww port name of the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: contains the wwpn in hexadecimal.\n * @count: number of wwpn bytes in buf\n *\n * Returns:\n * -EACCES hba reset not enabled, adapter over temp\n * -EINVAL soft wwn not enabled, count is invalid, invalid wwpn byte invalid\n * -EIO error taking adapter offline or online\n * value of count on success\n **/\nstatic ssize_t\nlpfc_soft_wwpn_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct completion online_compl;\n\tint stat1 = 0, stat2 = 0;\n\tunsigned int cnt = count;\n\tu8 wwpn[WWN_SZ];\n\tint rc;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->over_temp_state == HBA_OVER_TEMP) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn -EACCES;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\t/* count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tif (!phba->soft_wwn_enable)\n\t\treturn -EINVAL;\n\n\t/* lock setting wwpn, wwnn down */\n\tphba->soft_wwn_enable = 0;\n\n\trc = lpfc_wwn_set(buf, cnt, wwpn);\n\tif (rc) {\n\t\t/* not able to set wwpn, unlock it */\n\t\tphba->soft_wwn_enable = 1;\n\t\treturn rc;\n\t}\n\n\tphba->cfg_soft_wwpn = wwn_to_u64(wwpn);\n\tfc_host_port_name(shost) = phba->cfg_soft_wwpn;\n\tif (phba->cfg_soft_wwnn)\n\t\tfc_host_node_name(shost) = phba->cfg_soft_wwnn;\n\n\tdev_printk(KERN_NOTICE, &phba->pcidev->dev,\n\t\t   \"lpfc%d: Reinitializing to use soft_wwpn\\n\", phba->brd_no);\n\n\tstat1 = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\tif (stat1)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0463 lpfc_soft_wwpn attribute set failed to \"\n\t\t\t\t\"reinit adapter - %d\\n\", stat1);\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &stat2, &online_compl,\n\t\t\t\t   LPFC_EVT_ONLINE);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\tif (stat2)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0464 lpfc_soft_wwpn attribute set failed to \"\n\t\t\t\t\"reinit adapter - %d\\n\", stat2);\n\treturn (stat1 || stat2) ? -EIO : count;\n}\nstatic DEVICE_ATTR_RW(lpfc_soft_wwpn);\n\n/**\n * lpfc_soft_wwnn_show - Return the cfg soft ww node name for the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: on return contains the wwnn in hexadecimal.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_soft_wwnn_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t\t(unsigned long long)phba->cfg_soft_wwnn);\n}\n\n/**\n * lpfc_soft_wwnn_store - sets the ww node name of the adapter\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: contains the ww node name in hexadecimal.\n * @count: number of wwnn bytes in buf.\n *\n * Returns:\n * -EINVAL soft wwn not enabled, count is invalid, invalid wwnn byte invalid\n * value of count on success\n **/\nstatic ssize_t\nlpfc_soft_wwnn_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tu8 wwnn[WWN_SZ];\n\tint rc;\n\n\t/* count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tif (!phba->soft_wwn_enable)\n\t\treturn -EINVAL;\n\n\trc = lpfc_wwn_set(buf, cnt, wwnn);\n\tif (rc) {\n\t\t/* Allow wwnn to be set many times, as long as the enable\n\t\t * is set. However, once the wwpn is set, everything locks.\n\t\t */\n\t\treturn rc;\n\t}\n\n\tphba->cfg_soft_wwnn = wwn_to_u64(wwnn);\n\n\tdev_printk(KERN_NOTICE, &phba->pcidev->dev,\n\t\t   \"lpfc%d: soft_wwnn set. Value will take effect upon \"\n\t\t   \"setting of the soft_wwpn\\n\", phba->brd_no);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(lpfc_soft_wwnn);\n\n/**\n * lpfc_oas_tgt_show - Return wwpn of target whose luns maybe enabled for\n *\t\t      Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n *\n * Returns:\n * value of count\n **/\nstatic ssize_t\nlpfc_oas_tgt_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t\twwn_to_u64(phba->cfg_oas_tgt_wwpn));\n}\n\n/**\n * lpfc_oas_tgt_store - Store wwpn of target whose luns maybe enabled for\n *\t\t      Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n * @count: Size of the data buffer.\n *\n * Returns:\n * -EINVAL count is invalid, invalid wwpn byte invalid\n * -EPERM oas is not supported by hba\n * value of count on success\n **/\nstatic ssize_t\nlpfc_oas_tgt_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tuint8_t wwpn[WWN_SZ];\n\tint rc;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\t/* count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\trc = lpfc_wwn_set(buf, cnt, wwpn);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(phba->cfg_oas_tgt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tmemcpy(phba->sli4_hba.oas_next_tgt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tif (wwn_to_u64(wwpn) == 0)\n\t\tphba->cfg_oas_flags |= OAS_FIND_ANY_TARGET;\n\telse\n\t\tphba->cfg_oas_flags &= ~OAS_FIND_ANY_TARGET;\n\tphba->cfg_oas_flags &= ~OAS_LUN_VALID;\n\tphba->sli4_hba.oas_next_lun = FIND_FIRST_OAS_LUN;\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_tgt, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_tgt_show, lpfc_oas_tgt_store);\n\n/**\n * lpfc_oas_priority_show - Return wwpn of target whose luns maybe enabled for\n *\t\t      Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n *\n * Returns:\n * value of count\n **/\nstatic ssize_t\nlpfc_oas_priority_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->cfg_oas_priority);\n}\n\n/**\n * lpfc_oas_priority_store - Store wwpn of target whose luns maybe enabled for\n *\t\t      Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n * @count: Size of the data buffer.\n *\n * Returns:\n * -EINVAL count is invalid, invalid wwpn byte invalid\n * -EPERM oas is not supported by hba\n * value of count on success\n **/\nstatic ssize_t\nlpfc_oas_priority_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tunsigned long val;\n\tint ret;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\t/* count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret || (val > 0x7f))\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tphba->cfg_oas_priority = (uint8_t)val;\n\telse\n\t\tphba->cfg_oas_priority = phba->cfg_XLanePriority;\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_priority, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_priority_show, lpfc_oas_priority_store);\n\n/**\n * lpfc_oas_vpt_show - Return wwpn of vport whose targets maybe enabled\n *\t\t      for Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n *\n * Returns:\n * value of count on success\n **/\nstatic ssize_t\nlpfc_oas_vpt_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t\twwn_to_u64(phba->cfg_oas_vpt_wwpn));\n}\n\n/**\n * lpfc_oas_vpt_store - Store wwpn of vport whose targets maybe enabled\n *\t\t      for Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n * @count: Size of the data buffer.\n *\n * Returns:\n * -EINVAL count is invalid, invalid wwpn byte invalid\n * -EPERM oas is not supported by hba\n * value of count on success\n **/\nstatic ssize_t\nlpfc_oas_vpt_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tuint8_t wwpn[WWN_SZ];\n\tint rc;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\t/* count may include a LF at end of string */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\trc = lpfc_wwn_set(buf, cnt, wwpn);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(phba->cfg_oas_vpt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tmemcpy(phba->sli4_hba.oas_next_vpt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tif (wwn_to_u64(wwpn) == 0)\n\t\tphba->cfg_oas_flags |= OAS_FIND_ANY_VPORT;\n\telse\n\t\tphba->cfg_oas_flags &= ~OAS_FIND_ANY_VPORT;\n\tphba->cfg_oas_flags &= ~OAS_LUN_VALID;\n\tif (phba->cfg_oas_priority == 0)\n\t\tphba->cfg_oas_priority = phba->cfg_XLanePriority;\n\tphba->sli4_hba.oas_next_lun = FIND_FIRST_OAS_LUN;\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_vpt, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_vpt_show, lpfc_oas_vpt_store);\n\n/**\n * lpfc_oas_lun_state_show - Return the current state (enabled or disabled)\n *\t\t\t    of whether luns will be enabled or disabled\n *\t\t\t    for Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n *\n * Returns:\n * size of formatted string.\n **/\nstatic ssize_t\nlpfc_oas_lun_state_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->cfg_oas_lun_state);\n}\n\n/**\n * lpfc_oas_lun_state_store - Store the state (enabled or disabled)\n *\t\t\t    of whether luns will be enabled or disabled\n *\t\t\t    for Optimized Access Storage (OAS) operations.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n * @count: Size of the data buffer.\n *\n * Returns:\n * -EINVAL count is invalid, invalid wwpn byte invalid\n * -EPERM oas is not supported by hba\n * value of count on success\n **/\nstatic ssize_t\nlpfc_oas_lun_state_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tint val = 0;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif ((val != 0) && (val != 1))\n\t\treturn -EINVAL;\n\n\tphba->cfg_oas_lun_state = val;\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR(lpfc_xlane_lun_state, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_lun_state_show, lpfc_oas_lun_state_store);\n\n/**\n * lpfc_oas_lun_status_show - Return the status of the Optimized Access\n *                          Storage (OAS) lun returned by the\n *                          lpfc_oas_lun_show function.\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n *\n * Returns:\n * size of formatted string.\n **/\nstatic ssize_t\nlpfc_oas_lun_status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\tif (!(phba->cfg_oas_flags & OAS_LUN_VALID))\n\t\treturn -EFAULT;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->cfg_oas_lun_status);\n}\nstatic DEVICE_ATTR(lpfc_xlane_lun_status, S_IRUGO,\n\t\t   lpfc_oas_lun_status_show, NULL);\n\n\n/**\n * lpfc_oas_lun_state_set - enable or disable a lun for Optimized Access Storage\n *\t\t\t   (OAS) operations.\n * @phba: lpfc_hba pointer.\n * @vpt_wwpn: wwpn of the vport associated with the returned lun\n * @tgt_wwpn: wwpn of the target associated with the returned lun\n * @lun: the fc lun for setting oas state.\n * @oas_state: the oas state to be set to the lun.\n * @pri: priority\n *\n * Returns:\n * SUCCESS : 0\n * -EPERM OAS is not enabled or not supported by this port.\n *\n */\nstatic size_t\nlpfc_oas_lun_state_set(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\n\t\t       uint8_t tgt_wwpn[], uint64_t lun,\n\t\t       uint32_t oas_state, uint8_t pri)\n{\n\n\tint rc = 0;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (oas_state) {\n\t\tif (!lpfc_enable_oas_lun(phba, (struct lpfc_name *)vpt_wwpn,\n\t\t\t\t\t (struct lpfc_name *)tgt_wwpn,\n\t\t\t\t\t lun, pri))\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\tlpfc_disable_oas_lun(phba, (struct lpfc_name *)vpt_wwpn,\n\t\t\t\t     (struct lpfc_name *)tgt_wwpn, lun, pri);\n\t}\n\treturn rc;\n\n}\n\n/**\n * lpfc_oas_lun_get_next - get the next lun that has been enabled for Optimized\n *\t\t\t  Access Storage (OAS) operations.\n * @phba: lpfc_hba pointer.\n * @vpt_wwpn: wwpn of the vport associated with the returned lun\n * @tgt_wwpn: wwpn of the target associated with the returned lun\n * @lun_status: status of the lun returned lun\n * @lun_pri: priority of the lun returned lun\n *\n * Returns the first or next lun enabled for OAS operations for the vport/target\n * specified.  If a lun is found, its vport wwpn, target wwpn and status is\n * returned.  If the lun is not found, NOT_OAS_ENABLED_LUN is returned.\n *\n * Return:\n * lun that is OAS enabled for the vport/target\n * NOT_OAS_ENABLED_LUN when no oas enabled lun found.\n */\nstatic uint64_t\nlpfc_oas_lun_get_next(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\n\t\t      uint8_t tgt_wwpn[], uint32_t *lun_status,\n\t\t      uint32_t *lun_pri)\n{\n\tuint64_t found_lun;\n\n\tif (unlikely(!phba) || !vpt_wwpn || !tgt_wwpn)\n\t\treturn NOT_OAS_ENABLED_LUN;\n\tif (lpfc_find_next_oas_lun(phba, (struct lpfc_name *)\n\t\t\t\t   phba->sli4_hba.oas_next_vpt_wwpn,\n\t\t\t\t   (struct lpfc_name *)\n\t\t\t\t   phba->sli4_hba.oas_next_tgt_wwpn,\n\t\t\t\t   &phba->sli4_hba.oas_next_lun,\n\t\t\t\t   (struct lpfc_name *)vpt_wwpn,\n\t\t\t\t   (struct lpfc_name *)tgt_wwpn,\n\t\t\t\t   &found_lun, lun_status, lun_pri))\n\t\treturn found_lun;\n\telse\n\t\treturn NOT_OAS_ENABLED_LUN;\n}\n\n/**\n * lpfc_oas_lun_state_change - enable/disable a lun for OAS operations\n * @phba: lpfc_hba pointer.\n * @vpt_wwpn: vport wwpn by reference.\n * @tgt_wwpn: target wwpn by reference.\n * @lun: the fc lun for setting oas state.\n * @oas_state: the oas state to be set to the oas_lun.\n * @pri: priority\n *\n * This routine enables (OAS_LUN_ENABLE) or disables (OAS_LUN_DISABLE)\n * a lun for OAS operations.\n *\n * Return:\n * SUCCESS: 0\n * -ENOMEM: failed to enable an lun for OAS operations\n * -EPERM: OAS is not enabled\n */\nstatic ssize_t\nlpfc_oas_lun_state_change(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\n\t\t\t  uint8_t tgt_wwpn[], uint64_t lun,\n\t\t\t  uint32_t oas_state, uint8_t pri)\n{\n\n\tint rc;\n\n\trc = lpfc_oas_lun_state_set(phba, vpt_wwpn, tgt_wwpn, lun,\n\t\t\t\t    oas_state, pri);\n\treturn rc;\n}\n\n/**\n * lpfc_oas_lun_show - Return oas enabled luns from a chosen target\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n *\n * This routine returns a lun enabled for OAS each time the function\n * is called.\n *\n * Returns:\n * SUCCESS: size of formatted string.\n * -EFAULT: target or vport wwpn was not set properly.\n * -EPERM: oas is not enabled.\n **/\nstatic ssize_t\nlpfc_oas_lun_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\tuint64_t oas_lun;\n\tint len = 0;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (wwn_to_u64(phba->cfg_oas_vpt_wwpn) == 0)\n\t\tif (!(phba->cfg_oas_flags & OAS_FIND_ANY_VPORT))\n\t\t\treturn -EFAULT;\n\n\tif (wwn_to_u64(phba->cfg_oas_tgt_wwpn) == 0)\n\t\tif (!(phba->cfg_oas_flags & OAS_FIND_ANY_TARGET))\n\t\t\treturn -EFAULT;\n\n\toas_lun = lpfc_oas_lun_get_next(phba, phba->cfg_oas_vpt_wwpn,\n\t\t\t\t\tphba->cfg_oas_tgt_wwpn,\n\t\t\t\t\t&phba->cfg_oas_lun_status,\n\t\t\t\t\t&phba->cfg_oas_priority);\n\tif (oas_lun != NOT_OAS_ENABLED_LUN)\n\t\tphba->cfg_oas_flags |= OAS_LUN_VALID;\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"0x%llx\", oas_lun);\n\n\treturn len;\n}\n\n/**\n * lpfc_oas_lun_store - Sets the OAS state for lun\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: buffer for passing information.\n * @count: size of the formatting string\n *\n * This function sets the OAS state for lun.  Before this function is called,\n * the vport wwpn, target wwpn, and oas state need to be set.\n *\n * Returns:\n * SUCCESS: size of formatted string.\n * -EFAULT: target or vport wwpn was not set properly.\n * -EPERM: oas is not enabled.\n * size of formatted string.\n **/\nstatic ssize_t\nlpfc_oas_lun_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tuint64_t scsi_lun;\n\tuint32_t pri;\n\tssize_t rc;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (wwn_to_u64(phba->cfg_oas_vpt_wwpn) == 0)\n\t\treturn -EFAULT;\n\n\tif (wwn_to_u64(phba->cfg_oas_tgt_wwpn) == 0)\n\t\treturn -EFAULT;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"0x%llx\", &scsi_lun) != 1)\n\t\treturn -EINVAL;\n\n\tpri = phba->cfg_oas_priority;\n\tif (pri == 0)\n\t\tpri = phba->cfg_XLanePriority;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\"3372 Try to set vport 0x%llx target 0x%llx lun:0x%llx \"\n\t\t\t\"priority 0x%x with oas state %d\\n\",\n\t\t\twwn_to_u64(phba->cfg_oas_vpt_wwpn),\n\t\t\twwn_to_u64(phba->cfg_oas_tgt_wwpn), scsi_lun,\n\t\t\tpri, phba->cfg_oas_lun_state);\n\n\trc = lpfc_oas_lun_state_change(phba, phba->cfg_oas_vpt_wwpn,\n\t\t\t\t       phba->cfg_oas_tgt_wwpn, scsi_lun,\n\t\t\t\t       phba->cfg_oas_lun_state, pri);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_lun, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_lun_show, lpfc_oas_lun_store);\n\nint lpfc_enable_nvmet_cnt;\nunsigned long long lpfc_enable_nvmet[LPFC_NVMET_MAX_PORTS] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nmodule_param_array(lpfc_enable_nvmet, ullong, &lpfc_enable_nvmet_cnt, 0444);\nMODULE_PARM_DESC(lpfc_enable_nvmet, \"Enable HBA port(s) WWPN as a NVME Target\");\n\nstatic int lpfc_poll = 0;\nmodule_param(lpfc_poll, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_poll, \"FCP ring polling mode control:\"\n\t\t \" 0 - none,\"\n\t\t \" 1 - poll with interrupts enabled\"\n\t\t \" 3 - poll and disable FCP ring interrupts\");\n\nstatic DEVICE_ATTR_RW(lpfc_poll);\n\nint lpfc_no_hba_reset_cnt;\nunsigned long lpfc_no_hba_reset[MAX_HBAS_NO_RESET] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nmodule_param_array(lpfc_no_hba_reset, ulong, &lpfc_no_hba_reset_cnt, 0444);\nMODULE_PARM_DESC(lpfc_no_hba_reset, \"WWPN of HBAs that should not be reset\");\n\nLPFC_ATTR(sli_mode, 3, 3, 3,\n\t\"SLI mode selector: 3 - select SLI-3\");\n\nLPFC_ATTR_R(enable_npiv, 1, 0, 1,\n\t\"Enable NPIV functionality\");\n\nLPFC_ATTR_R(fcf_failover_policy, 1, 1, 2,\n\t\"FCF Fast failover=1 Priority failover=2\");\n\n/*\n# lpfc_enable_rrq: Track XRI/OXID reuse after IO failures\n#\t0x0 = disabled, XRI/OXID use not tracked.\n#\t0x1 = XRI/OXID reuse is timed with ratov, RRQ sent.\n#\t0x2 = XRI/OXID reuse is timed with ratov, No RRQ sent.\n*/\nLPFC_ATTR_R(enable_rrq, 2, 0, 2,\n\t\"Enable RRQ functionality\");\n\n/*\n# lpfc_suppress_link_up:  Bring link up at initialization\n#            0x0  = bring link up (issue MBX_INIT_LINK)\n#            0x1  = do NOT bring link up at initialization(MBX_INIT_LINK)\n#            0x2  = never bring up link\n# Default value is 0.\n*/\nLPFC_ATTR_R(suppress_link_up, LPFC_INITIALIZE_LINK, LPFC_INITIALIZE_LINK,\n\t\tLPFC_DELAY_INIT_LINK_INDEFINITELY,\n\t\t\"Suppress Link Up at initialization\");\n\nstatic ssize_t\nlpfc_pls_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t phba->sli4_hba.pc_sli4_params.pls);\n}\nstatic DEVICE_ATTR(pls, 0444,\n\t\t\t lpfc_pls_show, NULL);\n\nstatic ssize_t\nlpfc_pt_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t (phba->hba_flag & HBA_PERSISTENT_TOPO) ? 1 : 0);\n}\nstatic DEVICE_ATTR(pt, 0444,\n\t\t\t lpfc_pt_show, NULL);\n\n/*\n# lpfc_cnt: Number of IOCBs allocated for ELS, CT, and ABTS\n#       1 - (1024)\n#       2 - (2048)\n#       3 - (3072)\n#       4 - (4096)\n#       5 - (5120)\n*/\nstatic ssize_t\nlpfc_iocb_hw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->iocb_max);\n}\n\nstatic DEVICE_ATTR(iocb_hw, S_IRUGO,\n\t\t\t lpfc_iocb_hw_show, NULL);\nstatic ssize_t\nlpfc_txq_hw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\n\tstruct lpfc_sli_ring *pring = lpfc_phba_elsring(phba);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tpring ? pring->txq_max : 0);\n}\n\nstatic DEVICE_ATTR(txq_hw, S_IRUGO,\n\t\t\t lpfc_txq_hw_show, NULL);\nstatic ssize_t\nlpfc_txcmplq_hw_show(struct device *dev, struct device_attribute *attr,\n char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\n\tstruct lpfc_sli_ring *pring = lpfc_phba_elsring(phba);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tpring ? pring->txcmplq_max : 0);\n}\n\nstatic DEVICE_ATTR(txcmplq_hw, S_IRUGO,\n\t\t\t lpfc_txcmplq_hw_show, NULL);\n\n/*\n# lpfc_nodev_tmo: If set, it will hold all I/O errors on devices that disappear\n# until the timer expires. Value range is [0,255]. Default value is 30.\n*/\nstatic int lpfc_nodev_tmo = LPFC_DEF_DEVLOSS_TMO;\nstatic int lpfc_devloss_tmo = LPFC_DEF_DEVLOSS_TMO;\nmodule_param(lpfc_nodev_tmo, int, 0);\nMODULE_PARM_DESC(lpfc_nodev_tmo,\n\t\t \"Seconds driver will hold I/O waiting \"\n\t\t \"for a device to come back\");\n\n/**\n * lpfc_nodev_tmo_show - Return the hba dev loss timeout value\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains the dev loss timeout in decimal.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_nodev_tmo_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\tvport->cfg_devloss_tmo);\n}\n\n/**\n * lpfc_nodev_tmo_init - Set the hba nodev timeout value\n * @vport: lpfc vport structure pointer.\n * @val: contains the nodev timeout value.\n *\n * Description:\n * If the devloss tmo is already set then nodev tmo is set to devloss tmo,\n * a kernel error message is printed and zero is returned.\n * Else if val is in range then nodev tmo and devloss tmo are set to val.\n * Otherwise nodev tmo is set to the default value.\n *\n * Returns:\n * zero if already set or if val is in range\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_nodev_tmo_init(struct lpfc_vport *vport, int val)\n{\n\tif (vport->cfg_devloss_tmo != LPFC_DEF_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = vport->cfg_devloss_tmo;\n\t\tif (val != LPFC_DEF_DEVLOSS_TMO)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"0407 Ignoring lpfc_nodev_tmo module \"\n\t\t\t\t\t \"parameter because lpfc_devloss_tmo \"\n\t\t\t\t\t \"is set.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = val;\n\t\tvport->cfg_devloss_tmo = val;\n\t\treturn 0;\n\t}\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"0400 lpfc_nodev_tmo attribute cannot be set to\"\n\t\t\t \" %d, allowed range is [%d, %d]\\n\",\n\t\t\t val, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\n\tvport->cfg_nodev_tmo = LPFC_DEF_DEVLOSS_TMO;\n\treturn -EINVAL;\n}\n\n/**\n * lpfc_update_rport_devloss_tmo - Update dev loss tmo value\n * @vport: lpfc vport structure pointer.\n *\n * Description:\n * Update all the ndlp's dev loss tmo with the vport devloss tmo value.\n **/\nstatic void\nlpfc_update_rport_devloss_tmo(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host  *shost;\n\tstruct lpfc_nodelist  *ndlp;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_nvme_rport *rport;\n\tstruct nvme_fc_remote_port *remoteport = NULL;\n#endif\n\n\tshost = lpfc_shost_from_vport(vport);\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->rport)\n\t\t\tndlp->rport->dev_loss_tmo = vport->cfg_devloss_tmo;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\t\tspin_lock(&ndlp->lock);\n\t\trport = lpfc_ndlp_get_nrport(ndlp);\n\t\tif (rport)\n\t\t\tremoteport = rport->remoteport;\n\t\tspin_unlock(&ndlp->lock);\n\t\tif (rport && remoteport)\n\t\t\tnvme_fc_set_remoteport_devloss(remoteport,\n\t\t\t\t\t\t       vport->cfg_devloss_tmo);\n#endif\n\t}\n\tspin_unlock_irq(shost->host_lock);\n}\n\n/**\n * lpfc_nodev_tmo_set - Set the vport nodev tmo and devloss tmo values\n * @vport: lpfc vport structure pointer.\n * @val: contains the tmo value.\n *\n * Description:\n * If the devloss tmo is already set or the vport dev loss tmo has changed\n * then a kernel error message is printed and zero is returned.\n * Else if val is in range then nodev tmo and devloss tmo are set to val.\n * Otherwise nodev tmo is set to the default value.\n *\n * Returns:\n * zero if already set or if val is in range\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_nodev_tmo_set(struct lpfc_vport *vport, int val)\n{\n\tif (vport->dev_loss_tmo_changed ||\n\t    (lpfc_devloss_tmo != LPFC_DEF_DEVLOSS_TMO)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0401 Ignoring change to lpfc_nodev_tmo \"\n\t\t\t\t \"because lpfc_devloss_tmo is set.\\n\");\n\t\treturn 0;\n\t}\n\tif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = val;\n\t\tvport->cfg_devloss_tmo = val;\n\t\t/*\n\t\t * For compat: set the fc_host dev loss so new rports\n\t\t * will get the value.\n\t\t */\n\t\tfc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;\n\t\tlpfc_update_rport_devloss_tmo(vport);\n\t\treturn 0;\n\t}\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"0403 lpfc_nodev_tmo attribute cannot be set to \"\n\t\t\t \"%d, allowed range is [%d, %d]\\n\",\n\t\t\t val, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\n\treturn -EINVAL;\n}\n\nlpfc_vport_param_store(nodev_tmo)\n\nstatic DEVICE_ATTR_RW(lpfc_nodev_tmo);\n\n/*\n# lpfc_devloss_tmo: If set, it will hold all I/O errors on devices that\n# disappear until the timer expires. Value range is [0,255]. Default\n# value is 30.\n*/\nmodule_param(lpfc_devloss_tmo, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_devloss_tmo,\n\t\t \"Seconds driver will hold I/O waiting \"\n\t\t \"for a device to come back\");\nlpfc_vport_param_init(devloss_tmo, LPFC_DEF_DEVLOSS_TMO,\n\t\t      LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO)\nlpfc_vport_param_show(devloss_tmo)\n\n/**\n * lpfc_devloss_tmo_set - Sets vport nodev tmo, devloss tmo values, changed bit\n * @vport: lpfc vport structure pointer.\n * @val: contains the tmo value.\n *\n * Description:\n * If val is in a valid range then set the vport nodev tmo,\n * devloss tmo, also set the vport dev loss tmo changed flag.\n * Else a kernel error message is printed.\n *\n * Returns:\n * zero if val is in range\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_devloss_tmo_set(struct lpfc_vport *vport, int val)\n{\n\tif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = val;\n\t\tvport->cfg_devloss_tmo = val;\n\t\tvport->dev_loss_tmo_changed = 1;\n\t\tfc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;\n\t\tlpfc_update_rport_devloss_tmo(vport);\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"0404 lpfc_devloss_tmo attribute cannot be set to \"\n\t\t\t \"%d, allowed range is [%d, %d]\\n\",\n\t\t\t val, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\n\treturn -EINVAL;\n}\n\nlpfc_vport_param_store(devloss_tmo)\nstatic DEVICE_ATTR_RW(lpfc_devloss_tmo);\n\n/*\n * lpfc_suppress_rsp: Enable suppress rsp feature is firmware supports it\n * lpfc_suppress_rsp = 0  Disable\n * lpfc_suppress_rsp = 1  Enable (default)\n *\n */\nLPFC_ATTR_R(suppress_rsp, 1, 0, 1,\n\t    \"Enable suppress rsp feature is firmware supports it\");\n\n/*\n * lpfc_nvmet_mrq: Specify number of RQ pairs for processing NVMET cmds\n * lpfc_nvmet_mrq = 0  driver will calcualte optimal number of RQ pairs\n * lpfc_nvmet_mrq = 1  use a single RQ pair\n * lpfc_nvmet_mrq >= 2  use specified RQ pairs for MRQ\n *\n */\nLPFC_ATTR_R(nvmet_mrq,\n\t    LPFC_NVMET_MRQ_AUTO, LPFC_NVMET_MRQ_AUTO, LPFC_NVMET_MRQ_MAX,\n\t    \"Specify number of RQ pairs for processing NVMET cmds\");\n\n/*\n * lpfc_nvmet_mrq_post: Specify number of RQ buffer to initially post\n * to each NVMET RQ. Range 64 to 2048, default is 512.\n */\nLPFC_ATTR_R(nvmet_mrq_post,\n\t    LPFC_NVMET_RQE_DEF_POST, LPFC_NVMET_RQE_MIN_POST,\n\t    LPFC_NVMET_RQE_DEF_COUNT,\n\t    \"Specify number of RQ buffers to initially post\");\n\n/*\n * lpfc_enable_fc4_type: Defines what FC4 types are supported.\n * Supported Values:  1 - register just FCP\n *                    3 - register both FCP and NVME\n * Supported values are [1,3]. Default value is 3\n */\nLPFC_ATTR_R(enable_fc4_type, LPFC_ENABLE_BOTH,\n\t    LPFC_ENABLE_FCP, LPFC_ENABLE_BOTH,\n\t    \"Enable FC4 Protocol support - FCP / NVME\");\n\n/*\n# lpfc_log_verbose: Only turn this flag on if you are willing to risk being\n# deluged with LOTS of information.\n# You can set a bit mask to record specific types of verbose messages:\n# See lpfc_logmsh.h for definitions.\n*/\nLPFC_VPORT_ATTR_HEX_RW(log_verbose, 0x0, 0x0, 0xffffffff,\n\t\t       \"Verbose logging bit-mask\");\n\n/*\n# lpfc_enable_da_id: This turns on the DA_ID CT command that deregisters\n# objects that have been registered with the nameserver after login.\n*/\nLPFC_VPORT_ATTR_R(enable_da_id, 1, 0, 1,\n\t\t  \"Deregister nameserver objects before LOGO\");\n\n/*\n# lun_queue_depth:  This parameter is used to limit the number of outstanding\n# commands per FCP LUN.\n*/\nLPFC_VPORT_ATTR_R(lun_queue_depth, 64, 1, 512,\n\t\t  \"Max number of FCP commands we can queue to a specific LUN\");\n\n/*\n# tgt_queue_depth:  This parameter is used to limit the number of outstanding\n# commands per target port. Value range is [10,65535]. Default value is 65535.\n*/\nstatic uint lpfc_tgt_queue_depth = LPFC_MAX_TGT_QDEPTH;\nmodule_param(lpfc_tgt_queue_depth, uint, 0444);\nMODULE_PARM_DESC(lpfc_tgt_queue_depth, \"Set max Target queue depth\");\nlpfc_vport_param_show(tgt_queue_depth);\nlpfc_vport_param_init(tgt_queue_depth, LPFC_MAX_TGT_QDEPTH,\n\t\t      LPFC_MIN_TGT_QDEPTH, LPFC_MAX_TGT_QDEPTH);\n\n/**\n * lpfc_tgt_queue_depth_store: Sets an attribute value.\n * @vport: lpfc vport structure pointer.\n * @val: integer attribute value.\n *\n * Description: Sets the parameter to the new value.\n *\n * Returns:\n * zero on success\n * -EINVAL if val is invalid\n */\nstatic int\nlpfc_tgt_queue_depth_set(struct lpfc_vport *vport, uint val)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp;\n\n\tif (!lpfc_rangecheck(val, LPFC_MIN_TGT_QDEPTH, LPFC_MAX_TGT_QDEPTH))\n\t\treturn -EINVAL;\n\n\tif (val == vport->cfg_tgt_queue_depth)\n\t\treturn 0;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->cfg_tgt_queue_depth = val;\n\n\t/* Next loop thru nodelist and change cmd_qdepth */\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp)\n\t\tndlp->cmd_qdepth = vport->cfg_tgt_queue_depth;\n\n\tspin_unlock_irq(shost->host_lock);\n\treturn 0;\n}\n\nlpfc_vport_param_store(tgt_queue_depth);\nstatic DEVICE_ATTR_RW(lpfc_tgt_queue_depth);\n\n/*\n# hba_queue_depth:  This parameter is used to limit the number of outstanding\n# commands per lpfc HBA. Value range is [32,8192]. If this parameter\n# value is greater than the maximum number of exchanges supported by the HBA,\n# then maximum number of exchanges supported by the HBA is used to determine\n# the hba_queue_depth.\n*/\nLPFC_ATTR_R(hba_queue_depth, 8192, 32, 8192,\n\t    \"Max number of FCP commands we can queue to a lpfc HBA\");\n\n/*\n# peer_port_login:  This parameter allows/prevents logins\n# between peer ports hosted on the same physical port.\n# When this parameter is set 0 peer ports of same physical port\n# are not allowed to login to each other.\n# When this parameter is set 1 peer ports of same physical port\n# are allowed to login to each other.\n# Default value of this parameter is 0.\n*/\nLPFC_VPORT_ATTR_R(peer_port_login, 0, 0, 1,\n\t\t  \"Allow peer ports on the same physical port to login to each \"\n\t\t  \"other.\");\n\n/*\n# restrict_login:  This parameter allows/prevents logins\n# between Virtual Ports and remote initiators.\n# When this parameter is not set (0) Virtual Ports will accept PLOGIs from\n# other initiators and will attempt to PLOGI all remote ports.\n# When this parameter is set (1) Virtual Ports will reject PLOGIs from\n# remote ports and will not attempt to PLOGI to other initiators.\n# This parameter does not restrict to the physical port.\n# This parameter does not restrict logins to Fabric resident remote ports.\n# Default value of this parameter is 1.\n*/\nstatic int lpfc_restrict_login = 1;\nmodule_param(lpfc_restrict_login, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_restrict_login,\n\t\t \"Restrict virtual ports login to remote initiators.\");\nlpfc_vport_param_show(restrict_login);\n\n/**\n * lpfc_restrict_login_init - Set the vport restrict login flag\n * @vport: lpfc vport structure pointer.\n * @val: contains the restrict login value.\n *\n * Description:\n * If val is not in a valid range then log a kernel error message and set\n * the vport restrict login to one.\n * If the port type is physical clear the restrict login flag and return.\n * Else set the restrict login flag to val.\n *\n * Returns:\n * zero if val is in range\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_restrict_login_init(struct lpfc_vport *vport, int val)\n{\n\tif (val < 0 || val > 1) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0422 lpfc_restrict_login attribute cannot \"\n\t\t\t\t \"be set to %d, allowed range is [0, 1]\\n\",\n\t\t\t\t val);\n\t\tvport->cfg_restrict_login = 1;\n\t\treturn -EINVAL;\n\t}\n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tvport->cfg_restrict_login = 0;\n\t\treturn 0;\n\t}\n\tvport->cfg_restrict_login = val;\n\treturn 0;\n}\n\n/**\n * lpfc_restrict_login_set - Set the vport restrict login flag\n * @vport: lpfc vport structure pointer.\n * @val: contains the restrict login value.\n *\n * Description:\n * If val is not in a valid range then log a kernel error message and set\n * the vport restrict login to one.\n * If the port type is physical and the val is not zero log a kernel\n * error message, clear the restrict login flag and return zero.\n * Else set the restrict login flag to val.\n *\n * Returns:\n * zero if val is in range\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_restrict_login_set(struct lpfc_vport *vport, int val)\n{\n\tif (val < 0 || val > 1) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0425 lpfc_restrict_login attribute cannot \"\n\t\t\t\t \"be set to %d, allowed range is [0, 1]\\n\",\n\t\t\t\t val);\n\t\tvport->cfg_restrict_login = 1;\n\t\treturn -EINVAL;\n\t}\n\tif (vport->port_type == LPFC_PHYSICAL_PORT && val != 0) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0468 lpfc_restrict_login must be 0 for \"\n\t\t\t\t \"Physical ports.\\n\");\n\t\tvport->cfg_restrict_login = 0;\n\t\treturn 0;\n\t}\n\tvport->cfg_restrict_login = val;\n\treturn 0;\n}\nlpfc_vport_param_store(restrict_login);\nstatic DEVICE_ATTR_RW(lpfc_restrict_login);\n\n/*\n# Some disk devices have a \"select ID\" or \"select Target\" capability.\n# From a protocol standpoint \"select ID\" usually means select the\n# Fibre channel \"ALPA\".  In the FC-AL Profile there is an \"informative\n# annex\" which contains a table that maps a \"select ID\" (a number\n# between 0 and 7F) to an ALPA.  By default, for compatibility with\n# older drivers, the lpfc driver scans this table from low ALPA to high\n# ALPA.\n#\n# Turning on the scan-down variable (on  = 1, off = 0) will\n# cause the lpfc driver to use an inverted table, effectively\n# scanning ALPAs from high to low. Value range is [0,1]. Default value is 1.\n#\n# (Note: This \"select ID\" functionality is a LOOP ONLY characteristic\n# and will not work across a fabric. Also this parameter will take\n# effect only in the case when ALPA map is not available.)\n*/\nLPFC_VPORT_ATTR_R(scan_down, 1, 0, 1,\n\t\t  \"Start scanning for devices from highest ALPA to lowest\");\n\n/*\n# lpfc_topology:  link topology for init link\n#            0x0  = attempt loop mode then point-to-point\n#            0x01 = internal loopback mode\n#            0x02 = attempt point-to-point mode only\n#            0x04 = attempt loop mode only\n#            0x06 = attempt point-to-point mode then loop\n# Set point-to-point mode if you want to run as an N_Port.\n# Set loop mode if you want to run as an NL_Port. Value range is [0,0x6].\n# Default value is 0.\n*/\nLPFC_ATTR(topology, 0, 0, 6,\n\t\"Select Fibre Channel topology\");\n\n/**\n * lpfc_topology_set - Set the adapters topology field\n * @dev: class device that is converted into a scsi_host.\n * @attr:device attribute, not used.\n * @buf: buffer for passing information.\n * @count: size of the data buffer.\n *\n * Description:\n * If val is in a valid range then set the adapter's topology field and\n * issue a lip; if the lip fails reset the topology to the old value.\n *\n * If the value is not in range log a kernel error message and return an error.\n *\n * Returns:\n * zero if val is in range and lip okay\n * non-zero return value from lpfc_issue_lip()\n * -EINVAL val out of range\n **/\nstatic ssize_t\nlpfc_topology_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint val = 0;\n\tint nolip = 0;\n\tconst char *val_buf = buf;\n\tint err;\n\tuint32_t prev_val;\n\n\tif (!strncmp(buf, \"nolip \", strlen(\"nolip \"))) {\n\t\tnolip = 1;\n\t\tval_buf = &buf[strlen(\"nolip \")];\n\t}\n\n\tif (!isdigit(val_buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(val_buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif (val >= 0 && val <= 6) {\n\t\tprev_val = phba->cfg_topology;\n\t\tif (phba->cfg_link_speed == LPFC_USER_LINK_SPEED_16G &&\n\t\t\tval == 4) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3113 Loop mode not supported at speed %d\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/*\n\t\t * The 'topology' is not a configurable parameter if :\n\t\t *   - persistent topology enabled\n\t\t *   - G7/G6 with no private loop support\n\t\t */\n\n\t\tif ((phba->hba_flag & HBA_PERSISTENT_TOPO ||\n\t\t     (!phba->sli4_hba.pc_sli4_params.pls &&\n\t\t     (phba->pcidev->device == PCI_DEVICE_ID_LANCER_G6_FC ||\n\t\t     phba->pcidev->device == PCI_DEVICE_ID_LANCER_G7_FC))) &&\n\t\t    val == 4) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3114 Loop mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphba->cfg_topology = val;\n\t\tif (nolip)\n\t\t\treturn strlen(buf);\n\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\"3054 lpfc_topology changed from %d to %d\\n\",\n\t\t\tprev_val, val);\n\t\tif (prev_val != val && phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tphba->fc_topology_changed = 1;\n\t\terr = lpfc_issue_lip(lpfc_shost_from_vport(phba->pport));\n\t\tif (err) {\n\t\t\tphba->cfg_topology = prev_val;\n\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\treturn strlen(buf);\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\"%d:0467 lpfc_topology attribute cannot be set to %d, \"\n\t\t\"allowed range is [0, 6]\\n\",\n\t\tphba->brd_no, val);\n\treturn -EINVAL;\n}\n\nlpfc_param_show(topology)\nstatic DEVICE_ATTR_RW(lpfc_topology);\n\n/**\n * lpfc_static_vport_show: Read callback function for\n *   lpfc_static_vport sysfs file.\n * @dev: Pointer to class device object.\n * @attr: device attribute structure.\n * @buf: Data buffer.\n *\n * This function is the read call back function for\n * lpfc_static_vport sysfs file. The lpfc_static_vport\n * sysfs file report the mageability of the vport.\n **/\nstatic ssize_t\nlpfc_static_vport_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tif (vport->vport_flag & STATIC_VPORT)\n\t\tsprintf(buf, \"1\\n\");\n\telse\n\t\tsprintf(buf, \"0\\n\");\n\n\treturn strlen(buf);\n}\n\n/*\n * Sysfs attribute to control the statistical data collection.\n */\nstatic DEVICE_ATTR_RO(lpfc_static_vport);\n\n/**\n * lpfc_stat_data_ctrl_store - write call back for lpfc_stat_data_ctrl sysfs file\n * @dev: Pointer to class device.\n * @attr: Unused.\n * @buf: Data buffer.\n * @count: Size of the data buffer.\n *\n * This function get called when a user write to the lpfc_stat_data_ctrl\n * sysfs file. This function parse the command written to the sysfs file\n * and take appropriate action. These commands are used for controlling\n * driver statistical data collection.\n * Following are the command this function handles.\n *\n *    setbucket <bucket_type> <base> <step>\n *\t\t\t       = Set the latency buckets.\n *    destroybucket            = destroy all the buckets.\n *    start                    = start data collection\n *    stop                     = stop data collection\n *    reset                    = reset the collected data\n **/\nstatic ssize_t\nlpfc_stat_data_ctrl_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n#define LPFC_MAX_DATA_CTRL_LEN 1024\n\tstatic char bucket_data[LPFC_MAX_DATA_CTRL_LEN];\n\tunsigned long i;\n\tchar *str_ptr, *token;\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host *v_shost;\n\tchar *bucket_type_str, *base_str, *step_str;\n\tunsigned long base, step, bucket_type;\n\n\tif (!strncmp(buf, \"setbucket\", strlen(\"setbucket\"))) {\n\t\tif (strlen(buf) > (LPFC_MAX_DATA_CTRL_LEN - 1))\n\t\t\treturn -EINVAL;\n\n\t\tstrncpy(bucket_data, buf, LPFC_MAX_DATA_CTRL_LEN);\n\t\tstr_ptr = &bucket_data[0];\n\t\t/* Ignore this token - this is command token */\n\t\ttoken = strsep(&str_ptr, \"\\t \");\n\t\tif (!token)\n\t\t\treturn -EINVAL;\n\n\t\tbucket_type_str = strsep(&str_ptr, \"\\t \");\n\t\tif (!bucket_type_str)\n\t\t\treturn -EINVAL;\n\n\t\tif (!strncmp(bucket_type_str, \"linear\", strlen(\"linear\")))\n\t\t\tbucket_type = LPFC_LINEAR_BUCKET;\n\t\telse if (!strncmp(bucket_type_str, \"power2\", strlen(\"power2\")))\n\t\t\tbucket_type = LPFC_POWER2_BUCKET;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tbase_str = strsep(&str_ptr, \"\\t \");\n\t\tif (!base_str)\n\t\t\treturn -EINVAL;\n\t\tbase = simple_strtoul(base_str, NULL, 0);\n\n\t\tstep_str = strsep(&str_ptr, \"\\t \");\n\t\tif (!step_str)\n\t\t\treturn -EINVAL;\n\t\tstep = simple_strtoul(step_str, NULL, 0);\n\t\tif (!step)\n\t\t\treturn -EINVAL;\n\n\t\t/* Block the data collection for every vport */\n\t\tvports = lpfc_create_vport_work_array(phba);\n\t\tif (vports == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tv_shost = lpfc_shost_from_vport(vports[i]);\n\t\t\tspin_lock_irq(v_shost->host_lock);\n\t\t\t/* Block and reset data collection */\n\t\t\tvports[i]->stat_data_blocked = 1;\n\t\t\tif (vports[i]->stat_data_enabled)\n\t\t\t\tlpfc_vport_reset_stat_data(vports[i]);\n\t\t\tspin_unlock_irq(v_shost->host_lock);\n\t\t}\n\n\t\t/* Set the bucket attributes */\n\t\tphba->bucket_type = bucket_type;\n\t\tphba->bucket_base = base;\n\t\tphba->bucket_step = step;\n\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tv_shost = lpfc_shost_from_vport(vports[i]);\n\n\t\t\t/* Unblock data collection */\n\t\t\tspin_lock_irq(v_shost->host_lock);\n\t\t\tvports[i]->stat_data_blocked = 0;\n\t\t\tspin_unlock_irq(v_shost->host_lock);\n\t\t}\n\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t\treturn strlen(buf);\n\t}\n\n\tif (!strncmp(buf, \"destroybucket\", strlen(\"destroybucket\"))) {\n\t\tvports = lpfc_create_vport_work_array(phba);\n\t\tif (vports == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tv_shost = lpfc_shost_from_vport(vports[i]);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvports[i]->stat_data_blocked = 1;\n\t\t\tlpfc_free_bucket(vport);\n\t\t\tvport->stat_data_enabled = 0;\n\t\t\tvports[i]->stat_data_blocked = 0;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t\tphba->bucket_type = LPFC_NO_BUCKET;\n\t\tphba->bucket_base = 0;\n\t\tphba->bucket_step = 0;\n\t\treturn strlen(buf);\n\t}\n\n\tif (!strncmp(buf, \"start\", strlen(\"start\"))) {\n\t\t/* If no buckets configured return error */\n\t\tif (phba->bucket_type == LPFC_NO_BUCKET)\n\t\t\treturn -EINVAL;\n\t\tspin_lock_irq(shost->host_lock);\n\t\tif (vport->stat_data_enabled) {\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\treturn strlen(buf);\n\t\t}\n\t\tlpfc_alloc_bucket(vport);\n\t\tvport->stat_data_enabled = 1;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn strlen(buf);\n\t}\n\n\tif (!strncmp(buf, \"stop\", strlen(\"stop\"))) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tif (vport->stat_data_enabled == 0) {\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\treturn strlen(buf);\n\t\t}\n\t\tlpfc_free_bucket(vport);\n\t\tvport->stat_data_enabled = 0;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn strlen(buf);\n\t}\n\n\tif (!strncmp(buf, \"reset\", strlen(\"reset\"))) {\n\t\tif ((phba->bucket_type == LPFC_NO_BUCKET)\n\t\t\t|| !vport->stat_data_enabled)\n\t\t\treturn strlen(buf);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->stat_data_blocked = 1;\n\t\tlpfc_vport_reset_stat_data(vport);\n\t\tvport->stat_data_blocked = 0;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn strlen(buf);\n\t}\n\treturn -EINVAL;\n}\n\n\n/**\n * lpfc_stat_data_ctrl_show - Read function for lpfc_stat_data_ctrl sysfs file\n * @dev: Pointer to class device.\n * @attr: Unused.\n * @buf: Data buffer.\n *\n * This function is the read call back function for\n * lpfc_stat_data_ctrl sysfs file. This function report the\n * current statistical data collection state.\n **/\nstatic ssize_t\nlpfc_stat_data_ctrl_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint index = 0;\n\tint i;\n\tchar *bucket_type;\n\tunsigned long bucket_value;\n\n\tswitch (phba->bucket_type) {\n\tcase LPFC_LINEAR_BUCKET:\n\t\tbucket_type = \"linear\";\n\t\tbreak;\n\tcase LPFC_POWER2_BUCKET:\n\t\tbucket_type = \"power2\";\n\t\tbreak;\n\tdefault:\n\t\tbucket_type = \"No Bucket\";\n\t\tbreak;\n\t}\n\n\tsprintf(&buf[index], \"Statistical Data enabled :%d, \"\n\t\t\"blocked :%d, Bucket type :%s, Bucket base :%d,\"\n\t\t\" Bucket step :%d\\nLatency Ranges :\",\n\t\tvport->stat_data_enabled, vport->stat_data_blocked,\n\t\tbucket_type, phba->bucket_base, phba->bucket_step);\n\tindex = strlen(buf);\n\tif (phba->bucket_type != LPFC_NO_BUCKET) {\n\t\tfor (i = 0; i < LPFC_MAX_BUCKET_COUNT; i++) {\n\t\t\tif (phba->bucket_type == LPFC_LINEAR_BUCKET)\n\t\t\t\tbucket_value = phba->bucket_base +\n\t\t\t\t\tphba->bucket_step * i;\n\t\t\telse\n\t\t\t\tbucket_value = phba->bucket_base +\n\t\t\t\t(1 << i) * phba->bucket_step;\n\n\t\t\tif (index + 10 > PAGE_SIZE)\n\t\t\t\tbreak;\n\t\t\tsprintf(&buf[index], \"%08ld \", bucket_value);\n\t\t\tindex = strlen(buf);\n\t\t}\n\t}\n\tsprintf(&buf[index], \"\\n\");\n\treturn strlen(buf);\n}\n\n/*\n * Sysfs attribute to control the statistical data collection.\n */\nstatic DEVICE_ATTR_RW(lpfc_stat_data_ctrl);\n\n/*\n * lpfc_drvr_stat_data: sysfs attr to get driver statistical data.\n */\n\n/*\n * Each Bucket takes 11 characters and 1 new line + 17 bytes WWN\n * for each target.\n */\n#define STAT_DATA_SIZE_PER_TARGET(NUM_BUCKETS) ((NUM_BUCKETS) * 11 + 18)\n#define MAX_STAT_DATA_SIZE_PER_TARGET \\\n\tSTAT_DATA_SIZE_PER_TARGET(LPFC_MAX_BUCKET_COUNT)\n\n\n/**\n * sysfs_drvr_stat_data_read - Read function for lpfc_drvr_stat_data attribute\n * @filp: sysfs file\n * @kobj: Pointer to the kernel object\n * @bin_attr: Attribute object\n * @buf: Buffer pointer\n * @off: File offset\n * @count: Buffer size\n *\n * This function is the read call back function for lpfc_drvr_stat_data\n * sysfs file. This function export the statistical data to user\n * applications.\n **/\nstatic ssize_t\nsysfs_drvr_stat_data_read(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *bin_attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = container_of(kobj, struct device,\n\t\tkobj);\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint i = 0, index = 0;\n\tunsigned long nport_index;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tnport_index = (unsigned long)off /\n\t\tMAX_STAT_DATA_SIZE_PER_TARGET;\n\n\tif (!vport->stat_data_enabled || vport->stat_data_blocked\n\t\t|| (phba->bucket_type == LPFC_NO_BUCKET))\n\t\treturn 0;\n\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (!ndlp->lat_data)\n\t\t\tcontinue;\n\n\t\tif (nport_index > 0) {\n\t\t\tnport_index--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((index + MAX_STAT_DATA_SIZE_PER_TARGET)\n\t\t\t> count)\n\t\t\tbreak;\n\n\t\tif (!ndlp->lat_data)\n\t\t\tcontinue;\n\n\t\t/* Print the WWN */\n\t\tsprintf(&buf[index], \"%02x%02x%02x%02x%02x%02x%02x%02x:\",\n\t\t\tndlp->nlp_portname.u.wwn[0],\n\t\t\tndlp->nlp_portname.u.wwn[1],\n\t\t\tndlp->nlp_portname.u.wwn[2],\n\t\t\tndlp->nlp_portname.u.wwn[3],\n\t\t\tndlp->nlp_portname.u.wwn[4],\n\t\t\tndlp->nlp_portname.u.wwn[5],\n\t\t\tndlp->nlp_portname.u.wwn[6],\n\t\t\tndlp->nlp_portname.u.wwn[7]);\n\n\t\tindex = strlen(buf);\n\n\t\tfor (i = 0; i < LPFC_MAX_BUCKET_COUNT; i++) {\n\t\t\tsprintf(&buf[index], \"%010u,\",\n\t\t\t\tndlp->lat_data[i].cmd_count);\n\t\t\tindex = strlen(buf);\n\t\t}\n\t\tsprintf(&buf[index], \"\\n\");\n\t\tindex = strlen(buf);\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\treturn index;\n}\n\nstatic struct bin_attribute sysfs_drvr_stat_data_attr = {\n\t.attr = {\n\t\t.name = \"lpfc_drvr_stat_data\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = LPFC_MAX_TARGET * MAX_STAT_DATA_SIZE_PER_TARGET,\n\t.read = sysfs_drvr_stat_data_read,\n\t.write = NULL,\n};\n\n/*\n# lpfc_link_speed: Link speed selection for initializing the Fibre Channel\n# connection.\n# Value range is [0,16]. Default value is 0.\n*/\n/**\n * lpfc_link_speed_set - Set the adapters link speed\n * @dev: Pointer to class device.\n * @attr: Unused.\n * @buf: Data buffer.\n * @count: Size of the data buffer.\n *\n * Description:\n * If val is in a valid range then set the adapter's link speed field and\n * issue a lip; if the lip fails reset the link speed to the old value.\n *\n * Notes:\n * If the value is not in range log a kernel error message and return an error.\n *\n * Returns:\n * zero if val is in range and lip okay.\n * non-zero return value from lpfc_issue_lip()\n * -EINVAL val out of range\n **/\nstatic ssize_t\nlpfc_link_speed_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint val = LPFC_USER_LINK_SPEED_AUTO;\n\tint nolip = 0;\n\tconst char *val_buf = buf;\n\tint err;\n\tuint32_t prev_val, if_type;\n\n\tif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\n\tif (if_type >= LPFC_SLI_INTF_IF_TYPE_2 &&\n\t    phba->hba_flag & HBA_FORCED_LINK_SPEED)\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, \"nolip \", strlen(\"nolip \"))) {\n\t\tnolip = 1;\n\t\tval_buf = &buf[strlen(\"nolip \")];\n\t}\n\n\tif (!isdigit(val_buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(val_buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\"3055 lpfc_link_speed changed from %d to %d %s\\n\",\n\t\tphba->cfg_link_speed, val, nolip ? \"(nolip)\" : \"(lip)\");\n\n\tif (((val == LPFC_USER_LINK_SPEED_1G) && !(phba->lmt & LMT_1Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_2G) && !(phba->lmt & LMT_2Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_4G) && !(phba->lmt & LMT_4Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_8G) && !(phba->lmt & LMT_8Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_10G) && !(phba->lmt & LMT_10Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_16G) && !(phba->lmt & LMT_16Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_32G) && !(phba->lmt & LMT_32Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_64G) && !(phba->lmt & LMT_64Gb))) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"2879 lpfc_link_speed attribute cannot be set \"\n\t\t\t\t\"to %d. Speed is not supported by this port.\\n\",\n\t\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\tif (val >= LPFC_USER_LINK_SPEED_16G &&\n\t    phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3112 lpfc_link_speed attribute cannot be set \"\n\t\t\t\t\"to %d. Speed is not supported in loop mode.\\n\",\n\t\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (val) {\n\tcase LPFC_USER_LINK_SPEED_AUTO:\n\tcase LPFC_USER_LINK_SPEED_1G:\n\tcase LPFC_USER_LINK_SPEED_2G:\n\tcase LPFC_USER_LINK_SPEED_4G:\n\tcase LPFC_USER_LINK_SPEED_8G:\n\tcase LPFC_USER_LINK_SPEED_16G:\n\tcase LPFC_USER_LINK_SPEED_32G:\n\tcase LPFC_USER_LINK_SPEED_64G:\n\t\tprev_val = phba->cfg_link_speed;\n\t\tphba->cfg_link_speed = val;\n\t\tif (nolip)\n\t\t\treturn strlen(buf);\n\n\t\terr = lpfc_issue_lip(lpfc_shost_from_vport(phba->pport));\n\t\tif (err) {\n\t\t\tphba->cfg_link_speed = prev_val;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn strlen(buf);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0469 lpfc_link_speed attribute cannot be set to %d, \"\n\t\t\t\"allowed values are [%s]\\n\",\n\t\t\tval, LPFC_LINK_SPEED_STRING);\n\treturn -EINVAL;\n\n}\n\nstatic int lpfc_link_speed = 0;\nmodule_param(lpfc_link_speed, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_link_speed, \"Select link speed\");\nlpfc_param_show(link_speed)\n\n/**\n * lpfc_link_speed_init - Set the adapters link speed\n * @phba: lpfc_hba pointer.\n * @val: link speed value.\n *\n * Description:\n * If val is in a valid range then set the adapter's link speed field.\n *\n * Notes:\n * If the value is not in range log a kernel error message, clear the link\n * speed and return an error.\n *\n * Returns:\n * zero if val saved.\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_link_speed_init(struct lpfc_hba *phba, int val)\n{\n\tif (val >= LPFC_USER_LINK_SPEED_16G && phba->cfg_topology == 4) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"3111 lpfc_link_speed of %d cannot \"\n\t\t\t\"support loop mode, setting topology to default.\\n\",\n\t\t\t val);\n\t\tphba->cfg_topology = 0;\n\t}\n\n\tswitch (val) {\n\tcase LPFC_USER_LINK_SPEED_AUTO:\n\tcase LPFC_USER_LINK_SPEED_1G:\n\tcase LPFC_USER_LINK_SPEED_2G:\n\tcase LPFC_USER_LINK_SPEED_4G:\n\tcase LPFC_USER_LINK_SPEED_8G:\n\tcase LPFC_USER_LINK_SPEED_16G:\n\tcase LPFC_USER_LINK_SPEED_32G:\n\tcase LPFC_USER_LINK_SPEED_64G:\n\t\tphba->cfg_link_speed = val;\n\t\treturn 0;\n\tdefault:\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0405 lpfc_link_speed attribute cannot \"\n\t\t\t\t\"be set to %d, allowed values are \"\n\t\t\t\t\"[\"LPFC_LINK_SPEED_STRING\"]\\n\", val);\n\t\tphba->cfg_link_speed = LPFC_USER_LINK_SPEED_AUTO;\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic DEVICE_ATTR_RW(lpfc_link_speed);\n\n/*\n# lpfc_aer_support: Support PCIe device Advanced Error Reporting (AER)\n#       0  = aer disabled or not supported\n#       1  = aer supported and enabled (default)\n# Value range is [0,1]. Default value is 1.\n*/\nLPFC_ATTR(aer_support, 1, 0, 1,\n\t\"Enable PCIe device AER support\");\nlpfc_param_show(aer_support)\n\n/**\n * lpfc_aer_support_store - Set the adapter for aer support\n *\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing enable or disable aer flag.\n * @count: unused variable.\n *\n * Description:\n * If the val is 1 and currently the device's AER capability was not\n * enabled, invoke the kernel's enable AER helper routine, trying to\n * enable the device's AER capability. If the helper routine enabling\n * AER returns success, update the device's cfg_aer_support flag to\n * indicate AER is supported by the device; otherwise, if the device\n * AER capability is already enabled to support AER, then do nothing.\n *\n * If the val is 0 and currently the device's AER support was enabled,\n * invoke the kernel's disable AER helper routine. After that, update\n * the device's cfg_aer_support flag to indicate AER is not supported\n * by the device; otherwise, if the device AER capability is already\n * disabled from supporting AER, then do nothing.\n *\n * Returns:\n * length of the buf on success if val is in range the intended mode\n * is supported.\n * -EINVAL if val out of range or intended mode is not supported.\n **/\nstatic ssize_t\nlpfc_aer_support_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tint val = 0, rc = -EINVAL;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase 0:\n\t\tif (phba->hba_flag & HBA_AER_ENABLED) {\n\t\t\trc = pci_disable_pcie_error_reporting(phba->pcidev);\n\t\t\tif (!rc) {\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tphba->hba_flag &= ~HBA_AER_ENABLED;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\tphba->cfg_aer_support = 0;\n\t\t\t\trc = strlen(buf);\n\t\t\t} else\n\t\t\t\trc = -EPERM;\n\t\t} else {\n\t\t\tphba->cfg_aer_support = 0;\n\t\t\trc = strlen(buf);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif (!(phba->hba_flag & HBA_AER_ENABLED)) {\n\t\t\trc = pci_enable_pcie_error_reporting(phba->pcidev);\n\t\t\tif (!rc) {\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tphba->hba_flag |= HBA_AER_ENABLED;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\tphba->cfg_aer_support = 1;\n\t\t\t\trc = strlen(buf);\n\t\t\t} else\n\t\t\t\t rc = -EPERM;\n\t\t} else {\n\t\t\tphba->cfg_aer_support = 1;\n\t\t\trc = strlen(buf);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_aer_support);\n\n/**\n * lpfc_aer_cleanup_state - Clean up aer state to the aer enabled device\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing flag 1 for aer cleanup state.\n * @count: unused variable.\n *\n * Description:\n * If the @buf contains 1 and the device currently has the AER support\n * enabled, then invokes the kernel AER helper routine\n * pci_aer_clear_nonfatal_status() to clean up the uncorrectable\n * error status register.\n *\n * Notes:\n *\n * Returns:\n * -EINVAL if the buf does not contain the 1 or the device is not currently\n * enabled with the AER support.\n **/\nstatic ssize_t\nlpfc_aer_cleanup_state(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint val, rc = -1;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tif (phba->hba_flag & HBA_AER_ENABLED)\n\t\trc = pci_aer_clear_nonfatal_status(phba->pcidev);\n\n\tif (rc == 0)\n\t\treturn strlen(buf);\n\telse\n\t\treturn -EPERM;\n}\n\nstatic DEVICE_ATTR(lpfc_aer_state_cleanup, S_IWUSR, NULL,\n\t\t   lpfc_aer_cleanup_state);\n\n/**\n * lpfc_sriov_nr_virtfn_store - Enable the adapter for sr-iov virtual functions\n *\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing the string the number of vfs to be enabled.\n * @count: unused variable.\n *\n * Description:\n * When this api is called either through user sysfs, the driver shall\n * try to enable or disable SR-IOV virtual functions according to the\n * following:\n *\n * If zero virtual function has been enabled to the physical function,\n * the driver shall invoke the pci enable virtual function api trying\n * to enable the virtual functions. If the nr_vfn provided is greater\n * than the maximum supported, the maximum virtual function number will\n * be used for invoking the api; otherwise, the nr_vfn provided shall\n * be used for invoking the api. If the api call returned success, the\n * actual number of virtual functions enabled will be set to the driver\n * cfg_sriov_nr_virtfn; otherwise, -EINVAL shall be returned and driver\n * cfg_sriov_nr_virtfn remains zero.\n *\n * If none-zero virtual functions have already been enabled to the\n * physical function, as reflected by the driver's cfg_sriov_nr_virtfn,\n * -EINVAL will be returned and the driver does nothing;\n *\n * If the nr_vfn provided is zero and none-zero virtual functions have\n * been enabled, as indicated by the driver's cfg_sriov_nr_virtfn, the\n * disabling virtual function api shall be invoded to disable all the\n * virtual functions and driver's cfg_sriov_nr_virtfn shall be set to\n * zero. Otherwise, if zero virtual function has been enabled, do\n * nothing.\n *\n * Returns:\n * length of the buf on success if val is in range the intended mode\n * is supported.\n * -EINVAL if val out of range or intended mode is not supported.\n **/\nstatic ssize_t\nlpfc_sriov_nr_virtfn_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct pci_dev *pdev = phba->pcidev;\n\tint val = 0, rc = -EINVAL;\n\n\t/* Sanity check on user data */\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\t/* Request disabling virtual functions */\n\tif (val == 0) {\n\t\tif (phba->cfg_sriov_nr_virtfn > 0) {\n\t\t\tpci_disable_sriov(pdev);\n\t\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t\t}\n\t\treturn strlen(buf);\n\t}\n\n\t/* Request enabling virtual functions */\n\tif (phba->cfg_sriov_nr_virtfn > 0) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3018 There are %d virtual functions \"\n\t\t\t\t\"enabled on physical function.\\n\",\n\t\t\t\tphba->cfg_sriov_nr_virtfn);\n\t\treturn -EEXIST;\n\t}\n\n\tif (val <= LPFC_MAX_VFN_PER_PFN)\n\t\tphba->cfg_sriov_nr_virtfn = val;\n\telse {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3019 Enabling %d virtual functions is not \"\n\t\t\t\t\"allowed.\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\trc = lpfc_sli_probe_sriov_nr_virtfn(phba, phba->cfg_sriov_nr_virtfn);\n\tif (rc) {\n\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t\trc = -EPERM;\n\t} else\n\t\trc = strlen(buf);\n\n\treturn rc;\n}\n\nLPFC_ATTR(sriov_nr_virtfn, LPFC_DEF_VFN_PER_PFN, 0, LPFC_MAX_VFN_PER_PFN,\n\t\"Enable PCIe device SR-IOV virtual fn\");\n\nlpfc_param_show(sriov_nr_virtfn)\nstatic DEVICE_ATTR_RW(lpfc_sriov_nr_virtfn);\n\n/**\n * lpfc_request_firmware_store - Request for Linux generic firmware upgrade\n *\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: containing the string the number of vfs to be enabled.\n * @count: unused variable.\n *\n * Description:\n *\n * Returns:\n * length of the buf on success if val is in range the intended mode\n * is supported.\n * -EINVAL if val out of range or intended mode is not supported.\n **/\nstatic ssize_t\nlpfc_request_firmware_upgrade_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tint val = 0, rc;\n\n\t/* Sanity check on user data */\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\trc = lpfc_sli4_request_firmware_update(phba, RUN_FW_UPGRADE);\n\tif (rc)\n\t\trc = -EPERM;\n\telse\n\t\trc = strlen(buf);\n\treturn rc;\n}\n\nstatic int lpfc_req_fw_upgrade;\nmodule_param(lpfc_req_fw_upgrade, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(lpfc_req_fw_upgrade, \"Enable Linux generic firmware upgrade\");\nlpfc_param_show(request_firmware_upgrade)\n\n/**\n * lpfc_request_firmware_upgrade_init - Enable initial linux generic fw upgrade\n * @phba: lpfc_hba pointer.\n * @val: 0 or 1.\n *\n * Description:\n * Set the initial Linux generic firmware upgrade enable or disable flag.\n *\n * Returns:\n * zero if val saved.\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_request_firmware_upgrade_init(struct lpfc_hba *phba, int val)\n{\n\tif (val >= 0 && val <= 1) {\n\t\tphba->cfg_request_firmware_upgrade = val;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR(lpfc_req_fw_upgrade, S_IRUGO | S_IWUSR,\n\t\t   lpfc_request_firmware_upgrade_show,\n\t\t   lpfc_request_firmware_upgrade_store);\n\n/**\n * lpfc_force_rscn_store\n *\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: unused string\n * @count: unused variable.\n *\n * Description:\n * Force the switch to send a RSCN to all other NPorts in our zone\n * If we are direct connect pt2pt, build the RSCN command ourself\n * and send to the other NPort. Not supported for private loop.\n *\n * Returns:\n * 0      - on success\n * -EIO   - if command is not sent\n **/\nstatic ssize_t\nlpfc_force_rscn_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tint i;\n\n\ti = lpfc_issue_els_rscn(vport, 0);\n\tif (i)\n\t\treturn -EIO;\n\treturn strlen(buf);\n}\n\n/*\n * lpfc_force_rscn: Force an RSCN to be sent to all remote NPorts\n * connected to  the HBA.\n *\n * Value range is any ascii value\n */\nstatic int lpfc_force_rscn;\nmodule_param(lpfc_force_rscn, int, 0644);\nMODULE_PARM_DESC(lpfc_force_rscn,\n\t\t \"Force an RSCN to be sent to all remote NPorts\");\nlpfc_param_show(force_rscn)\n\n/**\n * lpfc_force_rscn_init - Force an RSCN to be sent to all remote NPorts\n * @phba: lpfc_hba pointer.\n * @val: unused value.\n *\n * Returns:\n * zero if val saved.\n **/\nstatic int\nlpfc_force_rscn_init(struct lpfc_hba *phba, int val)\n{\n\treturn 0;\n}\nstatic DEVICE_ATTR_RW(lpfc_force_rscn);\n\n/**\n * lpfc_fcp_imax_store\n *\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: string with the number of fast-path FCP interrupts per second.\n * @count: unused variable.\n *\n * Description:\n * If val is in a valid range [636,651042], then set the adapter's\n * maximum number of fast-path FCP interrupts per second.\n *\n * Returns:\n * length of the buf on success if val is in range the intended mode\n * is supported.\n * -EINVAL if val out of range or intended mode is not supported.\n **/\nstatic ssize_t\nlpfc_fcp_imax_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_eq_intr_info *eqi;\n\tuint32_t usdelay;\n\tint val = 0, i;\n\n\t/* fcp_imax is only valid for SLI4 */\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn -EINVAL;\n\n\t/* Sanity check on user data */\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Value range for the HBA is [5000,5000000]\n\t * The value for each EQ depends on how many EQs are configured.\n\t * Allow value == 0\n\t */\n\tif (val && (val < LPFC_MIN_IMAX || val > LPFC_MAX_IMAX))\n\t\treturn -EINVAL;\n\n\tphba->cfg_auto_imax = (val) ? 0 : 1;\n\tif (phba->cfg_fcp_imax && !val) {\n\t\tqueue_delayed_work(phba->wq, &phba->eq_delay_work,\n\t\t\t\t   msecs_to_jiffies(LPFC_EQ_DELAY_MSECS));\n\n\t\tfor_each_present_cpu(i) {\n\t\t\teqi = per_cpu_ptr(phba->sli4_hba.eq_info, i);\n\t\t\teqi->icnt = 0;\n\t\t}\n\t}\n\n\tphba->cfg_fcp_imax = (uint32_t)val;\n\n\tif (phba->cfg_fcp_imax)\n\t\tusdelay = LPFC_SEC_TO_USEC / phba->cfg_fcp_imax;\n\telse\n\t\tusdelay = 0;\n\n\tfor (i = 0; i < phba->cfg_irq_chann; i += LPFC_MAX_EQ_DELAY_EQID_CNT)\n\t\tlpfc_modify_hba_eq_delay(phba, i, LPFC_MAX_EQ_DELAY_EQID_CNT,\n\t\t\t\t\t usdelay);\n\n\treturn strlen(buf);\n}\n\n/*\n# lpfc_fcp_imax: The maximum number of fast-path FCP interrupts per second\n# for the HBA.\n#\n# Value range is [5,000 to 5,000,000]. Default value is 50,000.\n*/\nstatic int lpfc_fcp_imax = LPFC_DEF_IMAX;\nmodule_param(lpfc_fcp_imax, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(lpfc_fcp_imax,\n\t    \"Set the maximum number of FCP interrupts per second per HBA\");\nlpfc_param_show(fcp_imax)\n\n/**\n * lpfc_fcp_imax_init - Set the initial sr-iov virtual function enable\n * @phba: lpfc_hba pointer.\n * @val: link speed value.\n *\n * Description:\n * If val is in a valid range [636,651042], then initialize the adapter's\n * maximum number of fast-path FCP interrupts per second.\n *\n * Returns:\n * zero if val saved.\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_fcp_imax_init(struct lpfc_hba *phba, int val)\n{\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tphba->cfg_fcp_imax = 0;\n\t\treturn 0;\n\t}\n\n\tif ((val >= LPFC_MIN_IMAX && val <= LPFC_MAX_IMAX) ||\n\t    (val == 0)) {\n\t\tphba->cfg_fcp_imax = val;\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"3016 lpfc_fcp_imax: %d out of range, using default\\n\",\n\t\t\tval);\n\tphba->cfg_fcp_imax = LPFC_DEF_IMAX;\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_fcp_imax);\n\n/**\n * lpfc_cq_max_proc_limit_store\n *\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: string with the cq max processing limit of cqes\n * @count: unused variable.\n *\n * Description:\n * If val is in a valid range, then set value on each cq\n *\n * Returns:\n * The length of the buf: if successful\n * -ERANGE: if val is not in the valid range\n * -EINVAL: if bad value format or intended mode is not supported.\n **/\nstatic ssize_t\nlpfc_cq_max_proc_limit_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_queue *eq, *cq;\n\tunsigned long val;\n\tint i;\n\n\t/* cq_max_proc_limit is only valid for SLI4 */\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn -EINVAL;\n\n\t/* Sanity check on user data */\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val < LPFC_CQ_MIN_PROC_LIMIT || val > LPFC_CQ_MAX_PROC_LIMIT)\n\t\treturn -ERANGE;\n\n\tphba->cfg_cq_max_proc_limit = (uint32_t)val;\n\n\t/* set the values on the cq's */\n\tfor (i = 0; i < phba->cfg_irq_chann; i++) {\n\t\t/* Get the EQ corresponding to the IRQ vector */\n\t\teq = phba->sli4_hba.hba_eq_hdl[i].eq;\n\t\tif (!eq)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(cq, &eq->child_list, list)\n\t\t\tcq->max_proc_limit = min(phba->cfg_cq_max_proc_limit,\n\t\t\t\t\t\t cq->entry_count);\n\t}\n\n\treturn strlen(buf);\n}\n\n/*\n * lpfc_cq_max_proc_limit: The maximum number CQE entries processed in an\n *   itteration of CQ processing.\n */\nstatic int lpfc_cq_max_proc_limit = LPFC_CQ_DEF_MAX_PROC_LIMIT;\nmodule_param(lpfc_cq_max_proc_limit, int, 0644);\nMODULE_PARM_DESC(lpfc_cq_max_proc_limit,\n\t    \"Set the maximum number CQEs processed in an iteration of \"\n\t    \"CQ processing\");\nlpfc_param_show(cq_max_proc_limit)\n\n/*\n * lpfc_cq_poll_threshold: Set the threshold of CQE completions in a\n *   single handler call which should request a polled completion rather\n *   than re-enabling interrupts.\n */\nLPFC_ATTR_RW(cq_poll_threshold, LPFC_CQ_DEF_THRESHOLD_TO_POLL,\n\t     LPFC_CQ_MIN_THRESHOLD_TO_POLL,\n\t     LPFC_CQ_MAX_THRESHOLD_TO_POLL,\n\t     \"CQE Processing Threshold to enable Polling\");\n\n/**\n * lpfc_cq_max_proc_limit_init - Set the initial cq max_proc_limit\n * @phba: lpfc_hba pointer.\n * @val: entry limit\n *\n * Description:\n * If val is in a valid range, then initialize the adapter's maximum\n * value.\n *\n * Returns:\n *  Always returns 0 for success, even if value not always set to\n *  requested value. If value out of range or not supported, will fall\n *  back to default.\n **/\nstatic int\nlpfc_cq_max_proc_limit_init(struct lpfc_hba *phba, int val)\n{\n\tphba->cfg_cq_max_proc_limit = LPFC_CQ_DEF_MAX_PROC_LIMIT;\n\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn 0;\n\n\tif (val >= LPFC_CQ_MIN_PROC_LIMIT && val <= LPFC_CQ_MAX_PROC_LIMIT) {\n\t\tphba->cfg_cq_max_proc_limit = val;\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0371 \"LPFC_DRIVER_NAME\"_cq_max_proc_limit: \"\n\t\t\t\"%d out of range, using default\\n\",\n\t\t\tphba->cfg_cq_max_proc_limit);\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_cq_max_proc_limit);\n\n/**\n * lpfc_state_show - Display current driver CPU affinity\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains text describing the state of the link.\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_fcp_cpu_map_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_vector_map_info *cpup;\n\tint  len = 0;\n\n\tif ((phba->sli_rev != LPFC_SLI_REV4) ||\n\t    (phba->intr_type != MSIX))\n\t\treturn len;\n\n\tswitch (phba->cfg_fcp_cpu_map) {\n\tcase 0:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"fcp_cpu_map: No mapping (%d)\\n\",\n\t\t\t\tphba->cfg_fcp_cpu_map);\n\t\treturn len;\n\tcase 1:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"fcp_cpu_map: HBA centric mapping (%d): \"\n\t\t\t\t\"%d of %d CPUs online from %d possible CPUs\\n\",\n\t\t\t\tphba->cfg_fcp_cpu_map, num_online_cpus(),\n\t\t\t\tnum_present_cpus(),\n\t\t\t\tphba->sli4_hba.num_possible_cpu);\n\t\tbreak;\n\t}\n\n\twhile (phba->sli4_hba.curr_disp_cpu <\n\t       phba->sli4_hba.num_possible_cpu) {\n\t\tcpup = &phba->sli4_hba.cpu_map[phba->sli4_hba.curr_disp_cpu];\n\n\t\tif (!cpu_present(phba->sli4_hba.curr_disp_cpu))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d not present\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu);\n\t\telse if (cpup->eq == LPFC_VECTOR_MAP_EMPTY) {\n\t\t\tif (cpup->hdwq == LPFC_VECTOR_MAP_EMPTY)\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d hdwq None \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->phys_id, cpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN));\n\t\t\telse\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d EQ None hdwq %04d \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->hdwq, cpup->phys_id,\n\t\t\t\t\tcpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN));\n\t\t} else {\n\t\t\tif (cpup->hdwq == LPFC_VECTOR_MAP_EMPTY)\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d hdwq None \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d IRQ %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->phys_id,\n\t\t\t\t\tcpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN),\n\t\t\t\t\tlpfc_get_irq(cpup->eq));\n\t\t\telse\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d EQ %04d hdwq %04d \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d IRQ %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->eq, cpup->hdwq, cpup->phys_id,\n\t\t\t\t\tcpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN),\n\t\t\t\t\tlpfc_get_irq(cpup->eq));\n\t\t}\n\n\t\tphba->sli4_hba.curr_disp_cpu++;\n\n\t\t/* display max number of CPUs keeping some margin */\n\t\tif (phba->sli4_hba.curr_disp_cpu <\n\t\t\t\tphba->sli4_hba.num_possible_cpu &&\n\t\t\t\t(len >= (PAGE_SIZE - 64))) {\n\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\tPAGE_SIZE - len, \"more...\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phba->sli4_hba.curr_disp_cpu == phba->sli4_hba.num_possible_cpu)\n\t\tphba->sli4_hba.curr_disp_cpu = 0;\n\n\treturn len;\n}\n\n/**\n * lpfc_fcp_cpu_map_store - Change CPU affinity of driver vectors\n * @dev: class device that is converted into a Scsi_host.\n * @attr: device attribute, not used.\n * @buf: one or more lpfc_polling_flags values.\n * @count: not used.\n *\n * Returns:\n * -EINVAL  - Not implemented yet.\n **/\nstatic ssize_t\nlpfc_fcp_cpu_map_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\treturn -EINVAL;\n}\n\n/*\n# lpfc_fcp_cpu_map: Defines how to map CPUs to IRQ vectors\n# for the HBA.\n#\n# Value range is [0 to 1]. Default value is LPFC_HBA_CPU_MAP (1).\n#\t0 - Do not affinitze IRQ vectors\n#\t1 - Affintize HBA vectors with respect to each HBA\n#\t    (start with CPU0 for each HBA)\n# This also defines how Hardware Queues are mapped to specific CPUs.\n*/\nstatic int lpfc_fcp_cpu_map = LPFC_HBA_CPU_MAP;\nmodule_param(lpfc_fcp_cpu_map, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(lpfc_fcp_cpu_map,\n\t\t \"Defines how to map CPUs to IRQ vectors per HBA\");\n\n/**\n * lpfc_fcp_cpu_map_init - Set the initial sr-iov virtual function enable\n * @phba: lpfc_hba pointer.\n * @val: link speed value.\n *\n * Description:\n * If val is in a valid range [0-2], then affinitze the adapter's\n * MSIX vectors.\n *\n * Returns:\n * zero if val saved.\n * -EINVAL val out of range\n **/\nstatic int\nlpfc_fcp_cpu_map_init(struct lpfc_hba *phba, int val)\n{\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tphba->cfg_fcp_cpu_map = 0;\n\t\treturn 0;\n\t}\n\n\tif (val >= LPFC_MIN_CPU_MAP && val <= LPFC_MAX_CPU_MAP) {\n\t\tphba->cfg_fcp_cpu_map = val;\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"3326 lpfc_fcp_cpu_map: %d out of range, using \"\n\t\t\t\"default\\n\", val);\n\tphba->cfg_fcp_cpu_map = LPFC_HBA_CPU_MAP;\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_fcp_cpu_map);\n\n/*\n# lpfc_fcp_class:  Determines FC class to use for the FCP protocol.\n# Value range is [2,3]. Default value is 3.\n*/\nLPFC_VPORT_ATTR_R(fcp_class, 3, 2, 3,\n\t\t  \"Select Fibre Channel class of service for FCP sequences\");\n\n/*\n# lpfc_use_adisc: Use ADISC for FCP rediscovery instead of PLOGI. Value range\n# is [0,1]. Default value is 0.\n*/\nLPFC_VPORT_ATTR_RW(use_adisc, 0, 0, 1,\n\t\t   \"Use ADISC on rediscovery to authenticate FCP devices\");\n\n/*\n# lpfc_first_burst_size: First burst size to use on the NPorts\n# that support first burst.\n# Value range is [0,65536]. Default value is 0.\n*/\nLPFC_VPORT_ATTR_RW(first_burst_size, 0, 0, 65536,\n\t\t   \"First burst size for Targets that support first burst\");\n\n/*\n* lpfc_nvmet_fb_size: NVME Target mode supported first burst size.\n* When the driver is configured as an NVME target, this value is\n* communicated to the NVME initiator in the PRLI response.  It is\n* used only when the lpfc_nvme_enable_fb and lpfc_nvmet_support\n* parameters are set and the target is sending the PRLI RSP.\n* Parameter supported on physical port only - no NPIV support.\n* Value range is [0,65536]. Default value is 0.\n*/\nLPFC_ATTR_RW(nvmet_fb_size, 0, 0, 65536,\n\t     \"NVME Target mode first burst size in 512B increments.\");\n\n/*\n * lpfc_nvme_enable_fb: Enable NVME first burst on I and T functions.\n * For the Initiator (I), enabling this parameter means that an NVMET\n * PRLI response with FBA enabled and an FB_SIZE set to a nonzero value will be\n * processed by the initiator for subsequent NVME FCP IO.\n * Currently, this feature is not supported on the NVME target\n * Value range is [0,1]. Default value is 0 (disabled).\n */\nLPFC_ATTR_RW(nvme_enable_fb, 0, 0, 1,\n\t     \"Enable First Burst feature for NVME Initiator.\");\n\n/*\n# lpfc_max_scsicmpl_time: Use scsi command completion time to control I/O queue\n# depth. Default value is 0. When the value of this parameter is zero the\n# SCSI command completion time is not used for controlling I/O queue depth. When\n# the parameter is set to a non-zero value, the I/O queue depth is controlled\n# to limit the I/O completion time to the parameter value.\n# The value is set in milliseconds.\n*/\nLPFC_VPORT_ATTR(max_scsicmpl_time, 0, 0, 60000,\n\t\"Use command completion time to control queue depth\");\n\nlpfc_vport_param_show(max_scsicmpl_time);\nstatic int\nlpfc_max_scsicmpl_time_set(struct lpfc_vport *vport, int val)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\n\tif (val == vport->cfg_max_scsicmpl_time)\n\t\treturn 0;\n\tif ((val < 0) || (val > 60000))\n\t\treturn -EINVAL;\n\tvport->cfg_max_scsicmpl_time = val;\n\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_UNUSED_NODE)\n\t\t\tcontinue;\n\t\tndlp->cmd_qdepth = vport->cfg_tgt_queue_depth;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\treturn 0;\n}\nlpfc_vport_param_store(max_scsicmpl_time);\nstatic DEVICE_ATTR_RW(lpfc_max_scsicmpl_time);\n\n/*\n# lpfc_ack0: Use ACK0, instead of ACK1 for class 2 acknowledgement. Value\n# range is [0,1]. Default value is 0.\n*/\nLPFC_ATTR_R(ack0, 0, 0, 1, \"Enable ACK0 support\");\n\n/*\n# lpfc_xri_rebalancing: enable or disable XRI rebalancing feature\n# range is [0,1]. Default value is 1.\n*/\nLPFC_ATTR_R(xri_rebalancing, 1, 0, 1, \"Enable/Disable XRI rebalancing\");\n\n/*\n * lpfc_io_sched: Determine scheduling algrithmn for issuing FCP cmds\n * range is [0,1]. Default value is 0.\n * For [0], FCP commands are issued to Work Queues based on upper layer\n * hardware queue index.\n * For [1], FCP commands are issued to a Work Queue associated with the\n *          current CPU.\n *\n * LPFC_FCP_SCHED_BY_HDWQ == 0\n * LPFC_FCP_SCHED_BY_CPU == 1\n *\n * The driver dynamically sets this to 1 (BY_CPU) if it's able to set up cpu\n * affinity for FCP/NVME I/Os through Work Queues associated with the current\n * CPU. Otherwise, the default 0 (Round Robin) scheduling of FCP/NVME I/Os\n * through WQs will be used.\n */\nLPFC_ATTR_RW(fcp_io_sched, LPFC_FCP_SCHED_BY_CPU,\n\t     LPFC_FCP_SCHED_BY_HDWQ,\n\t     LPFC_FCP_SCHED_BY_CPU,\n\t     \"Determine scheduling algorithm for \"\n\t     \"issuing commands [0] - Hardware Queue, [1] - Current CPU\");\n\n/*\n * lpfc_ns_query: Determine algrithmn for NameServer queries after RSCN\n * range is [0,1]. Default value is 0.\n * For [0], GID_FT is used for NameServer queries after RSCN (default)\n * For [1], GID_PT is used for NameServer queries after RSCN\n *\n */\nLPFC_ATTR_RW(ns_query, LPFC_NS_QUERY_GID_FT,\n\t     LPFC_NS_QUERY_GID_FT, LPFC_NS_QUERY_GID_PT,\n\t     \"Determine algorithm NameServer queries after RSCN \"\n\t     \"[0] - GID_FT, [1] - GID_PT\");\n\n/*\n# lpfc_fcp2_no_tgt_reset: Determine bus reset behavior\n# range is [0,1]. Default value is 0.\n# For [0], bus reset issues target reset to ALL devices\n# For [1], bus reset issues target reset to non-FCP2 devices\n*/\nLPFC_ATTR_RW(fcp2_no_tgt_reset, 0, 0, 1, \"Determine bus reset behavior for \"\n\t     \"FCP2 devices [0] - issue tgt reset, [1] - no tgt reset\");\n\n\n/*\n# lpfc_cr_delay & lpfc_cr_count: Default values for I/O colaesing\n# cr_delay (msec) or cr_count outstanding commands. cr_delay can take\n# value [0,63]. cr_count can take value [1,255]. Default value of cr_delay\n# is 0. Default value of cr_count is 1. The cr_count feature is disabled if\n# cr_delay is set to 0.\n*/\nLPFC_ATTR_RW(cr_delay, 0, 0, 63, \"A count of milliseconds after which an \"\n\t\t\"interrupt response is generated\");\n\nLPFC_ATTR_RW(cr_count, 1, 1, 255, \"A count of I/O completions after which an \"\n\t\t\"interrupt response is generated\");\n\n/*\n# lpfc_multi_ring_support:  Determines how many rings to spread available\n# cmd/rsp IOCB entries across.\n# Value range is [1,2]. Default value is 1.\n*/\nLPFC_ATTR_R(multi_ring_support, 1, 1, 2, \"Determines number of primary \"\n\t\t\"SLI rings to spread IOCB entries across\");\n\n/*\n# lpfc_multi_ring_rctl:  If lpfc_multi_ring_support is enabled, this\n# identifies what rctl value to configure the additional ring for.\n# Value range is [1,0xff]. Default value is 4 (Unsolicated Data).\n*/\nLPFC_ATTR_R(multi_ring_rctl, FC_RCTL_DD_UNSOL_DATA, 1,\n\t     255, \"Identifies RCTL for additional ring configuration\");\n\n/*\n# lpfc_multi_ring_type:  If lpfc_multi_ring_support is enabled, this\n# identifies what type value to configure the additional ring for.\n# Value range is [1,0xff]. Default value is 5 (LLC/SNAP).\n*/\nLPFC_ATTR_R(multi_ring_type, FC_TYPE_IP, 1,\n\t     255, \"Identifies TYPE for additional ring configuration\");\n\n/*\n# lpfc_enable_SmartSAN: Sets up FDMI support for SmartSAN\n#       0  = SmartSAN functionality disabled (default)\n#       1  = SmartSAN functionality enabled\n# This parameter will override the value of lpfc_fdmi_on module parameter.\n# Value range is [0,1]. Default value is 0.\n*/\nLPFC_ATTR_R(enable_SmartSAN, 0, 0, 1, \"Enable SmartSAN functionality\");\n\n/*\n# lpfc_fdmi_on: Controls FDMI support.\n#       0       No FDMI support\n#       1       Traditional FDMI support (default)\n# Traditional FDMI support means the driver will assume FDMI-2 support;\n# however, if that fails, it will fallback to FDMI-1.\n# If lpfc_enable_SmartSAN is set to 1, the driver ignores lpfc_fdmi_on.\n# If lpfc_enable_SmartSAN is set 0, the driver uses the current value of\n# lpfc_fdmi_on.\n# Value range [0,1]. Default value is 1.\n*/\nLPFC_ATTR_R(fdmi_on, 1, 0, 1, \"Enable FDMI support\");\n\n/*\n# Specifies the maximum number of ELS cmds we can have outstanding (for\n# discovery). Value range is [1,64]. Default value = 32.\n*/\nLPFC_VPORT_ATTR(discovery_threads, 32, 1, 64, \"Maximum number of ELS commands \"\n\t\t \"during discovery\");\n\n/*\n# lpfc_max_luns: maximum allowed LUN ID. This is the highest LUN ID that\n#    will be scanned by the SCSI midlayer when sequential scanning is\n#    used; and is also the highest LUN ID allowed when the SCSI midlayer\n#    parses REPORT_LUN responses. The lpfc driver has no LUN count or\n#    LUN ID limit, but the SCSI midlayer requires this field for the uses\n#    above. The lpfc driver limits the default value to 255 for two reasons.\n#    As it bounds the sequential scan loop, scanning for thousands of luns\n#    on a target can take minutes of wall clock time.  Additionally,\n#    there are FC targets, such as JBODs, that only recognize 8-bits of\n#    LUN ID. When they receive a value greater than 8 bits, they chop off\n#    the high order bits. In other words, they see LUN IDs 0, 256, 512,\n#    and so on all as LUN ID 0. This causes the linux kernel, which sees\n#    valid responses at each of the LUN IDs, to believe there are multiple\n#    devices present, when in fact, there is only 1.\n#    A customer that is aware of their target behaviors, and the results as\n#    indicated above, is welcome to increase the lpfc_max_luns value.\n#    As mentioned, this value is not used by the lpfc driver, only the\n#    SCSI midlayer.\n# Value range is [0,65535]. Default value is 255.\n# NOTE: The SCSI layer might probe all allowed LUN on some old targets.\n*/\nLPFC_VPORT_ULL_ATTR_R(max_luns, 255, 0, 65535, \"Maximum allowed LUN ID\");\n\n/*\n# lpfc_poll_tmo: .Milliseconds driver will wait between polling FCP ring.\n# Value range is [1,255], default value is 10.\n*/\nLPFC_ATTR_RW(poll_tmo, 10, 1, 255,\n\t     \"Milliseconds driver will wait between polling FCP ring\");\n\n/*\n# lpfc_task_mgmt_tmo: Maximum time to wait for task management commands\n# to complete in seconds. Value range is [5,180], default value is 60.\n*/\nLPFC_ATTR_RW(task_mgmt_tmo, 60, 5, 180,\n\t     \"Maximum time to wait for task management commands to complete\");\n/*\n# lpfc_use_msi: Use MSI (Message Signaled Interrupts) in systems that\n#\t\tsupport this feature\n#       0  = MSI disabled\n#       1  = MSI enabled\n#       2  = MSI-X enabled (default)\n# Value range is [0,2]. Default value is 2.\n*/\nLPFC_ATTR_R(use_msi, 2, 0, 2, \"Use Message Signaled Interrupts (1) or \"\n\t    \"MSI-X (2), if possible\");\n\n/*\n * lpfc_nvme_oas: Use the oas bit when sending NVME/NVMET IOs\n *\n *      0  = NVME OAS disabled\n *      1  = NVME OAS enabled\n *\n * Value range is [0,1]. Default value is 0.\n */\nLPFC_ATTR_RW(nvme_oas, 0, 0, 1,\n\t     \"Use OAS bit on NVME IOs\");\n\n/*\n * lpfc_nvme_embed_cmd: Use the oas bit when sending NVME/NVMET IOs\n *\n *      0  = Put NVME Command in SGL\n *      1  = Embed NVME Command in WQE (unless G7)\n *      2 =  Embed NVME Command in WQE (force)\n *\n * Value range is [0,2]. Default value is 1.\n */\nLPFC_ATTR_RW(nvme_embed_cmd, 1, 0, 2,\n\t     \"Embed NVME Command in WQE\");\n\n/*\n * lpfc_fcp_mq_threshold: Set the maximum number of Hardware Queues\n * the driver will advertise it supports to the SCSI layer.\n *\n *      0    = Set nr_hw_queues by the number of CPUs or HW queues.\n *      1,256 = Manually specify nr_hw_queue value to be advertised,\n *\n * Value range is [0,256]. Default value is 8.\n */\nLPFC_ATTR_R(fcp_mq_threshold, LPFC_FCP_MQ_THRESHOLD_DEF,\n\t    LPFC_FCP_MQ_THRESHOLD_MIN, LPFC_FCP_MQ_THRESHOLD_MAX,\n\t    \"Set the number of SCSI Queues advertised\");\n\n/*\n * lpfc_hdw_queue: Set the number of Hardware Queues the driver\n * will advertise it supports to the NVME and  SCSI layers. This also\n * will map to the number of CQ/WQ pairs the driver will create.\n *\n * The NVME Layer will try to create this many, plus 1 administrative\n * hardware queue. The administrative queue will always map to WQ 0\n * A hardware IO queue maps (qidx) to a specific driver CQ/WQ.\n *\n *      0    = Configure the number of hdw queues to the number of active CPUs.\n *      1,256 = Manually specify how many hdw queues to use.\n *\n * Value range is [0,256]. Default value is 0.\n */\nLPFC_ATTR_R(hdw_queue,\n\t    LPFC_HBA_HDWQ_DEF,\n\t    LPFC_HBA_HDWQ_MIN, LPFC_HBA_HDWQ_MAX,\n\t    \"Set the number of I/O Hardware Queues\");\n\n#if IS_ENABLED(CONFIG_X86)\n/**\n * lpfc_cpumask_irq_mode_init - initalizes cpumask of phba based on\n *\t\t\t\tirq_chann_mode\n * @phba: Pointer to HBA context object.\n **/\nstatic void\nlpfc_cpumask_irq_mode_init(struct lpfc_hba *phba)\n{\n\tunsigned int cpu, first_cpu, numa_node = NUMA_NO_NODE;\n\tconst struct cpumask *sibling_mask;\n\tstruct cpumask *aff_mask = &phba->sli4_hba.irq_aff_mask;\n\n\tcpumask_clear(aff_mask);\n\n\tif (phba->irq_chann_mode == NUMA_MODE) {\n\t\t/* Check if we're a NUMA architecture */\n\t\tnuma_node = dev_to_node(&phba->pcidev->dev);\n\t\tif (numa_node == NUMA_NO_NODE) {\n\t\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tswitch (phba->irq_chann_mode) {\n\t\tcase NUMA_MODE:\n\t\t\tif (cpu_to_node(cpu) == numa_node)\n\t\t\t\tcpumask_set_cpu(cpu, aff_mask);\n\t\t\tbreak;\n\t\tcase NHT_MODE:\n\t\t\tsibling_mask = topology_sibling_cpumask(cpu);\n\t\t\tfirst_cpu = cpumask_first(sibling_mask);\n\t\t\tif (first_cpu < nr_cpu_ids)\n\t\t\t\tcpumask_set_cpu(first_cpu, aff_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n#endif\n\nstatic void\nlpfc_assign_default_irq_chann(struct lpfc_hba *phba)\n{\n#if IS_ENABLED(CONFIG_X86)\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_AMD:\n\t\t/* If AMD architecture, then default is NUMA_MODE */\n\t\tphba->irq_chann_mode = NUMA_MODE;\n\t\tbreak;\n\tcase X86_VENDOR_INTEL:\n\t\t/* If Intel architecture, then default is no hyperthread mode */\n\t\tphba->irq_chann_mode = NHT_MODE;\n\t\tbreak;\n\tdefault:\n\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\tbreak;\n\t}\n\tlpfc_cpumask_irq_mode_init(phba);\n#else\n\tphba->irq_chann_mode = NORMAL_MODE;\n#endif\n}\n\n/*\n * lpfc_irq_chann: Set the number of IRQ vectors that are available\n * for Hardware Queues to utilize.  This also will map to the number\n * of EQ / MSI-X vectors the driver will create. This should never be\n * more than the number of Hardware Queues\n *\n *\t0\t\t= Configure number of IRQ Channels to:\n *\t\t\t  if AMD architecture, number of CPUs on HBA's NUMA node\n *\t\t\t  if Intel architecture, number of physical CPUs.\n *\t\t\t  otherwise, number of active CPUs.\n *\t[1,256]\t\t= Manually specify how many IRQ Channels to use.\n *\n * Value range is [0,256]. Default value is [0].\n */\nstatic uint lpfc_irq_chann = LPFC_IRQ_CHANN_DEF;\nmodule_param(lpfc_irq_chann, uint, 0444);\nMODULE_PARM_DESC(lpfc_irq_chann, \"Set number of interrupt vectors to allocate\");\n\n/* lpfc_irq_chann_init - Set the hba irq_chann initial value\n * @phba: lpfc_hba pointer.\n * @val: contains the initial value\n *\n * Description:\n * Validates the initial value is within range and assigns it to the\n * adapter. If not in range, an error message is posted and the\n * default value is assigned.\n *\n * Returns:\n * zero if value is in range and is set\n * -EINVAL if value was out of range\n **/\nstatic int\nlpfc_irq_chann_init(struct lpfc_hba *phba, uint32_t val)\n{\n\tconst struct cpumask *aff_mask;\n\n\tif (phba->cfg_use_msi != 2) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\"8532 use_msi = %u ignoring cfg_irq_numa\\n\",\n\t\t\t\tphba->cfg_use_msi);\n\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\tphba->cfg_irq_chann = LPFC_IRQ_CHANN_DEF;\n\t\treturn 0;\n\t}\n\n\t/* Check if default setting was passed */\n\tif (val == LPFC_IRQ_CHANN_DEF)\n\t\tlpfc_assign_default_irq_chann(phba);\n\n\tif (phba->irq_chann_mode != NORMAL_MODE) {\n\t\taff_mask = &phba->sli4_hba.irq_aff_mask;\n\n\t\tif (cpumask_empty(aff_mask)) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8533 Could not identify CPUS for \"\n\t\t\t\t\t\"mode %d, ignoring\\n\",\n\t\t\t\t\tphba->irq_chann_mode);\n\t\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\t\tphba->cfg_irq_chann = LPFC_IRQ_CHANN_DEF;\n\t\t} else {\n\t\t\tphba->cfg_irq_chann = cpumask_weight(aff_mask);\n\n\t\t\t/* If no hyperthread mode, then set hdwq count to\n\t\t\t * aff_mask weight as well\n\t\t\t */\n\t\t\tif (phba->irq_chann_mode == NHT_MODE)\n\t\t\t\tphba->cfg_hdw_queue = phba->cfg_irq_chann;\n\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8543 lpfc_irq_chann set to %u \"\n\t\t\t\t\t\"(mode: %d)\\n\", phba->cfg_irq_chann,\n\t\t\t\t\tphba->irq_chann_mode);\n\t\t}\n\t} else {\n\t\tif (val > LPFC_IRQ_CHANN_MAX) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8545 lpfc_irq_chann attribute cannot \"\n\t\t\t\t\t\"be set to %u, allowed range is \"\n\t\t\t\t\t\"[%u,%u]\\n\",\n\t\t\t\t\tval,\n\t\t\t\t\tLPFC_IRQ_CHANN_MIN,\n\t\t\t\t\tLPFC_IRQ_CHANN_MAX);\n\t\t\tphba->cfg_irq_chann = LPFC_IRQ_CHANN_DEF;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphba->cfg_irq_chann = val;\n\t}\n\n\treturn 0;\n}\n\n/**\n * lpfc_irq_chann_show - Display value of irq_chann\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains a string with the list sizes\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_irq_chann_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", phba->cfg_irq_chann);\n}\n\nstatic DEVICE_ATTR_RO(lpfc_irq_chann);\n\n/*\n# lpfc_enable_hba_reset: Allow or prevent HBA resets to the hardware.\n#       0  = HBA resets disabled\n#       1  = HBA resets enabled (default)\n#       2  = HBA reset via PCI bus reset enabled\n# Value range is [0,2]. Default value is 1.\n*/\nLPFC_ATTR_RW(enable_hba_reset, 1, 0, 2, \"Enable HBA resets from the driver.\");\n\n/*\n# lpfc_enable_hba_heartbeat: Disable HBA heartbeat timer..\n#       0  = HBA Heartbeat disabled\n#       1  = HBA Heartbeat enabled (default)\n# Value range is [0,1]. Default value is 1.\n*/\nLPFC_ATTR_R(enable_hba_heartbeat, 0, 0, 1, \"Enable HBA Heartbeat.\");\n\n/*\n# lpfc_EnableXLane: Enable Express Lane Feature\n#      0x0   Express Lane Feature disabled\n#      0x1   Express Lane Feature enabled\n# Value range is [0,1]. Default value is 0.\n*/\nLPFC_ATTR_R(EnableXLane, 0, 0, 1, \"Enable Express Lane Feature.\");\n\n/*\n# lpfc_XLanePriority:  Define CS_CTL priority for Express Lane Feature\n#       0x0 - 0x7f  = CS_CTL field in FC header (high 7 bits)\n# Value range is [0x0,0x7f]. Default value is 0\n*/\nLPFC_ATTR_RW(XLanePriority, 0, 0x0, 0x7f, \"CS_CTL for Express Lane Feature.\");\n\n/*\n# lpfc_enable_bg: Enable BlockGuard (Emulex's Implementation of T10-DIF)\n#       0  = BlockGuard disabled (default)\n#       1  = BlockGuard enabled\n# Value range is [0,1]. Default value is 0.\n*/\nLPFC_ATTR_R(enable_bg, 0, 0, 1, \"Enable BlockGuard Support\");\n\n/*\n# lpfc_prot_mask: i\n#\t- Bit mask of host protection capabilities used to register with the\n#\t  SCSI mid-layer\n# \t- Only meaningful if BG is turned on (lpfc_enable_bg=1).\n#\t- Allows you to ultimately specify which profiles to use\n#\t- Default will result in registering capabilities for all profiles.\n#\t- SHOST_DIF_TYPE1_PROTECTION\t1\n#\t\tHBA supports T10 DIF Type 1: HBA to Target Type 1 Protection\n#\t- SHOST_DIX_TYPE0_PROTECTION\t8\n#\t\tHBA supports DIX Type 0: Host to HBA protection only\n#\t- SHOST_DIX_TYPE1_PROTECTION\t16\n#\t\tHBA supports DIX Type 1: Host to HBA  Type 1 protection\n#\n*/\nLPFC_ATTR(prot_mask,\n\t(SHOST_DIF_TYPE1_PROTECTION |\n\tSHOST_DIX_TYPE0_PROTECTION |\n\tSHOST_DIX_TYPE1_PROTECTION),\n\t0,\n\t(SHOST_DIF_TYPE1_PROTECTION |\n\tSHOST_DIX_TYPE0_PROTECTION |\n\tSHOST_DIX_TYPE1_PROTECTION),\n\t\"T10-DIF host protection capabilities mask\");\n\n/*\n# lpfc_prot_guard: i\n#\t- Bit mask of protection guard types to register with the SCSI mid-layer\n#\t- Guard types are currently either 1) T10-DIF CRC 2) IP checksum\n#\t- Allows you to ultimately specify which profiles to use\n#\t- Default will result in registering capabilities for all guard types\n#\n*/\nLPFC_ATTR(prot_guard,\n\tSHOST_DIX_GUARD_IP, SHOST_DIX_GUARD_CRC, SHOST_DIX_GUARD_IP,\n\t\"T10-DIF host protection guard type\");\n\n/*\n * Delay initial NPort discovery when Clean Address bit is cleared in\n * FLOGI/FDISC accept and FCID/Fabric name/Fabric portname is changed.\n * This parameter can have value 0 or 1.\n * When this parameter is set to 0, no delay is added to the initial\n * discovery.\n * When this parameter is set to non-zero value, initial Nport discovery is\n * delayed by ra_tov seconds when Clean Address bit is cleared in FLOGI/FDISC\n * accept and FCID/Fabric name/Fabric portname is changed.\n * Driver always delay Nport discovery for subsequent FLOGI/FDISC completion\n * when Clean Address bit is cleared in FLOGI/FDISC\n * accept and FCID/Fabric name/Fabric portname is changed.\n * Default value is 0.\n */\nLPFC_ATTR(delay_discovery, 0, 0, 1,\n\t\"Delay NPort discovery when Clean Address bit is cleared.\");\n\n/*\n * lpfc_sg_seg_cnt - Initial Maximum DMA Segment Count\n * This value can be set to values between 64 and 4096. The default value\n * is 64, but may be increased to allow for larger Max I/O sizes. The scsi\n * and nvme layers will allow I/O sizes up to (MAX_SEG_COUNT * SEG_SIZE).\n * Because of the additional overhead involved in setting up T10-DIF,\n * this parameter will be limited to 128 if BlockGuard is enabled under SLI4\n * and will be limited to 512 if BlockGuard is enabled under SLI3.\n */\nstatic uint lpfc_sg_seg_cnt = LPFC_DEFAULT_SG_SEG_CNT;\nmodule_param(lpfc_sg_seg_cnt, uint, 0444);\nMODULE_PARM_DESC(lpfc_sg_seg_cnt, \"Max Scatter Gather Segment Count\");\n\n/**\n * lpfc_sg_seg_cnt_show - Display the scatter/gather list sizes\n *    configured for the adapter\n * @dev: class converted to a Scsi_host structure.\n * @attr: device attribute, not used.\n * @buf: on return contains a string with the list sizes\n *\n * Returns: size of formatted string.\n **/\nstatic ssize_t\nlpfc_sg_seg_cnt_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint len;\n\n\tlen = scnprintf(buf, PAGE_SIZE, \"SGL sz: %d  total SGEs: %d\\n\",\n\t\t       phba->cfg_sg_dma_buf_size, phba->cfg_total_seg_cnt);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE, \"Cfg: %d  SCSI: %d  NVME: %d\\n\",\n\t\t\tphba->cfg_sg_seg_cnt, phba->cfg_scsi_seg_cnt,\n\t\t\tphba->cfg_nvme_seg_cnt);\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(lpfc_sg_seg_cnt);\n\n/**\n * lpfc_sg_seg_cnt_init - Set the hba sg_seg_cnt initial value\n * @phba: lpfc_hba pointer.\n * @val: contains the initial value\n *\n * Description:\n * Validates the initial value is within range and assigns it to the\n * adapter. If not in range, an error message is posted and the\n * default value is assigned.\n *\n * Returns:\n * zero if value is in range and is set\n * -EINVAL if value was out of range\n **/\nstatic int\nlpfc_sg_seg_cnt_init(struct lpfc_hba *phba, int val)\n{\n\tif (val >= LPFC_MIN_SG_SEG_CNT && val <= LPFC_MAX_SG_SEG_CNT) {\n\t\tphba->cfg_sg_seg_cnt = val;\n\t\treturn 0;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0409 \"LPFC_DRIVER_NAME\"_sg_seg_cnt attribute cannot \"\n\t\t\t\"be set to %d, allowed range is [%d, %d]\\n\",\n\t\t\tval, LPFC_MIN_SG_SEG_CNT, LPFC_MAX_SG_SEG_CNT);\n\tphba->cfg_sg_seg_cnt = LPFC_DEFAULT_SG_SEG_CNT;\n\treturn -EINVAL;\n}\n\n/*\n * lpfc_enable_mds_diags: Enable MDS Diagnostics\n *       0  = MDS Diagnostics disabled (default)\n *       1  = MDS Diagnostics enabled\n * Value range is [0,1]. Default value is 0.\n */\nLPFC_ATTR_RW(enable_mds_diags, 0, 0, 1, \"Enable MDS Diagnostics\");\n\n/*\n * lpfc_ras_fwlog_buffsize: Firmware logging host buffer size\n *\t0 = Disable firmware logging (default)\n *\t[1-4] = Multiple of 1/4th Mb of host memory for FW logging\n * Value range [0..4]. Default value is 0\n */\nLPFC_ATTR(ras_fwlog_buffsize, 0, 0, 4, \"Host memory for FW logging\");\nlpfc_param_show(ras_fwlog_buffsize);\n\nstatic ssize_t\nlpfc_ras_fwlog_buffsize_set(struct lpfc_hba  *phba, uint val)\n{\n\tint ret = 0;\n\tenum ras_state state;\n\n\tif (!lpfc_rangecheck(val, 0, 4))\n\t\treturn -EINVAL;\n\n\tif (phba->cfg_ras_fwlog_buffsize == val)\n\t\treturn 0;\n\n\tif (phba->cfg_ras_fwlog_func != PCI_FUNC(phba->pcidev->devfn))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&phba->hbalock);\n\tstate = phba->ras_fwlog.state;\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (state == REG_INPROGRESS) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI, \"6147 RAS Logging \"\n\t\t\t\t\"registration is in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* For disable logging: stop the logs and free the DMA.\n\t * For ras_fwlog_buffsize size change we still need to free and\n\t * reallocate the DMA in lpfc_sli4_ras_fwlog_init.\n\t */\n\tphba->cfg_ras_fwlog_buffsize = val;\n\tif (state == ACTIVE) {\n\t\tlpfc_ras_stop_fwlog(phba);\n\t\tlpfc_sli4_ras_dma_free(phba);\n\t}\n\n\tlpfc_sli4_ras_init(phba);\n\tif (phba->ras_fwlog.ras_enabled)\n\t\tret = lpfc_sli4_ras_fwlog_init(phba, phba->cfg_ras_fwlog_level,\n\t\t\t\t\t       LPFC_RAS_ENABLE_LOGGING);\n\treturn ret;\n}\n\nlpfc_param_store(ras_fwlog_buffsize);\nstatic DEVICE_ATTR_RW(lpfc_ras_fwlog_buffsize);\n\n/*\n * lpfc_ras_fwlog_level: Firmware logging verbosity level\n * Valid only if firmware logging is enabled\n * 0(Least Verbosity) 4 (most verbosity)\n * Value range is [0..4]. Default value is 0\n */\nLPFC_ATTR_RW(ras_fwlog_level, 0, 0, 4, \"Firmware Logging Level\");\n\n/*\n * lpfc_ras_fwlog_func: Firmware logging enabled on function number\n * Default function which has RAS support : 0\n * Value Range is [0..7].\n * FW logging is a global action and enablement is via a specific\n * port.\n */\nLPFC_ATTR_RW(ras_fwlog_func, 0, 0, 7, \"Firmware Logging Enabled on Function\");\n\n/*\n * lpfc_enable_bbcr: Enable BB Credit Recovery\n *       0  = BB Credit Recovery disabled\n *       1  = BB Credit Recovery enabled (default)\n * Value range is [0,1]. Default value is 1.\n */\nLPFC_BBCR_ATTR_RW(enable_bbcr, 1, 0, 1, \"Enable BBC Recovery\");\n\n/*\n * lpfc_enable_dpp: Enable DPP on G7\n *       0  = DPP on G7 disabled\n *       1  = DPP on G7 enabled (default)\n * Value range is [0,1]. Default value is 1.\n */\nLPFC_ATTR_RW(enable_dpp, 1, 0, 1, \"Enable Direct Packet Push\");\n\n/*\n * lpfc_enable_mi: Enable FDMI MIB\n *       0  = disabled\n *       1  = enabled (default)\n * Value range is [0,1].\n */\nLPFC_ATTR_R(enable_mi, 1, 0, 1, \"Enable MI\");\n\nstruct device_attribute *lpfc_hba_attrs[] = {\n\t&dev_attr_nvme_info,\n\t&dev_attr_scsi_stat,\n\t&dev_attr_bg_info,\n\t&dev_attr_bg_guard_err,\n\t&dev_attr_bg_apptag_err,\n\t&dev_attr_bg_reftag_err,\n\t&dev_attr_info,\n\t&dev_attr_serialnum,\n\t&dev_attr_modeldesc,\n\t&dev_attr_modelname,\n\t&dev_attr_programtype,\n\t&dev_attr_portnum,\n\t&dev_attr_fwrev,\n\t&dev_attr_hdw,\n\t&dev_attr_option_rom_version,\n\t&dev_attr_link_state,\n\t&dev_attr_num_discovered_ports,\n\t&dev_attr_menlo_mgmt_mode,\n\t&dev_attr_lpfc_drvr_version,\n\t&dev_attr_lpfc_enable_fip,\n\t&dev_attr_lpfc_temp_sensor,\n\t&dev_attr_lpfc_log_verbose,\n\t&dev_attr_lpfc_lun_queue_depth,\n\t&dev_attr_lpfc_tgt_queue_depth,\n\t&dev_attr_lpfc_hba_queue_depth,\n\t&dev_attr_lpfc_peer_port_login,\n\t&dev_attr_lpfc_nodev_tmo,\n\t&dev_attr_lpfc_devloss_tmo,\n\t&dev_attr_lpfc_enable_fc4_type,\n\t&dev_attr_lpfc_fcp_class,\n\t&dev_attr_lpfc_use_adisc,\n\t&dev_attr_lpfc_first_burst_size,\n\t&dev_attr_lpfc_ack0,\n\t&dev_attr_lpfc_xri_rebalancing,\n\t&dev_attr_lpfc_topology,\n\t&dev_attr_lpfc_scan_down,\n\t&dev_attr_lpfc_link_speed,\n\t&dev_attr_lpfc_fcp_io_sched,\n\t&dev_attr_lpfc_ns_query,\n\t&dev_attr_lpfc_fcp2_no_tgt_reset,\n\t&dev_attr_lpfc_cr_delay,\n\t&dev_attr_lpfc_cr_count,\n\t&dev_attr_lpfc_multi_ring_support,\n\t&dev_attr_lpfc_multi_ring_rctl,\n\t&dev_attr_lpfc_multi_ring_type,\n\t&dev_attr_lpfc_fdmi_on,\n\t&dev_attr_lpfc_enable_SmartSAN,\n\t&dev_attr_lpfc_max_luns,\n\t&dev_attr_lpfc_enable_npiv,\n\t&dev_attr_lpfc_fcf_failover_policy,\n\t&dev_attr_lpfc_enable_rrq,\n\t&dev_attr_nport_evt_cnt,\n\t&dev_attr_board_mode,\n\t&dev_attr_max_vpi,\n\t&dev_attr_used_vpi,\n\t&dev_attr_max_rpi,\n\t&dev_attr_used_rpi,\n\t&dev_attr_max_xri,\n\t&dev_attr_used_xri,\n\t&dev_attr_npiv_info,\n\t&dev_attr_issue_reset,\n\t&dev_attr_lpfc_poll,\n\t&dev_attr_lpfc_poll_tmo,\n\t&dev_attr_lpfc_task_mgmt_tmo,\n\t&dev_attr_lpfc_use_msi,\n\t&dev_attr_lpfc_nvme_oas,\n\t&dev_attr_lpfc_nvme_embed_cmd,\n\t&dev_attr_lpfc_fcp_imax,\n\t&dev_attr_lpfc_force_rscn,\n\t&dev_attr_lpfc_cq_poll_threshold,\n\t&dev_attr_lpfc_cq_max_proc_limit,\n\t&dev_attr_lpfc_fcp_cpu_map,\n\t&dev_attr_lpfc_fcp_mq_threshold,\n\t&dev_attr_lpfc_hdw_queue,\n\t&dev_attr_lpfc_irq_chann,\n\t&dev_attr_lpfc_suppress_rsp,\n\t&dev_attr_lpfc_nvmet_mrq,\n\t&dev_attr_lpfc_nvmet_mrq_post,\n\t&dev_attr_lpfc_nvme_enable_fb,\n\t&dev_attr_lpfc_nvmet_fb_size,\n\t&dev_attr_lpfc_enable_bg,\n\t&dev_attr_lpfc_soft_wwnn,\n\t&dev_attr_lpfc_soft_wwpn,\n\t&dev_attr_lpfc_soft_wwn_enable,\n\t&dev_attr_lpfc_enable_hba_reset,\n\t&dev_attr_lpfc_enable_hba_heartbeat,\n\t&dev_attr_lpfc_EnableXLane,\n\t&dev_attr_lpfc_XLanePriority,\n\t&dev_attr_lpfc_xlane_lun,\n\t&dev_attr_lpfc_xlane_tgt,\n\t&dev_attr_lpfc_xlane_vpt,\n\t&dev_attr_lpfc_xlane_lun_state,\n\t&dev_attr_lpfc_xlane_lun_status,\n\t&dev_attr_lpfc_xlane_priority,\n\t&dev_attr_lpfc_sg_seg_cnt,\n\t&dev_attr_lpfc_max_scsicmpl_time,\n\t&dev_attr_lpfc_stat_data_ctrl,\n\t&dev_attr_lpfc_aer_support,\n\t&dev_attr_lpfc_aer_state_cleanup,\n\t&dev_attr_lpfc_sriov_nr_virtfn,\n\t&dev_attr_lpfc_req_fw_upgrade,\n\t&dev_attr_lpfc_suppress_link_up,\n\t&dev_attr_iocb_hw,\n\t&dev_attr_pls,\n\t&dev_attr_pt,\n\t&dev_attr_txq_hw,\n\t&dev_attr_txcmplq_hw,\n\t&dev_attr_lpfc_sriov_hw_max_virtfn,\n\t&dev_attr_protocol,\n\t&dev_attr_lpfc_xlane_supported,\n\t&dev_attr_lpfc_enable_mds_diags,\n\t&dev_attr_lpfc_ras_fwlog_buffsize,\n\t&dev_attr_lpfc_ras_fwlog_level,\n\t&dev_attr_lpfc_ras_fwlog_func,\n\t&dev_attr_lpfc_enable_bbcr,\n\t&dev_attr_lpfc_enable_dpp,\n\t&dev_attr_lpfc_enable_mi,\n\tNULL,\n};\n\nstruct device_attribute *lpfc_vport_attrs[] = {\n\t&dev_attr_info,\n\t&dev_attr_link_state,\n\t&dev_attr_num_discovered_ports,\n\t&dev_attr_lpfc_drvr_version,\n\t&dev_attr_lpfc_log_verbose,\n\t&dev_attr_lpfc_lun_queue_depth,\n\t&dev_attr_lpfc_tgt_queue_depth,\n\t&dev_attr_lpfc_nodev_tmo,\n\t&dev_attr_lpfc_devloss_tmo,\n\t&dev_attr_lpfc_hba_queue_depth,\n\t&dev_attr_lpfc_peer_port_login,\n\t&dev_attr_lpfc_restrict_login,\n\t&dev_attr_lpfc_fcp_class,\n\t&dev_attr_lpfc_use_adisc,\n\t&dev_attr_lpfc_first_burst_size,\n\t&dev_attr_lpfc_max_luns,\n\t&dev_attr_nport_evt_cnt,\n\t&dev_attr_npiv_info,\n\t&dev_attr_lpfc_enable_da_id,\n\t&dev_attr_lpfc_max_scsicmpl_time,\n\t&dev_attr_lpfc_stat_data_ctrl,\n\t&dev_attr_lpfc_static_vport,\n\tNULL,\n};\n\n/**\n * sysfs_ctlreg_write - Write method for writing to ctlreg\n * @filp: open sysfs file\n * @kobj: kernel kobject that contains the kernel class device.\n * @bin_attr: kernel attributes passed to us.\n * @buf: contains the data to be written to the adapter IOREG space.\n * @off: offset into buffer to beginning of data.\n * @count: bytes to transfer.\n *\n * Description:\n * Accessed via /sys/class/scsi_host/hostxxx/ctlreg.\n * Uses the adapter io control registers to send buf contents to the adapter.\n *\n * Returns:\n * -ERANGE off and count combo out of range\n * -EINVAL off, count or buff address invalid\n * -EPERM adapter is offline\n * value of count, buf contents written\n **/\nstatic ssize_t\nsysfs_ctlreg_write(struct file *filp, struct kobject *kobj,\n\t\t   struct bin_attribute *bin_attr,\n\t\t   char *buf, loff_t off, size_t count)\n{\n\tsize_t buf_off;\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->sli_rev >= LPFC_SLI_REV4)\n\t\treturn -EPERM;\n\n\tif ((off + count) > FF_REG_AREA_SIZE)\n\t\treturn -ERANGE;\n\n\tif (count <= LPFC_REG_WRITE_KEY_SIZE)\n\t\treturn 0;\n\n\tif (off % 4 || count % 4 || (unsigned long)buf % 4)\n\t\treturn -EINVAL;\n\n\t/* This is to protect HBA registers from accidental writes. */\n\tif (memcmp(buf, LPFC_REG_WRITE_KEY, LPFC_REG_WRITE_KEY_SIZE))\n\t\treturn -EINVAL;\n\n\tif (!(vport->fc_flag & FC_OFFLINE_MODE))\n\t\treturn -EPERM;\n\n\tspin_lock_irq(&phba->hbalock);\n\tfor (buf_off = 0; buf_off < count - LPFC_REG_WRITE_KEY_SIZE;\n\t\t\tbuf_off += sizeof(uint32_t))\n\t\twritel(*((uint32_t *)(buf + buf_off + LPFC_REG_WRITE_KEY_SIZE)),\n\t\t       phba->ctrl_regs_memmap_p + off + buf_off);\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn count;\n}\n\n/**\n * sysfs_ctlreg_read - Read method for reading from ctlreg\n * @filp: open sysfs file\n * @kobj: kernel kobject that contains the kernel class device.\n * @bin_attr: kernel attributes passed to us.\n * @buf: if successful contains the data from the adapter IOREG space.\n * @off: offset into buffer to beginning of data.\n * @count: bytes to transfer.\n *\n * Description:\n * Accessed via /sys/class/scsi_host/hostxxx/ctlreg.\n * Uses the adapter io control registers to read data into buf.\n *\n * Returns:\n * -ERANGE off and count combo out of range\n * -EINVAL off, count or buff address invalid\n * value of count, buf contents read\n **/\nstatic ssize_t\nsysfs_ctlreg_read(struct file *filp, struct kobject *kobj,\n\t\t  struct bin_attribute *bin_attr,\n\t\t  char *buf, loff_t off, size_t count)\n{\n\tsize_t buf_off;\n\tuint32_t * tmp_ptr;\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->sli_rev >= LPFC_SLI_REV4)\n\t\treturn -EPERM;\n\n\tif (off > FF_REG_AREA_SIZE)\n\t\treturn -ERANGE;\n\n\tif ((off + count) > FF_REG_AREA_SIZE)\n\t\tcount = FF_REG_AREA_SIZE - off;\n\n\tif (count == 0) return 0;\n\n\tif (off % 4 || count % 4 || (unsigned long)buf % 4)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&phba->hbalock);\n\n\tfor (buf_off = 0; buf_off < count; buf_off += sizeof(uint32_t)) {\n\t\ttmp_ptr = (uint32_t *)(buf + buf_off);\n\t\t*tmp_ptr = readl(phba->ctrl_regs_memmap_p + off + buf_off);\n\t}\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_ctlreg_attr = {\n\t.attr = {\n\t\t.name = \"ctlreg\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 256,\n\t.read = sysfs_ctlreg_read,\n\t.write = sysfs_ctlreg_write,\n};\n\n/**\n * sysfs_mbox_write - Write method for writing information via mbox\n * @filp: open sysfs file\n * @kobj: kernel kobject that contains the kernel class device.\n * @bin_attr: kernel attributes passed to us.\n * @buf: contains the data to be written to sysfs mbox.\n * @off: offset into buffer to beginning of data.\n * @count: bytes to transfer.\n *\n * Description:\n * Deprecated function. All mailbox access from user space is performed via the\n * bsg interface.\n *\n * Returns:\n * -EPERM operation not permitted\n **/\nstatic ssize_t\nsysfs_mbox_write(struct file *filp, struct kobject *kobj,\n\t\t struct bin_attribute *bin_attr,\n\t\t char *buf, loff_t off, size_t count)\n{\n\treturn -EPERM;\n}\n\n/**\n * sysfs_mbox_read - Read method for reading information via mbox\n * @filp: open sysfs file\n * @kobj: kernel kobject that contains the kernel class device.\n * @bin_attr: kernel attributes passed to us.\n * @buf: contains the data to be read from sysfs mbox.\n * @off: offset into buffer to beginning of data.\n * @count: bytes to transfer.\n *\n * Description:\n * Deprecated function. All mailbox access from user space is performed via the\n * bsg interface.\n *\n * Returns:\n * -EPERM operation not permitted\n **/\nstatic ssize_t\nsysfs_mbox_read(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *bin_attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\treturn -EPERM;\n}\n\nstatic struct bin_attribute sysfs_mbox_attr = {\n\t.attr = {\n\t\t.name = \"mbox\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = MAILBOX_SYSFS_MAX,\n\t.read = sysfs_mbox_read,\n\t.write = sysfs_mbox_write,\n};\n\n/**\n * lpfc_alloc_sysfs_attr - Creates the ctlreg and mbox entries\n * @vport: address of lpfc vport structure.\n *\n * Return codes:\n * zero on success\n * error return code from sysfs_create_bin_file()\n **/\nint\nlpfc_alloc_sysfs_attr(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tint error;\n\n\terror = sysfs_create_bin_file(&shost->shost_dev.kobj,\n\t\t\t\t      &sysfs_drvr_stat_data_attr);\n\n\t/* Virtual ports do not need ctrl_reg and mbox */\n\tif (error || vport->port_type == LPFC_NPIV_PORT)\n\t\tgoto out;\n\n\terror = sysfs_create_bin_file(&shost->shost_dev.kobj,\n\t\t\t\t      &sysfs_ctlreg_attr);\n\tif (error)\n\t\tgoto out_remove_stat_attr;\n\n\terror = sysfs_create_bin_file(&shost->shost_dev.kobj,\n\t\t\t\t      &sysfs_mbox_attr);\n\tif (error)\n\t\tgoto out_remove_ctlreg_attr;\n\n\treturn 0;\nout_remove_ctlreg_attr:\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);\nout_remove_stat_attr:\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj,\n\t\t\t&sysfs_drvr_stat_data_attr);\nout:\n\treturn error;\n}\n\n/**\n * lpfc_free_sysfs_attr - Removes the ctlreg and mbox entries\n * @vport: address of lpfc vport structure.\n **/\nvoid\nlpfc_free_sysfs_attr(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj,\n\t\t&sysfs_drvr_stat_data_attr);\n\t/* Virtual ports do not need ctrl_reg and mbox */\n\tif (vport->port_type == LPFC_NPIV_PORT)\n\t\treturn;\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_mbox_attr);\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);\n}\n\n/*\n * Dynamic FC Host Attributes Support\n */\n\n/**\n * lpfc_get_host_symbolic_name - Copy symbolic name into the scsi host\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_get_host_symbolic_name(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\n\tlpfc_vport_symbolic_node_name(vport, fc_host_symbolic_name(shost),\n\t\t\t\t      sizeof fc_host_symbolic_name(shost));\n}\n\n/**\n * lpfc_get_host_port_id - Copy the vport DID into the scsi host port id\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\n\t/* note: fc_myDID already in cpu endianness */\n\tfc_host_port_id(shost) = vport->fc_myDID;\n}\n\n/**\n * lpfc_get_host_port_type - Set the value of the scsi host port type\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif (vport->port_type == LPFC_NPIV_PORT) {\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\n\t} else if (lpfc_is_link_up(phba)) {\n\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\tif (vport->fc_flag & FC_PUBLIC_LOOP)\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\n\t\t\telse\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\n\t\t} else {\n\t\t\tif (vport->fc_flag & FC_FABRIC)\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\t\t\telse\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_PTP;\n\t\t}\n\t} else\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\n\n\tspin_unlock_irq(shost->host_lock);\n}\n\n/**\n * lpfc_get_host_port_state - Set the value of the scsi host port state\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif (vport->fc_flag & FC_OFFLINE_MODE)\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\telse {\n\t\tswitch (phba->link_state) {\n\t\tcase LPFC_LINK_UNKNOWN:\n\t\tcase LPFC_LINK_DOWN:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_UP:\n\t\tcase LPFC_CLEAR_LA:\n\t\tcase LPFC_HBA_READY:\n\t\t\t/* Links up, reports port state accordingly */\n\t\t\tif (vport->port_state < LPFC_VPORT_READY)\n\t\t\t\tfc_host_port_state(shost) =\n\t\t\t\t\t\t\tFC_PORTSTATE_BYPASSED;\n\t\t\telse\n\t\t\t\tfc_host_port_state(shost) =\n\t\t\t\t\t\t\tFC_PORTSTATE_ONLINE;\n\t\t\tbreak;\n\t\tcase LPFC_HBA_ERROR:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irq(shost->host_lock);\n}\n\n/**\n * lpfc_get_host_speed - Set the value of the scsi host speed\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif ((lpfc_is_link_up(phba)) && (!(phba->hba_flag & HBA_FCOE_MODE))) {\n\t\tswitch(phba->fc_linkspeed) {\n\t\tcase LPFC_LINK_SPEED_1GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_2GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_4GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_8GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_10GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_16GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_32GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_32GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_64GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_64GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_128GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_128GBIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else if (lpfc_is_link_up(phba) && (phba->hba_flag & HBA_FCOE_MODE)) {\n\t\tswitch (phba->fc_linkspeed) {\n\t\tcase LPFC_ASYNC_LINK_SPEED_1GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_10GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_20GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_20GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_25GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_25GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_40GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_40GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_100GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_100GBIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\n\tspin_unlock_irq(shost->host_lock);\n}\n\n/**\n * lpfc_get_host_fabric_name - Set the value of the scsi host fabric name\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_get_host_fabric_name (struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tu64 node_name;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif ((vport->port_state > LPFC_FLOGI) &&\n\t    ((vport->fc_flag & FC_FABRIC) ||\n\t     ((phba->fc_topology == LPFC_TOPOLOGY_LOOP) &&\n\t      (vport->fc_flag & FC_PUBLIC_LOOP))))\n\t\tnode_name = wwn_to_u64(phba->fc_fabparam.nodeName.u.wwn);\n\telse\n\t\t/* fabric is local port if there is no F/FL_Port */\n\t\tnode_name = 0;\n\n\tspin_unlock_irq(shost->host_lock);\n\n\tfc_host_fabric_name(shost) = node_name;\n}\n\n/**\n * lpfc_get_stats - Return statistical information about the adapter\n * @shost: kernel scsi host pointer.\n *\n * Notes:\n * NULL on error for link down, no mbox pool, sli2 active,\n * management not allowed, memory allocation error, or mbox error.\n *\n * Returns:\n * NULL for error\n * address of the adapter host statistics\n **/\nstatic struct fc_host_statistics *\nlpfc_get_stats(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli   *psli = &phba->sli;\n\tstruct fc_host_statistics *hs = &phba->link_stats;\n\tstruct lpfc_lnk_stat * lso = &psli->lnk_stat_offsets;\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *pmb;\n\tint rc = 0;\n\n\t/*\n\t * prevent udev from issuing mailbox commands until the port is\n\t * configured.\n\t */\n\tif (phba->link_state < LPFC_LINK_DOWN ||\n\t    !phba->mbox_mem_pool ||\n\t    (phba->sli.sli_flag & LPFC_SLI_ACTIVE) == 0)\n\t\treturn NULL;\n\n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\n\t\treturn NULL;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn NULL;\n\tmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tpmb->mbxCommand = MBX_READ_STATUS;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif (vport->fc_flag & FC_OFFLINE_MODE)\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\telse\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\n\tif (rc != MBX_SUCCESS) {\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\treturn NULL;\n\t}\n\n\tmemset(hs, 0, sizeof (struct fc_host_statistics));\n\n\ths->tx_frames = pmb->un.varRdStatus.xmitFrameCnt;\n\t/*\n\t * The MBX_READ_STATUS returns tx_k_bytes which has to\n\t * converted to words\n\t */\n\ths->tx_words = (uint64_t)\n\t\t\t((uint64_t)pmb->un.varRdStatus.xmitByteCnt\n\t\t\t* (uint64_t)256);\n\ths->rx_frames = pmb->un.varRdStatus.rcvFrameCnt;\n\ths->rx_words = (uint64_t)\n\t\t\t((uint64_t)pmb->un.varRdStatus.rcvByteCnt\n\t\t\t * (uint64_t)256);\n\n\tmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\tpmb->mbxCommand = MBX_READ_LNK_STAT;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif (vport->fc_flag & FC_OFFLINE_MODE)\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\telse\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\n\tif (rc != MBX_SUCCESS) {\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\treturn NULL;\n\t}\n\n\ths->link_failure_count = pmb->un.varRdLnk.linkFailureCnt;\n\ths->loss_of_sync_count = pmb->un.varRdLnk.lossSyncCnt;\n\ths->loss_of_signal_count = pmb->un.varRdLnk.lossSignalCnt;\n\ths->prim_seq_protocol_err_count = pmb->un.varRdLnk.primSeqErrCnt;\n\ths->invalid_tx_word_count = pmb->un.varRdLnk.invalidXmitWord;\n\ths->invalid_crc_count = pmb->un.varRdLnk.crcCnt;\n\ths->error_frames = pmb->un.varRdLnk.crcCnt;\n\n\ths->link_failure_count -= lso->link_failure_count;\n\ths->loss_of_sync_count -= lso->loss_of_sync_count;\n\ths->loss_of_signal_count -= lso->loss_of_signal_count;\n\ths->prim_seq_protocol_err_count -= lso->prim_seq_protocol_err_count;\n\ths->invalid_tx_word_count -= lso->invalid_tx_word_count;\n\ths->invalid_crc_count -= lso->invalid_crc_count;\n\ths->error_frames -= lso->error_frames;\n\n\tif (phba->hba_flag & HBA_FCOE_MODE) {\n\t\ths->lip_count = -1;\n\t\ths->nos_count = (phba->link_events >> 1);\n\t\ths->nos_count -= lso->link_events;\n\t} else if (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\ths->lip_count = (phba->fc_eventTag >> 1);\n\t\ths->lip_count -= lso->link_events;\n\t\ths->nos_count = -1;\n\t} else {\n\t\ths->lip_count = -1;\n\t\ths->nos_count = (phba->fc_eventTag >> 1);\n\t\ths->nos_count -= lso->link_events;\n\t}\n\n\ths->dumped_frames = -1;\n\n\ths->seconds_since_last_reset = ktime_get_seconds() - psli->stats_start;\n\n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\treturn hs;\n}\n\n/**\n * lpfc_reset_stats - Copy the adapter link stats information\n * @shost: kernel scsi host pointer.\n **/\nstatic void\nlpfc_reset_stats(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli   *psli = &phba->sli;\n\tstruct lpfc_lnk_stat *lso = &psli->lnk_stat_offsets;\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *pmb;\n\tint rc = 0;\n\n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\n\t\treturn;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn;\n\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tpmb->mbxCommand = MBX_READ_STATUS;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmb->un.varWords[0] = 0x1; /* reset request */\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t\t(!(psli->sli_flag & LPFC_SLI_ACTIVE)))\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\telse\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\n\tif (rc != MBX_SUCCESS) {\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\tpmb->mbxCommand = MBX_READ_LNK_STAT;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t    (!(psli->sli_flag & LPFC_SLI_ACTIVE)))\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\telse\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\n\tif (rc != MBX_SUCCESS) {\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free( pmboxq, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\tlso->link_failure_count = pmb->un.varRdLnk.linkFailureCnt;\n\tlso->loss_of_sync_count = pmb->un.varRdLnk.lossSyncCnt;\n\tlso->loss_of_signal_count = pmb->un.varRdLnk.lossSignalCnt;\n\tlso->prim_seq_protocol_err_count = pmb->un.varRdLnk.primSeqErrCnt;\n\tlso->invalid_tx_word_count = pmb->un.varRdLnk.invalidXmitWord;\n\tlso->invalid_crc_count = pmb->un.varRdLnk.crcCnt;\n\tlso->error_frames = pmb->un.varRdLnk.crcCnt;\n\tif (phba->hba_flag & HBA_FCOE_MODE)\n\t\tlso->link_events = (phba->link_events >> 1);\n\telse\n\t\tlso->link_events = (phba->fc_eventTag >> 1);\n\n\tpsli->stats_start = ktime_get_seconds();\n\n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\treturn;\n}\n\n/*\n * The LPFC driver treats linkdown handling as target loss events so there\n * are no sysfs handlers for link_down_tmo.\n */\n\n/**\n * lpfc_get_node_by_target - Return the nodelist for a target\n * @starget: kernel scsi target pointer.\n *\n * Returns:\n * address of the node list if found\n * NULL target not found\n **/\nstatic struct lpfc_nodelist *\nlpfc_get_node_by_target(struct scsi_target *starget)\n{\n\tstruct Scsi_Host  *shost = dev_to_shost(starget->dev.parent);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_nodelist *ndlp;\n\n\tspin_lock_irq(shost->host_lock);\n\t/* Search for this, mapped, target ID */\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_MAPPED_NODE &&\n\t\t    starget->id == ndlp->nlp_sid) {\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\treturn ndlp;\n\t\t}\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\treturn NULL;\n}\n\n/**\n * lpfc_get_starget_port_id - Set the target port id to the ndlp DID or -1\n * @starget: kernel scsi target pointer.\n **/\nstatic void\nlpfc_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\n\n\tfc_starget_port_id(starget) = ndlp ? ndlp->nlp_DID : -1;\n}\n\n/**\n * lpfc_get_starget_node_name - Set the target node name\n * @starget: kernel scsi target pointer.\n *\n * Description: Set the target node name to the ndlp node name wwn or zero.\n **/\nstatic void\nlpfc_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\n\n\tfc_starget_node_name(starget) =\n\t\tndlp ? wwn_to_u64(ndlp->nlp_nodename.u.wwn) : 0;\n}\n\n/**\n * lpfc_get_starget_port_name - Set the target port name\n * @starget: kernel scsi target pointer.\n *\n * Description:  set the target port name to the ndlp port name wwn or zero.\n **/\nstatic void\nlpfc_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\n\n\tfc_starget_port_name(starget) =\n\t\tndlp ? wwn_to_u64(ndlp->nlp_portname.u.wwn) : 0;\n}\n\n/**\n * lpfc_set_rport_loss_tmo - Set the rport dev loss tmo\n * @rport: fc rport address.\n * @timeout: new value for dev loss tmo.\n *\n * Description:\n * If timeout is non zero set the dev_loss_tmo to timeout, else set\n * dev_loss_tmo to one.\n **/\nstatic void\nlpfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\n{\n\tstruct lpfc_rport_data *rdata = rport->dd_data;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_nvme_rport *nrport = NULL;\n#endif\n\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = 1;\n\n\tif (!ndlp) {\n\t\tdev_info(&rport->dev, \"Cannot find remote node to \"\n\t\t\t\t      \"set rport dev loss tmo, port_id x%x\\n\",\n\t\t\t\t      rport->port_id);\n\t\treturn;\n\t}\n\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tnrport = lpfc_ndlp_get_nrport(ndlp);\n\n\tif (nrport && nrport->remoteport)\n\t\tnvme_fc_set_remoteport_devloss(nrport->remoteport,\n\t\t\t\t\t       rport->dev_loss_tmo);\n#endif\n}\n\n/*\n * lpfc_rport_show_function - Return rport target information\n *\n * Description:\n * Macro that uses field to generate a function with the name lpfc_show_rport_\n *\n * lpfc_show_rport_##field: returns the bytes formatted in buf\n * @cdev: class converted to an fc_rport.\n * @buf: on return contains the target_field or zero.\n *\n * Returns: size of formatted string.\n **/\n#define lpfc_rport_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nlpfc_show_rport_##field (struct device *dev,\t\t\t\t\\\n\t\t\t struct device_attribute *attr,\t\t\t\\\n\t\t\t char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\t\t\\\n\tstruct lpfc_rport_data *rdata = rport->hostdata;\t\t\\\n\treturn scnprintf(buf, sz, format_string,\t\t\t\\\n\t\t(rdata->target) ? cast rdata->target->field : 0);\t\\\n}\n\n#define lpfc_rport_rd_attr(field, format_string, sz)\t\t\t\\\n\tlpfc_rport_show_function(field, format_string, sz, )\t\t\\\nstatic FC_RPORT_ATTR(field, S_IRUGO, lpfc_show_rport_##field, NULL)\n\n/**\n * lpfc_set_vport_symbolic_name - Set the vport's symbolic name\n * @fc_vport: The fc_vport who's symbolic name has been changed.\n *\n * Description:\n * This function is called by the transport after the @fc_vport's symbolic name\n * has been changed. This function re-registers the symbolic name with the\n * switch to propagate the change into the fabric if the vport is active.\n **/\nstatic void\nlpfc_set_vport_symbolic_name(struct fc_vport *fc_vport)\n{\n\tstruct lpfc_vport *vport = *(struct lpfc_vport **)fc_vport->dd_data;\n\n\tif (vport->port_state == LPFC_VPORT_READY)\n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RSPN_ID, 0, 0);\n}\n\n/**\n * lpfc_hba_log_verbose_init - Set hba's log verbose level\n * @phba: Pointer to lpfc_hba struct.\n * @verbose: Verbose level to set.\n *\n * This function is called by the lpfc_get_cfgparam() routine to set the\n * module lpfc_log_verbose into the @phba cfg_log_verbose for use with\n * log message according to the module's lpfc_log_verbose parameter setting\n * before hba port or vport created.\n **/\nstatic void\nlpfc_hba_log_verbose_init(struct lpfc_hba *phba, uint32_t verbose)\n{\n\tphba->cfg_log_verbose = verbose;\n}\n\nstruct fc_function_template lpfc_transport_functions = {\n\t/* fixed attributes the driver supports */\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_symbolic_name = lpfc_get_host_symbolic_name,\n\t.show_host_symbolic_name = 1,\n\n\t/* dynamic attributes the driver supports */\n\t.get_host_port_id = lpfc_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t.get_host_port_type = lpfc_get_host_port_type,\n\t.show_host_port_type = 1,\n\n\t.get_host_port_state = lpfc_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t/* active_fc4s is shown but doesn't change (thus no get function) */\n\t.show_host_active_fc4s = 1,\n\n\t.get_host_speed = lpfc_get_host_speed,\n\t.show_host_speed = 1,\n\n\t.get_host_fabric_name = lpfc_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\n\t/*\n\t * The LPFC driver treats linkdown handling as target loss events\n\t * so there are no sysfs handlers for link_down_tmo.\n\t */\n\n\t.get_fc_host_stats = lpfc_get_stats,\n\t.reset_fc_host_stats = lpfc_reset_stats,\n\n\t.dd_fcrport_size = sizeof(struct lpfc_rport_data),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = lpfc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.get_starget_port_id  = lpfc_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.get_starget_node_name = lpfc_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\n\t.get_starget_port_name = lpfc_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t.issue_fc_host_lip = lpfc_issue_lip,\n\t.dev_loss_tmo_callbk = lpfc_dev_loss_tmo_callbk,\n\t.terminate_rport_io = lpfc_terminate_rport_io,\n\n\t.dd_fcvport_size = sizeof(struct lpfc_vport *),\n\n\t.vport_disable = lpfc_vport_disable,\n\n\t.set_vport_symbolic_name = lpfc_set_vport_symbolic_name,\n\n\t.bsg_request = lpfc_bsg_request,\n\t.bsg_timeout = lpfc_bsg_timeout,\n};\n\nstruct fc_function_template lpfc_vport_transport_functions = {\n\t/* fixed attributes the driver supports */\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_symbolic_name = lpfc_get_host_symbolic_name,\n\t.show_host_symbolic_name = 1,\n\n\t/* dynamic attributes the driver supports */\n\t.get_host_port_id = lpfc_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t.get_host_port_type = lpfc_get_host_port_type,\n\t.show_host_port_type = 1,\n\n\t.get_host_port_state = lpfc_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t/* active_fc4s is shown but doesn't change (thus no get function) */\n\t.show_host_active_fc4s = 1,\n\n\t.get_host_speed = lpfc_get_host_speed,\n\t.show_host_speed = 1,\n\n\t.get_host_fabric_name = lpfc_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\n\t/*\n\t * The LPFC driver treats linkdown handling as target loss events\n\t * so there are no sysfs handlers for link_down_tmo.\n\t */\n\n\t.get_fc_host_stats = lpfc_get_stats,\n\t.reset_fc_host_stats = lpfc_reset_stats,\n\n\t.dd_fcrport_size = sizeof(struct lpfc_rport_data),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = lpfc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.get_starget_port_id  = lpfc_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.get_starget_node_name = lpfc_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\n\t.get_starget_port_name = lpfc_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t.dev_loss_tmo_callbk = lpfc_dev_loss_tmo_callbk,\n\t.terminate_rport_io = lpfc_terminate_rport_io,\n\n\t.vport_disable = lpfc_vport_disable,\n\n\t.set_vport_symbolic_name = lpfc_set_vport_symbolic_name,\n};\n\n/**\n * lpfc_get_hba_function_mode - Used to determine the HBA function in FCoE\n * Mode\n * @phba: lpfc_hba pointer.\n **/\nstatic void\nlpfc_get_hba_function_mode(struct lpfc_hba *phba)\n{\n\t/* If the adapter supports FCoE mode */\n\tswitch (phba->pcidev->device) {\n\tcase PCI_DEVICE_ID_SKYHAWK:\n\tcase PCI_DEVICE_ID_SKYHAWK_VF:\n\tcase PCI_DEVICE_ID_LANCER_FCOE:\n\tcase PCI_DEVICE_ID_LANCER_FCOE_VF:\n\tcase PCI_DEVICE_ID_ZEPHYR_DCSP:\n\tcase PCI_DEVICE_ID_HORNET:\n\tcase PCI_DEVICE_ID_TIGERSHARK:\n\tcase PCI_DEVICE_ID_TOMCAT:\n\t\tphba->hba_flag |= HBA_FCOE_MODE;\n\t\tbreak;\n\tdefault:\n\t/* for others, clear the flag */\n\t\tphba->hba_flag &= ~HBA_FCOE_MODE;\n\t}\n}\n\n/**\n * lpfc_get_cfgparam - Used during probe_one to init the adapter structure\n * @phba: lpfc_hba pointer.\n **/\nvoid\nlpfc_get_cfgparam(struct lpfc_hba *phba)\n{\n\tlpfc_hba_log_verbose_init(phba, lpfc_log_verbose);\n\tlpfc_fcp_io_sched_init(phba, lpfc_fcp_io_sched);\n\tlpfc_ns_query_init(phba, lpfc_ns_query);\n\tlpfc_fcp2_no_tgt_reset_init(phba, lpfc_fcp2_no_tgt_reset);\n\tlpfc_cr_delay_init(phba, lpfc_cr_delay);\n\tlpfc_cr_count_init(phba, lpfc_cr_count);\n\tlpfc_multi_ring_support_init(phba, lpfc_multi_ring_support);\n\tlpfc_multi_ring_rctl_init(phba, lpfc_multi_ring_rctl);\n\tlpfc_multi_ring_type_init(phba, lpfc_multi_ring_type);\n\tlpfc_ack0_init(phba, lpfc_ack0);\n\tlpfc_xri_rebalancing_init(phba, lpfc_xri_rebalancing);\n\tlpfc_topology_init(phba, lpfc_topology);\n\tlpfc_link_speed_init(phba, lpfc_link_speed);\n\tlpfc_poll_tmo_init(phba, lpfc_poll_tmo);\n\tlpfc_task_mgmt_tmo_init(phba, lpfc_task_mgmt_tmo);\n\tlpfc_enable_npiv_init(phba, lpfc_enable_npiv);\n\tlpfc_fcf_failover_policy_init(phba, lpfc_fcf_failover_policy);\n\tlpfc_enable_rrq_init(phba, lpfc_enable_rrq);\n\tlpfc_fdmi_on_init(phba, lpfc_fdmi_on);\n\tlpfc_enable_SmartSAN_init(phba, lpfc_enable_SmartSAN);\n\tlpfc_use_msi_init(phba, lpfc_use_msi);\n\tlpfc_nvme_oas_init(phba, lpfc_nvme_oas);\n\tlpfc_nvme_embed_cmd_init(phba, lpfc_nvme_embed_cmd);\n\tlpfc_fcp_imax_init(phba, lpfc_fcp_imax);\n\tlpfc_force_rscn_init(phba, lpfc_force_rscn);\n\tlpfc_cq_poll_threshold_init(phba, lpfc_cq_poll_threshold);\n\tlpfc_cq_max_proc_limit_init(phba, lpfc_cq_max_proc_limit);\n\tlpfc_fcp_cpu_map_init(phba, lpfc_fcp_cpu_map);\n\tlpfc_enable_hba_reset_init(phba, lpfc_enable_hba_reset);\n\tlpfc_enable_hba_heartbeat_init(phba, lpfc_enable_hba_heartbeat);\n\n\tlpfc_EnableXLane_init(phba, lpfc_EnableXLane);\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\tphba->cfg_EnableXLane = 0;\n\tlpfc_XLanePriority_init(phba, lpfc_XLanePriority);\n\n\tmemset(phba->cfg_oas_tgt_wwpn, 0, (8 * sizeof(uint8_t)));\n\tmemset(phba->cfg_oas_vpt_wwpn, 0, (8 * sizeof(uint8_t)));\n\tphba->cfg_oas_lun_state = 0;\n\tphba->cfg_oas_lun_status = 0;\n\tphba->cfg_oas_flags = 0;\n\tphba->cfg_oas_priority = 0;\n\tlpfc_enable_bg_init(phba, lpfc_enable_bg);\n\tlpfc_prot_mask_init(phba, lpfc_prot_mask);\n\tlpfc_prot_guard_init(phba, lpfc_prot_guard);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tphba->cfg_poll = 0;\n\telse\n\t\tphba->cfg_poll = lpfc_poll;\n\n\t/* Get the function mode */\n\tlpfc_get_hba_function_mode(phba);\n\n\t/* BlockGuard allowed for FC only. */\n\tif (phba->cfg_enable_bg && phba->hba_flag & HBA_FCOE_MODE) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\"0581 BlockGuard feature not supported\\n\");\n\t\t/* If set, clear the BlockGuard support param */\n\t\tphba->cfg_enable_bg = 0;\n\t} else if (phba->cfg_enable_bg) {\n\t\tphba->sli3_options |= LPFC_SLI3_BG_ENABLED;\n\t}\n\n\tlpfc_suppress_rsp_init(phba, lpfc_suppress_rsp);\n\n\tlpfc_enable_fc4_type_init(phba, lpfc_enable_fc4_type);\n\tlpfc_nvmet_mrq_init(phba, lpfc_nvmet_mrq);\n\tlpfc_nvmet_mrq_post_init(phba, lpfc_nvmet_mrq_post);\n\n\t/* Initialize first burst. Target vs Initiator are different. */\n\tlpfc_nvme_enable_fb_init(phba, lpfc_nvme_enable_fb);\n\tlpfc_nvmet_fb_size_init(phba, lpfc_nvmet_fb_size);\n\tlpfc_fcp_mq_threshold_init(phba, lpfc_fcp_mq_threshold);\n\tlpfc_hdw_queue_init(phba, lpfc_hdw_queue);\n\tlpfc_irq_chann_init(phba, lpfc_irq_chann);\n\tlpfc_enable_bbcr_init(phba, lpfc_enable_bbcr);\n\tlpfc_enable_dpp_init(phba, lpfc_enable_dpp);\n\tlpfc_enable_mi_init(phba, lpfc_enable_mi);\n\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\t/* NVME only supported on SLI4 */\n\t\tphba->nvmet_support = 0;\n\t\tphba->cfg_nvmet_mrq = 0;\n\t\tphba->cfg_enable_fc4_type = LPFC_ENABLE_FCP;\n\t\tphba->cfg_enable_bbcr = 0;\n\t\tphba->cfg_xri_rebalancing = 0;\n\t} else {\n\t\t/* We MUST have FCP support */\n\t\tif (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\n\t\t\tphba->cfg_enable_fc4_type |= LPFC_ENABLE_FCP;\n\t}\n\n\tphba->cfg_auto_imax = (phba->cfg_fcp_imax) ? 0 : 1;\n\n\tphba->cfg_enable_pbde = 0;\n\n\t/* A value of 0 means use the number of CPUs found in the system */\n\tif (phba->cfg_hdw_queue == 0)\n\t\tphba->cfg_hdw_queue = phba->sli4_hba.num_present_cpu;\n\tif (phba->cfg_irq_chann == 0)\n\t\tphba->cfg_irq_chann = phba->sli4_hba.num_present_cpu;\n\tif (phba->cfg_irq_chann > phba->cfg_hdw_queue)\n\t\tphba->cfg_irq_chann = phba->cfg_hdw_queue;\n\n\tphba->cfg_soft_wwnn = 0L;\n\tphba->cfg_soft_wwpn = 0L;\n\tlpfc_sg_seg_cnt_init(phba, lpfc_sg_seg_cnt);\n\tlpfc_hba_queue_depth_init(phba, lpfc_hba_queue_depth);\n\tlpfc_aer_support_init(phba, lpfc_aer_support);\n\tlpfc_sriov_nr_virtfn_init(phba, lpfc_sriov_nr_virtfn);\n\tlpfc_request_firmware_upgrade_init(phba, lpfc_req_fw_upgrade);\n\tlpfc_suppress_link_up_init(phba, lpfc_suppress_link_up);\n\tlpfc_delay_discovery_init(phba, lpfc_delay_discovery);\n\tlpfc_sli_mode_init(phba, lpfc_sli_mode);\n\tlpfc_enable_mds_diags_init(phba, lpfc_enable_mds_diags);\n\tlpfc_ras_fwlog_buffsize_init(phba, lpfc_ras_fwlog_buffsize);\n\tlpfc_ras_fwlog_level_init(phba, lpfc_ras_fwlog_level);\n\tlpfc_ras_fwlog_func_init(phba, lpfc_ras_fwlog_func);\n\n\treturn;\n}\n\n/**\n * lpfc_nvme_mod_param_dep - Adjust module parameter value based on\n * dependencies between protocols and roles.\n * @phba: lpfc_hba pointer.\n **/\nvoid\nlpfc_nvme_mod_param_dep(struct lpfc_hba *phba)\n{\n\tint  logit = 0;\n\n\tif (phba->cfg_hdw_queue > phba->sli4_hba.num_present_cpu) {\n\t\tphba->cfg_hdw_queue = phba->sli4_hba.num_present_cpu;\n\t\tlogit = 1;\n\t}\n\tif (phba->cfg_irq_chann > phba->sli4_hba.num_present_cpu) {\n\t\tphba->cfg_irq_chann = phba->sli4_hba.num_present_cpu;\n\t\tlogit = 1;\n\t}\n\tif (phba->cfg_irq_chann > phba->cfg_hdw_queue) {\n\t\tphba->cfg_irq_chann = phba->cfg_hdw_queue;\n\t\tlogit = 1;\n\t}\n\tif (logit)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\n\t\t\t\t\"2006 Reducing Queues - CPU limitation: \"\n\t\t\t\t\"IRQ %d HDWQ %d\\n\",\n\t\t\t\tphba->cfg_irq_chann,\n\t\t\t\tphba->cfg_hdw_queue);\n\n\tif (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME &&\n\t    phba->nvmet_support) {\n\t\tphba->cfg_enable_fc4_type &= ~LPFC_ENABLE_FCP;\n\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t\"6013 %s x%x fb_size x%x, fb_max x%x\\n\",\n\t\t\t\t\"NVME Target PRLI ACC enable_fb \",\n\t\t\t\tphba->cfg_nvme_enable_fb,\n\t\t\t\tphba->cfg_nvmet_fb_size,\n\t\t\t\tLPFC_NVMET_FB_SZ_MAX);\n\n\t\tif (phba->cfg_nvme_enable_fb == 0)\n\t\t\tphba->cfg_nvmet_fb_size = 0;\n\t\telse {\n\t\t\tif (phba->cfg_nvmet_fb_size > LPFC_NVMET_FB_SZ_MAX)\n\t\t\t\tphba->cfg_nvmet_fb_size = LPFC_NVMET_FB_SZ_MAX;\n\t\t}\n\n\t\tif (!phba->cfg_nvmet_mrq)\n\t\t\tphba->cfg_nvmet_mrq = phba->cfg_hdw_queue;\n\n\t\t/* Adjust lpfc_nvmet_mrq to avoid running out of WQE slots */\n\t\tif (phba->cfg_nvmet_mrq > phba->cfg_hdw_queue) {\n\t\t\tphba->cfg_nvmet_mrq = phba->cfg_hdw_queue;\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_NVME_DISC,\n\t\t\t\t\t\"6018 Adjust lpfc_nvmet_mrq to %d\\n\",\n\t\t\t\t\tphba->cfg_nvmet_mrq);\n\t\t}\n\t\tif (phba->cfg_nvmet_mrq > LPFC_NVMET_MRQ_MAX)\n\t\t\tphba->cfg_nvmet_mrq = LPFC_NVMET_MRQ_MAX;\n\n\t} else {\n\t\t/* Not NVME Target mode.  Turn off Target parameters. */\n\t\tphba->nvmet_support = 0;\n\t\tphba->cfg_nvmet_mrq = 0;\n\t\tphba->cfg_nvmet_fb_size = 0;\n\t}\n}\n\n/**\n * lpfc_get_vport_cfgparam - Used during port create, init the vport structure\n * @vport: lpfc_vport pointer.\n **/\nvoid\nlpfc_get_vport_cfgparam(struct lpfc_vport *vport)\n{\n\tlpfc_log_verbose_init(vport, lpfc_log_verbose);\n\tlpfc_lun_queue_depth_init(vport, lpfc_lun_queue_depth);\n\tlpfc_tgt_queue_depth_init(vport, lpfc_tgt_queue_depth);\n\tlpfc_devloss_tmo_init(vport, lpfc_devloss_tmo);\n\tlpfc_nodev_tmo_init(vport, lpfc_nodev_tmo);\n\tlpfc_peer_port_login_init(vport, lpfc_peer_port_login);\n\tlpfc_restrict_login_init(vport, lpfc_restrict_login);\n\tlpfc_fcp_class_init(vport, lpfc_fcp_class);\n\tlpfc_use_adisc_init(vport, lpfc_use_adisc);\n\tlpfc_first_burst_size_init(vport, lpfc_first_burst_size);\n\tlpfc_max_scsicmpl_time_init(vport, lpfc_max_scsicmpl_time);\n\tlpfc_discovery_threads_init(vport, lpfc_discovery_threads);\n\tlpfc_max_luns_init(vport, lpfc_max_luns);\n\tlpfc_scan_down_init(vport, lpfc_scan_down);\n\tlpfc_enable_da_id_init(vport, lpfc_enable_da_id);\n\treturn;\n}\n"}}, "reports": [{"events": [{"location": {"col": 60, "file": 0, "line": 6385}, "message": "WARNING opportunity for kobj_to_dev()"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_attr.c", "reportHash": "2e8340dc780d982e456c829d9dc75d65", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 60, "file": 0, "line": 6325}, "message": "WARNING opportunity for kobj_to_dev()"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_attr.c", "reportHash": "2e8340dc780d982e456c829d9dc75d65", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 4388}, "message": "WARNING opportunity for kobj_to_dev()"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/lpfc/lpfc_attr.c", "reportHash": "728be4f66c2aac44e8ed0079f53355f6", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
