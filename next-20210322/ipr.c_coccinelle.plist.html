<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/ipr.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * ipr.c -- driver for IBM Power Linux RAID adapters\n *\n * Written By: Brian King <brking@us.ibm.com>, IBM Corporation\n *\n * Copyright (C) 2003, 2004 IBM Corporation\n */\n\n/*\n * Notes:\n *\n * This driver is used to control the following SCSI adapters:\n *\n * IBM iSeries: 5702, 5703, 2780, 5709, 570A, 570B\n *\n * IBM pSeries: PCI-X Dual Channel Ultra 320 SCSI RAID Adapter\n *              PCI-X Dual Channel Ultra 320 SCSI Adapter\n *              PCI-X Dual Channel Ultra 320 SCSI RAID Enablement Card\n *              Embedded SCSI adapter on p615 and p655 systems\n *\n * Supported Hardware Features:\n *\t- Ultra 320 SCSI controller\n *\t- PCI-X host interface\n *\t- Embedded PowerPC RISC Processor and Hardware XOR DMA Engine\n *\t- Non-Volatile Write Cache\n *\t- Supports attachment of non-RAID disks, tape, and optical devices\n *\t- RAID Levels 0, 5, 10\n *\t- Hot spare\n *\t- Background Parity Checking\n *\t- Background Data Scrubbing\n *\t- Ability to increase the capacity of an existing RAID 5 disk array\n *\t\tby adding disks\n *\n * Driver Features:\n *\t- Tagged command queuing\n *\t- Adapter microcode download\n *\t- PCI hot plug\n *\t- SCSI device hot plug\n *\n */\n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/libata.h>\n#include <linux/hdreg.h>\n#include <linux/reboot.h>\n#include <linux/stringify.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_cmnd.h>\n#include \"ipr.h\"\n\n/*\n *   Global Data\n */\nstatic LIST_HEAD(ipr_ioa_head);\nstatic unsigned int ipr_log_level = IPR_DEFAULT_LOG_LEVEL;\nstatic unsigned int ipr_max_speed = 1;\nstatic int ipr_testmode = 0;\nstatic unsigned int ipr_fastfail = 0;\nstatic unsigned int ipr_transop_timeout = 0;\nstatic unsigned int ipr_debug = 0;\nstatic unsigned int ipr_max_devs = IPR_DEFAULT_SIS64_DEVS;\nstatic unsigned int ipr_dual_ioa_raid = 1;\nstatic unsigned int ipr_number_of_msix = 16;\nstatic unsigned int ipr_fast_reboot;\nstatic DEFINE_SPINLOCK(ipr_driver_lock);\n\n/* This table describes the differences between DMA controller chips */\nstatic const struct ipr_chip_cfg_t ipr_chip_cfg[] = {\n\t{ /* Gemstone, Citrine, Obsidian, and Obsidian-E */\n\t\t.mailbox = 0x0042C,\n\t\t.max_cmds = 100,\n\t\t.cache_line_size = 0x20,\n\t\t.clear_isr = 1,\n\t\t.iopoll_weight = 0,\n\t\t{\n\t\t\t.set_interrupt_mask_reg = 0x0022C,\n\t\t\t.clr_interrupt_mask_reg = 0x00230,\n\t\t\t.clr_interrupt_mask_reg32 = 0x00230,\n\t\t\t.sense_interrupt_mask_reg = 0x0022C,\n\t\t\t.sense_interrupt_mask_reg32 = 0x0022C,\n\t\t\t.clr_interrupt_reg = 0x00228,\n\t\t\t.clr_interrupt_reg32 = 0x00228,\n\t\t\t.sense_interrupt_reg = 0x00224,\n\t\t\t.sense_interrupt_reg32 = 0x00224,\n\t\t\t.ioarrin_reg = 0x00404,\n\t\t\t.sense_uproc_interrupt_reg = 0x00214,\n\t\t\t.sense_uproc_interrupt_reg32 = 0x00214,\n\t\t\t.set_uproc_interrupt_reg = 0x00214,\n\t\t\t.set_uproc_interrupt_reg32 = 0x00214,\n\t\t\t.clr_uproc_interrupt_reg = 0x00218,\n\t\t\t.clr_uproc_interrupt_reg32 = 0x00218\n\t\t}\n\t},\n\t{ /* Snipe and Scamp */\n\t\t.mailbox = 0x0052C,\n\t\t.max_cmds = 100,\n\t\t.cache_line_size = 0x20,\n\t\t.clear_isr = 1,\n\t\t.iopoll_weight = 0,\n\t\t{\n\t\t\t.set_interrupt_mask_reg = 0x00288,\n\t\t\t.clr_interrupt_mask_reg = 0x0028C,\n\t\t\t.clr_interrupt_mask_reg32 = 0x0028C,\n\t\t\t.sense_interrupt_mask_reg = 0x00288,\n\t\t\t.sense_interrupt_mask_reg32 = 0x00288,\n\t\t\t.clr_interrupt_reg = 0x00284,\n\t\t\t.clr_interrupt_reg32 = 0x00284,\n\t\t\t.sense_interrupt_reg = 0x00280,\n\t\t\t.sense_interrupt_reg32 = 0x00280,\n\t\t\t.ioarrin_reg = 0x00504,\n\t\t\t.sense_uproc_interrupt_reg = 0x00290,\n\t\t\t.sense_uproc_interrupt_reg32 = 0x00290,\n\t\t\t.set_uproc_interrupt_reg = 0x00290,\n\t\t\t.set_uproc_interrupt_reg32 = 0x00290,\n\t\t\t.clr_uproc_interrupt_reg = 0x00294,\n\t\t\t.clr_uproc_interrupt_reg32 = 0x00294\n\t\t}\n\t},\n\t{ /* CRoC */\n\t\t.mailbox = 0x00044,\n\t\t.max_cmds = 1000,\n\t\t.cache_line_size = 0x20,\n\t\t.clear_isr = 0,\n\t\t.iopoll_weight = 64,\n\t\t{\n\t\t\t.set_interrupt_mask_reg = 0x00010,\n\t\t\t.clr_interrupt_mask_reg = 0x00018,\n\t\t\t.clr_interrupt_mask_reg32 = 0x0001C,\n\t\t\t.sense_interrupt_mask_reg = 0x00010,\n\t\t\t.sense_interrupt_mask_reg32 = 0x00014,\n\t\t\t.clr_interrupt_reg = 0x00008,\n\t\t\t.clr_interrupt_reg32 = 0x0000C,\n\t\t\t.sense_interrupt_reg = 0x00000,\n\t\t\t.sense_interrupt_reg32 = 0x00004,\n\t\t\t.ioarrin_reg = 0x00070,\n\t\t\t.sense_uproc_interrupt_reg = 0x00020,\n\t\t\t.sense_uproc_interrupt_reg32 = 0x00024,\n\t\t\t.set_uproc_interrupt_reg = 0x00020,\n\t\t\t.set_uproc_interrupt_reg32 = 0x00024,\n\t\t\t.clr_uproc_interrupt_reg = 0x00028,\n\t\t\t.clr_uproc_interrupt_reg32 = 0x0002C,\n\t\t\t.init_feedback_reg = 0x0005C,\n\t\t\t.dump_addr_reg = 0x00064,\n\t\t\t.dump_data_reg = 0x00068,\n\t\t\t.endian_swap_reg = 0x00084\n\t\t}\n\t},\n};\n\nstatic const struct ipr_chip_t ipr_chip[] = {\n\t{ PCI_VENDOR_ID_MYLEX, PCI_DEVICE_ID_IBM_GEMSTONE, false, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[0] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CITRINE, false, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[0] },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_OBSIDIAN, false, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[0] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN, false, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[0] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN_E, true, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[0] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_SNIPE, false, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[1] },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_SCAMP, false, IPR_SIS32, IPR_PCI_CFG, &ipr_chip_cfg[1] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2, true, IPR_SIS64, IPR_MMIO, &ipr_chip_cfg[2] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE, true, IPR_SIS64, IPR_MMIO, &ipr_chip_cfg[2] },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_RATTLESNAKE, true, IPR_SIS64, IPR_MMIO, &ipr_chip_cfg[2] }\n};\n\nstatic int ipr_max_bus_speeds[] = {\n\tIPR_80MBs_SCSI_RATE, IPR_U160_SCSI_RATE, IPR_U320_SCSI_RATE\n};\n\nMODULE_AUTHOR(\"Brian King <brking@us.ibm.com>\");\nMODULE_DESCRIPTION(\"IBM Power RAID SCSI Adapter Driver\");\nmodule_param_named(max_speed, ipr_max_speed, uint, 0);\nMODULE_PARM_DESC(max_speed, \"Maximum bus speed (0-2). Default: 1=U160. Speeds: 0=80 MB/s, 1=U160, 2=U320\");\nmodule_param_named(log_level, ipr_log_level, uint, 0);\nMODULE_PARM_DESC(log_level, \"Set to 0 - 4 for increasing verbosity of device driver\");\nmodule_param_named(testmode, ipr_testmode, int, 0);\nMODULE_PARM_DESC(testmode, \"DANGEROUS!!! Allows unsupported configurations\");\nmodule_param_named(fastfail, ipr_fastfail, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(fastfail, \"Reduce timeouts and retries\");\nmodule_param_named(transop_timeout, ipr_transop_timeout, int, 0);\nMODULE_PARM_DESC(transop_timeout, \"Time in seconds to wait for adapter to come operational (default: 300)\");\nmodule_param_named(debug, ipr_debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Enable device driver debugging logging. Set to 1 to enable. (default: 0)\");\nmodule_param_named(dual_ioa_raid, ipr_dual_ioa_raid, int, 0);\nMODULE_PARM_DESC(dual_ioa_raid, \"Enable dual adapter RAID support. Set to 1 to enable. (default: 1)\");\nmodule_param_named(max_devs, ipr_max_devs, int, 0);\nMODULE_PARM_DESC(max_devs, \"Specify the maximum number of physical devices. \"\n\t\t \"[Default=\" __stringify(IPR_DEFAULT_SIS64_DEVS) \"]\");\nmodule_param_named(number_of_msix, ipr_number_of_msix, int, 0);\nMODULE_PARM_DESC(number_of_msix, \"Specify the number of MSIX interrupts to use on capable adapters (1 - 16).  (default:16)\");\nmodule_param_named(fast_reboot, ipr_fast_reboot, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(fast_reboot, \"Skip adapter shutdown during reboot. Set to 1 to enable. (default: 0)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(IPR_DRIVER_VERSION);\n\n/*  A constant array of IOASCs/URCs/Error Messages */\nstatic const\nstruct ipr_error_table_t ipr_error_table[] = {\n\t{0x00000000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"8155: An unknown error was received\"},\n\t{0x00330000, 0, 0,\n\t\"Soft underlength error\"},\n\t{0x005A0000, 0, 0,\n\t\"Command to be cancelled not found\"},\n\t{0x00808000, 0, 0,\n\t\"Qualified success\"},\n\t{0x01080000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFE: Soft device bus error recovered by the IOA\"},\n\t{0x01088100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4101: Soft device bus fabric error\"},\n\t{0x01100100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFC: Logical block guard error recovered by the device\"},\n\t{0x01100300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFC: Logical block reference tag error recovered by the device\"},\n\t{0x01108300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4171: Recovered scatter list tag / sequence number error\"},\n\t{0x01109000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FF3D: Recovered logical block CRC error on IOA to Host transfer\"},\n\t{0x01109200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4171: Recovered logical block sequence number error on IOA to Host transfer\"},\n\t{0x0110A000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFD: Recovered logical block reference tag error detected by the IOA\"},\n\t{0x0110A100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFD: Logical block guard error recovered by the IOA\"},\n\t{0x01170600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF9: Device sector reassign successful\"},\n\t{0x01170900, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF7: Media error recovered by device rewrite procedures\"},\n\t{0x01180200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"7001: IOA sector reassignment successful\"},\n\t{0x01180500, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF9: Soft media error. Sector reassignment recommended\"},\n\t{0x01180600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF7: Media error recovered by IOA rewrite procedures\"},\n\t{0x01418000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FF3D: Soft PCI bus error recovered by the IOA\"},\n\t{0x01440000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF6: Device hardware error recovered by the IOA\"},\n\t{0x01448100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF6: Device hardware error recovered by the device\"},\n\t{0x01448200, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FF3D: Soft IOA error recovered by the IOA\"},\n\t{0x01448300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFA: Undefined device response recovered by the IOA\"},\n\t{0x014A0000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF6: Device bus error, message or command phase\"},\n\t{0x014A8000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFE: Task Management Function failed\"},\n\t{0x015D0000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF6: Failure prediction threshold exceeded\"},\n\t{0x015D9200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"8009: Impending cache battery pack failure\"},\n\t{0x02040100, 0, 0,\n\t\"Logical Unit in process of becoming ready\"},\n\t{0x02040200, 0, 0,\n\t\"Initializing command required\"},\n\t{0x02040400, 0, 0,\n\t\"34FF: Disk device format in progress\"},\n\t{0x02040C00, 0, 0,\n\t\"Logical unit not accessible, target port in unavailable state\"},\n\t{0x02048000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9070: IOA requested reset\"},\n\t{0x023F0000, 0, 0,\n\t\"Synchronization required\"},\n\t{0x02408500, 0, 0,\n\t\"IOA microcode download required\"},\n\t{0x02408600, 0, 0,\n\t\"Device bus connection is prohibited by host\"},\n\t{0x024E0000, 0, 0,\n\t\"No ready, IOA shutdown\"},\n\t{0x025A0000, 0, 0,\n\t\"Not ready, IOA has been shutdown\"},\n\t{0x02670100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3020: Storage subsystem configuration error\"},\n\t{0x03110B00, 0, 0,\n\t\"FFF5: Medium error, data unreadable, recommend reassign\"},\n\t{0x03110C00, 0, 0,\n\t\"7000: Medium error, data unreadable, do not reassign\"},\n\t{0x03310000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF3: Disk media format bad\"},\n\t{0x04050000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3002: Addressed device failed to respond to selection\"},\n\t{0x04080000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"3100: Device bus error\"},\n\t{0x04080100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3109: IOA timed out a device command\"},\n\t{0x04088000, 0, 0,\n\t\"3120: SCSI bus is not operational\"},\n\t{0x04088100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4100: Hard device bus fabric error\"},\n\t{0x04100100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"310C: Logical block guard error detected by the device\"},\n\t{0x04100300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"310C: Logical block reference tag error detected by the device\"},\n\t{0x04108300, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"4170: Scatter list tag / sequence number error\"},\n\t{0x04109000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"8150: Logical block CRC error on IOA to Host transfer\"},\n\t{0x04109200, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"4170: Logical block sequence number error on IOA to Host transfer\"},\n\t{0x0410A000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"310D: Logical block reference tag error detected by the IOA\"},\n\t{0x0410A100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"310D: Logical block guard error detected by the IOA\"},\n\t{0x04118000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9000: IOA reserved area data check\"},\n\t{0x04118100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9001: IOA reserved area invalid data pattern\"},\n\t{0x04118200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9002: IOA reserved area LRC error\"},\n\t{0x04118300, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"Hardware Error, IOA metadata access error\"},\n\t{0x04320000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"102E: Out of alternate sectors for disk storage\"},\n\t{0x04330000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF4: Data transfer underlength error\"},\n\t{0x04338000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF4: Data transfer overlength error\"},\n\t{0x043E0100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3400: Logical unit failure\"},\n\t{0x04408500, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF4: Device microcode is corrupt\"},\n\t{0x04418000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"8150: PCI bus error\"},\n\t{0x04430000, 1, 0,\n\t\"Unsupported device bus message received\"},\n\t{0x04440000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF4: Disk device problem\"},\n\t{0x04448200, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"8150: Permanent IOA failure\"},\n\t{0x04448300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3010: Disk device returned wrong response to IOA\"},\n\t{0x04448400, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"8151: IOA microcode error\"},\n\t{0x04448500, 0, 0,\n\t\"Device bus status error\"},\n\t{0x04448600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"8157: IOA error requiring IOA reset to recover\"},\n\t{0x04448700, 0, 0,\n\t\"ATA device status error\"},\n\t{0x04490000, 0, 0,\n\t\"Message reject received from the device\"},\n\t{0x04449200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"8008: A permanent cache battery pack failure occurred\"},\n\t{0x0444A000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9090: Disk unit has been modified after the last known status\"},\n\t{0x0444A200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9081: IOA detected device error\"},\n\t{0x0444A300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9082: IOA detected device error\"},\n\t{0x044A0000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"3110: Device bus error, message or command phase\"},\n\t{0x044A8000, 1, IPR_DEFAULT_LOG_LEVEL,\n\t\"3110: SAS Command / Task Management Function failed\"},\n\t{0x04670400, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9091: Incorrect hardware configuration change has been detected\"},\n\t{0x04678000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9073: Invalid multi-adapter configuration\"},\n\t{0x04678100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4010: Incorrect connection between cascaded expanders\"},\n\t{0x04678200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4020: Connections exceed IOA design limits\"},\n\t{0x04678300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4030: Incorrect multipath connection\"},\n\t{0x04679000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4110: Unsupported enclosure function\"},\n\t{0x04679800, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4120: SAS cable VPD cannot be read\"},\n\t{0x046E0000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFF4: Command to logical unit failed\"},\n\t{0x05240000, 1, 0,\n\t\"Illegal request, invalid request type or request packet\"},\n\t{0x05250000, 0, 0,\n\t\"Illegal request, invalid resource handle\"},\n\t{0x05258000, 0, 0,\n\t\"Illegal request, commands not allowed to this device\"},\n\t{0x05258100, 0, 0,\n\t\"Illegal request, command not allowed to a secondary adapter\"},\n\t{0x05258200, 0, 0,\n\t\"Illegal request, command not allowed to a non-optimized resource\"},\n\t{0x05260000, 0, 0,\n\t\"Illegal request, invalid field in parameter list\"},\n\t{0x05260100, 0, 0,\n\t\"Illegal request, parameter not supported\"},\n\t{0x05260200, 0, 0,\n\t\"Illegal request, parameter value invalid\"},\n\t{0x052C0000, 0, 0,\n\t\"Illegal request, command sequence error\"},\n\t{0x052C8000, 1, 0,\n\t\"Illegal request, dual adapter support not enabled\"},\n\t{0x052C8100, 1, 0,\n\t\"Illegal request, another cable connector was physically disabled\"},\n\t{0x054E8000, 1, 0,\n\t\"Illegal request, inconsistent group id/group count\"},\n\t{0x06040500, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9031: Array protection temporarily suspended, protection resuming\"},\n\t{0x06040600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9040: Array protection temporarily suspended, protection resuming\"},\n\t{0x060B0100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4080: IOA exceeded maximum operating temperature\"},\n\t{0x060B8000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4085: Service required\"},\n\t{0x060B8100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4086: SAS Adapter Hardware Configuration Error\"},\n\t{0x06288000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3140: Device bus not ready to ready transition\"},\n\t{0x06290000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFB: SCSI bus was reset\"},\n\t{0x06290500, 0, 0,\n\t\"FFFE: SCSI bus transition to single ended\"},\n\t{0x06290600, 0, 0,\n\t\"FFFE: SCSI bus transition to LVD\"},\n\t{0x06298000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"FFFB: SCSI bus was reset by another initiator\"},\n\t{0x063F0300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3029: A device replacement has occurred\"},\n\t{0x063F8300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4102: Device bus fabric performance degradation\"},\n\t{0x064C8000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9051: IOA cache data exists for a missing or failed device\"},\n\t{0x064C8100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9055: Auxiliary cache IOA contains cache data needed by the primary IOA\"},\n\t{0x06670100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9025: Disk unit is not supported at its physical location\"},\n\t{0x06670600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3020: IOA detected a SCSI bus configuration error\"},\n\t{0x06678000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"3150: SCSI bus configuration error\"},\n\t{0x06678100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9074: Asymmetric advanced function disk configuration\"},\n\t{0x06678300, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4040: Incomplete multipath connection between IOA and enclosure\"},\n\t{0x06678400, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4041: Incomplete multipath connection between enclosure and device\"},\n\t{0x06678500, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9075: Incomplete multipath connection between IOA and remote IOA\"},\n\t{0x06678600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9076: Configuration error, missing remote IOA\"},\n\t{0x06679100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4050: Enclosure does not support a required multipath function\"},\n\t{0x06679800, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4121: Configuration error, required cable is missing\"},\n\t{0x06679900, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4122: Cable is not plugged into the correct location on remote IOA\"},\n\t{0x06679A00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4123: Configuration error, invalid cable vital product data\"},\n\t{0x06679B00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4124: Configuration error, both cable ends are plugged into the same IOA\"},\n\t{0x06690000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4070: Logically bad block written on device\"},\n\t{0x06690200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9041: Array protection temporarily suspended\"},\n\t{0x06698200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9042: Corrupt array parity detected on specified device\"},\n\t{0x066B0200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9030: Array no longer protected due to missing or failed disk unit\"},\n\t{0x066B8000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9071: Link operational transition\"},\n\t{0x066B8100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9072: Link not operational transition\"},\n\t{0x066B8200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9032: Array exposed but still protected\"},\n\t{0x066B8300, 0, IPR_DEBUG_LOG_LEVEL,\n\t\"70DD: Device forced failed by disrupt device command\"},\n\t{0x066B9100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4061: Multipath redundancy level got better\"},\n\t{0x066B9200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"4060: Multipath redundancy level got worse\"},\n\t{0x06808100, 0, IPR_DEBUG_LOG_LEVEL,\n\t\"9083: Device raw mode enabled\"},\n\t{0x06808200, 0, IPR_DEBUG_LOG_LEVEL,\n\t\"9084: Device raw mode disabled\"},\n\t{0x07270000, 0, 0,\n\t\"Failure due to other device\"},\n\t{0x07278000, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9008: IOA does not support functions expected by devices\"},\n\t{0x07278100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9010: Cache data associated with attached devices cannot be found\"},\n\t{0x07278200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9011: Cache data belongs to devices other than those attached\"},\n\t{0x07278400, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9020: Array missing 2 or more devices with only 1 device present\"},\n\t{0x07278500, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9021: Array missing 2 or more devices with 2 or more devices present\"},\n\t{0x07278600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9022: Exposed array is missing a required device\"},\n\t{0x07278700, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9023: Array member(s) not at required physical locations\"},\n\t{0x07278800, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9024: Array not functional due to present hardware configuration\"},\n\t{0x07278900, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9026: Array not functional due to present hardware configuration\"},\n\t{0x07278A00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9027: Array is missing a device and parity is out of sync\"},\n\t{0x07278B00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9028: Maximum number of arrays already exist\"},\n\t{0x07278C00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9050: Required cache data cannot be located for a disk unit\"},\n\t{0x07278D00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9052: Cache data exists for a device that has been modified\"},\n\t{0x07278F00, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9054: IOA resources not available due to previous problems\"},\n\t{0x07279100, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9092: Disk unit requires initialization before use\"},\n\t{0x07279200, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9029: Incorrect hardware configuration change has been detected\"},\n\t{0x07279600, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9060: One or more disk pairs are missing from an array\"},\n\t{0x07279700, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9061: One or more disks are missing from an array\"},\n\t{0x07279800, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9062: One or more disks are missing from an array\"},\n\t{0x07279900, 0, IPR_DEFAULT_LOG_LEVEL,\n\t\"9063: Maximum number of functional arrays has been exceeded\"},\n\t{0x07279A00, 0, 0,\n\t\"Data protect, other volume set problem\"},\n\t{0x0B260000, 0, 0,\n\t\"Aborted command, invalid descriptor\"},\n\t{0x0B3F9000, 0, 0,\n\t\"Target operating conditions have changed, dual adapter takeover\"},\n\t{0x0B530200, 0, 0,\n\t\"Aborted command, medium removal prevented\"},\n\t{0x0B5A0000, 0, 0,\n\t\"Command terminated by host\"},\n\t{0x0B5B8000, 0, 0,\n\t\"Aborted command, command terminated by host\"}\n};\n\nstatic const struct ipr_ses_table_entry ipr_ses_table[] = {\n\t{ \"2104-DL1        \", \"XXXXXXXXXXXXXXXX\", 80 },\n\t{ \"2104-TL1        \", \"XXXXXXXXXXXXXXXX\", 80 },\n\t{ \"HSBP07M P U2SCSI\", \"XXXXXXXXXXXXXXXX\", 80 }, /* Hidive 7 slot */\n\t{ \"HSBP05M P U2SCSI\", \"XXXXXXXXXXXXXXXX\", 80 }, /* Hidive 5 slot */\n\t{ \"HSBP05M S U2SCSI\", \"XXXXXXXXXXXXXXXX\", 80 }, /* Bowtie */\n\t{ \"HSBP06E ASU2SCSI\", \"XXXXXXXXXXXXXXXX\", 80 }, /* MartinFenning */\n\t{ \"2104-DU3        \", \"XXXXXXXXXXXXXXXX\", 160 },\n\t{ \"2104-TU3        \", \"XXXXXXXXXXXXXXXX\", 160 },\n\t{ \"HSBP04C RSU2SCSI\", \"XXXXXXX*XXXXXXXX\", 160 },\n\t{ \"HSBP06E RSU2SCSI\", \"XXXXXXX*XXXXXXXX\", 160 },\n\t{ \"St  V1S2        \", \"XXXXXXXXXXXXXXXX\", 160 },\n\t{ \"HSBPD4M  PU3SCSI\", \"XXXXXXX*XXXXXXXX\", 160 },\n\t{ \"VSBPD1H   U3SCSI\", \"XXXXXXX*XXXXXXXX\", 160 }\n};\n\n/*\n *  Function Prototypes\n */\nstatic int ipr_reset_alert(struct ipr_cmnd *);\nstatic void ipr_process_ccn(struct ipr_cmnd *);\nstatic void ipr_process_error(struct ipr_cmnd *);\nstatic void ipr_reset_ioa_job(struct ipr_cmnd *);\nstatic void ipr_initiate_ioa_reset(struct ipr_ioa_cfg *,\n\t\t\t\t   enum ipr_shutdown_type);\n\n#ifdef CONFIG_SCSI_IPR_TRACE\n/**\n * ipr_trc_hook - Add a trace entry to the driver trace\n * @ipr_cmd:\tipr command struct\n * @type:\t\ttrace type\n * @add_data:\tadditional data\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_trc_hook(struct ipr_cmnd *ipr_cmd,\n\t\t\t u8 type, u32 add_data)\n{\n\tstruct ipr_trace_entry *trace_entry;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tunsigned int trace_index;\n\n\ttrace_index = atomic_add_return(1, &ioa_cfg->trace_index) & IPR_TRACE_INDEX_MASK;\n\ttrace_entry = &ioa_cfg->trace[trace_index];\n\ttrace_entry->time = jiffies;\n\ttrace_entry->op_code = ipr_cmd->ioarcb.cmd_pkt.cdb[0];\n\ttrace_entry->type = type;\n\tif (ipr_cmd->ioa_cfg->sis64)\n\t\ttrace_entry->ata_op_code = ipr_cmd->i.ata_ioadl.regs.command;\n\telse\n\t\ttrace_entry->ata_op_code = ipr_cmd->ioarcb.u.add_data.u.regs.command;\n\ttrace_entry->cmd_index = ipr_cmd->cmd_index & 0xff;\n\ttrace_entry->res_handle = ipr_cmd->ioarcb.res_handle;\n\ttrace_entry->u.add_data = add_data;\n\twmb();\n}\n#else\n#define ipr_trc_hook(ipr_cmd, type, add_data) do { } while (0)\n#endif\n\n/**\n * ipr_lock_and_done - Acquire lock and complete command\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n *\tnone\n **/\nstatic void ipr_lock_and_done(struct ipr_cmnd *ipr_cmd)\n{\n\tunsigned long lock_flags;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tipr_cmd->done(ipr_cmd);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n}\n\n/**\n * ipr_reinit_ipr_cmnd - Re-initialize an IPR Cmnd block for reuse\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_reinit_ipr_cmnd(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioasa *ioasa = &ipr_cmd->s.ioasa;\n\tstruct ipr_ioasa64 *ioasa64 = &ipr_cmd->s.ioasa64;\n\tdma_addr_t dma_addr = ipr_cmd->dma_addr;\n\tint hrrq_id;\n\n\thrrq_id = ioarcb->cmd_pkt.hrrq_id;\n\tmemset(&ioarcb->cmd_pkt, 0, sizeof(struct ipr_cmd_pkt));\n\tioarcb->cmd_pkt.hrrq_id = hrrq_id;\n\tioarcb->data_transfer_length = 0;\n\tioarcb->read_data_transfer_length = 0;\n\tioarcb->ioadl_len = 0;\n\tioarcb->read_ioadl_len = 0;\n\n\tif (ipr_cmd->ioa_cfg->sis64) {\n\t\tioarcb->u.sis64_addr_data.data_ioadl_addr =\n\t\t\tcpu_to_be64(dma_addr + offsetof(struct ipr_cmnd, i.ioadl64));\n\t\tioasa64->u.gata.status = 0;\n\t} else {\n\t\tioarcb->write_ioadl_addr =\n\t\t\tcpu_to_be32(dma_addr + offsetof(struct ipr_cmnd, i.ioadl));\n\t\tioarcb->read_ioadl_addr = ioarcb->write_ioadl_addr;\n\t\tioasa->u.gata.status = 0;\n\t}\n\n\tioasa->hdr.ioasc = 0;\n\tioasa->hdr.residual_data_len = 0;\n\tipr_cmd->scsi_cmd = NULL;\n\tipr_cmd->qc = NULL;\n\tipr_cmd->sense_buffer[0] = 0;\n\tipr_cmd->dma_use_sg = 0;\n}\n\n/**\n * ipr_init_ipr_cmnd - Initialize an IPR Cmnd block\n * @ipr_cmd:\tipr command struct\n * @fast_done:\tfast done function call-back\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_init_ipr_cmnd(struct ipr_cmnd *ipr_cmd,\n\t\t\t      void (*fast_done) (struct ipr_cmnd *))\n{\n\tipr_reinit_ipr_cmnd(ipr_cmd);\n\tipr_cmd->u.scratch = 0;\n\tipr_cmd->sibling = NULL;\n\tipr_cmd->eh_comp = NULL;\n\tipr_cmd->fast_done = fast_done;\n\ttimer_setup(&ipr_cmd->timer, NULL, 0);\n}\n\n/**\n * __ipr_get_free_ipr_cmnd - Get a free IPR Cmnd block\n * @hrrq:\thrr queue\n *\n * Return value:\n * \tpointer to ipr command struct\n **/\nstatic\nstruct ipr_cmnd *__ipr_get_free_ipr_cmnd(struct ipr_hrr_queue *hrrq)\n{\n\tstruct ipr_cmnd *ipr_cmd = NULL;\n\n\tif (likely(!list_empty(&hrrq->hrrq_free_q))) {\n\t\tipr_cmd = list_entry(hrrq->hrrq_free_q.next,\n\t\t\tstruct ipr_cmnd, queue);\n\t\tlist_del(&ipr_cmd->queue);\n\t}\n\n\n\treturn ipr_cmd;\n}\n\n/**\n * ipr_get_free_ipr_cmnd - Get a free IPR Cmnd block and initialize it\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n *\tpointer to ipr command struct\n **/\nstatic\nstruct ipr_cmnd *ipr_get_free_ipr_cmnd(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct ipr_cmnd *ipr_cmd =\n\t\t__ipr_get_free_ipr_cmnd(&ioa_cfg->hrrq[IPR_INIT_HRRQ]);\n\tipr_init_ipr_cmnd(ipr_cmd, ipr_lock_and_done);\n\treturn ipr_cmd;\n}\n\n/**\n * ipr_mask_and_clear_interrupts - Mask all and clear specified interrupts\n * @ioa_cfg:\tioa config struct\n * @clr_ints:     interrupts to clear\n *\n * This function masks all interrupts on the adapter, then clears the\n * interrupts specified in the mask\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_mask_and_clear_interrupts(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t  u32 clr_ints)\n{\n\tint i;\n\n\t/* Stop new interrupts */\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\tioa_cfg->hrrq[i].allow_interrupts = 0;\n\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t}\n\n\t/* Set interrupt mask to stop all new interrupts */\n\tif (ioa_cfg->sis64)\n\t\twriteq(~0, ioa_cfg->regs.set_interrupt_mask_reg);\n\telse\n\t\twritel(~0, ioa_cfg->regs.set_interrupt_mask_reg);\n\n\t/* Clear any pending interrupts */\n\tif (ioa_cfg->sis64)\n\t\twritel(~0, ioa_cfg->regs.clr_interrupt_reg);\n\twritel(clr_ints, ioa_cfg->regs.clr_interrupt_reg32);\n\treadl(ioa_cfg->regs.sense_interrupt_reg);\n}\n\n/**\n * ipr_save_pcix_cmd_reg - Save PCI-X command register\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \t0 on success / -EIO on failure\n **/\nstatic int ipr_save_pcix_cmd_reg(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint pcix_cmd_reg = pci_find_capability(ioa_cfg->pdev, PCI_CAP_ID_PCIX);\n\n\tif (pcix_cmd_reg == 0)\n\t\treturn 0;\n\n\tif (pci_read_config_word(ioa_cfg->pdev, pcix_cmd_reg + PCI_X_CMD,\n\t\t\t\t &ioa_cfg->saved_pcix_cmd_reg) != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(&ioa_cfg->pdev->dev, \"Failed to save PCI-X command register\\n\");\n\t\treturn -EIO;\n\t}\n\n\tioa_cfg->saved_pcix_cmd_reg |= PCI_X_CMD_DPERR_E | PCI_X_CMD_ERO;\n\treturn 0;\n}\n\n/**\n * ipr_set_pcix_cmd_reg - Setup PCI-X command register\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \t0 on success / -EIO on failure\n **/\nstatic int ipr_set_pcix_cmd_reg(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint pcix_cmd_reg = pci_find_capability(ioa_cfg->pdev, PCI_CAP_ID_PCIX);\n\n\tif (pcix_cmd_reg) {\n\t\tif (pci_write_config_word(ioa_cfg->pdev, pcix_cmd_reg + PCI_X_CMD,\n\t\t\t\t\t  ioa_cfg->saved_pcix_cmd_reg) != PCIBIOS_SUCCESSFUL) {\n\t\t\tdev_err(&ioa_cfg->pdev->dev, \"Failed to setup PCI-X command register\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * __ipr_sata_eh_done - done function for aborted SATA commands\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked for ops generated to SATA\n * devices which are being aborted.\n *\n * Return value:\n * \tnone\n **/\nstatic void __ipr_sata_eh_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ata_queued_cmd *qc = ipr_cmd->qc;\n\tstruct ipr_sata_port *sata_port = qc->ap->private_data;\n\n\tqc->err_mask |= AC_ERR_OTHER;\n\tsata_port->ioasa.status |= ATA_BUSY;\n\tata_qc_complete(qc);\n\tif (ipr_cmd->eh_comp)\n\t\tcomplete(ipr_cmd->eh_comp);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n}\n\n/**\n * ipr_sata_eh_done - done function for aborted SATA commands\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked for ops generated to SATA\n * devices which are being aborted.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_sata_eh_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_hrr_queue *hrrq = ipr_cmd->hrrq;\n\tunsigned long hrrq_flags;\n\n\tspin_lock_irqsave(&hrrq->_lock, hrrq_flags);\n\t__ipr_sata_eh_done(ipr_cmd);\n\tspin_unlock_irqrestore(&hrrq->_lock, hrrq_flags);\n}\n\n/**\n * __ipr_scsi_eh_done - mid-layer done function for aborted ops\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked by the interrupt handler for\n * ops generated by the SCSI mid-layer which are being aborted.\n *\n * Return value:\n * \tnone\n **/\nstatic void __ipr_scsi_eh_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\n\tscsi_cmd->result |= (DID_ERROR << 16);\n\n\tscsi_dma_unmap(ipr_cmd->scsi_cmd);\n\tscsi_cmd->scsi_done(scsi_cmd);\n\tif (ipr_cmd->eh_comp)\n\t\tcomplete(ipr_cmd->eh_comp);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n}\n\n/**\n * ipr_scsi_eh_done - mid-layer done function for aborted ops\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked by the interrupt handler for\n * ops generated by the SCSI mid-layer which are being aborted.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_scsi_eh_done(struct ipr_cmnd *ipr_cmd)\n{\n\tunsigned long hrrq_flags;\n\tstruct ipr_hrr_queue *hrrq = ipr_cmd->hrrq;\n\n\tspin_lock_irqsave(&hrrq->_lock, hrrq_flags);\n\t__ipr_scsi_eh_done(ipr_cmd);\n\tspin_unlock_irqrestore(&hrrq->_lock, hrrq_flags);\n}\n\n/**\n * ipr_fail_all_ops - Fails all outstanding ops.\n * @ioa_cfg:\tioa config struct\n *\n * This function fails all outstanding ops.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_fail_all_ops(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct ipr_cmnd *ipr_cmd, *temp;\n\tstruct ipr_hrr_queue *hrrq;\n\n\tENTER;\n\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\tspin_lock(&hrrq->_lock);\n\t\tlist_for_each_entry_safe(ipr_cmd,\n\t\t\t\t\ttemp, &hrrq->hrrq_pending_q, queue) {\n\t\t\tlist_del(&ipr_cmd->queue);\n\n\t\t\tipr_cmd->s.ioasa.hdr.ioasc =\n\t\t\t\tcpu_to_be32(IPR_IOASC_IOA_WAS_RESET);\n\t\t\tipr_cmd->s.ioasa.hdr.ilid =\n\t\t\t\tcpu_to_be32(IPR_DRIVER_ILID);\n\n\t\t\tif (ipr_cmd->scsi_cmd)\n\t\t\t\tipr_cmd->done = __ipr_scsi_eh_done;\n\t\t\telse if (ipr_cmd->qc)\n\t\t\t\tipr_cmd->done = __ipr_sata_eh_done;\n\n\t\t\tipr_trc_hook(ipr_cmd, IPR_TRACE_FINISH,\n\t\t\t\t     IPR_IOASC_IOA_WAS_RESET);\n\t\t\tdel_timer(&ipr_cmd->timer);\n\t\t\tipr_cmd->done(ipr_cmd);\n\t\t}\n\t\tspin_unlock(&hrrq->_lock);\n\t}\n\tLEAVE;\n}\n\n/**\n * ipr_send_command -  Send driver initiated requests.\n * @ipr_cmd:\t\tipr command struct\n *\n * This function sends a command to the adapter using the correct write call.\n * In the case of sis64, calculate the ioarcb size required. Then or in the\n * appropriate bits.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_send_command(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tdma_addr_t send_dma_addr = ipr_cmd->dma_addr;\n\n\tif (ioa_cfg->sis64) {\n\t\t/* The default size is 256 bytes */\n\t\tsend_dma_addr |= 0x1;\n\n\t\t/* If the number of ioadls * size of ioadl > 128 bytes,\n\t\t   then use a 512 byte ioarcb */\n\t\tif (ipr_cmd->dma_use_sg * sizeof(struct ipr_ioadl64_desc) > 128 )\n\t\t\tsend_dma_addr |= 0x4;\n\t\twriteq(send_dma_addr, ioa_cfg->regs.ioarrin_reg);\n\t} else\n\t\twritel(send_dma_addr, ioa_cfg->regs.ioarrin_reg);\n}\n\n/**\n * ipr_do_req -  Send driver initiated requests.\n * @ipr_cmd:\t\tipr command struct\n * @done:\t\t\tdone function\n * @timeout_func:\ttimeout function\n * @timeout:\t\ttimeout value\n *\n * This function sends the specified command to the adapter with the\n * timeout given. The done function is invoked on command completion.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_do_req(struct ipr_cmnd *ipr_cmd,\n\t\t       void (*done) (struct ipr_cmnd *),\n\t\t       void (*timeout_func) (struct timer_list *), u32 timeout)\n{\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\n\tipr_cmd->done = done;\n\n\tipr_cmd->timer.expires = jiffies + timeout;\n\tipr_cmd->timer.function = timeout_func;\n\n\tadd_timer(&ipr_cmd->timer);\n\n\tipr_trc_hook(ipr_cmd, IPR_TRACE_START, 0);\n\n\tipr_send_command(ipr_cmd);\n}\n\n/**\n * ipr_internal_cmd_done - Op done function for an internally generated op.\n * @ipr_cmd:\tipr command struct\n *\n * This function is the op done function for an internally generated,\n * blocking op. It simply wakes the sleeping thread.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_internal_cmd_done(struct ipr_cmnd *ipr_cmd)\n{\n\tif (ipr_cmd->sibling)\n\t\tipr_cmd->sibling = NULL;\n\telse\n\t\tcomplete(&ipr_cmd->completion);\n}\n\n/**\n * ipr_init_ioadl - initialize the ioadl for the correct SIS type\n * @ipr_cmd:\tipr command struct\n * @dma_addr:\tdma address\n * @len:\ttransfer length\n * @flags:\tioadl flag value\n *\n * This function initializes an ioadl in the case where there is only a single\n * descriptor.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_init_ioadl(struct ipr_cmnd *ipr_cmd, dma_addr_t dma_addr,\n\t\t\t   u32 len, int flags)\n{\n\tstruct ipr_ioadl_desc *ioadl = ipr_cmd->i.ioadl;\n\tstruct ipr_ioadl64_desc *ioadl64 = ipr_cmd->i.ioadl64;\n\n\tipr_cmd->dma_use_sg = 1;\n\n\tif (ipr_cmd->ioa_cfg->sis64) {\n\t\tioadl64->flags = cpu_to_be32(flags);\n\t\tioadl64->data_len = cpu_to_be32(len);\n\t\tioadl64->address = cpu_to_be64(dma_addr);\n\n\t\tipr_cmd->ioarcb.ioadl_len =\n\t\t       \tcpu_to_be32(sizeof(struct ipr_ioadl64_desc));\n\t\tipr_cmd->ioarcb.data_transfer_length = cpu_to_be32(len);\n\t} else {\n\t\tioadl->flags_and_data_len = cpu_to_be32(flags | len);\n\t\tioadl->address = cpu_to_be32(dma_addr);\n\n\t\tif (flags == IPR_IOADL_FLAGS_READ_LAST) {\n\t\t\tipr_cmd->ioarcb.read_ioadl_len =\n\t\t\t\tcpu_to_be32(sizeof(struct ipr_ioadl_desc));\n\t\t\tipr_cmd->ioarcb.read_data_transfer_length = cpu_to_be32(len);\n\t\t} else {\n\t\t\tipr_cmd->ioarcb.ioadl_len =\n\t\t\t       \tcpu_to_be32(sizeof(struct ipr_ioadl_desc));\n\t\t\tipr_cmd->ioarcb.data_transfer_length = cpu_to_be32(len);\n\t\t}\n\t}\n}\n\n/**\n * ipr_send_blocking_cmd - Send command and sleep on its completion.\n * @ipr_cmd:\tipr command struct\n * @timeout_func:\tfunction to invoke if command times out\n * @timeout:\ttimeout\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_send_blocking_cmd(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t  void (*timeout_func) (struct timer_list *),\n\t\t\t\t  u32 timeout)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tinit_completion(&ipr_cmd->completion);\n\tipr_do_req(ipr_cmd, ipr_internal_cmd_done, timeout_func, timeout);\n\n\tspin_unlock_irq(ioa_cfg->host->host_lock);\n\twait_for_completion(&ipr_cmd->completion);\n\tspin_lock_irq(ioa_cfg->host->host_lock);\n}\n\nstatic int ipr_get_hrrq_index(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tunsigned int hrrq;\n\n\tif (ioa_cfg->hrrq_num == 1)\n\t\thrrq = 0;\n\telse {\n\t\thrrq = atomic_add_return(1, &ioa_cfg->hrrq_index);\n\t\thrrq = (hrrq % (ioa_cfg->hrrq_num - 1)) + 1;\n\t}\n\treturn hrrq;\n}\n\n/**\n * ipr_send_hcam - Send an HCAM to the adapter.\n * @ioa_cfg:\tioa config struct\n * @type:\t\tHCAM type\n * @hostrcb:\thostrcb struct\n *\n * This function will send a Host Controlled Async command to the adapter.\n * If HCAMs are currently not allowed to be issued to the adapter, it will\n * place the hostrcb on the free queue.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_send_hcam(struct ipr_ioa_cfg *ioa_cfg, u8 type,\n\t\t\t  struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioarcb *ioarcb;\n\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].allow_cmds) {\n\t\tipr_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);\n\t\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\t\tlist_add_tail(&hostrcb->queue, &ioa_cfg->hostrcb_pending_q);\n\n\t\tipr_cmd->u.hostrcb = hostrcb;\n\t\tioarcb = &ipr_cmd->ioarcb;\n\n\t\tioarcb->res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\t\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_HCAM;\n\t\tioarcb->cmd_pkt.cdb[0] = IPR_HOST_CONTROLLED_ASYNC;\n\t\tioarcb->cmd_pkt.cdb[1] = type;\n\t\tioarcb->cmd_pkt.cdb[7] = (sizeof(hostrcb->hcam) >> 8) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[8] = sizeof(hostrcb->hcam) & 0xff;\n\n\t\tipr_init_ioadl(ipr_cmd, hostrcb->hostrcb_dma,\n\t\t\t       sizeof(hostrcb->hcam), IPR_IOADL_FLAGS_READ_LAST);\n\n\t\tif (type == IPR_HCAM_CDB_OP_CODE_CONFIG_CHANGE)\n\t\t\tipr_cmd->done = ipr_process_ccn;\n\t\telse\n\t\t\tipr_cmd->done = ipr_process_error;\n\n\t\tipr_trc_hook(ipr_cmd, IPR_TRACE_START, IPR_IOA_RES_ADDR);\n\n\t\tipr_send_command(ipr_cmd);\n\t} else {\n\t\tlist_add_tail(&hostrcb->queue, &ioa_cfg->hostrcb_free_q);\n\t}\n}\n\n/**\n * ipr_update_ata_class - Update the ata class in the resource entry\n * @res:\tresource entry struct\n * @proto:\tcfgte device bus protocol value\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_update_ata_class(struct ipr_resource_entry *res, unsigned int proto)\n{\n\tswitch (proto) {\n\tcase IPR_PROTO_SATA:\n\tcase IPR_PROTO_SAS_STP:\n\t\tres->ata_class = ATA_DEV_ATA;\n\t\tbreak;\n\tcase IPR_PROTO_SATA_ATAPI:\n\tcase IPR_PROTO_SAS_STP_ATAPI:\n\t\tres->ata_class = ATA_DEV_ATAPI;\n\t\tbreak;\n\tdefault:\n\t\tres->ata_class = ATA_DEV_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n/**\n * ipr_init_res_entry - Initialize a resource entry struct.\n * @res:\tresource entry struct\n * @cfgtew:\tconfig table entry wrapper struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_init_res_entry(struct ipr_resource_entry *res,\n\t\t\t       struct ipr_config_table_entry_wrapper *cfgtew)\n{\n\tint found = 0;\n\tunsigned int proto;\n\tstruct ipr_ioa_cfg *ioa_cfg = res->ioa_cfg;\n\tstruct ipr_resource_entry *gscsi_res = NULL;\n\n\tres->needs_sync_complete = 0;\n\tres->in_erp = 0;\n\tres->add_to_ml = 0;\n\tres->del_from_ml = 0;\n\tres->resetting_device = 0;\n\tres->reset_occurred = 0;\n\tres->sdev = NULL;\n\tres->sata_port = NULL;\n\n\tif (ioa_cfg->sis64) {\n\t\tproto = cfgtew->u.cfgte64->proto;\n\t\tres->flags = be16_to_cpu(cfgtew->u.cfgte64->flags);\n\t\tres->res_flags = be16_to_cpu(cfgtew->u.cfgte64->res_flags);\n\t\tres->qmodel = IPR_QUEUEING_MODEL64(res);\n\t\tres->type = cfgtew->u.cfgte64->res_type;\n\n\t\tmemcpy(res->res_path, &cfgtew->u.cfgte64->res_path,\n\t\t\tsizeof(res->res_path));\n\n\t\tres->bus = 0;\n\t\tmemcpy(&res->dev_lun.scsi_lun, &cfgtew->u.cfgte64->lun,\n\t\t\tsizeof(res->dev_lun.scsi_lun));\n\t\tres->lun = scsilun_to_int(&res->dev_lun);\n\n\t\tif (res->type == IPR_RES_TYPE_GENERIC_SCSI) {\n\t\t\tlist_for_each_entry(gscsi_res, &ioa_cfg->used_res_q, queue) {\n\t\t\t\tif (gscsi_res->dev_id == cfgtew->u.cfgte64->dev_id) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tres->target = gscsi_res->target;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tres->target = find_first_zero_bit(ioa_cfg->target_ids,\n\t\t\t\t\t\t\t\t  ioa_cfg->max_devs_supported);\n\t\t\t\tset_bit(res->target, ioa_cfg->target_ids);\n\t\t\t}\n\t\t} else if (res->type == IPR_RES_TYPE_IOAFP) {\n\t\t\tres->bus = IPR_IOAFP_VIRTUAL_BUS;\n\t\t\tres->target = 0;\n\t\t} else if (res->type == IPR_RES_TYPE_ARRAY) {\n\t\t\tres->bus = IPR_ARRAY_VIRTUAL_BUS;\n\t\t\tres->target = find_first_zero_bit(ioa_cfg->array_ids,\n\t\t\t\t\t\t\t  ioa_cfg->max_devs_supported);\n\t\t\tset_bit(res->target, ioa_cfg->array_ids);\n\t\t} else if (res->type == IPR_RES_TYPE_VOLUME_SET) {\n\t\t\tres->bus = IPR_VSET_VIRTUAL_BUS;\n\t\t\tres->target = find_first_zero_bit(ioa_cfg->vset_ids,\n\t\t\t\t\t\t\t  ioa_cfg->max_devs_supported);\n\t\t\tset_bit(res->target, ioa_cfg->vset_ids);\n\t\t} else {\n\t\t\tres->target = find_first_zero_bit(ioa_cfg->target_ids,\n\t\t\t\t\t\t\t  ioa_cfg->max_devs_supported);\n\t\t\tset_bit(res->target, ioa_cfg->target_ids);\n\t\t}\n\t} else {\n\t\tproto = cfgtew->u.cfgte->proto;\n\t\tres->qmodel = IPR_QUEUEING_MODEL(res);\n\t\tres->flags = cfgtew->u.cfgte->flags;\n\t\tif (res->flags & IPR_IS_IOA_RESOURCE)\n\t\t\tres->type = IPR_RES_TYPE_IOAFP;\n\t\telse\n\t\t\tres->type = cfgtew->u.cfgte->rsvd_subtype & 0x0f;\n\n\t\tres->bus = cfgtew->u.cfgte->res_addr.bus;\n\t\tres->target = cfgtew->u.cfgte->res_addr.target;\n\t\tres->lun = cfgtew->u.cfgte->res_addr.lun;\n\t\tres->lun_wwn = get_unaligned_be64(cfgtew->u.cfgte->lun_wwn);\n\t}\n\n\tipr_update_ata_class(res, proto);\n}\n\n/**\n * ipr_is_same_device - Determine if two devices are the same.\n * @res:\tresource entry struct\n * @cfgtew:\tconfig table entry wrapper struct\n *\n * Return value:\n * \t1 if the devices are the same / 0 otherwise\n **/\nstatic int ipr_is_same_device(struct ipr_resource_entry *res,\n\t\t\t      struct ipr_config_table_entry_wrapper *cfgtew)\n{\n\tif (res->ioa_cfg->sis64) {\n\t\tif (!memcmp(&res->dev_id, &cfgtew->u.cfgte64->dev_id,\n\t\t\t\t\tsizeof(cfgtew->u.cfgte64->dev_id)) &&\n\t\t\t!memcmp(&res->dev_lun.scsi_lun, &cfgtew->u.cfgte64->lun,\n\t\t\t\t\tsizeof(cfgtew->u.cfgte64->lun))) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (res->bus == cfgtew->u.cfgte->res_addr.bus &&\n\t\t    res->target == cfgtew->u.cfgte->res_addr.target &&\n\t\t    res->lun == cfgtew->u.cfgte->res_addr.lun)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * __ipr_format_res_path - Format the resource path for printing.\n * @res_path:\tresource path\n * @buffer:\tbuffer\n * @len:\tlength of buffer provided\n *\n * Return value:\n * \tpointer to buffer\n **/\nstatic char *__ipr_format_res_path(u8 *res_path, char *buffer, int len)\n{\n\tint i;\n\tchar *p = buffer;\n\n\t*p = '\\0';\n\tp += scnprintf(p, buffer + len - p, \"%02X\", res_path[0]);\n\tfor (i = 1; res_path[i] != 0xff && ((i * 3) < len); i++)\n\t\tp += scnprintf(p, buffer + len - p, \"-%02X\", res_path[i]);\n\n\treturn buffer;\n}\n\n/**\n * ipr_format_res_path - Format the resource path for printing.\n * @ioa_cfg:\tioa config struct\n * @res_path:\tresource path\n * @buffer:\tbuffer\n * @len:\tlength of buffer provided\n *\n * Return value:\n *\tpointer to buffer\n **/\nstatic char *ipr_format_res_path(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t u8 *res_path, char *buffer, int len)\n{\n\tchar *p = buffer;\n\n\t*p = '\\0';\n\tp += scnprintf(p, buffer + len - p, \"%d/\", ioa_cfg->host->host_no);\n\t__ipr_format_res_path(res_path, p, len - (buffer - p));\n\treturn buffer;\n}\n\n/**\n * ipr_update_res_entry - Update the resource entry.\n * @res:\tresource entry struct\n * @cfgtew:\tconfig table entry wrapper struct\n *\n * Return value:\n *      none\n **/\nstatic void ipr_update_res_entry(struct ipr_resource_entry *res,\n\t\t\t\t struct ipr_config_table_entry_wrapper *cfgtew)\n{\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\tunsigned int proto;\n\tint new_path = 0;\n\n\tif (res->ioa_cfg->sis64) {\n\t\tres->flags = be16_to_cpu(cfgtew->u.cfgte64->flags);\n\t\tres->res_flags = be16_to_cpu(cfgtew->u.cfgte64->res_flags);\n\t\tres->type = cfgtew->u.cfgte64->res_type;\n\n\t\tmemcpy(&res->std_inq_data, &cfgtew->u.cfgte64->std_inq_data,\n\t\t\tsizeof(struct ipr_std_inq_data));\n\n\t\tres->qmodel = IPR_QUEUEING_MODEL64(res);\n\t\tproto = cfgtew->u.cfgte64->proto;\n\t\tres->res_handle = cfgtew->u.cfgte64->res_handle;\n\t\tres->dev_id = cfgtew->u.cfgte64->dev_id;\n\n\t\tmemcpy(&res->dev_lun.scsi_lun, &cfgtew->u.cfgte64->lun,\n\t\t\tsizeof(res->dev_lun.scsi_lun));\n\n\t\tif (memcmp(res->res_path, &cfgtew->u.cfgte64->res_path,\n\t\t\t\t\tsizeof(res->res_path))) {\n\t\t\tmemcpy(res->res_path, &cfgtew->u.cfgte64->res_path,\n\t\t\t\tsizeof(res->res_path));\n\t\t\tnew_path = 1;\n\t\t}\n\n\t\tif (res->sdev && new_path)\n\t\t\tsdev_printk(KERN_INFO, res->sdev, \"Resource path: %s\\n\",\n\t\t\t\t    ipr_format_res_path(res->ioa_cfg,\n\t\t\t\t\tres->res_path, buffer, sizeof(buffer)));\n\t} else {\n\t\tres->flags = cfgtew->u.cfgte->flags;\n\t\tif (res->flags & IPR_IS_IOA_RESOURCE)\n\t\t\tres->type = IPR_RES_TYPE_IOAFP;\n\t\telse\n\t\t\tres->type = cfgtew->u.cfgte->rsvd_subtype & 0x0f;\n\n\t\tmemcpy(&res->std_inq_data, &cfgtew->u.cfgte->std_inq_data,\n\t\t\tsizeof(struct ipr_std_inq_data));\n\n\t\tres->qmodel = IPR_QUEUEING_MODEL(res);\n\t\tproto = cfgtew->u.cfgte->proto;\n\t\tres->res_handle = cfgtew->u.cfgte->res_handle;\n\t}\n\n\tipr_update_ata_class(res, proto);\n}\n\n/**\n * ipr_clear_res_target - Clear the bit in the bit map representing the target\n * \t\t\t  for the resource.\n * @res:\tresource entry struct\n *\n * Return value:\n *      none\n **/\nstatic void ipr_clear_res_target(struct ipr_resource_entry *res)\n{\n\tstruct ipr_resource_entry *gscsi_res = NULL;\n\tstruct ipr_ioa_cfg *ioa_cfg = res->ioa_cfg;\n\n\tif (!ioa_cfg->sis64)\n\t\treturn;\n\n\tif (res->bus == IPR_ARRAY_VIRTUAL_BUS)\n\t\tclear_bit(res->target, ioa_cfg->array_ids);\n\telse if (res->bus == IPR_VSET_VIRTUAL_BUS)\n\t\tclear_bit(res->target, ioa_cfg->vset_ids);\n\telse if (res->bus == 0 && res->type == IPR_RES_TYPE_GENERIC_SCSI) {\n\t\tlist_for_each_entry(gscsi_res, &ioa_cfg->used_res_q, queue)\n\t\t\tif (gscsi_res->dev_id == res->dev_id && gscsi_res != res)\n\t\t\t\treturn;\n\t\tclear_bit(res->target, ioa_cfg->target_ids);\n\n\t} else if (res->bus == 0)\n\t\tclear_bit(res->target, ioa_cfg->target_ids);\n}\n\n/**\n * ipr_handle_config_change - Handle a config change from the adapter\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_handle_config_change(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t     struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_resource_entry *res = NULL;\n\tstruct ipr_config_table_entry_wrapper cfgtew;\n\t__be32 cc_res_handle;\n\n\tu32 is_ndn = 1;\n\n\tif (ioa_cfg->sis64) {\n\t\tcfgtew.u.cfgte64 = &hostrcb->hcam.u.ccn.u.cfgte64;\n\t\tcc_res_handle = cfgtew.u.cfgte64->res_handle;\n\t} else {\n\t\tcfgtew.u.cfgte = &hostrcb->hcam.u.ccn.u.cfgte;\n\t\tcc_res_handle = cfgtew.u.cfgte->res_handle;\n\t}\n\n\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\tif (res->res_handle == cc_res_handle) {\n\t\t\tis_ndn = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (is_ndn) {\n\t\tif (list_empty(&ioa_cfg->free_res_q)) {\n\t\t\tipr_send_hcam(ioa_cfg,\n\t\t\t\t      IPR_HCAM_CDB_OP_CODE_CONFIG_CHANGE,\n\t\t\t\t      hostrcb);\n\t\t\treturn;\n\t\t}\n\n\t\tres = list_entry(ioa_cfg->free_res_q.next,\n\t\t\t\t struct ipr_resource_entry, queue);\n\n\t\tlist_del(&res->queue);\n\t\tipr_init_res_entry(res, &cfgtew);\n\t\tlist_add_tail(&res->queue, &ioa_cfg->used_res_q);\n\t}\n\n\tipr_update_res_entry(res, &cfgtew);\n\n\tif (hostrcb->hcam.notify_type == IPR_HOST_RCB_NOTIF_TYPE_REM_ENTRY) {\n\t\tif (res->sdev) {\n\t\t\tres->del_from_ml = 1;\n\t\t\tres->res_handle = IPR_INVALID_RES_HANDLE;\n\t\t\tschedule_work(&ioa_cfg->work_q);\n\t\t} else {\n\t\t\tipr_clear_res_target(res);\n\t\t\tlist_move_tail(&res->queue, &ioa_cfg->free_res_q);\n\t\t}\n\t} else if (!res->sdev || res->del_from_ml) {\n\t\tres->add_to_ml = 1;\n\t\tschedule_work(&ioa_cfg->work_q);\n\t}\n\n\tipr_send_hcam(ioa_cfg, IPR_HCAM_CDB_OP_CODE_CONFIG_CHANGE, hostrcb);\n}\n\n/**\n * ipr_process_ccn - Op done function for a CCN.\n * @ipr_cmd:\tipr command struct\n *\n * This function is the op done function for a configuration\n * change notification host controlled async from the adapter.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_process_ccn(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_hostrcb *hostrcb = ipr_cmd->u.hostrcb;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tlist_del_init(&hostrcb->queue);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\n\tif (ioasc) {\n\t\tif (ioasc != IPR_IOASC_IOA_WAS_RESET &&\n\t\t    ioasc != IPR_IOASC_ABORTED_CMD_TERM_BY_HOST)\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"Host RCB failed with IOASC: 0x%08X\\n\", ioasc);\n\n\t\tipr_send_hcam(ioa_cfg, IPR_HCAM_CDB_OP_CODE_CONFIG_CHANGE, hostrcb);\n\t} else {\n\t\tipr_handle_config_change(ioa_cfg, hostrcb);\n\t}\n}\n\n/**\n * strip_and_pad_whitespace - Strip and pad trailing whitespace.\n * @i:\t\tindex into buffer\n * @buf:\t\tstring to modify\n *\n * This function will strip all trailing whitespace, pad the end\n * of the string with a single space, and NULL terminate the string.\n *\n * Return value:\n * \tnew length of string\n **/\nstatic int strip_and_pad_whitespace(int i, char *buf)\n{\n\twhile (i && buf[i] == ' ')\n\t\ti--;\n\tbuf[i+1] = ' ';\n\tbuf[i+2] = '\\0';\n\treturn i + 2;\n}\n\n/**\n * ipr_log_vpd_compact - Log the passed extended VPD compactly.\n * @prefix:\t\tstring to print at start of printk\n * @hostrcb:\thostrcb pointer\n * @vpd:\t\tvendor/product id/sn struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_vpd_compact(char *prefix, struct ipr_hostrcb *hostrcb,\n\t\t\t\tstruct ipr_vpd *vpd)\n{\n\tchar buffer[IPR_VENDOR_ID_LEN + IPR_PROD_ID_LEN + IPR_SERIAL_NUM_LEN + 3];\n\tint i = 0;\n\n\tmemcpy(buffer, vpd->vpids.vendor_id, IPR_VENDOR_ID_LEN);\n\ti = strip_and_pad_whitespace(IPR_VENDOR_ID_LEN - 1, buffer);\n\n\tmemcpy(&buffer[i], vpd->vpids.product_id, IPR_PROD_ID_LEN);\n\ti = strip_and_pad_whitespace(i + IPR_PROD_ID_LEN - 1, buffer);\n\n\tmemcpy(&buffer[i], vpd->sn, IPR_SERIAL_NUM_LEN);\n\tbuffer[IPR_SERIAL_NUM_LEN + i] = '\\0';\n\n\tipr_hcam_err(hostrcb, \"%s VPID/SN: %s\\n\", prefix, buffer);\n}\n\n/**\n * ipr_log_vpd - Log the passed VPD to the error log.\n * @vpd:\t\tvendor/product id/sn struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_vpd(struct ipr_vpd *vpd)\n{\n\tchar buffer[IPR_VENDOR_ID_LEN + IPR_PROD_ID_LEN\n\t\t    + IPR_SERIAL_NUM_LEN];\n\n\tmemcpy(buffer, vpd->vpids.vendor_id, IPR_VENDOR_ID_LEN);\n\tmemcpy(buffer + IPR_VENDOR_ID_LEN, vpd->vpids.product_id,\n\t       IPR_PROD_ID_LEN);\n\tbuffer[IPR_VENDOR_ID_LEN + IPR_PROD_ID_LEN] = '\\0';\n\tipr_err(\"Vendor/Product ID: %s\\n\", buffer);\n\n\tmemcpy(buffer, vpd->sn, IPR_SERIAL_NUM_LEN);\n\tbuffer[IPR_SERIAL_NUM_LEN] = '\\0';\n\tipr_err(\"    Serial Number: %s\\n\", buffer);\n}\n\n/**\n * ipr_log_ext_vpd_compact - Log the passed extended VPD compactly.\n * @prefix:\t\tstring to print at start of printk\n * @hostrcb:\thostrcb pointer\n * @vpd:\t\tvendor/product id/sn/wwn struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_ext_vpd_compact(char *prefix, struct ipr_hostrcb *hostrcb,\n\t\t\t\t    struct ipr_ext_vpd *vpd)\n{\n\tipr_log_vpd_compact(prefix, hostrcb, &vpd->vpd);\n\tipr_hcam_err(hostrcb, \"%s WWN: %08X%08X\\n\", prefix,\n\t\t     be32_to_cpu(vpd->wwid[0]), be32_to_cpu(vpd->wwid[1]));\n}\n\n/**\n * ipr_log_ext_vpd - Log the passed extended VPD to the error log.\n * @vpd:\t\tvendor/product id/sn/wwn struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_ext_vpd(struct ipr_ext_vpd *vpd)\n{\n\tipr_log_vpd(&vpd->vpd);\n\tipr_err(\"    WWN: %08X%08X\\n\", be32_to_cpu(vpd->wwid[0]),\n\t\tbe32_to_cpu(vpd->wwid[1]));\n}\n\n/**\n * ipr_log_enhanced_cache_error - Log a cache error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_enhanced_cache_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_12_error *error;\n\n\tif (ioa_cfg->sis64)\n\t\terror = &hostrcb->hcam.u.error64.u.type_12_error;\n\telse\n\t\terror = &hostrcb->hcam.u.error.u.type_12_error;\n\n\tipr_err(\"-----Current Configuration-----\\n\");\n\tipr_err(\"Cache Directory Card Information:\\n\");\n\tipr_log_ext_vpd(&error->ioa_vpd);\n\tipr_err(\"Adapter Card Information:\\n\");\n\tipr_log_ext_vpd(&error->cfc_vpd);\n\n\tipr_err(\"-----Expected Configuration-----\\n\");\n\tipr_err(\"Cache Directory Card Information:\\n\");\n\tipr_log_ext_vpd(&error->ioa_last_attached_to_cfc_vpd);\n\tipr_err(\"Adapter Card Information:\\n\");\n\tipr_log_ext_vpd(&error->cfc_last_attached_to_ioa_vpd);\n\n\tipr_err(\"Additional IOA Data: %08X %08X %08X\\n\",\n\t\t     be32_to_cpu(error->ioa_data[0]),\n\t\t     be32_to_cpu(error->ioa_data[1]),\n\t\t     be32_to_cpu(error->ioa_data[2]));\n}\n\n/**\n * ipr_log_cache_error - Log a cache error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_cache_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\tstruct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_02_error *error =\n\t\t&hostrcb->hcam.u.error.u.type_02_error;\n\n\tipr_err(\"-----Current Configuration-----\\n\");\n\tipr_err(\"Cache Directory Card Information:\\n\");\n\tipr_log_vpd(&error->ioa_vpd);\n\tipr_err(\"Adapter Card Information:\\n\");\n\tipr_log_vpd(&error->cfc_vpd);\n\n\tipr_err(\"-----Expected Configuration-----\\n\");\n\tipr_err(\"Cache Directory Card Information:\\n\");\n\tipr_log_vpd(&error->ioa_last_attached_to_cfc_vpd);\n\tipr_err(\"Adapter Card Information:\\n\");\n\tipr_log_vpd(&error->cfc_last_attached_to_ioa_vpd);\n\n\tipr_err(\"Additional IOA Data: %08X %08X %08X\\n\",\n\t\t     be32_to_cpu(error->ioa_data[0]),\n\t\t     be32_to_cpu(error->ioa_data[1]),\n\t\t     be32_to_cpu(error->ioa_data[2]));\n}\n\n/**\n * ipr_log_enhanced_config_error - Log a configuration error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_enhanced_config_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t  struct ipr_hostrcb *hostrcb)\n{\n\tint errors_logged, i;\n\tstruct ipr_hostrcb_device_data_entry_enhanced *dev_entry;\n\tstruct ipr_hostrcb_type_13_error *error;\n\n\terror = &hostrcb->hcam.u.error.u.type_13_error;\n\terrors_logged = be32_to_cpu(error->errors_logged);\n\n\tipr_err(\"Device Errors Detected/Logged: %d/%d\\n\",\n\t\tbe32_to_cpu(error->errors_detected), errors_logged);\n\n\tdev_entry = error->dev;\n\n\tfor (i = 0; i < errors_logged; i++, dev_entry++) {\n\t\tipr_err_separator;\n\n\t\tipr_phys_res_err(ioa_cfg, dev_entry->dev_res_addr, \"Device %d\", i + 1);\n\t\tipr_log_ext_vpd(&dev_entry->vpd);\n\n\t\tipr_err(\"-----New Device Information-----\\n\");\n\t\tipr_log_ext_vpd(&dev_entry->new_vpd);\n\n\t\tipr_err(\"Cache Directory Card Information:\\n\");\n\t\tipr_log_ext_vpd(&dev_entry->ioa_last_with_dev_vpd);\n\n\t\tipr_err(\"Adapter Card Information:\\n\");\n\t\tipr_log_ext_vpd(&dev_entry->cfc_last_with_dev_vpd);\n\t}\n}\n\n/**\n * ipr_log_sis64_config_error - Log a device error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_sis64_config_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t       struct ipr_hostrcb *hostrcb)\n{\n\tint errors_logged, i;\n\tstruct ipr_hostrcb64_device_data_entry_enhanced *dev_entry;\n\tstruct ipr_hostrcb_type_23_error *error;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\n\terror = &hostrcb->hcam.u.error64.u.type_23_error;\n\terrors_logged = be32_to_cpu(error->errors_logged);\n\n\tipr_err(\"Device Errors Detected/Logged: %d/%d\\n\",\n\t\tbe32_to_cpu(error->errors_detected), errors_logged);\n\n\tdev_entry = error->dev;\n\n\tfor (i = 0; i < errors_logged; i++, dev_entry++) {\n\t\tipr_err_separator;\n\n\t\tipr_err(\"Device %d : %s\", i + 1,\n\t\t\t__ipr_format_res_path(dev_entry->res_path,\n\t\t\t\t\t      buffer, sizeof(buffer)));\n\t\tipr_log_ext_vpd(&dev_entry->vpd);\n\n\t\tipr_err(\"-----New Device Information-----\\n\");\n\t\tipr_log_ext_vpd(&dev_entry->new_vpd);\n\n\t\tipr_err(\"Cache Directory Card Information:\\n\");\n\t\tipr_log_ext_vpd(&dev_entry->ioa_last_with_dev_vpd);\n\n\t\tipr_err(\"Adapter Card Information:\\n\");\n\t\tipr_log_ext_vpd(&dev_entry->cfc_last_with_dev_vpd);\n\t}\n}\n\n/**\n * ipr_log_config_error - Log a configuration error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_config_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t struct ipr_hostrcb *hostrcb)\n{\n\tint errors_logged, i;\n\tstruct ipr_hostrcb_device_data_entry *dev_entry;\n\tstruct ipr_hostrcb_type_03_error *error;\n\n\terror = &hostrcb->hcam.u.error.u.type_03_error;\n\terrors_logged = be32_to_cpu(error->errors_logged);\n\n\tipr_err(\"Device Errors Detected/Logged: %d/%d\\n\",\n\t\tbe32_to_cpu(error->errors_detected), errors_logged);\n\n\tdev_entry = error->dev;\n\n\tfor (i = 0; i < errors_logged; i++, dev_entry++) {\n\t\tipr_err_separator;\n\n\t\tipr_phys_res_err(ioa_cfg, dev_entry->dev_res_addr, \"Device %d\", i + 1);\n\t\tipr_log_vpd(&dev_entry->vpd);\n\n\t\tipr_err(\"-----New Device Information-----\\n\");\n\t\tipr_log_vpd(&dev_entry->new_vpd);\n\n\t\tipr_err(\"Cache Directory Card Information:\\n\");\n\t\tipr_log_vpd(&dev_entry->ioa_last_with_dev_vpd);\n\n\t\tipr_err(\"Adapter Card Information:\\n\");\n\t\tipr_log_vpd(&dev_entry->cfc_last_with_dev_vpd);\n\n\t\tipr_err(\"Additional IOA Data: %08X %08X %08X %08X %08X\\n\",\n\t\t\tbe32_to_cpu(dev_entry->ioa_data[0]),\n\t\t\tbe32_to_cpu(dev_entry->ioa_data[1]),\n\t\t\tbe32_to_cpu(dev_entry->ioa_data[2]),\n\t\t\tbe32_to_cpu(dev_entry->ioa_data[3]),\n\t\t\tbe32_to_cpu(dev_entry->ioa_data[4]));\n\t}\n}\n\n/**\n * ipr_log_enhanced_array_error - Log an array configuration error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_enhanced_array_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t struct ipr_hostrcb *hostrcb)\n{\n\tint i, num_entries;\n\tstruct ipr_hostrcb_type_14_error *error;\n\tstruct ipr_hostrcb_array_data_entry_enhanced *array_entry;\n\tconst u8 zero_sn[IPR_SERIAL_NUM_LEN] = { [0 ... IPR_SERIAL_NUM_LEN-1] = '0' };\n\n\terror = &hostrcb->hcam.u.error.u.type_14_error;\n\n\tipr_err_separator;\n\n\tipr_err(\"RAID %s Array Configuration: %d:%d:%d:%d\\n\",\n\t\terror->protection_level,\n\t\tioa_cfg->host->host_no,\n\t\terror->last_func_vset_res_addr.bus,\n\t\terror->last_func_vset_res_addr.target,\n\t\terror->last_func_vset_res_addr.lun);\n\n\tipr_err_separator;\n\n\tarray_entry = error->array_member;\n\tnum_entries = min_t(u32, be32_to_cpu(error->num_entries),\n\t\t\t    ARRAY_SIZE(error->array_member));\n\n\tfor (i = 0; i < num_entries; i++, array_entry++) {\n\t\tif (!memcmp(array_entry->vpd.vpd.sn, zero_sn, IPR_SERIAL_NUM_LEN))\n\t\t\tcontinue;\n\n\t\tif (be32_to_cpu(error->exposed_mode_adn) == i)\n\t\t\tipr_err(\"Exposed Array Member %d:\\n\", i);\n\t\telse\n\t\t\tipr_err(\"Array Member %d:\\n\", i);\n\n\t\tipr_log_ext_vpd(&array_entry->vpd);\n\t\tipr_phys_res_err(ioa_cfg, array_entry->dev_res_addr, \"Current Location\");\n\t\tipr_phys_res_err(ioa_cfg, array_entry->expected_dev_res_addr,\n\t\t\t\t \"Expected Location\");\n\n\t\tipr_err_separator;\n\t}\n}\n\n/**\n * ipr_log_array_error - Log an array configuration error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_array_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\tstruct ipr_hostrcb *hostrcb)\n{\n\tint i;\n\tstruct ipr_hostrcb_type_04_error *error;\n\tstruct ipr_hostrcb_array_data_entry *array_entry;\n\tconst u8 zero_sn[IPR_SERIAL_NUM_LEN] = { [0 ... IPR_SERIAL_NUM_LEN-1] = '0' };\n\n\terror = &hostrcb->hcam.u.error.u.type_04_error;\n\n\tipr_err_separator;\n\n\tipr_err(\"RAID %s Array Configuration: %d:%d:%d:%d\\n\",\n\t\terror->protection_level,\n\t\tioa_cfg->host->host_no,\n\t\terror->last_func_vset_res_addr.bus,\n\t\terror->last_func_vset_res_addr.target,\n\t\terror->last_func_vset_res_addr.lun);\n\n\tipr_err_separator;\n\n\tarray_entry = error->array_member;\n\n\tfor (i = 0; i < 18; i++) {\n\t\tif (!memcmp(array_entry->vpd.sn, zero_sn, IPR_SERIAL_NUM_LEN))\n\t\t\tcontinue;\n\n\t\tif (be32_to_cpu(error->exposed_mode_adn) == i)\n\t\t\tipr_err(\"Exposed Array Member %d:\\n\", i);\n\t\telse\n\t\t\tipr_err(\"Array Member %d:\\n\", i);\n\n\t\tipr_log_vpd(&array_entry->vpd);\n\n\t\tipr_phys_res_err(ioa_cfg, array_entry->dev_res_addr, \"Current Location\");\n\t\tipr_phys_res_err(ioa_cfg, array_entry->expected_dev_res_addr,\n\t\t\t\t \"Expected Location\");\n\n\t\tipr_err_separator;\n\n\t\tif (i == 9)\n\t\t\tarray_entry = error->array_member2;\n\t\telse\n\t\t\tarray_entry++;\n\t}\n}\n\n/**\n * ipr_log_hex_data - Log additional hex IOA error data.\n * @ioa_cfg:\tioa config struct\n * @data:\t\tIOA error data\n * @len:\t\tdata length\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_hex_data(struct ipr_ioa_cfg *ioa_cfg, __be32 *data, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn;\n\n\tif (ioa_cfg->log_level <= IPR_DEFAULT_LOG_LEVEL)\n\t\tlen = min_t(int, len, IPR_DEFAULT_MAX_ERROR_DUMP);\n\n\tfor (i = 0; i < len / 4; i += 4) {\n\t\tipr_err(\"%08X: %08X %08X %08X %08X\\n\", i*4,\n\t\t\tbe32_to_cpu(data[i]),\n\t\t\tbe32_to_cpu(data[i+1]),\n\t\t\tbe32_to_cpu(data[i+2]),\n\t\t\tbe32_to_cpu(data[i+3]));\n\t}\n}\n\n/**\n * ipr_log_enhanced_dual_ioa_error - Log an enhanced dual adapter error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_enhanced_dual_ioa_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t    struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_17_error *error;\n\n\tif (ioa_cfg->sis64)\n\t\terror = &hostrcb->hcam.u.error64.u.type_17_error;\n\telse\n\t\terror = &hostrcb->hcam.u.error.u.type_17_error;\n\n\terror->failure_reason[sizeof(error->failure_reason) - 1] = '\\0';\n\tstrim(error->failure_reason);\n\n\tipr_hcam_err(hostrcb, \"%s [PRC: %08X]\\n\", error->failure_reason,\n\t\t     be32_to_cpu(hostrcb->hcam.u.error.prc));\n\tipr_log_ext_vpd_compact(\"Remote IOA\", hostrcb, &error->vpd);\n\tipr_log_hex_data(ioa_cfg, error->data,\n\t\t\t be32_to_cpu(hostrcb->hcam.length) -\n\t\t\t (offsetof(struct ipr_hostrcb_error, u) +\n\t\t\t  offsetof(struct ipr_hostrcb_type_17_error, data)));\n}\n\n/**\n * ipr_log_dual_ioa_error - Log a dual adapter error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_dual_ioa_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t   struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_07_error *error;\n\n\terror = &hostrcb->hcam.u.error.u.type_07_error;\n\terror->failure_reason[sizeof(error->failure_reason) - 1] = '\\0';\n\tstrim(error->failure_reason);\n\n\tipr_hcam_err(hostrcb, \"%s [PRC: %08X]\\n\", error->failure_reason,\n\t\t     be32_to_cpu(hostrcb->hcam.u.error.prc));\n\tipr_log_vpd_compact(\"Remote IOA\", hostrcb, &error->vpd);\n\tipr_log_hex_data(ioa_cfg, error->data,\n\t\t\t be32_to_cpu(hostrcb->hcam.length) -\n\t\t\t (offsetof(struct ipr_hostrcb_error, u) +\n\t\t\t  offsetof(struct ipr_hostrcb_type_07_error, data)));\n}\n\nstatic const struct {\n\tu8 active;\n\tchar *desc;\n} path_active_desc[] = {\n\t{ IPR_PATH_NO_INFO, \"Path\" },\n\t{ IPR_PATH_ACTIVE, \"Active path\" },\n\t{ IPR_PATH_NOT_ACTIVE, \"Inactive path\" }\n};\n\nstatic const struct {\n\tu8 state;\n\tchar *desc;\n} path_state_desc[] = {\n\t{ IPR_PATH_STATE_NO_INFO, \"has no path state information available\" },\n\t{ IPR_PATH_HEALTHY, \"is healthy\" },\n\t{ IPR_PATH_DEGRADED, \"is degraded\" },\n\t{ IPR_PATH_FAILED, \"is failed\" }\n};\n\n/**\n * ipr_log_fabric_path - Log a fabric path error\n * @hostrcb:\thostrcb struct\n * @fabric:\t\tfabric descriptor\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_fabric_path(struct ipr_hostrcb *hostrcb,\n\t\t\t\tstruct ipr_hostrcb_fabric_desc *fabric)\n{\n\tint i, j;\n\tu8 path_state = fabric->path_state;\n\tu8 active = path_state & IPR_PATH_ACTIVE_MASK;\n\tu8 state = path_state & IPR_PATH_STATE_MASK;\n\n\tfor (i = 0; i < ARRAY_SIZE(path_active_desc); i++) {\n\t\tif (path_active_desc[i].active != active)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(path_state_desc); j++) {\n\t\t\tif (path_state_desc[j].state != state)\n\t\t\t\tcontinue;\n\n\t\t\tif (fabric->cascaded_expander == 0xff && fabric->phy == 0xff) {\n\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: IOA Port=%d\\n\",\n\t\t\t\t\t     path_active_desc[i].desc, path_state_desc[j].desc,\n\t\t\t\t\t     fabric->ioa_port);\n\t\t\t} else if (fabric->cascaded_expander == 0xff) {\n\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: IOA Port=%d, Phy=%d\\n\",\n\t\t\t\t\t     path_active_desc[i].desc, path_state_desc[j].desc,\n\t\t\t\t\t     fabric->ioa_port, fabric->phy);\n\t\t\t} else if (fabric->phy == 0xff) {\n\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: IOA Port=%d, Cascade=%d\\n\",\n\t\t\t\t\t     path_active_desc[i].desc, path_state_desc[j].desc,\n\t\t\t\t\t     fabric->ioa_port, fabric->cascaded_expander);\n\t\t\t} else {\n\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: IOA Port=%d, Cascade=%d, Phy=%d\\n\",\n\t\t\t\t\t     path_active_desc[i].desc, path_state_desc[j].desc,\n\t\t\t\t\t     fabric->ioa_port, fabric->cascaded_expander, fabric->phy);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tipr_err(\"Path state=%02X IOA Port=%d Cascade=%d Phy=%d\\n\", path_state,\n\t\tfabric->ioa_port, fabric->cascaded_expander, fabric->phy);\n}\n\n/**\n * ipr_log64_fabric_path - Log a fabric path error\n * @hostrcb:\thostrcb struct\n * @fabric:\t\tfabric descriptor\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log64_fabric_path(struct ipr_hostrcb *hostrcb,\n\t\t\t\t  struct ipr_hostrcb64_fabric_desc *fabric)\n{\n\tint i, j;\n\tu8 path_state = fabric->path_state;\n\tu8 active = path_state & IPR_PATH_ACTIVE_MASK;\n\tu8 state = path_state & IPR_PATH_STATE_MASK;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\n\tfor (i = 0; i < ARRAY_SIZE(path_active_desc); i++) {\n\t\tif (path_active_desc[i].active != active)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(path_state_desc); j++) {\n\t\t\tif (path_state_desc[j].state != state)\n\t\t\t\tcontinue;\n\n\t\t\tipr_hcam_err(hostrcb, \"%s %s: Resource Path=%s\\n\",\n\t\t\t\t     path_active_desc[i].desc, path_state_desc[j].desc,\n\t\t\t\t     ipr_format_res_path(hostrcb->ioa_cfg,\n\t\t\t\t\t\tfabric->res_path,\n\t\t\t\t\t\tbuffer, sizeof(buffer)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tipr_err(\"Path state=%02X Resource Path=%s\\n\", path_state,\n\t\tipr_format_res_path(hostrcb->ioa_cfg, fabric->res_path,\n\t\t\t\t    buffer, sizeof(buffer)));\n}\n\nstatic const struct {\n\tu8 type;\n\tchar *desc;\n} path_type_desc[] = {\n\t{ IPR_PATH_CFG_IOA_PORT, \"IOA port\" },\n\t{ IPR_PATH_CFG_EXP_PORT, \"Expander port\" },\n\t{ IPR_PATH_CFG_DEVICE_PORT, \"Device port\" },\n\t{ IPR_PATH_CFG_DEVICE_LUN, \"Device LUN\" }\n};\n\nstatic const struct {\n\tu8 status;\n\tchar *desc;\n} path_status_desc[] = {\n\t{ IPR_PATH_CFG_NO_PROB, \"Functional\" },\n\t{ IPR_PATH_CFG_DEGRADED, \"Degraded\" },\n\t{ IPR_PATH_CFG_FAILED, \"Failed\" },\n\t{ IPR_PATH_CFG_SUSPECT, \"Suspect\" },\n\t{ IPR_PATH_NOT_DETECTED, \"Missing\" },\n\t{ IPR_PATH_INCORRECT_CONN, \"Incorrectly connected\" }\n};\n\nstatic const char *link_rate[] = {\n\t\"unknown\",\n\t\"disabled\",\n\t\"phy reset problem\",\n\t\"spinup hold\",\n\t\"port selector\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"1.5Gbps\",\n\t\"3.0Gbps\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\"\n};\n\n/**\n * ipr_log_path_elem - Log a fabric path element.\n * @hostrcb:\thostrcb struct\n * @cfg:\t\tfabric path element struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_path_elem(struct ipr_hostrcb *hostrcb,\n\t\t\t      struct ipr_hostrcb_config_element *cfg)\n{\n\tint i, j;\n\tu8 type = cfg->type_status & IPR_PATH_CFG_TYPE_MASK;\n\tu8 status = cfg->type_status & IPR_PATH_CFG_STATUS_MASK;\n\n\tif (type == IPR_PATH_CFG_NOT_EXIST)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(path_type_desc); i++) {\n\t\tif (path_type_desc[i].type != type)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(path_status_desc); j++) {\n\t\t\tif (path_status_desc[j].status != status)\n\t\t\t\tcontinue;\n\n\t\t\tif (type == IPR_PATH_CFG_IOA_PORT) {\n\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: Phy=%d, Link rate=%s, WWN=%08X%08X\\n\",\n\t\t\t\t\t     path_status_desc[j].desc, path_type_desc[i].desc,\n\t\t\t\t\t     cfg->phy, link_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\t\t\t     be32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n\t\t\t} else {\n\t\t\t\tif (cfg->cascaded_expander == 0xff && cfg->phy == 0xff) {\n\t\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: Link rate=%s, WWN=%08X%08X\\n\",\n\t\t\t\t\t\t     path_status_desc[j].desc, path_type_desc[i].desc,\n\t\t\t\t\t\t     link_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\t\t\t\t     be32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n\t\t\t\t} else if (cfg->cascaded_expander == 0xff) {\n\t\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: Phy=%d, Link rate=%s, \"\n\t\t\t\t\t\t     \"WWN=%08X%08X\\n\", path_status_desc[j].desc,\n\t\t\t\t\t\t     path_type_desc[i].desc, cfg->phy,\n\t\t\t\t\t\t     link_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\t\t\t\t     be32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n\t\t\t\t} else if (cfg->phy == 0xff) {\n\t\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: Cascade=%d, Link rate=%s, \"\n\t\t\t\t\t\t     \"WWN=%08X%08X\\n\", path_status_desc[j].desc,\n\t\t\t\t\t\t     path_type_desc[i].desc, cfg->cascaded_expander,\n\t\t\t\t\t\t     link_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\t\t\t\t     be32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n\t\t\t\t} else {\n\t\t\t\t\tipr_hcam_err(hostrcb, \"%s %s: Cascade=%d, Phy=%d, Link rate=%s \"\n\t\t\t\t\t\t     \"WWN=%08X%08X\\n\", path_status_desc[j].desc,\n\t\t\t\t\t\t     path_type_desc[i].desc, cfg->cascaded_expander, cfg->phy,\n\t\t\t\t\t\t     link_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\t\t\t\t     be32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tipr_hcam_err(hostrcb, \"Path element=%02X: Cascade=%d Phy=%d Link rate=%s \"\n\t\t     \"WWN=%08X%08X\\n\", cfg->type_status, cfg->cascaded_expander, cfg->phy,\n\t\t     link_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t     be32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n}\n\n/**\n * ipr_log64_path_elem - Log a fabric path element.\n * @hostrcb:\thostrcb struct\n * @cfg:\t\tfabric path element struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log64_path_elem(struct ipr_hostrcb *hostrcb,\n\t\t\t\tstruct ipr_hostrcb64_config_element *cfg)\n{\n\tint i, j;\n\tu8 desc_id = cfg->descriptor_id & IPR_DESCRIPTOR_MASK;\n\tu8 type = cfg->type_status & IPR_PATH_CFG_TYPE_MASK;\n\tu8 status = cfg->type_status & IPR_PATH_CFG_STATUS_MASK;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\n\tif (type == IPR_PATH_CFG_NOT_EXIST || desc_id != IPR_DESCRIPTOR_SIS64)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(path_type_desc); i++) {\n\t\tif (path_type_desc[i].type != type)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(path_status_desc); j++) {\n\t\t\tif (path_status_desc[j].status != status)\n\t\t\t\tcontinue;\n\n\t\t\tipr_hcam_err(hostrcb, \"%s %s: Resource Path=%s, Link rate=%s, WWN=%08X%08X\\n\",\n\t\t\t\t     path_status_desc[j].desc, path_type_desc[i].desc,\n\t\t\t\t     ipr_format_res_path(hostrcb->ioa_cfg,\n\t\t\t\t\tcfg->res_path, buffer, sizeof(buffer)),\n\t\t\t\t\tlink_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\t\t\tbe32_to_cpu(cfg->wwid[0]),\n\t\t\t\t\tbe32_to_cpu(cfg->wwid[1]));\n\t\t\treturn;\n\t\t}\n\t}\n\tipr_hcam_err(hostrcb, \"Path element=%02X: Resource Path=%s, Link rate=%s \"\n\t\t     \"WWN=%08X%08X\\n\", cfg->type_status,\n\t\t     ipr_format_res_path(hostrcb->ioa_cfg,\n\t\t\tcfg->res_path, buffer, sizeof(buffer)),\n\t\t\tlink_rate[cfg->link_rate & IPR_PHY_LINK_RATE_MASK],\n\t\t\tbe32_to_cpu(cfg->wwid[0]), be32_to_cpu(cfg->wwid[1]));\n}\n\n/**\n * ipr_log_fabric_error - Log a fabric error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_fabric_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_20_error *error;\n\tstruct ipr_hostrcb_fabric_desc *fabric;\n\tstruct ipr_hostrcb_config_element *cfg;\n\tint i, add_len;\n\n\terror = &hostrcb->hcam.u.error.u.type_20_error;\n\terror->failure_reason[sizeof(error->failure_reason) - 1] = '\\0';\n\tipr_hcam_err(hostrcb, \"%s\\n\", error->failure_reason);\n\n\tadd_len = be32_to_cpu(hostrcb->hcam.length) -\n\t\t(offsetof(struct ipr_hostrcb_error, u) +\n\t\t offsetof(struct ipr_hostrcb_type_20_error, desc));\n\n\tfor (i = 0, fabric = error->desc; i < error->num_entries; i++) {\n\t\tipr_log_fabric_path(hostrcb, fabric);\n\t\tfor_each_fabric_cfg(fabric, cfg)\n\t\t\tipr_log_path_elem(hostrcb, cfg);\n\n\t\tadd_len -= be16_to_cpu(fabric->length);\n\t\tfabric = (struct ipr_hostrcb_fabric_desc *)\n\t\t\t((unsigned long)fabric + be16_to_cpu(fabric->length));\n\t}\n\n\tipr_log_hex_data(ioa_cfg, (__be32 *)fabric, add_len);\n}\n\n/**\n * ipr_log_sis64_array_error - Log a sis64 array error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_sis64_array_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t      struct ipr_hostrcb *hostrcb)\n{\n\tint i, num_entries;\n\tstruct ipr_hostrcb_type_24_error *error;\n\tstruct ipr_hostrcb64_array_data_entry *array_entry;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\tconst u8 zero_sn[IPR_SERIAL_NUM_LEN] = { [0 ... IPR_SERIAL_NUM_LEN-1] = '0' };\n\n\terror = &hostrcb->hcam.u.error64.u.type_24_error;\n\n\tipr_err_separator;\n\n\tipr_err(\"RAID %s Array Configuration: %s\\n\",\n\t\terror->protection_level,\n\t\tipr_format_res_path(ioa_cfg, error->last_res_path,\n\t\t\tbuffer, sizeof(buffer)));\n\n\tipr_err_separator;\n\n\tarray_entry = error->array_member;\n\tnum_entries = min_t(u32, error->num_entries,\n\t\t\t    ARRAY_SIZE(error->array_member));\n\n\tfor (i = 0; i < num_entries; i++, array_entry++) {\n\n\t\tif (!memcmp(array_entry->vpd.vpd.sn, zero_sn, IPR_SERIAL_NUM_LEN))\n\t\t\tcontinue;\n\n\t\tif (error->exposed_mode_adn == i)\n\t\t\tipr_err(\"Exposed Array Member %d:\\n\", i);\n\t\telse\n\t\t\tipr_err(\"Array Member %d:\\n\", i);\n\n\t\tipr_err(\"Array Member %d:\\n\", i);\n\t\tipr_log_ext_vpd(&array_entry->vpd);\n\t\tipr_err(\"Current Location: %s\\n\",\n\t\t\t ipr_format_res_path(ioa_cfg, array_entry->res_path,\n\t\t\t\tbuffer, sizeof(buffer)));\n\t\tipr_err(\"Expected Location: %s\\n\",\n\t\t\t ipr_format_res_path(ioa_cfg,\n\t\t\t\tarray_entry->expected_res_path,\n\t\t\t\tbuffer, sizeof(buffer)));\n\n\t\tipr_err_separator;\n\t}\n}\n\n/**\n * ipr_log_sis64_fabric_error - Log a sis64 fabric error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_sis64_fabric_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t       struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_30_error *error;\n\tstruct ipr_hostrcb64_fabric_desc *fabric;\n\tstruct ipr_hostrcb64_config_element *cfg;\n\tint i, add_len;\n\n\terror = &hostrcb->hcam.u.error64.u.type_30_error;\n\n\terror->failure_reason[sizeof(error->failure_reason) - 1] = '\\0';\n\tipr_hcam_err(hostrcb, \"%s\\n\", error->failure_reason);\n\n\tadd_len = be32_to_cpu(hostrcb->hcam.length) -\n\t\t(offsetof(struct ipr_hostrcb64_error, u) +\n\t\t offsetof(struct ipr_hostrcb_type_30_error, desc));\n\n\tfor (i = 0, fabric = error->desc; i < error->num_entries; i++) {\n\t\tipr_log64_fabric_path(hostrcb, fabric);\n\t\tfor_each_fabric_cfg(fabric, cfg)\n\t\t\tipr_log64_path_elem(hostrcb, cfg);\n\n\t\tadd_len -= be16_to_cpu(fabric->length);\n\t\tfabric = (struct ipr_hostrcb64_fabric_desc *)\n\t\t\t((unsigned long)fabric + be16_to_cpu(fabric->length));\n\t}\n\n\tipr_log_hex_data(ioa_cfg, (__be32 *)fabric, add_len);\n}\n\n/**\n * ipr_log_sis64_service_required_error - Log a sis64 service required error.\n * @ioa_cfg:    ioa config struct\n * @hostrcb:    hostrcb struct\n *\n * Return value:\n *      none\n **/\nstatic void ipr_log_sis64_service_required_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t       struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_41_error *error;\n\n\terror = &hostrcb->hcam.u.error64.u.type_41_error;\n\n\terror->failure_reason[sizeof(error->failure_reason) - 1] = '\\0';\n\tipr_err(\"Primary Failure Reason: %s\\n\", error->failure_reason);\n\tipr_log_hex_data(ioa_cfg, error->data,\n\t\t\t be32_to_cpu(hostrcb->hcam.length) -\n\t\t\t (offsetof(struct ipr_hostrcb_error, u) +\n\t\t\t  offsetof(struct ipr_hostrcb_type_41_error, data)));\n}\n/**\n * ipr_log_generic_error - Log an adapter error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_generic_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t  struct ipr_hostrcb *hostrcb)\n{\n\tipr_log_hex_data(ioa_cfg, hostrcb->hcam.u.raw.data,\n\t\t\t be32_to_cpu(hostrcb->hcam.length));\n}\n\n/**\n * ipr_log_sis64_device_error - Log a cache error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_log_sis64_device_error(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t struct ipr_hostrcb *hostrcb)\n{\n\tstruct ipr_hostrcb_type_21_error *error;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\n\terror = &hostrcb->hcam.u.error64.u.type_21_error;\n\n\tipr_err(\"-----Failing Device Information-----\\n\");\n\tipr_err(\"World Wide Unique ID: %08X%08X%08X%08X\\n\",\n\t\tbe32_to_cpu(error->wwn[0]), be32_to_cpu(error->wwn[1]),\n\t\t be32_to_cpu(error->wwn[2]), be32_to_cpu(error->wwn[3]));\n\tipr_err(\"Device Resource Path: %s\\n\",\n\t\t__ipr_format_res_path(error->res_path,\n\t\t\t\t      buffer, sizeof(buffer)));\n\terror->primary_problem_desc[sizeof(error->primary_problem_desc) - 1] = '\\0';\n\terror->second_problem_desc[sizeof(error->second_problem_desc) - 1] = '\\0';\n\tipr_err(\"Primary Problem Description: %s\\n\", error->primary_problem_desc);\n\tipr_err(\"Secondary Problem Description:  %s\\n\", error->second_problem_desc);\n\tipr_err(\"SCSI Sense Data:\\n\");\n\tipr_log_hex_data(ioa_cfg, error->sense_data, sizeof(error->sense_data));\n\tipr_err(\"SCSI Command Descriptor Block: \\n\");\n\tipr_log_hex_data(ioa_cfg, error->cdb, sizeof(error->cdb));\n\n\tipr_err(\"Additional IOA Data:\\n\");\n\tipr_log_hex_data(ioa_cfg, error->ioa_data, be32_to_cpu(error->length_of_error));\n}\n\n/**\n * ipr_get_error - Find the specfied IOASC in the ipr_error_table.\n * @ioasc:\tIOASC\n *\n * This function will return the index of into the ipr_error_table\n * for the specified IOASC. If the IOASC is not in the table,\n * 0 will be returned, which points to the entry used for unknown errors.\n *\n * Return value:\n * \tindex into the ipr_error_table\n **/\nstatic u32 ipr_get_error(u32 ioasc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ipr_error_table); i++)\n\t\tif (ipr_error_table[i].ioasc == (ioasc & IPR_IOASC_IOASC_MASK))\n\t\t\treturn i;\n\n\treturn 0;\n}\n\n/**\n * ipr_handle_log_data - Log an adapter error.\n * @ioa_cfg:\tioa config struct\n * @hostrcb:\thostrcb struct\n *\n * This function logs an adapter error to the system.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_handle_log_data(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\tstruct ipr_hostrcb *hostrcb)\n{\n\tu32 ioasc;\n\tint error_index;\n\tstruct ipr_hostrcb_type_21_error *error;\n\n\tif (hostrcb->hcam.notify_type != IPR_HOST_RCB_NOTIF_TYPE_ERROR_LOG_ENTRY)\n\t\treturn;\n\n\tif (hostrcb->hcam.notifications_lost == IPR_HOST_RCB_NOTIFICATIONS_LOST)\n\t\tdev_err(&ioa_cfg->pdev->dev, \"Error notifications lost\\n\");\n\n\tif (ioa_cfg->sis64)\n\t\tioasc = be32_to_cpu(hostrcb->hcam.u.error64.fd_ioasc);\n\telse\n\t\tioasc = be32_to_cpu(hostrcb->hcam.u.error.fd_ioasc);\n\n\tif (!ioa_cfg->sis64 && (ioasc == IPR_IOASC_BUS_WAS_RESET ||\n\t    ioasc == IPR_IOASC_BUS_WAS_RESET_BY_OTHER)) {\n\t\t/* Tell the midlayer we had a bus reset so it will handle the UA properly */\n\t\tscsi_report_bus_reset(ioa_cfg->host,\n\t\t\t\t      hostrcb->hcam.u.error.fd_res_addr.bus);\n\t}\n\n\terror_index = ipr_get_error(ioasc);\n\n\tif (!ipr_error_table[error_index].log_hcam)\n\t\treturn;\n\n\tif (ioasc == IPR_IOASC_HW_CMD_FAILED &&\n\t    hostrcb->hcam.overlay_id == IPR_HOST_RCB_OVERLAY_ID_21) {\n\t\terror = &hostrcb->hcam.u.error64.u.type_21_error;\n\n\t\tif (((be32_to_cpu(error->sense_data[0]) & 0x0000ff00) >> 8) == ILLEGAL_REQUEST &&\n\t\t\tioa_cfg->log_level <= IPR_DEFAULT_LOG_LEVEL)\n\t\t\t\treturn;\n\t}\n\n\tipr_hcam_err(hostrcb, \"%s\\n\", ipr_error_table[error_index].error);\n\n\t/* Set indication we have logged an error */\n\tioa_cfg->errors_logged++;\n\n\tif (ioa_cfg->log_level < ipr_error_table[error_index].log_hcam)\n\t\treturn;\n\tif (be32_to_cpu(hostrcb->hcam.length) > sizeof(hostrcb->hcam.u.raw))\n\t\thostrcb->hcam.length = cpu_to_be32(sizeof(hostrcb->hcam.u.raw));\n\n\tswitch (hostrcb->hcam.overlay_id) {\n\tcase IPR_HOST_RCB_OVERLAY_ID_2:\n\t\tipr_log_cache_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_3:\n\t\tipr_log_config_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_4:\n\tcase IPR_HOST_RCB_OVERLAY_ID_6:\n\t\tipr_log_array_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_7:\n\t\tipr_log_dual_ioa_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_12:\n\t\tipr_log_enhanced_cache_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_13:\n\t\tipr_log_enhanced_config_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_14:\n\tcase IPR_HOST_RCB_OVERLAY_ID_16:\n\t\tipr_log_enhanced_array_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_17:\n\t\tipr_log_enhanced_dual_ioa_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_20:\n\t\tipr_log_fabric_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_21:\n\t\tipr_log_sis64_device_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_23:\n\t\tipr_log_sis64_config_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_24:\n\tcase IPR_HOST_RCB_OVERLAY_ID_26:\n\t\tipr_log_sis64_array_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_30:\n\t\tipr_log_sis64_fabric_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_41:\n\t\tipr_log_sis64_service_required_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\tcase IPR_HOST_RCB_OVERLAY_ID_1:\n\tcase IPR_HOST_RCB_OVERLAY_ID_DEFAULT:\n\tdefault:\n\t\tipr_log_generic_error(ioa_cfg, hostrcb);\n\t\tbreak;\n\t}\n}\n\nstatic struct ipr_hostrcb *ipr_get_free_hostrcb(struct ipr_ioa_cfg *ioa)\n{\n\tstruct ipr_hostrcb *hostrcb;\n\n\thostrcb = list_first_entry_or_null(&ioa->hostrcb_free_q,\n\t\t\t\t\tstruct ipr_hostrcb, queue);\n\n\tif (unlikely(!hostrcb)) {\n\t\tdev_info(&ioa->pdev->dev, \"Reclaiming async error buffers.\");\n\t\thostrcb = list_first_entry_or_null(&ioa->hostrcb_report_q,\n\t\t\t\t\t\tstruct ipr_hostrcb, queue);\n\t}\n\n\tlist_del_init(&hostrcb->queue);\n\treturn hostrcb;\n}\n\n/**\n * ipr_process_error - Op done function for an adapter error log.\n * @ipr_cmd:\tipr command struct\n *\n * This function is the op done function for an error log host\n * controlled async from the adapter. It will log the error and\n * send the HCAM back to the adapter.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_process_error(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_hostrcb *hostrcb = ipr_cmd->u.hostrcb;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\tu32 fd_ioasc;\n\n\tif (ioa_cfg->sis64)\n\t\tfd_ioasc = be32_to_cpu(hostrcb->hcam.u.error64.fd_ioasc);\n\telse\n\t\tfd_ioasc = be32_to_cpu(hostrcb->hcam.u.error.fd_ioasc);\n\n\tlist_del_init(&hostrcb->queue);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\n\tif (!ioasc) {\n\t\tipr_handle_log_data(ioa_cfg, hostrcb);\n\t\tif (fd_ioasc == IPR_IOASC_NR_IOA_RESET_REQUIRED)\n\t\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_ABBREV);\n\t} else if (ioasc != IPR_IOASC_IOA_WAS_RESET &&\n\t\t   ioasc != IPR_IOASC_ABORTED_CMD_TERM_BY_HOST) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Host RCB failed with IOASC: 0x%08X\\n\", ioasc);\n\t}\n\n\tlist_add_tail(&hostrcb->queue, &ioa_cfg->hostrcb_report_q);\n\tschedule_work(&ioa_cfg->work_q);\n\thostrcb = ipr_get_free_hostrcb(ioa_cfg);\n\n\tipr_send_hcam(ioa_cfg, IPR_HCAM_CDB_OP_CODE_LOG_DATA, hostrcb);\n}\n\n/**\n * ipr_timeout -  An internally generated op has timed out.\n * @t: Timer context used to fetch ipr command struct\n *\n * This function blocks host requests and initiates an\n * adapter reset.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_timeout(struct timer_list *t)\n{\n\tstruct ipr_cmnd *ipr_cmd = from_timer(ipr_cmd, t, timer);\n\tunsigned long lock_flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tioa_cfg->errors_logged++;\n\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\"Adapter being reset due to command timeout.\\n\");\n\n\tif (WAIT_FOR_DUMP == ioa_cfg->sdt_state)\n\t\tioa_cfg->sdt_state = GET_DUMP;\n\n\tif (!ioa_cfg->in_reset_reload || ioa_cfg->reset_cmd == ipr_cmd)\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tLEAVE;\n}\n\n/**\n * ipr_oper_timeout -  Adapter timed out transitioning to operational\n * @t: Timer context used to fetch ipr command struct\n *\n * This function blocks host requests and initiates an\n * adapter reset.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_oper_timeout(struct timer_list *t)\n{\n\tstruct ipr_cmnd *ipr_cmd = from_timer(ipr_cmd, t, timer);\n\tunsigned long lock_flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tioa_cfg->errors_logged++;\n\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\"Adapter timed out transitioning to operational.\\n\");\n\n\tif (WAIT_FOR_DUMP == ioa_cfg->sdt_state)\n\t\tioa_cfg->sdt_state = GET_DUMP;\n\n\tif (!ioa_cfg->in_reset_reload || ioa_cfg->reset_cmd == ipr_cmd) {\n\t\tif (ipr_fastfail)\n\t\t\tioa_cfg->reset_retries += IPR_NUM_RESET_RELOAD_RETRIES;\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t}\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tLEAVE;\n}\n\n/**\n * ipr_find_ses_entry - Find matching SES in SES table\n * @res:\tresource entry struct of SES\n *\n * Return value:\n * \tpointer to SES table entry / NULL on failure\n **/\nstatic const struct ipr_ses_table_entry *\nipr_find_ses_entry(struct ipr_resource_entry *res)\n{\n\tint i, j, matches;\n\tstruct ipr_std_inq_vpids *vpids;\n\tconst struct ipr_ses_table_entry *ste = ipr_ses_table;\n\n\tfor (i = 0; i < ARRAY_SIZE(ipr_ses_table); i++, ste++) {\n\t\tfor (j = 0, matches = 0; j < IPR_PROD_ID_LEN; j++) {\n\t\t\tif (ste->compare_product_id_byte[j] == 'X') {\n\t\t\t\tvpids = &res->std_inq_data.vpids;\n\t\t\t\tif (vpids->product_id[j] == ste->product_id[j])\n\t\t\t\t\tmatches++;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tmatches++;\n\t\t}\n\n\t\tif (matches == IPR_PROD_ID_LEN)\n\t\t\treturn ste;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * ipr_get_max_scsi_speed - Determine max SCSI speed for a given bus\n * @ioa_cfg:\tioa config struct\n * @bus:\t\tSCSI bus\n * @bus_width:\tbus width\n *\n * Return value:\n *\tSCSI bus speed in units of 100KHz, 1600 is 160 MHz\n *\tFor a 2-byte wide SCSI bus, the maximum transfer speed is\n *\ttwice the maximum transfer rate (e.g. for a wide enabled bus,\n *\tmax 160MHz = max 320MB/sec).\n **/\nstatic u32 ipr_get_max_scsi_speed(struct ipr_ioa_cfg *ioa_cfg, u8 bus, u8 bus_width)\n{\n\tstruct ipr_resource_entry *res;\n\tconst struct ipr_ses_table_entry *ste;\n\tu32 max_xfer_rate = IPR_MAX_SCSI_RATE(bus_width);\n\n\t/* Loop through each config table entry in the config table buffer */\n\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\tif (!(IPR_IS_SES_DEVICE(res->std_inq_data)))\n\t\t\tcontinue;\n\n\t\tif (bus != res->bus)\n\t\t\tcontinue;\n\n\t\tif (!(ste = ipr_find_ses_entry(res)))\n\t\t\tcontinue;\n\n\t\tmax_xfer_rate = (ste->max_bus_speed_limit * 10) / (bus_width / 8);\n\t}\n\n\treturn max_xfer_rate;\n}\n\n/**\n * ipr_wait_iodbg_ack - Wait for an IODEBUG ACK from the IOA\n * @ioa_cfg:\t\tioa config struct\n * @max_delay:\t\tmax delay in micro-seconds to wait\n *\n * Waits for an IODEBUG ACK from the IOA, doing busy looping.\n *\n * Return value:\n * \t0 on success / other on failure\n **/\nstatic int ipr_wait_iodbg_ack(struct ipr_ioa_cfg *ioa_cfg, int max_delay)\n{\n\tvolatile u32 pcii_reg;\n\tint delay = 1;\n\n\t/* Read interrupt reg until IOA signals IO Debug Acknowledge */\n\twhile (delay < max_delay) {\n\t\tpcii_reg = readl(ioa_cfg->regs.sense_interrupt_reg);\n\n\t\tif (pcii_reg & IPR_PCII_IO_DEBUG_ACKNOWLEDGE)\n\t\t\treturn 0;\n\n\t\t/* udelay cannot be used if delay is more than a few milliseconds */\n\t\tif ((delay / 1000) > MAX_UDELAY_MS)\n\t\t\tmdelay(delay / 1000);\n\t\telse\n\t\t\tudelay(delay);\n\n\t\tdelay += delay;\n\t}\n\treturn -EIO;\n}\n\n/**\n * ipr_get_sis64_dump_data_section - Dump IOA memory\n * @ioa_cfg:\t\t\tioa config struct\n * @start_addr:\t\t\tadapter address to dump\n * @dest:\t\t\tdestination kernel buffer\n * @length_in_words:\t\tlength to dump in 4 byte words\n *\n * Return value:\n * \t0 on success\n **/\nstatic int ipr_get_sis64_dump_data_section(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t   u32 start_addr,\n\t\t\t\t\t   __be32 *dest, u32 length_in_words)\n{\n\tint i;\n\n\tfor (i = 0; i < length_in_words; i++) {\n\t\twritel(start_addr+(i*4), ioa_cfg->regs.dump_addr_reg);\n\t\t*dest = cpu_to_be32(readl(ioa_cfg->regs.dump_data_reg));\n\t\tdest++;\n\t}\n\n\treturn 0;\n}\n\n/**\n * ipr_get_ldump_data_section - Dump IOA memory\n * @ioa_cfg:\t\t\tioa config struct\n * @start_addr:\t\t\tadapter address to dump\n * @dest:\t\t\t\tdestination kernel buffer\n * @length_in_words:\tlength to dump in 4 byte words\n *\n * Return value:\n * \t0 on success / -EIO on failure\n **/\nstatic int ipr_get_ldump_data_section(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t      u32 start_addr,\n\t\t\t\t      __be32 *dest, u32 length_in_words)\n{\n\tvolatile u32 temp_pcii_reg;\n\tint i, delay = 0;\n\n\tif (ioa_cfg->sis64)\n\t\treturn ipr_get_sis64_dump_data_section(ioa_cfg, start_addr,\n\t\t\t\t\t\t       dest, length_in_words);\n\n\t/* Write IOA interrupt reg starting LDUMP state  */\n\twritel((IPR_UPROCI_RESET_ALERT | IPR_UPROCI_IO_DEBUG_ALERT),\n\t       ioa_cfg->regs.set_uproc_interrupt_reg32);\n\n\t/* Wait for IO debug acknowledge */\n\tif (ipr_wait_iodbg_ack(ioa_cfg,\n\t\t\t       IPR_LDUMP_MAX_LONG_ACK_DELAY_IN_USEC)) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"IOA dump long data transfer timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* Signal LDUMP interlocked - clear IO debug ack */\n\twritel(IPR_PCII_IO_DEBUG_ACKNOWLEDGE,\n\t       ioa_cfg->regs.clr_interrupt_reg);\n\n\t/* Write Mailbox with starting address */\n\twritel(start_addr, ioa_cfg->ioa_mailbox);\n\n\t/* Signal address valid - clear IOA Reset alert */\n\twritel(IPR_UPROCI_RESET_ALERT,\n\t       ioa_cfg->regs.clr_uproc_interrupt_reg32);\n\n\tfor (i = 0; i < length_in_words; i++) {\n\t\t/* Wait for IO debug acknowledge */\n\t\tif (ipr_wait_iodbg_ack(ioa_cfg,\n\t\t\t\t       IPR_LDUMP_MAX_SHORT_ACK_DELAY_IN_USEC)) {\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"IOA dump short data transfer timeout\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/* Read data from mailbox and increment destination pointer */\n\t\t*dest = cpu_to_be32(readl(ioa_cfg->ioa_mailbox));\n\t\tdest++;\n\n\t\t/* For all but the last word of data, signal data received */\n\t\tif (i < (length_in_words - 1)) {\n\t\t\t/* Signal dump data received - Clear IO debug Ack */\n\t\t\twritel(IPR_PCII_IO_DEBUG_ACKNOWLEDGE,\n\t\t\t       ioa_cfg->regs.clr_interrupt_reg);\n\t\t}\n\t}\n\n\t/* Signal end of block transfer. Set reset alert then clear IO debug ack */\n\twritel(IPR_UPROCI_RESET_ALERT,\n\t       ioa_cfg->regs.set_uproc_interrupt_reg32);\n\n\twritel(IPR_UPROCI_IO_DEBUG_ALERT,\n\t       ioa_cfg->regs.clr_uproc_interrupt_reg32);\n\n\t/* Signal dump data received - Clear IO debug Ack */\n\twritel(IPR_PCII_IO_DEBUG_ACKNOWLEDGE,\n\t       ioa_cfg->regs.clr_interrupt_reg);\n\n\t/* Wait for IOA to signal LDUMP exit - IOA reset alert will be cleared */\n\twhile (delay < IPR_LDUMP_MAX_SHORT_ACK_DELAY_IN_USEC) {\n\t\ttemp_pcii_reg =\n\t\t    readl(ioa_cfg->regs.sense_uproc_interrupt_reg32);\n\n\t\tif (!(temp_pcii_reg & IPR_UPROCI_RESET_ALERT))\n\t\t\treturn 0;\n\n\t\tudelay(10);\n\t\tdelay += 10;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_SCSI_IPR_DUMP\n/**\n * ipr_sdt_copy - Copy Smart Dump Table to kernel buffer\n * @ioa_cfg:\t\tioa config struct\n * @pci_address:\tadapter address\n * @length:\t\t\tlength of data to copy\n *\n * Copy data from PCI adapter to kernel buffer.\n * Note: length MUST be a 4 byte multiple\n * Return value:\n * \t0 on success / other on failure\n **/\nstatic int ipr_sdt_copy(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\tunsigned long pci_address, u32 length)\n{\n\tint bytes_copied = 0;\n\tint cur_len, rc, rem_len, rem_page_len, max_dump_size;\n\t__be32 *page;\n\tunsigned long lock_flags = 0;\n\tstruct ipr_ioa_dump *ioa_dump = &ioa_cfg->dump->ioa_dump;\n\n\tif (ioa_cfg->sis64)\n\t\tmax_dump_size = IPR_FMT3_MAX_IOA_DUMP_SIZE;\n\telse\n\t\tmax_dump_size = IPR_FMT2_MAX_IOA_DUMP_SIZE;\n\n\twhile (bytes_copied < length &&\n\t       (ioa_dump->hdr.len + bytes_copied) < max_dump_size) {\n\t\tif (ioa_dump->page_offset >= PAGE_SIZE ||\n\t\t    ioa_dump->page_offset == 0) {\n\t\t\tpage = (__be32 *)__get_free_page(GFP_ATOMIC);\n\n\t\t\tif (!page) {\n\t\t\t\tipr_trace;\n\t\t\t\treturn bytes_copied;\n\t\t\t}\n\n\t\t\tioa_dump->page_offset = 0;\n\t\t\tioa_dump->ioa_data[ioa_dump->next_page_index] = page;\n\t\t\tioa_dump->next_page_index++;\n\t\t} else\n\t\t\tpage = ioa_dump->ioa_data[ioa_dump->next_page_index - 1];\n\n\t\trem_len = length - bytes_copied;\n\t\trem_page_len = PAGE_SIZE - ioa_dump->page_offset;\n\t\tcur_len = min(rem_len, rem_page_len);\n\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\tif (ioa_cfg->sdt_state == ABORT_DUMP) {\n\t\t\trc = -EIO;\n\t\t} else {\n\t\t\trc = ipr_get_ldump_data_section(ioa_cfg,\n\t\t\t\t\t\t\tpci_address + bytes_copied,\n\t\t\t\t\t\t\t&page[ioa_dump->page_offset / 4],\n\t\t\t\t\t\t\t(cur_len / sizeof(u32)));\n\t\t}\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\t\tif (!rc) {\n\t\t\tioa_dump->page_offset += cur_len;\n\t\t\tbytes_copied += cur_len;\n\t\t} else {\n\t\t\tipr_trace;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t}\n\n\treturn bytes_copied;\n}\n\n/**\n * ipr_init_dump_entry_hdr - Initialize a dump entry header.\n * @hdr:\tdump entry header struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_init_dump_entry_hdr(struct ipr_dump_entry_header *hdr)\n{\n\thdr->eye_catcher = IPR_DUMP_EYE_CATCHER;\n\thdr->num_elems = 1;\n\thdr->offset = sizeof(*hdr);\n\thdr->status = IPR_DUMP_STATUS_SUCCESS;\n}\n\n/**\n * ipr_dump_ioa_type_data - Fill in the adapter type in the dump.\n * @ioa_cfg:\tioa config struct\n * @driver_dump:\tdriver dump struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_dump_ioa_type_data(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t   struct ipr_driver_dump *driver_dump)\n{\n\tstruct ipr_inquiry_page3 *ucode_vpd = &ioa_cfg->vpd_cbs->page3_data;\n\n\tipr_init_dump_entry_hdr(&driver_dump->ioa_type_entry.hdr);\n\tdriver_dump->ioa_type_entry.hdr.len =\n\t\tsizeof(struct ipr_dump_ioa_type_entry) -\n\t\tsizeof(struct ipr_dump_entry_header);\n\tdriver_dump->ioa_type_entry.hdr.data_type = IPR_DUMP_DATA_TYPE_BINARY;\n\tdriver_dump->ioa_type_entry.hdr.id = IPR_DUMP_DRIVER_TYPE_ID;\n\tdriver_dump->ioa_type_entry.type = ioa_cfg->type;\n\tdriver_dump->ioa_type_entry.fw_version = (ucode_vpd->major_release << 24) |\n\t\t(ucode_vpd->card_type << 16) | (ucode_vpd->minor_release[0] << 8) |\n\t\tucode_vpd->minor_release[1];\n\tdriver_dump->hdr.num_entries++;\n}\n\n/**\n * ipr_dump_version_data - Fill in the driver version in the dump.\n * @ioa_cfg:\tioa config struct\n * @driver_dump:\tdriver dump struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_dump_version_data(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t  struct ipr_driver_dump *driver_dump)\n{\n\tipr_init_dump_entry_hdr(&driver_dump->version_entry.hdr);\n\tdriver_dump->version_entry.hdr.len =\n\t\tsizeof(struct ipr_dump_version_entry) -\n\t\tsizeof(struct ipr_dump_entry_header);\n\tdriver_dump->version_entry.hdr.data_type = IPR_DUMP_DATA_TYPE_ASCII;\n\tdriver_dump->version_entry.hdr.id = IPR_DUMP_DRIVER_VERSION_ID;\n\tstrcpy(driver_dump->version_entry.version, IPR_DRIVER_VERSION);\n\tdriver_dump->hdr.num_entries++;\n}\n\n/**\n * ipr_dump_trace_data - Fill in the IOA trace in the dump.\n * @ioa_cfg:\tioa config struct\n * @driver_dump:\tdriver dump struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_dump_trace_data(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t   struct ipr_driver_dump *driver_dump)\n{\n\tipr_init_dump_entry_hdr(&driver_dump->trace_entry.hdr);\n\tdriver_dump->trace_entry.hdr.len =\n\t\tsizeof(struct ipr_dump_trace_entry) -\n\t\tsizeof(struct ipr_dump_entry_header);\n\tdriver_dump->trace_entry.hdr.data_type = IPR_DUMP_DATA_TYPE_BINARY;\n\tdriver_dump->trace_entry.hdr.id = IPR_DUMP_TRACE_ID;\n\tmemcpy(driver_dump->trace_entry.trace, ioa_cfg->trace, IPR_TRACE_SIZE);\n\tdriver_dump->hdr.num_entries++;\n}\n\n/**\n * ipr_dump_location_data - Fill in the IOA location in the dump.\n * @ioa_cfg:\tioa config struct\n * @driver_dump:\tdriver dump struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_dump_location_data(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t   struct ipr_driver_dump *driver_dump)\n{\n\tipr_init_dump_entry_hdr(&driver_dump->location_entry.hdr);\n\tdriver_dump->location_entry.hdr.len =\n\t\tsizeof(struct ipr_dump_location_entry) -\n\t\tsizeof(struct ipr_dump_entry_header);\n\tdriver_dump->location_entry.hdr.data_type = IPR_DUMP_DATA_TYPE_ASCII;\n\tdriver_dump->location_entry.hdr.id = IPR_DUMP_LOCATION_ID;\n\tstrcpy(driver_dump->location_entry.location, dev_name(&ioa_cfg->pdev->dev));\n\tdriver_dump->hdr.num_entries++;\n}\n\n/**\n * ipr_get_ioa_dump - Perform a dump of the driver and adapter.\n * @ioa_cfg:\tioa config struct\n * @dump:\t\tdump struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_get_ioa_dump(struct ipr_ioa_cfg *ioa_cfg, struct ipr_dump *dump)\n{\n\tunsigned long start_addr, sdt_word;\n\tunsigned long lock_flags = 0;\n\tstruct ipr_driver_dump *driver_dump = &dump->driver_dump;\n\tstruct ipr_ioa_dump *ioa_dump = &dump->ioa_dump;\n\tu32 num_entries, max_num_entries, start_off, end_off;\n\tu32 max_dump_size, bytes_to_copy, bytes_copied, rc;\n\tstruct ipr_sdt *sdt;\n\tint valid = 1;\n\tint i;\n\n\tENTER;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (ioa_cfg->sdt_state != READ_DUMP) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tif (ioa_cfg->sis64) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tssleep(IPR_DUMP_DELAY_SECONDS);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t}\n\n\tstart_addr = readl(ioa_cfg->ioa_mailbox);\n\n\tif (!ioa_cfg->sis64 && !ipr_sdt_is_fmt2(start_addr)) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Invalid dump table format: %lx\\n\", start_addr);\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tdev_err(&ioa_cfg->pdev->dev, \"Dump of IOA initiated\\n\");\n\n\tdriver_dump->hdr.eye_catcher = IPR_DUMP_EYE_CATCHER;\n\n\t/* Initialize the overall dump header */\n\tdriver_dump->hdr.len = sizeof(struct ipr_driver_dump);\n\tdriver_dump->hdr.num_entries = 1;\n\tdriver_dump->hdr.first_entry_offset = sizeof(struct ipr_dump_header);\n\tdriver_dump->hdr.status = IPR_DUMP_STATUS_SUCCESS;\n\tdriver_dump->hdr.os = IPR_DUMP_OS_LINUX;\n\tdriver_dump->hdr.driver_name = IPR_DUMP_DRIVER_NAME;\n\n\tipr_dump_version_data(ioa_cfg, driver_dump);\n\tipr_dump_location_data(ioa_cfg, driver_dump);\n\tipr_dump_ioa_type_data(ioa_cfg, driver_dump);\n\tipr_dump_trace_data(ioa_cfg, driver_dump);\n\n\t/* Update dump_header */\n\tdriver_dump->hdr.len += sizeof(struct ipr_dump_entry_header);\n\n\t/* IOA Dump entry */\n\tipr_init_dump_entry_hdr(&ioa_dump->hdr);\n\tioa_dump->hdr.len = 0;\n\tioa_dump->hdr.data_type = IPR_DUMP_DATA_TYPE_BINARY;\n\tioa_dump->hdr.id = IPR_DUMP_IOA_DUMP_ID;\n\n\t/* First entries in sdt are actually a list of dump addresses and\n\t lengths to gather the real dump data.  sdt represents the pointer\n\t to the ioa generated dump table.  Dump data will be extracted based\n\t on entries in this table */\n\tsdt = &ioa_dump->sdt;\n\n\tif (ioa_cfg->sis64) {\n\t\tmax_num_entries = IPR_FMT3_NUM_SDT_ENTRIES;\n\t\tmax_dump_size = IPR_FMT3_MAX_IOA_DUMP_SIZE;\n\t} else {\n\t\tmax_num_entries = IPR_FMT2_NUM_SDT_ENTRIES;\n\t\tmax_dump_size = IPR_FMT2_MAX_IOA_DUMP_SIZE;\n\t}\n\n\tbytes_to_copy = offsetof(struct ipr_sdt, entry) +\n\t\t\t(max_num_entries * sizeof(struct ipr_sdt_entry));\n\trc = ipr_get_ldump_data_section(ioa_cfg, start_addr, (__be32 *)sdt,\n\t\t\t\t\tbytes_to_copy / sizeof(__be32));\n\n\t/* Smart Dump table is ready to use and the first entry is valid */\n\tif (rc || ((be32_to_cpu(sdt->hdr.state) != IPR_FMT3_SDT_READY_TO_USE) &&\n\t    (be32_to_cpu(sdt->hdr.state) != IPR_FMT2_SDT_READY_TO_USE))) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Dump of IOA failed. Dump table not valid: %d, %X.\\n\",\n\t\t\trc, be32_to_cpu(sdt->hdr.state));\n\t\tdriver_dump->hdr.status = IPR_DUMP_STATUS_FAILED;\n\t\tioa_cfg->sdt_state = DUMP_OBTAINED;\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tnum_entries = be32_to_cpu(sdt->hdr.num_entries_used);\n\n\tif (num_entries > max_num_entries)\n\t\tnum_entries = max_num_entries;\n\n\t/* Update dump length to the actual data to be copied */\n\tdump->driver_dump.hdr.len += sizeof(struct ipr_sdt_header);\n\tif (ioa_cfg->sis64)\n\t\tdump->driver_dump.hdr.len += num_entries * sizeof(struct ipr_sdt_entry);\n\telse\n\t\tdump->driver_dump.hdr.len += max_num_entries * sizeof(struct ipr_sdt_entry);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (ioa_dump->hdr.len > max_dump_size) {\n\t\t\tdriver_dump->hdr.status = IPR_DUMP_STATUS_QUAL_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdt->entry[i].flags & IPR_SDT_VALID_ENTRY) {\n\t\t\tsdt_word = be32_to_cpu(sdt->entry[i].start_token);\n\t\t\tif (ioa_cfg->sis64)\n\t\t\t\tbytes_to_copy = be32_to_cpu(sdt->entry[i].end_token);\n\t\t\telse {\n\t\t\t\tstart_off = sdt_word & IPR_FMT2_MBX_ADDR_MASK;\n\t\t\t\tend_off = be32_to_cpu(sdt->entry[i].end_token);\n\n\t\t\t\tif (ipr_sdt_is_fmt2(sdt_word) && sdt_word)\n\t\t\t\t\tbytes_to_copy = end_off - start_off;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t\tif (valid) {\n\t\t\t\tif (bytes_to_copy > max_dump_size) {\n\t\t\t\t\tsdt->entry[i].flags &= ~IPR_SDT_VALID_ENTRY;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/* Copy data from adapter to driver buffers */\n\t\t\t\tbytes_copied = ipr_sdt_copy(ioa_cfg, sdt_word,\n\t\t\t\t\t\t\t    bytes_to_copy);\n\n\t\t\t\tioa_dump->hdr.len += bytes_copied;\n\n\t\t\t\tif (bytes_copied != bytes_to_copy) {\n\t\t\t\t\tdriver_dump->hdr.status = IPR_DUMP_STATUS_QUAL_SUCCESS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_err(&ioa_cfg->pdev->dev, \"Dump of IOA completed.\\n\");\n\n\t/* Update dump_header */\n\tdriver_dump->hdr.len += ioa_dump->hdr.len;\n\twmb();\n\tioa_cfg->sdt_state = DUMP_OBTAINED;\n\tLEAVE;\n}\n\n#else\n#define ipr_get_ioa_dump(ioa_cfg, dump) do { } while (0)\n#endif\n\n/**\n * ipr_release_dump - Free adapter dump memory\n * @kref:\tkref struct\n *\n * Return value:\n *\tnothing\n **/\nstatic void ipr_release_dump(struct kref *kref)\n{\n\tstruct ipr_dump *dump = container_of(kref, struct ipr_dump, kref);\n\tstruct ipr_ioa_cfg *ioa_cfg = dump->ioa_cfg;\n\tunsigned long lock_flags = 0;\n\tint i;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tioa_cfg->dump = NULL;\n\tioa_cfg->sdt_state = INACTIVE;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tfor (i = 0; i < dump->ioa_dump.next_page_index; i++)\n\t\tfree_page((unsigned long) dump->ioa_dump.ioa_data[i]);\n\n\tvfree(dump->ioa_dump.ioa_data);\n\tkfree(dump);\n\tLEAVE;\n}\n\nstatic void ipr_add_remove_thread(struct work_struct *work)\n{\n\tunsigned long lock_flags;\n\tstruct ipr_resource_entry *res;\n\tstruct scsi_device *sdev;\n\tstruct ipr_ioa_cfg *ioa_cfg =\n\t\tcontainer_of(work, struct ipr_ioa_cfg, scsi_add_work_q);\n\tu8 bus, target, lun;\n\tint did_work;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\nrestart:\n\tdo {\n\t\tdid_work = 0;\n\t\tif (!ioa_cfg->hrrq[IPR_INIT_HRRQ].allow_cmds) {\n\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\t\treturn;\n\t\t}\n\n\t\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\t\tif (res->del_from_ml && res->sdev) {\n\t\t\t\tdid_work = 1;\n\t\t\t\tsdev = res->sdev;\n\t\t\t\tif (!scsi_device_get(sdev)) {\n\t\t\t\t\tif (!res->add_to_ml)\n\t\t\t\t\t\tlist_move_tail(&res->queue, &ioa_cfg->free_res_q);\n\t\t\t\t\telse\n\t\t\t\t\t\tres->del_from_ml = 0;\n\t\t\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\t\t\t\tscsi_remove_device(sdev);\n\t\t\t\t\tscsi_device_put(sdev);\n\t\t\t\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (did_work);\n\n\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\tif (res->add_to_ml) {\n\t\t\tbus = res->bus;\n\t\t\ttarget = res->target;\n\t\t\tlun = res->lun;\n\t\t\tres->add_to_ml = 0;\n\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\t\tscsi_add_device(ioa_cfg->host, bus, target, lun);\n\t\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tioa_cfg->scan_done = 1;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tkobject_uevent(&ioa_cfg->host->shost_dev.kobj, KOBJ_CHANGE);\n\tLEAVE;\n}\n\n/**\n * ipr_worker_thread - Worker thread\n * @work:\t\tioa config struct\n *\n * Called at task level from a work thread. This function takes care\n * of adding and removing device from the mid-layer as configuration\n * changes are detected by the adapter.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_worker_thread(struct work_struct *work)\n{\n\tunsigned long lock_flags;\n\tstruct ipr_dump *dump;\n\tstruct ipr_ioa_cfg *ioa_cfg =\n\t\tcontainer_of(work, struct ipr_ioa_cfg, work_q);\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (ioa_cfg->sdt_state == READ_DUMP) {\n\t\tdump = ioa_cfg->dump;\n\t\tif (!dump) {\n\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\t\treturn;\n\t\t}\n\t\tkref_get(&dump->kref);\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tipr_get_ioa_dump(ioa_cfg, dump);\n\t\tkref_put(&dump->kref, ipr_release_dump);\n\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\tif (ioa_cfg->sdt_state == DUMP_OBTAINED && !ioa_cfg->dump_timeout)\n\t\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tif (ioa_cfg->scsi_unblock) {\n\t\tioa_cfg->scsi_unblock = 0;\n\t\tioa_cfg->scsi_blocked = 0;\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tscsi_unblock_requests(ioa_cfg->host);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\tif (ioa_cfg->scsi_blocked)\n\t\t\tscsi_block_requests(ioa_cfg->host);\n\t}\n\n\tif (!ioa_cfg->scan_enabled) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tschedule_work(&ioa_cfg->scsi_add_work_q);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tLEAVE;\n}\n\n#ifdef CONFIG_SCSI_IPR_TRACE\n/**\n * ipr_read_trace - Dump the adapter trace\n * @filp:\t\topen sysfs file\n * @kobj:\t\tkobject struct\n * @bin_attr:\t\tbin_attribute struct\n * @buf:\t\tbuffer\n * @off:\t\toffset\n * @count:\t\tbuffer size\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_read_trace(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr,\n\t\t\t      char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\tssize_t ret;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tret = memory_read_from_buffer(buf, count, &off, ioa_cfg->trace,\n\t\t\t\tIPR_TRACE_SIZE);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\treturn ret;\n}\n\nstatic struct bin_attribute ipr_trace_attr = {\n\t.attr =\t{\n\t\t.name = \"trace\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.size = 0,\n\t.read = ipr_read_trace,\n};\n#endif\n\n/**\n * ipr_show_fw_version - Show the firmware version\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_fw_version(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tstruct ipr_inquiry_page3 *ucode_vpd = &ioa_cfg->vpd_cbs->page3_data;\n\tunsigned long lock_flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"%02X%02X%02X%02X\\n\",\n\t\t       ucode_vpd->major_release, ucode_vpd->card_type,\n\t\t       ucode_vpd->minor_release[0],\n\t\t       ucode_vpd->minor_release[1]);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_fw_version_attr = {\n\t.attr = {\n\t\t.name =\t\t\"fw_version\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = ipr_show_fw_version,\n};\n\n/**\n * ipr_show_log_level - Show the adapter's error logging level\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_log_level(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d\\n\", ioa_cfg->log_level);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\n/**\n * ipr_store_log_level - Change the adapter's error logging level\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\tbuffer size\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_store_log_level(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tioa_cfg->log_level = simple_strtoul(buf, NULL, 10);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn strlen(buf);\n}\n\nstatic struct device_attribute ipr_log_level_attr = {\n\t.attr = {\n\t\t.name =\t\t\"log_level\",\n\t\t.mode =\t\tS_IRUGO | S_IWUSR,\n\t},\n\t.show = ipr_show_log_level,\n\t.store = ipr_store_log_level\n};\n\n/**\n * ipr_store_diagnostics - IOA Diagnostics interface\n * @dev:\tdevice struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\tbuffer size\n *\n * This function will reset the adapter and wait a reasonable\n * amount of time for any errors that the adapter might log.\n *\n * Return value:\n * \tcount on success / other on failure\n **/\nstatic ssize_t ipr_store_diagnostics(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\tint rc = count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t}\n\n\tioa_cfg->errors_logged = 0;\n\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NORMAL);\n\n\tif (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\n\t\t/* Wait for a second for any errors to be logged */\n\t\tmsleep(1000);\n\t} else {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (ioa_cfg->in_reset_reload || ioa_cfg->errors_logged)\n\t\trc = -EIO;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\treturn rc;\n}\n\nstatic struct device_attribute ipr_diagnostics_attr = {\n\t.attr = {\n\t\t.name =\t\t\"run_diagnostics\",\n\t\t.mode =\t\tS_IWUSR,\n\t},\n\t.store = ipr_store_diagnostics\n};\n\n/**\n * ipr_show_adapter_state - Show the adapter's state\n * @dev:\tdevice struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_adapter_state(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"offline\\n\");\n\telse\n\t\tlen = snprintf(buf, PAGE_SIZE, \"online\\n\");\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\n/**\n * ipr_store_adapter_state - Change adapter state\n * @dev:\tdevice struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\tbuffer size\n *\n * This function will change the adapter's state.\n *\n * Return value:\n * \tcount on success / other on failure\n **/\nstatic ssize_t ipr_store_adapter_state(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags;\n\tint result = count, i;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead &&\n\t    !strncmp(buf, \"online\", 6)) {\n\t\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\t\tioa_cfg->hrrq[i].ioa_is_dead = 0;\n\t\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t\t}\n\t\twmb();\n\t\tioa_cfg->reset_retries = 0;\n\t\tioa_cfg->in_ioa_bringdown = 0;\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t}\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\n\treturn result;\n}\n\nstatic struct device_attribute ipr_ioa_state_attr = {\n\t.attr = {\n\t\t.name =\t\t\"online_state\",\n\t\t.mode =\t\tS_IRUGO | S_IWUSR,\n\t},\n\t.show = ipr_show_adapter_state,\n\t.store = ipr_store_adapter_state\n};\n\n/**\n * ipr_store_reset_adapter - Reset the adapter\n * @dev:\tdevice struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\tbuffer size\n *\n * This function will reset the adapter.\n *\n * Return value:\n * \tcount on success / other on failure\n **/\nstatic ssize_t ipr_store_reset_adapter(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags;\n\tint result = count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (!ioa_cfg->in_reset_reload)\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NORMAL);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\n\treturn result;\n}\n\nstatic struct device_attribute ipr_ioa_reset_attr = {\n\t.attr = {\n\t\t.name =\t\t\"reset_host\",\n\t\t.mode =\t\tS_IWUSR,\n\t},\n\t.store = ipr_store_reset_adapter\n};\n\nstatic int ipr_iopoll(struct irq_poll *iop, int budget);\n /**\n * ipr_show_iopoll_weight - Show ipr polling mode\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_iopoll_weight(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(shost->host_lock, lock_flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d\\n\", ioa_cfg->iopoll_weight);\n\tspin_unlock_irqrestore(shost->host_lock, lock_flags);\n\n\treturn len;\n}\n\n/**\n * ipr_store_iopoll_weight - Change the adapter's polling mode\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\tbuffer size\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_store_iopoll_weight(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long user_iopoll_weight;\n\tunsigned long lock_flags = 0;\n\tint i;\n\n\tif (!ioa_cfg->sis64) {\n\t\tdev_info(&ioa_cfg->pdev->dev, \"irq_poll not supported on this adapter\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (kstrtoul(buf, 10, &user_iopoll_weight))\n\t\treturn -EINVAL;\n\n\tif (user_iopoll_weight > 256) {\n\t\tdev_info(&ioa_cfg->pdev->dev, \"Invalid irq_poll weight. It must be less than 256\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (user_iopoll_weight == ioa_cfg->iopoll_weight) {\n\t\tdev_info(&ioa_cfg->pdev->dev, \"Current irq_poll weight has the same weight\\n\");\n\t\treturn strlen(buf);\n\t}\n\n\tif (ioa_cfg->iopoll_weight && ioa_cfg->sis64 && ioa_cfg->nvectors > 1) {\n\t\tfor (i = 1; i < ioa_cfg->hrrq_num; i++)\n\t\t\tirq_poll_disable(&ioa_cfg->hrrq[i].iopoll);\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, lock_flags);\n\tioa_cfg->iopoll_weight = user_iopoll_weight;\n\tif (ioa_cfg->iopoll_weight && ioa_cfg->sis64 && ioa_cfg->nvectors > 1) {\n\t\tfor (i = 1; i < ioa_cfg->hrrq_num; i++) {\n\t\t\tirq_poll_init(&ioa_cfg->hrrq[i].iopoll,\n\t\t\t\t\tioa_cfg->iopoll_weight, ipr_iopoll);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, lock_flags);\n\n\treturn strlen(buf);\n}\n\nstatic struct device_attribute ipr_iopoll_weight_attr = {\n\t.attr = {\n\t\t.name =\t\t\"iopoll_weight\",\n\t\t.mode =\t\tS_IRUGO | S_IWUSR,\n\t},\n\t.show = ipr_show_iopoll_weight,\n\t.store = ipr_store_iopoll_weight\n};\n\n/**\n * ipr_alloc_ucode_buffer - Allocates a microcode download buffer\n * @buf_len:\t\tbuffer length\n *\n * Allocates a DMA'able buffer in chunks and assembles a scatter/gather\n * list to use for microcode download\n *\n * Return value:\n * \tpointer to sglist / NULL on failure\n **/\nstatic struct ipr_sglist *ipr_alloc_ucode_buffer(int buf_len)\n{\n\tint sg_size, order;\n\tstruct ipr_sglist *sglist;\n\n\t/* Get the minimum size per scatter/gather element */\n\tsg_size = buf_len / (IPR_MAX_SGLIST - 1);\n\n\t/* Get the actual size per element */\n\torder = get_order(sg_size);\n\n\t/* Allocate a scatter/gather list for the DMA */\n\tsglist = kzalloc(sizeof(struct ipr_sglist), GFP_KERNEL);\n\tif (sglist == NULL) {\n\t\tipr_trace;\n\t\treturn NULL;\n\t}\n\tsglist->order = order;\n\tsglist->scatterlist = sgl_alloc_order(buf_len, order, false, GFP_KERNEL,\n\t\t\t\t\t      &sglist->num_sg);\n\tif (!sglist->scatterlist) {\n\t\tkfree(sglist);\n\t\treturn NULL;\n\t}\n\n\treturn sglist;\n}\n\n/**\n * ipr_free_ucode_buffer - Frees a microcode download buffer\n * @sglist:\t\tscatter/gather list pointer\n *\n * Free a DMA'able ucode download buffer previously allocated with\n * ipr_alloc_ucode_buffer\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_free_ucode_buffer(struct ipr_sglist *sglist)\n{\n\tsgl_free_order(sglist->scatterlist, sglist->order);\n\tkfree(sglist);\n}\n\n/**\n * ipr_copy_ucode_buffer - Copy user buffer to kernel buffer\n * @sglist:\t\tscatter/gather list pointer\n * @buffer:\t\tbuffer pointer\n * @len:\t\tbuffer length\n *\n * Copy a microcode image from a user buffer into a buffer allocated by\n * ipr_alloc_ucode_buffer\n *\n * Return value:\n * \t0 on success / other on failure\n **/\nstatic int ipr_copy_ucode_buffer(struct ipr_sglist *sglist,\n\t\t\t\t u8 *buffer, u32 len)\n{\n\tint bsize_elem, i, result = 0;\n\tstruct scatterlist *sg;\n\tvoid *kaddr;\n\n\t/* Determine the actual number of bytes per element */\n\tbsize_elem = PAGE_SIZE * (1 << sglist->order);\n\n\tsg = sglist->scatterlist;\n\n\tfor (i = 0; i < (len / bsize_elem); i++, sg = sg_next(sg),\n\t\t\tbuffer += bsize_elem) {\n\t\tstruct page *page = sg_page(sg);\n\n\t\tkaddr = kmap(page);\n\t\tmemcpy(kaddr, buffer, bsize_elem);\n\t\tkunmap(page);\n\n\t\tsg->length = bsize_elem;\n\n\t\tif (result != 0) {\n\t\t\tipr_trace;\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tif (len % bsize_elem) {\n\t\tstruct page *page = sg_page(sg);\n\n\t\tkaddr = kmap(page);\n\t\tmemcpy(kaddr, buffer, len % bsize_elem);\n\t\tkunmap(page);\n\n\t\tsg->length = len % bsize_elem;\n\t}\n\n\tsglist->buffer_len = len;\n\treturn result;\n}\n\n/**\n * ipr_build_ucode_ioadl64 - Build a microcode download IOADL\n * @ipr_cmd:\t\tipr command struct\n * @sglist:\t\tscatter/gather list\n *\n * Builds a microcode download IOA data list (IOADL).\n *\n **/\nstatic void ipr_build_ucode_ioadl64(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t    struct ipr_sglist *sglist)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioadl64_desc *ioadl64 = ipr_cmd->i.ioadl64;\n\tstruct scatterlist *scatterlist = sglist->scatterlist;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tipr_cmd->dma_use_sg = sglist->num_dma_sg;\n\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\tioarcb->data_transfer_length = cpu_to_be32(sglist->buffer_len);\n\n\tioarcb->ioadl_len =\n\t\tcpu_to_be32(sizeof(struct ipr_ioadl64_desc) * ipr_cmd->dma_use_sg);\n\tfor_each_sg(scatterlist, sg, ipr_cmd->dma_use_sg, i) {\n\t\tioadl64[i].flags = cpu_to_be32(IPR_IOADL_FLAGS_WRITE);\n\t\tioadl64[i].data_len = cpu_to_be32(sg_dma_len(sg));\n\t\tioadl64[i].address = cpu_to_be64(sg_dma_address(sg));\n\t}\n\n\tioadl64[i-1].flags |= cpu_to_be32(IPR_IOADL_FLAGS_LAST);\n}\n\n/**\n * ipr_build_ucode_ioadl - Build a microcode download IOADL\n * @ipr_cmd:\tipr command struct\n * @sglist:\t\tscatter/gather list\n *\n * Builds a microcode download IOA data list (IOADL).\n *\n **/\nstatic void ipr_build_ucode_ioadl(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t  struct ipr_sglist *sglist)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioadl_desc *ioadl = ipr_cmd->i.ioadl;\n\tstruct scatterlist *scatterlist = sglist->scatterlist;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tipr_cmd->dma_use_sg = sglist->num_dma_sg;\n\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\tioarcb->data_transfer_length = cpu_to_be32(sglist->buffer_len);\n\n\tioarcb->ioadl_len =\n\t\tcpu_to_be32(sizeof(struct ipr_ioadl_desc) * ipr_cmd->dma_use_sg);\n\n\tfor_each_sg(scatterlist, sg, ipr_cmd->dma_use_sg, i) {\n\t\tioadl[i].flags_and_data_len =\n\t\t\tcpu_to_be32(IPR_IOADL_FLAGS_WRITE | sg_dma_len(sg));\n\t\tioadl[i].address =\n\t\t\tcpu_to_be32(sg_dma_address(sg));\n\t}\n\n\tioadl[i-1].flags_and_data_len |=\n\t\tcpu_to_be32(IPR_IOADL_FLAGS_LAST);\n}\n\n/**\n * ipr_update_ioa_ucode - Update IOA's microcode\n * @ioa_cfg:\tioa config struct\n * @sglist:\t\tscatter/gather list\n *\n * Initiate an adapter reset to update the IOA's microcode\n *\n * Return value:\n * \t0 on success / -EIO on failure\n **/\nstatic int ipr_update_ioa_ucode(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\tstruct ipr_sglist *sglist)\n{\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t}\n\n\tif (ioa_cfg->ucode_sglist) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Microcode download already in progress\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsglist->num_dma_sg = dma_map_sg(&ioa_cfg->pdev->dev,\n\t\t\t\t\tsglist->scatterlist, sglist->num_sg,\n\t\t\t\t\tDMA_TO_DEVICE);\n\n\tif (!sglist->num_dma_sg) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Failed to map microcode download buffer!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tioa_cfg->ucode_sglist = sglist;\n\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NORMAL);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tioa_cfg->ucode_sglist = NULL;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn 0;\n}\n\n/**\n * ipr_store_update_fw - Update the firmware on the adapter\n * @dev:\tdevice struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\tbuffer size\n *\n * This function will update the firmware on the adapter.\n *\n * Return value:\n * \tcount on success / other on failure\n **/\nstatic ssize_t ipr_store_update_fw(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tstruct ipr_ucode_image_header *image_hdr;\n\tconst struct firmware *fw_entry;\n\tstruct ipr_sglist *sglist;\n\tchar fname[100];\n\tchar *src;\n\tchar *endline;\n\tint result, dnld_size;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tsnprintf(fname, sizeof(fname), \"%s\", buf);\n\n\tendline = strchr(fname, '\\n');\n\tif (endline)\n\t\t*endline = '\\0';\n\n\tif (request_firmware(&fw_entry, fname, &ioa_cfg->pdev->dev)) {\n\t\tdev_err(&ioa_cfg->pdev->dev, \"Firmware file %s not found\\n\", fname);\n\t\treturn -EIO;\n\t}\n\n\timage_hdr = (struct ipr_ucode_image_header *)fw_entry->data;\n\n\tsrc = (u8 *)image_hdr + be32_to_cpu(image_hdr->header_length);\n\tdnld_size = fw_entry->size - be32_to_cpu(image_hdr->header_length);\n\tsglist = ipr_alloc_ucode_buffer(dnld_size);\n\n\tif (!sglist) {\n\t\tdev_err(&ioa_cfg->pdev->dev, \"Microcode buffer allocation failed\\n\");\n\t\trelease_firmware(fw_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\tresult = ipr_copy_ucode_buffer(sglist, src, dnld_size);\n\n\tif (result) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Microcode buffer copy to DMA buffer failed\\n\");\n\t\tgoto out;\n\t}\n\n\tipr_info(\"Updating microcode, please be patient.  This may take up to 30 minutes.\\n\");\n\n\tresult = ipr_update_ioa_ucode(ioa_cfg, sglist);\n\n\tif (!result)\n\t\tresult = count;\nout:\n\tipr_free_ucode_buffer(sglist);\n\trelease_firmware(fw_entry);\n\treturn result;\n}\n\nstatic struct device_attribute ipr_update_fw_attr = {\n\t.attr = {\n\t\t.name =\t\t\"update_fw\",\n\t\t.mode =\t\tS_IWUSR,\n\t},\n\t.store = ipr_store_update_fw\n};\n\n/**\n * ipr_show_fw_type - Show the adapter's firmware type.\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_fw_type(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tunsigned long lock_flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d\\n\", ioa_cfg->sis64);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_ioa_fw_type_attr = {\n\t.attr = {\n\t\t.name =\t\t\"fw_type\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = ipr_show_fw_type\n};\n\nstatic ssize_t ipr_read_async_err_log(struct file *filep, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tstruct ipr_hostrcb *hostrcb;\n\tunsigned long lock_flags = 0;\n\tint ret;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\thostrcb = list_first_entry_or_null(&ioa_cfg->hostrcb_report_q,\n\t\t\t\t\tstruct ipr_hostrcb, queue);\n\tif (!hostrcb) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn 0;\n\t}\n\tret = memory_read_from_buffer(buf, count, &off, &hostrcb->hcam,\n\t\t\t\tsizeof(hostrcb->hcam));\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn ret;\n}\n\nstatic ssize_t ipr_next_async_err_log(struct file *filep, struct kobject *kobj,\n\t\t\t\tstruct bin_attribute *bin_attr, char *buf,\n\t\t\t\tloff_t off, size_t count)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tstruct ipr_hostrcb *hostrcb;\n\tunsigned long lock_flags = 0;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\thostrcb = list_first_entry_or_null(&ioa_cfg->hostrcb_report_q,\n\t\t\t\t\tstruct ipr_hostrcb, queue);\n\tif (!hostrcb) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn count;\n\t}\n\n\t/* Reclaim hostrcb before exit */\n\tlist_move_tail(&hostrcb->queue, &ioa_cfg->hostrcb_free_q);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn count;\n}\n\nstatic struct bin_attribute ipr_ioa_async_err_log = {\n\t.attr = {\n\t\t.name =\t\t\"async_err_log\",\n\t\t.mode =\t\tS_IRUGO | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = ipr_read_async_err_log,\n\t.write = ipr_next_async_err_log\n};\n\nstatic struct device_attribute *ipr_ioa_attrs[] = {\n\t&ipr_fw_version_attr,\n\t&ipr_log_level_attr,\n\t&ipr_diagnostics_attr,\n\t&ipr_ioa_state_attr,\n\t&ipr_ioa_reset_attr,\n\t&ipr_update_fw_attr,\n\t&ipr_ioa_fw_type_attr,\n\t&ipr_iopoll_weight_attr,\n\tNULL,\n};\n\n#ifdef CONFIG_SCSI_IPR_DUMP\n/**\n * ipr_read_dump - Dump the adapter\n * @filp:\t\topen sysfs file\n * @kobj:\t\tkobject struct\n * @bin_attr:\t\tbin_attribute struct\n * @buf:\t\tbuffer\n * @off:\t\toffset\n * @count:\t\tbuffer size\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_read_dump(struct file *filp, struct kobject *kobj,\n\t\t\t     struct bin_attribute *bin_attr,\n\t\t\t     char *buf, loff_t off, size_t count)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tstruct ipr_dump *dump;\n\tunsigned long lock_flags = 0;\n\tchar *src;\n\tint len, sdt_end;\n\tsize_t rc = count;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tdump = ioa_cfg->dump;\n\n\tif (ioa_cfg->sdt_state != DUMP_OBTAINED || !dump) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn 0;\n\t}\n\tkref_get(&dump->kref);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (off > dump->driver_dump.hdr.len) {\n\t\tkref_put(&dump->kref, ipr_release_dump);\n\t\treturn 0;\n\t}\n\n\tif (off + count > dump->driver_dump.hdr.len) {\n\t\tcount = dump->driver_dump.hdr.len - off;\n\t\trc = count;\n\t}\n\n\tif (count && off < sizeof(dump->driver_dump)) {\n\t\tif (off + count > sizeof(dump->driver_dump))\n\t\t\tlen = sizeof(dump->driver_dump) - off;\n\t\telse\n\t\t\tlen = count;\n\t\tsrc = (u8 *)&dump->driver_dump + off;\n\t\tmemcpy(buf, src, len);\n\t\tbuf += len;\n\t\toff += len;\n\t\tcount -= len;\n\t}\n\n\toff -= sizeof(dump->driver_dump);\n\n\tif (ioa_cfg->sis64)\n\t\tsdt_end = offsetof(struct ipr_ioa_dump, sdt.entry) +\n\t\t\t  (be32_to_cpu(dump->ioa_dump.sdt.hdr.num_entries_used) *\n\t\t\t   sizeof(struct ipr_sdt_entry));\n\telse\n\t\tsdt_end = offsetof(struct ipr_ioa_dump, sdt.entry) +\n\t\t\t  (IPR_FMT2_NUM_SDT_ENTRIES * sizeof(struct ipr_sdt_entry));\n\n\tif (count && off < sdt_end) {\n\t\tif (off + count > sdt_end)\n\t\t\tlen = sdt_end - off;\n\t\telse\n\t\t\tlen = count;\n\t\tsrc = (u8 *)&dump->ioa_dump + off;\n\t\tmemcpy(buf, src, len);\n\t\tbuf += len;\n\t\toff += len;\n\t\tcount -= len;\n\t}\n\n\toff -= sdt_end;\n\n\twhile (count) {\n\t\tif ((off & PAGE_MASK) != ((off + count) & PAGE_MASK))\n\t\t\tlen = PAGE_ALIGN(off) - off;\n\t\telse\n\t\t\tlen = count;\n\t\tsrc = (u8 *)dump->ioa_dump.ioa_data[(off & PAGE_MASK) >> PAGE_SHIFT];\n\t\tsrc += off & ~PAGE_MASK;\n\t\tmemcpy(buf, src, len);\n\t\tbuf += len;\n\t\toff += len;\n\t\tcount -= len;\n\t}\n\n\tkref_put(&dump->kref, ipr_release_dump);\n\treturn rc;\n}\n\n/**\n * ipr_alloc_dump - Prepare for adapter dump\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n *\t0 on success / other on failure\n **/\nstatic int ipr_alloc_dump(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct ipr_dump *dump;\n\t__be32 **ioa_data;\n\tunsigned long lock_flags = 0;\n\n\tdump = kzalloc(sizeof(struct ipr_dump), GFP_KERNEL);\n\n\tif (!dump) {\n\t\tipr_err(\"Dump memory allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ioa_cfg->sis64)\n\t\tioa_data = vmalloc(array_size(IPR_FMT3_MAX_NUM_DUMP_PAGES,\n\t\t\t\t\t      sizeof(__be32 *)));\n\telse\n\t\tioa_data = vmalloc(array_size(IPR_FMT2_MAX_NUM_DUMP_PAGES,\n\t\t\t\t\t      sizeof(__be32 *)));\n\n\tif (!ioa_data) {\n\t\tipr_err(\"Dump memory allocation failed\\n\");\n\t\tkfree(dump);\n\t\treturn -ENOMEM;\n\t}\n\n\tdump->ioa_dump.ioa_data = ioa_data;\n\n\tkref_init(&dump->kref);\n\tdump->ioa_cfg = ioa_cfg;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (INACTIVE != ioa_cfg->sdt_state) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tvfree(dump->ioa_dump.ioa_data);\n\t\tkfree(dump);\n\t\treturn 0;\n\t}\n\n\tioa_cfg->dump = dump;\n\tioa_cfg->sdt_state = WAIT_FOR_DUMP;\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead && !ioa_cfg->dump_taken) {\n\t\tioa_cfg->dump_taken = 1;\n\t\tschedule_work(&ioa_cfg->work_q);\n\t}\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\treturn 0;\n}\n\n/**\n * ipr_free_dump - Free adapter dump memory\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n *\t0 on success / other on failure\n **/\nstatic int ipr_free_dump(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct ipr_dump *dump;\n\tunsigned long lock_flags = 0;\n\n\tENTER;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tdump = ioa_cfg->dump;\n\tif (!dump) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn 0;\n\t}\n\n\tioa_cfg->dump = NULL;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tkref_put(&dump->kref, ipr_release_dump);\n\n\tLEAVE;\n\treturn 0;\n}\n\n/**\n * ipr_write_dump - Setup dump state of adapter\n * @filp:\t\topen sysfs file\n * @kobj:\t\tkobject struct\n * @bin_attr:\t\tbin_attribute struct\n * @buf:\t\tbuffer\n * @off:\t\toffset\n * @count:\t\tbuffer size\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_write_dump(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr,\n\t\t\t      char *buf, loff_t off, size_t count)\n{\n\tstruct device *cdev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\tint rc;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (buf[0] == '1')\n\t\trc = ipr_alloc_dump(ioa_cfg);\n\telse if (buf[0] == '0')\n\t\trc = ipr_free_dump(ioa_cfg);\n\telse\n\t\treturn -EINVAL;\n\n\tif (rc)\n\t\treturn rc;\n\telse\n\t\treturn count;\n}\n\nstatic struct bin_attribute ipr_dump_attr = {\n\t.attr =\t{\n\t\t.name = \"dump\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = ipr_read_dump,\n\t.write = ipr_write_dump\n};\n#else\nstatic int ipr_free_dump(struct ipr_ioa_cfg *ioa_cfg) { return 0; };\n#endif\n\n/**\n * ipr_change_queue_depth - Change the device's queue depth\n * @sdev:\tscsi device struct\n * @qdepth:\tdepth to set\n *\n * Return value:\n * \tactual depth set\n **/\nstatic int ipr_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\n\tif (res && ipr_is_gata(res) && qdepth > IPR_MAX_CMD_PER_ATA_LUN)\n\t\tqdepth = IPR_MAX_CMD_PER_ATA_LUN;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tscsi_change_queue_depth(sdev, qdepth);\n\treturn sdev->queue_depth;\n}\n\n/**\n * ipr_show_adapter_handle - Show the adapter's resource handle for this device\n * @dev:\tdevice struct\n * @attr:\tdevice attribute structure\n * @buf:\tbuffer\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_adapter_handle(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tssize_t len = -ENXIO;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\tif (res)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%08X\\n\", res->res_handle);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_adapter_handle_attr = {\n\t.attr = {\n\t\t.name = \t\"adapter_handle\",\n\t\t.mode =\t\tS_IRUSR,\n\t},\n\t.show = ipr_show_adapter_handle\n};\n\n/**\n * ipr_show_resource_path - Show the resource path or the resource address for\n *\t\t\t    this device.\n * @dev:\tdevice struct\n * @attr:\tdevice attribute structure\n * @buf:\tbuffer\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_resource_path(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tssize_t len = -ENXIO;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\tif (res && ioa_cfg->sis64)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t       __ipr_format_res_path(res->res_path, buffer,\n\t\t\t\t\t\t     sizeof(buffer)));\n\telse if (res)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%d:%d:%d:%d\\n\", ioa_cfg->host->host_no,\n\t\t\t       res->bus, res->target, res->lun);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_resource_path_attr = {\n\t.attr = {\n\t\t.name = \t\"resource_path\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = ipr_show_resource_path\n};\n\n/**\n * ipr_show_device_id - Show the device_id for this device.\n * @dev:\tdevice struct\n * @attr:\tdevice attribute structure\n * @buf:\tbuffer\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_device_id(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tssize_t len = -ENXIO;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\tif (res && ioa_cfg->sis64)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"0x%llx\\n\", be64_to_cpu(res->dev_id));\n\telse if (res)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"0x%llx\\n\", res->lun_wwn);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_device_id_attr = {\n\t.attr = {\n\t\t.name =\t\t\"device_id\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = ipr_show_device_id\n};\n\n/**\n * ipr_show_resource_type - Show the resource type for this device.\n * @dev:\tdevice struct\n * @attr:\tdevice attribute structure\n * @buf:\tbuffer\n *\n * Return value:\n *\tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_resource_type(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tssize_t len = -ENXIO;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\n\tif (res)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%x\\n\", res->type);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_resource_type_attr = {\n\t.attr = {\n\t\t.name =\t\t\"resource_type\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = ipr_show_resource_type\n};\n\n/**\n * ipr_show_raw_mode - Show the adapter's raw mode\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_show_raw_mode(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tssize_t len;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\tif (res)\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%d\\n\", res->raw_mode);\n\telse\n\t\tlen = -ENXIO;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\n/**\n * ipr_store_raw_mode - Change the adapter's raw mode\n * @dev:\tclass device struct\n * @attr:\tdevice attribute (unused)\n * @buf:\tbuffer\n * @count:\t\tbuffer size\n *\n * Return value:\n * \tnumber of bytes printed to buffer\n **/\nstatic ssize_t ipr_store_raw_mode(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tssize_t len;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\tif (res) {\n\t\tif (ipr_is_af_dasd_device(res)) {\n\t\t\tres->raw_mode = simple_strtoul(buf, NULL, 10);\n\t\t\tlen = strlen(buf);\n\t\t\tif (res->sdev)\n\t\t\t\tsdev_printk(KERN_INFO, res->sdev, \"raw mode is %s\\n\",\n\t\t\t\t\tres->raw_mode ? \"enabled\" : \"disabled\");\n\t\t} else\n\t\t\tlen = -EINVAL;\n\t} else\n\t\tlen = -ENXIO;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn len;\n}\n\nstatic struct device_attribute ipr_raw_mode_attr = {\n\t.attr = {\n\t\t.name =\t\t\"raw_mode\",\n\t\t.mode =\t\tS_IRUGO | S_IWUSR,\n\t},\n\t.show = ipr_show_raw_mode,\n\t.store = ipr_store_raw_mode\n};\n\nstatic struct device_attribute *ipr_dev_attrs[] = {\n\t&ipr_adapter_handle_attr,\n\t&ipr_resource_path_attr,\n\t&ipr_device_id_attr,\n\t&ipr_resource_type_attr,\n\t&ipr_raw_mode_attr,\n\tNULL,\n};\n\n/**\n * ipr_biosparam - Return the HSC mapping\n * @sdev:\t\t\tscsi device struct\n * @block_device:\tblock device pointer\n * @capacity:\t\tcapacity of the device\n * @parm:\t\t\tArray containing returned HSC values.\n *\n * This function generates the HSC parms that fdisk uses.\n * We want to make sure we return something that places partitions\n * on 4k boundaries for best performance with the IOA.\n *\n * Return value:\n * \t0 on success\n **/\nstatic int ipr_biosparam(struct scsi_device *sdev,\n\t\t\t struct block_device *block_device,\n\t\t\t sector_t capacity, int *parm)\n{\n\tint heads, sectors;\n\tsector_t cylinders;\n\n\theads = 128;\n\tsectors = 32;\n\n\tcylinders = capacity;\n\tsector_div(cylinders, (128 * 32));\n\n\t/* return result */\n\tparm[0] = heads;\n\tparm[1] = sectors;\n\tparm[2] = cylinders;\n\n\treturn 0;\n}\n\n/**\n * ipr_find_starget - Find target based on bus/target.\n * @starget:\tscsi target struct\n *\n * Return value:\n * \tresource entry pointer if found / NULL if not found\n **/\nstatic struct ipr_resource_entry *ipr_find_starget(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;\n\tstruct ipr_resource_entry *res;\n\n\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\tif ((res->bus == starget->channel) &&\n\t\t    (res->target == starget->id)) {\n\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ata_port_info sata_port_info;\n\n/**\n * ipr_target_alloc - Prepare for commands to a SCSI target\n * @starget:\tscsi target struct\n *\n * If the device is a SATA device, this function allocates an\n * ATA port with libata, else it does nothing.\n *\n * Return value:\n * \t0 on success / non-0 on failure\n **/\nstatic int ipr_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;\n\tstruct ipr_sata_port *sata_port;\n\tstruct ata_port *ap;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = ipr_find_starget(starget);\n\tstarget->hostdata = NULL;\n\n\tif (res && ipr_is_gata(res)) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\tsata_port = kzalloc(sizeof(*sata_port), GFP_KERNEL);\n\t\tif (!sata_port)\n\t\t\treturn -ENOMEM;\n\n\t\tap = ata_sas_port_alloc(&ioa_cfg->ata_host, &sata_port_info, shost);\n\t\tif (ap) {\n\t\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\t\tsata_port->ioa_cfg = ioa_cfg;\n\t\t\tsata_port->ap = ap;\n\t\t\tsata_port->res = res;\n\n\t\t\tres->sata_port = sata_port;\n\t\t\tap->private_data = sata_port;\n\t\t\tstarget->hostdata = sata_port;\n\t\t} else {\n\t\t\tkfree(sata_port);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\treturn 0;\n}\n\n/**\n * ipr_target_destroy - Destroy a SCSI target\n * @starget:\tscsi target struct\n *\n * If the device was a SATA device, this function frees the libata\n * ATA port, else it does nothing.\n *\n **/\nstatic void ipr_target_destroy(struct scsi_target *starget)\n{\n\tstruct ipr_sata_port *sata_port = starget->hostdata;\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;\n\n\tif (ioa_cfg->sis64) {\n\t\tif (!ipr_find_starget(starget)) {\n\t\t\tif (starget->channel == IPR_ARRAY_VIRTUAL_BUS)\n\t\t\t\tclear_bit(starget->id, ioa_cfg->array_ids);\n\t\t\telse if (starget->channel == IPR_VSET_VIRTUAL_BUS)\n\t\t\t\tclear_bit(starget->id, ioa_cfg->vset_ids);\n\t\t\telse if (starget->channel == 0)\n\t\t\t\tclear_bit(starget->id, ioa_cfg->target_ids);\n\t\t}\n\t}\n\n\tif (sata_port) {\n\t\tstarget->hostdata = NULL;\n\t\tata_sas_port_destroy(sata_port->ap);\n\t\tkfree(sata_port);\n\t}\n}\n\n/**\n * ipr_find_sdev - Find device based on bus/target/lun.\n * @sdev:\tscsi device struct\n *\n * Return value:\n * \tresource entry pointer if found / NULL if not found\n **/\nstatic struct ipr_resource_entry *ipr_find_sdev(struct scsi_device *sdev)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\n\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\tif ((res->bus == sdev->channel) &&\n\t\t    (res->target == sdev->id) &&\n\t\t    (res->lun == sdev->lun))\n\t\t\treturn res;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * ipr_slave_destroy - Unconfigure a SCSI device\n * @sdev:\tscsi device struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct ipr_resource_entry *res;\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tunsigned long lock_flags = 0;\n\n\tioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = (struct ipr_resource_entry *) sdev->hostdata;\n\tif (res) {\n\t\tif (res->sata_port)\n\t\t\tres->sata_port->ap->link.device[0].class = ATA_DEV_NONE;\n\t\tsdev->hostdata = NULL;\n\t\tres->sdev = NULL;\n\t\tres->sata_port = NULL;\n\t}\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n}\n\n/**\n * ipr_slave_configure - Configure a SCSI device\n * @sdev:\tscsi device struct\n *\n * This function configures the specified scsi device.\n *\n * Return value:\n * \t0 on success\n **/\nstatic int ipr_slave_configure(struct scsi_device *sdev)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tstruct ata_port *ap = NULL;\n\tunsigned long lock_flags = 0;\n\tchar buffer[IPR_MAX_RES_PATH_LENGTH];\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tres = sdev->hostdata;\n\tif (res) {\n\t\tif (ipr_is_af_dasd_device(res))\n\t\t\tsdev->type = TYPE_RAID;\n\t\tif (ipr_is_af_dasd_device(res) || ipr_is_ioa_resource(res)) {\n\t\t\tsdev->scsi_level = 4;\n\t\t\tsdev->no_uld_attach = 1;\n\t\t}\n\t\tif (ipr_is_vset_device(res)) {\n\t\t\tsdev->scsi_level = SCSI_SPC_3;\n\t\t\tsdev->no_report_opcodes = 1;\n\t\t\tblk_queue_rq_timeout(sdev->request_queue,\n\t\t\t\t\t     IPR_VSET_RW_TIMEOUT);\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue, IPR_VSET_MAX_SECTORS);\n\t\t}\n\t\tif (ipr_is_gata(res) && res->sata_port)\n\t\t\tap = res->sata_port->ap;\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\t\tif (ap) {\n\t\t\tscsi_change_queue_depth(sdev, IPR_MAX_CMD_PER_ATA_LUN);\n\t\t\tata_sas_slave_configure(sdev, ap);\n\t\t}\n\n\t\tif (ioa_cfg->sis64)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"Resource path: %s\\n\",\n\t\t\t\t    ipr_format_res_path(ioa_cfg,\n\t\t\t\tres->res_path, buffer, sizeof(buffer)));\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn 0;\n}\n\n/**\n * ipr_ata_slave_alloc - Prepare for commands to a SATA device\n * @sdev:\tscsi device struct\n *\n * This function initializes an ATA port so that future commands\n * sent through queuecommand will work.\n *\n * Return value:\n * \t0 on success\n **/\nstatic int ipr_ata_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct ipr_sata_port *sata_port = NULL;\n\tint rc = -ENXIO;\n\n\tENTER;\n\tif (sdev->sdev_target)\n\t\tsata_port = sdev->sdev_target->hostdata;\n\tif (sata_port) {\n\t\trc = ata_sas_port_init(sata_port->ap);\n\t\tif (rc == 0)\n\t\t\trc = ata_sas_sync_probe(sata_port->ap);\n\t}\n\n\tif (rc)\n\t\tipr_slave_destroy(sdev);\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_slave_alloc - Prepare for commands to a device.\n * @sdev:\tscsi device struct\n *\n * This function saves a pointer to the resource entry\n * in the scsi device struct if the device exists. We\n * can then use this pointer in ipr_queuecommand when\n * handling new commands.\n *\n * Return value:\n * \t0 on success / -ENXIO if device does not exist\n **/\nstatic int ipr_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) sdev->host->hostdata;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags;\n\tint rc = -ENXIO;\n\n\tsdev->hostdata = NULL;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tres = ipr_find_sdev(sdev);\n\tif (res) {\n\t\tres->sdev = sdev;\n\t\tres->add_to_ml = 0;\n\t\tres->in_erp = 0;\n\t\tsdev->hostdata = res;\n\t\tif (!ipr_is_naca_model(res))\n\t\t\tres->needs_sync_complete = 1;\n\t\trc = 0;\n\t\tif (ipr_is_gata(res)) {\n\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\t\treturn ipr_ata_slave_alloc(sdev);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\treturn rc;\n}\n\n/**\n * ipr_match_lun - Match function for specified LUN\n * @ipr_cmd:\tipr command struct\n * @device:\t\tdevice to match (sdev)\n *\n * Returns:\n *\t1 if command matches sdev / 0 if command does not match sdev\n **/\nstatic int ipr_match_lun(struct ipr_cmnd *ipr_cmd, void *device)\n{\n\tif (ipr_cmd->scsi_cmd && ipr_cmd->scsi_cmd->device == device)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * ipr_cmnd_is_free - Check if a command is free or not\n * @ipr_cmd:\tipr command struct\n *\n * Returns:\n *\ttrue / false\n **/\nstatic bool ipr_cmnd_is_free(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_cmnd *loop_cmd;\n\n\tlist_for_each_entry(loop_cmd, &ipr_cmd->hrrq->hrrq_free_q, queue) {\n\t\tif (loop_cmd == ipr_cmd)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * ipr_match_res - Match function for specified resource entry\n * @ipr_cmd:\tipr command struct\n * @resource:\tresource entry to match\n *\n * Returns:\n *\t1 if command matches sdev / 0 if command does not match sdev\n **/\nstatic int ipr_match_res(struct ipr_cmnd *ipr_cmd, void *resource)\n{\n\tstruct ipr_resource_entry *res = resource;\n\n\tif (res && ipr_cmd->ioarcb.res_handle == res->res_handle)\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * ipr_wait_for_ops - Wait for matching commands to complete\n * @ioa_cfg:\tioa config struct\n * @device:\t\tdevice to match (sdev)\n * @match:\t\tmatch function to use\n *\n * Returns:\n *\tSUCCESS / FAILED\n **/\nstatic int ipr_wait_for_ops(struct ipr_ioa_cfg *ioa_cfg, void *device,\n\t\t\t    int (*match)(struct ipr_cmnd *, void *))\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tint wait, i;\n\tunsigned long flags;\n\tstruct ipr_hrr_queue *hrrq;\n\tsigned long timeout = IPR_ABORT_TASK_TIMEOUT;\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\n\tENTER;\n\tdo {\n\t\twait = 0;\n\n\t\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\t\tspin_lock_irqsave(hrrq->lock, flags);\n\t\t\tfor (i = hrrq->min_cmd_id; i <= hrrq->max_cmd_id; i++) {\n\t\t\t\tipr_cmd = ioa_cfg->ipr_cmnd_list[i];\n\t\t\t\tif (!ipr_cmnd_is_free(ipr_cmd)) {\n\t\t\t\t\tif (match(ipr_cmd, device)) {\n\t\t\t\t\t\tipr_cmd->eh_comp = &comp;\n\t\t\t\t\t\twait++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(hrrq->lock, flags);\n\t\t}\n\n\t\tif (wait) {\n\t\t\ttimeout = wait_for_completion_timeout(&comp, timeout);\n\n\t\t\tif (!timeout) {\n\t\t\t\twait = 0;\n\n\t\t\t\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\t\t\t\tspin_lock_irqsave(hrrq->lock, flags);\n\t\t\t\t\tfor (i = hrrq->min_cmd_id; i <= hrrq->max_cmd_id; i++) {\n\t\t\t\t\t\tipr_cmd = ioa_cfg->ipr_cmnd_list[i];\n\t\t\t\t\t\tif (!ipr_cmnd_is_free(ipr_cmd)) {\n\t\t\t\t\t\t\tif (match(ipr_cmd, device)) {\n\t\t\t\t\t\t\t\tipr_cmd->eh_comp = NULL;\n\t\t\t\t\t\t\t\twait++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tspin_unlock_irqrestore(hrrq->lock, flags);\n\t\t\t\t}\n\n\t\t\t\tif (wait)\n\t\t\t\t\tdev_err(&ioa_cfg->pdev->dev, \"Timed out waiting for aborted commands\\n\");\n\t\t\t\tLEAVE;\n\t\t\t\treturn wait ? FAILED : SUCCESS;\n\t\t\t}\n\t\t}\n\t} while (wait);\n\n\tLEAVE;\n\treturn SUCCESS;\n}\n\nstatic int ipr_eh_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tunsigned long lock_flags = 0;\n\tint rc = SUCCESS;\n\n\tENTER;\n\tioa_cfg = (struct ipr_ioa_cfg *) cmd->device->host->hostdata;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (!ioa_cfg->in_reset_reload && !ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead) {\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_ABBREV);\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Adapter being reset as a result of error recovery.\\n\");\n\n\t\tif (WAIT_FOR_DUMP == ioa_cfg->sdt_state)\n\t\t\tioa_cfg->sdt_state = GET_DUMP;\n\t}\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\t/* If we got hit with a host reset while we were already resetting\n\t the adapter for some reason, and the reset failed. */\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead) {\n\t\tipr_trace;\n\t\trc = FAILED;\n\t}\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_device_reset - Reset the device\n * @ioa_cfg:\tioa config struct\n * @res:\t\tresource entry struct\n *\n * This function issues a device reset to the affected device.\n * If the device is a SCSI device, a LUN reset will be sent\n * to the device first. If that does not work, a target reset\n * will be sent. If the device is a SATA device, a PHY reset will\n * be sent.\n *\n * Return value:\n *\t0 on success / non-zero on failure\n **/\nstatic int ipr_device_reset(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t    struct ipr_resource_entry *res)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioarcb *ioarcb;\n\tstruct ipr_cmd_pkt *cmd_pkt;\n\tstruct ipr_ioarcb_ata_regs *regs;\n\tu32 ioasc;\n\n\tENTER;\n\tipr_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);\n\tioarcb = &ipr_cmd->ioarcb;\n\tcmd_pkt = &ioarcb->cmd_pkt;\n\n\tif (ipr_cmd->ioa_cfg->sis64) {\n\t\tregs = &ipr_cmd->i.ata_ioadl.regs;\n\t\tioarcb->add_cmd_parms_offset = cpu_to_be16(sizeof(*ioarcb));\n\t} else\n\t\tregs = &ioarcb->u.add_data.u.regs;\n\n\tioarcb->res_handle = res->res_handle;\n\tcmd_pkt->request_type = IPR_RQTYPE_IOACMD;\n\tcmd_pkt->cdb[0] = IPR_RESET_DEVICE;\n\tif (ipr_is_gata(res)) {\n\t\tcmd_pkt->cdb[2] = IPR_ATA_PHY_RESET;\n\t\tioarcb->add_cmd_parms_len = cpu_to_be16(sizeof(regs->flags));\n\t\tregs->flags |= IPR_ATA_FLAG_STATUS_ON_GOOD_COMPLETION;\n\t}\n\n\tipr_send_blocking_cmd(ipr_cmd, ipr_timeout, IPR_DEVICE_RESET_TIMEOUT);\n\tioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\tif (ipr_is_gata(res) && res->sata_port && ioasc != IPR_IOASC_IOA_WAS_RESET) {\n\t\tif (ipr_cmd->ioa_cfg->sis64)\n\t\t\tmemcpy(&res->sata_port->ioasa, &ipr_cmd->s.ioasa64.u.gata,\n\t\t\t       sizeof(struct ipr_ioasa_gata));\n\t\telse\n\t\t\tmemcpy(&res->sata_port->ioasa, &ipr_cmd->s.ioasa.u.gata,\n\t\t\t       sizeof(struct ipr_ioasa_gata));\n\t}\n\n\tLEAVE;\n\treturn IPR_IOASC_SENSE_KEY(ioasc) ? -EIO : 0;\n}\n\n/**\n * ipr_sata_reset - Reset the SATA port\n * @link:\tSATA link to reset\n * @classes:\tclass of the attached device\n * @deadline:\tunused\n *\n * This function issues a SATA phy reset to the affected ATA link.\n *\n * Return value:\n *\t0 on success / non-zero on failure\n **/\nstatic int ipr_sata_reset(struct ata_link *link, unsigned int *classes,\n\t\t\t\tunsigned long deadline)\n{\n\tstruct ipr_sata_port *sata_port = link->ap->private_data;\n\tstruct ipr_ioa_cfg *ioa_cfg = sata_port->ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\tunsigned long lock_flags = 0;\n\tint rc = -ENXIO, ret;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t}\n\n\tres = sata_port->res;\n\tif (res) {\n\t\trc = ipr_device_reset(ioa_cfg, res);\n\t\t*classes = res->ata_class;\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\t\tret = ipr_wait_for_ops(ioa_cfg, res, ipr_match_res);\n\t\tif (ret != SUCCESS) {\n\t\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_ABBREV);\n\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\t\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\t}\n\t} else\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * __ipr_eh_dev_reset - Reset the device\n * @scsi_cmd:\tscsi command struct\n *\n * This function issues a device reset to the affected device.\n * A LUN reset will be sent to the device first. If that does\n * not work, a target reset will be sent.\n *\n * Return value:\n *\tSUCCESS / FAILED\n **/\nstatic int __ipr_eh_dev_reset(struct scsi_cmnd *scsi_cmd)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\tstruct ata_port *ap;\n\tint rc = 0, i;\n\tstruct ipr_hrr_queue *hrrq;\n\n\tENTER;\n\tioa_cfg = (struct ipr_ioa_cfg *) scsi_cmd->device->host->hostdata;\n\tres = scsi_cmd->device->hostdata;\n\n\t/*\n\t * If we are currently going through reset/reload, return failed. This will force the\n\t * mid-layer to call ipr_eh_host_reset, which will then go to sleep and wait for the\n\t * reset to complete\n\t */\n\tif (ioa_cfg->in_reset_reload)\n\t\treturn FAILED;\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead)\n\t\treturn FAILED;\n\n\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\tspin_lock(&hrrq->_lock);\n\t\tfor (i = hrrq->min_cmd_id; i <= hrrq->max_cmd_id; i++) {\n\t\t\tipr_cmd = ioa_cfg->ipr_cmnd_list[i];\n\n\t\t\tif (ipr_cmd->ioarcb.res_handle == res->res_handle) {\n\t\t\t\tif (!ipr_cmd->qc)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ipr_cmnd_is_free(ipr_cmd))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tipr_cmd->done = ipr_sata_eh_done;\n\t\t\t\tif (!(ipr_cmd->qc->flags & ATA_QCFLAG_FAILED)) {\n\t\t\t\t\tipr_cmd->qc->err_mask |= AC_ERR_TIMEOUT;\n\t\t\t\t\tipr_cmd->qc->flags |= ATA_QCFLAG_FAILED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&hrrq->_lock);\n\t}\n\tres->resetting_device = 1;\n\tscmd_printk(KERN_ERR, scsi_cmd, \"Resetting device\\n\");\n\n\tif (ipr_is_gata(res) && res->sata_port) {\n\t\tap = res->sata_port->ap;\n\t\tspin_unlock_irq(scsi_cmd->device->host->host_lock);\n\t\tata_std_error_handler(ap);\n\t\tspin_lock_irq(scsi_cmd->device->host->host_lock);\n\t} else\n\t\trc = ipr_device_reset(ioa_cfg, res);\n\tres->resetting_device = 0;\n\tres->reset_occurred = 1;\n\n\tLEAVE;\n\treturn rc ? FAILED : SUCCESS;\n}\n\nstatic int ipr_eh_dev_reset(struct scsi_cmnd *cmd)\n{\n\tint rc;\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\n\tioa_cfg = (struct ipr_ioa_cfg *) cmd->device->host->hostdata;\n\tres = cmd->device->hostdata;\n\n\tif (!res)\n\t\treturn FAILED;\n\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __ipr_eh_dev_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\n\tif (rc == SUCCESS) {\n\t\tif (ipr_is_gata(res) && res->sata_port)\n\t\t\trc = ipr_wait_for_ops(ioa_cfg, res, ipr_match_res);\n\t\telse\n\t\t\trc = ipr_wait_for_ops(ioa_cfg, cmd->device, ipr_match_lun);\n\t}\n\n\treturn rc;\n}\n\n/**\n * ipr_bus_reset_done - Op done function for bus reset.\n * @ipr_cmd:\tipr command struct\n *\n * This function is the op done function for a bus reset\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_bus_reset_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\n\tENTER;\n\tif (!ioa_cfg->sis64)\n\t\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\t\tif (res->res_handle == ipr_cmd->ioarcb.res_handle) {\n\t\t\t\tscsi_report_bus_reset(ioa_cfg->host, res->bus);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t/*\n\t * If abort has not completed, indicate the reset has, else call the\n\t * abort's done function to wake the sleeping eh thread\n\t */\n\tif (ipr_cmd->sibling->sibling)\n\t\tipr_cmd->sibling->sibling = NULL;\n\telse\n\t\tipr_cmd->sibling->done(ipr_cmd->sibling);\n\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\tLEAVE;\n}\n\n/**\n * ipr_abort_timeout - An abort task has timed out\n * @t: Timer context used to fetch ipr command struct\n *\n * This function handles when an abort task times out. If this\n * happens we issue a bus reset since we have resources tied\n * up that must be freed before returning to the midlayer.\n *\n * Return value:\n *\tnone\n **/\nstatic void ipr_abort_timeout(struct timer_list *t)\n{\n\tstruct ipr_cmnd *ipr_cmd = from_timer(ipr_cmd, t, timer);\n\tstruct ipr_cmnd *reset_cmd;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_cmd_pkt *cmd_pkt;\n\tunsigned long lock_flags = 0;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (ipr_cmd->completion.done || ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn;\n\t}\n\n\tsdev_printk(KERN_ERR, ipr_cmd->u.sdev, \"Abort timed out. Resetting bus.\\n\");\n\treset_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);\n\tipr_cmd->sibling = reset_cmd;\n\treset_cmd->sibling = ipr_cmd;\n\treset_cmd->ioarcb.res_handle = ipr_cmd->ioarcb.res_handle;\n\tcmd_pkt = &reset_cmd->ioarcb.cmd_pkt;\n\tcmd_pkt->request_type = IPR_RQTYPE_IOACMD;\n\tcmd_pkt->cdb[0] = IPR_RESET_DEVICE;\n\tcmd_pkt->cdb[2] = IPR_RESET_TYPE_SELECT | IPR_BUS_RESET;\n\n\tipr_do_req(reset_cmd, ipr_bus_reset_done, ipr_timeout, IPR_DEVICE_RESET_TIMEOUT);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tLEAVE;\n}\n\n/**\n * ipr_cancel_op - Cancel specified op\n * @scsi_cmd:\tscsi command struct\n *\n * This function cancels specified op.\n *\n * Return value:\n *\tSUCCESS / FAILED\n **/\nstatic int ipr_cancel_op(struct scsi_cmnd *scsi_cmd)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\tstruct ipr_cmd_pkt *cmd_pkt;\n\tu32 ioasc;\n\tint i, op_found = 0;\n\tstruct ipr_hrr_queue *hrrq;\n\n\tENTER;\n\tioa_cfg = (struct ipr_ioa_cfg *)scsi_cmd->device->host->hostdata;\n\tres = scsi_cmd->device->hostdata;\n\n\t/* If we are currently going through reset/reload, return failed.\n\t * This will force the mid-layer to call ipr_eh_host_reset,\n\t * which will then go to sleep and wait for the reset to complete\n\t */\n\tif (ioa_cfg->in_reset_reload ||\n\t    ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead)\n\t\treturn FAILED;\n\tif (!res)\n\t\treturn FAILED;\n\n\t/*\n\t * If we are aborting a timed out op, chances are that the timeout was caused\n\t * by a still not detected EEH error. In such cases, reading a register will\n\t * trigger the EEH recovery infrastructure.\n\t */\n\treadl(ioa_cfg->regs.sense_interrupt_reg);\n\n\tif (!ipr_is_gscsi(res))\n\t\treturn FAILED;\n\n\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\tspin_lock(&hrrq->_lock);\n\t\tfor (i = hrrq->min_cmd_id; i <= hrrq->max_cmd_id; i++) {\n\t\t\tif (ioa_cfg->ipr_cmnd_list[i]->scsi_cmd == scsi_cmd) {\n\t\t\t\tif (!ipr_cmnd_is_free(ioa_cfg->ipr_cmnd_list[i])) {\n\t\t\t\t\top_found = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&hrrq->_lock);\n\t}\n\n\tif (!op_found)\n\t\treturn SUCCESS;\n\n\tipr_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);\n\tipr_cmd->ioarcb.res_handle = res->res_handle;\n\tcmd_pkt = &ipr_cmd->ioarcb.cmd_pkt;\n\tcmd_pkt->request_type = IPR_RQTYPE_IOACMD;\n\tcmd_pkt->cdb[0] = IPR_CANCEL_ALL_REQUESTS;\n\tipr_cmd->u.sdev = scsi_cmd->device;\n\n\tscmd_printk(KERN_ERR, scsi_cmd, \"Aborting command: %02X\\n\",\n\t\t    scsi_cmd->cmnd[0]);\n\tipr_send_blocking_cmd(ipr_cmd, ipr_abort_timeout, IPR_CANCEL_ALL_TIMEOUT);\n\tioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\t/*\n\t * If the abort task timed out and we sent a bus reset, we will get\n\t * one the following responses to the abort\n\t */\n\tif (ioasc == IPR_IOASC_BUS_WAS_RESET || ioasc == IPR_IOASC_SYNC_REQUIRED) {\n\t\tioasc = 0;\n\t\tipr_trace;\n\t}\n\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\tif (!ipr_is_naca_model(res))\n\t\tres->needs_sync_complete = 1;\n\n\tLEAVE;\n\treturn IPR_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\n}\n\n/**\n * ipr_scan_finished - Report whether scan is done\n * @shost:           scsi host struct\n * @elapsed_time:    elapsed time\n *\n * Return value:\n *\t0 if scan in progress / 1 if scan is complete\n **/\nstatic int ipr_scan_finished(struct Scsi_Host *shost, unsigned long elapsed_time)\n{\n\tunsigned long lock_flags;\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *) shost->hostdata;\n\tint rc = 0;\n\n\tspin_lock_irqsave(shost->host_lock, lock_flags);\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead || ioa_cfg->scan_done)\n\t\trc = 1;\n\tif ((elapsed_time/HZ) > (ioa_cfg->transop_timeout * 2))\n\t\trc = 1;\n\tspin_unlock_irqrestore(shost->host_lock, lock_flags);\n\treturn rc;\n}\n\n/**\n * ipr_eh_abort - Reset the host adapter\n * @scsi_cmd:\tscsi command struct\n *\n * Return value:\n * \tSUCCESS / FAILED\n **/\nstatic int ipr_eh_abort(struct scsi_cmnd *scsi_cmd)\n{\n\tunsigned long flags;\n\tint rc;\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\n\tENTER;\n\n\tioa_cfg = (struct ipr_ioa_cfg *) scsi_cmd->device->host->hostdata;\n\n\tspin_lock_irqsave(scsi_cmd->device->host->host_lock, flags);\n\trc = ipr_cancel_op(scsi_cmd);\n\tspin_unlock_irqrestore(scsi_cmd->device->host->host_lock, flags);\n\n\tif (rc == SUCCESS)\n\t\trc = ipr_wait_for_ops(ioa_cfg, scsi_cmd->device, ipr_match_lun);\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_handle_other_interrupt - Handle \"other\" interrupts\n * @ioa_cfg:\tioa config struct\n * @int_reg:\tinterrupt register\n *\n * Return value:\n * \tIRQ_NONE / IRQ_HANDLED\n **/\nstatic irqreturn_t ipr_handle_other_interrupt(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t      u32 int_reg)\n{\n\tirqreturn_t rc = IRQ_HANDLED;\n\tu32 int_mask_reg;\n\n\tint_mask_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg32);\n\tint_reg &= ~int_mask_reg;\n\n\t/* If an interrupt on the adapter did not occur, ignore it.\n\t * Or in the case of SIS 64, check for a stage change interrupt.\n\t */\n\tif ((int_reg & IPR_PCII_OPER_INTERRUPTS) == 0) {\n\t\tif (ioa_cfg->sis64) {\n\t\t\tint_mask_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);\n\t\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg) & ~int_mask_reg;\n\t\t\tif (int_reg & IPR_PCII_IPL_STAGE_CHANGE) {\n\n\t\t\t\t/* clear stage change */\n\t\t\t\twritel(IPR_PCII_IPL_STAGE_CHANGE, ioa_cfg->regs.clr_interrupt_reg);\n\t\t\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg) & ~int_mask_reg;\n\t\t\t\tlist_del(&ioa_cfg->reset_cmd->queue);\n\t\t\t\tdel_timer(&ioa_cfg->reset_cmd->timer);\n\t\t\t\tipr_reset_ioa_job(ioa_cfg->reset_cmd);\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (int_reg & IPR_PCII_IOA_TRANS_TO_OPER) {\n\t\t/* Mask the interrupt */\n\t\twritel(IPR_PCII_IOA_TRANS_TO_OPER, ioa_cfg->regs.set_interrupt_mask_reg);\n\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg);\n\n\t\tlist_del(&ioa_cfg->reset_cmd->queue);\n\t\tdel_timer(&ioa_cfg->reset_cmd->timer);\n\t\tipr_reset_ioa_job(ioa_cfg->reset_cmd);\n\t} else if ((int_reg & IPR_PCII_HRRQ_UPDATED) == int_reg) {\n\t\tif (ioa_cfg->clear_isr) {\n\t\t\tif (ipr_debug && printk_ratelimit())\n\t\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\t\"Spurious interrupt detected. 0x%08X\\n\", int_reg);\n\t\t\twritel(IPR_PCII_HRRQ_UPDATED, ioa_cfg->regs.clr_interrupt_reg32);\n\t\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg32);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t} else {\n\t\tif (int_reg & IPR_PCII_IOA_UNIT_CHECKED)\n\t\t\tioa_cfg->ioa_unit_checked = 1;\n\t\telse if (int_reg & IPR_PCII_NO_HOST_RRQ)\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"No Host RRQ. 0x%08X\\n\", int_reg);\n\t\telse\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"Permanent IOA failure. 0x%08X\\n\", int_reg);\n\n\t\tif (WAIT_FOR_DUMP == ioa_cfg->sdt_state)\n\t\t\tioa_cfg->sdt_state = GET_DUMP;\n\n\t\tipr_mask_and_clear_interrupts(ioa_cfg, ~0);\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t}\n\n\treturn rc;\n}\n\n/**\n * ipr_isr_eh - Interrupt service routine error handler\n * @ioa_cfg:\tioa config struct\n * @msg:\tmessage to log\n * @number:\tvarious meanings depending on the caller/message\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_isr_eh(struct ipr_ioa_cfg *ioa_cfg, char *msg, u16 number)\n{\n\tioa_cfg->errors_logged++;\n\tdev_err(&ioa_cfg->pdev->dev, \"%s %d\\n\", msg, number);\n\n\tif (WAIT_FOR_DUMP == ioa_cfg->sdt_state)\n\t\tioa_cfg->sdt_state = GET_DUMP;\n\n\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n}\n\nstatic int ipr_process_hrrq(struct ipr_hrr_queue *hrr_queue, int budget,\n\t\t\t\t\t\tstruct list_head *doneq)\n{\n\tu32 ioasc;\n\tu16 cmd_index;\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioa_cfg *ioa_cfg = hrr_queue->ioa_cfg;\n\tint num_hrrq = 0;\n\n\t/* If interrupts are disabled, ignore the interrupt */\n\tif (!hrr_queue->allow_interrupts)\n\t\treturn 0;\n\n\twhile ((be32_to_cpu(*hrr_queue->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==\n\t       hrr_queue->toggle_bit) {\n\n\t\tcmd_index = (be32_to_cpu(*hrr_queue->hrrq_curr) &\n\t\t\t     IPR_HRRQ_REQ_RESP_HANDLE_MASK) >>\n\t\t\t     IPR_HRRQ_REQ_RESP_HANDLE_SHIFT;\n\n\t\tif (unlikely(cmd_index > hrr_queue->max_cmd_id ||\n\t\t\t     cmd_index < hrr_queue->min_cmd_id)) {\n\t\t\tipr_isr_eh(ioa_cfg,\n\t\t\t\t\"Invalid response handle from IOA: \",\n\t\t\t\tcmd_index);\n\t\t\tbreak;\n\t\t}\n\n\t\tipr_cmd = ioa_cfg->ipr_cmnd_list[cmd_index];\n\t\tioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\t\tipr_trc_hook(ipr_cmd, IPR_TRACE_FINISH, ioasc);\n\n\t\tlist_move_tail(&ipr_cmd->queue, doneq);\n\n\t\tif (hrr_queue->hrrq_curr < hrr_queue->hrrq_end) {\n\t\t\thrr_queue->hrrq_curr++;\n\t\t} else {\n\t\t\thrr_queue->hrrq_curr = hrr_queue->hrrq_start;\n\t\t\thrr_queue->toggle_bit ^= 1u;\n\t\t}\n\t\tnum_hrrq++;\n\t\tif (budget > 0 && num_hrrq >= budget)\n\t\t\tbreak;\n\t}\n\n\treturn num_hrrq;\n}\n\nstatic int ipr_iopoll(struct irq_poll *iop, int budget)\n{\n\tstruct ipr_hrr_queue *hrrq;\n\tstruct ipr_cmnd *ipr_cmd, *temp;\n\tunsigned long hrrq_flags;\n\tint completed_ops;\n\tLIST_HEAD(doneq);\n\n\thrrq = container_of(iop, struct ipr_hrr_queue, iopoll);\n\n\tspin_lock_irqsave(hrrq->lock, hrrq_flags);\n\tcompleted_ops = ipr_process_hrrq(hrrq, budget, &doneq);\n\n\tif (completed_ops < budget)\n\t\tirq_poll_complete(iop);\n\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\n\tlist_for_each_entry_safe(ipr_cmd, temp, &doneq, queue) {\n\t\tlist_del(&ipr_cmd->queue);\n\t\tdel_timer(&ipr_cmd->timer);\n\t\tipr_cmd->fast_done(ipr_cmd);\n\t}\n\n\treturn completed_ops;\n}\n\n/**\n * ipr_isr - Interrupt service routine\n * @irq:\tirq number\n * @devp:\tpointer to ioa config struct\n *\n * Return value:\n * \tIRQ_NONE / IRQ_HANDLED\n **/\nstatic irqreturn_t ipr_isr(int irq, void *devp)\n{\n\tstruct ipr_hrr_queue *hrrq = (struct ipr_hrr_queue *)devp;\n\tstruct ipr_ioa_cfg *ioa_cfg = hrrq->ioa_cfg;\n\tunsigned long hrrq_flags = 0;\n\tu32 int_reg = 0;\n\tint num_hrrq = 0;\n\tint irq_none = 0;\n\tstruct ipr_cmnd *ipr_cmd, *temp;\n\tirqreturn_t rc = IRQ_NONE;\n\tLIST_HEAD(doneq);\n\n\tspin_lock_irqsave(hrrq->lock, hrrq_flags);\n\t/* If interrupts are disabled, ignore the interrupt */\n\tif (!hrrq->allow_interrupts) {\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\twhile (1) {\n\t\tif (ipr_process_hrrq(hrrq, -1, &doneq)) {\n\t\t\trc =  IRQ_HANDLED;\n\n\t\t\tif (!ioa_cfg->clear_isr)\n\t\t\t\tbreak;\n\n\t\t\t/* Clear the PCI interrupt */\n\t\t\tnum_hrrq = 0;\n\t\t\tdo {\n\t\t\t\twritel(IPR_PCII_HRRQ_UPDATED,\n\t\t\t\t     ioa_cfg->regs.clr_interrupt_reg32);\n\t\t\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg32);\n\t\t\t} while (int_reg & IPR_PCII_HRRQ_UPDATED &&\n\t\t\t\tnum_hrrq++ < IPR_MAX_HRRQ_RETRIES);\n\n\t\t} else if (rc == IRQ_NONE && irq_none == 0) {\n\t\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg32);\n\t\t\tirq_none++;\n\t\t} else if (num_hrrq == IPR_MAX_HRRQ_RETRIES &&\n\t\t\t   int_reg & IPR_PCII_HRRQ_UPDATED) {\n\t\t\tipr_isr_eh(ioa_cfg,\n\t\t\t\t\"Error clearing HRRQ: \", num_hrrq);\n\t\t\trc = IRQ_HANDLED;\n\t\t\tbreak;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(rc == IRQ_NONE))\n\t\trc = ipr_handle_other_interrupt(ioa_cfg, int_reg);\n\n\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\tlist_for_each_entry_safe(ipr_cmd, temp, &doneq, queue) {\n\t\tlist_del(&ipr_cmd->queue);\n\t\tdel_timer(&ipr_cmd->timer);\n\t\tipr_cmd->fast_done(ipr_cmd);\n\t}\n\treturn rc;\n}\n\n/**\n * ipr_isr_mhrrq - Interrupt service routine\n * @irq:\tirq number\n * @devp:\tpointer to ioa config struct\n *\n * Return value:\n *\tIRQ_NONE / IRQ_HANDLED\n **/\nstatic irqreturn_t ipr_isr_mhrrq(int irq, void *devp)\n{\n\tstruct ipr_hrr_queue *hrrq = (struct ipr_hrr_queue *)devp;\n\tstruct ipr_ioa_cfg *ioa_cfg = hrrq->ioa_cfg;\n\tunsigned long hrrq_flags = 0;\n\tstruct ipr_cmnd *ipr_cmd, *temp;\n\tirqreturn_t rc = IRQ_NONE;\n\tLIST_HEAD(doneq);\n\n\tspin_lock_irqsave(hrrq->lock, hrrq_flags);\n\n\t/* If interrupts are disabled, ignore the interrupt */\n\tif (!hrrq->allow_interrupts) {\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (ioa_cfg->iopoll_weight && ioa_cfg->sis64 && ioa_cfg->nvectors > 1) {\n\t\tif ((be32_to_cpu(*hrrq->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==\n\t\t       hrrq->toggle_bit) {\n\t\t\tirq_poll_sched(&hrrq->iopoll);\n\t\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t} else {\n\t\tif ((be32_to_cpu(*hrrq->hrrq_curr) & IPR_HRRQ_TOGGLE_BIT) ==\n\t\t\thrrq->toggle_bit)\n\n\t\t\tif (ipr_process_hrrq(hrrq, -1, &doneq))\n\t\t\t\trc =  IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\n\tlist_for_each_entry_safe(ipr_cmd, temp, &doneq, queue) {\n\t\tlist_del(&ipr_cmd->queue);\n\t\tdel_timer(&ipr_cmd->timer);\n\t\tipr_cmd->fast_done(ipr_cmd);\n\t}\n\treturn rc;\n}\n\n/**\n * ipr_build_ioadl64 - Build a scatter/gather list and map the buffer\n * @ioa_cfg:\tioa config struct\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n * \t0 on success / -1 on failure\n **/\nstatic int ipr_build_ioadl64(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t     struct ipr_cmnd *ipr_cmd)\n{\n\tint i, nseg;\n\tstruct scatterlist *sg;\n\tu32 length;\n\tu32 ioadl_flags = 0;\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioadl64_desc *ioadl64 = ipr_cmd->i.ioadl64;\n\n\tlength = scsi_bufflen(scsi_cmd);\n\tif (!length)\n\t\treturn 0;\n\n\tnseg = scsi_dma_map(scsi_cmd);\n\tif (nseg < 0) {\n\t\tif (printk_ratelimit())\n\t\t\tdev_err(&ioa_cfg->pdev->dev, \"scsi_dma_map failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tipr_cmd->dma_use_sg = nseg;\n\n\tioarcb->data_transfer_length = cpu_to_be32(length);\n\tioarcb->ioadl_len =\n\t\tcpu_to_be32(sizeof(struct ipr_ioadl64_desc) * ipr_cmd->dma_use_sg);\n\n\tif (scsi_cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tioadl_flags = IPR_IOADL_FLAGS_WRITE;\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\t} else if (scsi_cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tioadl_flags = IPR_IOADL_FLAGS_READ;\n\n\tscsi_for_each_sg(scsi_cmd, sg, ipr_cmd->dma_use_sg, i) {\n\t\tioadl64[i].flags = cpu_to_be32(ioadl_flags);\n\t\tioadl64[i].data_len = cpu_to_be32(sg_dma_len(sg));\n\t\tioadl64[i].address = cpu_to_be64(sg_dma_address(sg));\n\t}\n\n\tioadl64[i-1].flags |= cpu_to_be32(IPR_IOADL_FLAGS_LAST);\n\treturn 0;\n}\n\n/**\n * ipr_build_ioadl - Build a scatter/gather list and map the buffer\n * @ioa_cfg:\tioa config struct\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n * \t0 on success / -1 on failure\n **/\nstatic int ipr_build_ioadl(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t   struct ipr_cmnd *ipr_cmd)\n{\n\tint i, nseg;\n\tstruct scatterlist *sg;\n\tu32 length;\n\tu32 ioadl_flags = 0;\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioadl_desc *ioadl = ipr_cmd->i.ioadl;\n\n\tlength = scsi_bufflen(scsi_cmd);\n\tif (!length)\n\t\treturn 0;\n\n\tnseg = scsi_dma_map(scsi_cmd);\n\tif (nseg < 0) {\n\t\tdev_err(&ioa_cfg->pdev->dev, \"scsi_dma_map failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tipr_cmd->dma_use_sg = nseg;\n\n\tif (scsi_cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tioadl_flags = IPR_IOADL_FLAGS_WRITE;\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\t\tioarcb->data_transfer_length = cpu_to_be32(length);\n\t\tioarcb->ioadl_len =\n\t\t\tcpu_to_be32(sizeof(struct ipr_ioadl_desc) * ipr_cmd->dma_use_sg);\n\t} else if (scsi_cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tioadl_flags = IPR_IOADL_FLAGS_READ;\n\t\tioarcb->read_data_transfer_length = cpu_to_be32(length);\n\t\tioarcb->read_ioadl_len =\n\t\t\tcpu_to_be32(sizeof(struct ipr_ioadl_desc) * ipr_cmd->dma_use_sg);\n\t}\n\n\tif (ipr_cmd->dma_use_sg <= ARRAY_SIZE(ioarcb->u.add_data.u.ioadl)) {\n\t\tioadl = ioarcb->u.add_data.u.ioadl;\n\t\tioarcb->write_ioadl_addr = cpu_to_be32((ipr_cmd->dma_addr) +\n\t\t\t\t    offsetof(struct ipr_ioarcb, u.add_data));\n\t\tioarcb->read_ioadl_addr = ioarcb->write_ioadl_addr;\n\t}\n\n\tscsi_for_each_sg(scsi_cmd, sg, ipr_cmd->dma_use_sg, i) {\n\t\tioadl[i].flags_and_data_len =\n\t\t\tcpu_to_be32(ioadl_flags | sg_dma_len(sg));\n\t\tioadl[i].address = cpu_to_be32(sg_dma_address(sg));\n\t}\n\n\tioadl[i-1].flags_and_data_len |= cpu_to_be32(IPR_IOADL_FLAGS_LAST);\n\treturn 0;\n}\n\n/**\n * __ipr_erp_done - Process completion of ERP for a device\n * @ipr_cmd:\t\tipr command struct\n *\n * This function copies the sense buffer into the scsi_cmd\n * struct and pushes the scsi_done function.\n *\n * Return value:\n * \tnothing\n **/\nstatic void __ipr_erp_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\tstruct ipr_resource_entry *res = scsi_cmd->device->hostdata;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tif (IPR_IOASC_SENSE_KEY(ioasc) > 0) {\n\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tscmd_printk(KERN_ERR, scsi_cmd,\n\t\t\t    \"Request Sense failed with IOASC: 0x%08X\\n\", ioasc);\n\t} else {\n\t\tmemcpy(scsi_cmd->sense_buffer, ipr_cmd->sense_buffer,\n\t\t       SCSI_SENSE_BUFFERSIZE);\n\t}\n\n\tif (res) {\n\t\tif (!ipr_is_naca_model(res))\n\t\t\tres->needs_sync_complete = 1;\n\t\tres->in_erp = 0;\n\t}\n\tscsi_dma_unmap(ipr_cmd->scsi_cmd);\n\tscsi_cmd->scsi_done(scsi_cmd);\n\tif (ipr_cmd->eh_comp)\n\t\tcomplete(ipr_cmd->eh_comp);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n}\n\n/**\n * ipr_erp_done - Process completion of ERP for a device\n * @ipr_cmd:\t\tipr command struct\n *\n * This function copies the sense buffer into the scsi_cmd\n * struct and pushes the scsi_done function.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_erp_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_hrr_queue *hrrq = ipr_cmd->hrrq;\n\tunsigned long hrrq_flags;\n\n\tspin_lock_irqsave(&hrrq->_lock, hrrq_flags);\n\t__ipr_erp_done(ipr_cmd);\n\tspin_unlock_irqrestore(&hrrq->_lock, hrrq_flags);\n}\n\n/**\n * ipr_reinit_ipr_cmnd_for_erp - Re-initialize a cmnd block to be used for ERP\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_reinit_ipr_cmnd_for_erp(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioasa *ioasa = &ipr_cmd->s.ioasa;\n\tdma_addr_t dma_addr = ipr_cmd->dma_addr;\n\n\tmemset(&ioarcb->cmd_pkt, 0, sizeof(struct ipr_cmd_pkt));\n\tioarcb->data_transfer_length = 0;\n\tioarcb->read_data_transfer_length = 0;\n\tioarcb->ioadl_len = 0;\n\tioarcb->read_ioadl_len = 0;\n\tioasa->hdr.ioasc = 0;\n\tioasa->hdr.residual_data_len = 0;\n\n\tif (ipr_cmd->ioa_cfg->sis64)\n\t\tioarcb->u.sis64_addr_data.data_ioadl_addr =\n\t\t\tcpu_to_be64(dma_addr + offsetof(struct ipr_cmnd, i.ioadl64));\n\telse {\n\t\tioarcb->write_ioadl_addr =\n\t\t\tcpu_to_be32(dma_addr + offsetof(struct ipr_cmnd, i.ioadl));\n\t\tioarcb->read_ioadl_addr = ioarcb->write_ioadl_addr;\n\t}\n}\n\n/**\n * __ipr_erp_request_sense - Send request sense to a device\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a request sense to a device as a result\n * of a check condition.\n *\n * Return value:\n * \tnothing\n **/\nstatic void __ipr_erp_request_sense(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_cmd_pkt *cmd_pkt = &ipr_cmd->ioarcb.cmd_pkt;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tif (IPR_IOASC_SENSE_KEY(ioasc) > 0) {\n\t\t__ipr_erp_done(ipr_cmd);\n\t\treturn;\n\t}\n\n\tipr_reinit_ipr_cmnd_for_erp(ipr_cmd);\n\n\tcmd_pkt->request_type = IPR_RQTYPE_SCSICDB;\n\tcmd_pkt->cdb[0] = REQUEST_SENSE;\n\tcmd_pkt->cdb[4] = SCSI_SENSE_BUFFERSIZE;\n\tcmd_pkt->flags_hi |= IPR_FLAGS_HI_SYNC_OVERRIDE;\n\tcmd_pkt->flags_hi |= IPR_FLAGS_HI_NO_ULEN_CHK;\n\tcmd_pkt->timeout = cpu_to_be16(IPR_REQUEST_SENSE_TIMEOUT / HZ);\n\n\tipr_init_ioadl(ipr_cmd, ipr_cmd->sense_buffer_dma,\n\t\t       SCSI_SENSE_BUFFERSIZE, IPR_IOADL_FLAGS_READ_LAST);\n\n\tipr_do_req(ipr_cmd, ipr_erp_done, ipr_timeout,\n\t\t   IPR_REQUEST_SENSE_TIMEOUT * 2);\n}\n\n/**\n * ipr_erp_request_sense - Send request sense to a device\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a request sense to a device as a result\n * of a check condition.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_erp_request_sense(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_hrr_queue *hrrq = ipr_cmd->hrrq;\n\tunsigned long hrrq_flags;\n\n\tspin_lock_irqsave(&hrrq->_lock, hrrq_flags);\n\t__ipr_erp_request_sense(ipr_cmd);\n\tspin_unlock_irqrestore(&hrrq->_lock, hrrq_flags);\n}\n\n/**\n * ipr_erp_cancel_all - Send cancel all to a device\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a cancel all to a device to clear the\n * queue. If we are running TCQ on the device, QERR is set to 1,\n * which means all outstanding ops have been dropped on the floor.\n * Cancel all will return them to us.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_erp_cancel_all(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\tstruct ipr_resource_entry *res = scsi_cmd->device->hostdata;\n\tstruct ipr_cmd_pkt *cmd_pkt;\n\n\tres->in_erp = 1;\n\n\tipr_reinit_ipr_cmnd_for_erp(ipr_cmd);\n\n\tif (!scsi_cmd->device->simple_tags) {\n\t\t__ipr_erp_request_sense(ipr_cmd);\n\t\treturn;\n\t}\n\n\tcmd_pkt = &ipr_cmd->ioarcb.cmd_pkt;\n\tcmd_pkt->request_type = IPR_RQTYPE_IOACMD;\n\tcmd_pkt->cdb[0] = IPR_CANCEL_ALL_REQUESTS;\n\n\tipr_do_req(ipr_cmd, ipr_erp_request_sense, ipr_timeout,\n\t\t   IPR_CANCEL_ALL_TIMEOUT);\n}\n\n/**\n * ipr_dump_ioasa - Dump contents of IOASA\n * @ioa_cfg:\tioa config struct\n * @ipr_cmd:\tipr command struct\n * @res:\t\tresource entry struct\n *\n * This function is invoked by the interrupt handler when ops\n * fail. It will log the IOASA if appropriate. Only called\n * for GPDD ops.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_dump_ioasa(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t   struct ipr_cmnd *ipr_cmd, struct ipr_resource_entry *res)\n{\n\tint i;\n\tu16 data_len;\n\tu32 ioasc, fd_ioasc;\n\tstruct ipr_ioasa *ioasa = &ipr_cmd->s.ioasa;\n\t__be32 *ioasa_data = (__be32 *)ioasa;\n\tint error_index;\n\n\tioasc = be32_to_cpu(ioasa->hdr.ioasc) & IPR_IOASC_IOASC_MASK;\n\tfd_ioasc = be32_to_cpu(ioasa->hdr.fd_ioasc) & IPR_IOASC_IOASC_MASK;\n\n\tif (0 == ioasc)\n\t\treturn;\n\n\tif (ioa_cfg->log_level < IPR_DEFAULT_LOG_LEVEL)\n\t\treturn;\n\n\tif (ioasc == IPR_IOASC_BUS_WAS_RESET && fd_ioasc)\n\t\terror_index = ipr_get_error(fd_ioasc);\n\telse\n\t\terror_index = ipr_get_error(ioasc);\n\n\tif (ioa_cfg->log_level < IPR_MAX_LOG_LEVEL) {\n\t\t/* Don't log an error if the IOA already logged one */\n\t\tif (ioasa->hdr.ilid != 0)\n\t\t\treturn;\n\n\t\tif (!ipr_is_gscsi(res))\n\t\t\treturn;\n\n\t\tif (ipr_error_table[error_index].log_ioasa == 0)\n\t\t\treturn;\n\t}\n\n\tipr_res_err(ioa_cfg, res, \"%s\\n\", ipr_error_table[error_index].error);\n\n\tdata_len = be16_to_cpu(ioasa->hdr.ret_stat_len);\n\tif (ioa_cfg->sis64 && sizeof(struct ipr_ioasa64) < data_len)\n\t\tdata_len = sizeof(struct ipr_ioasa64);\n\telse if (!ioa_cfg->sis64 && sizeof(struct ipr_ioasa) < data_len)\n\t\tdata_len = sizeof(struct ipr_ioasa);\n\n\tipr_err(\"IOASA Dump:\\n\");\n\n\tfor (i = 0; i < data_len / 4; i += 4) {\n\t\tipr_err(\"%08X: %08X %08X %08X %08X\\n\", i*4,\n\t\t\tbe32_to_cpu(ioasa_data[i]),\n\t\t\tbe32_to_cpu(ioasa_data[i+1]),\n\t\t\tbe32_to_cpu(ioasa_data[i+2]),\n\t\t\tbe32_to_cpu(ioasa_data[i+3]));\n\t}\n}\n\n/**\n * ipr_gen_sense - Generate SCSI sense data from an IOASA\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_gen_sense(struct ipr_cmnd *ipr_cmd)\n{\n\tu32 failing_lba;\n\tu8 *sense_buf = ipr_cmd->scsi_cmd->sense_buffer;\n\tstruct ipr_resource_entry *res = ipr_cmd->scsi_cmd->device->hostdata;\n\tstruct ipr_ioasa *ioasa = &ipr_cmd->s.ioasa;\n\tu32 ioasc = be32_to_cpu(ioasa->hdr.ioasc);\n\n\tmemset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);\n\n\tif (ioasc >= IPR_FIRST_DRIVER_IOASC)\n\t\treturn;\n\n\tipr_cmd->scsi_cmd->result = SAM_STAT_CHECK_CONDITION;\n\n\tif (ipr_is_vset_device(res) &&\n\t    ioasc == IPR_IOASC_MED_DO_NOT_REALLOC &&\n\t    ioasa->u.vset.failing_lba_hi != 0) {\n\t\tsense_buf[0] = 0x72;\n\t\tsense_buf[1] = IPR_IOASC_SENSE_KEY(ioasc);\n\t\tsense_buf[2] = IPR_IOASC_SENSE_CODE(ioasc);\n\t\tsense_buf[3] = IPR_IOASC_SENSE_QUAL(ioasc);\n\n\t\tsense_buf[7] = 12;\n\t\tsense_buf[8] = 0;\n\t\tsense_buf[9] = 0x0A;\n\t\tsense_buf[10] = 0x80;\n\n\t\tfailing_lba = be32_to_cpu(ioasa->u.vset.failing_lba_hi);\n\n\t\tsense_buf[12] = (failing_lba & 0xff000000) >> 24;\n\t\tsense_buf[13] = (failing_lba & 0x00ff0000) >> 16;\n\t\tsense_buf[14] = (failing_lba & 0x0000ff00) >> 8;\n\t\tsense_buf[15] = failing_lba & 0x000000ff;\n\n\t\tfailing_lba = be32_to_cpu(ioasa->u.vset.failing_lba_lo);\n\n\t\tsense_buf[16] = (failing_lba & 0xff000000) >> 24;\n\t\tsense_buf[17] = (failing_lba & 0x00ff0000) >> 16;\n\t\tsense_buf[18] = (failing_lba & 0x0000ff00) >> 8;\n\t\tsense_buf[19] = failing_lba & 0x000000ff;\n\t} else {\n\t\tsense_buf[0] = 0x70;\n\t\tsense_buf[2] = IPR_IOASC_SENSE_KEY(ioasc);\n\t\tsense_buf[12] = IPR_IOASC_SENSE_CODE(ioasc);\n\t\tsense_buf[13] = IPR_IOASC_SENSE_QUAL(ioasc);\n\n\t\t/* Illegal request */\n\t\tif ((IPR_IOASC_SENSE_KEY(ioasc) == 0x05) &&\n\t\t    (be32_to_cpu(ioasa->hdr.ioasc_specific) & IPR_FIELD_POINTER_VALID)) {\n\t\t\tsense_buf[7] = 10;\t/* additional length */\n\n\t\t\t/* IOARCB was in error */\n\t\t\tif (IPR_IOASC_SENSE_CODE(ioasc) == 0x24)\n\t\t\t\tsense_buf[15] = 0xC0;\n\t\t\telse\t/* Parameter data was invalid */\n\t\t\t\tsense_buf[15] = 0x80;\n\n\t\t\tsense_buf[16] =\n\t\t\t    ((IPR_FIELD_POINTER_MASK &\n\t\t\t      be32_to_cpu(ioasa->hdr.ioasc_specific)) >> 8) & 0xff;\n\t\t\tsense_buf[17] =\n\t\t\t    (IPR_FIELD_POINTER_MASK &\n\t\t\t     be32_to_cpu(ioasa->hdr.ioasc_specific)) & 0xff;\n\t\t} else {\n\t\t\tif (ioasc == IPR_IOASC_MED_DO_NOT_REALLOC) {\n\t\t\t\tif (ipr_is_vset_device(res))\n\t\t\t\t\tfailing_lba = be32_to_cpu(ioasa->u.vset.failing_lba_lo);\n\t\t\t\telse\n\t\t\t\t\tfailing_lba = be32_to_cpu(ioasa->u.dasd.failing_lba);\n\n\t\t\t\tsense_buf[0] |= 0x80;\t/* Or in the Valid bit */\n\t\t\t\tsense_buf[3] = (failing_lba & 0xff000000) >> 24;\n\t\t\t\tsense_buf[4] = (failing_lba & 0x00ff0000) >> 16;\n\t\t\t\tsense_buf[5] = (failing_lba & 0x0000ff00) >> 8;\n\t\t\t\tsense_buf[6] = failing_lba & 0x000000ff;\n\t\t\t}\n\n\t\t\tsense_buf[7] = 6;\t/* additional length */\n\t\t}\n\t}\n}\n\n/**\n * ipr_get_autosense - Copy autosense data to sense buffer\n * @ipr_cmd:\tipr command struct\n *\n * This function copies the autosense buffer to the buffer\n * in the scsi_cmd, if there is autosense available.\n *\n * Return value:\n *\t1 if autosense was available / 0 if not\n **/\nstatic int ipr_get_autosense(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioasa *ioasa = &ipr_cmd->s.ioasa;\n\tstruct ipr_ioasa64 *ioasa64 = &ipr_cmd->s.ioasa64;\n\n\tif ((be32_to_cpu(ioasa->hdr.ioasc_specific) & IPR_AUTOSENSE_VALID) == 0)\n\t\treturn 0;\n\n\tif (ipr_cmd->ioa_cfg->sis64)\n\t\tmemcpy(ipr_cmd->scsi_cmd->sense_buffer, ioasa64->auto_sense.data,\n\t\t       min_t(u16, be16_to_cpu(ioasa64->auto_sense.auto_sense_len),\n\t\t\t   SCSI_SENSE_BUFFERSIZE));\n\telse\n\t\tmemcpy(ipr_cmd->scsi_cmd->sense_buffer, ioasa->auto_sense.data,\n\t\t       min_t(u16, be16_to_cpu(ioasa->auto_sense.auto_sense_len),\n\t\t\t   SCSI_SENSE_BUFFERSIZE));\n\treturn 1;\n}\n\n/**\n * ipr_erp_start - Process an error response for a SCSI op\n * @ioa_cfg:\tioa config struct\n * @ipr_cmd:\tipr command struct\n *\n * This function determines whether or not to initiate ERP\n * on the affected device.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_erp_start(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t      struct ipr_cmnd *ipr_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\tstruct ipr_resource_entry *res = scsi_cmd->device->hostdata;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\tu32 masked_ioasc = ioasc & IPR_IOASC_IOASC_MASK;\n\n\tif (!res) {\n\t\t__ipr_scsi_eh_done(ipr_cmd);\n\t\treturn;\n\t}\n\n\tif (!ipr_is_gscsi(res) && masked_ioasc != IPR_IOASC_HW_DEV_BUS_STATUS)\n\t\tipr_gen_sense(ipr_cmd);\n\n\tipr_dump_ioasa(ioa_cfg, ipr_cmd, res);\n\n\tswitch (masked_ioasc) {\n\tcase IPR_IOASC_ABORTED_CMD_TERM_BY_HOST:\n\t\tif (ipr_is_naca_model(res))\n\t\t\tscsi_cmd->result |= (DID_ABORT << 16);\n\t\telse\n\t\t\tscsi_cmd->result |= (DID_IMM_RETRY << 16);\n\t\tbreak;\n\tcase IPR_IOASC_IR_RESOURCE_HANDLE:\n\tcase IPR_IOASC_IR_NO_CMDS_TO_2ND_IOA:\n\t\tscsi_cmd->result |= (DID_NO_CONNECT << 16);\n\t\tbreak;\n\tcase IPR_IOASC_HW_SEL_TIMEOUT:\n\t\tscsi_cmd->result |= (DID_NO_CONNECT << 16);\n\t\tif (!ipr_is_naca_model(res))\n\t\t\tres->needs_sync_complete = 1;\n\t\tbreak;\n\tcase IPR_IOASC_SYNC_REQUIRED:\n\t\tif (!res->in_erp)\n\t\t\tres->needs_sync_complete = 1;\n\t\tscsi_cmd->result |= (DID_IMM_RETRY << 16);\n\t\tbreak;\n\tcase IPR_IOASC_MED_DO_NOT_REALLOC: /* prevent retries */\n\tcase IPR_IOASA_IR_DUAL_IOA_DISABLED:\n\t\t/*\n\t\t * exception: do not set DID_PASSTHROUGH on CHECK CONDITION\n\t\t * so SCSI mid-layer and upper layers handle it accordingly.\n\t\t */\n\t\tif (scsi_cmd->result != SAM_STAT_CHECK_CONDITION)\n\t\t\tscsi_cmd->result |= (DID_PASSTHROUGH << 16);\n\t\tbreak;\n\tcase IPR_IOASC_BUS_WAS_RESET:\n\tcase IPR_IOASC_BUS_WAS_RESET_BY_OTHER:\n\t\t/*\n\t\t * Report the bus reset and ask for a retry. The device\n\t\t * will give CC/UA the next command.\n\t\t */\n\t\tif (!res->resetting_device)\n\t\t\tscsi_report_bus_reset(ioa_cfg->host, scsi_cmd->device->channel);\n\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tif (!ipr_is_naca_model(res))\n\t\t\tres->needs_sync_complete = 1;\n\t\tbreak;\n\tcase IPR_IOASC_HW_DEV_BUS_STATUS:\n\t\tscsi_cmd->result |= IPR_IOASC_SENSE_STATUS(ioasc);\n\t\tif (IPR_IOASC_SENSE_STATUS(ioasc) == SAM_STAT_CHECK_CONDITION) {\n\t\t\tif (!ipr_get_autosense(ipr_cmd)) {\n\t\t\t\tif (!ipr_is_naca_model(res)) {\n\t\t\t\t\tipr_erp_cancel_all(ipr_cmd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ipr_is_naca_model(res))\n\t\t\tres->needs_sync_complete = 1;\n\t\tbreak;\n\tcase IPR_IOASC_NR_INIT_CMD_REQUIRED:\n\t\tbreak;\n\tcase IPR_IOASC_IR_NON_OPTIMIZED:\n\t\tif (res->raw_mode) {\n\t\t\tres->raw_mode = 0;\n\t\t\tscsi_cmd->result |= (DID_IMM_RETRY << 16);\n\t\t} else\n\t\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tbreak;\n\tdefault:\n\t\tif (IPR_IOASC_SENSE_KEY(ioasc) > RECOVERED_ERROR)\n\t\t\tscsi_cmd->result |= (DID_ERROR << 16);\n\t\tif (!ipr_is_vset_device(res) && !ipr_is_naca_model(res))\n\t\t\tres->needs_sync_complete = 1;\n\t\tbreak;\n\t}\n\n\tscsi_dma_unmap(ipr_cmd->scsi_cmd);\n\tscsi_cmd->scsi_done(scsi_cmd);\n\tif (ipr_cmd->eh_comp)\n\t\tcomplete(ipr_cmd->eh_comp);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n}\n\n/**\n * ipr_scsi_done - mid-layer done function\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked by the interrupt handler for\n * ops generated by the SCSI mid-layer\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_scsi_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct scsi_cmnd *scsi_cmd = ipr_cmd->scsi_cmd;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\tunsigned long lock_flags;\n\n\tscsi_set_resid(scsi_cmd, be32_to_cpu(ipr_cmd->s.ioasa.hdr.residual_data_len));\n\n\tif (likely(IPR_IOASC_SENSE_KEY(ioasc) == 0)) {\n\t\tscsi_dma_unmap(scsi_cmd);\n\n\t\tspin_lock_irqsave(ipr_cmd->hrrq->lock, lock_flags);\n\t\tscsi_cmd->scsi_done(scsi_cmd);\n\t\tif (ipr_cmd->eh_comp)\n\t\t\tcomplete(ipr_cmd->eh_comp);\n\t\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\t\tspin_unlock_irqrestore(ipr_cmd->hrrq->lock, lock_flags);\n\t} else {\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\tspin_lock(&ipr_cmd->hrrq->_lock);\n\t\tipr_erp_start(ioa_cfg, ipr_cmd);\n\t\tspin_unlock(&ipr_cmd->hrrq->_lock);\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t}\n}\n\n/**\n * ipr_queuecommand - Queue a mid-layer request\n * @shost:\t\tscsi host struct\n * @scsi_cmd:\tscsi command struct\n *\n * This function queues a request generated by the mid-layer.\n *\n * Return value:\n *\t0 on success\n *\tSCSI_MLQUEUE_DEVICE_BUSY if device is busy\n *\tSCSI_MLQUEUE_HOST_BUSY if host is busy\n **/\nstatic int ipr_queuecommand(struct Scsi_Host *shost,\n\t\t\t    struct scsi_cmnd *scsi_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\tstruct ipr_ioarcb *ioarcb;\n\tstruct ipr_cmnd *ipr_cmd;\n\tunsigned long hrrq_flags, lock_flags;\n\tint rc;\n\tstruct ipr_hrr_queue *hrrq;\n\tint hrrq_id;\n\n\tioa_cfg = (struct ipr_ioa_cfg *)shost->hostdata;\n\n\tscsi_cmd->result = (DID_OK << 16);\n\tres = scsi_cmd->device->hostdata;\n\n\tif (ipr_is_gata(res) && res->sata_port) {\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t\trc = ata_sas_queuecmd(scsi_cmd, res->sata_port->ap);\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\treturn rc;\n\t}\n\n\thrrq_id = ipr_get_hrrq_index(ioa_cfg);\n\thrrq = &ioa_cfg->hrrq[hrrq_id];\n\n\tspin_lock_irqsave(hrrq->lock, hrrq_flags);\n\t/*\n\t * We are currently blocking all devices due to a host reset\n\t * We have told the host to stop giving us new requests, but\n\t * ERP ops don't count. FIXME\n\t */\n\tif (unlikely(!hrrq->allow_cmds && !hrrq->ioa_is_dead && !hrrq->removing_ioa)) {\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\t/*\n\t * FIXME - Create scsi_set_host_offline interface\n\t *  and the ioa_is_dead check can be removed\n\t */\n\tif (unlikely(hrrq->ioa_is_dead || hrrq->removing_ioa || !res)) {\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\tgoto err_nodev;\n\t}\n\n\tipr_cmd = __ipr_get_free_ipr_cmnd(hrrq);\n\tif (ipr_cmd == NULL) {\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\n\tipr_init_ipr_cmnd(ipr_cmd, ipr_scsi_done);\n\tioarcb = &ipr_cmd->ioarcb;\n\n\tmemcpy(ioarcb->cmd_pkt.cdb, scsi_cmd->cmnd, scsi_cmd->cmd_len);\n\tipr_cmd->scsi_cmd = scsi_cmd;\n\tipr_cmd->done = ipr_scsi_eh_done;\n\n\tif (ipr_is_gscsi(res)) {\n\t\tif (scsi_cmd->underflow == 0)\n\t\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_NO_ULEN_CHK;\n\n\t\tif (res->reset_occurred) {\n\t\t\tres->reset_occurred = 0;\n\t\t\tioarcb->cmd_pkt.flags_lo |= IPR_FLAGS_LO_DELAY_AFTER_RST;\n\t\t}\n\t}\n\n\tif (ipr_is_gscsi(res) || ipr_is_vset_device(res)) {\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_NO_LINK_DESC;\n\n\t\tioarcb->cmd_pkt.flags_lo |= IPR_FLAGS_LO_ALIGNED_BFR;\n\t\tif (scsi_cmd->flags & SCMD_TAGGED)\n\t\t\tioarcb->cmd_pkt.flags_lo |= IPR_FLAGS_LO_SIMPLE_TASK;\n\t\telse\n\t\t\tioarcb->cmd_pkt.flags_lo |= IPR_FLAGS_LO_UNTAGGED_TASK;\n\t}\n\n\tif (scsi_cmd->cmnd[0] >= 0xC0 &&\n\t    (!ipr_is_gscsi(res) || scsi_cmd->cmnd[0] == IPR_QUERY_RSRC_STATE)) {\n\t\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\t}\n\tif (res->raw_mode && ipr_is_af_dasd_device(res)) {\n\t\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_PIPE;\n\n\t\tif (scsi_cmd->underflow == 0)\n\t\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_NO_ULEN_CHK;\n\t}\n\n\tif (ioa_cfg->sis64)\n\t\trc = ipr_build_ioadl64(ioa_cfg, ipr_cmd);\n\telse\n\t\trc = ipr_build_ioadl(ioa_cfg, ipr_cmd);\n\n\tspin_lock_irqsave(hrrq->lock, hrrq_flags);\n\tif (unlikely(rc || (!hrrq->allow_cmds && !hrrq->ioa_is_dead))) {\n\t\tlist_add_tail(&ipr_cmd->queue, &hrrq->hrrq_free_q);\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\tif (!rc)\n\t\t\tscsi_dma_unmap(scsi_cmd);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tif (unlikely(hrrq->ioa_is_dead)) {\n\t\tlist_add_tail(&ipr_cmd->queue, &hrrq->hrrq_free_q);\n\t\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\t\tscsi_dma_unmap(scsi_cmd);\n\t\tgoto err_nodev;\n\t}\n\n\tioarcb->res_handle = res->res_handle;\n\tif (res->needs_sync_complete) {\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_SYNC_COMPLETE;\n\t\tres->needs_sync_complete = 0;\n\t}\n\tlist_add_tail(&ipr_cmd->queue, &hrrq->hrrq_pending_q);\n\tipr_trc_hook(ipr_cmd, IPR_TRACE_START, IPR_GET_RES_PHYS_LOC(res));\n\tipr_send_command(ipr_cmd);\n\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\treturn 0;\n\nerr_nodev:\n\tspin_lock_irqsave(hrrq->lock, hrrq_flags);\n\tmemset(scsi_cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\tscsi_cmd->result = (DID_NO_CONNECT << 16);\n\tscsi_cmd->scsi_done(scsi_cmd);\n\tspin_unlock_irqrestore(hrrq->lock, hrrq_flags);\n\treturn 0;\n}\n\n/**\n * ipr_ioctl - IOCTL handler\n * @sdev:\tscsi device struct\n * @cmd:\tIOCTL cmd\n * @arg:\tIOCTL arg\n *\n * Return value:\n * \t0 on success / other on failure\n **/\nstatic int ipr_ioctl(struct scsi_device *sdev, unsigned int cmd,\n\t\t     void __user *arg)\n{\n\tstruct ipr_resource_entry *res;\n\n\tres = (struct ipr_resource_entry *)sdev->hostdata;\n\tif (res && ipr_is_gata(res)) {\n\t\tif (cmd == HDIO_GET_IDENTITY)\n\t\t\treturn -ENOTTY;\n\t\treturn ata_sas_scsi_ioctl(res->sata_port->ap, sdev, cmd, arg);\n\t}\n\n\treturn -EINVAL;\n}\n\n/**\n * ipr_ioa_info - Get information about the card/driver\n * @host:\tscsi host struct\n *\n * Return value:\n * \tpointer to buffer with description string\n **/\nstatic const char *ipr_ioa_info(struct Scsi_Host *host)\n{\n\tstatic char buffer[512];\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tunsigned long lock_flags = 0;\n\n\tioa_cfg = (struct ipr_ioa_cfg *) host->hostdata;\n\n\tspin_lock_irqsave(host->host_lock, lock_flags);\n\tsprintf(buffer, \"IBM %X Storage Adapter\", ioa_cfg->type);\n\tspin_unlock_irqrestore(host->host_lock, lock_flags);\n\n\treturn buffer;\n}\n\nstatic struct scsi_host_template driver_template = {\n\t.module = THIS_MODULE,\n\t.name = \"IPR\",\n\t.info = ipr_ioa_info,\n\t.ioctl = ipr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = ipr_ioctl,\n#endif\n\t.queuecommand = ipr_queuecommand,\n\t.dma_need_drain = ata_scsi_dma_need_drain,\n\t.eh_abort_handler = ipr_eh_abort,\n\t.eh_device_reset_handler = ipr_eh_dev_reset,\n\t.eh_host_reset_handler = ipr_eh_host_reset,\n\t.slave_alloc = ipr_slave_alloc,\n\t.slave_configure = ipr_slave_configure,\n\t.slave_destroy = ipr_slave_destroy,\n\t.scan_finished = ipr_scan_finished,\n\t.target_alloc = ipr_target_alloc,\n\t.target_destroy = ipr_target_destroy,\n\t.change_queue_depth = ipr_change_queue_depth,\n\t.bios_param = ipr_biosparam,\n\t.can_queue = IPR_MAX_COMMANDS,\n\t.this_id = -1,\n\t.sg_tablesize = IPR_MAX_SGLIST,\n\t.max_sectors = IPR_IOA_MAX_SECTORS,\n\t.cmd_per_lun = IPR_MAX_CMD_PER_LUN,\n\t.shost_attrs = ipr_ioa_attrs,\n\t.sdev_attrs = ipr_dev_attrs,\n\t.proc_name = IPR_NAME,\n};\n\n/**\n * ipr_ata_phy_reset - libata phy_reset handler\n * @ap:\t\tata port to reset\n *\n **/\nstatic void ipr_ata_phy_reset(struct ata_port *ap)\n{\n\tunsigned long flags;\n\tstruct ipr_sata_port *sata_port = ap->private_data;\n\tstruct ipr_resource_entry *res = sata_port->res;\n\tstruct ipr_ioa_cfg *ioa_cfg = sata_port->ioa_cfg;\n\tint rc;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\t}\n\n\tif (!ioa_cfg->hrrq[IPR_INIT_HRRQ].allow_cmds)\n\t\tgoto out_unlock;\n\n\trc = ipr_device_reset(ioa_cfg, res);\n\n\tif (rc) {\n\t\tap->link.device[0].class = ATA_DEV_NONE;\n\t\tgoto out_unlock;\n\t}\n\n\tap->link.device[0].class = res->ata_class;\n\tif (ap->link.device[0].class == ATA_DEV_UNKNOWN)\n\t\tap->link.device[0].class = ATA_DEV_NONE;\n\nout_unlock:\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\tLEAVE;\n}\n\n/**\n * ipr_ata_post_internal - Cleanup after an internal command\n * @qc:\tATA queued command\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_ata_post_internal(struct ata_queued_cmd *qc)\n{\n\tstruct ipr_sata_port *sata_port = qc->ap->private_data;\n\tstruct ipr_ioa_cfg *ioa_cfg = sata_port->ioa_cfg;\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_hrr_queue *hrrq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\t}\n\n\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\tspin_lock(&hrrq->_lock);\n\t\tlist_for_each_entry(ipr_cmd, &hrrq->hrrq_pending_q, queue) {\n\t\t\tif (ipr_cmd->qc == qc) {\n\t\t\t\tipr_device_reset(ioa_cfg, sata_port->res);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&hrrq->_lock);\n\t}\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n}\n\n/**\n * ipr_copy_sata_tf - Copy a SATA taskfile to an IOA data structure\n * @regs:\tdestination\n * @tf:\tsource ATA taskfile\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_copy_sata_tf(struct ipr_ioarcb_ata_regs *regs,\n\t\t\t     struct ata_taskfile *tf)\n{\n\tregs->feature = tf->feature;\n\tregs->nsect = tf->nsect;\n\tregs->lbal = tf->lbal;\n\tregs->lbam = tf->lbam;\n\tregs->lbah = tf->lbah;\n\tregs->device = tf->device;\n\tregs->command = tf->command;\n\tregs->hob_feature = tf->hob_feature;\n\tregs->hob_nsect = tf->hob_nsect;\n\tregs->hob_lbal = tf->hob_lbal;\n\tregs->hob_lbam = tf->hob_lbam;\n\tregs->hob_lbah = tf->hob_lbah;\n\tregs->ctl = tf->ctl;\n}\n\n/**\n * ipr_sata_done - done function for SATA commands\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked by the interrupt handler for\n * ops generated by the SCSI mid-layer to SATA devices\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_sata_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ata_queued_cmd *qc = ipr_cmd->qc;\n\tstruct ipr_sata_port *sata_port = qc->ap->private_data;\n\tstruct ipr_resource_entry *res = sata_port->res;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tspin_lock(&ipr_cmd->hrrq->_lock);\n\tif (ipr_cmd->ioa_cfg->sis64)\n\t\tmemcpy(&sata_port->ioasa, &ipr_cmd->s.ioasa64.u.gata,\n\t\t       sizeof(struct ipr_ioasa_gata));\n\telse\n\t\tmemcpy(&sata_port->ioasa, &ipr_cmd->s.ioasa.u.gata,\n\t\t       sizeof(struct ipr_ioasa_gata));\n\tipr_dump_ioasa(ioa_cfg, ipr_cmd, res);\n\n\tif (be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc_specific) & IPR_ATA_DEVICE_WAS_RESET)\n\t\tscsi_report_device_reset(ioa_cfg->host, res->bus, res->target);\n\n\tif (IPR_IOASC_SENSE_KEY(ioasc) > RECOVERED_ERROR)\n\t\tqc->err_mask |= __ac_err_mask(sata_port->ioasa.status);\n\telse\n\t\tqc->err_mask |= ac_err_mask(sata_port->ioasa.status);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\tspin_unlock(&ipr_cmd->hrrq->_lock);\n\tata_qc_complete(qc);\n}\n\n/**\n * ipr_build_ata_ioadl64 - Build an ATA scatter/gather list\n * @ipr_cmd:\tipr command struct\n * @qc:\t\tATA queued command\n *\n **/\nstatic void ipr_build_ata_ioadl64(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t  struct ata_queued_cmd *qc)\n{\n\tu32 ioadl_flags = 0;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioadl64_desc *ioadl64 = ipr_cmd->i.ata_ioadl.ioadl64;\n\tstruct ipr_ioadl64_desc *last_ioadl64 = NULL;\n\tint len = qc->nbytes;\n\tstruct scatterlist *sg;\n\tunsigned int si;\n\tdma_addr_t dma_addr = ipr_cmd->dma_addr;\n\n\tif (len == 0)\n\t\treturn;\n\n\tif (qc->dma_dir == DMA_TO_DEVICE) {\n\t\tioadl_flags = IPR_IOADL_FLAGS_WRITE;\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\t} else if (qc->dma_dir == DMA_FROM_DEVICE)\n\t\tioadl_flags = IPR_IOADL_FLAGS_READ;\n\n\tioarcb->data_transfer_length = cpu_to_be32(len);\n\tioarcb->ioadl_len =\n\t\tcpu_to_be32(sizeof(struct ipr_ioadl64_desc) * ipr_cmd->dma_use_sg);\n\tioarcb->u.sis64_addr_data.data_ioadl_addr =\n\t\tcpu_to_be64(dma_addr + offsetof(struct ipr_cmnd, i.ata_ioadl.ioadl64));\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tioadl64->flags = cpu_to_be32(ioadl_flags);\n\t\tioadl64->data_len = cpu_to_be32(sg_dma_len(sg));\n\t\tioadl64->address = cpu_to_be64(sg_dma_address(sg));\n\n\t\tlast_ioadl64 = ioadl64;\n\t\tioadl64++;\n\t}\n\n\tif (likely(last_ioadl64))\n\t\tlast_ioadl64->flags |= cpu_to_be32(IPR_IOADL_FLAGS_LAST);\n}\n\n/**\n * ipr_build_ata_ioadl - Build an ATA scatter/gather list\n * @ipr_cmd:\tipr command struct\n * @qc:\t\tATA queued command\n *\n **/\nstatic void ipr_build_ata_ioadl(struct ipr_cmnd *ipr_cmd,\n\t\t\t\tstruct ata_queued_cmd *qc)\n{\n\tu32 ioadl_flags = 0;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioadl_desc *ioadl = ipr_cmd->i.ioadl;\n\tstruct ipr_ioadl_desc *last_ioadl = NULL;\n\tint len = qc->nbytes;\n\tstruct scatterlist *sg;\n\tunsigned int si;\n\n\tif (len == 0)\n\t\treturn;\n\n\tif (qc->dma_dir == DMA_TO_DEVICE) {\n\t\tioadl_flags = IPR_IOADL_FLAGS_WRITE;\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\t\tioarcb->data_transfer_length = cpu_to_be32(len);\n\t\tioarcb->ioadl_len =\n\t\t\tcpu_to_be32(sizeof(struct ipr_ioadl_desc) * ipr_cmd->dma_use_sg);\n\t} else if (qc->dma_dir == DMA_FROM_DEVICE) {\n\t\tioadl_flags = IPR_IOADL_FLAGS_READ;\n\t\tioarcb->read_data_transfer_length = cpu_to_be32(len);\n\t\tioarcb->read_ioadl_len =\n\t\t\tcpu_to_be32(sizeof(struct ipr_ioadl_desc) * ipr_cmd->dma_use_sg);\n\t}\n\n\tfor_each_sg(qc->sg, sg, qc->n_elem, si) {\n\t\tioadl->flags_and_data_len = cpu_to_be32(ioadl_flags | sg_dma_len(sg));\n\t\tioadl->address = cpu_to_be32(sg_dma_address(sg));\n\n\t\tlast_ioadl = ioadl;\n\t\tioadl++;\n\t}\n\n\tif (likely(last_ioadl))\n\t\tlast_ioadl->flags_and_data_len |= cpu_to_be32(IPR_IOADL_FLAGS_LAST);\n}\n\n/**\n * ipr_qc_defer - Get a free ipr_cmd\n * @qc:\tqueued command\n *\n * Return value:\n *\t0 if success\n **/\nstatic int ipr_qc_defer(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ipr_sata_port *sata_port = ap->private_data;\n\tstruct ipr_ioa_cfg *ioa_cfg = sata_port->ioa_cfg;\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_hrr_queue *hrrq;\n\tint hrrq_id;\n\n\thrrq_id = ipr_get_hrrq_index(ioa_cfg);\n\thrrq = &ioa_cfg->hrrq[hrrq_id];\n\n\tqc->lldd_task = NULL;\n\tspin_lock(&hrrq->_lock);\n\tif (unlikely(hrrq->ioa_is_dead)) {\n\t\tspin_unlock(&hrrq->_lock);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!hrrq->allow_cmds)) {\n\t\tspin_unlock(&hrrq->_lock);\n\t\treturn ATA_DEFER_LINK;\n\t}\n\n\tipr_cmd = __ipr_get_free_ipr_cmnd(hrrq);\n\tif (ipr_cmd == NULL) {\n\t\tspin_unlock(&hrrq->_lock);\n\t\treturn ATA_DEFER_LINK;\n\t}\n\n\tqc->lldd_task = ipr_cmd;\n\tspin_unlock(&hrrq->_lock);\n\treturn 0;\n}\n\n/**\n * ipr_qc_issue - Issue a SATA qc to a device\n * @qc:\tqueued command\n *\n * Return value:\n * \t0 if success\n **/\nstatic unsigned int ipr_qc_issue(struct ata_queued_cmd *qc)\n{\n\tstruct ata_port *ap = qc->ap;\n\tstruct ipr_sata_port *sata_port = ap->private_data;\n\tstruct ipr_resource_entry *res = sata_port->res;\n\tstruct ipr_ioa_cfg *ioa_cfg = sata_port->ioa_cfg;\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioarcb *ioarcb;\n\tstruct ipr_ioarcb_ata_regs *regs;\n\n\tif (qc->lldd_task == NULL)\n\t\tipr_qc_defer(qc);\n\n\tipr_cmd = qc->lldd_task;\n\tif (ipr_cmd == NULL)\n\t\treturn AC_ERR_SYSTEM;\n\n\tqc->lldd_task = NULL;\n\tspin_lock(&ipr_cmd->hrrq->_lock);\n\tif (unlikely(!ipr_cmd->hrrq->allow_cmds ||\n\t\t\tipr_cmd->hrrq->ioa_is_dead)) {\n\t\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\t\tspin_unlock(&ipr_cmd->hrrq->_lock);\n\t\treturn AC_ERR_SYSTEM;\n\t}\n\n\tipr_init_ipr_cmnd(ipr_cmd, ipr_lock_and_done);\n\tioarcb = &ipr_cmd->ioarcb;\n\n\tif (ioa_cfg->sis64) {\n\t\tregs = &ipr_cmd->i.ata_ioadl.regs;\n\t\tioarcb->add_cmd_parms_offset = cpu_to_be16(sizeof(*ioarcb));\n\t} else\n\t\tregs = &ioarcb->u.add_data.u.regs;\n\n\tmemset(regs, 0, sizeof(*regs));\n\tioarcb->add_cmd_parms_len = cpu_to_be16(sizeof(*regs));\n\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\tipr_cmd->qc = qc;\n\tipr_cmd->done = ipr_sata_done;\n\tipr_cmd->ioarcb.res_handle = res->res_handle;\n\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_ATA_PASSTHRU;\n\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_NO_LINK_DESC;\n\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_NO_ULEN_CHK;\n\tipr_cmd->dma_use_sg = qc->n_elem;\n\n\tif (ioa_cfg->sis64)\n\t\tipr_build_ata_ioadl64(ipr_cmd, qc);\n\telse\n\t\tipr_build_ata_ioadl(ipr_cmd, qc);\n\n\tregs->flags |= IPR_ATA_FLAG_STATUS_ON_GOOD_COMPLETION;\n\tipr_copy_sata_tf(regs, &qc->tf);\n\tmemcpy(ioarcb->cmd_pkt.cdb, qc->cdb, IPR_MAX_CDB_LEN);\n\tipr_trc_hook(ipr_cmd, IPR_TRACE_START, IPR_GET_RES_PHYS_LOC(res));\n\n\tswitch (qc->tf.protocol) {\n\tcase ATA_PROT_NODATA:\n\tcase ATA_PROT_PIO:\n\t\tbreak;\n\n\tcase ATA_PROT_DMA:\n\t\tregs->flags |= IPR_ATA_FLAG_XFER_TYPE_DMA;\n\t\tbreak;\n\n\tcase ATAPI_PROT_PIO:\n\tcase ATAPI_PROT_NODATA:\n\t\tregs->flags |= IPR_ATA_FLAG_PACKET_CMD;\n\t\tbreak;\n\n\tcase ATAPI_PROT_DMA:\n\t\tregs->flags |= IPR_ATA_FLAG_PACKET_CMD;\n\t\tregs->flags |= IPR_ATA_FLAG_XFER_TYPE_DMA;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\tspin_unlock(&ipr_cmd->hrrq->_lock);\n\t\treturn AC_ERR_INVALID;\n\t}\n\n\tipr_send_command(ipr_cmd);\n\tspin_unlock(&ipr_cmd->hrrq->_lock);\n\n\treturn 0;\n}\n\n/**\n * ipr_qc_fill_rtf - Read result TF\n * @qc: ATA queued command\n *\n * Return value:\n * \ttrue\n **/\nstatic bool ipr_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct ipr_sata_port *sata_port = qc->ap->private_data;\n\tstruct ipr_ioasa_gata *g = &sata_port->ioasa;\n\tstruct ata_taskfile *tf = &qc->result_tf;\n\n\ttf->feature = g->error;\n\ttf->nsect = g->nsect;\n\ttf->lbal = g->lbal;\n\ttf->lbam = g->lbam;\n\ttf->lbah = g->lbah;\n\ttf->device = g->device;\n\ttf->command = g->status;\n\ttf->hob_nsect = g->hob_nsect;\n\ttf->hob_lbal = g->hob_lbal;\n\ttf->hob_lbam = g->hob_lbam;\n\ttf->hob_lbah = g->hob_lbah;\n\n\treturn true;\n}\n\nstatic struct ata_port_operations ipr_sata_ops = {\n\t.phy_reset = ipr_ata_phy_reset,\n\t.hardreset = ipr_sata_reset,\n\t.post_internal_cmd = ipr_ata_post_internal,\n\t.qc_prep = ata_noop_qc_prep,\n\t.qc_defer = ipr_qc_defer,\n\t.qc_issue = ipr_qc_issue,\n\t.qc_fill_rtf = ipr_qc_fill_rtf,\n\t.port_start = ata_sas_port_start,\n\t.port_stop = ata_sas_port_stop\n};\n\nstatic struct ata_port_info sata_port_info = {\n\t.flags\t\t= ATA_FLAG_SATA | ATA_FLAG_PIO_DMA |\n\t\t\t  ATA_FLAG_SAS_HOST,\n\t.pio_mask\t= ATA_PIO4_ONLY,\n\t.mwdma_mask\t= ATA_MWDMA2,\n\t.udma_mask\t= ATA_UDMA6,\n\t.port_ops\t= &ipr_sata_ops\n};\n\n#ifdef CONFIG_PPC_PSERIES\nstatic const u16 ipr_blocked_processors[] = {\n\tPVR_NORTHSTAR,\n\tPVR_PULSAR,\n\tPVR_POWER4,\n\tPVR_ICESTAR,\n\tPVR_SSTAR,\n\tPVR_POWER4p,\n\tPVR_630,\n\tPVR_630p\n};\n\n/**\n * ipr_invalid_adapter - Determine if this adapter is supported on this hardware\n * @ioa_cfg:\tioa cfg struct\n *\n * Adapters that use Gemstone revision < 3.1 do not work reliably on\n * certain pSeries hardware. This function determines if the given\n * adapter is in one of these confgurations or not.\n *\n * Return value:\n * \t1 if adapter is not supported / 0 if adapter is supported\n **/\nstatic int ipr_invalid_adapter(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint i;\n\n\tif ((ioa_cfg->type == 0x5702) && (ioa_cfg->pdev->revision < 4)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ipr_blocked_processors); i++) {\n\t\t\tif (pvr_version_is(ipr_blocked_processors[i]))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n#else\n#define ipr_invalid_adapter(ioa_cfg) 0\n#endif\n\n/**\n * ipr_ioa_bringdown_done - IOA bring down completion.\n * @ipr_cmd:\tipr command struct\n *\n * This function processes the completion of an adapter bring down.\n * It wakes any reset sleepers.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioa_bringdown_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tint i;\n\n\tENTER;\n\tif (!ioa_cfg->hrrq[IPR_INIT_HRRQ].removing_ioa) {\n\t\tipr_trace;\n\t\tioa_cfg->scsi_unblock = 1;\n\t\tschedule_work(&ioa_cfg->work_q);\n\t}\n\n\tioa_cfg->in_reset_reload = 0;\n\tioa_cfg->reset_retries = 0;\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\tioa_cfg->hrrq[i].ioa_is_dead = 1;\n\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t}\n\twmb();\n\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\twake_up_all(&ioa_cfg->reset_wait_q);\n\tLEAVE;\n\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_ioa_reset_done - IOA reset completion.\n * @ipr_cmd:\tipr command struct\n *\n * This function processes the completion of an adapter reset.\n * It schedules any necessary mid-layer add/removes and\n * wakes any reset sleepers.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioa_reset_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_resource_entry *res;\n\tint j;\n\n\tENTER;\n\tioa_cfg->in_reset_reload = 0;\n\tfor (j = 0; j < ioa_cfg->hrrq_num; j++) {\n\t\tspin_lock(&ioa_cfg->hrrq[j]._lock);\n\t\tioa_cfg->hrrq[j].allow_cmds = 1;\n\t\tspin_unlock(&ioa_cfg->hrrq[j]._lock);\n\t}\n\twmb();\n\tioa_cfg->reset_cmd = NULL;\n\tioa_cfg->doorbell |= IPR_RUNTIME_RESET;\n\n\tlist_for_each_entry(res, &ioa_cfg->used_res_q, queue) {\n\t\tif (res->add_to_ml || res->del_from_ml) {\n\t\t\tipr_trace;\n\t\t\tbreak;\n\t\t}\n\t}\n\tschedule_work(&ioa_cfg->work_q);\n\n\tfor (j = 0; j < IPR_NUM_HCAMS; j++) {\n\t\tlist_del_init(&ioa_cfg->hostrcb[j]->queue);\n\t\tif (j < IPR_NUM_LOG_HCAMS)\n\t\t\tipr_send_hcam(ioa_cfg,\n\t\t\t\tIPR_HCAM_CDB_OP_CODE_LOG_DATA,\n\t\t\t\tioa_cfg->hostrcb[j]);\n\t\telse\n\t\t\tipr_send_hcam(ioa_cfg,\n\t\t\t\tIPR_HCAM_CDB_OP_CODE_CONFIG_CHANGE,\n\t\t\t\tioa_cfg->hostrcb[j]);\n\t}\n\n\tscsi_report_bus_reset(ioa_cfg->host, IPR_VSET_BUS);\n\tdev_info(&ioa_cfg->pdev->dev, \"IOA initialized.\\n\");\n\n\tioa_cfg->reset_retries = 0;\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\twake_up_all(&ioa_cfg->reset_wait_q);\n\n\tioa_cfg->scsi_unblock = 1;\n\tschedule_work(&ioa_cfg->work_q);\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_set_sup_dev_dflt - Initialize a Set Supported Device buffer\n * @supported_dev:\tsupported device struct\n * @vpids:\t\t\tvendor product id struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_set_sup_dev_dflt(struct ipr_supported_device *supported_dev,\n\t\t\t\t struct ipr_std_inq_vpids *vpids)\n{\n\tmemset(supported_dev, 0, sizeof(struct ipr_supported_device));\n\tmemcpy(&supported_dev->vpids, vpids, sizeof(struct ipr_std_inq_vpids));\n\tsupported_dev->num_records = 1;\n\tsupported_dev->data_length =\n\t\tcpu_to_be16(sizeof(struct ipr_supported_device));\n\tsupported_dev->reserved = 0;\n}\n\n/**\n * ipr_set_supported_devs - Send Set Supported Devices for a device\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a Set Supported Devices to the adapter\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_set_supported_devs(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_supported_device *supp_dev = &ioa_cfg->vpd_cbs->supp_dev;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_resource_entry *res = ipr_cmd->u.res;\n\n\tipr_cmd->job_step = ipr_ioa_reset_done;\n\n\tlist_for_each_entry_continue(res, &ioa_cfg->used_res_q, queue) {\n\t\tif (!ipr_is_scsi_disk(res))\n\t\t\tcontinue;\n\n\t\tipr_cmd->u.res = res;\n\t\tipr_set_sup_dev_dflt(supp_dev, &res->std_inq_data.vpids);\n\n\t\tioarcb->res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\t\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\t\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\n\t\tioarcb->cmd_pkt.cdb[0] = IPR_SET_SUPPORTED_DEVICES;\n\t\tioarcb->cmd_pkt.cdb[1] = IPR_SET_ALL_SUPPORTED_DEVICES;\n\t\tioarcb->cmd_pkt.cdb[7] = (sizeof(struct ipr_supported_device) >> 8) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[8] = sizeof(struct ipr_supported_device) & 0xff;\n\n\t\tipr_init_ioadl(ipr_cmd,\n\t\t\t       ioa_cfg->vpd_cbs_dma +\n\t\t\t\t offsetof(struct ipr_misc_cbs, supp_dev),\n\t\t\t       sizeof(struct ipr_supported_device),\n\t\t\t       IPR_IOADL_FLAGS_WRITE_LAST);\n\n\t\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout,\n\t\t\t   IPR_SET_SUP_DEVICE_TIMEOUT);\n\n\t\tif (!ioa_cfg->sis64)\n\t\t\tipr_cmd->job_step = ipr_set_supported_devs;\n\t\tLEAVE;\n\t\treturn IPR_RC_JOB_RETURN;\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_get_mode_page - Locate specified mode page\n * @mode_pages:\tmode page buffer\n * @page_code:\tpage code to find\n * @len:\t\tminimum required length for mode page\n *\n * Return value:\n * \tpointer to mode page / NULL on failure\n **/\nstatic void *ipr_get_mode_page(struct ipr_mode_pages *mode_pages,\n\t\t\t       u32 page_code, u32 len)\n{\n\tstruct ipr_mode_page_hdr *mode_hdr;\n\tu32 page_length;\n\tu32 length;\n\n\tif (!mode_pages || (mode_pages->hdr.length == 0))\n\t\treturn NULL;\n\n\tlength = (mode_pages->hdr.length + 1) - 4 - mode_pages->hdr.block_desc_len;\n\tmode_hdr = (struct ipr_mode_page_hdr *)\n\t\t(mode_pages->data + mode_pages->hdr.block_desc_len);\n\n\twhile (length) {\n\t\tif (IPR_GET_MODE_PAGE_CODE(mode_hdr) == page_code) {\n\t\t\tif (mode_hdr->page_length >= (len - sizeof(struct ipr_mode_page_hdr)))\n\t\t\t\treturn mode_hdr;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpage_length = (sizeof(struct ipr_mode_page_hdr) +\n\t\t\t\t       mode_hdr->page_length);\n\t\t\tlength -= page_length;\n\t\t\tmode_hdr = (struct ipr_mode_page_hdr *)\n\t\t\t\t((unsigned long)mode_hdr + page_length);\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * ipr_check_term_power - Check for term power errors\n * @ioa_cfg:\tioa config struct\n * @mode_pages:\tIOAFP mode pages buffer\n *\n * Check the IOAFP's mode page 28 for term power errors\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_check_term_power(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t struct ipr_mode_pages *mode_pages)\n{\n\tint i;\n\tint entry_length;\n\tstruct ipr_dev_bus_entry *bus;\n\tstruct ipr_mode_page28 *mode_page;\n\n\tmode_page = ipr_get_mode_page(mode_pages, 0x28,\n\t\t\t\t      sizeof(struct ipr_mode_page28));\n\n\tentry_length = mode_page->entry_length;\n\n\tbus = mode_page->bus;\n\n\tfor (i = 0; i < mode_page->num_entries; i++) {\n\t\tif (bus->flags & IPR_SCSI_ATTR_NO_TERM_PWR) {\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"Term power is absent on scsi bus %d\\n\",\n\t\t\t\tbus->res_addr.bus);\n\t\t}\n\n\t\tbus = (struct ipr_dev_bus_entry *)((char *)bus + entry_length);\n\t}\n}\n\n/**\n * ipr_scsi_bus_speed_limit - Limit the SCSI speed based on SES table\n * @ioa_cfg:\tioa config struct\n *\n * Looks through the config table checking for SES devices. If\n * the SES device is in the SES table indicating a maximum SCSI\n * bus speed, the speed is limited for the bus.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_scsi_bus_speed_limit(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tu32 max_xfer_rate;\n\tint i;\n\n\tfor (i = 0; i < IPR_MAX_NUM_BUSES; i++) {\n\t\tmax_xfer_rate = ipr_get_max_scsi_speed(ioa_cfg, i,\n\t\t\t\t\t\t       ioa_cfg->bus_attr[i].bus_width);\n\n\t\tif (max_xfer_rate < ioa_cfg->bus_attr[i].max_xfer_rate)\n\t\t\tioa_cfg->bus_attr[i].max_xfer_rate = max_xfer_rate;\n\t}\n}\n\n/**\n * ipr_modify_ioafp_mode_page_28 - Modify IOAFP Mode Page 28\n * @ioa_cfg:\tioa config struct\n * @mode_pages:\tmode page 28 buffer\n *\n * Updates mode page 28 based on driver configuration\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_modify_ioafp_mode_page_28(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t\t  struct ipr_mode_pages *mode_pages)\n{\n\tint i, entry_length;\n\tstruct ipr_dev_bus_entry *bus;\n\tstruct ipr_bus_attributes *bus_attr;\n\tstruct ipr_mode_page28 *mode_page;\n\n\tmode_page = ipr_get_mode_page(mode_pages, 0x28,\n\t\t\t\t      sizeof(struct ipr_mode_page28));\n\n\tentry_length = mode_page->entry_length;\n\n\t/* Loop for each device bus entry */\n\tfor (i = 0, bus = mode_page->bus;\n\t     i < mode_page->num_entries;\n\t     i++, bus = (struct ipr_dev_bus_entry *)((u8 *)bus + entry_length)) {\n\t\tif (bus->res_addr.bus > IPR_MAX_NUM_BUSES) {\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"Invalid resource address reported: 0x%08X\\n\",\n\t\t\t\tIPR_GET_PHYS_LOC(bus->res_addr));\n\t\t\tcontinue;\n\t\t}\n\n\t\tbus_attr = &ioa_cfg->bus_attr[i];\n\t\tbus->extended_reset_delay = IPR_EXTENDED_RESET_DELAY;\n\t\tbus->bus_width = bus_attr->bus_width;\n\t\tbus->max_xfer_rate = cpu_to_be32(bus_attr->max_xfer_rate);\n\t\tbus->flags &= ~IPR_SCSI_ATTR_QAS_MASK;\n\t\tif (bus_attr->qas_enabled)\n\t\t\tbus->flags |= IPR_SCSI_ATTR_ENABLE_QAS;\n\t\telse\n\t\t\tbus->flags |= IPR_SCSI_ATTR_DISABLE_QAS;\n\t}\n}\n\n/**\n * ipr_build_mode_select - Build a mode select command\n * @ipr_cmd:\tipr command struct\n * @res_handle:\tresource handle to send command to\n * @parm:\t\tByte 2 of Mode Sense command\n * @dma_addr:\tDMA buffer address\n * @xfer_len:\tdata transfer length\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_build_mode_select(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t  __be32 res_handle, u8 parm,\n\t\t\t\t  dma_addr_t dma_addr, u8 xfer_len)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\n\tioarcb->res_handle = res_handle;\n\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_SCSICDB;\n\tioarcb->cmd_pkt.flags_hi |= IPR_FLAGS_HI_WRITE_NOT_READ;\n\tioarcb->cmd_pkt.cdb[0] = MODE_SELECT;\n\tioarcb->cmd_pkt.cdb[1] = parm;\n\tioarcb->cmd_pkt.cdb[4] = xfer_len;\n\n\tipr_init_ioadl(ipr_cmd, dma_addr, xfer_len, IPR_IOADL_FLAGS_WRITE_LAST);\n}\n\n/**\n * ipr_ioafp_mode_select_page28 - Issue Mode Select Page 28 to IOA\n * @ipr_cmd:\tipr command struct\n *\n * This function sets up the SCSI bus attributes and sends\n * a Mode Select for Page 28 to activate them.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_mode_select_page28(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_mode_pages *mode_pages = &ioa_cfg->vpd_cbs->mode_pages;\n\tint length;\n\n\tENTER;\n\tipr_scsi_bus_speed_limit(ioa_cfg);\n\tipr_check_term_power(ioa_cfg, mode_pages);\n\tipr_modify_ioafp_mode_page_28(ioa_cfg, mode_pages);\n\tlength = mode_pages->hdr.length + 1;\n\tmode_pages->hdr.length = 0;\n\n\tipr_build_mode_select(ipr_cmd, cpu_to_be32(IPR_IOA_RES_HANDLE), 0x11,\n\t\t\t      ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, mode_pages),\n\t\t\t      length);\n\n\tipr_cmd->job_step = ipr_set_supported_devs;\n\tipr_cmd->u.res = list_entry(ioa_cfg->used_res_q.next,\n\t\t\t\t    struct ipr_resource_entry, queue);\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, IPR_INTERNAL_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_build_mode_sense - Builds a mode sense command\n * @ipr_cmd:\tipr command struct\n * @res_handle:\t\tresource entry struct\n * @parm:\t\tByte 2 of mode sense command\n * @dma_addr:\tDMA address of mode sense buffer\n * @xfer_len:\tSize of DMA buffer\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_build_mode_sense(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t __be32 res_handle,\n\t\t\t\t u8 parm, dma_addr_t dma_addr, u8 xfer_len)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\n\tioarcb->res_handle = res_handle;\n\tioarcb->cmd_pkt.cdb[0] = MODE_SENSE;\n\tioarcb->cmd_pkt.cdb[2] = parm;\n\tioarcb->cmd_pkt.cdb[4] = xfer_len;\n\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_SCSICDB;\n\n\tipr_init_ioadl(ipr_cmd, dma_addr, xfer_len, IPR_IOADL_FLAGS_READ_LAST);\n}\n\n/**\n * ipr_reset_cmd_failed - Handle failure of IOA reset command\n * @ipr_cmd:\tipr command struct\n *\n * This function handles the failure of an IOA bringup command.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_cmd_failed(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\"0x%02X failed with IOASC: 0x%08X\\n\",\n\t\tipr_cmd->ioarcb.cmd_pkt.cdb[0], ioasc);\n\n\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_mode_sense_failed - Handle failure of IOAFP mode sense\n * @ipr_cmd:\tipr command struct\n *\n * This function handles the failure of a Mode Sense to the IOAFP.\n * Some adapters do not handle all mode pages.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_mode_sense_failed(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tif (ioasc == IPR_IOASC_IR_INVALID_REQ_TYPE_OR_PKT) {\n\t\tipr_cmd->job_step = ipr_set_supported_devs;\n\t\tipr_cmd->u.res = list_entry(ioa_cfg->used_res_q.next,\n\t\t\t\t\t    struct ipr_resource_entry, queue);\n\t\treturn IPR_RC_JOB_CONTINUE;\n\t}\n\n\treturn ipr_reset_cmd_failed(ipr_cmd);\n}\n\n/**\n * ipr_ioafp_mode_sense_page28 - Issue Mode Sense Page 28 to IOA\n * @ipr_cmd:\tipr command struct\n *\n * This function send a Page 28 mode sense to the IOA to\n * retrieve SCSI bus attributes.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_mode_sense_page28(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tipr_build_mode_sense(ipr_cmd, cpu_to_be32(IPR_IOA_RES_HANDLE),\n\t\t\t     0x28, ioa_cfg->vpd_cbs_dma +\n\t\t\t     offsetof(struct ipr_misc_cbs, mode_pages),\n\t\t\t     sizeof(struct ipr_mode_pages));\n\n\tipr_cmd->job_step = ipr_ioafp_mode_select_page28;\n\tipr_cmd->job_step_failed = ipr_reset_mode_sense_failed;\n\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, IPR_INTERNAL_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_ioafp_mode_select_page24 - Issue Mode Select to IOA\n * @ipr_cmd:\tipr command struct\n *\n * This function enables dual IOA RAID support if possible.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_mode_select_page24(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_mode_pages *mode_pages = &ioa_cfg->vpd_cbs->mode_pages;\n\tstruct ipr_mode_page24 *mode_page;\n\tint length;\n\n\tENTER;\n\tmode_page = ipr_get_mode_page(mode_pages, 0x24,\n\t\t\t\t      sizeof(struct ipr_mode_page24));\n\n\tif (mode_page)\n\t\tmode_page->flags |= IPR_ENABLE_DUAL_IOA_AF;\n\n\tlength = mode_pages->hdr.length + 1;\n\tmode_pages->hdr.length = 0;\n\n\tipr_build_mode_select(ipr_cmd, cpu_to_be32(IPR_IOA_RES_HANDLE), 0x11,\n\t\t\t      ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, mode_pages),\n\t\t\t      length);\n\n\tipr_cmd->job_step = ipr_ioafp_mode_sense_page28;\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, IPR_INTERNAL_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_mode_sense_page24_failed - Handle failure of IOAFP mode sense\n * @ipr_cmd:\tipr command struct\n *\n * This function handles the failure of a Mode Sense to the IOAFP.\n * Some adapters do not handle all mode pages.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_mode_sense_page24_failed(struct ipr_cmnd *ipr_cmd)\n{\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tif (ioasc == IPR_IOASC_IR_INVALID_REQ_TYPE_OR_PKT) {\n\t\tipr_cmd->job_step = ipr_ioafp_mode_sense_page28;\n\t\treturn IPR_RC_JOB_CONTINUE;\n\t}\n\n\treturn ipr_reset_cmd_failed(ipr_cmd);\n}\n\n/**\n * ipr_ioafp_mode_sense_page24 - Issue Page 24 Mode Sense to IOA\n * @ipr_cmd:\tipr command struct\n *\n * This function send a mode sense to the IOA to retrieve\n * the IOA Advanced Function Control mode page.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_mode_sense_page24(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tipr_build_mode_sense(ipr_cmd, cpu_to_be32(IPR_IOA_RES_HANDLE),\n\t\t\t     0x24, ioa_cfg->vpd_cbs_dma +\n\t\t\t     offsetof(struct ipr_misc_cbs, mode_pages),\n\t\t\t     sizeof(struct ipr_mode_pages));\n\n\tipr_cmd->job_step = ipr_ioafp_mode_select_page24;\n\tipr_cmd->job_step_failed = ipr_reset_mode_sense_page24_failed;\n\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, IPR_INTERNAL_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_init_res_table - Initialize the resource table\n * @ipr_cmd:\tipr command struct\n *\n * This function looks through the existing resource table, comparing\n * it with the config table. This function will take care of old/new\n * devices and schedule adding/removing them from the mid-layer\n * as appropriate.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_init_res_table(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_resource_entry *res, *temp;\n\tstruct ipr_config_table_entry_wrapper cfgtew;\n\tint entries, found, flag, i;\n\tLIST_HEAD(old_res);\n\n\tENTER;\n\tif (ioa_cfg->sis64)\n\t\tflag = ioa_cfg->u.cfg_table64->hdr64.flags;\n\telse\n\t\tflag = ioa_cfg->u.cfg_table->hdr.flags;\n\n\tif (flag & IPR_UCODE_DOWNLOAD_REQ)\n\t\tdev_err(&ioa_cfg->pdev->dev, \"Microcode download required\\n\");\n\n\tlist_for_each_entry_safe(res, temp, &ioa_cfg->used_res_q, queue)\n\t\tlist_move_tail(&res->queue, &old_res);\n\n\tif (ioa_cfg->sis64)\n\t\tentries = be16_to_cpu(ioa_cfg->u.cfg_table64->hdr64.num_entries);\n\telse\n\t\tentries = ioa_cfg->u.cfg_table->hdr.num_entries;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tif (ioa_cfg->sis64)\n\t\t\tcfgtew.u.cfgte64 = &ioa_cfg->u.cfg_table64->dev[i];\n\t\telse\n\t\t\tcfgtew.u.cfgte = &ioa_cfg->u.cfg_table->dev[i];\n\t\tfound = 0;\n\n\t\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\t\t\tif (ipr_is_same_device(res, &cfgtew)) {\n\t\t\t\tlist_move_tail(&res->queue, &ioa_cfg->used_res_q);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (list_empty(&ioa_cfg->free_res_q)) {\n\t\t\t\tdev_err(&ioa_cfg->pdev->dev, \"Too many devices attached\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfound = 1;\n\t\t\tres = list_entry(ioa_cfg->free_res_q.next,\n\t\t\t\t\t struct ipr_resource_entry, queue);\n\t\t\tlist_move_tail(&res->queue, &ioa_cfg->used_res_q);\n\t\t\tipr_init_res_entry(res, &cfgtew);\n\t\t\tres->add_to_ml = 1;\n\t\t} else if (res->sdev && (ipr_is_vset_device(res) || ipr_is_scsi_disk(res)))\n\t\t\tres->sdev->allow_restart = 1;\n\n\t\tif (found)\n\t\t\tipr_update_res_entry(res, &cfgtew);\n\t}\n\n\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\t\tif (res->sdev) {\n\t\t\tres->del_from_ml = 1;\n\t\t\tres->res_handle = IPR_INVALID_RES_HANDLE;\n\t\t\tlist_move_tail(&res->queue, &ioa_cfg->used_res_q);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(res, temp, &old_res, queue) {\n\t\tipr_clear_res_target(res);\n\t\tlist_move_tail(&res->queue, &ioa_cfg->free_res_q);\n\t}\n\n\tif (ioa_cfg->dual_raid && ipr_dual_ioa_raid)\n\t\tipr_cmd->job_step = ipr_ioafp_mode_sense_page24;\n\telse\n\t\tipr_cmd->job_step = ipr_ioafp_mode_sense_page28;\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_ioafp_query_ioa_cfg - Send a Query IOA Config to the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a Query IOA Configuration command\n * to the adapter to retrieve the IOA configuration table.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_query_ioa_cfg(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_inquiry_page3 *ucode_vpd = &ioa_cfg->vpd_cbs->page3_data;\n\tstruct ipr_inquiry_cap *cap = &ioa_cfg->vpd_cbs->cap;\n\n\tENTER;\n\tif (cap->cap & IPR_CAP_DUAL_IOA_RAID)\n\t\tioa_cfg->dual_raid = 1;\n\tdev_info(&ioa_cfg->pdev->dev, \"Adapter firmware version: %02X%02X%02X%02X\\n\",\n\t\t ucode_vpd->major_release, ucode_vpd->card_type,\n\t\t ucode_vpd->minor_release[0], ucode_vpd->minor_release[1]);\n\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\tioarcb->res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\n\tioarcb->cmd_pkt.cdb[0] = IPR_QUERY_IOA_CONFIG;\n\tioarcb->cmd_pkt.cdb[6] = (ioa_cfg->cfg_table_size >> 16) & 0xff;\n\tioarcb->cmd_pkt.cdb[7] = (ioa_cfg->cfg_table_size >> 8) & 0xff;\n\tioarcb->cmd_pkt.cdb[8] = ioa_cfg->cfg_table_size & 0xff;\n\n\tipr_init_ioadl(ipr_cmd, ioa_cfg->cfg_table_dma, ioa_cfg->cfg_table_size,\n\t\t       IPR_IOADL_FLAGS_READ_LAST);\n\n\tipr_cmd->job_step = ipr_init_res_table;\n\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, IPR_INTERNAL_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\nstatic int ipr_ioa_service_action_failed(struct ipr_cmnd *ipr_cmd)\n{\n\tu32 ioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\tif (ioasc == IPR_IOASC_IR_INVALID_REQ_TYPE_OR_PKT)\n\t\treturn IPR_RC_JOB_CONTINUE;\n\n\treturn ipr_reset_cmd_failed(ipr_cmd);\n}\n\nstatic void ipr_build_ioa_service_action(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t\t __be32 res_handle, u8 sa_code)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\n\tioarcb->res_handle = res_handle;\n\tioarcb->cmd_pkt.cdb[0] = IPR_IOA_SERVICE_ACTION;\n\tioarcb->cmd_pkt.cdb[1] = sa_code;\n\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n}\n\n/**\n * ipr_ioafp_set_caching_parameters - Issue Set Cache parameters service\n * action\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n *\tnone\n **/\nstatic int ipr_ioafp_set_caching_parameters(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_inquiry_pageC4 *pageC4 = &ioa_cfg->vpd_cbs->pageC4_data;\n\n\tENTER;\n\n\tipr_cmd->job_step = ipr_ioafp_query_ioa_cfg;\n\n\tif (pageC4->cache_cap[0] & IPR_CAP_SYNC_CACHE) {\n\t\tipr_build_ioa_service_action(ipr_cmd,\n\t\t\t\t\t     cpu_to_be32(IPR_IOA_RES_HANDLE),\n\t\t\t\t\t     IPR_IOA_SA_CHANGE_CACHE_PARAMS);\n\n\t\tioarcb->cmd_pkt.cdb[2] = 0x40;\n\n\t\tipr_cmd->job_step_failed = ipr_ioa_service_action_failed;\n\t\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout,\n\t\t\t   IPR_SET_SUP_DEVICE_TIMEOUT);\n\n\t\tLEAVE;\n\t\treturn IPR_RC_JOB_RETURN;\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_ioafp_inquiry - Send an Inquiry to the adapter.\n * @ipr_cmd:\tipr command struct\n * @flags:\tflags to send\n * @page:\tpage to inquire\n * @dma_addr:\tDMA address\n * @xfer_len:\ttransfer data length\n *\n * This utility function sends an inquiry to the adapter.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_ioafp_inquiry(struct ipr_cmnd *ipr_cmd, u8 flags, u8 page,\n\t\t\t      dma_addr_t dma_addr, u8 xfer_len)\n{\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\n\tENTER;\n\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_SCSICDB;\n\tioarcb->res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\n\tioarcb->cmd_pkt.cdb[0] = INQUIRY;\n\tioarcb->cmd_pkt.cdb[1] = flags;\n\tioarcb->cmd_pkt.cdb[2] = page;\n\tioarcb->cmd_pkt.cdb[4] = xfer_len;\n\n\tipr_init_ioadl(ipr_cmd, dma_addr, xfer_len, IPR_IOADL_FLAGS_READ_LAST);\n\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, IPR_INTERNAL_TIMEOUT);\n\tLEAVE;\n}\n\n/**\n * ipr_inquiry_page_supported - Is the given inquiry page supported\n * @page0:\t\tinquiry page 0 buffer\n * @page:\t\tpage code.\n *\n * This function determines if the specified inquiry page is supported.\n *\n * Return value:\n *\t1 if page is supported / 0 if not\n **/\nstatic int ipr_inquiry_page_supported(struct ipr_inquiry_page0 *page0, u8 page)\n{\n\tint i;\n\n\tfor (i = 0; i < min_t(u8, page0->len, IPR_INQUIRY_PAGE0_ENTRIES); i++)\n\t\tif (page0->page[i] == page)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * ipr_ioafp_pageC4_inquiry - Send a Page 0xC4 Inquiry to the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a Page 0xC4 inquiry to the adapter\n * to retrieve software VPD information.\n *\n * Return value:\n *\tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_pageC4_inquiry(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_inquiry_page0 *page0 = &ioa_cfg->vpd_cbs->page0_data;\n\tstruct ipr_inquiry_pageC4 *pageC4 = &ioa_cfg->vpd_cbs->pageC4_data;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_ioafp_set_caching_parameters;\n\tmemset(pageC4, 0, sizeof(*pageC4));\n\n\tif (ipr_inquiry_page_supported(page0, 0xC4)) {\n\t\tipr_ioafp_inquiry(ipr_cmd, 1, 0xC4,\n\t\t\t\t  (ioa_cfg->vpd_cbs_dma\n\t\t\t\t   + offsetof(struct ipr_misc_cbs,\n\t\t\t\t\t      pageC4_data)),\n\t\t\t\t  sizeof(struct ipr_inquiry_pageC4));\n\t\treturn IPR_RC_JOB_RETURN;\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_ioafp_cap_inquiry - Send a Page 0xD0 Inquiry to the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a Page 0xD0 inquiry to the adapter\n * to retrieve adapter capabilities.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_cap_inquiry(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_inquiry_page0 *page0 = &ioa_cfg->vpd_cbs->page0_data;\n\tstruct ipr_inquiry_cap *cap = &ioa_cfg->vpd_cbs->cap;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_ioafp_pageC4_inquiry;\n\tmemset(cap, 0, sizeof(*cap));\n\n\tif (ipr_inquiry_page_supported(page0, 0xD0)) {\n\t\tipr_ioafp_inquiry(ipr_cmd, 1, 0xD0,\n\t\t\t\t  ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, cap),\n\t\t\t\t  sizeof(struct ipr_inquiry_cap));\n\t\treturn IPR_RC_JOB_RETURN;\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_ioafp_page3_inquiry - Send a Page 3 Inquiry to the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a Page 3 inquiry to the adapter\n * to retrieve software VPD information.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_page3_inquiry(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\n\tipr_cmd->job_step = ipr_ioafp_cap_inquiry;\n\n\tipr_ioafp_inquiry(ipr_cmd, 1, 3,\n\t\t\t  ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, page3_data),\n\t\t\t  sizeof(struct ipr_inquiry_page3));\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_ioafp_page0_inquiry - Send a Page 0 Inquiry to the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a Page 0 inquiry to the adapter\n * to retrieve supported inquiry pages.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_page0_inquiry(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tchar type[5];\n\n\tENTER;\n\n\t/* Grab the type out of the VPD and store it away */\n\tmemcpy(type, ioa_cfg->vpd_cbs->ioa_vpd.std_inq_data.vpids.product_id, 4);\n\ttype[4] = '\\0';\n\tioa_cfg->type = simple_strtoul((char *)type, NULL, 16);\n\n\tif (ipr_invalid_adapter(ioa_cfg)) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"Adapter not supported in this hardware configuration.\\n\");\n\n\t\tif (!ipr_testmode) {\n\t\t\tioa_cfg->reset_retries += IPR_NUM_RESET_RELOAD_RETRIES;\n\t\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t\t\tlist_add_tail(&ipr_cmd->queue,\n\t\t\t\t\t&ioa_cfg->hrrq->hrrq_free_q);\n\t\t\treturn IPR_RC_JOB_RETURN;\n\t\t}\n\t}\n\n\tipr_cmd->job_step = ipr_ioafp_page3_inquiry;\n\n\tipr_ioafp_inquiry(ipr_cmd, 1, 0,\n\t\t\t  ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, page0_data),\n\t\t\t  sizeof(struct ipr_inquiry_page0));\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_ioafp_std_inquiry - Send a Standard Inquiry to the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * This function sends a standard inquiry to the adapter.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_std_inquiry(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_ioafp_page0_inquiry;\n\n\tipr_ioafp_inquiry(ipr_cmd, 0, 0,\n\t\t\t  ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, ioa_vpd),\n\t\t\t  sizeof(struct ipr_ioa_vpd));\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_ioafp_identify_hrrq - Send Identify Host RRQ.\n * @ipr_cmd:\tipr command struct\n *\n * This function send an Identify Host Request Response Queue\n * command to establish the HRRQ with the adapter.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_ioafp_identify_hrrq(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_ioarcb *ioarcb = &ipr_cmd->ioarcb;\n\tstruct ipr_hrr_queue *hrrq;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_ioafp_std_inquiry;\n\tif (ioa_cfg->identify_hrrq_index == 0)\n\t\tdev_info(&ioa_cfg->pdev->dev, \"Starting IOA initialization sequence.\\n\");\n\n\tif (ioa_cfg->identify_hrrq_index < ioa_cfg->hrrq_num) {\n\t\thrrq = &ioa_cfg->hrrq[ioa_cfg->identify_hrrq_index];\n\n\t\tioarcb->cmd_pkt.cdb[0] = IPR_ID_HOST_RR_Q;\n\t\tioarcb->res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\n\t\tioarcb->cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\t\tif (ioa_cfg->sis64)\n\t\t\tioarcb->cmd_pkt.cdb[1] = 0x1;\n\n\t\tif (ioa_cfg->nvectors == 1)\n\t\t\tioarcb->cmd_pkt.cdb[1] &= ~IPR_ID_HRRQ_SELE_ENABLE;\n\t\telse\n\t\t\tioarcb->cmd_pkt.cdb[1] |= IPR_ID_HRRQ_SELE_ENABLE;\n\n\t\tioarcb->cmd_pkt.cdb[2] =\n\t\t\t((u64) hrrq->host_rrq_dma >> 24) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[3] =\n\t\t\t((u64) hrrq->host_rrq_dma >> 16) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[4] =\n\t\t\t((u64) hrrq->host_rrq_dma >> 8) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[5] =\n\t\t\t((u64) hrrq->host_rrq_dma) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[7] =\n\t\t\t((sizeof(u32) * hrrq->size) >> 8) & 0xff;\n\t\tioarcb->cmd_pkt.cdb[8] =\n\t\t\t(sizeof(u32) * hrrq->size) & 0xff;\n\n\t\tif (ioarcb->cmd_pkt.cdb[1] & IPR_ID_HRRQ_SELE_ENABLE)\n\t\t\tioarcb->cmd_pkt.cdb[9] =\n\t\t\t\t\tioa_cfg->identify_hrrq_index;\n\n\t\tif (ioa_cfg->sis64) {\n\t\t\tioarcb->cmd_pkt.cdb[10] =\n\t\t\t\t((u64) hrrq->host_rrq_dma >> 56) & 0xff;\n\t\t\tioarcb->cmd_pkt.cdb[11] =\n\t\t\t\t((u64) hrrq->host_rrq_dma >> 48) & 0xff;\n\t\t\tioarcb->cmd_pkt.cdb[12] =\n\t\t\t\t((u64) hrrq->host_rrq_dma >> 40) & 0xff;\n\t\t\tioarcb->cmd_pkt.cdb[13] =\n\t\t\t\t((u64) hrrq->host_rrq_dma >> 32) & 0xff;\n\t\t}\n\n\t\tif (ioarcb->cmd_pkt.cdb[1] & IPR_ID_HRRQ_SELE_ENABLE)\n\t\t\tioarcb->cmd_pkt.cdb[14] =\n\t\t\t\t\tioa_cfg->identify_hrrq_index;\n\n\t\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout,\n\t\t\t   IPR_INTERNAL_TIMEOUT);\n\n\t\tif (++ioa_cfg->identify_hrrq_index < ioa_cfg->hrrq_num)\n\t\t\tipr_cmd->job_step = ipr_ioafp_identify_hrrq;\n\n\t\tLEAVE;\n\t\treturn IPR_RC_JOB_RETURN;\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_reset_timer_done - Adapter reset timer function\n * @t: Timer context used to fetch ipr command struct\n *\n * Description: This function is used in adapter reset processing\n * for timing events. If the reset_cmd pointer in the IOA\n * config struct is not this adapter's we are doing nested\n * resets and fail_all_ops will take care of freeing the\n * command block.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_reset_timer_done(struct timer_list *t)\n{\n\tstruct ipr_cmnd *ipr_cmd = from_timer(ipr_cmd, t, timer);\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tunsigned long lock_flags = 0;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (ioa_cfg->reset_cmd == ipr_cmd) {\n\t\tlist_del(&ipr_cmd->queue);\n\t\tipr_cmd->done(ipr_cmd);\n\t}\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n}\n\n/**\n * ipr_reset_start_timer - Start a timer for adapter reset job\n * @ipr_cmd:\tipr command struct\n * @timeout:\ttimeout value\n *\n * Description: This function is used in adapter reset processing\n * for timing events. If the reset_cmd pointer in the IOA\n * config struct is not this adapter's we are doing nested\n * resets and fail_all_ops will take care of freeing the\n * command block.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_reset_start_timer(struct ipr_cmnd *ipr_cmd,\n\t\t\t\t  unsigned long timeout)\n{\n\n\tENTER;\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\tipr_cmd->done = ipr_reset_ioa_job;\n\n\tipr_cmd->timer.expires = jiffies + timeout;\n\tipr_cmd->timer.function = ipr_reset_timer_done;\n\tadd_timer(&ipr_cmd->timer);\n}\n\n/**\n * ipr_init_ioa_mem - Initialize ioa_cfg control block\n * @ioa_cfg:\tioa cfg struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_init_ioa_mem(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct ipr_hrr_queue *hrrq;\n\n\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\tspin_lock(&hrrq->_lock);\n\t\tmemset(hrrq->host_rrq, 0, sizeof(u32) * hrrq->size);\n\n\t\t/* Initialize Host RRQ pointers */\n\t\thrrq->hrrq_start = hrrq->host_rrq;\n\t\thrrq->hrrq_end = &hrrq->host_rrq[hrrq->size - 1];\n\t\thrrq->hrrq_curr = hrrq->hrrq_start;\n\t\thrrq->toggle_bit = 1;\n\t\tspin_unlock(&hrrq->_lock);\n\t}\n\twmb();\n\n\tioa_cfg->identify_hrrq_index = 0;\n\tif (ioa_cfg->hrrq_num == 1)\n\t\tatomic_set(&ioa_cfg->hrrq_index, 0);\n\telse\n\t\tatomic_set(&ioa_cfg->hrrq_index, 1);\n\n\t/* Zero out config table */\n\tmemset(ioa_cfg->u.cfg_table, 0, ioa_cfg->cfg_table_size);\n}\n\n/**\n * ipr_reset_next_stage - Process IPL stage change based on feedback register.\n * @ipr_cmd:\tipr command struct\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_next_stage(struct ipr_cmnd *ipr_cmd)\n{\n\tunsigned long stage, stage_time;\n\tu32 feedback;\n\tvolatile u32 int_reg;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tu64 maskval = 0;\n\n\tfeedback = readl(ioa_cfg->regs.init_feedback_reg);\n\tstage = feedback & IPR_IPL_INIT_STAGE_MASK;\n\tstage_time = feedback & IPR_IPL_INIT_STAGE_TIME_MASK;\n\n\tipr_dbg(\"IPL stage = 0x%lx, IPL stage time = %ld\\n\", stage, stage_time);\n\n\t/* sanity check the stage_time value */\n\tif (stage_time == 0)\n\t\tstage_time = IPR_IPL_INIT_DEFAULT_STAGE_TIME;\n\telse if (stage_time < IPR_IPL_INIT_MIN_STAGE_TIME)\n\t\tstage_time = IPR_IPL_INIT_MIN_STAGE_TIME;\n\telse if (stage_time > IPR_LONG_OPERATIONAL_TIMEOUT)\n\t\tstage_time = IPR_LONG_OPERATIONAL_TIMEOUT;\n\n\tif (stage == IPR_IPL_INIT_STAGE_UNKNOWN) {\n\t\twritel(IPR_PCII_IPL_STAGE_CHANGE, ioa_cfg->regs.set_interrupt_mask_reg);\n\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);\n\t\tstage_time = ioa_cfg->transop_timeout;\n\t\tipr_cmd->job_step = ipr_ioafp_identify_hrrq;\n\t} else if (stage == IPR_IPL_INIT_STAGE_TRANSOP) {\n\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg32);\n\t\tif (int_reg & IPR_PCII_IOA_TRANS_TO_OPER) {\n\t\t\tipr_cmd->job_step = ipr_ioafp_identify_hrrq;\n\t\t\tmaskval = IPR_PCII_IPL_STAGE_CHANGE;\n\t\t\tmaskval = (maskval << 32) | IPR_PCII_IOA_TRANS_TO_OPER;\n\t\t\twriteq(maskval, ioa_cfg->regs.set_interrupt_mask_reg);\n\t\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);\n\t\t\treturn IPR_RC_JOB_CONTINUE;\n\t\t}\n\t}\n\n\tipr_cmd->timer.expires = jiffies + stage_time * HZ;\n\tipr_cmd->timer.function = ipr_oper_timeout;\n\tipr_cmd->done = ipr_reset_ioa_job;\n\tadd_timer(&ipr_cmd->timer);\n\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_enable_ioa - Enable the IOA following a reset.\n * @ipr_cmd:\tipr command struct\n *\n * This function reinitializes some control blocks and\n * enables destructive diagnostics on the adapter.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_enable_ioa(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tvolatile u32 int_reg;\n\tvolatile u64 maskval;\n\tint i;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_ioafp_identify_hrrq;\n\tipr_init_ioa_mem(ioa_cfg);\n\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\tioa_cfg->hrrq[i].allow_interrupts = 1;\n\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t}\n\tif (ioa_cfg->sis64) {\n\t\t/* Set the adapter to the correct endian mode. */\n\t\twritel(IPR_ENDIAN_SWAP_KEY, ioa_cfg->regs.endian_swap_reg);\n\t\tint_reg = readl(ioa_cfg->regs.endian_swap_reg);\n\t}\n\n\tint_reg = readl(ioa_cfg->regs.sense_interrupt_reg32);\n\n\tif (int_reg & IPR_PCII_IOA_TRANS_TO_OPER) {\n\t\twritel((IPR_PCII_ERROR_INTERRUPTS | IPR_PCII_HRRQ_UPDATED),\n\t\t       ioa_cfg->regs.clr_interrupt_mask_reg32);\n\t\tint_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);\n\t\treturn IPR_RC_JOB_CONTINUE;\n\t}\n\n\t/* Enable destructive diagnostics on IOA */\n\twritel(ioa_cfg->doorbell, ioa_cfg->regs.set_uproc_interrupt_reg32);\n\n\tif (ioa_cfg->sis64) {\n\t\tmaskval = IPR_PCII_IPL_STAGE_CHANGE;\n\t\tmaskval = (maskval << 32) | IPR_PCII_OPER_INTERRUPTS;\n\t\twriteq(maskval, ioa_cfg->regs.clr_interrupt_mask_reg);\n\t} else\n\t\twritel(IPR_PCII_OPER_INTERRUPTS, ioa_cfg->regs.clr_interrupt_mask_reg32);\n\n\tint_reg = readl(ioa_cfg->regs.sense_interrupt_mask_reg);\n\n\tdev_info(&ioa_cfg->pdev->dev, \"Initializing IOA.\\n\");\n\n\tif (ioa_cfg->sis64) {\n\t\tipr_cmd->job_step = ipr_reset_next_stage;\n\t\treturn IPR_RC_JOB_CONTINUE;\n\t}\n\n\tipr_cmd->timer.expires = jiffies + (ioa_cfg->transop_timeout * HZ);\n\tipr_cmd->timer.function = ipr_oper_timeout;\n\tipr_cmd->done = ipr_reset_ioa_job;\n\tadd_timer(&ipr_cmd->timer);\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_wait_for_dump - Wait for a dump to timeout.\n * @ipr_cmd:\tipr command struct\n *\n * This function is invoked when an adapter dump has run out\n * of processing time.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_reset_wait_for_dump(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tif (ioa_cfg->sdt_state == GET_DUMP)\n\t\tioa_cfg->sdt_state = WAIT_FOR_DUMP;\n\telse if (ioa_cfg->sdt_state == READ_DUMP)\n\t\tioa_cfg->sdt_state = ABORT_DUMP;\n\n\tioa_cfg->dump_timeout = 1;\n\tipr_cmd->job_step = ipr_reset_alert;\n\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_unit_check_no_data - Log a unit check/no data error log\n * @ioa_cfg:\t\tioa config struct\n *\n * Logs an error indicating the adapter unit checked, but for some\n * reason, we were unable to fetch the unit check buffer.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_unit_check_no_data(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tioa_cfg->errors_logged++;\n\tdev_err(&ioa_cfg->pdev->dev, \"IOA unit check with no data\\n\");\n}\n\n/**\n * ipr_get_unit_check_buffer - Get the unit check buffer from the IOA\n * @ioa_cfg:\t\tioa config struct\n *\n * Fetches the unit check buffer from the adapter by clocking the data\n * through the mailbox register.\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_get_unit_check_buffer(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tunsigned long mailbox;\n\tstruct ipr_hostrcb *hostrcb;\n\tstruct ipr_uc_sdt sdt;\n\tint rc, length;\n\tu32 ioasc;\n\n\tmailbox = readl(ioa_cfg->ioa_mailbox);\n\n\tif (!ioa_cfg->sis64 && !ipr_sdt_is_fmt2(mailbox)) {\n\t\tipr_unit_check_no_data(ioa_cfg);\n\t\treturn;\n\t}\n\n\tmemset(&sdt, 0, sizeof(struct ipr_uc_sdt));\n\trc = ipr_get_ldump_data_section(ioa_cfg, mailbox, (__be32 *) &sdt,\n\t\t\t\t\t(sizeof(struct ipr_uc_sdt)) / sizeof(__be32));\n\n\tif (rc || !(sdt.entry[0].flags & IPR_SDT_VALID_ENTRY) ||\n\t    ((be32_to_cpu(sdt.hdr.state) != IPR_FMT3_SDT_READY_TO_USE) &&\n\t    (be32_to_cpu(sdt.hdr.state) != IPR_FMT2_SDT_READY_TO_USE))) {\n\t\tipr_unit_check_no_data(ioa_cfg);\n\t\treturn;\n\t}\n\n\t/* Find length of the first sdt entry (UC buffer) */\n\tif (be32_to_cpu(sdt.hdr.state) == IPR_FMT3_SDT_READY_TO_USE)\n\t\tlength = be32_to_cpu(sdt.entry[0].end_token);\n\telse\n\t\tlength = (be32_to_cpu(sdt.entry[0].end_token) -\n\t\t\t  be32_to_cpu(sdt.entry[0].start_token)) &\n\t\t\t  IPR_FMT2_MBX_ADDR_MASK;\n\n\thostrcb = list_entry(ioa_cfg->hostrcb_free_q.next,\n\t\t\t     struct ipr_hostrcb, queue);\n\tlist_del_init(&hostrcb->queue);\n\tmemset(&hostrcb->hcam, 0, sizeof(hostrcb->hcam));\n\n\trc = ipr_get_ldump_data_section(ioa_cfg,\n\t\t\t\t\tbe32_to_cpu(sdt.entry[0].start_token),\n\t\t\t\t\t(__be32 *)&hostrcb->hcam,\n\t\t\t\t\tmin(length, (int)sizeof(hostrcb->hcam)) / sizeof(__be32));\n\n\tif (!rc) {\n\t\tipr_handle_log_data(ioa_cfg, hostrcb);\n\t\tioasc = be32_to_cpu(hostrcb->hcam.u.error.fd_ioasc);\n\t\tif (ioasc == IPR_IOASC_NR_IOA_RESET_REQUIRED &&\n\t\t    ioa_cfg->sdt_state == GET_DUMP)\n\t\t\tioa_cfg->sdt_state = WAIT_FOR_DUMP;\n\t} else\n\t\tipr_unit_check_no_data(ioa_cfg);\n\n\tlist_add_tail(&hostrcb->queue, &ioa_cfg->hostrcb_free_q);\n}\n\n/**\n * ipr_reset_get_unit_check_job - Call to get the unit check buffer.\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function will call to get the unit check buffer.\n *\n * Return value:\n *\tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_get_unit_check_job(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tioa_cfg->ioa_unit_checked = 0;\n\tipr_get_unit_check_buffer(ioa_cfg);\n\tipr_cmd->job_step = ipr_reset_alert;\n\tipr_reset_start_timer(ipr_cmd, 0);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\nstatic int ipr_dump_mailbox_wait(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\n\tif (ioa_cfg->sdt_state != GET_DUMP)\n\t\treturn IPR_RC_JOB_RETURN;\n\n\tif (!ioa_cfg->sis64 || !ipr_cmd->u.time_left ||\n\t    (readl(ioa_cfg->regs.sense_interrupt_reg) &\n\t     IPR_PCII_MAILBOX_STABLE)) {\n\n\t\tif (!ipr_cmd->u.time_left)\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"Timed out waiting for Mailbox register.\\n\");\n\n\t\tioa_cfg->sdt_state = READ_DUMP;\n\t\tioa_cfg->dump_timeout = 0;\n\t\tif (ioa_cfg->sis64)\n\t\t\tipr_reset_start_timer(ipr_cmd, IPR_SIS64_DUMP_TIMEOUT);\n\t\telse\n\t\t\tipr_reset_start_timer(ipr_cmd, IPR_SIS32_DUMP_TIMEOUT);\n\t\tipr_cmd->job_step = ipr_reset_wait_for_dump;\n\t\tschedule_work(&ioa_cfg->work_q);\n\n\t} else {\n\t\tipr_cmd->u.time_left -= IPR_CHECK_FOR_RESET_TIMEOUT;\n\t\tipr_reset_start_timer(ipr_cmd,\n\t\t\t\t      IPR_CHECK_FOR_RESET_TIMEOUT);\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_restore_cfg_space - Restore PCI config space.\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function restores the saved PCI config space of\n * the adapter, fails all outstanding ops back to the callers, and\n * fetches the dump/unit check if applicable to this reset.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_restore_cfg_space(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tioa_cfg->pdev->state_saved = true;\n\tpci_restore_state(ioa_cfg->pdev);\n\n\tif (ipr_set_pcix_cmd_reg(ioa_cfg)) {\n\t\tipr_cmd->s.ioasa.hdr.ioasc = cpu_to_be32(IPR_IOASC_PCI_ACCESS_ERROR);\n\t\treturn IPR_RC_JOB_CONTINUE;\n\t}\n\n\tipr_fail_all_ops(ioa_cfg);\n\n\tif (ioa_cfg->sis64) {\n\t\t/* Set the adapter to the correct endian mode. */\n\t\twritel(IPR_ENDIAN_SWAP_KEY, ioa_cfg->regs.endian_swap_reg);\n\t\treadl(ioa_cfg->regs.endian_swap_reg);\n\t}\n\n\tif (ioa_cfg->ioa_unit_checked) {\n\t\tif (ioa_cfg->sis64) {\n\t\t\tipr_cmd->job_step = ipr_reset_get_unit_check_job;\n\t\t\tipr_reset_start_timer(ipr_cmd, IPR_DUMP_DELAY_TIMEOUT);\n\t\t\treturn IPR_RC_JOB_RETURN;\n\t\t} else {\n\t\t\tioa_cfg->ioa_unit_checked = 0;\n\t\t\tipr_get_unit_check_buffer(ioa_cfg);\n\t\t\tipr_cmd->job_step = ipr_reset_alert;\n\t\t\tipr_reset_start_timer(ipr_cmd, 0);\n\t\t\treturn IPR_RC_JOB_RETURN;\n\t\t}\n\t}\n\n\tif (ioa_cfg->in_ioa_bringdown) {\n\t\tipr_cmd->job_step = ipr_ioa_bringdown_done;\n\t} else if (ioa_cfg->sdt_state == GET_DUMP) {\n\t\tipr_cmd->job_step = ipr_dump_mailbox_wait;\n\t\tipr_cmd->u.time_left = IPR_WAIT_FOR_MAILBOX;\n\t} else {\n\t\tipr_cmd->job_step = ipr_reset_enable_ioa;\n\t}\n\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_reset_bist_done - BIST has completed on the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * Description: Unblock config space and resume the reset process.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_reset_bist_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tif (ioa_cfg->cfg_locked)\n\t\tpci_cfg_access_unlock(ioa_cfg->pdev);\n\tioa_cfg->cfg_locked = 0;\n\tipr_cmd->job_step = ipr_reset_restore_cfg_space;\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_reset_start_bist - Run BIST on the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function runs BIST on the adapter, then delays 2 seconds.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_start_bist(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tint rc = PCIBIOS_SUCCESSFUL;\n\n\tENTER;\n\tif (ioa_cfg->ipr_chip->bist_method == IPR_MMIO)\n\t\twritel(IPR_UPROCI_SIS64_START_BIST,\n\t\t       ioa_cfg->regs.set_uproc_interrupt_reg32);\n\telse\n\t\trc = pci_write_config_byte(ioa_cfg->pdev, PCI_BIST, PCI_BIST_START);\n\n\tif (rc == PCIBIOS_SUCCESSFUL) {\n\t\tipr_cmd->job_step = ipr_reset_bist_done;\n\t\tipr_reset_start_timer(ipr_cmd, IPR_WAIT_FOR_BIST_TIMEOUT);\n\t\trc = IPR_RC_JOB_RETURN;\n\t} else {\n\t\tif (ioa_cfg->cfg_locked)\n\t\t\tpci_cfg_access_unlock(ipr_cmd->ioa_cfg->pdev);\n\t\tioa_cfg->cfg_locked = 0;\n\t\tipr_cmd->s.ioasa.hdr.ioasc = cpu_to_be32(IPR_IOASC_PCI_ACCESS_ERROR);\n\t\trc = IPR_RC_JOB_CONTINUE;\n\t}\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_reset_slot_reset_done - Clear PCI reset to the adapter\n * @ipr_cmd:\tipr command struct\n *\n * Description: This clears PCI reset to the adapter and delays two seconds.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_slot_reset_done(struct ipr_cmnd *ipr_cmd)\n{\n\tENTER;\n\tipr_cmd->job_step = ipr_reset_bist_done;\n\tipr_reset_start_timer(ipr_cmd, IPR_WAIT_FOR_BIST_TIMEOUT);\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_reset_work - Pulse a PCIe fundamental reset\n * @work:\twork struct\n *\n * Description: This pulses warm reset to a slot.\n *\n **/\nstatic void ipr_reset_reset_work(struct work_struct *work)\n{\n\tstruct ipr_cmnd *ipr_cmd = container_of(work, struct ipr_cmnd, work);\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct pci_dev *pdev = ioa_cfg->pdev;\n\tunsigned long lock_flags = 0;\n\n\tENTER;\n\tpci_set_pcie_reset_state(pdev, pcie_warm_reset);\n\tmsleep(jiffies_to_msecs(IPR_PCI_RESET_TIMEOUT));\n\tpci_set_pcie_reset_state(pdev, pcie_deassert_reset);\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (ioa_cfg->reset_cmd == ipr_cmd)\n\t\tipr_reset_ioa_job(ipr_cmd);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\tLEAVE;\n}\n\n/**\n * ipr_reset_slot_reset - Reset the PCI slot of the adapter.\n * @ipr_cmd:\tipr command struct\n *\n * Description: This asserts PCI reset to the adapter.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_slot_reset(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tINIT_WORK(&ipr_cmd->work, ipr_reset_reset_work);\n\tqueue_work(ioa_cfg->reset_work_q, &ipr_cmd->work);\n\tipr_cmd->job_step = ipr_reset_slot_reset_done;\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_block_config_access_wait - Wait for permission to block config access\n * @ipr_cmd:\tipr command struct\n *\n * Description: This attempts to block config access to the IOA.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_block_config_access_wait(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tint rc = IPR_RC_JOB_CONTINUE;\n\n\tif (pci_cfg_access_trylock(ioa_cfg->pdev)) {\n\t\tioa_cfg->cfg_locked = 1;\n\t\tipr_cmd->job_step = ioa_cfg->reset;\n\t} else {\n\t\tif (ipr_cmd->u.time_left) {\n\t\t\trc = IPR_RC_JOB_RETURN;\n\t\t\tipr_cmd->u.time_left -= IPR_CHECK_FOR_RESET_TIMEOUT;\n\t\t\tipr_reset_start_timer(ipr_cmd,\n\t\t\t\t\t      IPR_CHECK_FOR_RESET_TIMEOUT);\n\t\t} else {\n\t\t\tipr_cmd->job_step = ioa_cfg->reset;\n\t\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\t\"Timed out waiting to lock config access. Resetting anyway.\\n\");\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/**\n * ipr_reset_block_config_access - Block config access to the IOA\n * @ipr_cmd:\tipr command struct\n *\n * Description: This attempts to block config access to the IOA\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_reset_block_config_access(struct ipr_cmnd *ipr_cmd)\n{\n\tipr_cmd->ioa_cfg->cfg_locked = 0;\n\tipr_cmd->job_step = ipr_reset_block_config_access_wait;\n\tipr_cmd->u.time_left = IPR_WAIT_FOR_RESET_TIMEOUT;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_reset_allowed - Query whether or not IOA can be reset\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \t0 if reset not allowed / non-zero if reset is allowed\n **/\nstatic int ipr_reset_allowed(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tvolatile u32 temp_reg;\n\n\ttemp_reg = readl(ioa_cfg->regs.sense_interrupt_reg);\n\treturn ((temp_reg & IPR_PCII_CRITICAL_OPERATION) == 0);\n}\n\n/**\n * ipr_reset_wait_to_start_bist - Wait for permission to reset IOA.\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function waits for adapter permission to run BIST,\n * then runs BIST. If the adapter does not give permission after a\n * reasonable time, we will reset the adapter anyway. The impact of\n * resetting the adapter without warning the adapter is the risk of\n * losing the persistent error log on the adapter. If the adapter is\n * reset while it is writing to the flash on the adapter, the flash\n * segment will have bad ECC and be zeroed.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_wait_to_start_bist(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tint rc = IPR_RC_JOB_RETURN;\n\n\tif (!ipr_reset_allowed(ioa_cfg) && ipr_cmd->u.time_left) {\n\t\tipr_cmd->u.time_left -= IPR_CHECK_FOR_RESET_TIMEOUT;\n\t\tipr_reset_start_timer(ipr_cmd, IPR_CHECK_FOR_RESET_TIMEOUT);\n\t} else {\n\t\tipr_cmd->job_step = ipr_reset_block_config_access;\n\t\trc = IPR_RC_JOB_CONTINUE;\n\t}\n\n\treturn rc;\n}\n\n/**\n * ipr_reset_alert - Alert the adapter of a pending reset\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function alerts the adapter that it will be reset.\n * If memory space is not currently enabled, proceed directly\n * to running BIST on the adapter. The timer must always be started\n * so we guarantee we do not run BIST from ipr_isr.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_alert(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tu16 cmd_reg;\n\tint rc;\n\n\tENTER;\n\trc = pci_read_config_word(ioa_cfg->pdev, PCI_COMMAND, &cmd_reg);\n\n\tif ((rc == PCIBIOS_SUCCESSFUL) && (cmd_reg & PCI_COMMAND_MEMORY)) {\n\t\tipr_mask_and_clear_interrupts(ioa_cfg, ~0);\n\t\twritel(IPR_UPROCI_RESET_ALERT, ioa_cfg->regs.set_uproc_interrupt_reg32);\n\t\tipr_cmd->job_step = ipr_reset_wait_to_start_bist;\n\t} else {\n\t\tipr_cmd->job_step = ipr_reset_block_config_access;\n\t}\n\n\tipr_cmd->u.time_left = IPR_WAIT_FOR_RESET_TIMEOUT;\n\tipr_reset_start_timer(ipr_cmd, IPR_CHECK_FOR_RESET_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_quiesce_done - Complete IOA disconnect\n * @ipr_cmd:\tipr command struct\n *\n * Description: Freeze the adapter to complete quiesce processing\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_reset_quiesce_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_ioa_bringdown_done;\n\tipr_mask_and_clear_interrupts(ioa_cfg, ~IPR_PCII_IOA_TRANS_TO_OPER);\n\tLEAVE;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_reset_cancel_hcam_done - Check for outstanding commands\n * @ipr_cmd:\tipr command struct\n *\n * Description: Ensure nothing is outstanding to the IOA and\n *\t\t\tproceed with IOA disconnect. Otherwise reset the IOA.\n *\n * Return value:\n * \tIPR_RC_JOB_RETURN / IPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_reset_cancel_hcam_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_cmnd *loop_cmd;\n\tstruct ipr_hrr_queue *hrrq;\n\tint rc = IPR_RC_JOB_CONTINUE;\n\tint count = 0;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_reset_quiesce_done;\n\n\tfor_each_hrrq(hrrq, ioa_cfg) {\n\t\tspin_lock(&hrrq->_lock);\n\t\tlist_for_each_entry(loop_cmd, &hrrq->hrrq_pending_q, queue) {\n\t\t\tcount++;\n\t\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t\t\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\t\t\trc = IPR_RC_JOB_RETURN;\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&hrrq->_lock);\n\n\t\tif (count)\n\t\t\tbreak;\n\t}\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_reset_cancel_hcam - Cancel outstanding HCAMs\n * @ipr_cmd:\tipr command struct\n *\n * Description: Cancel any oustanding HCAMs to the IOA.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_cancel_hcam(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tint rc = IPR_RC_JOB_CONTINUE;\n\tstruct ipr_cmd_pkt *cmd_pkt;\n\tstruct ipr_cmnd *hcam_cmd;\n\tstruct ipr_hrr_queue *hrrq = &ioa_cfg->hrrq[IPR_INIT_HRRQ];\n\n\tENTER;\n\tipr_cmd->job_step = ipr_reset_cancel_hcam_done;\n\n\tif (!hrrq->ioa_is_dead) {\n\t\tif (!list_empty(&ioa_cfg->hostrcb_pending_q)) {\n\t\t\tlist_for_each_entry(hcam_cmd, &hrrq->hrrq_pending_q, queue) {\n\t\t\t\tif (hcam_cmd->ioarcb.cmd_pkt.cdb[0] != IPR_HOST_CONTROLLED_ASYNC)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tipr_cmd->ioarcb.res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\t\t\t\tipr_cmd->ioarcb.cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\t\t\t\tcmd_pkt = &ipr_cmd->ioarcb.cmd_pkt;\n\t\t\t\tcmd_pkt->request_type = IPR_RQTYPE_IOACMD;\n\t\t\t\tcmd_pkt->cdb[0] = IPR_CANCEL_REQUEST;\n\t\t\t\tcmd_pkt->cdb[1] = IPR_CANCEL_64BIT_IOARCB;\n\t\t\t\tcmd_pkt->cdb[10] = ((u64) hcam_cmd->dma_addr >> 56) & 0xff;\n\t\t\t\tcmd_pkt->cdb[11] = ((u64) hcam_cmd->dma_addr >> 48) & 0xff;\n\t\t\t\tcmd_pkt->cdb[12] = ((u64) hcam_cmd->dma_addr >> 40) & 0xff;\n\t\t\t\tcmd_pkt->cdb[13] = ((u64) hcam_cmd->dma_addr >> 32) & 0xff;\n\t\t\t\tcmd_pkt->cdb[2] = ((u64) hcam_cmd->dma_addr >> 24) & 0xff;\n\t\t\t\tcmd_pkt->cdb[3] = ((u64) hcam_cmd->dma_addr >> 16) & 0xff;\n\t\t\t\tcmd_pkt->cdb[4] = ((u64) hcam_cmd->dma_addr >> 8) & 0xff;\n\t\t\t\tcmd_pkt->cdb[5] = ((u64) hcam_cmd->dma_addr) & 0xff;\n\n\t\t\t\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout,\n\t\t\t\t\t   IPR_CANCEL_TIMEOUT);\n\n\t\t\t\trc = IPR_RC_JOB_RETURN;\n\t\t\t\tipr_cmd->job_step = ipr_reset_cancel_hcam;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else\n\t\tipr_cmd->job_step = ipr_reset_alert;\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_reset_ucode_download_done - Microcode download completion\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function unmaps the microcode download buffer.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE\n **/\nstatic int ipr_reset_ucode_download_done(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_sglist *sglist = ioa_cfg->ucode_sglist;\n\n\tdma_unmap_sg(&ioa_cfg->pdev->dev, sglist->scatterlist,\n\t\t     sglist->num_sg, DMA_TO_DEVICE);\n\n\tipr_cmd->job_step = ipr_reset_alert;\n\treturn IPR_RC_JOB_CONTINUE;\n}\n\n/**\n * ipr_reset_ucode_download - Download microcode to the adapter\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function checks to see if it there is microcode\n * to download to the adapter. If there is, a download is performed.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_ucode_download(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tstruct ipr_sglist *sglist = ioa_cfg->ucode_sglist;\n\n\tENTER;\n\tipr_cmd->job_step = ipr_reset_alert;\n\n\tif (!sglist)\n\t\treturn IPR_RC_JOB_CONTINUE;\n\n\tipr_cmd->ioarcb.res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\tipr_cmd->ioarcb.cmd_pkt.request_type = IPR_RQTYPE_SCSICDB;\n\tipr_cmd->ioarcb.cmd_pkt.cdb[0] = WRITE_BUFFER;\n\tipr_cmd->ioarcb.cmd_pkt.cdb[1] = IPR_WR_BUF_DOWNLOAD_AND_SAVE;\n\tipr_cmd->ioarcb.cmd_pkt.cdb[6] = (sglist->buffer_len & 0xff0000) >> 16;\n\tipr_cmd->ioarcb.cmd_pkt.cdb[7] = (sglist->buffer_len & 0x00ff00) >> 8;\n\tipr_cmd->ioarcb.cmd_pkt.cdb[8] = sglist->buffer_len & 0x0000ff;\n\n\tif (ioa_cfg->sis64)\n\t\tipr_build_ucode_ioadl64(ipr_cmd, sglist);\n\telse\n\t\tipr_build_ucode_ioadl(ipr_cmd, sglist);\n\tipr_cmd->job_step = ipr_reset_ucode_download_done;\n\n\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout,\n\t\t   IPR_WRITE_BUFFER_TIMEOUT);\n\n\tLEAVE;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_reset_shutdown_ioa - Shutdown the adapter\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function issues an adapter shutdown of the\n * specified type to the specified adapter as part of the\n * adapter reset job.\n *\n * Return value:\n * \tIPR_RC_JOB_CONTINUE / IPR_RC_JOB_RETURN\n **/\nstatic int ipr_reset_shutdown_ioa(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tenum ipr_shutdown_type shutdown_type = ipr_cmd->u.shutdown_type;\n\tunsigned long timeout;\n\tint rc = IPR_RC_JOB_CONTINUE;\n\n\tENTER;\n\tif (shutdown_type == IPR_SHUTDOWN_QUIESCE)\n\t\tipr_cmd->job_step = ipr_reset_cancel_hcam;\n\telse if (shutdown_type != IPR_SHUTDOWN_NONE &&\n\t\t\t!ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead) {\n\t\tipr_cmd->ioarcb.res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\t\tipr_cmd->ioarcb.cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\t\tipr_cmd->ioarcb.cmd_pkt.cdb[0] = IPR_IOA_SHUTDOWN;\n\t\tipr_cmd->ioarcb.cmd_pkt.cdb[1] = shutdown_type;\n\n\t\tif (shutdown_type == IPR_SHUTDOWN_NORMAL)\n\t\t\ttimeout = IPR_SHUTDOWN_TIMEOUT;\n\t\telse if (shutdown_type == IPR_SHUTDOWN_PREPARE_FOR_NORMAL)\n\t\t\ttimeout = IPR_INTERNAL_TIMEOUT;\n\t\telse if (ioa_cfg->dual_raid && ipr_dual_ioa_raid)\n\t\t\ttimeout = IPR_DUAL_IOA_ABBR_SHUTDOWN_TO;\n\t\telse\n\t\t\ttimeout = IPR_ABBREV_SHUTDOWN_TIMEOUT;\n\n\t\tipr_do_req(ipr_cmd, ipr_reset_ioa_job, ipr_timeout, timeout);\n\n\t\trc = IPR_RC_JOB_RETURN;\n\t\tipr_cmd->job_step = ipr_reset_ucode_download;\n\t} else\n\t\tipr_cmd->job_step = ipr_reset_alert;\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_reset_ioa_job - Adapter reset job\n * @ipr_cmd:\tipr command struct\n *\n * Description: This function is the job router for the adapter reset job.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_reset_ioa_job(struct ipr_cmnd *ipr_cmd)\n{\n\tu32 rc, ioasc;\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\n\tdo {\n\t\tioasc = be32_to_cpu(ipr_cmd->s.ioasa.hdr.ioasc);\n\n\t\tif (ioa_cfg->reset_cmd != ipr_cmd) {\n\t\t\t/*\n\t\t\t * We are doing nested adapter resets and this is\n\t\t\t * not the current reset job.\n\t\t\t */\n\t\t\tlist_add_tail(&ipr_cmd->queue,\n\t\t\t\t\t&ipr_cmd->hrrq->hrrq_free_q);\n\t\t\treturn;\n\t\t}\n\n\t\tif (IPR_IOASC_SENSE_KEY(ioasc)) {\n\t\t\trc = ipr_cmd->job_step_failed(ipr_cmd);\n\t\t\tif (rc == IPR_RC_JOB_RETURN)\n\t\t\t\treturn;\n\t\t}\n\n\t\tipr_reinit_ipr_cmnd(ipr_cmd);\n\t\tipr_cmd->job_step_failed = ipr_reset_cmd_failed;\n\t\trc = ipr_cmd->job_step(ipr_cmd);\n\t} while (rc == IPR_RC_JOB_CONTINUE);\n}\n\n/**\n * _ipr_initiate_ioa_reset - Initiate an adapter reset\n * @ioa_cfg:\t\tioa config struct\n * @job_step:\t\tfirst job step of reset job\n * @shutdown_type:\tshutdown type\n *\n * Description: This function will initiate the reset of the given adapter\n * starting at the selected job step.\n * If the caller needs to wait on the completion of the reset,\n * the caller must sleep on the reset_wait_q.\n *\n * Return value:\n * \tnone\n **/\nstatic void _ipr_initiate_ioa_reset(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t    int (*job_step) (struct ipr_cmnd *),\n\t\t\t\t    enum ipr_shutdown_type shutdown_type)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tint i;\n\n\tioa_cfg->in_reset_reload = 1;\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\tioa_cfg->hrrq[i].allow_cmds = 0;\n\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t}\n\twmb();\n\tif (!ioa_cfg->hrrq[IPR_INIT_HRRQ].removing_ioa) {\n\t\tioa_cfg->scsi_unblock = 0;\n\t\tioa_cfg->scsi_blocked = 1;\n\t\tscsi_block_requests(ioa_cfg->host);\n\t}\n\n\tipr_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);\n\tioa_cfg->reset_cmd = ipr_cmd;\n\tipr_cmd->job_step = job_step;\n\tipr_cmd->u.shutdown_type = shutdown_type;\n\n\tipr_reset_ioa_job(ipr_cmd);\n}\n\n/**\n * ipr_initiate_ioa_reset - Initiate an adapter reset\n * @ioa_cfg:\t\tioa config struct\n * @shutdown_type:\tshutdown type\n *\n * Description: This function will initiate the reset of the given adapter.\n * If the caller needs to wait on the completion of the reset,\n * the caller must sleep on the reset_wait_q.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_initiate_ioa_reset(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t   enum ipr_shutdown_type shutdown_type)\n{\n\tint i;\n\n\tif (ioa_cfg->hrrq[IPR_INIT_HRRQ].ioa_is_dead)\n\t\treturn;\n\n\tif (ioa_cfg->in_reset_reload) {\n\t\tif (ioa_cfg->sdt_state == GET_DUMP)\n\t\t\tioa_cfg->sdt_state = WAIT_FOR_DUMP;\n\t\telse if (ioa_cfg->sdt_state == READ_DUMP)\n\t\t\tioa_cfg->sdt_state = ABORT_DUMP;\n\t}\n\n\tif (ioa_cfg->reset_retries++ >= IPR_NUM_RESET_RELOAD_RETRIES) {\n\t\tdev_err(&ioa_cfg->pdev->dev,\n\t\t\t\"IOA taken offline - error recovery failed\\n\");\n\n\t\tioa_cfg->reset_retries = 0;\n\t\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\t\tioa_cfg->hrrq[i].ioa_is_dead = 1;\n\t\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t\t}\n\t\twmb();\n\n\t\tif (ioa_cfg->in_ioa_bringdown) {\n\t\t\tioa_cfg->reset_cmd = NULL;\n\t\t\tioa_cfg->in_reset_reload = 0;\n\t\t\tipr_fail_all_ops(ioa_cfg);\n\t\t\twake_up_all(&ioa_cfg->reset_wait_q);\n\n\t\t\tif (!ioa_cfg->hrrq[IPR_INIT_HRRQ].removing_ioa) {\n\t\t\t\tioa_cfg->scsi_unblock = 1;\n\t\t\t\tschedule_work(&ioa_cfg->work_q);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tioa_cfg->in_ioa_bringdown = 1;\n\t\t\tshutdown_type = IPR_SHUTDOWN_NONE;\n\t\t}\n\t}\n\n\t_ipr_initiate_ioa_reset(ioa_cfg, ipr_reset_shutdown_ioa,\n\t\t\t\tshutdown_type);\n}\n\n/**\n * ipr_reset_freeze - Hold off all I/O activity\n * @ipr_cmd:\tipr command struct\n *\n * Description: If the PCI slot is frozen, hold off all I/O\n * activity; then, as soon as the slot is available again,\n * initiate an adapter reset.\n */\nstatic int ipr_reset_freeze(struct ipr_cmnd *ipr_cmd)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;\n\tint i;\n\n\t/* Disallow new interrupts, avoid loop */\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\tioa_cfg->hrrq[i].allow_interrupts = 0;\n\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t}\n\twmb();\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_pending_q);\n\tipr_cmd->done = ipr_reset_ioa_job;\n\treturn IPR_RC_JOB_RETURN;\n}\n\n/**\n * ipr_pci_mmio_enabled - Called when MMIO has been re-enabled\n * @pdev:\tPCI device struct\n *\n * Description: This routine is called to tell us that the MMIO\n * access to the IOA has been restored\n */\nstatic pci_ers_result_t ipr_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tunsigned long flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\tif (!ioa_cfg->probe_done)\n\t\tpci_save_state(pdev);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * ipr_pci_frozen - Called when slot has experienced a PCI bus error.\n * @pdev:\tPCI device struct\n *\n * Description: This routine is called to tell us that the PCI bus\n * is down. Can't do anything here, except put the device driver\n * into a holding pattern, waiting for the PCI bus to come back.\n */\nstatic void ipr_pci_frozen(struct pci_dev *pdev)\n{\n\tunsigned long flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\tif (ioa_cfg->probe_done)\n\t\t_ipr_initiate_ioa_reset(ioa_cfg, ipr_reset_freeze, IPR_SHUTDOWN_NONE);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n}\n\n/**\n * ipr_pci_slot_reset - Called when PCI slot has been reset.\n * @pdev:\tPCI device struct\n *\n * Description: This routine is called by the pci error recovery\n * code after the PCI slot has been reset, just before we\n * should resume normal operations.\n */\nstatic pci_ers_result_t ipr_pci_slot_reset(struct pci_dev *pdev)\n{\n\tunsigned long flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\tif (ioa_cfg->probe_done) {\n\t\tif (ioa_cfg->needs_warm_reset)\n\t\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t\telse\n\t\t\t_ipr_initiate_ioa_reset(ioa_cfg, ipr_reset_restore_cfg_space,\n\t\t\t\t\t\tIPR_SHUTDOWN_NONE);\n\t} else\n\t\twake_up_all(&ioa_cfg->eeh_wait_q);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\n/**\n * ipr_pci_perm_failure - Called when PCI slot is dead for good.\n * @pdev:\tPCI device struct\n *\n * Description: This routine is called when the PCI bus has\n * permanently failed.\n */\nstatic void ipr_pci_perm_failure(struct pci_dev *pdev)\n{\n\tunsigned long flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\tint i;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\tif (ioa_cfg->probe_done) {\n\t\tif (ioa_cfg->sdt_state == WAIT_FOR_DUMP)\n\t\t\tioa_cfg->sdt_state = ABORT_DUMP;\n\t\tioa_cfg->reset_retries = IPR_NUM_RESET_RELOAD_RETRIES - 1;\n\t\tioa_cfg->in_ioa_bringdown = 1;\n\t\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\t\tioa_cfg->hrrq[i].allow_cmds = 0;\n\t\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t\t}\n\t\twmb();\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t} else\n\t\twake_up_all(&ioa_cfg->eeh_wait_q);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n}\n\n/**\n * ipr_pci_error_detected - Called when a PCI error is detected.\n * @pdev:\tPCI device struct\n * @state:\tPCI channel state\n *\n * Description: Called when a PCI error is detected.\n *\n * Return value:\n * \tPCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT\n */\nstatic pci_ers_result_t ipr_pci_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tswitch (state) {\n\tcase pci_channel_io_frozen:\n\t\tipr_pci_frozen(pdev);\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_perm_failure:\n\t\tipr_pci_perm_failure(pdev);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * ipr_probe_ioa_part2 - Initializes IOAs found in ipr_probe_ioa(..)\n * @ioa_cfg:\tioa cfg struct\n *\n * Description: This is the second phase of adapter initialization\n * This function takes care of initilizing the adapter to the point\n * where it can accept new commands.\n * Return value:\n * \t0 on success / -EIO on failure\n **/\nstatic int ipr_probe_ioa_part2(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint rc = 0;\n\tunsigned long host_lock_flags = 0;\n\n\tENTER;\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);\n\tdev_dbg(&ioa_cfg->pdev->dev, \"ioa_cfg adx: 0x%p\\n\", ioa_cfg);\n\tioa_cfg->probe_done = 1;\n\tif (ioa_cfg->needs_hard_reset) {\n\t\tioa_cfg->needs_hard_reset = 0;\n\t\tipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);\n\t} else\n\t\t_ipr_initiate_ioa_reset(ioa_cfg, ipr_reset_enable_ioa,\n\t\t\t\t\tIPR_SHUTDOWN_NONE);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);\n\n\tLEAVE;\n\treturn rc;\n}\n\n/**\n * ipr_free_cmd_blks - Frees command blocks allocated for an adapter\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_free_cmd_blks(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint i;\n\n\tif (ioa_cfg->ipr_cmnd_list) {\n\t\tfor (i = 0; i < IPR_NUM_CMD_BLKS; i++) {\n\t\t\tif (ioa_cfg->ipr_cmnd_list[i])\n\t\t\t\tdma_pool_free(ioa_cfg->ipr_cmd_pool,\n\t\t\t\t\t      ioa_cfg->ipr_cmnd_list[i],\n\t\t\t\t\t      ioa_cfg->ipr_cmnd_list_dma[i]);\n\n\t\t\tioa_cfg->ipr_cmnd_list[i] = NULL;\n\t\t}\n\t}\n\n\tdma_pool_destroy(ioa_cfg->ipr_cmd_pool);\n\n\tkfree(ioa_cfg->ipr_cmnd_list);\n\tkfree(ioa_cfg->ipr_cmnd_list_dma);\n\tioa_cfg->ipr_cmnd_list = NULL;\n\tioa_cfg->ipr_cmnd_list_dma = NULL;\n\tioa_cfg->ipr_cmd_pool = NULL;\n}\n\n/**\n * ipr_free_mem - Frees memory allocated for an adapter\n * @ioa_cfg:\tioa cfg struct\n *\n * Return value:\n * \tnothing\n **/\nstatic void ipr_free_mem(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint i;\n\n\tkfree(ioa_cfg->res_entries);\n\tdma_free_coherent(&ioa_cfg->pdev->dev, sizeof(struct ipr_misc_cbs),\n\t\t\t  ioa_cfg->vpd_cbs, ioa_cfg->vpd_cbs_dma);\n\tipr_free_cmd_blks(ioa_cfg);\n\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++)\n\t\tdma_free_coherent(&ioa_cfg->pdev->dev,\n\t\t\t\t  sizeof(u32) * ioa_cfg->hrrq[i].size,\n\t\t\t\t  ioa_cfg->hrrq[i].host_rrq,\n\t\t\t\t  ioa_cfg->hrrq[i].host_rrq_dma);\n\n\tdma_free_coherent(&ioa_cfg->pdev->dev, ioa_cfg->cfg_table_size,\n\t\t\t  ioa_cfg->u.cfg_table, ioa_cfg->cfg_table_dma);\n\n\tfor (i = 0; i < IPR_MAX_HCAMS; i++) {\n\t\tdma_free_coherent(&ioa_cfg->pdev->dev,\n\t\t\t\t  sizeof(struct ipr_hostrcb),\n\t\t\t\t  ioa_cfg->hostrcb[i],\n\t\t\t\t  ioa_cfg->hostrcb_dma[i]);\n\t}\n\n\tipr_free_dump(ioa_cfg);\n\tkfree(ioa_cfg->trace);\n}\n\n/**\n * ipr_free_irqs - Free all allocated IRQs for the adapter.\n * @ioa_cfg:\tipr cfg struct\n *\n * This function frees all allocated IRQs for the\n * specified adapter.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_free_irqs(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct pci_dev *pdev = ioa_cfg->pdev;\n\tint i;\n\n\tfor (i = 0; i < ioa_cfg->nvectors; i++)\n\t\tfree_irq(pci_irq_vector(pdev, i), &ioa_cfg->hrrq[i]);\n\tpci_free_irq_vectors(pdev);\n}\n\n/**\n * ipr_free_all_resources - Free all allocated resources for an adapter.\n * @ioa_cfg:\tioa config struct\n *\n * This function frees all allocated resources for the\n * specified adapter.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_free_all_resources(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct pci_dev *pdev = ioa_cfg->pdev;\n\n\tENTER;\n\tipr_free_irqs(ioa_cfg);\n\tif (ioa_cfg->reset_work_q)\n\t\tdestroy_workqueue(ioa_cfg->reset_work_q);\n\tiounmap(ioa_cfg->hdw_dma_regs);\n\tpci_release_regions(pdev);\n\tipr_free_mem(ioa_cfg);\n\tscsi_host_put(ioa_cfg->host);\n\tpci_disable_device(pdev);\n\tLEAVE;\n}\n\n/**\n * ipr_alloc_cmd_blks - Allocate command blocks for an adapter\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \t0 on success / -ENOMEM on allocation failure\n **/\nstatic int ipr_alloc_cmd_blks(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioarcb *ioarcb;\n\tdma_addr_t dma_addr;\n\tint i, entries_each_hrrq, hrrq_id = 0;\n\n\tioa_cfg->ipr_cmd_pool = dma_pool_create(IPR_NAME, &ioa_cfg->pdev->dev,\n\t\t\t\t\t\tsizeof(struct ipr_cmnd), 512, 0);\n\n\tif (!ioa_cfg->ipr_cmd_pool)\n\t\treturn -ENOMEM;\n\n\tioa_cfg->ipr_cmnd_list = kcalloc(IPR_NUM_CMD_BLKS, sizeof(struct ipr_cmnd *), GFP_KERNEL);\n\tioa_cfg->ipr_cmnd_list_dma = kcalloc(IPR_NUM_CMD_BLKS, sizeof(dma_addr_t), GFP_KERNEL);\n\n\tif (!ioa_cfg->ipr_cmnd_list || !ioa_cfg->ipr_cmnd_list_dma) {\n\t\tipr_free_cmd_blks(ioa_cfg);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tif (ioa_cfg->hrrq_num > 1) {\n\t\t\tif (i == 0) {\n\t\t\t\tentries_each_hrrq = IPR_NUM_INTERNAL_CMD_BLKS;\n\t\t\t\tioa_cfg->hrrq[i].min_cmd_id = 0;\n\t\t\t\tioa_cfg->hrrq[i].max_cmd_id =\n\t\t\t\t\t(entries_each_hrrq - 1);\n\t\t\t} else {\n\t\t\t\tentries_each_hrrq =\n\t\t\t\t\tIPR_NUM_BASE_CMD_BLKS/\n\t\t\t\t\t(ioa_cfg->hrrq_num - 1);\n\t\t\t\tioa_cfg->hrrq[i].min_cmd_id =\n\t\t\t\t\tIPR_NUM_INTERNAL_CMD_BLKS +\n\t\t\t\t\t(i - 1) * entries_each_hrrq;\n\t\t\t\tioa_cfg->hrrq[i].max_cmd_id =\n\t\t\t\t\t(IPR_NUM_INTERNAL_CMD_BLKS +\n\t\t\t\t\ti * entries_each_hrrq - 1);\n\t\t\t}\n\t\t} else {\n\t\t\tentries_each_hrrq = IPR_NUM_CMD_BLKS;\n\t\t\tioa_cfg->hrrq[i].min_cmd_id = 0;\n\t\t\tioa_cfg->hrrq[i].max_cmd_id = (entries_each_hrrq - 1);\n\t\t}\n\t\tioa_cfg->hrrq[i].size = entries_each_hrrq;\n\t}\n\n\tBUG_ON(ioa_cfg->hrrq_num == 0);\n\n\ti = IPR_NUM_CMD_BLKS -\n\t\tioa_cfg->hrrq[ioa_cfg->hrrq_num - 1].max_cmd_id - 1;\n\tif (i > 0) {\n\t\tioa_cfg->hrrq[ioa_cfg->hrrq_num - 1].size += i;\n\t\tioa_cfg->hrrq[ioa_cfg->hrrq_num - 1].max_cmd_id += i;\n\t}\n\n\tfor (i = 0; i < IPR_NUM_CMD_BLKS; i++) {\n\t\tipr_cmd = dma_pool_zalloc(ioa_cfg->ipr_cmd_pool,\n\t\t\t\tGFP_KERNEL, &dma_addr);\n\n\t\tif (!ipr_cmd) {\n\t\t\tipr_free_cmd_blks(ioa_cfg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tioa_cfg->ipr_cmnd_list[i] = ipr_cmd;\n\t\tioa_cfg->ipr_cmnd_list_dma[i] = dma_addr;\n\n\t\tioarcb = &ipr_cmd->ioarcb;\n\t\tipr_cmd->dma_addr = dma_addr;\n\t\tif (ioa_cfg->sis64)\n\t\t\tioarcb->a.ioarcb_host_pci_addr64 = cpu_to_be64(dma_addr);\n\t\telse\n\t\t\tioarcb->a.ioarcb_host_pci_addr = cpu_to_be32(dma_addr);\n\n\t\tioarcb->host_response_handle = cpu_to_be32(i << 2);\n\t\tif (ioa_cfg->sis64) {\n\t\t\tioarcb->u.sis64_addr_data.data_ioadl_addr =\n\t\t\t\tcpu_to_be64(dma_addr + offsetof(struct ipr_cmnd, i.ioadl64));\n\t\t\tioarcb->u.sis64_addr_data.ioasa_host_pci_addr =\n\t\t\t\tcpu_to_be64(dma_addr + offsetof(struct ipr_cmnd, s.ioasa64));\n\t\t} else {\n\t\t\tioarcb->write_ioadl_addr =\n\t\t\t\tcpu_to_be32(dma_addr + offsetof(struct ipr_cmnd, i.ioadl));\n\t\t\tioarcb->read_ioadl_addr = ioarcb->write_ioadl_addr;\n\t\t\tioarcb->ioasa_host_pci_addr =\n\t\t\t\tcpu_to_be32(dma_addr + offsetof(struct ipr_cmnd, s.ioasa));\n\t\t}\n\t\tioarcb->ioasa_len = cpu_to_be16(sizeof(struct ipr_ioasa));\n\t\tipr_cmd->cmd_index = i;\n\t\tipr_cmd->ioa_cfg = ioa_cfg;\n\t\tipr_cmd->sense_buffer_dma = dma_addr +\n\t\t\toffsetof(struct ipr_cmnd, sense_buffer);\n\n\t\tipr_cmd->ioarcb.cmd_pkt.hrrq_id = hrrq_id;\n\t\tipr_cmd->hrrq = &ioa_cfg->hrrq[hrrq_id];\n\t\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n\t\tif (i >= ioa_cfg->hrrq[hrrq_id].max_cmd_id)\n\t\t\thrrq_id++;\n\t}\n\n\treturn 0;\n}\n\n/**\n * ipr_alloc_mem - Allocate memory for an adapter\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \t0 on success / non-zero for error\n **/\nstatic int ipr_alloc_mem(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct pci_dev *pdev = ioa_cfg->pdev;\n\tint i, rc = -ENOMEM;\n\n\tENTER;\n\tioa_cfg->res_entries = kcalloc(ioa_cfg->max_devs_supported,\n\t\t\t\t       sizeof(struct ipr_resource_entry),\n\t\t\t\t       GFP_KERNEL);\n\n\tif (!ioa_cfg->res_entries)\n\t\tgoto out;\n\n\tfor (i = 0; i < ioa_cfg->max_devs_supported; i++) {\n\t\tlist_add_tail(&ioa_cfg->res_entries[i].queue, &ioa_cfg->free_res_q);\n\t\tioa_cfg->res_entries[i].ioa_cfg = ioa_cfg;\n\t}\n\n\tioa_cfg->vpd_cbs = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t      sizeof(struct ipr_misc_cbs),\n\t\t\t\t\t      &ioa_cfg->vpd_cbs_dma,\n\t\t\t\t\t      GFP_KERNEL);\n\n\tif (!ioa_cfg->vpd_cbs)\n\t\tgoto out_free_res_entries;\n\n\tif (ipr_alloc_cmd_blks(ioa_cfg))\n\t\tgoto out_free_vpd_cbs;\n\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tioa_cfg->hrrq[i].host_rrq = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(u32) * ioa_cfg->hrrq[i].size,\n\t\t\t\t\t&ioa_cfg->hrrq[i].host_rrq_dma,\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!ioa_cfg->hrrq[i].host_rrq)  {\n\t\t\twhile (--i > 0)\n\t\t\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(u32) * ioa_cfg->hrrq[i].size,\n\t\t\t\t\tioa_cfg->hrrq[i].host_rrq,\n\t\t\t\t\tioa_cfg->hrrq[i].host_rrq_dma);\n\t\t\tgoto out_ipr_free_cmd_blocks;\n\t\t}\n\t\tioa_cfg->hrrq[i].ioa_cfg = ioa_cfg;\n\t}\n\n\tioa_cfg->u.cfg_table = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t  ioa_cfg->cfg_table_size,\n\t\t\t\t\t\t  &ioa_cfg->cfg_table_dma,\n\t\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!ioa_cfg->u.cfg_table)\n\t\tgoto out_free_host_rrq;\n\n\tfor (i = 0; i < IPR_MAX_HCAMS; i++) {\n\t\tioa_cfg->hostrcb[i] = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\t sizeof(struct ipr_hostrcb),\n\t\t\t\t\t\t\t &ioa_cfg->hostrcb_dma[i],\n\t\t\t\t\t\t\t GFP_KERNEL);\n\n\t\tif (!ioa_cfg->hostrcb[i])\n\t\t\tgoto out_free_hostrcb_dma;\n\n\t\tioa_cfg->hostrcb[i]->hostrcb_dma =\n\t\t\tioa_cfg->hostrcb_dma[i] + offsetof(struct ipr_hostrcb, hcam);\n\t\tioa_cfg->hostrcb[i]->ioa_cfg = ioa_cfg;\n\t\tlist_add_tail(&ioa_cfg->hostrcb[i]->queue, &ioa_cfg->hostrcb_free_q);\n\t}\n\n\tioa_cfg->trace = kcalloc(IPR_NUM_TRACE_ENTRIES,\n\t\t\t\t sizeof(struct ipr_trace_entry),\n\t\t\t\t GFP_KERNEL);\n\n\tif (!ioa_cfg->trace)\n\t\tgoto out_free_hostrcb_dma;\n\n\trc = 0;\nout:\n\tLEAVE;\n\treturn rc;\n\nout_free_hostrcb_dma:\n\twhile (i-- > 0) {\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct ipr_hostrcb),\n\t\t\t\t  ioa_cfg->hostrcb[i],\n\t\t\t\t  ioa_cfg->hostrcb_dma[i]);\n\t}\n\tdma_free_coherent(&pdev->dev, ioa_cfg->cfg_table_size,\n\t\t\t  ioa_cfg->u.cfg_table, ioa_cfg->cfg_table_dma);\nout_free_host_rrq:\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(u32) * ioa_cfg->hrrq[i].size,\n\t\t\t\t  ioa_cfg->hrrq[i].host_rrq,\n\t\t\t\t  ioa_cfg->hrrq[i].host_rrq_dma);\n\t}\nout_ipr_free_cmd_blocks:\n\tipr_free_cmd_blks(ioa_cfg);\nout_free_vpd_cbs:\n\tdma_free_coherent(&pdev->dev, sizeof(struct ipr_misc_cbs),\n\t\t\t  ioa_cfg->vpd_cbs, ioa_cfg->vpd_cbs_dma);\nout_free_res_entries:\n\tkfree(ioa_cfg->res_entries);\n\tgoto out;\n}\n\n/**\n * ipr_initialize_bus_attr - Initialize SCSI bus attributes to default values\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_initialize_bus_attr(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint i;\n\n\tfor (i = 0; i < IPR_MAX_NUM_BUSES; i++) {\n\t\tioa_cfg->bus_attr[i].bus = i;\n\t\tioa_cfg->bus_attr[i].qas_enabled = 0;\n\t\tioa_cfg->bus_attr[i].bus_width = IPR_DEFAULT_BUS_WIDTH;\n\t\tif (ipr_max_speed < ARRAY_SIZE(ipr_max_bus_speeds))\n\t\t\tioa_cfg->bus_attr[i].max_xfer_rate = ipr_max_bus_speeds[ipr_max_speed];\n\t\telse\n\t\t\tioa_cfg->bus_attr[i].max_xfer_rate = IPR_U160_SCSI_RATE;\n\t}\n}\n\n/**\n * ipr_init_regs - Initialize IOA registers\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n *\tnone\n **/\nstatic void ipr_init_regs(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tconst struct ipr_interrupt_offsets *p;\n\tstruct ipr_interrupts *t;\n\tvoid __iomem *base;\n\n\tp = &ioa_cfg->chip_cfg->regs;\n\tt = &ioa_cfg->regs;\n\tbase = ioa_cfg->hdw_dma_regs;\n\n\tt->set_interrupt_mask_reg = base + p->set_interrupt_mask_reg;\n\tt->clr_interrupt_mask_reg = base + p->clr_interrupt_mask_reg;\n\tt->clr_interrupt_mask_reg32 = base + p->clr_interrupt_mask_reg32;\n\tt->sense_interrupt_mask_reg = base + p->sense_interrupt_mask_reg;\n\tt->sense_interrupt_mask_reg32 = base + p->sense_interrupt_mask_reg32;\n\tt->clr_interrupt_reg = base + p->clr_interrupt_reg;\n\tt->clr_interrupt_reg32 = base + p->clr_interrupt_reg32;\n\tt->sense_interrupt_reg = base + p->sense_interrupt_reg;\n\tt->sense_interrupt_reg32 = base + p->sense_interrupt_reg32;\n\tt->ioarrin_reg = base + p->ioarrin_reg;\n\tt->sense_uproc_interrupt_reg = base + p->sense_uproc_interrupt_reg;\n\tt->sense_uproc_interrupt_reg32 = base + p->sense_uproc_interrupt_reg32;\n\tt->set_uproc_interrupt_reg = base + p->set_uproc_interrupt_reg;\n\tt->set_uproc_interrupt_reg32 = base + p->set_uproc_interrupt_reg32;\n\tt->clr_uproc_interrupt_reg = base + p->clr_uproc_interrupt_reg;\n\tt->clr_uproc_interrupt_reg32 = base + p->clr_uproc_interrupt_reg32;\n\n\tif (ioa_cfg->sis64) {\n\t\tt->init_feedback_reg = base + p->init_feedback_reg;\n\t\tt->dump_addr_reg = base + p->dump_addr_reg;\n\t\tt->dump_data_reg = base + p->dump_data_reg;\n\t\tt->endian_swap_reg = base + p->endian_swap_reg;\n\t}\n}\n\n/**\n * ipr_init_ioa_cfg - Initialize IOA config struct\n * @ioa_cfg:\tioa config struct\n * @host:\t\tscsi host struct\n * @pdev:\t\tPCI dev struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_init_ioa_cfg(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t     struct Scsi_Host *host, struct pci_dev *pdev)\n{\n\tint i;\n\n\tioa_cfg->host = host;\n\tioa_cfg->pdev = pdev;\n\tioa_cfg->log_level = ipr_log_level;\n\tioa_cfg->doorbell = IPR_DOORBELL;\n\tsprintf(ioa_cfg->eye_catcher, IPR_EYECATCHER);\n\tsprintf(ioa_cfg->trace_start, IPR_TRACE_START_LABEL);\n\tsprintf(ioa_cfg->cfg_table_start, IPR_CFG_TBL_START);\n\tsprintf(ioa_cfg->resource_table_label, IPR_RES_TABLE_LABEL);\n\tsprintf(ioa_cfg->ipr_hcam_label, IPR_HCAM_LABEL);\n\tsprintf(ioa_cfg->ipr_cmd_label, IPR_CMD_LABEL);\n\n\tINIT_LIST_HEAD(&ioa_cfg->hostrcb_free_q);\n\tINIT_LIST_HEAD(&ioa_cfg->hostrcb_pending_q);\n\tINIT_LIST_HEAD(&ioa_cfg->hostrcb_report_q);\n\tINIT_LIST_HEAD(&ioa_cfg->free_res_q);\n\tINIT_LIST_HEAD(&ioa_cfg->used_res_q);\n\tINIT_WORK(&ioa_cfg->work_q, ipr_worker_thread);\n\tINIT_WORK(&ioa_cfg->scsi_add_work_q, ipr_add_remove_thread);\n\tinit_waitqueue_head(&ioa_cfg->reset_wait_q);\n\tinit_waitqueue_head(&ioa_cfg->msi_wait_q);\n\tinit_waitqueue_head(&ioa_cfg->eeh_wait_q);\n\tioa_cfg->sdt_state = INACTIVE;\n\n\tipr_initialize_bus_attr(ioa_cfg);\n\tioa_cfg->max_devs_supported = ipr_max_devs;\n\n\tif (ioa_cfg->sis64) {\n\t\thost->max_channel = IPR_MAX_SIS64_BUSES;\n\t\thost->max_id = IPR_MAX_SIS64_TARGETS_PER_BUS;\n\t\thost->max_lun = IPR_MAX_SIS64_LUNS_PER_TARGET;\n\t\tif (ipr_max_devs > IPR_MAX_SIS64_DEVS)\n\t\t\tioa_cfg->max_devs_supported = IPR_MAX_SIS64_DEVS;\n\t\tioa_cfg->cfg_table_size = (sizeof(struct ipr_config_table_hdr64)\n\t\t\t\t\t   + ((sizeof(struct ipr_config_table_entry64)\n\t\t\t\t\t       * ioa_cfg->max_devs_supported)));\n\t} else {\n\t\thost->max_channel = IPR_VSET_BUS;\n\t\thost->max_id = IPR_MAX_NUM_TARGETS_PER_BUS;\n\t\thost->max_lun = IPR_MAX_NUM_LUNS_PER_TARGET;\n\t\tif (ipr_max_devs > IPR_MAX_PHYSICAL_DEVS)\n\t\t\tioa_cfg->max_devs_supported = IPR_MAX_PHYSICAL_DEVS;\n\t\tioa_cfg->cfg_table_size = (sizeof(struct ipr_config_table_hdr)\n\t\t\t\t\t   + ((sizeof(struct ipr_config_table_entry)\n\t\t\t\t\t       * ioa_cfg->max_devs_supported)));\n\t}\n\n\thost->unique_id = host->host_no;\n\thost->max_cmd_len = IPR_MAX_CDB_LEN;\n\thost->can_queue = ioa_cfg->max_cmds;\n\tpci_set_drvdata(pdev, ioa_cfg);\n\n\tfor (i = 0; i < ARRAY_SIZE(ioa_cfg->hrrq); i++) {\n\t\tINIT_LIST_HEAD(&ioa_cfg->hrrq[i].hrrq_free_q);\n\t\tINIT_LIST_HEAD(&ioa_cfg->hrrq[i].hrrq_pending_q);\n\t\tspin_lock_init(&ioa_cfg->hrrq[i]._lock);\n\t\tif (i == 0)\n\t\t\tioa_cfg->hrrq[i].lock = ioa_cfg->host->host_lock;\n\t\telse\n\t\t\tioa_cfg->hrrq[i].lock = &ioa_cfg->hrrq[i]._lock;\n\t}\n}\n\n/**\n * ipr_get_chip_info - Find adapter chip information\n * @dev_id:\t\tPCI device id struct\n *\n * Return value:\n * \tptr to chip information on success / NULL on failure\n **/\nstatic const struct ipr_chip_t *\nipr_get_chip_info(const struct pci_device_id *dev_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ipr_chip); i++)\n\t\tif (ipr_chip[i].vendor == dev_id->vendor &&\n\t\t    ipr_chip[i].device == dev_id->device)\n\t\t\treturn &ipr_chip[i];\n\treturn NULL;\n}\n\n/**\n * ipr_wait_for_pci_err_recovery - Wait for any PCI error recovery to complete\n *\t\t\t\t\t\tduring probe time\n * @ioa_cfg:\tioa config struct\n *\n * Return value:\n * \tNone\n **/\nstatic void ipr_wait_for_pci_err_recovery(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tstruct pci_dev *pdev = ioa_cfg->pdev;\n\n\tif (pci_channel_offline(pdev)) {\n\t\twait_event_timeout(ioa_cfg->eeh_wait_q,\n\t\t\t\t   !pci_channel_offline(pdev),\n\t\t\t\t   IPR_PCI_ERROR_RECOVERY_TIMEOUT);\n\t\tpci_restore_state(pdev);\n\t}\n}\n\nstatic void name_msi_vectors(struct ipr_ioa_cfg *ioa_cfg)\n{\n\tint vec_idx, n = sizeof(ioa_cfg->vectors_info[0].desc) - 1;\n\n\tfor (vec_idx = 0; vec_idx < ioa_cfg->nvectors; vec_idx++) {\n\t\tsnprintf(ioa_cfg->vectors_info[vec_idx].desc, n,\n\t\t\t \"host%d-%d\", ioa_cfg->host->host_no, vec_idx);\n\t\tioa_cfg->vectors_info[vec_idx].\n\t\t\tdesc[strlen(ioa_cfg->vectors_info[vec_idx].desc)] = 0;\n\t}\n}\n\nstatic int ipr_request_other_msi_irqs(struct ipr_ioa_cfg *ioa_cfg,\n\t\tstruct pci_dev *pdev)\n{\n\tint i, rc;\n\n\tfor (i = 1; i < ioa_cfg->nvectors; i++) {\n\t\trc = request_irq(pci_irq_vector(pdev, i),\n\t\t\tipr_isr_mhrrq,\n\t\t\t0,\n\t\t\tioa_cfg->vectors_info[i].desc,\n\t\t\t&ioa_cfg->hrrq[i]);\n\t\tif (rc) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tfree_irq(pci_irq_vector(pdev, i),\n\t\t\t\t\t&ioa_cfg->hrrq[i]);\n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * ipr_test_intr - Handle the interrupt generated in ipr_test_msi().\n * @devp:\t\tPCI device struct\n * @irq:\t\tIRQ number\n *\n * Description: Simply set the msi_received flag to 1 indicating that\n * Message Signaled Interrupts are supported.\n *\n * Return value:\n * \t0 on success / non-zero on failure\n **/\nstatic irqreturn_t ipr_test_intr(int irq, void *devp)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = (struct ipr_ioa_cfg *)devp;\n\tunsigned long lock_flags = 0;\n\tirqreturn_t rc = IRQ_HANDLED;\n\n\tdev_info(&ioa_cfg->pdev->dev, \"Received IRQ : %d\\n\", irq);\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\n\tioa_cfg->msi_received = 1;\n\twake_up(&ioa_cfg->msi_wait_q);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\treturn rc;\n}\n\n/**\n * ipr_test_msi - Test for Message Signaled Interrupt (MSI) support.\n * @ioa_cfg:\t\tioa config struct\n * @pdev:\t\tPCI device struct\n *\n * Description: This routine sets up and initiates a test interrupt to determine\n * if the interrupt is received via the ipr_test_intr() service routine.\n * If the tests fails, the driver will fall back to LSI.\n *\n * Return value:\n * \t0 on success / non-zero on failure\n **/\nstatic int ipr_test_msi(struct ipr_ioa_cfg *ioa_cfg, struct pci_dev *pdev)\n{\n\tint rc;\n\tunsigned long lock_flags = 0;\n\tint irq = pci_irq_vector(pdev, 0);\n\n\tENTER;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tinit_waitqueue_head(&ioa_cfg->msi_wait_q);\n\tioa_cfg->msi_received = 0;\n\tipr_mask_and_clear_interrupts(ioa_cfg, ~IPR_PCII_IOA_TRANS_TO_OPER);\n\twritel(IPR_PCII_IO_DEBUG_ACKNOWLEDGE, ioa_cfg->regs.clr_interrupt_mask_reg32);\n\treadl(ioa_cfg->regs.sense_interrupt_mask_reg);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\trc = request_irq(irq, ipr_test_intr, 0, IPR_NAME, ioa_cfg);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Can not assign irq %d\\n\", irq);\n\t\treturn rc;\n\t} else if (ipr_debug)\n\t\tdev_info(&pdev->dev, \"IRQ assigned: %d\\n\", irq);\n\n\twritel(IPR_PCII_IO_DEBUG_ACKNOWLEDGE, ioa_cfg->regs.sense_interrupt_reg32);\n\treadl(ioa_cfg->regs.sense_interrupt_reg);\n\twait_event_timeout(ioa_cfg->msi_wait_q, ioa_cfg->msi_received, HZ);\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tipr_mask_and_clear_interrupts(ioa_cfg, ~IPR_PCII_IOA_TRANS_TO_OPER);\n\n\tif (!ioa_cfg->msi_received) {\n\t\t/* MSI test failed */\n\t\tdev_info(&pdev->dev, \"MSI test failed.  Falling back to LSI.\\n\");\n\t\trc = -EOPNOTSUPP;\n\t} else if (ipr_debug)\n\t\tdev_info(&pdev->dev, \"MSI test succeeded.\\n\");\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tfree_irq(irq, ioa_cfg);\n\n\tLEAVE;\n\n\treturn rc;\n}\n\n /* ipr_probe_ioa - Allocates memory and does first stage of initialization\n * @pdev:\t\tPCI device struct\n * @dev_id:\t\tPCI device id struct\n *\n * Return value:\n * \t0 on success / non-zero on failure\n **/\nstatic int ipr_probe_ioa(struct pci_dev *pdev,\n\t\t\t const struct pci_device_id *dev_id)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tstruct Scsi_Host *host;\n\tunsigned long ipr_regs_pci;\n\tvoid __iomem *ipr_regs;\n\tint rc = PCIBIOS_SUCCESSFUL;\n\tvolatile u32 mask, uproc, interrupts;\n\tunsigned long lock_flags, driver_lock_flags;\n\tunsigned int irq_flag;\n\n\tENTER;\n\n\tdev_info(&pdev->dev, \"Found IOA with IRQ: %d\\n\", pdev->irq);\n\thost = scsi_host_alloc(&driver_template, sizeof(*ioa_cfg));\n\n\tif (!host) {\n\t\tdev_err(&pdev->dev, \"call to scsi_host_alloc failed!\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tioa_cfg = (struct ipr_ioa_cfg *)host->hostdata;\n\tmemset(ioa_cfg, 0, sizeof(struct ipr_ioa_cfg));\n\tata_host_init(&ioa_cfg->ata_host, &pdev->dev, &ipr_sata_ops);\n\n\tioa_cfg->ipr_chip = ipr_get_chip_info(dev_id);\n\n\tif (!ioa_cfg->ipr_chip) {\n\t\tdev_err(&pdev->dev, \"Unknown adapter chipset 0x%04X 0x%04X\\n\",\n\t\t\tdev_id->vendor, dev_id->device);\n\t\tgoto out_scsi_host_put;\n\t}\n\n\t/* set SIS 32 or SIS 64 */\n\tioa_cfg->sis64 = ioa_cfg->ipr_chip->sis_type == IPR_SIS64 ? 1 : 0;\n\tioa_cfg->chip_cfg = ioa_cfg->ipr_chip->cfg;\n\tioa_cfg->clear_isr = ioa_cfg->chip_cfg->clear_isr;\n\tioa_cfg->max_cmds = ioa_cfg->chip_cfg->max_cmds;\n\n\tif (ipr_transop_timeout)\n\t\tioa_cfg->transop_timeout = ipr_transop_timeout;\n\telse if (dev_id->driver_data & IPR_USE_LONG_TRANSOP_TIMEOUT)\n\t\tioa_cfg->transop_timeout = IPR_LONG_OPERATIONAL_TIMEOUT;\n\telse\n\t\tioa_cfg->transop_timeout = IPR_OPERATIONAL_TIMEOUT;\n\n\tioa_cfg->revid = pdev->revision;\n\n\tipr_init_ioa_cfg(ioa_cfg, host, pdev);\n\n\tipr_regs_pci = pci_resource_start(pdev, 0);\n\n\trc = pci_request_regions(pdev, IPR_NAME);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Couldn't register memory range of registers\\n\");\n\t\tgoto out_scsi_host_put;\n\t}\n\n\trc = pci_enable_device(pdev);\n\n\tif (rc || pci_channel_offline(pdev)) {\n\t\tif (pci_channel_offline(pdev)) {\n\t\t\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\t\t\trc = pci_enable_device(pdev);\n\t\t}\n\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev, \"Cannot enable adapter\\n\");\n\t\t\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\t\t\tgoto out_release_regions;\n\t\t}\n\t}\n\n\tipr_regs = pci_ioremap_bar(pdev, 0);\n\n\tif (!ipr_regs) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Couldn't map memory range of registers\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_disable;\n\t}\n\n\tioa_cfg->hdw_dma_regs = ipr_regs;\n\tioa_cfg->hdw_dma_regs_pci = ipr_regs_pci;\n\tioa_cfg->ioa_mailbox = ioa_cfg->chip_cfg->mailbox + ipr_regs;\n\n\tipr_init_regs(ioa_cfg);\n\n\tif (ioa_cfg->sis64) {\n\t\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\t\tif (rc < 0) {\n\t\t\tdev_dbg(&pdev->dev, \"Failed to set 64 bit DMA mask\\n\");\n\t\t\trc = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t       DMA_BIT_MASK(32));\n\t\t}\n\t} else\n\t\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\t\tgoto cleanup_nomem;\n\t}\n\n\trc = pci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t\t   ioa_cfg->chip_cfg->cache_line_size);\n\n\tif (rc != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(&pdev->dev, \"Write of cache line size failed\\n\");\n\t\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\t\trc = -EIO;\n\t\tgoto cleanup_nomem;\n\t}\n\n\t/* Issue MMIO read to ensure card is not in EEH */\n\tinterrupts = readl(ioa_cfg->regs.sense_interrupt_reg);\n\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\n\tif (ipr_number_of_msix > IPR_MAX_MSIX_VECTORS) {\n\t\tdev_err(&pdev->dev, \"The max number of MSIX is %d\\n\",\n\t\t\tIPR_MAX_MSIX_VECTORS);\n\t\tipr_number_of_msix = IPR_MAX_MSIX_VECTORS;\n\t}\n\n\tirq_flag = PCI_IRQ_LEGACY;\n\tif (ioa_cfg->ipr_chip->has_msi)\n\t\tirq_flag |= PCI_IRQ_MSI | PCI_IRQ_MSIX;\n\trc = pci_alloc_irq_vectors(pdev, 1, ipr_number_of_msix, irq_flag);\n\tif (rc < 0) {\n\t\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\t\tgoto cleanup_nomem;\n\t}\n\tioa_cfg->nvectors = rc;\n\n\tif (!pdev->msi_enabled && !pdev->msix_enabled)\n\t\tioa_cfg->clear_isr = 1;\n\n\tpci_set_master(pdev);\n\n\tif (pci_channel_offline(pdev)) {\n\t\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\t\tpci_set_master(pdev);\n\t\tif (pci_channel_offline(pdev)) {\n\t\t\trc = -EIO;\n\t\t\tgoto out_msi_disable;\n\t\t}\n\t}\n\n\tif (pdev->msi_enabled || pdev->msix_enabled) {\n\t\trc = ipr_test_msi(ioa_cfg, pdev);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\"Request for %d MSI%ss succeeded.\", ioa_cfg->nvectors,\n\t\t\t\tpdev->msix_enabled ? \"-X\" : \"\");\n\t\t\tbreak;\n\t\tcase -EOPNOTSUPP:\n\t\t\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\t\t\tpci_free_irq_vectors(pdev);\n\n\t\t\tioa_cfg->nvectors = 1;\n\t\t\tioa_cfg->clear_isr = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_msi_disable;\n\t\t}\n\t}\n\n\tioa_cfg->hrrq_num = min3(ioa_cfg->nvectors,\n\t\t\t\t(unsigned int)num_online_cpus(),\n\t\t\t\t(unsigned int)IPR_MAX_HRRQ_NUM);\n\n\tif ((rc = ipr_save_pcix_cmd_reg(ioa_cfg)))\n\t\tgoto out_msi_disable;\n\n\tif ((rc = ipr_set_pcix_cmd_reg(ioa_cfg)))\n\t\tgoto out_msi_disable;\n\n\trc = ipr_alloc_mem(ioa_cfg);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Couldn't allocate enough memory for device driver!\\n\");\n\t\tgoto out_msi_disable;\n\t}\n\n\t/* Save away PCI config space for use following IOA reset */\n\trc = pci_save_state(pdev);\n\n\tif (rc != PCIBIOS_SUCCESSFUL) {\n\t\tdev_err(&pdev->dev, \"Failed to save PCI config space\\n\");\n\t\trc = -EIO;\n\t\tgoto cleanup_nolog;\n\t}\n\n\t/*\n\t * If HRRQ updated interrupt is not masked, or reset alert is set,\n\t * the card is in an unknown state and needs a hard reset\n\t */\n\tmask = readl(ioa_cfg->regs.sense_interrupt_mask_reg32);\n\tinterrupts = readl(ioa_cfg->regs.sense_interrupt_reg32);\n\tuproc = readl(ioa_cfg->regs.sense_uproc_interrupt_reg32);\n\tif ((mask & IPR_PCII_HRRQ_UPDATED) == 0 || (uproc & IPR_UPROCI_RESET_ALERT))\n\t\tioa_cfg->needs_hard_reset = 1;\n\tif ((interrupts & IPR_PCII_ERROR_INTERRUPTS) || reset_devices)\n\t\tioa_cfg->needs_hard_reset = 1;\n\tif (interrupts & IPR_PCII_IOA_UNIT_CHECKED)\n\t\tioa_cfg->ioa_unit_checked = 1;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tipr_mask_and_clear_interrupts(ioa_cfg, ~IPR_PCII_IOA_TRANS_TO_OPER);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\n\tif (pdev->msi_enabled || pdev->msix_enabled) {\n\t\tname_msi_vectors(ioa_cfg);\n\t\trc = request_irq(pci_irq_vector(pdev, 0), ipr_isr, 0,\n\t\t\tioa_cfg->vectors_info[0].desc,\n\t\t\t&ioa_cfg->hrrq[0]);\n\t\tif (!rc)\n\t\t\trc = ipr_request_other_msi_irqs(ioa_cfg, pdev);\n\t} else {\n\t\trc = request_irq(pdev->irq, ipr_isr,\n\t\t\t IRQF_SHARED,\n\t\t\t IPR_NAME, &ioa_cfg->hrrq[0]);\n\t}\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Couldn't register IRQ %d! rc=%d\\n\",\n\t\t\tpdev->irq, rc);\n\t\tgoto cleanup_nolog;\n\t}\n\n\tif ((dev_id->driver_data & IPR_USE_PCI_WARM_RESET) ||\n\t    (dev_id->device == PCI_DEVICE_ID_IBM_OBSIDIAN_E && !ioa_cfg->revid)) {\n\t\tioa_cfg->needs_warm_reset = 1;\n\t\tioa_cfg->reset = ipr_reset_slot_reset;\n\n\t\tioa_cfg->reset_work_q = alloc_ordered_workqueue(\"ipr_reset_%d\",\n\t\t\t\t\t\t\t\tWQ_MEM_RECLAIM, host->host_no);\n\n\t\tif (!ioa_cfg->reset_work_q) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't register reset workqueue\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_irq;\n\t\t}\n\t} else\n\t\tioa_cfg->reset = ipr_reset_start_bist;\n\n\tspin_lock_irqsave(&ipr_driver_lock, driver_lock_flags);\n\tlist_add_tail(&ioa_cfg->queue, &ipr_ioa_head);\n\tspin_unlock_irqrestore(&ipr_driver_lock, driver_lock_flags);\n\n\tLEAVE;\nout:\n\treturn rc;\n\nout_free_irq:\n\tipr_free_irqs(ioa_cfg);\ncleanup_nolog:\n\tipr_free_mem(ioa_cfg);\nout_msi_disable:\n\tipr_wait_for_pci_err_recovery(ioa_cfg);\n\tpci_free_irq_vectors(pdev);\ncleanup_nomem:\n\tiounmap(ipr_regs);\nout_disable:\n\tpci_disable_device(pdev);\nout_release_regions:\n\tpci_release_regions(pdev);\nout_scsi_host_put:\n\tscsi_host_put(host);\n\tgoto out;\n}\n\n/**\n * ipr_initiate_ioa_bringdown - Bring down an adapter\n * @ioa_cfg:\t\tioa config struct\n * @shutdown_type:\tshutdown type\n *\n * Description: This function will initiate bringing down the adapter.\n * This consists of issuing an IOA shutdown to the adapter\n * to flush the cache, and running BIST.\n * If the caller needs to wait on the completion of the reset,\n * the caller must sleep on the reset_wait_q.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_initiate_ioa_bringdown(struct ipr_ioa_cfg *ioa_cfg,\n\t\t\t\t       enum ipr_shutdown_type shutdown_type)\n{\n\tENTER;\n\tif (ioa_cfg->sdt_state == WAIT_FOR_DUMP)\n\t\tioa_cfg->sdt_state = ABORT_DUMP;\n\tioa_cfg->reset_retries = 0;\n\tioa_cfg->in_ioa_bringdown = 1;\n\tipr_initiate_ioa_reset(ioa_cfg, shutdown_type);\n\tLEAVE;\n}\n\n/**\n * __ipr_remove - Remove a single adapter\n * @pdev:\tpci device struct\n *\n * Adapter hot plug remove entry point.\n *\n * Return value:\n * \tnone\n **/\nstatic void __ipr_remove(struct pci_dev *pdev)\n{\n\tunsigned long host_lock_flags = 0;\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\tint i;\n\tunsigned long driver_lock_flags;\n\tENTER;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);\n\t}\n\n\tfor (i = 0; i < ioa_cfg->hrrq_num; i++) {\n\t\tspin_lock(&ioa_cfg->hrrq[i]._lock);\n\t\tioa_cfg->hrrq[i].removing_ioa = 1;\n\t\tspin_unlock(&ioa_cfg->hrrq[i]._lock);\n\t}\n\twmb();\n\tipr_initiate_ioa_bringdown(ioa_cfg, IPR_SHUTDOWN_NORMAL);\n\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);\n\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\tflush_work(&ioa_cfg->work_q);\n\tif (ioa_cfg->reset_work_q)\n\t\tflush_workqueue(ioa_cfg->reset_work_q);\n\tINIT_LIST_HEAD(&ioa_cfg->used_res_q);\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, host_lock_flags);\n\n\tspin_lock_irqsave(&ipr_driver_lock, driver_lock_flags);\n\tlist_del(&ioa_cfg->queue);\n\tspin_unlock_irqrestore(&ipr_driver_lock, driver_lock_flags);\n\n\tif (ioa_cfg->sdt_state == ABORT_DUMP)\n\t\tioa_cfg->sdt_state = WAIT_FOR_DUMP;\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, host_lock_flags);\n\n\tipr_free_all_resources(ioa_cfg);\n\n\tLEAVE;\n}\n\n/**\n * ipr_remove - IOA hot plug remove entry point\n * @pdev:\tpci device struct\n *\n * Adapter hot plug remove entry point.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_remove(struct pci_dev *pdev)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\n\tENTER;\n\n\tipr_remove_trace_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t      &ipr_trace_attr);\n\tipr_remove_dump_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t     &ipr_dump_attr);\n\tsysfs_remove_bin_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t&ipr_ioa_async_err_log);\n\tscsi_remove_host(ioa_cfg->host);\n\n\t__ipr_remove(pdev);\n\n\tLEAVE;\n}\n\n/**\n * ipr_probe - Adapter hot plug add entry point\n * @pdev:\tpci device struct\n * @dev_id:\tpci device ID\n *\n * Return value:\n * \t0 on success / non-zero on failure\n **/\nstatic int ipr_probe(struct pci_dev *pdev, const struct pci_device_id *dev_id)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tunsigned long flags;\n\tint rc, i;\n\n\trc = ipr_probe_ioa(pdev, dev_id);\n\n\tif (rc)\n\t\treturn rc;\n\n\tioa_cfg = pci_get_drvdata(pdev);\n\trc = ipr_probe_ioa_part2(ioa_cfg);\n\n\tif (rc) {\n\t\t__ipr_remove(pdev);\n\t\treturn rc;\n\t}\n\n\trc = scsi_add_host(ioa_cfg->host, &pdev->dev);\n\n\tif (rc) {\n\t\t__ipr_remove(pdev);\n\t\treturn rc;\n\t}\n\n\trc = ipr_create_trace_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t\t   &ipr_trace_attr);\n\n\tif (rc) {\n\t\tscsi_remove_host(ioa_cfg->host);\n\t\t__ipr_remove(pdev);\n\t\treturn rc;\n\t}\n\n\trc = sysfs_create_bin_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t&ipr_ioa_async_err_log);\n\n\tif (rc) {\n\t\tipr_remove_dump_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t\t&ipr_dump_attr);\n\t\tipr_remove_trace_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t\t&ipr_trace_attr);\n\t\tscsi_remove_host(ioa_cfg->host);\n\t\t__ipr_remove(pdev);\n\t\treturn rc;\n\t}\n\n\trc = ipr_create_dump_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t\t   &ipr_dump_attr);\n\n\tif (rc) {\n\t\tsysfs_remove_bin_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t\t      &ipr_ioa_async_err_log);\n\t\tipr_remove_trace_file(&ioa_cfg->host->shost_dev.kobj,\n\t\t\t\t      &ipr_trace_attr);\n\t\tscsi_remove_host(ioa_cfg->host);\n\t\t__ipr_remove(pdev);\n\t\treturn rc;\n\t}\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\tioa_cfg->scan_enabled = 1;\n\tschedule_work(&ioa_cfg->work_q);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\n\tioa_cfg->iopoll_weight = ioa_cfg->chip_cfg->iopoll_weight;\n\n\tif (ioa_cfg->iopoll_weight && ioa_cfg->sis64 && ioa_cfg->nvectors > 1) {\n\t\tfor (i = 1; i < ioa_cfg->hrrq_num; i++) {\n\t\t\tirq_poll_init(&ioa_cfg->hrrq[i].iopoll,\n\t\t\t\t\tioa_cfg->iopoll_weight, ipr_iopoll);\n\t\t}\n\t}\n\n\tscsi_scan_host(ioa_cfg->host);\n\n\treturn 0;\n}\n\n/**\n * ipr_shutdown - Shutdown handler.\n * @pdev:\tpci device struct\n *\n * This function is invoked upon system shutdown/reboot. It will issue\n * an adapter shutdown to the adapter to flush the write cache.\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_shutdown(struct pci_dev *pdev)\n{\n\tstruct ipr_ioa_cfg *ioa_cfg = pci_get_drvdata(pdev);\n\tunsigned long lock_flags = 0;\n\tenum ipr_shutdown_type shutdown_type = IPR_SHUTDOWN_NORMAL;\n\tint i;\n\n\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\tif (ioa_cfg->iopoll_weight && ioa_cfg->sis64 && ioa_cfg->nvectors > 1) {\n\t\tioa_cfg->iopoll_weight = 0;\n\t\tfor (i = 1; i < ioa_cfg->hrrq_num; i++)\n\t\t\tirq_poll_disable(&ioa_cfg->hrrq[i].iopoll);\n\t}\n\n\twhile (ioa_cfg->in_reset_reload) {\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\t\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);\n\t}\n\n\tif (ipr_fast_reboot && system_state == SYSTEM_RESTART && ioa_cfg->sis64)\n\t\tshutdown_type = IPR_SHUTDOWN_QUIESCE;\n\n\tipr_initiate_ioa_bringdown(ioa_cfg, shutdown_type);\n\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);\n\twait_event(ioa_cfg->reset_wait_q, !ioa_cfg->in_reset_reload);\n\tif (ipr_fast_reboot && system_state == SYSTEM_RESTART && ioa_cfg->sis64) {\n\t\tipr_free_irqs(ioa_cfg);\n\t\tpci_disable_device(ioa_cfg->pdev);\n\t}\n}\n\nstatic struct pci_device_id ipr_pci_table[] = {\n\t{ PCI_VENDOR_ID_MYLEX, PCI_DEVICE_ID_IBM_GEMSTONE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_5702, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_MYLEX, PCI_DEVICE_ID_IBM_GEMSTONE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_5703, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_MYLEX, PCI_DEVICE_ID_IBM_GEMSTONE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_573D, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_MYLEX, PCI_DEVICE_ID_IBM_GEMSTONE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_573E, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CITRINE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_571B, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CITRINE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_572E, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CITRINE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_571A, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CITRINE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_575B, 0, 0,\n\t\tIPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_OBSIDIAN,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_572A, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_OBSIDIAN,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_572B, 0, 0,\n\t      IPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_OBSIDIAN,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_575C, 0, 0,\n\t      IPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_572A, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_572B, 0, 0,\n\t      IPR_USE_LONG_TRANSOP_TIMEOUT},\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_575C, 0, 0,\n\t      IPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN_E,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_574E, 0, 0,\n\t      IPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN_E,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57B3, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN_E,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57CC, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_OBSIDIAN_E,\n\t      PCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57B7, 0, 0,\n\t      IPR_USE_LONG_TRANSOP_TIMEOUT | IPR_USE_PCI_WARM_RESET },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_SNIPE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_2780, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_SCAMP,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_571E, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_SCAMP,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_571F, 0, 0,\n\t\tIPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_ADAPTEC2, PCI_DEVICE_ID_ADAPTEC2_SCAMP,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_572F, 0, 0,\n\t\tIPR_USE_LONG_TRANSOP_TIMEOUT },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57B5, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_574D, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57B2, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57C0, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57C3, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROC_FPGA_E2,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57C4, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57B4, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57B1, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57C6, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57C8, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57CE, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57D5, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57D6, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57D7, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57D8, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57D9, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57DA, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57EB, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57EC, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57ED, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57EE, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57EF, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_57F0, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_2CCA, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_2CD2, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_CROCODILE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_2CCD, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_RATTLESNAKE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_580A, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_IBM, PCI_DEVICE_ID_IBM_RATTLESNAKE,\n\t\tPCI_VENDOR_ID_IBM, IPR_SUBS_DEV_ID_580B, 0, 0, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, ipr_pci_table);\n\nstatic const struct pci_error_handlers ipr_err_handler = {\n\t.error_detected = ipr_pci_error_detected,\n\t.mmio_enabled = ipr_pci_mmio_enabled,\n\t.slot_reset = ipr_pci_slot_reset,\n};\n\nstatic struct pci_driver ipr_driver = {\n\t.name = IPR_NAME,\n\t.id_table = ipr_pci_table,\n\t.probe = ipr_probe,\n\t.remove = ipr_remove,\n\t.shutdown = ipr_shutdown,\n\t.err_handler = &ipr_err_handler,\n};\n\n/**\n * ipr_halt_done - Shutdown prepare completion\n * @ipr_cmd:   ipr command struct\n *\n * Return value:\n * \tnone\n **/\nstatic void ipr_halt_done(struct ipr_cmnd *ipr_cmd)\n{\n\tlist_add_tail(&ipr_cmd->queue, &ipr_cmd->hrrq->hrrq_free_q);\n}\n\n/**\n * ipr_halt - Issue shutdown prepare to all adapters\n * @nb: Notifier block\n * @event: Notifier event\n * @buf: Notifier data (unused)\n *\n * Return value:\n * \tNOTIFY_OK on success / NOTIFY_DONE on failure\n **/\nstatic int ipr_halt(struct notifier_block *nb, ulong event, void *buf)\n{\n\tstruct ipr_cmnd *ipr_cmd;\n\tstruct ipr_ioa_cfg *ioa_cfg;\n\tunsigned long flags = 0, driver_lock_flags;\n\n\tif (event != SYS_RESTART && event != SYS_HALT && event != SYS_POWER_OFF)\n\t\treturn NOTIFY_DONE;\n\n\tspin_lock_irqsave(&ipr_driver_lock, driver_lock_flags);\n\n\tlist_for_each_entry(ioa_cfg, &ipr_ioa_head, queue) {\n\t\tspin_lock_irqsave(ioa_cfg->host->host_lock, flags);\n\t\tif (!ioa_cfg->hrrq[IPR_INIT_HRRQ].allow_cmds ||\n\t\t    (ipr_fast_reboot && event == SYS_RESTART && ioa_cfg->sis64)) {\n\t\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tipr_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);\n\t\tipr_cmd->ioarcb.res_handle = cpu_to_be32(IPR_IOA_RES_HANDLE);\n\t\tipr_cmd->ioarcb.cmd_pkt.request_type = IPR_RQTYPE_IOACMD;\n\t\tipr_cmd->ioarcb.cmd_pkt.cdb[0] = IPR_IOA_SHUTDOWN;\n\t\tipr_cmd->ioarcb.cmd_pkt.cdb[1] = IPR_SHUTDOWN_PREPARE_FOR_NORMAL;\n\n\t\tipr_do_req(ipr_cmd, ipr_halt_done, ipr_timeout, IPR_DEVICE_RESET_TIMEOUT);\n\t\tspin_unlock_irqrestore(ioa_cfg->host->host_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ipr_driver_lock, driver_lock_flags);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block ipr_notifier = {\n\tipr_halt, NULL, 0\n};\n\n/**\n * ipr_init - Module entry point\n *\n * Return value:\n * \t0 on success / negative value on failure\n **/\nstatic int __init ipr_init(void)\n{\n\tipr_info(\"IBM Power RAID SCSI Device Driver version: %s %s\\n\",\n\t\t IPR_DRIVER_VERSION, IPR_DRIVER_DATE);\n\n\tregister_reboot_notifier(&ipr_notifier);\n\treturn pci_register_driver(&ipr_driver);\n}\n\n/**\n * ipr_exit - Module unload\n *\n * Module unload entry point.\n *\n * Return value:\n * \tnone\n **/\nstatic void __exit ipr_exit(void)\n{\n\tunregister_reboot_notifier(&ipr_notifier);\n\tpci_unregister_driver(&ipr_driver);\n}\n\nmodule_init(ipr_init);\nmodule_exit(ipr_exit);\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 0, "line": 1468}, "message": "ERROR: invalid reference to the index variable of the iterator on line 1445"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ipr.c", "reportHash": "5f3f861888df7cffd762437e00f3896c", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 7861}, "message": "ERROR: invalid reference to the index variable of the iterator on line 7841"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ipr.c", "reportHash": "4670ce26aaf66ea66fcc74c73bdf9e32", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 46, "file": 0, "line": 7861}, "message": "ERROR: invalid reference to the index variable of the iterator on line 7841"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ipr.c", "reportHash": "1b447b11a3bcac93b6c2f32404f32954", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 71, "file": 0, "line": 7861}, "message": "ERROR: invalid reference to the index variable of the iterator on line 7841"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/ipr.c", "reportHash": "4d885e13731b4c13082d790ad2571f81", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
