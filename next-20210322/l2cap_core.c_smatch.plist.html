<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/bluetooth/l2cap_core.c", "content": "/*\n   BlueZ - Bluetooth protocol stack for Linux\n   Copyright (C) 2000-2001 Qualcomm Incorporated\n   Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>\n   Copyright (C) 2010 Google Inc.\n   Copyright (C) 2011 ProFUSION Embedded Systems\n   Copyright (c) 2012 Code Aurora Forum.  All rights reserved.\n\n   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/* Bluetooth L2CAP core. */\n\n#include <linux/module.h>\n\n#include <linux/debugfs.h>\n#include <linux/crc16.h>\n#include <linux/filter.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n#include \"a2mp.h\"\n#include \"amp.h\"\n\n#define LE_FLOWCTL_MAX_CREDITS 65535\n\nbool disable_ertm;\nbool enable_ecred;\n\nstatic u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN | L2CAP_FEAT_UCD;\n\nstatic LIST_HEAD(chan_list);\nstatic DEFINE_RWLOCK(chan_list_lock);\n\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,\n\t\t\t\t       u8 code, u8 ident, u16 dlen, void *data);\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\n\t\t\t   void *data);\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);\n\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t     struct sk_buff_head *skbs, u8 event);\n\nstatic inline u8 bdaddr_type(u8 link_type, u8 bdaddr_type)\n{\n\tif (link_type == LE_LINK) {\n\t\tif (bdaddr_type == ADDR_LE_DEV_PUBLIC)\n\t\t\treturn BDADDR_LE_PUBLIC;\n\t\telse\n\t\t\treturn BDADDR_LE_RANDOM;\n\t}\n\n\treturn BDADDR_BREDR;\n}\n\nstatic inline u8 bdaddr_src_type(struct hci_conn *hcon)\n{\n\treturn bdaddr_type(hcon->type, hcon->src_type);\n}\n\nstatic inline u8 bdaddr_dst_type(struct hci_conn *hcon)\n{\n\treturn bdaddr_type(hcon->type, hcon->dst_type);\n}\n\n/* ---- L2CAP channels ---- */\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\n\t\t\t\t\t\t   u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->dcid == cid)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_scid(struct l2cap_conn *conn,\n\t\t\t\t\t\t   u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->scid == cid)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\n/* Find channel with given SCID.\n * Returns locked channel. */\nstatic struct l2cap_chan *l2cap_get_chan_by_scid(struct l2cap_conn *conn,\n\t\t\t\t\t\t u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_scid(conn, cid);\n\tif (c)\n\t\tl2cap_chan_lock(c);\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\n/* Find channel with given DCID.\n * Returns locked channel.\n */\nstatic struct l2cap_chan *l2cap_get_chan_by_dcid(struct l2cap_conn *conn,\n\t\t\t\t\t\t u16 cid)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_dcid(conn, cid);\n\tif (c)\n\t\tl2cap_chan_lock(c);\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\nstatic struct l2cap_chan *__l2cap_get_chan_by_ident(struct l2cap_conn *conn,\n\t\t\t\t\t\t    u8 ident)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &conn->chan_l, list) {\n\t\tif (c->ident == ident)\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nstatic struct l2cap_chan *l2cap_get_chan_by_ident(struct l2cap_conn *conn,\n\t\t\t\t\t\t  u8 ident)\n{\n\tstruct l2cap_chan *c;\n\n\tmutex_lock(&conn->chan_lock);\n\tc = __l2cap_get_chan_by_ident(conn, ident);\n\tif (c)\n\t\tl2cap_chan_lock(c);\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn c;\n}\n\nstatic struct l2cap_chan *__l2cap_global_chan_by_addr(__le16 psm, bdaddr_t *src,\n\t\t\t\t\t\t      u8 src_type)\n{\n\tstruct l2cap_chan *c;\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (src_type == BDADDR_BREDR && c->src_type != BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (src_type != BDADDR_BREDR && c->src_type == BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (c->sport == psm && !bacmp(&c->src, src))\n\t\t\treturn c;\n\t}\n\treturn NULL;\n}\n\nint l2cap_add_psm(struct l2cap_chan *chan, bdaddr_t *src, __le16 psm)\n{\n\tint err;\n\n\twrite_lock(&chan_list_lock);\n\n\tif (psm && __l2cap_global_chan_by_addr(psm, src, chan->src_type)) {\n\t\terr = -EADDRINUSE;\n\t\tgoto done;\n\t}\n\n\tif (psm) {\n\t\tchan->psm = psm;\n\t\tchan->sport = psm;\n\t\terr = 0;\n\t} else {\n\t\tu16 p, start, end, incr;\n\n\t\tif (chan->src_type == BDADDR_BREDR) {\n\t\t\tstart = L2CAP_PSM_DYN_START;\n\t\t\tend = L2CAP_PSM_AUTO_END;\n\t\t\tincr = 2;\n\t\t} else {\n\t\t\tstart = L2CAP_PSM_LE_DYN_START;\n\t\t\tend = L2CAP_PSM_LE_DYN_END;\n\t\t\tincr = 1;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tfor (p = start; p <= end; p += incr)\n\t\t\tif (!__l2cap_global_chan_by_addr(cpu_to_le16(p), src,\n\t\t\t\t\t\t\t chan->src_type)) {\n\t\t\t\tchan->psm   = cpu_to_le16(p);\n\t\t\t\tchan->sport = cpu_to_le16(p);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\ndone:\n\twrite_unlock(&chan_list_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_add_psm);\n\nint l2cap_add_scid(struct l2cap_chan *chan,  __u16 scid)\n{\n\twrite_lock(&chan_list_lock);\n\n\t/* Override the defaults (which are for conn-oriented) */\n\tchan->omtu = L2CAP_DEFAULT_MTU;\n\tchan->chan_type = L2CAP_CHAN_FIXED;\n\n\tchan->scid = scid;\n\n\twrite_unlock(&chan_list_lock);\n\n\treturn 0;\n}\n\nstatic u16 l2cap_alloc_cid(struct l2cap_conn *conn)\n{\n\tu16 cid, dyn_end;\n\n\tif (conn->hcon->type == LE_LINK)\n\t\tdyn_end = L2CAP_CID_LE_DYN_END;\n\telse\n\t\tdyn_end = L2CAP_CID_DYN_END;\n\n\tfor (cid = L2CAP_CID_DYN_START; cid <= dyn_end; cid++) {\n\t\tif (!__l2cap_get_chan_by_scid(conn, cid))\n\t\t\treturn cid;\n\t}\n\n\treturn 0;\n}\n\nstatic void l2cap_state_change(struct l2cap_chan *chan, int state)\n{\n\tBT_DBG(\"chan %p %s -> %s\", chan, state_to_string(chan->state),\n\t       state_to_string(state));\n\n\tchan->state = state;\n\tchan->ops->state_change(chan, state, 0);\n}\n\nstatic inline void l2cap_state_change_and_error(struct l2cap_chan *chan,\n\t\t\t\t\t\tint state, int err)\n{\n\tchan->state = state;\n\tchan->ops->state_change(chan, chan->state, err);\n}\n\nstatic inline void l2cap_chan_set_err(struct l2cap_chan *chan, int err)\n{\n\tchan->ops->state_change(chan, chan->state, err);\n}\n\nstatic void __set_retrans_timer(struct l2cap_chan *chan)\n{\n\tif (!delayed_work_pending(&chan->monitor_timer) &&\n\t    chan->retrans_timeout) {\n\t\tl2cap_set_timer(chan, &chan->retrans_timer,\n\t\t\t\tmsecs_to_jiffies(chan->retrans_timeout));\n\t}\n}\n\nstatic void __set_monitor_timer(struct l2cap_chan *chan)\n{\n\t__clear_retrans_timer(chan);\n\tif (chan->monitor_timeout) {\n\t\tl2cap_set_timer(chan, &chan->monitor_timer,\n\t\t\t\tmsecs_to_jiffies(chan->monitor_timeout));\n\t}\n}\n\nstatic struct sk_buff *l2cap_ertm_seq_in_queue(struct sk_buff_head *head,\n\t\t\t\t\t       u16 seq)\n{\n\tstruct sk_buff *skb;\n\n\tskb_queue_walk(head, skb) {\n\t\tif (bt_cb(skb)->l2cap.txseq == seq)\n\t\t\treturn skb;\n\t}\n\n\treturn NULL;\n}\n\n/* ---- L2CAP sequence number lists ---- */\n\n/* For ERTM, ordered lists of sequence numbers must be tracked for\n * SREJ requests that are received and for frames that are to be\n * retransmitted. These seq_list functions implement a singly-linked\n * list in an array, where membership in the list can also be checked\n * in constant time. Items can also be added to the tail of the list\n * and removed from the head in constant time, without further memory\n * allocs or frees.\n */\n\nstatic int l2cap_seq_list_init(struct l2cap_seq_list *seq_list, u16 size)\n{\n\tsize_t alloc_size, i;\n\n\t/* Allocated size is a power of 2 to map sequence numbers\n\t * (which may be up to 14 bits) in to a smaller array that is\n\t * sized for the negotiated ERTM transmit windows.\n\t */\n\talloc_size = roundup_pow_of_two(size);\n\n\tseq_list->list = kmalloc_array(alloc_size, sizeof(u16), GFP_KERNEL);\n\tif (!seq_list->list)\n\t\treturn -ENOMEM;\n\n\tseq_list->mask = alloc_size - 1;\n\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n\tfor (i = 0; i < alloc_size; i++)\n\t\tseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\n\n\treturn 0;\n}\n\nstatic inline void l2cap_seq_list_free(struct l2cap_seq_list *seq_list)\n{\n\tkfree(seq_list->list);\n}\n\nstatic inline bool l2cap_seq_list_contains(struct l2cap_seq_list *seq_list,\n\t\t\t\t\t   u16 seq)\n{\n\t/* Constant-time check for list membership */\n\treturn seq_list->list[seq & seq_list->mask] != L2CAP_SEQ_LIST_CLEAR;\n}\n\nstatic inline u16 l2cap_seq_list_pop(struct l2cap_seq_list *seq_list)\n{\n\tu16 seq = seq_list->head;\n\tu16 mask = seq_list->mask;\n\n\tseq_list->head = seq_list->list[seq & mask];\n\tseq_list->list[seq & mask] = L2CAP_SEQ_LIST_CLEAR;\n\n\tif (seq_list->head == L2CAP_SEQ_LIST_TAIL) {\n\t\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\t\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n\t}\n\n\treturn seq;\n}\n\nstatic void l2cap_seq_list_clear(struct l2cap_seq_list *seq_list)\n{\n\tu16 i;\n\n\tif (seq_list->head == L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tfor (i = 0; i <= seq_list->mask; i++)\n\t\tseq_list->list[i] = L2CAP_SEQ_LIST_CLEAR;\n\n\tseq_list->head = L2CAP_SEQ_LIST_CLEAR;\n\tseq_list->tail = L2CAP_SEQ_LIST_CLEAR;\n}\n\nstatic void l2cap_seq_list_append(struct l2cap_seq_list *seq_list, u16 seq)\n{\n\tu16 mask = seq_list->mask;\n\n\t/* All appends happen in constant time */\n\n\tif (seq_list->list[seq & mask] != L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tif (seq_list->tail == L2CAP_SEQ_LIST_CLEAR)\n\t\tseq_list->head = seq;\n\telse\n\t\tseq_list->list[seq_list->tail & mask] = seq;\n\n\tseq_list->tail = seq;\n\tseq_list->list[seq & mask] = L2CAP_SEQ_LIST_TAIL;\n}\n\nstatic void l2cap_chan_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       chan_timer.work);\n\tstruct l2cap_conn *conn = chan->conn;\n\tint reason;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tmutex_lock(&conn->chan_lock);\n\t/* __set_chan_timer() calls l2cap_chan_hold(chan) while scheduling\n\t * this work. No need to call l2cap_chan_hold(chan) here again.\n\t */\n\tl2cap_chan_lock(chan);\n\n\tif (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)\n\t\treason = ECONNREFUSED;\n\telse if (chan->state == BT_CONNECT &&\n\t\t chan->sec_level != BT_SECURITY_SDP)\n\t\treason = ECONNREFUSED;\n\telse\n\t\treason = ETIMEDOUT;\n\n\tl2cap_chan_close(chan, reason);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstruct l2cap_chan *l2cap_chan_create(void)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = kzalloc(sizeof(*chan), GFP_ATOMIC);\n\tif (!chan)\n\t\treturn NULL;\n\n\tmutex_init(&chan->lock);\n\n\t/* Set default lock nesting level */\n\tatomic_set(&chan->nesting, L2CAP_NESTING_NORMAL);\n\n\twrite_lock(&chan_list_lock);\n\tlist_add(&chan->global_l, &chan_list);\n\twrite_unlock(&chan_list_lock);\n\n\tINIT_DELAYED_WORK(&chan->chan_timer, l2cap_chan_timeout);\n\n\tchan->state = BT_OPEN;\n\n\tkref_init(&chan->kref);\n\n\t/* This flag is cleared in l2cap_chan_ready() */\n\tset_bit(CONF_NOT_COMPLETE, &chan->conf_state);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\treturn chan;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_create);\n\nstatic void l2cap_chan_destroy(struct kref *kref)\n{\n\tstruct l2cap_chan *chan = container_of(kref, struct l2cap_chan, kref);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twrite_lock(&chan_list_lock);\n\tlist_del(&chan->global_l);\n\twrite_unlock(&chan_list_lock);\n\n\tkfree(chan);\n}\n\nvoid l2cap_chan_hold(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %d\", c, kref_read(&c->kref));\n\n\tkref_get(&c->kref);\n}\n\nvoid l2cap_chan_put(struct l2cap_chan *c)\n{\n\tBT_DBG(\"chan %p orig refcnt %d\", c, kref_read(&c->kref));\n\n\tkref_put(&c->kref, l2cap_chan_destroy);\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_put);\n\nvoid l2cap_chan_set_defaults(struct l2cap_chan *chan)\n{\n\tchan->fcs  = L2CAP_FCS_CRC16;\n\tchan->max_tx = L2CAP_DEFAULT_MAX_TX;\n\tchan->tx_win = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->remote_max_tx = chan->max_tx;\n\tchan->remote_tx_win = chan->tx_win;\n\tchan->ack_win = L2CAP_DEFAULT_TX_WINDOW;\n\tchan->sec_level = BT_SECURITY_LOW;\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\tchan->retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\tchan->monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\tchan->conf_state = 0;\n\n\tset_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_set_defaults);\n\nstatic void l2cap_le_flowctl_init(struct l2cap_chan *chan, u16 tx_credits)\n{\n\tchan->sdu = NULL;\n\tchan->sdu_last_frag = NULL;\n\tchan->sdu_len = 0;\n\tchan->tx_credits = tx_credits;\n\t/* Derive MPS from connection MTU to stop HCI fragmentation */\n\tchan->mps = min_t(u16, chan->imtu, chan->conn->mtu - L2CAP_HDR_SIZE);\n\t/* Give enough credits for a full packet */\n\tchan->rx_credits = (chan->imtu / chan->mps) + 1;\n\n\tskb_queue_head_init(&chan->tx_q);\n}\n\nstatic void l2cap_ecred_init(struct l2cap_chan *chan, u16 tx_credits)\n{\n\tl2cap_le_flowctl_init(chan, tx_credits);\n\n\t/* L2CAP implementations shall support a minimum MPS of 64 octets */\n\tif (chan->mps < L2CAP_ECRED_MIN_MPS) {\n\t\tchan->mps = L2CAP_ECRED_MIN_MPS;\n\t\tchan->rx_credits = (chan->imtu / chan->mps) + 1;\n\t}\n}\n\nvoid __l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\n{\n\tBT_DBG(\"conn %p, psm 0x%2.2x, dcid 0x%4.4x\", conn,\n\t       __le16_to_cpu(chan->psm), chan->dcid);\n\n\tconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\n\n\tchan->conn = conn;\n\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\t/* Alloc CID for connection-oriented socket */\n\t\tchan->scid = l2cap_alloc_cid(conn);\n\t\tif (conn->hcon->type == ACL_LINK)\n\t\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t\tbreak;\n\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\t/* Connectionless socket */\n\t\tchan->scid = L2CAP_CID_CONN_LESS;\n\t\tchan->dcid = L2CAP_CID_CONN_LESS;\n\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t\tbreak;\n\n\tcase L2CAP_CHAN_FIXED:\n\t\t/* Caller will set CID and CID specific MTU values */\n\t\tbreak;\n\n\tdefault:\n\t\t/* Raw socket can send/recv signalling messages only */\n\t\tchan->scid = L2CAP_CID_SIGNALING;\n\t\tchan->dcid = L2CAP_CID_SIGNALING;\n\t\tchan->omtu = L2CAP_DEFAULT_MTU;\n\t}\n\n\tchan->local_id\t\t= L2CAP_BESTEFFORT_ID;\n\tchan->local_stype\t= L2CAP_SERV_BESTEFFORT;\n\tchan->local_msdu\t= L2CAP_DEFAULT_MAX_SDU_SIZE;\n\tchan->local_sdu_itime\t= L2CAP_DEFAULT_SDU_ITIME;\n\tchan->local_acc_lat\t= L2CAP_DEFAULT_ACC_LAT;\n\tchan->local_flush_to\t= L2CAP_EFS_DEFAULT_FLUSH_TO;\n\n\tl2cap_chan_hold(chan);\n\n\t/* Only keep a reference for fixed channels if they requested it */\n\tif (chan->chan_type != L2CAP_CHAN_FIXED ||\n\t    test_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\n\t\thci_conn_hold(conn->hcon);\n\n\tlist_add(&chan->list, &conn->chan_l);\n}\n\nvoid l2cap_chan_add(struct l2cap_conn *conn, struct l2cap_chan *chan)\n{\n\tmutex_lock(&conn->chan_lock);\n\t__l2cap_chan_add(conn, chan);\n\tmutex_unlock(&conn->chan_lock);\n}\n\nvoid l2cap_chan_del(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\t__clear_chan_timer(chan);\n\n\tBT_DBG(\"chan %p, conn %p, err %d, state %s\", chan, conn, err,\n\t       state_to_string(chan->state));\n\n\tchan->ops->teardown(chan, err);\n\n\tif (conn) {\n\t\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\t\t/* Delete from channel list */\n\t\tlist_del(&chan->list);\n\n\t\tl2cap_chan_put(chan);\n\n\t\tchan->conn = NULL;\n\n\t\t/* Reference was only held for non-fixed channels or\n\t\t * fixed channels that explicitly requested it using the\n\t\t * FLAG_HOLD_HCI_CONN flag.\n\t\t */\n\t\tif (chan->chan_type != L2CAP_CHAN_FIXED ||\n\t\t    test_bit(FLAG_HOLD_HCI_CONN, &chan->flags))\n\t\t\thci_conn_drop(conn->hcon);\n\n\t\tif (mgr && mgr->bredr_chan == chan)\n\t\t\tmgr->bredr_chan = NULL;\n\t}\n\n\tif (chan->hs_hchan) {\n\t\tstruct hci_chan *hs_hchan = chan->hs_hchan;\n\n\t\tBT_DBG(\"chan %p disconnect hs_hchan %p\", chan, hs_hchan);\n\t\tamp_disconnect_logical_link(hs_hchan);\n\t}\n\n\tif (test_bit(CONF_NOT_COMPLETE, &chan->conf_state))\n\t\treturn;\n\n\tswitch(chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tskb_queue_purge(&chan->tx_q);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\t__clear_retrans_timer(chan);\n\t\t__clear_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\n\t\tskb_queue_purge(&chan->srej_q);\n\n\t\tl2cap_seq_list_free(&chan->srej_list);\n\t\tl2cap_seq_list_free(&chan->retrans_list);\n\t\tfallthrough;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tskb_queue_purge(&chan->tx_q);\n\t\tbreak;\n\t}\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_del);\n\nstatic void __l2cap_chan_list(struct l2cap_conn *conn, l2cap_chan_func_t func,\n\t\t\t      void *data)\n{\n\tstruct l2cap_chan *chan;\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tfunc(chan, data);\n\t}\n}\n\nvoid l2cap_chan_list(struct l2cap_conn *conn, l2cap_chan_func_t func,\n\t\t     void *data)\n{\n\tif (!conn)\n\t\treturn;\n\n\tmutex_lock(&conn->chan_lock);\n\t__l2cap_chan_list(conn, func, data);\n\tmutex_unlock(&conn->chan_lock);\n}\n\nEXPORT_SYMBOL_GPL(l2cap_chan_list);\n\nstatic void l2cap_conn_update_id_addr(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       id_addr_update_work);\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan;\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\t\tbacpy(&chan->dst, &hcon->dst);\n\t\tchan->dst_type = bdaddr_dst_type(hcon);\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_chan_le_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_LE_AUTHORIZATION;\n\telse\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\trsp.dcid    = cpu_to_le16(chan->scid);\n\trsp.mtu     = cpu_to_le16(chan->imtu);\n\trsp.mps     = cpu_to_le16(chan->mps);\n\trsp.credits = cpu_to_le16(chan->rx_credits);\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nstatic void l2cap_chan_ecred_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_ecred_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_LE_AUTHORIZATION;\n\telse\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nstatic void l2cap_chan_connect_reject(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_conn_rsp rsp;\n\tu16 result;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\telse\n\t\tresult = L2CAP_CR_BAD_PSM;\n\n\tl2cap_state_change(chan, BT_DISCONN);\n\n\trsp.scid   = cpu_to_le16(chan->dcid);\n\trsp.dcid   = cpu_to_le16(chan->scid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);\n}\n\nvoid l2cap_chan_close(struct l2cap_chan *chan, int reason)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\tswitch (chan->state) {\n\tcase BT_LISTEN:\n\t\tchan->ops->teardown(chan, 0);\n\t\tbreak;\n\n\tcase BT_CONNECTED:\n\tcase BT_CONFIG:\n\t\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\t\t\tl2cap_send_disconn_req(chan, reason);\n\t\t} else\n\t\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT2:\n\t\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tif (conn->hcon->type == ACL_LINK)\n\t\t\t\tl2cap_chan_connect_reject(chan);\n\t\t\telse if (conn->hcon->type == LE_LINK) {\n\t\t\t\tswitch (chan->mode) {\n\t\t\t\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\t\t\t\tl2cap_chan_le_connect_reject(chan);\n\t\t\t\t\tbreak;\n\t\t\t\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\t\t\t\tl2cap_chan_ecred_connect_reject(chan);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_DISCONN:\n\t\tl2cap_chan_del(chan, reason);\n\t\tbreak;\n\n\tdefault:\n\t\tchan->ops->teardown(chan, 0);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(l2cap_chan_close);\n\nstatic inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)\n{\n\tswitch (chan->chan_type) {\n\tcase L2CAP_CHAN_RAW:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\tcase BT_SECURITY_FIPS:\n\t\t\treturn HCI_AT_DEDICATED_BONDING_MITM;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\treturn HCI_AT_DEDICATED_BONDING;\n\t\tdefault:\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_LESS:\n\t\tif (chan->psm == cpu_to_le16(L2CAP_PSM_3DSP)) {\n\t\t\tif (chan->sec_level == BT_SECURITY_LOW)\n\t\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\t\t}\n\t\tif (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t    chan->sec_level == BT_SECURITY_FIPS)\n\t\t\treturn HCI_AT_NO_BONDING_MITM;\n\t\telse\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\tbreak;\n\tcase L2CAP_CHAN_CONN_ORIENTED:\n\t\tif (chan->psm == cpu_to_le16(L2CAP_PSM_SDP)) {\n\t\t\tif (chan->sec_level == BT_SECURITY_LOW)\n\t\t\t\tchan->sec_level = BT_SECURITY_SDP;\n\n\t\t\tif (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t\t    chan->sec_level == BT_SECURITY_FIPS)\n\t\t\t\treturn HCI_AT_NO_BONDING_MITM;\n\t\t\telse\n\t\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tswitch (chan->sec_level) {\n\t\tcase BT_SECURITY_HIGH:\n\t\tcase BT_SECURITY_FIPS:\n\t\t\treturn HCI_AT_GENERAL_BONDING_MITM;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\treturn HCI_AT_GENERAL_BONDING;\n\t\tdefault:\n\t\t\treturn HCI_AT_NO_BONDING;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/* Service level security */\nint l2cap_chan_check_security(struct l2cap_chan *chan, bool initiator)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\t__u8 auth_type;\n\n\tif (conn->hcon->type == LE_LINK)\n\t\treturn smp_conn_security(conn->hcon, chan->sec_level);\n\n\tauth_type = l2cap_get_auth_type(chan);\n\n\treturn hci_conn_security(conn->hcon, chan->sec_level, auth_type,\n\t\t\t\t initiator);\n}\n\nstatic u8 l2cap_get_ident(struct l2cap_conn *conn)\n{\n\tu8 id;\n\n\t/* Get next available identificator.\n\t *    1 - 128 are used by kernel.\n\t *  129 - 199 are reserved.\n\t *  200 - 254 are used by utilities like l2ping, etc.\n\t */\n\n\tmutex_lock(&conn->ident_lock);\n\n\tif (++conn->tx_ident > 128)\n\t\tconn->tx_ident = 1;\n\n\tid = conn->tx_ident;\n\n\tmutex_unlock(&conn->ident_lock);\n\n\treturn id;\n}\n\nstatic void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,\n\t\t\t   void *data)\n{\n\tstruct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);\n\tu8 flags;\n\n\tBT_DBG(\"code 0x%2.2x\", code);\n\n\tif (!skb)\n\t\treturn;\n\n\t/* Use NO_FLUSH if supported or we have an LE link (which does\n\t * not support auto-flushing packets) */\n\tif (lmp_no_flush_capable(conn->hcon->hdev) ||\n\t    conn->hcon->type == LE_LINK)\n\t\tflags = ACL_START_NO_FLUSH;\n\telse\n\t\tflags = ACL_START;\n\n\tbt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;\n\tskb->priority = HCI_PRIO_MAX;\n\n\thci_send_acl(conn->hchan, skb, flags);\n}\n\nstatic bool __chan_is_moving(struct l2cap_chan *chan)\n{\n\treturn chan->move_state != L2CAP_MOVE_STABLE &&\n\t       chan->move_state != L2CAP_MOVE_WAIT_PREPARE;\n}\n\nstatic void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = chan->conn->hcon;\n\tu16 flags;\n\n\tBT_DBG(\"chan %p, skb %p len %d priority %u\", chan, skb, skb->len,\n\t       skb->priority);\n\n\tif (chan->hs_hcon && !__chan_is_moving(chan)) {\n\t\tif (chan->hs_hchan)\n\t\t\thci_send_acl(chan->hs_hchan, skb, ACL_COMPLETE);\n\t\telse\n\t\t\tkfree_skb(skb);\n\n\t\treturn;\n\t}\n\n\t/* Use NO_FLUSH for LE links (where this is the only option) or\n\t * if the BR/EDR link supports it and flushing has not been\n\t * explicitly requested (through FLAG_FLUSHABLE).\n\t */\n\tif (hcon->type == LE_LINK ||\n\t    (!test_bit(FLAG_FLUSHABLE, &chan->flags) &&\n\t     lmp_no_flush_capable(hcon->hdev)))\n\t\tflags = ACL_START_NO_FLUSH;\n\telse\n\t\tflags = ACL_START;\n\n\tbt_cb(skb)->force_active = test_bit(FLAG_FORCE_ACTIVE, &chan->flags);\n\thci_send_acl(chan->conn->hchan, skb, flags);\n}\n\nstatic void __unpack_enhanced_control(u16 enh, struct l2cap_ctrl *control)\n{\n\tcontrol->reqseq = (enh & L2CAP_CTRL_REQSEQ) >> L2CAP_CTRL_REQSEQ_SHIFT;\n\tcontrol->final = (enh & L2CAP_CTRL_FINAL) >> L2CAP_CTRL_FINAL_SHIFT;\n\n\tif (enh & L2CAP_CTRL_FRAME_TYPE) {\n\t\t/* S-Frame */\n\t\tcontrol->sframe = 1;\n\t\tcontrol->poll = (enh & L2CAP_CTRL_POLL) >> L2CAP_CTRL_POLL_SHIFT;\n\t\tcontrol->super = (enh & L2CAP_CTRL_SUPERVISE) >> L2CAP_CTRL_SUPER_SHIFT;\n\n\t\tcontrol->sar = 0;\n\t\tcontrol->txseq = 0;\n\t} else {\n\t\t/* I-Frame */\n\t\tcontrol->sframe = 0;\n\t\tcontrol->sar = (enh & L2CAP_CTRL_SAR) >> L2CAP_CTRL_SAR_SHIFT;\n\t\tcontrol->txseq = (enh & L2CAP_CTRL_TXSEQ) >> L2CAP_CTRL_TXSEQ_SHIFT;\n\n\t\tcontrol->poll = 0;\n\t\tcontrol->super = 0;\n\t}\n}\n\nstatic void __unpack_extended_control(u32 ext, struct l2cap_ctrl *control)\n{\n\tcontrol->reqseq = (ext & L2CAP_EXT_CTRL_REQSEQ) >> L2CAP_EXT_CTRL_REQSEQ_SHIFT;\n\tcontrol->final = (ext & L2CAP_EXT_CTRL_FINAL) >> L2CAP_EXT_CTRL_FINAL_SHIFT;\n\n\tif (ext & L2CAP_EXT_CTRL_FRAME_TYPE) {\n\t\t/* S-Frame */\n\t\tcontrol->sframe = 1;\n\t\tcontrol->poll = (ext & L2CAP_EXT_CTRL_POLL) >> L2CAP_EXT_CTRL_POLL_SHIFT;\n\t\tcontrol->super = (ext & L2CAP_EXT_CTRL_SUPERVISE) >> L2CAP_EXT_CTRL_SUPER_SHIFT;\n\n\t\tcontrol->sar = 0;\n\t\tcontrol->txseq = 0;\n\t} else {\n\t\t/* I-Frame */\n\t\tcontrol->sframe = 0;\n\t\tcontrol->sar = (ext & L2CAP_EXT_CTRL_SAR) >> L2CAP_EXT_CTRL_SAR_SHIFT;\n\t\tcontrol->txseq = (ext & L2CAP_EXT_CTRL_TXSEQ) >> L2CAP_EXT_CTRL_TXSEQ_SHIFT;\n\n\t\tcontrol->poll = 0;\n\t\tcontrol->super = 0;\n\t}\n}\n\nstatic inline void __unpack_control(struct l2cap_chan *chan,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\t__unpack_extended_control(get_unaligned_le32(skb->data),\n\t\t\t\t\t  &bt_cb(skb)->l2cap);\n\t\tskb_pull(skb, L2CAP_EXT_CTRL_SIZE);\n\t} else {\n\t\t__unpack_enhanced_control(get_unaligned_le16(skb->data),\n\t\t\t\t\t  &bt_cb(skb)->l2cap);\n\t\tskb_pull(skb, L2CAP_ENH_CTRL_SIZE);\n\t}\n}\n\nstatic u32 __pack_extended_control(struct l2cap_ctrl *control)\n{\n\tu32 packed;\n\n\tpacked = control->reqseq << L2CAP_EXT_CTRL_REQSEQ_SHIFT;\n\tpacked |= control->final << L2CAP_EXT_CTRL_FINAL_SHIFT;\n\n\tif (control->sframe) {\n\t\tpacked |= control->poll << L2CAP_EXT_CTRL_POLL_SHIFT;\n\t\tpacked |= control->super << L2CAP_EXT_CTRL_SUPER_SHIFT;\n\t\tpacked |= L2CAP_EXT_CTRL_FRAME_TYPE;\n\t} else {\n\t\tpacked |= control->sar << L2CAP_EXT_CTRL_SAR_SHIFT;\n\t\tpacked |= control->txseq << L2CAP_EXT_CTRL_TXSEQ_SHIFT;\n\t}\n\n\treturn packed;\n}\n\nstatic u16 __pack_enhanced_control(struct l2cap_ctrl *control)\n{\n\tu16 packed;\n\n\tpacked = control->reqseq << L2CAP_CTRL_REQSEQ_SHIFT;\n\tpacked |= control->final << L2CAP_CTRL_FINAL_SHIFT;\n\n\tif (control->sframe) {\n\t\tpacked |= control->poll << L2CAP_CTRL_POLL_SHIFT;\n\t\tpacked |= control->super << L2CAP_CTRL_SUPER_SHIFT;\n\t\tpacked |= L2CAP_CTRL_FRAME_TYPE;\n\t} else {\n\t\tpacked |= control->sar << L2CAP_CTRL_SAR_SHIFT;\n\t\tpacked |= control->txseq << L2CAP_CTRL_TXSEQ_SHIFT;\n\t}\n\n\treturn packed;\n}\n\nstatic inline void __pack_control(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\tput_unaligned_le32(__pack_extended_control(control),\n\t\t\t\t   skb->data + L2CAP_HDR_SIZE);\n\t} else {\n\t\tput_unaligned_le16(__pack_enhanced_control(control),\n\t\t\t\t   skb->data + L2CAP_HDR_SIZE);\n\t}\n}\n\nstatic inline unsigned int __ertm_hdr_size(struct l2cap_chan *chan)\n{\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\treturn L2CAP_EXT_HDR_SIZE;\n\telse\n\t\treturn L2CAP_ENH_HDR_SIZE;\n}\n\nstatic struct sk_buff *l2cap_create_sframe_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t       u32 control)\n{\n\tstruct sk_buff *skb;\n\tstruct l2cap_hdr *lh;\n\tint hlen = __ertm_hdr_size(chan);\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\thlen += L2CAP_FCS_SIZE;\n\n\tskb = bt_skb_alloc(hlen, GFP_KERNEL);\n\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tput_unaligned_le32(control, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\n\telse\n\t\tput_unaligned_le16(control, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\n\n\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\tu16 fcs = crc16(0, (u8 *)skb->data, skb->len);\n\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t}\n\n\tskb->priority = HCI_PRIO_MAX;\n\treturn skb;\n}\n\nstatic void l2cap_send_sframe(struct l2cap_chan *chan,\n\t\t\t      struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\tu32 control_field;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (!control->sframe)\n\t\treturn;\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state) &&\n\t    !control->poll)\n\t\tcontrol->final = 1;\n\n\tif (control->super == L2CAP_SUPER_RR)\n\t\tclear_bit(CONN_RNR_SENT, &chan->conn_state);\n\telse if (control->super == L2CAP_SUPER_RNR)\n\t\tset_bit(CONN_RNR_SENT, &chan->conn_state);\n\n\tif (control->super != L2CAP_SUPER_SREJ) {\n\t\tchan->last_acked_seq = control->reqseq;\n\t\t__clear_ack_timer(chan);\n\t}\n\n\tBT_DBG(\"reqseq %d, final %d, poll %d, super %d\", control->reqseq,\n\t       control->final, control->poll, control->super);\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tcontrol_field = __pack_extended_control(control);\n\telse\n\t\tcontrol_field = __pack_enhanced_control(control);\n\n\tskb = l2cap_create_sframe_pdu(chan, control_field);\n\tif (!IS_ERR(skb))\n\t\tl2cap_do_send(chan, skb);\n}\n\nstatic void l2cap_send_rr_or_rnr(struct l2cap_chan *chan, bool poll)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p, poll %d\", chan, poll);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.poll = poll;\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\telse\n\t\tcontrol.super = L2CAP_SUPER_RR;\n\n\tcontrol.reqseq = chan->buffer_seq;\n\tl2cap_send_sframe(chan, &control);\n}\n\nstatic inline int __l2cap_no_conn_pending(struct l2cap_chan *chan)\n{\n\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\n\t\treturn true;\n\n\treturn !test_bit(CONF_CONNECT_PEND, &chan->conf_state);\n}\n\nstatic bool __amp_capable(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct hci_dev *hdev;\n\tbool amp_available = false;\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn false;\n\n\tif (!(conn->remote_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn false;\n\n\tread_lock(&hci_dev_list_lock);\n\tlist_for_each_entry(hdev, &hci_dev_list, list) {\n\t\tif (hdev->amp_type != AMP_TYPE_BREDR &&\n\t\t    test_bit(HCI_UP, &hdev->flags)) {\n\t\t\tamp_available = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&hci_dev_list_lock);\n\n\tif (chan->chan_policy == BT_CHANNEL_POLICY_AMP_PREFERRED)\n\t\treturn amp_available;\n\n\treturn false;\n}\n\nstatic bool l2cap_check_efs(struct l2cap_chan *chan)\n{\n\t/* Check EFS parameters */\n\treturn true;\n}\n\nvoid l2cap_send_conn_req(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_conn_req req;\n\n\treq.scid = cpu_to_le16(chan->scid);\n\treq.psm  = chan->psm;\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_REQ, sizeof(req), &req);\n}\n\nstatic void l2cap_send_create_chan_req(struct l2cap_chan *chan, u8 amp_id)\n{\n\tstruct l2cap_create_chan_req req;\n\treq.scid = cpu_to_le16(chan->scid);\n\treq.psm  = chan->psm;\n\treq.amp_id = amp_id;\n\n\tchan->ident = l2cap_get_ident(chan->conn);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstatic void l2cap_move_setup(struct l2cap_chan *chan)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\t__clear_retrans_timer(chan);\n\t__clear_monitor_timer(chan);\n\t__clear_ack_timer(chan);\n\n\tchan->retry_count = 0;\n\tskb_queue_walk(&chan->tx_q, skb) {\n\t\tif (bt_cb(skb)->l2cap.retries)\n\t\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tchan->expected_tx_seq = chan->buffer_seq;\n\n\tclear_bit(CONN_REJ_ACT, &chan->conn_state);\n\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\tl2cap_seq_list_clear(&chan->retrans_list);\n\tl2cap_seq_list_clear(&chan->srej_list);\n\tskb_queue_purge(&chan->srej_q);\n\n\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\tchan->rx_state = L2CAP_RX_STATE_MOVE;\n\n\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n}\n\nstatic void l2cap_move_done(struct l2cap_chan *chan)\n{\n\tu8 move_role = chan->move_role;\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\tswitch (move_role) {\n\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_EXPLICIT_POLL);\n\t\tchan->rx_state = L2CAP_RX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\tchan->rx_state = L2CAP_RX_STATE_WAIT_P;\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_chan_ready(struct l2cap_chan *chan)\n{\n\t/* The channel may have already been flagged as connected in\n\t * case of receiving data before the L2CAP info req/rsp\n\t * procedure is complete.\n\t */\n\tif (chan->state == BT_CONNECTED)\n\t\treturn;\n\n\t/* This clears all conf flags, including CONF_NOT_COMPLETE */\n\tchan->conf_state = 0;\n\t__clear_chan_timer(chan);\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!chan->tx_credits)\n\t\t\tchan->ops->suspend(chan);\n\t\tbreak;\n\t}\n\n\tchan->state = BT_CONNECTED;\n\n\tchan->ops->ready(chan);\n}\n\nstatic void l2cap_le_connect(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_conn_req req;\n\n\tif (test_and_set_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tif (!chan->imtu)\n\t\tchan->imtu = chan->conn->mtu;\n\n\tl2cap_le_flowctl_init(chan, 0);\n\n\treq.psm     = chan->psm;\n\treq.scid    = cpu_to_le16(chan->scid);\n\treq.mtu     = cpu_to_le16(chan->imtu);\n\treq.mps     = cpu_to_le16(chan->mps);\n\treq.credits = cpu_to_le16(chan->rx_credits);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstruct l2cap_ecred_conn_data {\n\tstruct {\n\t\tstruct l2cap_ecred_conn_req req;\n\t\t__le16 scid[5];\n\t} __packed pdu;\n\tstruct l2cap_chan *chan;\n\tstruct pid *pid;\n\tint count;\n};\n\nstatic void l2cap_ecred_defer_connect(struct l2cap_chan *chan, void *data)\n{\n\tstruct l2cap_ecred_conn_data *conn = data;\n\tstruct pid *pid;\n\n\tif (chan == conn->chan)\n\t\treturn;\n\n\tif (!test_and_clear_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tpid = chan->ops->get_peer_pid(chan);\n\n\t/* Only add deferred channels with the same PID/PSM */\n\tif (conn->pid != pid || chan->psm != conn->chan->psm || chan->ident ||\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL || chan->state != BT_CONNECT)\n\t\treturn;\n\n\tif (test_and_set_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tl2cap_ecred_init(chan, 0);\n\n\t/* Set the same ident so we can match on the rsp */\n\tchan->ident = conn->chan->ident;\n\n\t/* Include all channels deferred */\n\tconn->pdu.scid[conn->count] = cpu_to_le16(chan->scid);\n\n\tconn->count++;\n}\n\nstatic void l2cap_ecred_connect(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_ecred_conn_data data;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tif (test_and_set_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags))\n\t\treturn;\n\n\tl2cap_ecred_init(chan, 0);\n\n\tdata.pdu.req.psm     = chan->psm;\n\tdata.pdu.req.mtu     = cpu_to_le16(chan->imtu);\n\tdata.pdu.req.mps     = cpu_to_le16(chan->mps);\n\tdata.pdu.req.credits = cpu_to_le16(chan->rx_credits);\n\tdata.pdu.scid[0]     = cpu_to_le16(chan->scid);\n\n\tchan->ident = l2cap_get_ident(conn);\n\tdata.pid = chan->ops->get_peer_pid(chan);\n\n\tdata.count = 1;\n\tdata.chan = chan;\n\tdata.pid = chan->ops->get_peer_pid(chan);\n\n\t__l2cap_chan_list(conn, l2cap_ecred_defer_connect, &data);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_ECRED_CONN_REQ,\n\t\t       sizeof(data.pdu.req) + data.count * sizeof(__le16),\n\t\t       &data.pdu);\n}\n\nstatic void l2cap_le_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (!smp_conn_security(conn->hcon, chan->sec_level))\n\t\treturn;\n\n\tif (!chan->psm) {\n\t\tl2cap_chan_ready(chan);\n\t\treturn;\n\t}\n\n\tif (chan->state == BT_CONNECT) {\n\t\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL)\n\t\t\tl2cap_ecred_connect(chan);\n\t\telse\n\t\t\tl2cap_le_connect(chan);\n\t}\n}\n\nstatic void l2cap_start_connection(struct l2cap_chan *chan)\n{\n\tif (__amp_capable(chan)) {\n\t\tBT_DBG(\"chan %p AMP capable: discover AMPs\", chan);\n\t\ta2mp_discover_amp(chan);\n\t} else if (chan->conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t} else {\n\t\tl2cap_send_conn_req(chan);\n\t}\n}\n\nstatic void l2cap_request_info(struct l2cap_conn *conn)\n{\n\tstruct l2cap_info_req req;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\treturn;\n\n\treq.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\tconn->info_ident = l2cap_get_ident(conn);\n\n\tschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\n\n\tl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\n\t\t       sizeof(req), &req);\n}\n\nstatic bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\t/* The minimum encryption key size needs to be enforced by the\n\t * host stack before establishing any L2CAP connections. The\n\t * specification in theory allows a minimum of 1, but to align\n\t * BR/EDR and LE transports, a minimum of 7 is chosen.\n\t *\n\t * This check might also be called for unencrypted connections\n\t * that have no key size requirements. Ensure that the link is\n\t * actually encrypted before enforcing a key size.\n\t */\n\tint min_key_size = hcon->hdev->min_enc_key_size;\n\n\t/* On FIPS security level, key size must be 16 bytes */\n\tif (hcon->sec_level == BT_SECURITY_FIPS)\n\t\tmin_key_size = 16;\n\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size >= min_key_size);\n}\n\nstatic void l2cap_do_start(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tif (conn->hcon->type == LE_LINK) {\n\t\tl2cap_le_start(chan);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)) {\n\t\tl2cap_request_info(conn);\n\t\treturn;\n\t}\n\n\tif (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))\n\t\treturn;\n\n\tif (!l2cap_chan_check_security(chan, true) ||\n\t    !__l2cap_no_conn_pending(chan))\n\t\treturn;\n\n\tif (l2cap_check_enc_key_size(conn->hcon))\n\t\tl2cap_start_connection(chan);\n\telse\n\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n}\n\nstatic inline int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (!disable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;\n\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}\n\nstatic void l2cap_send_disconn_req(struct l2cap_chan *chan, int err)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_disconn_req req;\n\n\tif (!conn)\n\t\treturn;\n\n\tif (chan->mode == L2CAP_MODE_ERTM && chan->state == BT_CONNECTED) {\n\t\t__clear_retrans_timer(chan);\n\t\t__clear_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\t}\n\n\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\treturn;\n\t}\n\n\treq.dcid = cpu_to_le16(chan->dcid);\n\treq.scid = cpu_to_le16(chan->scid);\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_DISCONN_REQ,\n\t\t       sizeof(req), &req);\n\n\tl2cap_state_change_and_error(chan, BT_DISCONN, err);\n}\n\n/* ---- L2CAP connections ---- */\nstatic void l2cap_conn_start(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan, *tmp;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry_safe(chan, tmp, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tl2cap_chan_ready(chan);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!l2cap_chan_check_security(chan, true) ||\n\t\t\t    !__l2cap_no_conn_pending(chan)) {\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!l2cap_mode_supported(chan->mode, conn->feat_mask)\n\t\t\t    && test_bit(CONF_STATE2_DEVICE,\n\t\t\t\t\t&chan->conf_state)) {\n\t\t\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (l2cap_check_enc_key_size(conn->hcon))\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\tl2cap_chan_close(chan, ECONNREFUSED);\n\n\t\t} else if (chan->state == BT_CONNECT2) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\tchar buf[128];\n\t\t\trsp.scid = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid = cpu_to_le16(chan->scid);\n\n\t\t\tif (l2cap_chan_check_security(chan, false)) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);\n\t\t\t\t\tchan->ops->defer(chan);\n\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trsp.result = cpu_to_le16(L2CAP_CR_PEND);\n\t\t\t\trsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (test_bit(CONF_REQ_SENT, &chan->conf_state) ||\n\t\t\t    rsp.result != L2CAP_CR_SUCCESS) {\n\t\t\t\tl2cap_chan_unlock(chan);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\t\tchan->num_conf_req++;\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_le_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct hci_dev *hdev = hcon->hdev;\n\n\tBT_DBG(\"%s conn %p\", hdev->name, conn);\n\n\t/* For outgoing pairing which doesn't necessarily have an\n\t * associated socket (e.g. mgmt_pair_device).\n\t */\n\tif (hcon->out)\n\t\tsmp_conn_security(hcon, hcon->pending_sec_level);\n\n\t/* For LE slave connections, make sure the connection interval\n\t * is in the range of the minium and maximum interval that has\n\t * been configured for this connection. If not, then trigger\n\t * the connection update procedure.\n\t */\n\tif (hcon->role == HCI_ROLE_SLAVE &&\n\t    (hcon->le_conn_interval < hcon->le_conn_min_interval ||\n\t     hcon->le_conn_interval > hcon->le_conn_max_interval)) {\n\t\tstruct l2cap_conn_param_update_req req;\n\n\t\treq.min = cpu_to_le16(hcon->le_conn_min_interval);\n\t\treq.max = cpu_to_le16(hcon->le_conn_max_interval);\n\t\treq.latency = cpu_to_le16(hcon->le_conn_latency);\n\t\treq.to_multiplier = cpu_to_le16(hcon->le_supv_timeout);\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t       L2CAP_CONN_PARAM_UPDATE_REQ, sizeof(req), &req);\n\t}\n}\n\nstatic void l2cap_conn_ready(struct l2cap_conn *conn)\n{\n\tstruct l2cap_chan *chan;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tif (hcon->type == ACL_LINK)\n\t\tl2cap_request_info(conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\n\t\tl2cap_chan_lock(chan);\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hcon->type == LE_LINK) {\n\t\t\tl2cap_le_start(chan);\n\t\t} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\n\t\t\t\tl2cap_chan_ready(chan);\n\t\t} else if (chan->state == BT_CONNECT) {\n\t\t\tl2cap_do_start(chan);\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\tif (hcon->type == LE_LINK)\n\t\tl2cap_le_conn_ready(conn);\n\n\tqueue_work(hcon->hdev->workqueue, &conn->pending_rx_work);\n}\n\n/* Notify sockets that we cannot guaranty reliability anymore */\nstatic void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)\n{\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (test_bit(FLAG_FORCE_RELIABLE, &chan->flags))\n\t\t\tl2cap_chan_set_err(chan, err);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\nstatic void l2cap_info_timeout(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       info_timer.work);\n\n\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\tconn->info_ident = 0;\n\n\tl2cap_conn_start(conn);\n}\n\n/*\n * l2cap_user\n * External modules can register l2cap_user objects on l2cap_conn. The ->probe\n * callback is called during registration. The ->remove callback is called\n * during unregistration.\n * An l2cap_user object can either be explicitly unregistered or when the\n * underlying l2cap_conn object is deleted. This guarantees that l2cap->hcon,\n * l2cap->hchan, .. are valid as long as the remove callback hasn't been called.\n * External modules must own a reference to the l2cap_conn object if they intend\n * to call l2cap_unregister_user(). The l2cap_conn object might get destroyed at\n * any time if they don't.\n */\n\nint l2cap_register_user(struct l2cap_conn *conn, struct l2cap_user *user)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tint ret;\n\n\t/* We need to check whether l2cap_conn is registered. If it is not, we\n\t * must not register the l2cap_user. l2cap_conn_del() is unregisters\n\t * l2cap_conn objects, but doesn't provide its own locking. Instead, it\n\t * relies on the parent hci_conn object to be locked. This itself relies\n\t * on the hci_dev object to be locked. So we must lock the hci device\n\t * here, too. */\n\n\thci_dev_lock(hdev);\n\n\tif (!list_empty(&user->list)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* conn->hchan is NULL after l2cap_conn_del() was called */\n\tif (!conn->hchan) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tret = user->probe(conn, user);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tlist_add(&user->list, &conn->users);\n\tret = 0;\n\nout_unlock:\n\thci_dev_unlock(hdev);\n\treturn ret;\n}\nEXPORT_SYMBOL(l2cap_register_user);\n\nvoid l2cap_unregister_user(struct l2cap_conn *conn, struct l2cap_user *user)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\n\thci_dev_lock(hdev);\n\n\tif (list_empty(&user->list))\n\t\tgoto out_unlock;\n\n\tlist_del_init(&user->list);\n\tuser->remove(conn, user);\n\nout_unlock:\n\thci_dev_unlock(hdev);\n}\nEXPORT_SYMBOL(l2cap_unregister_user);\n\nstatic void l2cap_unregister_all_users(struct l2cap_conn *conn)\n{\n\tstruct l2cap_user *user;\n\n\twhile (!list_empty(&conn->users)) {\n\t\tuser = list_first_entry(&conn->users, struct l2cap_user, list);\n\t\tlist_del_init(&user->list);\n\t\tuser->remove(conn, user);\n\t}\n}\n\nstatic void l2cap_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan, *l;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\tkfree_skb(conn->rx_skb);\n\n\tskb_queue_purge(&conn->pending_rx);\n\n\t/* We can not call flush_work(&conn->pending_rx_work) here since we\n\t * might block if we are running on a worker from the same workqueue\n\t * pending_rx_work is waiting on.\n\t */\n\tif (work_pending(&conn->pending_rx_work))\n\t\tcancel_work_sync(&conn->pending_rx_work);\n\n\tif (work_pending(&conn->id_addr_update_work))\n\t\tcancel_work_sync(&conn->id_addr_update_work);\n\n\tl2cap_unregister_all_users(conn);\n\n\t/* Force the connection to be immediately dropped */\n\thcon->disc_timeout = 0;\n\n\tmutex_lock(&conn->chan_lock);\n\n\t/* Kill channels */\n\tlist_for_each_entry_safe(chan, l, &conn->chan_l, list) {\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\tl2cap_chan_del(chan, err);\n\n\t\tchan->ops->close(chan);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\thci_chan_del(conn->hchan);\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)\n\t\tcancel_delayed_work_sync(&conn->info_timer);\n\n\thcon->l2cap_data = NULL;\n\tconn->hchan = NULL;\n\tl2cap_conn_put(conn);\n}\n\nstatic void l2cap_conn_free(struct kref *ref)\n{\n\tstruct l2cap_conn *conn = container_of(ref, struct l2cap_conn, ref);\n\n\thci_conn_put(conn->hcon);\n\tkfree(conn);\n}\n\nstruct l2cap_conn *l2cap_conn_get(struct l2cap_conn *conn)\n{\n\tkref_get(&conn->ref);\n\treturn conn;\n}\nEXPORT_SYMBOL(l2cap_conn_get);\n\nvoid l2cap_conn_put(struct l2cap_conn *conn)\n{\n\tkref_put(&conn->ref, l2cap_conn_free);\n}\nEXPORT_SYMBOL(l2cap_conn_put);\n\n/* ---- Socket interface ---- */\n\n/* Find socket with psm and source / destination bdaddr.\n * Returns closest match.\n */\nstatic struct l2cap_chan *l2cap_global_chan_by_psm(int state, __le16 psm,\n\t\t\t\t\t\t   bdaddr_t *src,\n\t\t\t\t\t\t   bdaddr_t *dst,\n\t\t\t\t\t\t   u8 link_type)\n{\n\tstruct l2cap_chan *c, *c1 = NULL;\n\n\tread_lock(&chan_list_lock);\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (state && c->state != state)\n\t\t\tcontinue;\n\n\t\tif (link_type == ACL_LINK && c->src_type != BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (link_type == LE_LINK && c->src_type == BDADDR_BREDR)\n\t\t\tcontinue;\n\n\t\tif (c->psm == psm) {\n\t\t\tint src_match, dst_match;\n\t\t\tint src_any, dst_any;\n\n\t\t\t/* Exact match. */\n\t\t\tsrc_match = !bacmp(&c->src, src);\n\t\t\tdst_match = !bacmp(&c->dst, dst);\n\t\t\tif (src_match && dst_match) {\n\t\t\t\tl2cap_chan_hold(c);\n\t\t\t\tread_unlock(&chan_list_lock);\n\t\t\t\treturn c;\n\t\t\t}\n\n\t\t\t/* Closest match */\n\t\t\tsrc_any = !bacmp(&c->src, BDADDR_ANY);\n\t\t\tdst_any = !bacmp(&c->dst, BDADDR_ANY);\n\t\t\tif ((src_match && dst_any) || (src_any && dst_match) ||\n\t\t\t    (src_any && dst_any))\n\t\t\t\tc1 = c;\n\t\t}\n\t}\n\n\tif (c1)\n\t\tl2cap_chan_hold(c1);\n\n\tread_unlock(&chan_list_lock);\n\n\treturn c1;\n}\n\nstatic void l2cap_monitor_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       monitor_timer.work);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tif (!chan->conn) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\n\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_MONITOR_TO);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_retrans_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       retrans_timer.work);\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tif (!chan->conn) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\n\tl2cap_tx(chan, NULL, NULL, L2CAP_EV_RETRANS_TO);\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nstatic void l2cap_streaming_send(struct l2cap_chan *chan,\n\t\t\t\t struct sk_buff_head *skbs)\n{\n\tstruct sk_buff *skb;\n\tstruct l2cap_ctrl *control;\n\n\tBT_DBG(\"chan %p, skbs %p\", chan, skbs);\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\n\twhile (!skb_queue_empty(&chan->tx_q)) {\n\n\t\tskb = skb_dequeue(&chan->tx_q);\n\n\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\tcontrol = &bt_cb(skb)->l2cap;\n\n\t\tcontrol->reqseq = 0;\n\t\tcontrol->txseq = chan->next_tx_seq;\n\n\t\t__pack_control(chan, control, skb);\n\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\n\t\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\n\t\tBT_DBG(\"Sent txseq %u\", control->txseq);\n\n\t\tchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\n\t\tchan->frames_sent++;\n\t}\n}\n\nstatic int l2cap_ertm_send(struct l2cap_chan *chan)\n{\n\tstruct sk_buff *skb, *tx_skb;\n\tstruct l2cap_ctrl *control;\n\tint sent = 0;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->state != BT_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn 0;\n\n\tif (__chan_is_moving(chan))\n\t\treturn 0;\n\n\twhile (chan->tx_send_head &&\n\t       chan->unacked_frames < chan->remote_tx_win &&\n\t       chan->tx_state == L2CAP_TX_STATE_XMIT) {\n\n\t\tskb = chan->tx_send_head;\n\n\t\tbt_cb(skb)->l2cap.retries = 1;\n\t\tcontrol = &bt_cb(skb)->l2cap;\n\n\t\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\n\t\t\tcontrol->final = 1;\n\n\t\tcontrol->reqseq = chan->buffer_seq;\n\t\tchan->last_acked_seq = chan->buffer_seq;\n\t\tcontrol->txseq = chan->next_tx_seq;\n\n\t\t__pack_control(chan, control, skb);\n\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) skb->data, skb->len);\n\t\t\tput_unaligned_le16(fcs, skb_put(skb, L2CAP_FCS_SIZE));\n\t\t}\n\n\t\t/* Clone after data has been modified. Data is assumed to be\n\t\t   read-only (for locking purposes) on cloned sk_buffs.\n\t\t */\n\t\ttx_skb = skb_clone(skb, GFP_KERNEL);\n\n\t\tif (!tx_skb)\n\t\t\tbreak;\n\n\t\t__set_retrans_timer(chan);\n\n\t\tchan->next_tx_seq = __next_seq(chan, chan->next_tx_seq);\n\t\tchan->unacked_frames++;\n\t\tchan->frames_sent++;\n\t\tsent++;\n\n\t\tif (skb_queue_is_last(&chan->tx_q, skb))\n\t\t\tchan->tx_send_head = NULL;\n\t\telse\n\t\t\tchan->tx_send_head = skb_queue_next(&chan->tx_q, skb);\n\n\t\tl2cap_do_send(chan, tx_skb);\n\t\tBT_DBG(\"Sent txseq %u\", control->txseq);\n\t}\n\n\tBT_DBG(\"Sent %d, %u unacked, %u in ERTM queue\", sent,\n\t       chan->unacked_frames, skb_queue_len(&chan->tx_q));\n\n\treturn sent;\n}\n\nstatic void l2cap_ertm_resend(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *tx_skb;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn;\n\n\tif (__chan_is_moving(chan))\n\t\treturn;\n\n\twhile (chan->retrans_list.head != L2CAP_SEQ_LIST_CLEAR) {\n\t\tseq = l2cap_seq_list_pop(&chan->retrans_list);\n\n\t\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, seq);\n\t\tif (!skb) {\n\t\t\tBT_DBG(\"Error: Can't retransmit seq %d, frame missing\",\n\t\t\t       seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbt_cb(skb)->l2cap.retries++;\n\t\tcontrol = bt_cb(skb)->l2cap;\n\n\t\tif (chan->max_tx != 0 &&\n\t\t    bt_cb(skb)->l2cap.retries > chan->max_tx) {\n\t\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\t\tbreak;\n\t\t}\n\n\t\tcontrol.reqseq = chan->buffer_seq;\n\t\tif (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))\n\t\t\tcontrol.final = 1;\n\t\telse\n\t\t\tcontrol.final = 0;\n\n\t\tif (skb_cloned(skb)) {\n\t\t\t/* Cloned sk_buffs are read-only, so we need a\n\t\t\t * writeable copy\n\t\t\t */\n\t\t\ttx_skb = skb_copy(skb, GFP_KERNEL);\n\t\t} else {\n\t\t\ttx_skb = skb_clone(skb, GFP_KERNEL);\n\t\t}\n\n\t\tif (!tx_skb) {\n\t\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Update skb contents */\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags)) {\n\t\t\tput_unaligned_le32(__pack_extended_control(&control),\n\t\t\t\t\t   tx_skb->data + L2CAP_HDR_SIZE);\n\t\t} else {\n\t\t\tput_unaligned_le16(__pack_enhanced_control(&control),\n\t\t\t\t\t   tx_skb->data + L2CAP_HDR_SIZE);\n\t\t}\n\n\t\t/* Update FCS */\n\t\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\t\tu16 fcs = crc16(0, (u8 *) tx_skb->data,\n\t\t\t\t\ttx_skb->len - L2CAP_FCS_SIZE);\n\t\t\tput_unaligned_le16(fcs, skb_tail_pointer(tx_skb) -\n\t\t\t\t\t\tL2CAP_FCS_SIZE);\n\t\t}\n\n\t\tl2cap_do_send(chan, tx_skb);\n\n\t\tBT_DBG(\"Resent txseq %d\", control.txseq);\n\n\t\tchan->last_acked_seq = chan->buffer_seq;\n\t}\n}\n\nstatic void l2cap_retransmit(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tl2cap_seq_list_append(&chan->retrans_list, control->reqseq);\n\tl2cap_ertm_resend(chan);\n}\n\nstatic void l2cap_retransmit_all(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->poll)\n\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\n\tl2cap_seq_list_clear(&chan->retrans_list);\n\n\tif (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))\n\t\treturn;\n\n\tif (chan->unacked_frames) {\n\t\tskb_queue_walk(&chan->tx_q, skb) {\n\t\t\tif (bt_cb(skb)->l2cap.txseq == control->reqseq ||\n\t\t\t    skb == chan->tx_send_head)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tskb_queue_walk_from(&chan->tx_q, skb) {\n\t\t\tif (skb == chan->tx_send_head)\n\t\t\t\tbreak;\n\n\t\t\tl2cap_seq_list_append(&chan->retrans_list,\n\t\t\t\t\t      bt_cb(skb)->l2cap.txseq);\n\t\t}\n\n\t\tl2cap_ertm_resend(chan);\n\t}\n}\n\nstatic void l2cap_send_ack(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\tu16 frames_to_ack = __seq_offset(chan, chan->buffer_seq,\n\t\t\t\t\t chan->last_acked_seq);\n\tint threshold;\n\n\tBT_DBG(\"chan %p last_acked_seq %d buffer_seq %d\",\n\t       chan, chan->last_acked_seq, chan->buffer_seq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\n\t    chan->rx_state == L2CAP_RX_STATE_RECV) {\n\t\t__clear_ack_timer(chan);\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\t\tcontrol.reqseq = chan->buffer_seq;\n\t\tl2cap_send_sframe(chan, &control);\n\t} else {\n\t\tif (!test_bit(CONN_REMOTE_BUSY, &chan->conn_state)) {\n\t\t\tl2cap_ertm_send(chan);\n\t\t\t/* If any i-frames were sent, they included an ack */\n\t\t\tif (chan->buffer_seq == chan->last_acked_seq)\n\t\t\t\tframes_to_ack = 0;\n\t\t}\n\n\t\t/* Ack now if the window is 3/4ths full.\n\t\t * Calculate without mul or div\n\t\t */\n\t\tthreshold = chan->ack_win;\n\t\tthreshold += threshold << 1;\n\t\tthreshold >>= 2;\n\n\t\tBT_DBG(\"frames_to_ack %u, threshold %d\", frames_to_ack,\n\t\t       threshold);\n\n\t\tif (frames_to_ack >= threshold) {\n\t\t\t__clear_ack_timer(chan);\n\t\t\tcontrol.super = L2CAP_SUPER_RR;\n\t\t\tcontrol.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &control);\n\t\t\tframes_to_ack = 0;\n\t\t}\n\n\t\tif (frames_to_ack)\n\t\t\t__set_ack_timer(chan);\n\t}\n}\n\nstatic inline int l2cap_skbuff_fromiovec(struct l2cap_chan *chan,\n\t\t\t\t\t struct msghdr *msg, int len,\n\t\t\t\t\t int count, struct sk_buff *skb)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff **frag;\n\tint sent = 0;\n\n\tif (!copy_from_iter_full(skb_put(skb, count), count, &msg->msg_iter))\n\t\treturn -EFAULT;\n\n\tsent += count;\n\tlen  -= count;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tstruct sk_buff *tmp;\n\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\ttmp = chan->ops->alloc_skb(chan, 0, count,\n\t\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn PTR_ERR(tmp);\n\n\t\t*frag = tmp;\n\n\t\tif (!copy_from_iter_full(skb_put(*frag, count), count,\n\t\t\t\t   &msg->msg_iter))\n\t\t\treturn -EFAULT;\n\n\t\tsent += count;\n\t\tlen  -= count;\n\n\t\tskb->len += (*frag)->len;\n\t\tskb->data_len += (*frag)->len;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn sent;\n}\n\nstatic struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t\t struct msghdr *msg, size_t len)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen = L2CAP_HDR_SIZE + L2CAP_PSMLEN_SIZE;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p psm 0x%2.2x len %zu\", chan,\n\t       __le16_to_cpu(chan->psm), len);\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + L2CAP_PSMLEN_SIZE);\n\tput_unaligned(chan->psm, (__le16 *) skb_put(skb, L2CAP_PSMLEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tcount = min_t(unsigned int, (conn->mtu - L2CAP_HDR_SIZE), len);\n\n\tskb = chan->ops->alloc_skb(chan, L2CAP_HDR_SIZE, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len);\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn skb;\n}\n\nstatic struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t       struct msghdr *msg, size_t len,\n\t\t\t\t\t       u16 sdulen)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\thlen = __ertm_hdr_size(chan);\n\n\tif (sdulen)\n\t\thlen += L2CAP_SDULEN_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\thlen += L2CAP_FCS_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\t/* Control header is populated later */\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\tput_unaligned_le32(0, skb_put(skb, L2CAP_EXT_CTRL_SIZE));\n\telse\n\t\tput_unaligned_le16(0, skb_put(skb, L2CAP_ENH_CTRL_SIZE));\n\n\tif (sdulen)\n\t\tput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tbt_cb(skb)->l2cap.fcs = chan->fcs;\n\tbt_cb(skb)->l2cap.retries = 0;\n\treturn skb;\n}\n\nstatic int l2cap_segment_sdu(struct l2cap_chan *chan,\n\t\t\t     struct sk_buff_head *seg_queue,\n\t\t\t     struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tu16 sdu_len;\n\tsize_t pdu_len;\n\tu8 sar;\n\n\tBT_DBG(\"chan %p, msg %p, len %zu\", chan, msg, len);\n\n\t/* It is critical that ERTM PDUs fit in a single HCI fragment,\n\t * so fragmented skbs are not used.  The HCI layer's handling\n\t * of fragmented skbs is not compatible with ERTM's queueing.\n\t */\n\n\t/* PDU size is derived from the HCI MTU */\n\tpdu_len = chan->conn->mtu;\n\n\t/* Constrain PDU size for BR/EDR connections */\n\tif (!chan->hs_hcon)\n\t\tpdu_len = min_t(size_t, pdu_len, L2CAP_BREDR_MAX_PAYLOAD);\n\n\t/* Adjust for largest possible L2CAP overhead. */\n\tif (chan->fcs)\n\t\tpdu_len -= L2CAP_FCS_SIZE;\n\n\tpdu_len -= __ertm_hdr_size(chan);\n\n\t/* Remote device may have requested smaller PDUs */\n\tpdu_len = min_t(size_t, pdu_len, chan->remote_mps);\n\n\tif (len <= pdu_len) {\n\t\tsar = L2CAP_SAR_UNSEGMENTED;\n\t\tsdu_len = 0;\n\t\tpdu_len = len;\n\t} else {\n\t\tsar = L2CAP_SAR_START;\n\t\tsdu_len = len;\n\t}\n\n\twhile (len > 0) {\n\t\tskb = l2cap_create_iframe_pdu(chan, msg, pdu_len, sdu_len);\n\n\t\tif (IS_ERR(skb)) {\n\t\t\t__skb_queue_purge(seg_queue);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\tbt_cb(skb)->l2cap.sar = sar;\n\t\t__skb_queue_tail(seg_queue, skb);\n\n\t\tlen -= pdu_len;\n\t\tif (sdu_len)\n\t\t\tsdu_len = 0;\n\n\t\tif (len <= pdu_len) {\n\t\t\tsar = L2CAP_SAR_END;\n\t\t\tpdu_len = len;\n\t\t} else {\n\t\t\tsar = L2CAP_SAR_CONTINUE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *l2cap_create_le_flowctl_pdu(struct l2cap_chan *chan,\n\t\t\t\t\t\t   struct msghdr *msg,\n\t\t\t\t\t\t   size_t len, u16 sdulen)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct sk_buff *skb;\n\tint err, count, hlen;\n\tstruct l2cap_hdr *lh;\n\n\tBT_DBG(\"chan %p len %zu\", chan, len);\n\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOTCONN);\n\n\thlen = L2CAP_HDR_SIZE;\n\n\tif (sdulen)\n\t\thlen += L2CAP_SDULEN_SIZE;\n\n\tcount = min_t(unsigned int, (conn->mtu - hlen), len);\n\n\tskb = chan->ops->alloc_skb(chan, hlen, count,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT);\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\t/* Create L2CAP header */\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->cid = cpu_to_le16(chan->dcid);\n\tlh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));\n\n\tif (sdulen)\n\t\tput_unaligned_le16(sdulen, skb_put(skb, L2CAP_SDULEN_SIZE));\n\n\terr = l2cap_skbuff_fromiovec(chan, msg, len, count, skb);\n\tif (unlikely(err < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int l2cap_segment_le_sdu(struct l2cap_chan *chan,\n\t\t\t\tstruct sk_buff_head *seg_queue,\n\t\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tsize_t pdu_len;\n\tu16 sdu_len;\n\n\tBT_DBG(\"chan %p, msg %p, len %zu\", chan, msg, len);\n\n\tsdu_len = len;\n\tpdu_len = chan->remote_mps - L2CAP_SDULEN_SIZE;\n\n\twhile (len > 0) {\n\t\tif (len <= pdu_len)\n\t\t\tpdu_len = len;\n\n\t\tskb = l2cap_create_le_flowctl_pdu(chan, msg, pdu_len, sdu_len);\n\t\tif (IS_ERR(skb)) {\n\t\t\t__skb_queue_purge(seg_queue);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\t__skb_queue_tail(seg_queue, skb);\n\n\t\tlen -= pdu_len;\n\n\t\tif (sdu_len) {\n\t\t\tsdu_len = 0;\n\t\t\tpdu_len += L2CAP_SDULEN_SIZE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void l2cap_le_flowctl_send(struct l2cap_chan *chan)\n{\n\tint sent = 0;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (chan->tx_credits && !skb_queue_empty(&chan->tx_q)) {\n\t\tl2cap_do_send(chan, skb_dequeue(&chan->tx_q));\n\t\tchan->tx_credits--;\n\t\tsent++;\n\t}\n\n\tBT_DBG(\"Sent %d credits %u queued %u\", sent, chan->tx_credits,\n\t       skb_queue_len(&chan->tx_q));\n}\n\nint l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct sk_buff_head seg_queue;\n\n\tif (!chan->conn)\n\t\treturn -ENOTCONN;\n\n\t/* Connectionless channel */\n\tif (chan->chan_type == L2CAP_CHAN_CONN_LESS) {\n\t\tskb = l2cap_create_connless_pdu(chan, msg, len);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\t/* Channel lock is released before requesting new skb and then\n\t\t * reacquired thus we need to recheck channel state.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\t\treturn len;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu)\n\t\t\treturn -EMSGSIZE;\n\n\t\t__skb_queue_head_init(&seg_queue);\n\n\t\terr = l2cap_segment_le_sdu(chan, &seg_queue, msg, len);\n\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\t__skb_queue_purge(&seg_queue);\n\t\t\terr = -ENOTCONN;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tskb_queue_splice_tail_init(&seg_queue, &chan->tx_q);\n\n\t\tl2cap_le_flowctl_send(chan);\n\n\t\tif (!chan->tx_credits)\n\t\t\tchan->ops->suspend(chan);\n\n\t\terr = len;\n\n\t\tbreak;\n\n\tcase L2CAP_MODE_BASIC:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu)\n\t\t\treturn -EMSGSIZE;\n\n\t\t/* Create a basic PDU */\n\t\tskb = l2cap_create_basic_pdu(chan, msg, len);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\t/* Channel lock is released before requesting new skb and then\n\t\t * reacquired thus we need to recheck channel state.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\n\t\tl2cap_do_send(chan, skb);\n\t\terr = len;\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\t/* Check outgoing MTU */\n\t\tif (len > chan->omtu) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\t__skb_queue_head_init(&seg_queue);\n\n\t\t/* Do segmentation before calling in to the state machine,\n\t\t * since it's possible to block while waiting for memory\n\t\t * allocation.\n\t\t */\n\t\terr = l2cap_segment_sdu(chan, &seg_queue, msg, len);\n\n\t\t/* The channel could have been closed while segmenting,\n\t\t * check that it is still connected.\n\t\t */\n\t\tif (chan->state != BT_CONNECTED) {\n\t\t\t__skb_queue_purge(&seg_queue);\n\t\t\terr = -ENOTCONN;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM)\n\t\t\tl2cap_tx(chan, NULL, &seg_queue, L2CAP_EV_DATA_REQUEST);\n\t\telse\n\t\t\tl2cap_streaming_send(chan, &seg_queue);\n\n\t\terr = len;\n\n\t\t/* If the skbs were not queued for sending, they'll still be in\n\t\t * seg_queue and need to be purged.\n\t\t */\n\t\t__skb_queue_purge(&seg_queue);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_DBG(\"bad state %1.1x\", chan->mode);\n\t\terr = -EBADFD;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_send);\n\nstatic void l2cap_send_srej(struct l2cap_chan *chan, u16 txseq)\n{\n\tstruct l2cap_ctrl control;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p, txseq %u\", chan, txseq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\n\tfor (seq = chan->expected_tx_seq; seq != txseq;\n\t     seq = __next_seq(chan, seq)) {\n\t\tif (!l2cap_ertm_seq_in_queue(&chan->srej_q, seq)) {\n\t\t\tcontrol.reqseq = seq;\n\t\t\tl2cap_send_sframe(chan, &control);\n\t\t\tl2cap_seq_list_append(&chan->srej_list, seq);\n\t\t}\n\t}\n\n\tchan->expected_tx_seq = __next_seq(chan, txseq);\n}\n\nstatic void l2cap_send_srej_tail(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->srej_list.tail == L2CAP_SEQ_LIST_CLEAR)\n\t\treturn;\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\tcontrol.reqseq = chan->srej_list.tail;\n\tl2cap_send_sframe(chan, &control);\n}\n\nstatic void l2cap_send_srej_list(struct l2cap_chan *chan, u16 txseq)\n{\n\tstruct l2cap_ctrl control;\n\tu16 initial_head;\n\tu16 seq;\n\n\tBT_DBG(\"chan %p, txseq %u\", chan, txseq);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.super = L2CAP_SUPER_SREJ;\n\n\t/* Capture initial list head to allow only one pass through the list. */\n\tinitial_head = chan->srej_list.head;\n\n\tdo {\n\t\tseq = l2cap_seq_list_pop(&chan->srej_list);\n\t\tif (seq == txseq || seq == L2CAP_SEQ_LIST_CLEAR)\n\t\t\tbreak;\n\n\t\tcontrol.reqseq = seq;\n\t\tl2cap_send_sframe(chan, &control);\n\t\tl2cap_seq_list_append(&chan->srej_list, seq);\n\t} while (chan->srej_list.head != initial_head);\n}\n\nstatic void l2cap_process_reqseq(struct l2cap_chan *chan, u16 reqseq)\n{\n\tstruct sk_buff *acked_skb;\n\tu16 ackseq;\n\n\tBT_DBG(\"chan %p, reqseq %u\", chan, reqseq);\n\n\tif (chan->unacked_frames == 0 || reqseq == chan->expected_ack_seq)\n\t\treturn;\n\n\tBT_DBG(\"expected_ack_seq %u, unacked_frames %u\",\n\t       chan->expected_ack_seq, chan->unacked_frames);\n\n\tfor (ackseq = chan->expected_ack_seq; ackseq != reqseq;\n\t     ackseq = __next_seq(chan, ackseq)) {\n\n\t\tacked_skb = l2cap_ertm_seq_in_queue(&chan->tx_q, ackseq);\n\t\tif (acked_skb) {\n\t\t\tskb_unlink(acked_skb, &chan->tx_q);\n\t\t\tkfree_skb(acked_skb);\n\t\t\tchan->unacked_frames--;\n\t\t}\n\t}\n\n\tchan->expected_ack_seq = reqseq;\n\n\tif (chan->unacked_frames == 0)\n\t\t__clear_retrans_timer(chan);\n\n\tBT_DBG(\"unacked_frames %u\", chan->unacked_frames);\n}\n\nstatic void l2cap_abort_rx_srej_sent(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->expected_tx_seq = chan->buffer_seq;\n\tl2cap_seq_list_clear(&chan->srej_list);\n\tskb_queue_purge(&chan->srej_q);\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n}\n\nstatic void l2cap_tx_state_xmit(struct l2cap_chan *chan,\n\t\t\t\tstruct l2cap_ctrl *control,\n\t\t\t\tstruct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d\", chan, control, skbs,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_DATA_REQUEST:\n\t\tif (chan->tx_send_head == NULL)\n\t\t\tchan->tx_send_head = skb_peek(skbs);\n\n\t\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\t\tl2cap_ertm_send(chan);\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_DETECTED:\n\t\tBT_DBG(\"Enter LOCAL_BUSY\");\n\t\tset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\t\t/* The SREJ_SENT state must be aborted if we are to\n\t\t\t * enter the LOCAL_BUSY state.\n\t\t\t */\n\t\t\tl2cap_abort_rx_srej_sent(chan);\n\t\t}\n\n\t\tl2cap_send_ack(chan);\n\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_CLEAR:\n\t\tBT_DBG(\"Exit LOCAL_BUSY\");\n\t\tclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\n\t\t\tstruct l2cap_ctrl local_control;\n\n\t\t\tmemset(&local_control, 0, sizeof(local_control));\n\t\t\tlocal_control.sframe = 1;\n\t\t\tlocal_control.super = L2CAP_SUPER_RR;\n\t\t\tlocal_control.poll = 1;\n\t\t\tlocal_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &local_control);\n\n\t\t\tchan->retry_count = 1;\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\n\t\tl2cap_process_reqseq(chan, control->reqseq);\n\t\tbreak;\n\tcase L2CAP_EV_EXPLICIT_POLL:\n\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\tchan->retry_count = 1;\n\t\t__set_monitor_timer(chan);\n\t\t__clear_ack_timer(chan);\n\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_EV_RETRANS_TO:\n\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\tchan->retry_count = 1;\n\t\t__set_monitor_timer(chan);\n\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\tbreak;\n\tcase L2CAP_EV_RECV_FBIT:\n\t\t/* Nothing to process */\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_tx_state_wait_f(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control,\n\t\t\t\t  struct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d\", chan, control, skbs,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_DATA_REQUEST:\n\t\tif (chan->tx_send_head == NULL)\n\t\t\tchan->tx_send_head = skb_peek(skbs);\n\t\t/* Queue data, but don't send. */\n\t\tskb_queue_splice_tail_init(skbs, &chan->tx_q);\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_DETECTED:\n\t\tBT_DBG(\"Enter LOCAL_BUSY\");\n\t\tset_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\t\t/* The SREJ_SENT state must be aborted if we are to\n\t\t\t * enter the LOCAL_BUSY state.\n\t\t\t */\n\t\t\tl2cap_abort_rx_srej_sent(chan);\n\t\t}\n\n\t\tl2cap_send_ack(chan);\n\n\t\tbreak;\n\tcase L2CAP_EV_LOCAL_BUSY_CLEAR:\n\t\tBT_DBG(\"Exit LOCAL_BUSY\");\n\t\tclear_bit(CONN_LOCAL_BUSY, &chan->conn_state);\n\n\t\tif (test_bit(CONN_RNR_SENT, &chan->conn_state)) {\n\t\t\tstruct l2cap_ctrl local_control;\n\t\t\tmemset(&local_control, 0, sizeof(local_control));\n\t\t\tlocal_control.sframe = 1;\n\t\t\tlocal_control.super = L2CAP_SUPER_RR;\n\t\t\tlocal_control.poll = 1;\n\t\t\tlocal_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &local_control);\n\n\t\t\tchan->retry_count = 1;\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->tx_state = L2CAP_TX_STATE_WAIT_F;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REQSEQ_AND_FBIT:\n\t\tl2cap_process_reqseq(chan, control->reqseq);\n\t\tfallthrough;\n\n\tcase L2CAP_EV_RECV_FBIT:\n\t\tif (control && control->final) {\n\t\t\t__clear_monitor_timer(chan);\n\t\t\tif (chan->unacked_frames > 0)\n\t\t\t\t__set_retrans_timer(chan);\n\t\t\tchan->retry_count = 0;\n\t\t\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\t\t\tBT_DBG(\"recv fbit tx_state 0x2.2%x\", chan->tx_state);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_EXPLICIT_POLL:\n\t\t/* Ignore */\n\t\tbreak;\n\tcase L2CAP_EV_MONITOR_TO:\n\t\tif (chan->max_tx == 0 || chan->retry_count < chan->max_tx) {\n\t\t\tl2cap_send_rr_or_rnr(chan, 1);\n\t\t\t__set_monitor_timer(chan);\n\t\t\tchan->retry_count++;\n\t\t} else {\n\t\t\tl2cap_send_disconn_req(chan, ECONNABORTED);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t     struct sk_buff_head *skbs, u8 event)\n{\n\tBT_DBG(\"chan %p, control %p, skbs %p, event %d, state %d\",\n\t       chan, control, skbs, event, chan->tx_state);\n\n\tswitch (chan->tx_state) {\n\tcase L2CAP_TX_STATE_XMIT:\n\t\tl2cap_tx_state_xmit(chan, control, skbs, event);\n\t\tbreak;\n\tcase L2CAP_TX_STATE_WAIT_F:\n\t\tl2cap_tx_state_wait_f(chan, control, skbs, event);\n\t\tbreak;\n\tdefault:\n\t\t/* Ignore event */\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_pass_to_tx(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\tl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_REQSEQ_AND_FBIT);\n}\n\nstatic void l2cap_pass_to_tx_fbit(struct l2cap_chan *chan,\n\t\t\t\t  struct l2cap_ctrl *control)\n{\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\tl2cap_tx(chan, control, NULL, L2CAP_EV_RECV_FBIT);\n}\n\n/* Copy frame to all raw sockets on that connection */\nstatic void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"conn %p\", conn);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->chan_type != L2CAP_CHAN_RAW)\n\t\t\tcontinue;\n\n\t\t/* Don't send frame to the channel it came from */\n\t\tif (bt_cb(skb)->l2cap.chan == chan)\n\t\t\tcontinue;\n\n\t\tnskb = skb_clone(skb, GFP_KERNEL);\n\t\tif (!nskb)\n\t\t\tcontinue;\n\t\tif (chan->ops->recv(chan, nskb))\n\t\t\tkfree_skb(nskb);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\n/* ---- L2CAP signalling commands ---- */\nstatic struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn, u8 code,\n\t\t\t\t       u8 ident, u16 dlen, void *data)\n{\n\tstruct sk_buff *skb, **frag;\n\tstruct l2cap_cmd_hdr *cmd;\n\tstruct l2cap_hdr *lh;\n\tint len, count;\n\n\tBT_DBG(\"conn %p, code 0x%2.2x, ident 0x%2.2x, len %u\",\n\t       conn, code, ident, dlen);\n\n\tif (conn->mtu < L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE)\n\t\treturn NULL;\n\n\tlen = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;\n\tcount = min_t(unsigned int, conn->mtu, len);\n\n\tskb = bt_skb_alloc(count, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlh = skb_put(skb, L2CAP_HDR_SIZE);\n\tlh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);\n\n\tif (conn->hcon->type == LE_LINK)\n\t\tlh->cid = cpu_to_le16(L2CAP_CID_LE_SIGNALING);\n\telse\n\t\tlh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);\n\n\tcmd = skb_put(skb, L2CAP_CMD_HDR_SIZE);\n\tcmd->code  = code;\n\tcmd->ident = ident;\n\tcmd->len   = cpu_to_le16(dlen);\n\n\tif (dlen) {\n\t\tcount -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;\n\t\tskb_put_data(skb, data, count);\n\t\tdata += count;\n\t}\n\n\tlen -= skb->len;\n\n\t/* Continuation fragments (no L2CAP header) */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tcount = min_t(unsigned int, conn->mtu, len);\n\n\t\t*frag = bt_skb_alloc(count, GFP_KERNEL);\n\t\tif (!*frag)\n\t\t\tgoto fail;\n\n\t\tskb_put_data(*frag, data, count);\n\n\t\tlen  -= count;\n\t\tdata += count;\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\treturn skb;\n\nfail:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,\n\t\t\t\t     unsigned long *val)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\tint len;\n\n\tlen = L2CAP_CONF_OPT_SIZE + opt->len;\n\t*ptr += len;\n\n\t*type = opt->type;\n\t*olen = opt->len;\n\n\tswitch (opt->len) {\n\tcase 1:\n\t\t*val = *((u8 *) opt->val);\n\t\tbreak;\n\n\tcase 2:\n\t\t*val = get_unaligned_le16(opt->val);\n\t\tbreak;\n\n\tcase 4:\n\t\t*val = get_unaligned_le32(opt->val);\n\t\tbreak;\n\n\tdefault:\n\t\t*val = (unsigned long) opt->val;\n\t\tbreak;\n\t}\n\n\tBT_DBG(\"type 0x%2.2x len %u val 0x%lx\", *type, opt->len, *val);\n\treturn len;\n}\n\nstatic void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)\n{\n\tstruct l2cap_conf_opt *opt = *ptr;\n\n\tBT_DBG(\"type 0x%2.2x len %u val 0x%lx\", type, len, val);\n\n\tif (size < L2CAP_CONF_OPT_SIZE + len)\n\t\treturn;\n\n\topt->type = type;\n\topt->len  = len;\n\n\tswitch (len) {\n\tcase 1:\n\t\t*((u8 *) opt->val)  = val;\n\t\tbreak;\n\n\tcase 2:\n\t\tput_unaligned_le16(val, opt->val);\n\t\tbreak;\n\n\tcase 4:\n\t\tput_unaligned_le32(val, opt->val);\n\t\tbreak;\n\n\tdefault:\n\t\tmemcpy(opt->val, (void *) val, len);\n\t\tbreak;\n\t}\n\n\t*ptr += L2CAP_CONF_OPT_SIZE + len;\n}\n\nstatic void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)\n{\n\tstruct l2cap_conf_efs efs;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tefs.id\t\t= chan->local_id;\n\t\tefs.stype\t= chan->local_stype;\n\t\tefs.msdu\t= cpu_to_le16(chan->local_msdu);\n\t\tefs.sdu_itime\t= cpu_to_le32(chan->local_sdu_itime);\n\t\tefs.acc_lat\t= cpu_to_le32(L2CAP_DEFAULT_ACC_LAT);\n\t\tefs.flush_to\t= cpu_to_le32(L2CAP_EFS_DEFAULT_FLUSH_TO);\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tefs.id\t\t= 1;\n\t\tefs.stype\t= L2CAP_SERV_BESTEFFORT;\n\t\tefs.msdu\t= cpu_to_le16(chan->local_msdu);\n\t\tefs.sdu_itime\t= cpu_to_le32(chan->local_sdu_itime);\n\t\tefs.acc_lat\t= 0;\n\t\tefs.flush_to\t= 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tl2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t   (unsigned long) &efs, size);\n}\n\nstatic void l2cap_ack_timeout(struct work_struct *work)\n{\n\tstruct l2cap_chan *chan = container_of(work, struct l2cap_chan,\n\t\t\t\t\t       ack_timer.work);\n\tu16 frames_to_ack;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tl2cap_chan_lock(chan);\n\n\tframes_to_ack = __seq_offset(chan, chan->buffer_seq,\n\t\t\t\t     chan->last_acked_seq);\n\n\tif (frames_to_ack)\n\t\tl2cap_send_rr_or_rnr(chan, 0);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n}\n\nint l2cap_ertm_init(struct l2cap_chan *chan)\n{\n\tint err;\n\n\tchan->next_tx_seq = 0;\n\tchan->expected_tx_seq = 0;\n\tchan->expected_ack_seq = 0;\n\tchan->unacked_frames = 0;\n\tchan->buffer_seq = 0;\n\tchan->frames_sent = 0;\n\tchan->last_acked_seq = 0;\n\tchan->sdu = NULL;\n\tchan->sdu_last_frag = NULL;\n\tchan->sdu_len = 0;\n\n\tskb_queue_head_init(&chan->tx_q);\n\n\tchan->local_amp_id = AMP_ID_BREDR;\n\tchan->move_id = AMP_ID_BREDR;\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn 0;\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\tchan->tx_state = L2CAP_TX_STATE_XMIT;\n\n\tINIT_DELAYED_WORK(&chan->retrans_timer, l2cap_retrans_timeout);\n\tINIT_DELAYED_WORK(&chan->monitor_timer, l2cap_monitor_timeout);\n\tINIT_DELAYED_WORK(&chan->ack_timer, l2cap_ack_timeout);\n\n\tskb_queue_head_init(&chan->srej_q);\n\n\terr = l2cap_seq_list_init(&chan->srej_list, chan->tx_win);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = l2cap_seq_list_init(&chan->retrans_list, chan->remote_tx_win);\n\tif (err < 0)\n\t\tl2cap_seq_list_free(&chan->srej_list);\n\n\treturn err;\n}\n\nstatic inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\t\tfallthrough;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}\n\nstatic inline bool __l2cap_ews_supported(struct l2cap_conn *conn)\n{\n\treturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\n\t\t(conn->feat_mask & L2CAP_FEAT_EXT_WINDOW));\n}\n\nstatic inline bool __l2cap_efs_supported(struct l2cap_conn *conn)\n{\n\treturn ((conn->local_fixed_chan & L2CAP_FC_A2MP) &&\n\t\t(conn->feat_mask & L2CAP_FEAT_EXT_FLOW));\n}\n\nstatic void __l2cap_set_ertm_timeouts(struct l2cap_chan *chan,\n\t\t\t\t      struct l2cap_conf_rfc *rfc)\n{\n\tif (chan->local_amp_id != AMP_ID_BREDR && chan->hs_hcon) {\n\t\tu64 ertm_to = chan->hs_hcon->hdev->amp_be_flush_to;\n\n\t\t/* Class 1 devices have must have ERTM timeouts\n\t\t * exceeding the Link Supervision Timeout.  The\n\t\t * default Link Supervision Timeout for AMP\n\t\t * controllers is 10 seconds.\n\t\t *\n\t\t * Class 1 devices use 0xffffffff for their\n\t\t * best-effort flush timeout, so the clamping logic\n\t\t * will result in a timeout that meets the above\n\t\t * requirement.  ERTM timeouts are 16-bit values, so\n\t\t * the maximum timeout is 65.535 seconds.\n\t\t */\n\n\t\t/* Convert timeout to milliseconds and round */\n\t\tertm_to = DIV_ROUND_UP_ULL(ertm_to, 1000);\n\n\t\t/* This is the recommended formula for class 2 devices\n\t\t * that start ERTM timers when packets are sent to the\n\t\t * controller.\n\t\t */\n\t\tertm_to = 3 * ertm_to + 500;\n\n\t\tif (ertm_to > 0xffff)\n\t\t\tertm_to = 0xffff;\n\n\t\trfc->retrans_timeout = cpu_to_le16((u16) ertm_to);\n\t\trfc->monitor_timeout = rfc->retrans_timeout;\n\t} else {\n\t\trfc->retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc->monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t}\n}\n\nstatic inline void l2cap_txwin_setup(struct l2cap_chan *chan)\n{\n\tif (chan->tx_win > L2CAP_DEFAULT_TX_WINDOW &&\n\t    __l2cap_ews_supported(chan->conn)) {\n\t\t/* use extended control field */\n\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t} else {\n\t\tchan->tx_win = min_t(u16, chan->tx_win,\n\t\t\t\t     L2CAP_DEFAULT_TX_WINDOW);\n\t\tchan->tx_win_max = L2CAP_DEFAULT_TX_WINDOW;\n\t}\n\tchan->ack_win = chan->tx_win;\n}\n\nstatic void l2cap_mtu_auto(struct l2cap_chan *chan)\n{\n\tstruct hci_conn *conn = chan->conn->hcon;\n\n\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\n\t/* The 2-DH1 packet has between 2 and 56 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH1))\n\t\tchan->imtu = 54;\n\n\t/* The 3-DH1 packet has between 2 and 85 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH1))\n\t\tchan->imtu = 83;\n\n\t/* The 2-DH3 packet has between 2 and 369 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH3))\n\t\tchan->imtu = 367;\n\n\t/* The 3-DH3 packet has between 2 and 554 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH3))\n\t\tchan->imtu = 552;\n\n\t/* The 2-DH5 packet has between 2 and 681 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_2DH5))\n\t\tchan->imtu = 679;\n\n\t/* The 3-DH5 packet has between 2 and 1023 information bytes\n\t * (including the 2-byte payload header)\n\t */\n\tif (!(conn->pkt_type & HCI_3DH5))\n\t\tchan->imtu = 1021;\n}\n\nstatic int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = chan->mode };\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + data_size;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->num_conf_req || chan->num_conf_rsp)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\n\t\tfallthrough;\n\tdefault:\n\t\tchan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->imtu != L2CAP_DEFAULT_MTU) {\n\t\tif (!chan->imtu)\n\t\t\tl2cap_mtu_auto(chan);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t   endptr - ptr);\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (disable_ertm)\n\t\t\tbreak;\n\n\t\tif (!(chan->conn->feat_mask & L2CAP_FEAT_ERTM) &&\n\t\t    !(chan->conn->feat_mask & L2CAP_FEAT_STREAMING))\n\t\t\tbreak;\n\n\t\trfc.mode            = L2CAP_MODE_BASIC;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\t\trfc.max_pdu_size    = 0;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.max_transmit    = chan->max_tx;\n\n\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\tsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\n\t\t\t     L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\n\t\t\t     L2CAP_FCS_SIZE);\n\t\trfc.max_pdu_size = cpu_to_le16(size);\n\n\t\tl2cap_txwin_setup(chan);\n\n\t\trfc.txwin_size = min_t(u16, chan->tx_win,\n\t\t\t\t       L2CAP_DEFAULT_TX_WINDOW);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\n\t\t\tl2cap_add_opt_efs(&ptr, chan, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\n\t\tif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\n\t\t\tif (chan->fcs == L2CAP_FCS_NONE ||\n\t\t\t    test_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\n\t\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\n\t\t\t\t\t\t   chan->fcs, endptr - ptr);\n\t\t\t}\n\t\tbreak;\n\n\tcase L2CAP_MODE_STREAMING:\n\t\tl2cap_txwin_setup(chan);\n\t\trfc.mode            = L2CAP_MODE_STREAMING;\n\t\trfc.txwin_size      = 0;\n\t\trfc.max_transmit    = 0;\n\t\trfc.retrans_timeout = 0;\n\t\trfc.monitor_timeout = 0;\n\n\t\tsize = min_t(u16, L2CAP_DEFAULT_MAX_PDU_SIZE, chan->conn->mtu -\n\t\t\t     L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE -\n\t\t\t     L2CAP_FCS_SIZE);\n\t\trfc.max_pdu_size = cpu_to_le16(size);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags))\n\t\t\tl2cap_add_opt_efs(&ptr, chan, endptr - ptr);\n\n\t\tif (chan->conn->feat_mask & L2CAP_FEAT_FCS)\n\t\t\tif (chan->fcs == L2CAP_FCS_NONE ||\n\t\t\t    test_bit(CONF_RECV_NO_FCS, &chan->conf_state)) {\n\t\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1,\n\t\t\t\t\t\t   chan->fcs, endptr - ptr);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\treq->dcid  = cpu_to_le16(chan->dcid);\n\treq->flags = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\tvoid *endptr = data + data_size;\n\tvoid *req = chan->conf_req;\n\tint len = chan->conf_len;\n\tint type, hint, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\tu8 remote_efs = 0;\n\tu16 mtu = L2CAP_DEFAULT_MTU;\n\tu16 result = L2CAP_CONF_SUCCESS;\n\tu16 size;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&req, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\thint  = type & L2CAP_CONF_HINT;\n\t\ttype &= L2CAP_CONF_MASK;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tmtu = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_QOS:\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\tset_bit(CONF_RECV_NO_FCS, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tremote_efs = 1;\n\t\t\tmemcpy(&efs, (void *) val, olen);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tset_bit(FLAG_EXT_CTRL, &chan->flags);\n\t\t\tset_bit(CONF_EWS_RECV, &chan->conf_state);\n\t\t\tchan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW;\n\t\t\tchan->remote_tx_win = val;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\tl2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->num_conf_rsp || chan->num_conf_req > 1)\n\t\tgoto done;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {\n\t\t\tchan->mode = l2cap_select_mode(rfc.mode,\n\t\t\t\t\t\t       chan->conn->feat_mask);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remote_efs) {\n\t\t\tif (__l2cap_efs_supported(chan->conn))\n\t\t\t\tset_bit(FLAG_EFS_ENABLE, &chan->flags);\n\t\t\telse\n\t\t\t\treturn -ECONNREFUSED;\n\t\t}\n\n\t\tif (chan->mode != rfc.mode)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tbreak;\n\t}\n\ndone:\n\tif (chan->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = chan->mode;\n\n\t\tif (chan->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tchan->omtu = mtu;\n\t\t\tset_bit(CONF_MTU_DONE, &chan->conf_state);\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr);\n\n\t\tif (remote_efs) {\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype) {\n\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\t\tif (chan->num_conf_req >= 1)\n\t\t\t\t\treturn -ECONNREFUSED;\n\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t} else {\n\t\t\t\t/* Send PENDING Conf Rsp */\n\t\t\t\tresult = L2CAP_CONF_PENDING;\n\t\t\t\tset_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\t\t\t}\n\t\t}\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tif (!test_bit(CONF_EWS_RECV, &chan->conf_state))\n\t\t\t\tchan->remote_tx_win = rfc.txwin_size;\n\t\t\telse\n\t\t\t\trfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW;\n\n\t\t\tchan->remote_max_tx = rfc.max_transmit;\n\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\t__l2cap_set_ertm_timeouts(chan, &rfc);\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\t   sizeof(rfc), (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->remote_id = efs.id;\n\t\t\t\tchan->remote_stype = efs.stype;\n\t\t\t\tchan->remote_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->remote_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t\tchan->remote_acc_lat =\n\t\t\t\t\tle32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->remote_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS,\n\t\t\t\t\t\t   sizeof(efs),\n\t\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tsize = min_t(u16, le16_to_cpu(rfc.max_pdu_size),\n\t\t\t\t     chan->conn->mtu - L2CAP_EXT_HDR_SIZE -\n\t\t\t\t     L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE);\n\t\t\trfc.max_pdu_size = cpu_to_le16(size);\n\t\t\tchan->remote_mps = size;\n\n\t\t\tset_bit(CONF_MODE_DONE, &chan->conf_state);\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = chan->mode;\n\t\t}\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\t}\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,\n\t\t\t\tvoid *data, size_t size, u16 *result)\n{\n\tstruct l2cap_conf_req *req = data;\n\tvoid *ptr = req->data;\n\tvoid *endptr = data + size;\n\tint type, olen;\n\tunsigned long val;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tstruct l2cap_conf_efs efs;\n\n\tBT_DBG(\"chan %p, rsp %p, len %d, req %p\", chan, rsp, len, data);\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_MTU:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tif (val < L2CAP_DEFAULT_MIN_MTU) {\n\t\t\t\t*result = L2CAP_CONF_UNACCEPT;\n\t\t\t\tchan->imtu = L2CAP_DEFAULT_MIN_MTU;\n\t\t\t} else\n\t\t\t\tchan->imtu = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu,\n\t\t\t\t\t   endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FLUSH_TO:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->flush_to = val;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2,\n\t\t\t\t\t   chan->flush_to, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tif (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&\n\t\t\t    rfc.mode != chan->mode)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tchan->fcs = 0;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),\n\t\t\t\t\t   (unsigned long) &rfc, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\tchan->ack_win = min_t(u16, val, chan->ack_win);\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2,\n\t\t\t\t\t   chan->tx_win, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_EFS:\n\t\t\tif (olen != sizeof(efs))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&efs, (void *)val, olen);\n\t\t\tif (chan->local_stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != L2CAP_SERV_NOTRAFIC &&\n\t\t\t    efs.stype != chan->local_stype)\n\t\t\t\treturn -ECONNREFUSED;\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs),\n\t\t\t\t\t   (unsigned long) &efs, endptr - ptr);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CONF_FCS:\n\t\t\tif (olen != 1)\n\t\t\t\tbreak;\n\t\t\tif (*result == L2CAP_CONF_PENDING)\n\t\t\t\tif (val == L2CAP_FCS_NONE)\n\t\t\t\t\tset_bit(CONF_RECV_NO_FCS,\n\t\t\t\t\t\t&chan->conf_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode)\n\t\treturn -ECONNREFUSED;\n\n\tchan->mode = rfc.mode;\n\n\tif (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) {\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t\tif (!test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t\t      rfc.txwin_size);\n\n\t\t\tif (test_bit(FLAG_EFS_ENABLE, &chan->flags)) {\n\t\t\t\tchan->local_msdu = le16_to_cpu(efs.msdu);\n\t\t\t\tchan->local_sdu_itime =\n\t\t\t\t\tle32_to_cpu(efs.sdu_itime);\n\t\t\t\tchan->local_acc_lat = le32_to_cpu(efs.acc_lat);\n\t\t\t\tchan->local_flush_to =\n\t\t\t\t\tle32_to_cpu(efs.flush_to);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t\t}\n\t}\n\n\treq->dcid   = cpu_to_le16(chan->dcid);\n\treq->flags  = cpu_to_le16(0);\n\n\treturn ptr - data;\n}\n\nstatic int l2cap_build_conf_rsp(struct l2cap_chan *chan, void *data,\n\t\t\t\tu16 result, u16 flags)\n{\n\tstruct l2cap_conf_rsp *rsp = data;\n\tvoid *ptr = rsp->data;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\trsp->scid   = cpu_to_le16(chan->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(flags);\n\n\treturn ptr - data;\n}\n\nvoid __l2cap_le_connect_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct l2cap_le_conn_rsp rsp;\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\trsp.dcid    = cpu_to_le16(chan->scid);\n\trsp.mtu     = cpu_to_le16(chan->imtu);\n\trsp.mps     = cpu_to_le16(chan->mps);\n\trsp.credits = cpu_to_le16(chan->rx_credits);\n\trsp.result  = cpu_to_le16(L2CAP_CR_LE_SUCCESS);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CONN_RSP, sizeof(rsp),\n\t\t       &rsp);\n}\n\nvoid __l2cap_ecred_conn_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct {\n\t\tstruct l2cap_ecred_conn_rsp rsp;\n\t\t__le16 dcid[5];\n\t} __packed pdu;\n\tstruct l2cap_conn *conn = chan->conn;\n\tu16 ident = chan->ident;\n\tint i = 0;\n\n\tif (!ident)\n\t\treturn;\n\n\tBT_DBG(\"chan %p ident %d\", chan, ident);\n\n\tpdu.rsp.mtu     = cpu_to_le16(chan->imtu);\n\tpdu.rsp.mps     = cpu_to_le16(chan->mps);\n\tpdu.rsp.credits = cpu_to_le16(chan->rx_credits);\n\tpdu.rsp.result  = cpu_to_le16(L2CAP_CR_LE_SUCCESS);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->ident != ident)\n\t\t\tcontinue;\n\n\t\t/* Reset ident so only one response is sent */\n\t\tchan->ident = 0;\n\n\t\t/* Include all channels pending with the same ident */\n\t\tpdu.dcid[i++] = cpu_to_le16(chan->scid);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_ECRED_CONN_RSP,\n\t\t\tsizeof(pdu.rsp) + i * sizeof(__le16), &pdu);\n}\n\nvoid __l2cap_connect_rsp_defer(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn_rsp rsp;\n\tstruct l2cap_conn *conn = chan->conn;\n\tu8 buf[128];\n\tu8 rsp_code;\n\n\trsp.scid   = cpu_to_le16(chan->dcid);\n\trsp.dcid   = cpu_to_le16(chan->scid);\n\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tif (chan->hs_hcon)\n\t\trsp_code = L2CAP_CREATE_CHAN_RSP;\n\telse\n\t\trsp_code = L2CAP_CONN_RSP;\n\n\tBT_DBG(\"chan %p rsp_code %u\", chan, rsp_code);\n\n\tl2cap_send_cmd(conn, chan->ident, rsp_code, sizeof(rsp), &rsp);\n\n\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\treturn;\n\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\tchan->num_conf_req++;\n}\n\nstatic void l2cap_conf_rfc_get(struct l2cap_chan *chan, void *rsp, int len)\n{\n\tint type, olen;\n\tunsigned long val;\n\t/* Use sane default values in case a misbehaving remote device\n\t * did not send an RFC or extended window size option.\n\t */\n\tu16 txwin_ext = chan->ack_win;\n\tstruct l2cap_conf_rfc rfc = {\n\t\t.mode = chan->mode,\n\t\t.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO),\n\t\t.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO),\n\t\t.max_pdu_size = cpu_to_le16(chan->imtu),\n\t\t.txwin_size = min_t(u16, chan->ack_win, L2CAP_DEFAULT_TX_WINDOW),\n\t};\n\n\tBT_DBG(\"chan %p, rsp %p, len %d\", chan, rsp, len);\n\n\tif ((chan->mode != L2CAP_MODE_ERTM) && (chan->mode != L2CAP_MODE_STREAMING))\n\t\treturn;\n\n\twhile (len >= L2CAP_CONF_OPT_SIZE) {\n\t\tlen -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);\n\t\tif (len < 0)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase L2CAP_CONF_RFC:\n\t\t\tif (olen != sizeof(rfc))\n\t\t\t\tbreak;\n\t\t\tmemcpy(&rfc, (void *)val, olen);\n\t\t\tbreak;\n\t\tcase L2CAP_CONF_EWS:\n\t\t\tif (olen != 2)\n\t\t\t\tbreak;\n\t\t\ttxwin_ext = val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (rfc.mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\tchan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);\n\t\tchan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);\n\t\tchan->mps = le16_to_cpu(rfc.max_pdu_size);\n\t\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win, txwin_ext);\n\t\telse\n\t\t\tchan->ack_win = min_t(u16, chan->ack_win,\n\t\t\t\t\t      rfc.txwin_size);\n\t\tbreak;\n\tcase L2CAP_MODE_STREAMING:\n\t\tchan->mps    = le16_to_cpu(rfc.max_pdu_size);\n\t}\n}\n\nstatic inline int l2cap_command_rej(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\n\n\tif (cmd_len < sizeof(*rej))\n\t\treturn -EPROTO;\n\n\tif (rej->reason != L2CAP_REJ_NOT_UNDERSTOOD)\n\t\treturn 0;\n\n\tif ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&\n\t    cmd->ident == conn->info_ident) {\n\t\tcancel_delayed_work(&conn->info_timer);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd,\n\t\t\t\t\tu8 *data, u8 rsp_code, u8 amp_id)\n{\n\tstruct l2cap_conn_req *req = (struct l2cap_conn_req *) data;\n\tstruct l2cap_conn_rsp rsp;\n\tstruct l2cap_chan *chan = NULL, *pchan;\n\tint result, status = L2CAP_CS_NO_INFO;\n\n\tu16 dcid = 0, scid = __le16_to_cpu(req->scid);\n\t__le16 psm = req->psm;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x\", __le16_to_cpu(psm), scid);\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, ACL_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_BAD_PSM;\n\t\tgoto sendresp;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\t/* Check if the ACL is secure enough (if not SDP) */\n\tif (psm != cpu_to_le16(L2CAP_PSM_SDP) &&\n\t    !hci_conn_check_link_mode(conn->hcon)) {\n\t\tconn->disc_reason = HCI_ERROR_AUTH_FAILURE;\n\t\tresult = L2CAP_CR_SEC_BLOCK;\n\t\tgoto response;\n\t}\n\n\tresult = L2CAP_CR_NO_MEM;\n\n\t/* Check for valid dynamic CID range (as per Erratum 3253) */\n\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_DYN_END) {\n\t\tresult = L2CAP_CR_INVALID_SCID;\n\t\tgoto response;\n\t}\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\tresult = L2CAP_CR_SCID_IN_USE;\n\t\tgoto response;\n\t}\n\n\tchan = pchan->ops->new_connection(pchan);\n\tif (!chan)\n\t\tgoto response;\n\n\t/* For certain devices (ex: HID mouse), support for authentication,\n\t * pairing and bonding is optional. For such devices, inorder to avoid\n\t * the ACL alive for too long after L2CAP disconnection, reset the ACL\n\t * disc_timeout back to HCI_DISCONN_TIMEOUT during L2CAP connect.\n\t */\n\tconn->hcon->disc_timeout = HCI_DISCONN_TIMEOUT;\n\n\tbacpy(&chan->src, &conn->hcon->src);\n\tbacpy(&chan->dst, &conn->hcon->dst);\n\tchan->src_type = bdaddr_src_type(conn->hcon);\n\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\tchan->psm  = psm;\n\tchan->dcid = scid;\n\tchan->local_amp_id = amp_id;\n\n\t__l2cap_chan_add(conn, chan);\n\n\tdcid = chan->scid;\n\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\tchan->ident = cmd->ident;\n\n\tif (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {\n\t\tif (l2cap_chan_check_security(chan, false)) {\n\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\tstatus = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\tchan->ops->defer(chan);\n\t\t\t} else {\n\t\t\t\t/* Force pending result for AMP controllers.\n\t\t\t\t * The connection will succeed after the\n\t\t\t\t * physical link is up.\n\t\t\t\t */\n\t\t\t\tif (amp_id == AMP_ID_BREDR) {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tresult = L2CAP_CR_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\t\t\tresult = L2CAP_CR_PEND;\n\t\t\t\t}\n\t\t\t\tstatus = L2CAP_CS_NO_INFO;\n\t\t\t}\n\t\t} else {\n\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\tresult = L2CAP_CR_PEND;\n\t\t\tstatus = L2CAP_CS_AUTHEN_PEND;\n\t\t}\n\t} else {\n\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\tresult = L2CAP_CR_PEND;\n\t\tstatus = L2CAP_CS_NO_INFO;\n\t}\n\nresponse:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\nsendresp:\n\trsp.scid   = cpu_to_le16(scid);\n\trsp.dcid   = cpu_to_le16(dcid);\n\trsp.result = cpu_to_le16(result);\n\trsp.status = cpu_to_le16(status);\n\tl2cap_send_cmd(conn, cmd->ident, rsp_code, sizeof(rsp), &rsp);\n\n\tif (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {\n\t\tstruct l2cap_info_req info;\n\t\tinfo.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;\n\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\tschedule_delayed_work(&conn->info_timer, L2CAP_INFO_TIMEOUT);\n\n\t\tl2cap_send_cmd(conn, conn->info_ident, L2CAP_INFO_REQ,\n\t\t\t       sizeof(info), &info);\n\t}\n\n\tif (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t    result == L2CAP_CR_SUCCESS) {\n\t\tu8 buf[128];\n\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\treturn chan;\n}\n\nstatic int l2cap_connect_req(struct l2cap_conn *conn,\n\t\t\t     struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)\n{\n\tstruct hci_dev *hdev = conn->hcon->hdev;\n\tstruct hci_conn *hcon = conn->hcon;\n\n\tif (cmd_len < sizeof(struct l2cap_conn_req))\n\t\treturn -EPROTO;\n\n\thci_dev_lock(hdev);\n\tif (hci_dev_test_flag(hdev, HCI_MGMT) &&\n\t    !test_and_set_bit(HCI_CONN_MGMT_CONNECTED, &hcon->flags))\n\t\tmgmt_device_connected(hdev, hcon, 0, NULL, 0);\n\thci_dev_unlock(hdev);\n\n\tl2cap_connect(conn, cmd, data, L2CAP_CONN_RSP, 0);\n\treturn 0;\n}\n\nstatic int l2cap_connect_create_rsp(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t    u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct l2cap_chan *chan;\n\tu8 req[128];\n\tint err;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\",\n\t       dcid, scid, result, status);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tif (scid) {\n\t\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\t\tif (!chan) {\n\t\t\terr = -EBADSLT;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tclear_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\n\t\tif (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))\n\t\t\tbreak;\n\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, req, sizeof(req)), req);\n\t\tchan->num_conf_req++;\n\t\tbreak;\n\n\tcase L2CAP_CR_PEND:\n\t\tset_bit(CONF_CONNECT_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline void set_default_fcs(struct l2cap_chan *chan)\n{\n\t/* FCS is enabled only in ERTM or streaming mode, if one or both\n\t * sides request it.\n\t */\n\tif (chan->mode != L2CAP_MODE_ERTM && chan->mode != L2CAP_MODE_STREAMING)\n\t\tchan->fcs = L2CAP_FCS_NONE;\n\telse if (!test_bit(CONF_RECV_NO_FCS, &chan->conf_state))\n\t\tchan->fcs = L2CAP_FCS_CRC16;\n}\n\nstatic void l2cap_send_efs_conf_rsp(struct l2cap_chan *chan, void *data,\n\t\t\t\t    u8 ident, u16 flags)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\n\tBT_DBG(\"conn %p chan %p ident %d flags 0x%4.4x\", conn, chan, ident,\n\t       flags);\n\n\tclear_bit(CONF_LOC_CONF_PEND, &chan->conf_state);\n\tset_bit(CONF_OUTPUT_DONE, &chan->conf_state);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_CONF_RSP,\n\t\t       l2cap_build_conf_rsp(chan, data,\n\t\t\t\t\t    L2CAP_CONF_SUCCESS, flags), data);\n}\n\nstatic void cmd_reject_invalid_cid(struct l2cap_conn *conn, u8 ident,\n\t\t\t\t   u16 scid, u16 dcid)\n{\n\tstruct l2cap_cmd_rej_cid rej;\n\n\trej.reason = cpu_to_le16(L2CAP_REJ_INVALID_CID);\n\trej.scid = __cpu_to_le16(scid);\n\trej.dcid = __cpu_to_le16(dcid);\n\n\tl2cap_send_cmd(conn, ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);\n}\n\nstatic inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2 &&\n\t    chan->state != BT_CONNECTED) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}\n\nstatic inline int l2cap_config_rsp(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct l2cap_chan *chan;\n\tint len = cmd_len - sizeof(*rsp);\n\tint err = 0;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x len %d\", scid, flags,\n\t       result, len);\n\n\tchan = l2cap_get_chan_by_scid(conn, scid);\n\tif (!chan)\n\t\treturn 0;\n\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tl2cap_conf_rfc_get(chan, rsp->data, len);\n\t\tclear_bit(CONF_REM_CONF_PEND, &chan->conf_state);\n\t\tbreak;\n\n\tcase L2CAP_CONF_PENDING:\n\t\tset_bit(CONF_REM_CONF_PEND, &chan->conf_state);\n\n\t\tif (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\t\t\tchar buf[64];\n\n\t\t\tlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\n\t\t\t\t\t\t   buf, sizeof(buf), &result);\n\t\t\tif (len < 0) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!chan->hs_hcon) {\n\t\t\t\tl2cap_send_efs_conf_rsp(chan, buf, cmd->ident,\n\t\t\t\t\t\t\t0);\n\t\t\t} else {\n\t\t\t\tif (l2cap_check_efs(chan)) {\n\t\t\t\t\tamp_create_logical_link(chan);\n\t\t\t\t\tchan->ident = cmd->ident;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\n\tcase L2CAP_CONF_UNKNOWN:\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (chan->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {\n\t\t\tchar req[64];\n\n\t\t\tif (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* throw out any old stored conf requests */\n\t\t\tresult = L2CAP_CONF_SUCCESS;\n\t\t\tlen = l2cap_parse_conf_rsp(chan, rsp->data, len,\n\t\t\t\t\t\t   req, sizeof(req), &result);\n\t\t\tif (len < 0) {\n\t\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t       L2CAP_CONF_REQ, len, req);\n\t\t\tchan->num_conf_req++;\n\t\t\tif (result != L2CAP_CONF_SUCCESS)\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tdefault:\n\t\tl2cap_chan_set_err(chan, ECONNRESET);\n\n\t\t__set_chan_timer(chan, L2CAP_DISC_REJ_TIMEOUT);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto done;\n\t}\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION)\n\t\tgoto done;\n\n\tset_bit(CONF_INPUT_DONE, &chan->conf_state);\n\n\tif (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\t}\n\ndone:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}\n\nstatic inline int l2cap_disconnect_req(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;\n\tstruct l2cap_disconn_rsp rsp;\n\tu16 dcid, scid;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(req->scid);\n\tdcid = __le16_to_cpu(req->dcid);\n\n\tBT_DBG(\"scid 0x%4.4x dcid 0x%4.4x\", scid, dcid);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, scid);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\trsp.dcid = cpu_to_le16(chan->scid);\n\trsp.scid = cpu_to_le16(chan->dcid);\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);\n\n\tchan->ops->set_shutdown(chan);\n\n\tl2cap_chan_del(chan, ECONNRESET);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_disconnect_rsp(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;\n\tu16 dcid, scid;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(rsp->scid);\n\tdcid = __le16_to_cpu(rsp->dcid);\n\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x\", dcid, scid);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_scid(conn, scid);\n\tif (!chan) {\n\t\tmutex_unlock(&conn->chan_lock);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tif (chan->state != BT_DISCONN) {\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t\tmutex_unlock(&conn->chan_lock);\n\t\treturn 0;\n\t}\n\n\tl2cap_chan_del(chan, 0);\n\n\tchan->ops->close(chan);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_req(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\tu8 *data)\n{\n\tstruct l2cap_info_req *req = (struct l2cap_info_req *) data;\n\tu16 type;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\ttype = __le16_to_cpu(req->type);\n\n\tBT_DBG(\"type 0x%4.4x\", type);\n\n\tif (type == L2CAP_IT_FEAT_MASK) {\n\t\tu8 buf[8];\n\t\tu32 feat_mask = l2cap_feat_mask;\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\tif (!disable_ertm)\n\t\t\tfeat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING\n\t\t\t\t| L2CAP_FEAT_FCS;\n\t\tif (conn->local_fixed_chan & L2CAP_FC_A2MP)\n\t\t\tfeat_mask |= L2CAP_FEAT_EXT_FLOW\n\t\t\t\t| L2CAP_FEAT_EXT_WINDOW;\n\n\t\tput_unaligned_le32(feat_mask, rsp->data);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\n\t\t\t       buf);\n\t} else if (type == L2CAP_IT_FIXED_CHAN) {\n\t\tu8 buf[12];\n\t\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;\n\n\t\trsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\t\trsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);\n\t\trsp->data[0] = conn->local_fixed_chan;\n\t\tmemset(rsp->data + 1, 0, 7);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(buf),\n\t\t\t       buf);\n\t} else {\n\t\tstruct l2cap_info_rsp rsp;\n\t\trsp.type   = cpu_to_le16(type);\n\t\trsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(rsp),\n\t\t\t       &rsp);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_information_rsp(struct l2cap_conn *conn,\n\t\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\tu8 *data)\n{\n\tstruct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;\n\tu16 type, result;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ttype   = __le16_to_cpu(rsp->type);\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"type 0x%4.4x result 0x%2.2x\", type, result);\n\n\t/* L2CAP Info req/rsp are unbound to channels, add extra checks */\n\tif (cmd->ident != conn->info_ident ||\n\t    conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE)\n\t\treturn 0;\n\n\tcancel_delayed_work(&conn->info_timer);\n\n\tif (result != L2CAP_IR_SUCCESS) {\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase L2CAP_IT_FEAT_MASK:\n\t\tconn->feat_mask = get_unaligned_le32(rsp->data);\n\n\t\tif (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {\n\t\t\tstruct l2cap_info_req req;\n\t\t\treq.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);\n\n\t\t\tconn->info_ident = l2cap_get_ident(conn);\n\n\t\t\tl2cap_send_cmd(conn, conn->info_ident,\n\t\t\t\t       L2CAP_INFO_REQ, sizeof(req), &req);\n\t\t} else {\n\t\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\t\tconn->info_ident = 0;\n\n\t\t\tl2cap_conn_start(conn);\n\t\t}\n\t\tbreak;\n\n\tcase L2CAP_IT_FIXED_CHAN:\n\t\tconn->remote_fixed_chan = rsp->data[0];\n\t\tconn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;\n\t\tconn->info_ident = 0;\n\n\t\tl2cap_conn_start(conn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int l2cap_create_channel_req(struct l2cap_conn *conn,\n\t\t\t\t    struct l2cap_cmd_hdr *cmd,\n\t\t\t\t    u16 cmd_len, void *data)\n{\n\tstruct l2cap_create_chan_req *req = data;\n\tstruct l2cap_create_chan_rsp rsp;\n\tstruct l2cap_chan *chan;\n\tstruct hci_dev *hdev;\n\tu16 psm, scid;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn -EINVAL;\n\n\tpsm = le16_to_cpu(req->psm);\n\tscid = le16_to_cpu(req->scid);\n\n\tBT_DBG(\"psm 0x%2.2x, scid 0x%4.4x, amp_id %d\", psm, scid, req->amp_id);\n\n\t/* For controller id 0 make BR/EDR connection */\n\tif (req->amp_id == AMP_ID_BREDR) {\n\t\tl2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\n\t\t\t      req->amp_id);\n\t\treturn 0;\n\t}\n\n\t/* Validate AMP controller id */\n\thdev = hci_dev_get(req->amp_id);\n\tif (!hdev)\n\t\tgoto error;\n\n\tif (hdev->dev_type != HCI_AMP || !test_bit(HCI_UP, &hdev->flags)) {\n\t\thci_dev_put(hdev);\n\t\tgoto error;\n\t}\n\n\tchan = l2cap_connect(conn, cmd, data, L2CAP_CREATE_CHAN_RSP,\n\t\t\t     req->amp_id);\n\tif (chan) {\n\t\tstruct amp_mgr *mgr = conn->hcon->amp_mgr;\n\t\tstruct hci_conn *hs_hcon;\n\n\t\ths_hcon = hci_conn_hash_lookup_ba(hdev, AMP_LINK,\n\t\t\t\t\t\t  &conn->hcon->dst);\n\t\tif (!hs_hcon) {\n\t\t\thci_dev_put(hdev);\n\t\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t\t       chan->dcid);\n\t\t\treturn 0;\n\t\t}\n\n\t\tBT_DBG(\"mgr %p bredr_chan %p hs_hcon %p\", mgr, chan, hs_hcon);\n\n\t\tmgr->bredr_chan = chan;\n\t\tchan->hs_hcon = hs_hcon;\n\t\tchan->fcs = L2CAP_FCS_NONE;\n\t\tconn->mtu = hdev->block_mtu;\n\t}\n\n\thci_dev_put(hdev);\n\n\treturn 0;\n\nerror:\n\trsp.dcid = 0;\n\trsp.scid = cpu_to_le16(scid);\n\trsp.result = cpu_to_le16(L2CAP_CR_BAD_AMP);\n\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CREATE_CHAN_RSP,\n\t\t       sizeof(rsp), &rsp);\n\n\treturn 0;\n}\n\nstatic void l2cap_send_move_chan_req(struct l2cap_chan *chan, u8 dest_amp_id)\n{\n\tstruct l2cap_move_chan_req req;\n\tu8 ident;\n\n\tBT_DBG(\"chan %p, dest_amp_id %d\", chan, dest_amp_id);\n\n\tident = l2cap_get_ident(chan->conn);\n\tchan->ident = ident;\n\n\treq.icid = cpu_to_le16(chan->scid);\n\treq.dest_amp_id = dest_amp_id;\n\n\tl2cap_send_cmd(chan->conn, ident, L2CAP_MOVE_CHAN_REQ, sizeof(req),\n\t\t       &req);\n\n\t__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\n}\n\nstatic void l2cap_send_move_chan_rsp(struct l2cap_chan *chan, u16 result)\n{\n\tstruct l2cap_move_chan_rsp rsp;\n\n\tBT_DBG(\"chan %p, result 0x%4.4x\", chan, result);\n\n\trsp.icid = cpu_to_le16(chan->dcid);\n\trsp.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_RSP,\n\t\t       sizeof(rsp), &rsp);\n}\n\nstatic void l2cap_send_move_chan_cfm(struct l2cap_chan *chan, u16 result)\n{\n\tstruct l2cap_move_chan_cfm cfm;\n\n\tBT_DBG(\"chan %p, result 0x%4.4x\", chan, result);\n\n\tchan->ident = l2cap_get_ident(chan->conn);\n\n\tcfm.icid = cpu_to_le16(chan->scid);\n\tcfm.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_MOVE_CHAN_CFM,\n\t\t       sizeof(cfm), &cfm);\n\n\t__set_chan_timer(chan, L2CAP_MOVE_TIMEOUT);\n}\n\nstatic void l2cap_send_move_chan_cfm_icid(struct l2cap_conn *conn, u16 icid)\n{\n\tstruct l2cap_move_chan_cfm cfm;\n\n\tBT_DBG(\"conn %p, icid 0x%4.4x\", conn, icid);\n\n\tcfm.icid = cpu_to_le16(icid);\n\tcfm.result = cpu_to_le16(L2CAP_MC_UNCONFIRMED);\n\n\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_MOVE_CHAN_CFM,\n\t\t       sizeof(cfm), &cfm);\n}\n\nstatic void l2cap_send_move_chan_cfm_rsp(struct l2cap_conn *conn, u8 ident,\n\t\t\t\t\t u16 icid)\n{\n\tstruct l2cap_move_chan_cfm_rsp rsp;\n\n\tBT_DBG(\"icid 0x%4.4x\", icid);\n\n\trsp.icid = cpu_to_le16(icid);\n\tl2cap_send_cmd(conn, ident, L2CAP_MOVE_CHAN_CFM_RSP, sizeof(rsp), &rsp);\n}\n\nstatic void __release_logical_link(struct l2cap_chan *chan)\n{\n\tchan->hs_hchan = NULL;\n\tchan->hs_hcon = NULL;\n\n\t/* Placeholder - release the logical link */\n}\n\nstatic void l2cap_logical_fail(struct l2cap_chan *chan)\n{\n\t/* Logical link setup failed */\n\tif (chan->state != BT_CONNECTED) {\n\t\t/* Create channel failure, disconnect */\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tswitch (chan->move_role) {\n\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\tl2cap_move_done(chan);\n\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_SUPP);\n\t\tbreak;\n\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\tif (chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_COMP ||\n\t\t    chan->move_state == L2CAP_MOVE_WAIT_LOGICAL_CFM) {\n\t\t\t/* Remote has only sent pending or\n\t\t\t * success responses, clean up\n\t\t\t */\n\t\t\tl2cap_move_done(chan);\n\t\t}\n\n\t\t/* Other amp move states imply that the move\n\t\t * has already aborted\n\t\t */\n\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t\tbreak;\n\t}\n}\n\nstatic void l2cap_logical_finish_create(struct l2cap_chan *chan,\n\t\t\t\t\tstruct hci_chan *hchan)\n{\n\tstruct l2cap_conf_rsp rsp;\n\n\tchan->hs_hchan = hchan;\n\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\tl2cap_send_efs_conf_rsp(chan, &rsp, chan->ident, 0);\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tint err;\n\n\t\tset_default_fcs(chan);\n\n\t\terr = l2cap_ertm_init(chan);\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\t}\n}\n\nstatic void l2cap_logical_finish_move(struct l2cap_chan *chan,\n\t\t\t\t      struct hci_chan *hchan)\n{\n\tchan->hs_hcon = hchan->conn;\n\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\tBT_DBG(\"move_state %d\", chan->move_state);\n\n\tswitch (chan->move_state) {\n\tcase L2CAP_MOVE_WAIT_LOGICAL_COMP:\n\t\t/* Move confirm will be sent after a success\n\t\t * response is received\n\t\t */\n\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_LOGICAL_CFM:\n\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t} else if (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t} else if (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Move was not in expected state, free the channel */\n\t\t__release_logical_link(chan);\n\n\t\tchan->move_state = L2CAP_MOVE_STABLE;\n\t}\n}\n\n/* Call with chan locked */\nvoid l2cap_logical_cfm(struct l2cap_chan *chan, struct hci_chan *hchan,\n\t\t       u8 status)\n{\n\tBT_DBG(\"chan %p, hchan %p, status %d\", chan, hchan, status);\n\n\tif (status) {\n\t\tl2cap_logical_fail(chan);\n\t\t__release_logical_link(chan);\n\t\treturn;\n\t}\n\n\tif (chan->state != BT_CONNECTED) {\n\t\t/* Ignore logical link if channel is on BR/EDR */\n\t\tif (chan->local_amp_id != AMP_ID_BREDR)\n\t\t\tl2cap_logical_finish_create(chan, hchan);\n\t} else {\n\t\tl2cap_logical_finish_move(chan, hchan);\n\t}\n}\n\nvoid l2cap_move_start(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tif (chan->local_amp_id == AMP_ID_BREDR) {\n\t\tif (chan->chan_policy != BT_CHANNEL_POLICY_AMP_PREFERRED)\n\t\t\treturn;\n\t\tchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\n\t\tchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\n\t\t/* Placeholder - start physical link setup */\n\t} else {\n\t\tchan->move_role = L2CAP_MOVE_ROLE_INITIATOR;\n\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\tchan->move_id = 0;\n\t\tl2cap_move_setup(chan);\n\t\tl2cap_send_move_chan_req(chan, 0);\n\t}\n}\n\nstatic void l2cap_do_create(struct l2cap_chan *chan, int result,\n\t\t\t    u8 local_amp_id, u8 remote_amp_id)\n{\n\tBT_DBG(\"chan %p state %s %u -> %u\", chan, state_to_string(chan->state),\n\t       local_amp_id, remote_amp_id);\n\n\tchan->fcs = L2CAP_FCS_NONE;\n\n\t/* Outgoing channel on AMP */\n\tif (chan->state == BT_CONNECT) {\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\tchan->local_amp_id = local_amp_id;\n\t\t\tl2cap_send_create_chan_req(chan, remote_amp_id);\n\t\t} else {\n\t\t\t/* Revert to BR/EDR connect */\n\t\t\tl2cap_send_conn_req(chan);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/* Incoming channel on AMP */\n\tif (__l2cap_no_conn_pending(chan)) {\n\t\tstruct l2cap_conn_rsp rsp;\n\t\tchar buf[128];\n\t\trsp.scid = cpu_to_le16(chan->dcid);\n\t\trsp.dcid = cpu_to_le16(chan->scid);\n\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\t/* Send successful response */\n\t\t\trsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t} else {\n\t\t\t/* Send negative response */\n\t\t\trsp.result = cpu_to_le16(L2CAP_CR_NO_MEM);\n\t\t\trsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);\n\t\t}\n\n\t\tl2cap_send_cmd(chan->conn, chan->ident, L2CAP_CREATE_CHAN_RSP,\n\t\t\t       sizeof(rsp), &rsp);\n\n\t\tif (result == L2CAP_CR_SUCCESS) {\n\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\tl2cap_send_cmd(chan->conn, l2cap_get_ident(chan->conn),\n\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\t\tchan->num_conf_req++;\n\t\t}\n\t}\n}\n\nstatic void l2cap_do_move_initiate(struct l2cap_chan *chan, u8 local_amp_id,\n\t\t\t\t   u8 remote_amp_id)\n{\n\tl2cap_move_setup(chan);\n\tchan->move_id = local_amp_id;\n\tchan->move_state = L2CAP_MOVE_WAIT_RSP;\n\n\tl2cap_send_move_chan_req(chan, remote_amp_id);\n}\n\nstatic void l2cap_do_move_respond(struct l2cap_chan *chan, int result)\n{\n\tstruct hci_chan *hchan = NULL;\n\n\t/* Placeholder - get hci_chan for logical link */\n\n\tif (hchan) {\n\t\tif (hchan->state == BT_CONNECTED) {\n\t\t\t/* Logical link is ready to go */\n\t\t\tchan->hs_hcon = hchan->conn;\n\t\t\tchan->hs_hcon->l2cap_data = chan->conn;\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_SUCCESS);\n\n\t\t\tl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\n\t\t} else {\n\t\t\t/* Wait for logical link to be ready */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\t}\n\t} else {\n\t\t/* Logical link not available */\n\t\tl2cap_send_move_chan_rsp(chan, L2CAP_MR_NOT_ALLOWED);\n\t}\n}\n\nstatic void l2cap_do_move_cancel(struct l2cap_chan *chan, int result)\n{\n\tif (chan->move_role == L2CAP_MOVE_ROLE_RESPONDER) {\n\t\tu8 rsp_result;\n\t\tif (result == -EINVAL)\n\t\t\trsp_result = L2CAP_MR_BAD_ID;\n\t\telse\n\t\t\trsp_result = L2CAP_MR_NOT_ALLOWED;\n\n\t\tl2cap_send_move_chan_rsp(chan, rsp_result);\n\t}\n\n\tchan->move_role = L2CAP_MOVE_ROLE_NONE;\n\tchan->move_state = L2CAP_MOVE_STABLE;\n\n\t/* Restart data transmission */\n\tl2cap_ertm_send(chan);\n}\n\n/* Invoke with locked chan */\nvoid __l2cap_physical_cfm(struct l2cap_chan *chan, int result)\n{\n\tu8 local_amp_id = chan->local_amp_id;\n\tu8 remote_amp_id = chan->remote_amp_id;\n\n\tBT_DBG(\"chan %p, result %d, local_amp_id %d, remote_amp_id %d\",\n\t       chan, result, local_amp_id, remote_amp_id);\n\n\tif (chan->state == BT_DISCONN || chan->state == BT_CLOSED)\n\t\treturn;\n\n\tif (chan->state != BT_CONNECTED) {\n\t\tl2cap_do_create(chan, result, local_amp_id, remote_amp_id);\n\t} else if (result != L2CAP_MR_SUCCESS) {\n\t\tl2cap_do_move_cancel(chan, result);\n\t} else {\n\t\tswitch (chan->move_role) {\n\t\tcase L2CAP_MOVE_ROLE_INITIATOR:\n\t\t\tl2cap_do_move_initiate(chan, local_amp_id,\n\t\t\t\t\t       remote_amp_id);\n\t\t\tbreak;\n\t\tcase L2CAP_MOVE_ROLE_RESPONDER:\n\t\t\tl2cap_do_move_respond(chan, result);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tl2cap_do_move_cancel(chan, result);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int l2cap_move_channel_req(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_req *req = data;\n\tstruct l2cap_move_chan_rsp rsp;\n\tstruct l2cap_chan *chan;\n\tu16 icid = 0;\n\tu16 result = L2CAP_MR_NOT_ALLOWED;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(req->icid);\n\n\tBT_DBG(\"icid 0x%4.4x, dest_amp_id %d\", icid, req->dest_amp_id);\n\n\tif (!(conn->local_fixed_chan & L2CAP_FC_A2MP))\n\t\treturn -EINVAL;\n\n\tchan = l2cap_get_chan_by_dcid(conn, icid);\n\tif (!chan) {\n\t\trsp.icid = cpu_to_le16(icid);\n\t\trsp.result = cpu_to_le16(L2CAP_MR_NOT_ALLOWED);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_MOVE_CHAN_RSP,\n\t\t\t       sizeof(rsp), &rsp);\n\t\treturn 0;\n\t}\n\n\tchan->ident = cmd->ident;\n\n\tif (chan->scid < L2CAP_CID_DYN_START ||\n\t    chan->chan_policy == BT_CHANNEL_POLICY_BREDR_ONLY ||\n\t    (chan->mode != L2CAP_MODE_ERTM &&\n\t     chan->mode != L2CAP_MODE_STREAMING)) {\n\t\tresult = L2CAP_MR_NOT_ALLOWED;\n\t\tgoto send_move_response;\n\t}\n\n\tif (chan->local_amp_id == req->dest_amp_id) {\n\t\tresult = L2CAP_MR_SAME_ID;\n\t\tgoto send_move_response;\n\t}\n\n\tif (req->dest_amp_id != AMP_ID_BREDR) {\n\t\tstruct hci_dev *hdev;\n\t\thdev = hci_dev_get(req->dest_amp_id);\n\t\tif (!hdev || hdev->dev_type != HCI_AMP ||\n\t\t    !test_bit(HCI_UP, &hdev->flags)) {\n\t\t\tif (hdev)\n\t\t\t\thci_dev_put(hdev);\n\n\t\t\tresult = L2CAP_MR_BAD_ID;\n\t\t\tgoto send_move_response;\n\t\t}\n\t\thci_dev_put(hdev);\n\t}\n\n\t/* Detect a move collision.  Only send a collision response\n\t * if this side has \"lost\", otherwise proceed with the move.\n\t * The winner has the larger bd_addr.\n\t */\n\tif ((__chan_is_moving(chan) ||\n\t     chan->move_role != L2CAP_MOVE_ROLE_NONE) &&\n\t    bacmp(&conn->hcon->src, &conn->hcon->dst) > 0) {\n\t\tresult = L2CAP_MR_COLLISION;\n\t\tgoto send_move_response;\n\t}\n\n\tchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\n\tl2cap_move_setup(chan);\n\tchan->move_id = req->dest_amp_id;\n\n\tif (req->dest_amp_id == AMP_ID_BREDR) {\n\t\t/* Moving to BR/EDR */\n\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t\tresult = L2CAP_MR_PEND;\n\t\t} else {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM;\n\t\t\tresult = L2CAP_MR_SUCCESS;\n\t\t}\n\t} else {\n\t\tchan->move_state = L2CAP_MOVE_WAIT_PREPARE;\n\t\t/* Placeholder - uncomment when amp functions are available */\n\t\t/*amp_accept_physical(chan, req->dest_amp_id);*/\n\t\tresult = L2CAP_MR_PEND;\n\t}\n\nsend_move_response:\n\tl2cap_send_move_chan_rsp(chan, result);\n\n\tl2cap_chan_unlock(chan);\n\n\treturn 0;\n}\n\nstatic void l2cap_move_continue(struct l2cap_conn *conn, u16 icid, u16 result)\n{\n\tstruct l2cap_chan *chan;\n\tstruct hci_chan *hchan = NULL;\n\n\tchan = l2cap_get_chan_by_scid(conn, icid);\n\tif (!chan) {\n\t\tl2cap_send_move_chan_cfm_icid(conn, icid);\n\t\treturn;\n\t}\n\n\t__clear_chan_timer(chan);\n\tif (result == L2CAP_MR_PEND)\n\t\t__set_chan_timer(chan, L2CAP_MOVE_ERTX_TIMEOUT);\n\n\tswitch (chan->move_state) {\n\tcase L2CAP_MOVE_WAIT_LOGICAL_COMP:\n\t\t/* Move confirm will be sent when logical link\n\t\t * is complete.\n\t\t */\n\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_RSP_SUCCESS:\n\t\tif (result == L2CAP_MR_PEND) {\n\t\t\tbreak;\n\t\t} else if (test_bit(CONN_LOCAL_BUSY,\n\t\t\t\t    &chan->conn_state)) {\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOCAL_BUSY;\n\t\t} else {\n\t\t\t/* Logical link is up or moving to BR/EDR,\n\t\t\t * proceed with move\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_CONFIRM_RSP;\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MOVE_WAIT_RSP:\n\t\t/* Moving to AMP */\n\t\tif (result == L2CAP_MR_SUCCESS) {\n\t\t\t/* Remote is ready, send confirm immediately\n\t\t\t * after logical link is ready\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_CFM;\n\t\t} else {\n\t\t\t/* Both logical link and move success\n\t\t\t * are required to confirm\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_LOGICAL_COMP;\n\t\t}\n\n\t\t/* Placeholder - get hci_chan for logical link */\n\t\tif (!hchan) {\n\t\t\t/* Logical link not available */\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the logical link is not yet connected, do not\n\t\t * send confirmation.\n\t\t */\n\t\tif (hchan->state != BT_CONNECTED)\n\t\t\tbreak;\n\n\t\t/* Logical link is already ready to go */\n\n\t\tchan->hs_hcon = hchan->conn;\n\t\tchan->hs_hcon->l2cap_data = chan->conn;\n\n\t\tif (result == L2CAP_MR_SUCCESS) {\n\t\t\t/* Can confirm now */\n\t\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_CONFIRMED);\n\t\t} else {\n\t\t\t/* Now only need move success\n\t\t\t * to confirm\n\t\t\t */\n\t\t\tchan->move_state = L2CAP_MOVE_WAIT_RSP_SUCCESS;\n\t\t}\n\n\t\tl2cap_logical_cfm(chan, hchan, L2CAP_MR_SUCCESS);\n\t\tbreak;\n\tdefault:\n\t\t/* Any other amp move state means the move failed. */\n\t\tchan->move_id = chan->local_amp_id;\n\t\tl2cap_move_done(chan);\n\t\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\t}\n\n\tl2cap_chan_unlock(chan);\n}\n\nstatic void l2cap_move_fail(struct l2cap_conn *conn, u8 ident, u16 icid,\n\t\t\t    u16 result)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_get_chan_by_ident(conn, ident);\n\tif (!chan) {\n\t\t/* Could not locate channel, icid is best guess */\n\t\tl2cap_send_move_chan_cfm_icid(conn, icid);\n\t\treturn;\n\t}\n\n\t__clear_chan_timer(chan);\n\n\tif (chan->move_role == L2CAP_MOVE_ROLE_INITIATOR) {\n\t\tif (result == L2CAP_MR_COLLISION) {\n\t\t\tchan->move_role = L2CAP_MOVE_ROLE_RESPONDER;\n\t\t} else {\n\t\t\t/* Cleanup - cancel move */\n\t\t\tchan->move_id = chan->local_amp_id;\n\t\t\tl2cap_move_done(chan);\n\t\t}\n\t}\n\n\tl2cap_send_move_chan_cfm(chan, L2CAP_MC_UNCONFIRMED);\n\n\tl2cap_chan_unlock(chan);\n}\n\nstatic int l2cap_move_channel_rsp(struct l2cap_conn *conn,\n\t\t\t\t  struct l2cap_cmd_hdr *cmd,\n\t\t\t\t  u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_rsp *rsp = data;\n\tu16 icid, result;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(rsp->icid);\n\tresult = le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"icid 0x%4.4x, result 0x%4.4x\", icid, result);\n\n\tif (result == L2CAP_MR_SUCCESS || result == L2CAP_MR_PEND)\n\t\tl2cap_move_continue(conn, icid, result);\n\telse\n\t\tl2cap_move_fail(conn, cmd->ident, icid, result);\n\n\treturn 0;\n}\n\nstatic int l2cap_move_channel_confirm(struct l2cap_conn *conn,\n\t\t\t\t      struct l2cap_cmd_hdr *cmd,\n\t\t\t\t      u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_cfm *cfm = data;\n\tstruct l2cap_chan *chan;\n\tu16 icid, result;\n\n\tif (cmd_len != sizeof(*cfm))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(cfm->icid);\n\tresult = le16_to_cpu(cfm->result);\n\n\tBT_DBG(\"icid 0x%4.4x, result 0x%4.4x\", icid, result);\n\n\tchan = l2cap_get_chan_by_dcid(conn, icid);\n\tif (!chan) {\n\t\t/* Spec requires a response even if the icid was not found */\n\t\tl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\n\t\treturn 0;\n\t}\n\n\tif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM) {\n\t\tif (result == L2CAP_MC_CONFIRMED) {\n\t\t\tchan->local_amp_id = chan->move_id;\n\t\t\tif (chan->local_amp_id == AMP_ID_BREDR)\n\t\t\t\t__release_logical_link(chan);\n\t\t} else {\n\t\t\tchan->move_id = chan->local_amp_id;\n\t\t}\n\n\t\tl2cap_move_done(chan);\n\t}\n\n\tl2cap_send_move_chan_cfm_rsp(conn, cmd->ident, icid);\n\n\tl2cap_chan_unlock(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_move_channel_confirm_rsp(struct l2cap_conn *conn,\n\t\t\t\t\t\t struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t\t u16 cmd_len, void *data)\n{\n\tstruct l2cap_move_chan_cfm_rsp *rsp = data;\n\tstruct l2cap_chan *chan;\n\tu16 icid;\n\n\tif (cmd_len != sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\ticid = le16_to_cpu(rsp->icid);\n\n\tBT_DBG(\"icid 0x%4.4x\", icid);\n\n\tchan = l2cap_get_chan_by_scid(conn, icid);\n\tif (!chan)\n\t\treturn 0;\n\n\t__clear_chan_timer(chan);\n\n\tif (chan->move_state == L2CAP_MOVE_WAIT_CONFIRM_RSP) {\n\t\tchan->local_amp_id = chan->move_id;\n\n\t\tif (chan->local_amp_id == AMP_ID_BREDR && chan->hs_hchan)\n\t\t\t__release_logical_link(chan);\n\n\t\tl2cap_move_done(chan);\n\t}\n\n\tl2cap_chan_unlock(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_conn_param_update_req(struct l2cap_conn *conn,\n\t\t\t\t\t      struct l2cap_cmd_hdr *cmd,\n\t\t\t\t\t      u16 cmd_len, u8 *data)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_conn_param_update_req *req;\n\tstruct l2cap_conn_param_update_rsp rsp;\n\tu16 min, max, latency, to_multiplier;\n\tint err;\n\n\tif (hcon->role != HCI_ROLE_MASTER)\n\t\treturn -EINVAL;\n\n\tif (cmd_len != sizeof(struct l2cap_conn_param_update_req))\n\t\treturn -EPROTO;\n\n\treq = (struct l2cap_conn_param_update_req *) data;\n\tmin\t\t= __le16_to_cpu(req->min);\n\tmax\t\t= __le16_to_cpu(req->max);\n\tlatency\t\t= __le16_to_cpu(req->latency);\n\tto_multiplier\t= __le16_to_cpu(req->to_multiplier);\n\n\tBT_DBG(\"min 0x%4.4x max 0x%4.4x latency: 0x%4.4x Timeout: 0x%4.4x\",\n\t       min, max, latency, to_multiplier);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\terr = hci_check_conn_params(min, max, latency, to_multiplier);\n\tif (err)\n\t\trsp.result = cpu_to_le16(L2CAP_CONN_PARAM_REJECTED);\n\telse\n\t\trsp.result = cpu_to_le16(L2CAP_CONN_PARAM_ACCEPTED);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_PARAM_UPDATE_RSP,\n\t\t       sizeof(rsp), &rsp);\n\n\tif (!err) {\n\t\tu8 store_hint;\n\n\t\tstore_hint = hci_le_conn_update(hcon, min, max, latency,\n\t\t\t\t\t\tto_multiplier);\n\t\tmgmt_new_conn_param(hcon->hdev, &hcon->dst, hcon->dst_type,\n\t\t\t\t    store_hint, min, max, latency,\n\t\t\t\t    to_multiplier);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int l2cap_le_connect_rsp(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\tu8 *data)\n{\n\tstruct l2cap_le_conn_rsp *rsp = (struct l2cap_le_conn_rsp *) data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 dcid, mtu, mps, credits, result;\n\tstruct l2cap_chan *chan;\n\tint err, sec_level;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tdcid    = __le16_to_cpu(rsp->dcid);\n\tmtu     = __le16_to_cpu(rsp->mtu);\n\tmps     = __le16_to_cpu(rsp->mps);\n\tcredits = __le16_to_cpu(rsp->credits);\n\tresult  = __le16_to_cpu(rsp->result);\n\n\tif (result == L2CAP_CR_LE_SUCCESS && (mtu < 23 || mps < 23 ||\n\t\t\t\t\t   dcid < L2CAP_CID_DYN_START ||\n\t\t\t\t\t   dcid > L2CAP_CID_LE_DYN_END))\n\t\treturn -EPROTO;\n\n\tBT_DBG(\"dcid 0x%4.4x mtu %u mps %u credits %u result 0x%2.2x\",\n\t       dcid, mtu, mps, credits, result);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\tif (!chan) {\n\t\terr = -EBADSLT;\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\n\tl2cap_chan_lock(chan);\n\n\tswitch (result) {\n\tcase L2CAP_CR_LE_SUCCESS:\n\t\tif (__l2cap_get_chan_by_dcid(conn, dcid)) {\n\t\t\terr = -EBADSLT;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->ident = 0;\n\t\tchan->dcid = dcid;\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\t\tchan->tx_credits = credits;\n\t\tl2cap_chan_ready(chan);\n\t\tbreak;\n\n\tcase L2CAP_CR_LE_AUTHENTICATION:\n\tcase L2CAP_CR_LE_ENCRYPTION:\n\t\t/* If we already have MITM protection we can't do\n\t\t * anything.\n\t\t */\n\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM) {\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tbreak;\n\t\t}\n\n\t\tsec_level = hcon->sec_level + 1;\n\t\tif (chan->sec_level < sec_level)\n\t\t\tchan->sec_level = sec_level;\n\n\t\t/* We'll need to send a new Connect Request */\n\t\tclear_bit(FLAG_LE_CONN_REQ_SENT, &chan->flags);\n\n\t\tsmp_conn_security(hcon, chan->sec_level);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\tbreak;\n\t}\n\n\tl2cap_chan_unlock(chan);\n\nunlock:\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline int l2cap_bredr_sig_cmd(struct l2cap_conn *conn,\n\t\t\t\t      struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t      u8 *data)\n{\n\tint err = 0;\n\n\tswitch (cmd->code) {\n\tcase L2CAP_COMMAND_REJ:\n\t\tl2cap_command_rej(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_REQ:\n\t\terr = l2cap_connect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_RSP:\n\tcase L2CAP_CREATE_CHAN_RSP:\n\t\tl2cap_connect_create_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONF_REQ:\n\t\terr = l2cap_config_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONF_RSP:\n\t\tl2cap_config_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_REQ:\n\t\terr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_RSP:\n\t\tl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECHO_REQ:\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECHO_RSP, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECHO_RSP:\n\t\tbreak;\n\n\tcase L2CAP_INFO_REQ:\n\t\terr = l2cap_information_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_INFO_RSP:\n\t\tl2cap_information_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CREATE_CHAN_REQ:\n\t\terr = l2cap_create_channel_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_REQ:\n\t\terr = l2cap_move_channel_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_RSP:\n\t\tl2cap_move_channel_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_CFM:\n\t\terr = l2cap_move_channel_confirm(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_MOVE_CHAN_CFM_RSP:\n\t\tl2cap_move_channel_confirm_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown BR/EDR signaling command 0x%2.2x\", cmd->code);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_le_connect_req(struct l2cap_conn *conn,\n\t\t\t\tstruct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\tu8 *data)\n{\n\tstruct l2cap_le_conn_req *req = (struct l2cap_le_conn_req *) data;\n\tstruct l2cap_le_conn_rsp rsp;\n\tstruct l2cap_chan *chan, *pchan;\n\tu16 dcid, scid, credits, mtu, mps;\n\t__le16 psm;\n\tu8 result;\n\n\tif (cmd_len != sizeof(*req))\n\t\treturn -EPROTO;\n\n\tscid = __le16_to_cpu(req->scid);\n\tmtu  = __le16_to_cpu(req->mtu);\n\tmps  = __le16_to_cpu(req->mps);\n\tpsm  = req->psm;\n\tdcid = 0;\n\tcredits = 0;\n\n\tif (mtu < 23 || mps < 23)\n\t\treturn -EPROTO;\n\n\tBT_DBG(\"psm 0x%2.2x scid 0x%4.4x mtu %u mps %u\", __le16_to_cpu(psm),\n\t       scid, mtu, mps);\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, LE_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tchan = NULL;\n\t\tgoto response;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\tif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\n\t\t\t\t     SMP_ALLOW_STK)) {\n\t\tresult = L2CAP_CR_LE_AUTHENTICATION;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\t/* Check for valid dynamic CID range */\n\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\n\t\tresult = L2CAP_CR_LE_INVALID_SCID;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\t/* Check if we already have channel with that dcid */\n\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\tresult = L2CAP_CR_LE_SCID_IN_USE;\n\t\tchan = NULL;\n\t\tgoto response_unlock;\n\t}\n\n\tchan = pchan->ops->new_connection(pchan);\n\tif (!chan) {\n\t\tresult = L2CAP_CR_LE_NO_MEM;\n\t\tgoto response_unlock;\n\t}\n\n\tbacpy(&chan->src, &conn->hcon->src);\n\tbacpy(&chan->dst, &conn->hcon->dst);\n\tchan->src_type = bdaddr_src_type(conn->hcon);\n\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\tchan->psm  = psm;\n\tchan->dcid = scid;\n\tchan->omtu = mtu;\n\tchan->remote_mps = mps;\n\n\t__l2cap_chan_add(conn, chan);\n\n\tl2cap_le_flowctl_init(chan, __le16_to_cpu(req->credits));\n\n\tdcid = chan->scid;\n\tcredits = chan->rx_credits;\n\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\tchan->ident = cmd->ident;\n\n\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t/* The following result value is actually not defined\n\t\t * for LE CoC but we use it to let the function know\n\t\t * that it should bail out after doing its cleanup\n\t\t * instead of sending a response.\n\t\t */\n\t\tresult = L2CAP_CR_PEND;\n\t\tchan->ops->defer(chan);\n\t} else {\n\t\tl2cap_chan_ready(chan);\n\t\tresult = L2CAP_CR_LE_SUCCESS;\n\t}\n\nresponse_unlock:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\n\tif (result == L2CAP_CR_PEND)\n\t\treturn 0;\n\nresponse:\n\tif (chan) {\n\t\trsp.mtu = cpu_to_le16(chan->imtu);\n\t\trsp.mps = cpu_to_le16(chan->mps);\n\t} else {\n\t\trsp.mtu = 0;\n\t\trsp.mps = 0;\n\t}\n\n\trsp.dcid    = cpu_to_le16(dcid);\n\trsp.credits = cpu_to_le16(credits);\n\trsp.result  = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_LE_CONN_RSP, sizeof(rsp), &rsp);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_le_credits(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_le_credits *pkt;\n\tstruct l2cap_chan *chan;\n\tu16 cid, credits, max_credits;\n\n\tif (cmd_len != sizeof(*pkt))\n\t\treturn -EPROTO;\n\n\tpkt = (struct l2cap_le_credits *) data;\n\tcid\t= __le16_to_cpu(pkt->cid);\n\tcredits\t= __le16_to_cpu(pkt->credits);\n\n\tBT_DBG(\"cid 0x%4.4x credits 0x%4.4x\", cid, credits);\n\n\tchan = l2cap_get_chan_by_dcid(conn, cid);\n\tif (!chan)\n\t\treturn -EBADSLT;\n\n\tmax_credits = LE_FLOWCTL_MAX_CREDITS - chan->tx_credits;\n\tif (credits > max_credits) {\n\t\tBT_ERR(\"LE credits overflow\");\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tl2cap_chan_unlock(chan);\n\n\t\t/* Return 0 so that we don't trigger an unnecessary\n\t\t * command reject packet.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tchan->tx_credits += credits;\n\n\t/* Resume sending */\n\tl2cap_le_flowctl_send(chan);\n\n\tif (chan->tx_credits)\n\t\tchan->ops->resume(chan);\n\n\tl2cap_chan_unlock(chan);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_conn_req(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_ecred_conn_req *req = (void *) data;\n\tstruct {\n\t\tstruct l2cap_ecred_conn_rsp rsp;\n\t\t__le16 dcid[L2CAP_ECRED_MAX_CID];\n\t} __packed pdu;\n\tstruct l2cap_chan *chan, *pchan;\n\tu16 mtu, mps;\n\t__le16 psm;\n\tu8 result, len = 0;\n\tint i, num_scid;\n\tbool defer = false;\n\n\tif (!enable_ecred)\n\t\treturn -EINVAL;\n\n\tif (cmd_len < sizeof(*req) || (cmd_len - sizeof(*req)) % sizeof(u16)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto response;\n\t}\n\n\tcmd_len -= sizeof(*req);\n\tnum_scid = cmd_len / sizeof(u16);\n\n\tif (num_scid > ARRAY_SIZE(pdu.dcid)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto response;\n\t}\n\n\tmtu  = __le16_to_cpu(req->mtu);\n\tmps  = __le16_to_cpu(req->mps);\n\n\tif (mtu < L2CAP_ECRED_MIN_MTU || mps < L2CAP_ECRED_MIN_MPS) {\n\t\tresult = L2CAP_CR_LE_UNACCEPT_PARAMS;\n\t\tgoto response;\n\t}\n\n\tpsm  = req->psm;\n\n\tBT_DBG(\"psm 0x%2.2x mtu %u mps %u\", __le16_to_cpu(psm), mtu, mps);\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\t/* Check if we have socket listening on psm */\n\tpchan = l2cap_global_chan_by_psm(BT_LISTEN, psm, &conn->hcon->src,\n\t\t\t\t\t &conn->hcon->dst, LE_LINK);\n\tif (!pchan) {\n\t\tresult = L2CAP_CR_LE_BAD_PSM;\n\t\tgoto response;\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(pchan);\n\n\tif (!smp_sufficient_security(conn->hcon, pchan->sec_level,\n\t\t\t\t     SMP_ALLOW_STK)) {\n\t\tresult = L2CAP_CR_LE_AUTHENTICATION;\n\t\tgoto unlock;\n\t}\n\n\tresult = L2CAP_CR_LE_SUCCESS;\n\n\tfor (i = 0; i < num_scid; i++) {\n\t\tu16 scid = __le16_to_cpu(req->scid[i]);\n\n\t\tBT_DBG(\"scid[%d] 0x%4.4x\", i, scid);\n\n\t\tpdu.dcid[i] = 0x0000;\n\t\tlen += sizeof(*pdu.dcid);\n\n\t\t/* Check for valid dynamic CID range */\n\t\tif (scid < L2CAP_CID_DYN_START || scid > L2CAP_CID_LE_DYN_END) {\n\t\t\tresult = L2CAP_CR_LE_INVALID_SCID;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check if we already have channel with that dcid */\n\t\tif (__l2cap_get_chan_by_dcid(conn, scid)) {\n\t\t\tresult = L2CAP_CR_LE_SCID_IN_USE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchan = pchan->ops->new_connection(pchan);\n\t\tif (!chan) {\n\t\t\tresult = L2CAP_CR_LE_NO_MEM;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbacpy(&chan->src, &conn->hcon->src);\n\t\tbacpy(&chan->dst, &conn->hcon->dst);\n\t\tchan->src_type = bdaddr_src_type(conn->hcon);\n\t\tchan->dst_type = bdaddr_dst_type(conn->hcon);\n\t\tchan->psm  = psm;\n\t\tchan->dcid = scid;\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\n\t\t__l2cap_chan_add(conn, chan);\n\n\t\tl2cap_ecred_init(chan, __le16_to_cpu(req->credits));\n\n\t\t/* Init response */\n\t\tif (!pdu.rsp.credits) {\n\t\t\tpdu.rsp.mtu = cpu_to_le16(chan->imtu);\n\t\t\tpdu.rsp.mps = cpu_to_le16(chan->mps);\n\t\t\tpdu.rsp.credits = cpu_to_le16(chan->rx_credits);\n\t\t}\n\n\t\tpdu.dcid[i] = cpu_to_le16(chan->scid);\n\n\t\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\t\tchan->ident = cmd->ident;\n\n\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\tl2cap_state_change(chan, BT_CONNECT2);\n\t\t\tdefer = true;\n\t\t\tchan->ops->defer(chan);\n\t\t} else {\n\t\t\tl2cap_chan_ready(chan);\n\t\t}\n\t}\n\nunlock:\n\tl2cap_chan_unlock(pchan);\n\tmutex_unlock(&conn->chan_lock);\n\tl2cap_chan_put(pchan);\n\nresponse:\n\tpdu.rsp.result = cpu_to_le16(result);\n\n\tif (defer)\n\t\treturn 0;\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECRED_CONN_RSP,\n\t\t       sizeof(pdu.rsp) + len, &pdu);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_conn_rsp(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_ecred_conn_rsp *rsp = (void *) data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 mtu, mps, credits, result;\n\tstruct l2cap_chan *chan;\n\tint err = 0, sec_level;\n\tint i = 0;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tmtu     = __le16_to_cpu(rsp->mtu);\n\tmps     = __le16_to_cpu(rsp->mps);\n\tcredits = __le16_to_cpu(rsp->credits);\n\tresult  = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"mtu %u mps %u credits %u result 0x%4.4x\", mtu, mps, credits,\n\t       result);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tcmd_len -= sizeof(*rsp);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tu16 dcid;\n\n\t\tif (chan->ident != cmd->ident ||\n\t\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL ||\n\t\t    chan->state == BT_CONNECTED)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_lock(chan);\n\n\t\t/* Check that there is a dcid for each pending channel */\n\t\tif (cmd_len < sizeof(dcid)) {\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdcid = __le16_to_cpu(rsp->dcid[i++]);\n\t\tcmd_len -= sizeof(u16);\n\n\t\tBT_DBG(\"dcid[%d] 0x%4.4x\", i, dcid);\n\n\t\t/* Check if dcid is already in use */\n\t\tif (dcid && __l2cap_get_chan_by_dcid(conn, dcid)) {\n\t\t\t/* If a device receives a\n\t\t\t * L2CAP_CREDIT_BASED_CONNECTION_RSP packet with an\n\t\t\t * already-assigned Destination CID, then both the\n\t\t\t * original channel and the new channel shall be\n\t\t\t * immediately discarded and not used.\n\t\t\t */\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tchan = __l2cap_get_chan_by_dcid(conn, dcid);\n\t\t\tl2cap_chan_lock(chan);\n\t\t\tl2cap_chan_del(chan, ECONNRESET);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (result) {\n\t\tcase L2CAP_CR_LE_AUTHENTICATION:\n\t\tcase L2CAP_CR_LE_ENCRYPTION:\n\t\t\t/* If we already have MITM protection we can't do\n\t\t\t * anything.\n\t\t\t */\n\t\t\tif (hcon->sec_level > BT_SECURITY_MEDIUM) {\n\t\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsec_level = hcon->sec_level + 1;\n\t\t\tif (chan->sec_level < sec_level)\n\t\t\t\tchan->sec_level = sec_level;\n\n\t\t\t/* We'll need to send a new Connect Request */\n\t\t\tclear_bit(FLAG_ECRED_CONN_REQ_SENT, &chan->flags);\n\n\t\t\tsmp_conn_security(hcon, chan->sec_level);\n\t\t\tbreak;\n\n\t\tcase L2CAP_CR_LE_BAD_PSM:\n\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* If dcid was not set it means channels was refused */\n\t\t\tif (!dcid) {\n\t\t\t\tl2cap_chan_del(chan, ECONNREFUSED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->ident = 0;\n\t\t\tchan->dcid = dcid;\n\t\t\tchan->omtu = mtu;\n\t\t\tchan->remote_mps = mps;\n\t\t\tchan->tx_credits = credits;\n\t\t\tl2cap_chan_ready(chan);\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n\n\treturn err;\n}\n\nstatic inline int l2cap_ecred_reconf_req(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\t u8 *data)\n{\n\tstruct l2cap_ecred_reconf_req *req = (void *) data;\n\tstruct l2cap_ecred_reconf_rsp rsp;\n\tu16 mtu, mps, result;\n\tstruct l2cap_chan *chan;\n\tint i, num_scid;\n\n\tif (!enable_ecred)\n\t\treturn -EINVAL;\n\n\tif (cmd_len < sizeof(*req) || cmd_len - sizeof(*req) % sizeof(u16)) {\n\t\tresult = L2CAP_CR_LE_INVALID_PARAMS;\n\t\tgoto respond;\n\t}\n\n\tmtu = __le16_to_cpu(req->mtu);\n\tmps = __le16_to_cpu(req->mps);\n\n\tBT_DBG(\"mtu %u mps %u\", mtu, mps);\n\n\tif (mtu < L2CAP_ECRED_MIN_MTU) {\n\t\tresult = L2CAP_RECONF_INVALID_MTU;\n\t\tgoto respond;\n\t}\n\n\tif (mps < L2CAP_ECRED_MIN_MPS) {\n\t\tresult = L2CAP_RECONF_INVALID_MPS;\n\t\tgoto respond;\n\t}\n\n\tcmd_len -= sizeof(*req);\n\tnum_scid = cmd_len / sizeof(u16);\n\tresult = L2CAP_RECONF_SUCCESS;\n\n\tfor (i = 0; i < num_scid; i++) {\n\t\tu16 scid;\n\n\t\tscid = __le16_to_cpu(req->scid[i]);\n\t\tif (!scid)\n\t\t\treturn -EPROTO;\n\n\t\tchan = __l2cap_get_chan_by_dcid(conn, scid);\n\t\tif (!chan)\n\t\t\tcontinue;\n\n\t\t/* If the MTU value is decreased for any of the included\n\t\t * channels, then the receiver shall disconnect all\n\t\t * included channels.\n\t\t */\n\t\tif (chan->omtu > mtu) {\n\t\t\tBT_ERR(\"chan %p decreased MTU %u -> %u\", chan,\n\t\t\t       chan->omtu, mtu);\n\t\t\tresult = L2CAP_RECONF_INVALID_MTU;\n\t\t}\n\n\t\tchan->omtu = mtu;\n\t\tchan->remote_mps = mps;\n\t}\n\nrespond:\n\trsp.result = cpu_to_le16(result);\n\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_ECRED_RECONF_RSP, sizeof(rsp),\n\t\t       &rsp);\n\n\treturn 0;\n}\n\nstatic inline int l2cap_ecred_reconf_rsp(struct l2cap_conn *conn,\n\t\t\t\t\t struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t\t u8 *data)\n{\n\tstruct l2cap_chan *chan;\n\tstruct l2cap_ecred_conn_rsp *rsp = (void *) data;\n\tu16 result;\n\n\tif (cmd_len < sizeof(*rsp))\n\t\treturn -EPROTO;\n\n\tresult = __le16_to_cpu(rsp->result);\n\n\tBT_DBG(\"result 0x%4.4x\", rsp->result);\n\n\tif (!result)\n\t\treturn 0;\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tif (chan->ident != cmd->ident)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_del(chan, ECONNRESET);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int l2cap_le_command_rej(struct l2cap_conn *conn,\n\t\t\t\t       struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t       u8 *data)\n{\n\tstruct l2cap_cmd_rej_unk *rej = (struct l2cap_cmd_rej_unk *) data;\n\tstruct l2cap_chan *chan;\n\n\tif (cmd_len < sizeof(*rej))\n\t\treturn -EPROTO;\n\n\tmutex_lock(&conn->chan_lock);\n\n\tchan = __l2cap_get_chan_by_ident(conn, cmd->ident);\n\tif (!chan)\n\t\tgoto done;\n\n\tl2cap_chan_lock(chan);\n\tl2cap_chan_del(chan, ECONNREFUSED);\n\tl2cap_chan_unlock(chan);\n\ndone:\n\tmutex_unlock(&conn->chan_lock);\n\treturn 0;\n}\n\nstatic inline int l2cap_le_sig_cmd(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tint err = 0;\n\n\tswitch (cmd->code) {\n\tcase L2CAP_COMMAND_REJ:\n\t\tl2cap_le_command_rej(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_PARAM_UPDATE_REQ:\n\t\terr = l2cap_conn_param_update_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_CONN_PARAM_UPDATE_RSP:\n\t\tbreak;\n\n\tcase L2CAP_LE_CONN_RSP:\n\t\tl2cap_le_connect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_LE_CONN_REQ:\n\t\terr = l2cap_le_connect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_LE_CREDITS:\n\t\terr = l2cap_le_credits(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_CONN_REQ:\n\t\terr = l2cap_ecred_conn_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_CONN_RSP:\n\t\terr = l2cap_ecred_conn_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_RECONF_REQ:\n\t\terr = l2cap_ecred_reconf_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_ECRED_RECONF_RSP:\n\t\terr = l2cap_ecred_reconf_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_REQ:\n\t\terr = l2cap_disconnect_req(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tcase L2CAP_DISCONN_RSP:\n\t\tl2cap_disconnect_rsp(conn, cmd, cmd_len, data);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown LE signaling command 0x%2.2x\", cmd->code);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic inline void l2cap_le_sig_channel(struct l2cap_conn *conn,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_cmd_hdr *cmd;\n\tu16 len;\n\tint err;\n\n\tif (hcon->type != LE_LINK)\n\t\tgoto drop;\n\n\tif (skb->len < L2CAP_CMD_HDR_SIZE)\n\t\tgoto drop;\n\n\tcmd = (void *) skb->data;\n\tskb_pull(skb, L2CAP_CMD_HDR_SIZE);\n\n\tlen = le16_to_cpu(cmd->len);\n\n\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd->code, len, cmd->ident);\n\n\tif (len != skb->len || !cmd->ident) {\n\t\tBT_DBG(\"corrupted command\");\n\t\tgoto drop;\n\t}\n\n\terr = l2cap_le_sig_cmd(conn, cmd, len, skb->data);\n\tif (err) {\n\t\tstruct l2cap_cmd_rej_unk rej;\n\n\t\tBT_ERR(\"Wrong link type (%d)\", err);\n\n\t\trej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t       sizeof(rej), &rej);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic inline void l2cap_sig_channel(struct l2cap_conn *conn,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_cmd_hdr *cmd;\n\tint err;\n\n\tl2cap_raw_recv(conn, skb);\n\n\tif (hcon->type != ACL_LINK)\n\t\tgoto drop;\n\n\twhile (skb->len >= L2CAP_CMD_HDR_SIZE) {\n\t\tu16 len;\n\n\t\tcmd = (void *) skb->data;\n\t\tskb_pull(skb, L2CAP_CMD_HDR_SIZE);\n\n\t\tlen = le16_to_cpu(cmd->len);\n\n\t\tBT_DBG(\"code 0x%2.2x len %d id 0x%2.2x\", cmd->code, len,\n\t\t       cmd->ident);\n\n\t\tif (len > skb->len || !cmd->ident) {\n\t\t\tBT_DBG(\"corrupted command\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = l2cap_bredr_sig_cmd(conn, cmd, len, skb->data);\n\t\tif (err) {\n\t\t\tstruct l2cap_cmd_rej_unk rej;\n\n\t\t\tBT_ERR(\"Wrong link type (%d)\", err);\n\n\t\t\trej.reason = cpu_to_le16(L2CAP_REJ_NOT_UNDERSTOOD);\n\t\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,\n\t\t\t\t       sizeof(rej), &rej);\n\t\t}\n\n\t\tskb_pull(skb, len);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic int l2cap_check_fcs(struct l2cap_chan *chan,  struct sk_buff *skb)\n{\n\tu16 our_fcs, rcv_fcs;\n\tint hdr_size;\n\n\tif (test_bit(FLAG_EXT_CTRL, &chan->flags))\n\t\thdr_size = L2CAP_EXT_HDR_SIZE;\n\telse\n\t\thdr_size = L2CAP_ENH_HDR_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16) {\n\t\tskb_trim(skb, skb->len - L2CAP_FCS_SIZE);\n\t\trcv_fcs = get_unaligned_le16(skb->data + skb->len);\n\t\tour_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);\n\n\t\tif (our_fcs != rcv_fcs)\n\t\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\nstatic void l2cap_send_i_or_rr_or_rnr(struct l2cap_chan *chan)\n{\n\tstruct l2cap_ctrl control;\n\n\tBT_DBG(\"chan %p\", chan);\n\n\tmemset(&control, 0, sizeof(control));\n\tcontrol.sframe = 1;\n\tcontrol.final = 1;\n\tcontrol.reqseq = chan->buffer_seq;\n\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\n\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\tcontrol.super = L2CAP_SUPER_RNR;\n\t\tl2cap_send_sframe(chan, &control);\n\t}\n\n\tif (test_and_clear_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&\n\t    chan->unacked_frames > 0)\n\t\t__set_retrans_timer(chan);\n\n\t/* Send pending iframes */\n\tl2cap_ertm_send(chan);\n\n\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&\n\t    test_bit(CONN_SEND_FBIT, &chan->conn_state)) {\n\t\t/* F-bit wasn't sent in an s-frame or i-frame yet, so\n\t\t * send it now.\n\t\t */\n\t\tcontrol.super = L2CAP_SUPER_RR;\n\t\tl2cap_send_sframe(chan, &control);\n\t}\n}\n\nstatic void append_skb_frag(struct sk_buff *skb, struct sk_buff *new_frag,\n\t\t\t    struct sk_buff **last_frag)\n{\n\t/* skb->len reflects data in skb as well as all fragments\n\t * skb->data_len reflects only data in fragments\n\t */\n\tif (!skb_has_frag_list(skb))\n\t\tskb_shinfo(skb)->frag_list = new_frag;\n\n\tnew_frag->next = NULL;\n\n\t(*last_frag)->next = new_frag;\n\t*last_frag = new_frag;\n\n\tskb->len += new_frag->len;\n\tskb->data_len += new_frag->len;\n\tskb->truesize += new_frag->truesize;\n}\n\nstatic int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb,\n\t\t\t\tstruct l2cap_ctrl *control)\n{\n\tint err = -EINVAL;\n\n\tswitch (control->sar) {\n\tcase L2CAP_SAR_UNSEGMENTED:\n\t\tif (chan->sdu)\n\t\t\tbreak;\n\n\t\terr = chan->ops->recv(chan, skb);\n\t\tbreak;\n\n\tcase L2CAP_SAR_START:\n\t\tif (chan->sdu)\n\t\t\tbreak;\n\n\t\tif (!pskb_may_pull(skb, L2CAP_SDULEN_SIZE))\n\t\t\tbreak;\n\n\t\tchan->sdu_len = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, L2CAP_SDULEN_SIZE);\n\n\t\tif (chan->sdu_len > chan->imtu) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len >= chan->sdu_len)\n\t\t\tbreak;\n\n\t\tchan->sdu = skb;\n\t\tchan->sdu_last_frag = skb;\n\n\t\tskb = NULL;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase L2CAP_SAR_CONTINUE:\n\t\tif (!chan->sdu)\n\t\t\tbreak;\n\n\t\tappend_skb_frag(chan->sdu, skb,\n\t\t\t\t&chan->sdu_last_frag);\n\t\tskb = NULL;\n\n\t\tif (chan->sdu->len >= chan->sdu_len)\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase L2CAP_SAR_END:\n\t\tif (!chan->sdu)\n\t\t\tbreak;\n\n\t\tappend_skb_frag(chan->sdu, skb,\n\t\t\t\t&chan->sdu_last_frag);\n\t\tskb = NULL;\n\n\t\tif (chan->sdu->len != chan->sdu_len)\n\t\t\tbreak;\n\n\t\terr = chan->ops->recv(chan, chan->sdu);\n\n\t\tif (!err) {\n\t\t\t/* Reassembly complete */\n\t\t\tchan->sdu = NULL;\n\t\t\tchan->sdu_last_frag = NULL;\n\t\t\tchan->sdu_len = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(chan->sdu);\n\t\tchan->sdu = NULL;\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_resegment(struct l2cap_chan *chan)\n{\n\t/* Placeholder */\n\treturn 0;\n}\n\nvoid l2cap_chan_busy(struct l2cap_chan *chan, int busy)\n{\n\tu8 event;\n\n\tif (chan->mode != L2CAP_MODE_ERTM)\n\t\treturn;\n\n\tevent = busy ? L2CAP_EV_LOCAL_BUSY_DETECTED : L2CAP_EV_LOCAL_BUSY_CLEAR;\n\tl2cap_tx(chan, NULL, NULL, event);\n}\n\nstatic int l2cap_rx_queued_iframes(struct l2cap_chan *chan)\n{\n\tint err = 0;\n\t/* Pass sequential frames to l2cap_reassemble_sdu()\n\t * until a gap is encountered.\n\t */\n\n\tBT_DBG(\"chan %p\", chan);\n\n\twhile (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\tstruct sk_buff *skb;\n\t\tBT_DBG(\"Searching for skb with txseq %d (queue len %d)\",\n\t\t       chan->buffer_seq, skb_queue_len(&chan->srej_q));\n\n\t\tskb = l2cap_ertm_seq_in_queue(&chan->srej_q, chan->buffer_seq);\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tskb_unlink(skb, &chan->srej_q);\n\t\tchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\n\t\terr = l2cap_reassemble_sdu(chan, skb, &bt_cb(skb)->l2cap);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (skb_queue_empty(&chan->srej_q)) {\n\t\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\t\tl2cap_send_ack(chan);\n\t}\n\n\treturn err;\n}\n\nstatic void l2cap_handle_srej(struct l2cap_chan *chan,\n\t\t\t      struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->reqseq == chan->next_tx_seq) {\n\t\tBT_DBG(\"Invalid reqseq %d, disconnecting\", control->reqseq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\n\n\tif (skb == NULL) {\n\t\tBT_DBG(\"Seq %d not available for retransmission\",\n\t\t       control->reqseq);\n\t\treturn;\n\t}\n\n\tif (chan->max_tx != 0 && bt_cb(skb)->l2cap.retries >= chan->max_tx) {\n\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tif (control->poll) {\n\t\tl2cap_pass_to_tx(chan, control);\n\n\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\tl2cap_retransmit(chan, control);\n\t\tl2cap_ertm_send(chan);\n\n\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\n\t\t\tset_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tchan->srej_save_reqseq = control->reqseq;\n\t\t}\n\t} else {\n\t\tl2cap_pass_to_tx_fbit(chan, control);\n\n\t\tif (control->final) {\n\t\t\tif (chan->srej_save_reqseq != control->reqseq ||\n\t\t\t    !test_and_clear_bit(CONN_SREJ_ACT,\n\t\t\t\t\t\t&chan->conn_state))\n\t\t\t\tl2cap_retransmit(chan, control);\n\t\t} else {\n\t\t\tl2cap_retransmit(chan, control);\n\t\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F) {\n\t\t\t\tset_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\t\tchan->srej_save_reqseq = control->reqseq;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void l2cap_handle_rej(struct l2cap_chan *chan,\n\t\t\t     struct l2cap_ctrl *control)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"chan %p, control %p\", chan, control);\n\n\tif (control->reqseq == chan->next_tx_seq) {\n\t\tBT_DBG(\"Invalid reqseq %d, disconnecting\", control->reqseq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tskb = l2cap_ertm_seq_in_queue(&chan->tx_q, control->reqseq);\n\n\tif (chan->max_tx && skb &&\n\t    bt_cb(skb)->l2cap.retries >= chan->max_tx) {\n\t\tBT_DBG(\"Retry limit exceeded (%d)\", chan->max_tx);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn;\n\t}\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tl2cap_pass_to_tx(chan, control);\n\n\tif (control->final) {\n\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))\n\t\t\tl2cap_retransmit_all(chan, control);\n\t} else {\n\t\tl2cap_retransmit_all(chan, control);\n\t\tl2cap_ertm_send(chan);\n\t\tif (chan->tx_state == L2CAP_TX_STATE_WAIT_F)\n\t\t\tset_bit(CONN_REJ_ACT, &chan->conn_state);\n\t}\n}\n\nstatic u8 l2cap_classify_txseq(struct l2cap_chan *chan, u16 txseq)\n{\n\tBT_DBG(\"chan %p, txseq %d\", chan, txseq);\n\n\tBT_DBG(\"last_acked_seq %d, expected_tx_seq %d\", chan->last_acked_seq,\n\t       chan->expected_tx_seq);\n\n\tif (chan->rx_state == L2CAP_RX_STATE_SREJ_SENT) {\n\t\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\n\t\t    chan->tx_win) {\n\t\t\t/* See notes below regarding \"double poll\" and\n\t\t\t * invalid packets.\n\t\t\t */\n\t\t\tif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\n\t\t\t\tBT_DBG(\"Invalid/Ignore - after SREJ\");\n\t\t\t\treturn L2CAP_TXSEQ_INVALID_IGNORE;\n\t\t\t} else {\n\t\t\t\tBT_DBG(\"Invalid - in window after SREJ sent\");\n\t\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t\t}\n\t\t}\n\n\t\tif (chan->srej_list.head == txseq) {\n\t\t\tBT_DBG(\"Expected SREJ\");\n\t\t\treturn L2CAP_TXSEQ_EXPECTED_SREJ;\n\t\t}\n\n\t\tif (l2cap_ertm_seq_in_queue(&chan->srej_q, txseq)) {\n\t\t\tBT_DBG(\"Duplicate SREJ - txseq already stored\");\n\t\t\treturn L2CAP_TXSEQ_DUPLICATE_SREJ;\n\t\t}\n\n\t\tif (l2cap_seq_list_contains(&chan->srej_list, txseq)) {\n\t\t\tBT_DBG(\"Unexpected SREJ - not requested\");\n\t\t\treturn L2CAP_TXSEQ_UNEXPECTED_SREJ;\n\t\t}\n\t}\n\n\tif (chan->expected_tx_seq == txseq) {\n\t\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >=\n\t\t    chan->tx_win) {\n\t\t\tBT_DBG(\"Invalid - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t} else {\n\t\t\tBT_DBG(\"Expected\");\n\t\t\treturn L2CAP_TXSEQ_EXPECTED;\n\t\t}\n\t}\n\n\tif (__seq_offset(chan, txseq, chan->last_acked_seq) <\n\t    __seq_offset(chan, chan->expected_tx_seq, chan->last_acked_seq)) {\n\t\tBT_DBG(\"Duplicate - expected_tx_seq later than txseq\");\n\t\treturn L2CAP_TXSEQ_DUPLICATE;\n\t}\n\n\tif (__seq_offset(chan, txseq, chan->last_acked_seq) >= chan->tx_win) {\n\t\t/* A source of invalid packets is a \"double poll\" condition,\n\t\t * where delays cause us to send multiple poll packets.  If\n\t\t * the remote stack receives and processes both polls,\n\t\t * sequence numbers can wrap around in such a way that a\n\t\t * resent frame has a sequence number that looks like new data\n\t\t * with a sequence gap.  This would trigger an erroneous SREJ\n\t\t * request.\n\t\t *\n\t\t * Fortunately, this is impossible with a tx window that's\n\t\t * less than half of the maximum sequence number, which allows\n\t\t * invalid frames to be safely ignored.\n\t\t *\n\t\t * With tx window sizes greater than half of the tx window\n\t\t * maximum, the frame is invalid and cannot be ignored.  This\n\t\t * causes a disconnect.\n\t\t */\n\n\t\tif (chan->tx_win <= ((chan->tx_win_max + 1) >> 1)) {\n\t\t\tBT_DBG(\"Invalid/Ignore - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID_IGNORE;\n\t\t} else {\n\t\t\tBT_DBG(\"Invalid - txseq outside tx window\");\n\t\t\treturn L2CAP_TXSEQ_INVALID;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Unexpected - txseq indicates missing frames\");\n\t\treturn L2CAP_TXSEQ_UNEXPECTED;\n\t}\n}\n\nstatic int l2cap_rx_state_recv(struct l2cap_chan *chan,\n\t\t\t       struct l2cap_ctrl *control,\n\t\t\t       struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, control->txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding expected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan,\n\t\t\t\t\t\t\t   control->txseq);\n\n\t\t\tchan->buffer_seq = chan->expected_tx_seq;\n\t\t\tskb_in_use = true;\n\n\t\t\terr = l2cap_reassemble_sdu(chan, skb, control);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tif (control->final) {\n\t\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\t\tcontrol->final = 0;\n\t\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t\t\tl2cap_ertm_send(chan);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state))\n\t\t\t\tl2cap_send_ack(chan);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\n\t\t\t/* Can't issue SREJ frames in the local busy state.\n\t\t\t * Drop this frame, it will be seen as missing\n\t\t\t * when local busy is exited.\n\t\t\t */\n\t\t\tif (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {\n\t\t\t\tBT_DBG(\"Busy, discarding unexpected seq %d\",\n\t\t\t\t       control->txseq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* There was a gap in the sequence, so an SREJ\n\t\t\t * must be sent for each missing frame.  The\n\t\t\t * current frame is stored for later use.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tclear_bit(CONN_SREJ_ACT, &chan->conn_state);\n\t\t\tl2cap_seq_list_clear(&chan->srej_list);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\n\t\t\tchan->rx_state = L2CAP_RX_STATE_SREJ_SENT;\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state) &&\n\t\t\t    !__chan_is_moving(chan)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tl2cap_send_i_or_rr_or_rnr(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control && control->poll) {\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_rr_or_rnr(chan, 0);\n\t\t}\n\t\t__clear_retrans_timer(chan);\n\t\tl2cap_seq_list_clear(&chan->retrans_list);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_rx_state_srej_sent(struct l2cap_chan *chan,\n\t\t\t\t    struct l2cap_ctrl *control,\n\t\t\t\t    struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\tu16 txseq = control->txseq;\n\tbool skb_in_use = false;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tswitch (event) {\n\tcase L2CAP_EV_RECV_IFRAME:\n\t\tswitch (l2cap_classify_txseq(chan, txseq)) {\n\t\tcase L2CAP_TXSEQ_EXPECTED:\n\t\t\t/* Keep frame for reassembly later */\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tchan->expected_tx_seq = __next_seq(chan, txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_EXPECTED_SREJ:\n\t\t\tl2cap_seq_list_pop(&chan->srej_list);\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\terr = l2cap_rx_queued_iframes(chan);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED:\n\t\t\t/* Got a frame that can't be reassembled yet.\n\t\t\t * Save it for later, and send SREJs to cover\n\t\t\t * the missing frames.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tl2cap_send_srej(chan, control->txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_UNEXPECTED_SREJ:\n\t\t\t/* This frame was requested with an SREJ, but\n\t\t\t * some expected retransmitted frames are\n\t\t\t * missing.  Request retransmission of missing\n\t\t\t * SREJ'd frames.\n\t\t\t */\n\t\t\tskb_queue_tail(&chan->srej_q, skb);\n\t\t\tskb_in_use = true;\n\t\t\tBT_DBG(\"Queued %p (queue len %d)\", skb,\n\t\t\t       skb_queue_len(&chan->srej_q));\n\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tl2cap_send_srej_list(chan, control->txseq);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE_SREJ:\n\t\t\t/* We've already queued this frame.  Drop this copy. */\n\t\t\tl2cap_pass_to_tx(chan, control);\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_DUPLICATE:\n\t\t\t/* Expecting a later sequence number, so this frame\n\t\t\t * was already received.  Ignore it completely.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID_IGNORE:\n\t\t\tbreak;\n\t\tcase L2CAP_TXSEQ_INVALID:\n\t\tdefault:\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RR:\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->final) {\n\t\t\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\t\t\tif (!test_and_clear_bit(CONN_REJ_ACT,\n\t\t\t\t\t\t&chan->conn_state)) {\n\t\t\t\tcontrol->final = 0;\n\t\t\t\tl2cap_retransmit_all(chan, control);\n\t\t\t}\n\n\t\t\tl2cap_ertm_send(chan);\n\t\t} else if (control->poll) {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames) {\n\t\t\t\t__set_retrans_timer(chan);\n\t\t\t}\n\n\t\t\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\t\t\tl2cap_send_srej_tail(chan);\n\t\t} else {\n\t\t\tif (test_and_clear_bit(CONN_REMOTE_BUSY,\n\t\t\t\t\t       &chan->conn_state) &&\n\t\t\t    chan->unacked_frames)\n\t\t\t\t__set_retrans_timer(chan);\n\n\t\t\tl2cap_send_ack(chan);\n\t\t}\n\t\tbreak;\n\tcase L2CAP_EV_RECV_RNR:\n\t\tset_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\t\tl2cap_pass_to_tx(chan, control);\n\t\tif (control->poll) {\n\t\t\tl2cap_send_srej_tail(chan);\n\t\t} else {\n\t\t\tstruct l2cap_ctrl rr_control;\n\t\t\tmemset(&rr_control, 0, sizeof(rr_control));\n\t\t\trr_control.sframe = 1;\n\t\t\trr_control.super = L2CAP_SUPER_RR;\n\t\t\trr_control.reqseq = chan->buffer_seq;\n\t\t\tl2cap_send_sframe(chan, &rr_control);\n\t\t}\n\n\t\tbreak;\n\tcase L2CAP_EV_RECV_REJ:\n\t\tl2cap_handle_rej(chan, control);\n\t\tbreak;\n\tcase L2CAP_EV_RECV_SREJ:\n\t\tl2cap_handle_srej(chan, control);\n\t\tbreak;\n\t}\n\n\tif (skb && !skb_in_use) {\n\t\tBT_DBG(\"Freeing %p\", skb);\n\t\tkfree_skb(skb);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_finish_move(struct l2cap_chan *chan)\n{\n\tBT_DBG(\"chan %p\", chan);\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\n\tif (chan->hs_hcon)\n\t\tchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\n\telse\n\t\tchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\n\n\treturn l2cap_resegment(chan);\n}\n\nstatic int l2cap_rx_state_wait_p(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control,\n\t\t\t\t struct sk_buff *skb, u8 event)\n{\n\tint err;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d\", chan, control, skb,\n\t       event);\n\n\tif (!control->poll)\n\t\treturn -EPROTO;\n\n\tl2cap_process_reqseq(chan, control->reqseq);\n\n\tif (!skb_queue_empty(&chan->tx_q))\n\t\tchan->tx_send_head = skb_peek(&chan->tx_q);\n\telse\n\t\tchan->tx_send_head = NULL;\n\n\t/* Rewind next_tx_seq to the point expected\n\t * by the receiver.\n\t */\n\tchan->next_tx_seq = control->reqseq;\n\tchan->unacked_frames = 0;\n\n\terr = l2cap_finish_move(chan);\n\tif (err)\n\t\treturn err;\n\n\tset_bit(CONN_SEND_FBIT, &chan->conn_state);\n\tl2cap_send_i_or_rr_or_rnr(chan);\n\n\tif (event == L2CAP_EV_RECV_IFRAME)\n\t\treturn -EPROTO;\n\n\treturn l2cap_rx_state_recv(chan, control, NULL, event);\n}\n\nstatic int l2cap_rx_state_wait_f(struct l2cap_chan *chan,\n\t\t\t\t struct l2cap_ctrl *control,\n\t\t\t\t struct sk_buff *skb, u8 event)\n{\n\tint err;\n\n\tif (!control->final)\n\t\treturn -EPROTO;\n\n\tclear_bit(CONN_REMOTE_BUSY, &chan->conn_state);\n\n\tchan->rx_state = L2CAP_RX_STATE_RECV;\n\tl2cap_process_reqseq(chan, control->reqseq);\n\n\tif (!skb_queue_empty(&chan->tx_q))\n\t\tchan->tx_send_head = skb_peek(&chan->tx_q);\n\telse\n\t\tchan->tx_send_head = NULL;\n\n\t/* Rewind next_tx_seq to the point expected\n\t * by the receiver.\n\t */\n\tchan->next_tx_seq = control->reqseq;\n\tchan->unacked_frames = 0;\n\n\tif (chan->hs_hcon)\n\t\tchan->conn->mtu = chan->hs_hcon->hdev->block_mtu;\n\telse\n\t\tchan->conn->mtu = chan->conn->hcon->hdev->acl_mtu;\n\n\terr = l2cap_resegment(chan);\n\n\tif (!err)\n\t\terr = l2cap_rx_state_recv(chan, control, skb, event);\n\n\treturn err;\n}\n\nstatic bool __valid_reqseq(struct l2cap_chan *chan, u16 reqseq)\n{\n\t/* Make sure reqseq is for a packet that has been sent but not acked */\n\tu16 unacked;\n\n\tunacked = __seq_offset(chan, chan->next_tx_seq, chan->expected_ack_seq);\n\treturn __seq_offset(chan, chan->next_tx_seq, reqseq) <= unacked;\n}\n\nstatic int l2cap_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t    struct sk_buff *skb, u8 event)\n{\n\tint err = 0;\n\n\tBT_DBG(\"chan %p, control %p, skb %p, event %d, state %d\", chan,\n\t       control, skb, event, chan->rx_state);\n\n\tif (__valid_reqseq(chan, control->reqseq)) {\n\t\tswitch (chan->rx_state) {\n\t\tcase L2CAP_RX_STATE_RECV:\n\t\t\terr = l2cap_rx_state_recv(chan, control, skb, event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_SREJ_SENT:\n\t\t\terr = l2cap_rx_state_srej_sent(chan, control, skb,\n\t\t\t\t\t\t       event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_WAIT_P:\n\t\t\terr = l2cap_rx_state_wait_p(chan, control, skb, event);\n\t\t\tbreak;\n\t\tcase L2CAP_RX_STATE_WAIT_F:\n\t\t\terr = l2cap_rx_state_wait_f(chan, control, skb, event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* shut it down */\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tBT_DBG(\"Invalid reqseq %d (next_tx_seq %d, expected_ack_seq %d\",\n\t\t       control->reqseq, chan->next_tx_seq,\n\t\t       chan->expected_ack_seq);\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t}\n\n\treturn err;\n}\n\nstatic int l2cap_stream_rx(struct l2cap_chan *chan, struct l2cap_ctrl *control,\n\t\t\t   struct sk_buff *skb)\n{\n\tBT_DBG(\"chan %p, control %p, skb %p, state %d\", chan, control, skb,\n\t       chan->rx_state);\n\n\tif (l2cap_classify_txseq(chan, control->txseq) ==\n\t    L2CAP_TXSEQ_EXPECTED) {\n\t\tl2cap_pass_to_tx(chan, control);\n\n\t\tBT_DBG(\"buffer_seq %d->%d\", chan->buffer_seq,\n\t\t       __next_seq(chan, chan->buffer_seq));\n\n\t\tchan->buffer_seq = __next_seq(chan, chan->buffer_seq);\n\n\t\tl2cap_reassemble_sdu(chan, skb, control);\n\t} else {\n\t\tif (chan->sdu) {\n\t\t\tkfree_skb(chan->sdu);\n\t\t\tchan->sdu = NULL;\n\t\t}\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\n\t\tif (skb) {\n\t\t\tBT_DBG(\"Freeing %p\", skb);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tchan->last_acked_seq = control->txseq;\n\tchan->expected_tx_seq = __next_seq(chan, control->txseq);\n\n\treturn 0;\n}\n\nstatic int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct l2cap_ctrl *control = &bt_cb(skb)->l2cap;\n\tu16 len;\n\tu8 event;\n\n\t__unpack_control(chan, skb);\n\n\tlen = skb->len;\n\n\t/*\n\t * We can just drop the corrupted I-frame here.\n\t * Receiver will miss it and start proper recovery\n\t * procedures and ask for retransmission.\n\t */\n\tif (l2cap_check_fcs(chan, skb))\n\t\tgoto drop;\n\n\tif (!control->sframe && control->sar == L2CAP_SAR_START)\n\t\tlen -= L2CAP_SDULEN_SIZE;\n\n\tif (chan->fcs == L2CAP_FCS_CRC16)\n\t\tlen -= L2CAP_FCS_SIZE;\n\n\tif (len > chan->mps) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto drop;\n\t}\n\n\tif (chan->ops->filter) {\n\t\tif (chan->ops->filter(chan, skb))\n\t\t\tgoto drop;\n\t}\n\n\tif (!control->sframe) {\n\t\tint err;\n\n\t\tBT_DBG(\"iframe sar %d, reqseq %d, final %d, txseq %d\",\n\t\t       control->sar, control->reqseq, control->final,\n\t\t       control->txseq);\n\n\t\t/* Validate F-bit - F=0 always valid, F=1 only\n\t\t * valid in TX WAIT_F\n\t\t */\n\t\tif (control->final && chan->tx_state != L2CAP_TX_STATE_WAIT_F)\n\t\t\tgoto drop;\n\n\t\tif (chan->mode != L2CAP_MODE_STREAMING) {\n\t\t\tevent = L2CAP_EV_RECV_IFRAME;\n\t\t\terr = l2cap_rx(chan, control, skb, event);\n\t\t} else {\n\t\t\terr = l2cap_stream_rx(chan, control, skb);\n\t\t}\n\n\t\tif (err)\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t} else {\n\t\tconst u8 rx_func_to_event[4] = {\n\t\t\tL2CAP_EV_RECV_RR, L2CAP_EV_RECV_REJ,\n\t\t\tL2CAP_EV_RECV_RNR, L2CAP_EV_RECV_SREJ\n\t\t};\n\n\t\t/* Only I-frames are expected in streaming mode */\n\t\tif (chan->mode == L2CAP_MODE_STREAMING)\n\t\t\tgoto drop;\n\n\t\tBT_DBG(\"sframe reqseq %d, final %d, poll %d, super %d\",\n\t\t       control->reqseq, control->final, control->poll,\n\t\t       control->super);\n\n\t\tif (len != 0) {\n\t\t\tBT_ERR(\"Trailing bytes: %d in sframe\", len);\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Validate F and P bits */\n\t\tif (control->final && (control->poll ||\n\t\t\t\t       chan->tx_state != L2CAP_TX_STATE_WAIT_F))\n\t\t\tgoto drop;\n\n\t\tevent = rx_func_to_event[control->super];\n\t\tif (l2cap_rx(chan, control, skb, event))\n\t\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t}\n\n\treturn 0;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void l2cap_chan_le_send_credits(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct l2cap_le_credits pkt;\n\tu16 return_credits;\n\n\treturn_credits = (chan->imtu / chan->mps) + 1;\n\n\tif (chan->rx_credits >= return_credits)\n\t\treturn;\n\n\treturn_credits -= chan->rx_credits;\n\n\tBT_DBG(\"chan %p returning %u credits to sender\", chan, return_credits);\n\n\tchan->rx_credits += return_credits;\n\n\tpkt.cid     = cpu_to_le16(chan->scid);\n\tpkt.credits = cpu_to_le16(return_credits);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_LE_CREDITS, sizeof(pkt), &pkt);\n}\n\nstatic int l2cap_ecred_recv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tBT_DBG(\"SDU reassemble complete: chan %p skb->len %u\", chan, skb->len);\n\n\t/* Wait recv to confirm reception before updating the credits */\n\terr = chan->ops->recv(chan, skb);\n\n\t/* Update credits whenever an SDU is received */\n\tl2cap_chan_le_send_credits(chan);\n\n\treturn err;\n}\n\nstatic int l2cap_ecred_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tint err;\n\n\tif (!chan->rx_credits) {\n\t\tBT_ERR(\"No credits to receive LE L2CAP data\");\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (chan->imtu < skb->len) {\n\t\tBT_ERR(\"Too big LE L2CAP PDU\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tchan->rx_credits--;\n\tBT_DBG(\"rx_credits %u -> %u\", chan->rx_credits + 1, chan->rx_credits);\n\n\t/* Update if remote had run out of credits, this should only happens\n\t * if the remote is not using the entire MPS.\n\t */\n\tif (!chan->rx_credits)\n\t\tl2cap_chan_le_send_credits(chan);\n\n\terr = 0;\n\n\tif (!chan->sdu) {\n\t\tu16 sdu_len;\n\n\t\tsdu_len = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, L2CAP_SDULEN_SIZE);\n\n\t\tBT_DBG(\"Start of new SDU. sdu_len %u skb->len %u imtu %u\",\n\t\t       sdu_len, skb->len, chan->imtu);\n\n\t\tif (sdu_len > chan->imtu) {\n\t\t\tBT_ERR(\"Too big LE L2CAP SDU length received\");\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (skb->len > sdu_len) {\n\t\t\tBT_ERR(\"Too much LE L2CAP data received\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (skb->len == sdu_len)\n\t\t\treturn l2cap_ecred_recv(chan, skb);\n\n\t\tchan->sdu = skb;\n\t\tchan->sdu_len = sdu_len;\n\t\tchan->sdu_last_frag = skb;\n\n\t\t/* Detect if remote is not able to use the selected MPS */\n\t\tif (skb->len + L2CAP_SDULEN_SIZE < chan->mps) {\n\t\t\tu16 mps_len = skb->len + L2CAP_SDULEN_SIZE;\n\n\t\t\t/* Adjust the number of credits */\n\t\t\tBT_DBG(\"chan->mps %u -> %u\", chan->mps, mps_len);\n\t\t\tchan->mps = mps_len;\n\t\t\tl2cap_chan_le_send_credits(chan);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tBT_DBG(\"SDU fragment. chan->sdu->len %u skb->len %u chan->sdu_len %u\",\n\t       chan->sdu->len, skb->len, chan->sdu_len);\n\n\tif (chan->sdu->len + skb->len > chan->sdu_len) {\n\t\tBT_ERR(\"Too much LE L2CAP data received\");\n\t\terr = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tappend_skb_frag(chan->sdu, skb, &chan->sdu_last_frag);\n\tskb = NULL;\n\n\tif (chan->sdu->len == chan->sdu_len) {\n\t\terr = l2cap_ecred_recv(chan, chan->sdu);\n\t\tif (!err) {\n\t\t\tchan->sdu = NULL;\n\t\t\tchan->sdu_last_frag = NULL;\n\t\t\tchan->sdu_len = 0;\n\t\t}\n\t}\n\nfailed:\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(chan->sdu);\n\t\tchan->sdu = NULL;\n\t\tchan->sdu_last_frag = NULL;\n\t\tchan->sdu_len = 0;\n\t}\n\n\t/* We can't return an error here since we took care of the skb\n\t * freeing internally. An error return would cause the caller to\n\t * do a double-free of the skb.\n\t */\n\treturn 0;\n}\n\nstatic void l2cap_data_channel(struct l2cap_conn *conn, u16 cid,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct l2cap_chan *chan;\n\n\tchan = l2cap_get_chan_by_scid(conn, cid);\n\tif (!chan) {\n\t\tif (cid == L2CAP_CID_A2MP) {\n\t\t\tchan = a2mp_channel_create(conn, skb);\n\t\t\tif (!chan) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tl2cap_chan_lock(chan);\n\t\t} else {\n\t\t\tBT_DBG(\"unknown cid 0x%4.4x\", cid);\n\t\t\t/* Drop packet and return */\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tBT_DBG(\"chan %p, len %d\", chan, skb->len);\n\n\t/* If we receive data on a fixed channel before the info req/rsp\n\t * procdure is done simply assume that the channel is supported\n\t * and mark it as ready.\n\t */\n\tif (chan->chan_type == L2CAP_CHAN_FIXED)\n\t\tl2cap_chan_ready(chan);\n\n\tif (chan->state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (l2cap_ecred_data_rcv(chan, skb) < 0)\n\t\t\tgoto drop;\n\n\t\tgoto done;\n\n\tcase L2CAP_MODE_BASIC:\n\t\t/* If socket recv buffers overflows we drop data here\n\t\t * which is *bad* because L2CAP has to be reliable.\n\t\t * But we don't have any other choice. L2CAP doesn't\n\t\t * provide flow control mechanism. */\n\n\t\tif (chan->imtu < skb->len) {\n\t\t\tBT_ERR(\"Dropping L2CAP data: receive buffer overflow\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (!chan->ops->recv(chan, skb))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tl2cap_data_rcv(chan, skb);\n\t\tgoto done;\n\n\tdefault:\n\t\tBT_DBG(\"chan %p: bad mode 0x%2.2x\", chan, chan->mode);\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\ndone:\n\tl2cap_chan_unlock(chan);\n}\n\nstatic void l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct hci_conn *hcon = conn->hcon;\n\tstruct l2cap_chan *chan;\n\n\tif (hcon->type != ACL_LINK)\n\t\tgoto free_skb;\n\n\tchan = l2cap_global_chan_by_psm(0, psm, &hcon->src, &hcon->dst,\n\t\t\t\t\tACL_LINK);\n\tif (!chan)\n\t\tgoto free_skb;\n\n\tBT_DBG(\"chan %p, len %d\", chan, skb->len);\n\n\tif (chan->state != BT_BOUND && chan->state != BT_CONNECTED)\n\t\tgoto drop;\n\n\tif (chan->imtu < skb->len)\n\t\tgoto drop;\n\n\t/* Store remote BD_ADDR and PSM for msg_name */\n\tbacpy(&bt_cb(skb)->l2cap.bdaddr, &hcon->dst);\n\tbt_cb(skb)->l2cap.psm = psm;\n\n\tif (!chan->ops->recv(chan, skb)) {\n\t\tl2cap_chan_put(chan);\n\t\treturn;\n\t}\n\ndrop:\n\tl2cap_chan_put(chan);\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct l2cap_hdr *lh = (void *) skb->data;\n\tstruct hci_conn *hcon = conn->hcon;\n\tu16 cid, len;\n\t__le16 psm;\n\n\tif (hcon->state != BT_CONNECTED) {\n\t\tBT_DBG(\"queueing pending rx skb\");\n\t\tskb_queue_tail(&conn->pending_rx, skb);\n\t\treturn;\n\t}\n\n\tskb_pull(skb, L2CAP_HDR_SIZE);\n\tcid = __le16_to_cpu(lh->cid);\n\tlen = __le16_to_cpu(lh->len);\n\n\tif (len != skb->len) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t/* Since we can't actively block incoming LE connections we must\n\t * at least ensure that we ignore incoming data from them.\n\t */\n\tif (hcon->type == LE_LINK &&\n\t    hci_bdaddr_list_lookup(&hcon->hdev->blacklist, &hcon->dst,\n\t\t\t\t   bdaddr_dst_type(hcon))) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tBT_DBG(\"len %d, cid 0x%4.4x\", len, cid);\n\n\tswitch (cid) {\n\tcase L2CAP_CID_SIGNALING:\n\t\tl2cap_sig_channel(conn, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_CONN_LESS:\n\t\tpsm = get_unaligned((__le16 *) skb->data);\n\t\tskb_pull(skb, L2CAP_PSMLEN_SIZE);\n\t\tl2cap_conless_channel(conn, psm, skb);\n\t\tbreak;\n\n\tcase L2CAP_CID_LE_SIGNALING:\n\t\tl2cap_le_sig_channel(conn, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tl2cap_data_channel(conn, cid, skb);\n\t\tbreak;\n\t}\n}\n\nstatic void process_pending_rx(struct work_struct *work)\n{\n\tstruct l2cap_conn *conn = container_of(work, struct l2cap_conn,\n\t\t\t\t\t       pending_rx_work);\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"\");\n\n\twhile ((skb = skb_dequeue(&conn->pending_rx)))\n\t\tl2cap_recv_frame(conn, skb);\n}\n\nstatic struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct hci_chan *hchan;\n\n\tif (conn)\n\t\treturn conn;\n\n\thchan = hci_chan_create(hcon);\n\tif (!hchan)\n\t\treturn NULL;\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn) {\n\t\thci_chan_del(hchan);\n\t\treturn NULL;\n\t}\n\n\tkref_init(&conn->ref);\n\thcon->l2cap_data = conn;\n\tconn->hcon = hci_conn_get(hcon);\n\tconn->hchan = hchan;\n\n\tBT_DBG(\"hcon %p conn %p hchan %p\", hcon, conn, hchan);\n\n\tswitch (hcon->type) {\n\tcase LE_LINK:\n\t\tif (hcon->hdev->le_mtu) {\n\t\t\tconn->mtu = hcon->hdev->le_mtu;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tconn->mtu = hcon->hdev->acl_mtu;\n\t\tbreak;\n\t}\n\n\tconn->feat_mask = 0;\n\n\tconn->local_fixed_chan = L2CAP_FC_SIG_BREDR | L2CAP_FC_CONNLESS;\n\n\tif (hcon->type == ACL_LINK &&\n\t    hci_dev_test_flag(hcon->hdev, HCI_HS_ENABLED))\n\t\tconn->local_fixed_chan |= L2CAP_FC_A2MP;\n\n\tif (hci_dev_test_flag(hcon->hdev, HCI_LE_ENABLED) &&\n\t    (bredr_sc_enabled(hcon->hdev) ||\n\t     hci_dev_test_flag(hcon->hdev, HCI_FORCE_BREDR_SMP)))\n\t\tconn->local_fixed_chan |= L2CAP_FC_SMP_BREDR;\n\n\tmutex_init(&conn->ident_lock);\n\tmutex_init(&conn->chan_lock);\n\n\tINIT_LIST_HEAD(&conn->chan_l);\n\tINIT_LIST_HEAD(&conn->users);\n\n\tINIT_DELAYED_WORK(&conn->info_timer, l2cap_info_timeout);\n\n\tskb_queue_head_init(&conn->pending_rx);\n\tINIT_WORK(&conn->pending_rx_work, process_pending_rx);\n\tINIT_WORK(&conn->id_addr_update_work, l2cap_conn_update_id_addr);\n\n\tconn->disc_reason = HCI_ERROR_REMOTE_USER_TERM;\n\n\treturn conn;\n}\n\nstatic bool is_valid_psm(u16 psm, u8 dst_type) {\n\tif (!psm)\n\t\treturn false;\n\n\tif (bdaddr_type_is_le(dst_type))\n\t\treturn (psm <= 0x00ff);\n\n\t/* PSM must be odd and lsb of upper byte must be 0 */\n\treturn ((psm & 0x0101) == 0x0001);\n}\n\nstruct l2cap_chan_data {\n\tstruct l2cap_chan *chan;\n\tstruct pid *pid;\n\tint count;\n};\n\nstatic void l2cap_chan_by_pid(struct l2cap_chan *chan, void *data)\n{\n\tstruct l2cap_chan_data *d = data;\n\tstruct pid *pid;\n\n\tif (chan == d->chan)\n\t\treturn;\n\n\tif (!test_bit(FLAG_DEFER_SETUP, &chan->flags))\n\t\treturn;\n\n\tpid = chan->ops->get_peer_pid(chan);\n\n\t/* Only count deferred channels with the same PID/PSM */\n\tif (d->pid != pid || chan->psm != d->chan->psm || chan->ident ||\n\t    chan->mode != L2CAP_MODE_EXT_FLOWCTL || chan->state != BT_CONNECT)\n\t\treturn;\n\n\td->count++;\n}\n\nint l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,\n\t\t       bdaddr_t *dst, u8 dst_type)\n{\n\tstruct l2cap_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"%pMR -> %pMR (type %u) psm 0x%4.4x mode 0x%2.2x\", &chan->src,\n\t       dst, dst_type, __le16_to_cpu(psm), chan->mode);\n\n\thdev = hci_get_route(dst, &chan->src, chan->src_type);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\n\thci_dev_lock(hdev);\n\n\tif (!is_valid_psm(__le16_to_cpu(psm), dst_type) && !cid &&\n\t    chan->chan_type != L2CAP_CHAN_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED && !psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (chan->chan_type == L2CAP_CHAN_FIXED && !cid) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_LE_FLOWCTL:\n\t\tbreak;\n\tcase L2CAP_MODE_EXT_FLOWCTL:\n\t\tif (!enable_ecred) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (!disable_ertm)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\tswitch (chan->state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\t/* Already connecting */\n\t\terr = 0;\n\t\tgoto done;\n\n\tcase BT_CONNECTED:\n\t\t/* Already connected */\n\t\terr = -EISCONN;\n\t\tgoto done;\n\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\t/* Can connect */\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\t/* Set destination address and psm */\n\tbacpy(&chan->dst, dst);\n\tchan->dst_type = dst_type;\n\n\tchan->psm = psm;\n\tchan->dcid = cid;\n\n\tif (bdaddr_type_is_le(dst_type)) {\n\t\t/* Convert from L2CAP channel address type to HCI address type\n\t\t */\n\t\tif (dst_type == BDADDR_LE_PUBLIC)\n\t\t\tdst_type = ADDR_LE_DEV_PUBLIC;\n\t\telse\n\t\t\tdst_type = ADDR_LE_DEV_RANDOM;\n\n\t\tif (hci_dev_test_flag(hdev, HCI_ADVERTISING))\n\t\t\thcon = hci_connect_le(hdev, dst, dst_type,\n\t\t\t\t\t      chan->sec_level,\n\t\t\t\t\t      HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t      HCI_ROLE_SLAVE, NULL);\n\t\telse\n\t\t\thcon = hci_connect_le_scan(hdev, dst, dst_type,\n\t\t\t\t\t\t   chan->sec_level,\n\t\t\t\t\t\t   HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t\t   CONN_REASON_L2CAP_CHAN);\n\n\t} else {\n\t\tu8 auth_type = l2cap_get_auth_type(chan);\n\t\thcon = hci_connect_acl(hdev, dst, chan->sec_level, auth_type,\n\t\t\t\t       CONN_REASON_L2CAP_CHAN);\n\t}\n\n\tif (IS_ERR(hcon)) {\n\t\terr = PTR_ERR(hcon);\n\t\tgoto done;\n\t}\n\n\tconn = l2cap_conn_add(hcon);\n\tif (!conn) {\n\t\thci_conn_drop(hcon);\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif (chan->mode == L2CAP_MODE_EXT_FLOWCTL) {\n\t\tstruct l2cap_chan_data data;\n\n\t\tdata.chan = chan;\n\t\tdata.pid = chan->ops->get_peer_pid(chan);\n\t\tdata.count = 1;\n\n\t\tl2cap_chan_list(conn, l2cap_chan_by_pid, &data);\n\n\t\t/* Check if there isn't too many channels being connected */\n\t\tif (data.count > L2CAP_ECRED_CONN_SCID_MAX) {\n\t\t\thci_conn_drop(hcon);\n\t\t\terr = -EPROTO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tmutex_lock(&conn->chan_lock);\n\tl2cap_chan_lock(chan);\n\n\tif (cid && __l2cap_get_chan_by_dcid(conn, cid)) {\n\t\thci_conn_drop(hcon);\n\t\terr = -EBUSY;\n\t\tgoto chan_unlock;\n\t}\n\n\t/* Update source addr of the socket */\n\tbacpy(&chan->src, &hcon->src);\n\tchan->src_type = bdaddr_src_type(hcon);\n\n\t__l2cap_chan_add(conn, chan);\n\n\t/* l2cap_chan_add takes its own ref so we can drop this one */\n\thci_conn_drop(hcon);\n\n\tl2cap_state_change(chan, BT_CONNECT);\n\t__set_chan_timer(chan, chan->ops->get_sndtimeo(chan));\n\n\t/* Release chan->sport so that it can be reused by other\n\t * sockets (as it's only used for listening sockets).\n\t */\n\twrite_lock(&chan_list_lock);\n\tchan->sport = 0;\n\twrite_unlock(&chan_list_lock);\n\n\tif (hcon->state == BT_CONNECTED) {\n\t\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {\n\t\t\t__clear_chan_timer(chan);\n\t\t\tif (l2cap_chan_check_security(chan, true))\n\t\t\t\tl2cap_state_change(chan, BT_CONNECTED);\n\t\t} else\n\t\t\tl2cap_do_start(chan);\n\t}\n\n\terr = 0;\n\nchan_unlock:\n\tl2cap_chan_unlock(chan);\n\tmutex_unlock(&conn->chan_lock);\ndone:\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2cap_chan_connect);\n\nstatic void l2cap_ecred_reconfigure(struct l2cap_chan *chan)\n{\n\tstruct l2cap_conn *conn = chan->conn;\n\tstruct {\n\t\tstruct l2cap_ecred_reconf_req req;\n\t\t__le16 scid;\n\t} pdu;\n\n\tpdu.req.mtu = cpu_to_le16(chan->imtu);\n\tpdu.req.mps = cpu_to_le16(chan->mps);\n\tpdu.scid    = cpu_to_le16(chan->scid);\n\n\tchan->ident = l2cap_get_ident(conn);\n\n\tl2cap_send_cmd(conn, chan->ident, L2CAP_ECRED_RECONF_REQ,\n\t\t       sizeof(pdu), &pdu);\n}\n\nint l2cap_chan_reconfigure(struct l2cap_chan *chan, __u16 mtu)\n{\n\tif (chan->imtu > mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"chan %p mtu 0x%4.4x\", chan, mtu);\n\n\tchan->imtu = mtu;\n\n\tl2cap_ecred_reconfigure(chan);\n\n\treturn 0;\n}\n\n/* ---- L2CAP interface with lower layer (HCI) ---- */\n\nint l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)\n{\n\tint exact = 0, lm1 = 0, lm2 = 0;\n\tstruct l2cap_chan *c;\n\n\tBT_DBG(\"hdev %s, bdaddr %pMR\", hdev->name, bdaddr);\n\n\t/* Find listening sockets and check their link_mode */\n\tread_lock(&chan_list_lock);\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tif (c->state != BT_LISTEN)\n\t\t\tcontinue;\n\n\t\tif (!bacmp(&c->src, &hdev->bdaddr)) {\n\t\t\tlm1 |= HCI_LM_ACCEPT;\n\t\t\tif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\n\t\t\t\tlm1 |= HCI_LM_MASTER;\n\t\t\texact++;\n\t\t} else if (!bacmp(&c->src, BDADDR_ANY)) {\n\t\t\tlm2 |= HCI_LM_ACCEPT;\n\t\t\tif (test_bit(FLAG_ROLE_SWITCH, &c->flags))\n\t\t\t\tlm2 |= HCI_LM_MASTER;\n\t\t}\n\t}\n\tread_unlock(&chan_list_lock);\n\n\treturn exact ? lm1 : lm2;\n}\n\n/* Find the next fixed channel in BT_LISTEN state, continue iteration\n * from an existing channel in the list or from the beginning of the\n * global list (by passing NULL as first parameter).\n */\nstatic struct l2cap_chan *l2cap_global_fixed_chan(struct l2cap_chan *c,\n\t\t\t\t\t\t  struct hci_conn *hcon)\n{\n\tu8 src_type = bdaddr_src_type(hcon);\n\n\tread_lock(&chan_list_lock);\n\n\tif (c)\n\t\tc = list_next_entry(c, global_l);\n\telse\n\t\tc = list_entry(chan_list.next, typeof(*c), global_l);\n\n\tlist_for_each_entry_from(c, &chan_list, global_l) {\n\t\tif (c->chan_type != L2CAP_CHAN_FIXED)\n\t\t\tcontinue;\n\t\tif (c->state != BT_LISTEN)\n\t\t\tcontinue;\n\t\tif (bacmp(&c->src, &hcon->src) && bacmp(&c->src, BDADDR_ANY))\n\t\t\tcontinue;\n\t\tif (src_type != c->src_type)\n\t\t\tcontinue;\n\n\t\tl2cap_chan_hold(c);\n\t\tread_unlock(&chan_list_lock);\n\t\treturn c;\n\t}\n\n\tread_unlock(&chan_list_lock);\n\n\treturn NULL;\n}\n\nstatic void l2cap_connect_cfm(struct hci_conn *hcon, u8 status)\n{\n\tstruct hci_dev *hdev = hcon->hdev;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *pchan;\n\tu8 dst_type;\n\n\tif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p bdaddr %pMR status %d\", hcon, &hcon->dst, status);\n\n\tif (status) {\n\t\tl2cap_conn_del(hcon, bt_to_errno(status));\n\t\treturn;\n\t}\n\n\tconn = l2cap_conn_add(hcon);\n\tif (!conn)\n\t\treturn;\n\n\tdst_type = bdaddr_dst_type(hcon);\n\n\t/* If device is blocked, do not create channels for it */\n\tif (hci_bdaddr_list_lookup(&hdev->blacklist, &hcon->dst, dst_type))\n\t\treturn;\n\n\t/* Find fixed channels and notify them of the new connection. We\n\t * use multiple individual lookups, continuing each time where\n\t * we left off, because the list lock would prevent calling the\n\t * potentially sleeping l2cap_chan_lock() function.\n\t */\n\tpchan = l2cap_global_fixed_chan(NULL, hcon);\n\twhile (pchan) {\n\t\tstruct l2cap_chan *chan, *next;\n\n\t\t/* Client fixed channels should override server ones */\n\t\tif (__l2cap_get_chan_by_dcid(conn, pchan->scid))\n\t\t\tgoto next;\n\n\t\tl2cap_chan_lock(pchan);\n\t\tchan = pchan->ops->new_connection(pchan);\n\t\tif (chan) {\n\t\t\tbacpy(&chan->src, &hcon->src);\n\t\t\tbacpy(&chan->dst, &hcon->dst);\n\t\t\tchan->src_type = bdaddr_src_type(hcon);\n\t\t\tchan->dst_type = dst_type;\n\n\t\t\t__l2cap_chan_add(conn, chan);\n\t\t}\n\n\t\tl2cap_chan_unlock(pchan);\nnext:\n\t\tnext = l2cap_global_fixed_chan(pchan, hcon);\n\t\tl2cap_chan_put(pchan);\n\t\tpchan = next;\n\t}\n\n\tl2cap_conn_ready(conn);\n}\n\nint l2cap_disconn_ind(struct hci_conn *hcon)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\n\tBT_DBG(\"hcon %p\", hcon);\n\n\tif (!conn)\n\t\treturn HCI_ERROR_REMOTE_USER_TERM;\n\treturn conn->disc_reason;\n}\n\nstatic void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)\n{\n\tif (hcon->type != ACL_LINK && hcon->type != LE_LINK)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p reason %d\", hcon, reason);\n\n\tl2cap_conn_del(hcon, bt_to_errno(reason));\n}\n\nstatic inline void l2cap_check_encryption(struct l2cap_chan *chan, u8 encrypt)\n{\n\tif (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)\n\t\treturn;\n\n\tif (encrypt == 0x00) {\n\t\tif (chan->sec_level == BT_SECURITY_MEDIUM) {\n\t\t\t__set_chan_timer(chan, L2CAP_ENC_TIMEOUT);\n\t\t} else if (chan->sec_level == BT_SECURITY_HIGH ||\n\t\t\t   chan->sec_level == BT_SECURITY_FIPS)\n\t\t\tl2cap_chan_close(chan, ECONNREFUSED);\n\t} else {\n\t\tif (chan->sec_level == BT_SECURITY_MEDIUM)\n\t\t\t__clear_chan_timer(chan);\n\t}\n}\n\nstatic void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"conn %p status 0x%2.2x encrypt %u\", conn, status, encrypt);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tBT_DBG(\"chan %p scid 0x%4.4x state %s\", chan, chan->scid,\n\t\t       state_to_string(chan->state));\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && encrypt)\n\t\t\tchan->sec_level = hcon->sec_level;\n\n\t\tif (!__l2cap_no_conn_pending(chan)) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (chan->state == BT_CONNECTED ||\n\t\t\t\tchan->state == BT_CONFIG)) {\n\t\t\tchan->ops->resume(chan);\n\t\t\tl2cap_check_encryption(chan, encrypt);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!status && l2cap_check_enc_key_size(hcon))\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t} else if (chan->state == BT_CONNECT2 &&\n\t\t\t   !(chan->mode == L2CAP_MODE_EXT_FLOWCTL ||\n\t\t\t     chan->mode == L2CAP_MODE_LE_FLOWCTL)) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 res, stat;\n\n\t\t\tif (!status && l2cap_check_enc_key_size(hcon)) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\tres = L2CAP_CR_PEND;\n\t\t\t\t\tstat = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\t\tchan->ops->defer(chan);\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tres = L2CAP_CR_SUCCESS;\n\t\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t\t\tres = L2CAP_CR_SEC_BLOCK;\n\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(chan->scid);\n\t\t\trsp.result = cpu_to_le16(res);\n\t\t\trsp.status = cpu_to_le16(stat);\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t\t\t    res == L2CAP_CR_SUCCESS) {\n\t\t\t\tchar buf[128];\n\t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),\n\t\t\t\t\t       buf);\n\t\t\t\tchan->num_conf_req++;\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}\n\n/* Append fragment into frame respecting the maximum len of rx_skb */\nstatic int l2cap_recv_frag(struct l2cap_conn *conn, struct sk_buff *skb,\n\t\t\t   u16 len)\n{\n\tif (!conn->rx_skb) {\n\t\t/* Allocate skb for the complete frame (with header) */\n\t\tconn->rx_skb = bt_skb_alloc(len, GFP_KERNEL);\n\t\tif (!conn->rx_skb)\n\t\t\treturn -ENOMEM;\n\t\t/* Init rx_len */\n\t\tconn->rx_len = len;\n\t}\n\n\t/* Copy as much as the rx_skb can hold */\n\tlen = min_t(u16, len, skb->len);\n\tskb_copy_from_linear_data(skb, skb_put(conn->rx_skb, len), len);\n\tskb_pull(skb, len);\n\tconn->rx_len -= len;\n\n\treturn len;\n}\n\nstatic int l2cap_recv_len(struct l2cap_conn *conn, struct sk_buff *skb)\n{\n\tstruct sk_buff *rx_skb;\n\tint len;\n\n\t/* Append just enough to complete the header */\n\tlen = l2cap_recv_frag(conn, skb, L2CAP_LEN_SIZE - conn->rx_skb->len);\n\n\t/* If header could not be read just continue */\n\tif (len < 0 || conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\treturn len;\n\n\trx_skb = conn->rx_skb;\n\tlen = get_unaligned_le16(rx_skb->data);\n\n\t/* Check if rx_skb has enough space to received all fragments */\n\tif (len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE) <= skb_tailroom(rx_skb)) {\n\t\t/* Update expected len */\n\t\tconn->rx_len = len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE);\n\t\treturn L2CAP_LEN_SIZE;\n\t}\n\n\t/* Reset conn->rx_skb since it will need to be reallocated in order to\n\t * fit all fragments.\n\t */\n\tconn->rx_skb = NULL;\n\n\t/* Reallocates rx_skb using the exact expected length */\n\tlen = l2cap_recv_frag(conn, rx_skb,\n\t\t\t      len + (L2CAP_HDR_SIZE - L2CAP_LEN_SIZE));\n\tkfree_skb(rx_skb);\n\n\treturn len;\n}\n\nstatic void l2cap_recv_reset(struct l2cap_conn *conn)\n{\n\tkfree_skb(conn->rx_skb);\n\tconn->rx_skb = NULL;\n\tconn->rx_len = 0;\n}\n\nvoid l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tint len;\n\n\t/* For AMP controller do not create l2cap conn */\n\tif (!conn && hcon->hdev->dev_type != HCI_PRIMARY)\n\t\tgoto drop;\n\n\tif (!conn)\n\t\tconn = l2cap_conn_add(hcon);\n\n\tif (!conn)\n\t\tgoto drop;\n\n\tBT_DBG(\"conn %p len %d flags 0x%x\", conn, skb->len, flags);\n\n\tswitch (flags) {\n\tcase ACL_START:\n\tcase ACL_START_NO_FLUSH:\n\tcase ACL_COMPLETE:\n\t\tif (conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected start frame (len %d)\", skb->len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t}\n\n\t\t/* Start fragment may not contain the L2CAP length so just\n\t\t * copy the initial byte when that happens and use conn->mtu as\n\t\t * expected length.\n\t\t */\n\t\tif (skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_frag(conn, skb, conn->mtu) < 0)\n\t\t\t\tgoto drop;\n\t\t\treturn;\n\t\t}\n\n\t\tlen = get_unaligned_le16(skb->data) + L2CAP_HDR_SIZE;\n\n\t\tif (len == skb->len) {\n\t\t\t/* Complete frame received */\n\t\t\tl2cap_recv_frame(conn, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tBT_DBG(\"Start: total len %d, frag len %d\", len, skb->len);\n\n\t\tif (skb->len > len) {\n\t\t\tBT_ERR(\"Frame is too long (len %d, expected len %d)\",\n\t\t\t       skb->len, len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tif (l2cap_recv_frag(conn, skb, len) < 0)\n\t\t\tgoto drop;\n\n\t\tbreak;\n\n\tcase ACL_CONT:\n\t\tBT_DBG(\"Cont: frag len %d (expecting %d)\", skb->len, conn->rx_len);\n\n\t\tif (!conn->rx_skb) {\n\t\t\tBT_ERR(\"Unexpected continuation frame (len %d)\", skb->len);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Complete the L2CAP length if it has not been read */\n\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE) {\n\t\t\tif (l2cap_recv_len(conn, skb) < 0) {\n\t\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\t/* Header still could not be read just continue */\n\t\t\tif (conn->rx_skb->len < L2CAP_LEN_SIZE)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (skb->len > conn->rx_len) {\n\t\t\tBT_ERR(\"Fragment is too long (len %d, expected %d)\",\n\t\t\t       skb->len, conn->rx_len);\n\t\t\tl2cap_recv_reset(conn);\n\t\t\tl2cap_conn_unreliable(conn, ECOMM);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t/* Append fragment into frame (with header) */\n\t\tl2cap_recv_frag(conn, skb, skb->len);\n\n\t\tif (!conn->rx_len) {\n\t\t\t/* Complete frame received. l2cap_recv_frame\n\t\t\t * takes ownership of the skb so set the global\n\t\t\t * rx_skb pointer to NULL first.\n\t\t\t */\n\t\t\tstruct sk_buff *rx_skb = conn->rx_skb;\n\t\t\tconn->rx_skb = NULL;\n\t\t\tl2cap_recv_frame(conn, rx_skb);\n\t\t}\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n}\n\nstatic struct hci_cb l2cap_cb = {\n\t.name\t\t= \"L2CAP\",\n\t.connect_cfm\t= l2cap_connect_cfm,\n\t.disconn_cfm\t= l2cap_disconn_cfm,\n\t.security_cfm\t= l2cap_security_cfm,\n};\n\nstatic int l2cap_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct l2cap_chan *c;\n\n\tread_lock(&chan_list_lock);\n\n\tlist_for_each_entry(c, &chan_list, global_l) {\n\t\tseq_printf(f, \"%pMR (%u) %pMR (%u) %d %d 0x%4.4x 0x%4.4x %d %d %d %d\\n\",\n\t\t\t   &c->src, c->src_type, &c->dst, c->dst_type,\n\t\t\t   c->state, __le16_to_cpu(c->psm),\n\t\t\t   c->scid, c->dcid, c->imtu, c->omtu,\n\t\t\t   c->sec_level, c->mode);\n\t}\n\n\tread_unlock(&chan_list_lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(l2cap_debugfs);\n\nstatic struct dentry *l2cap_debugfs;\n\nint __init l2cap_init(void)\n{\n\tint err;\n\n\terr = l2cap_init_sockets();\n\tif (err < 0)\n\t\treturn err;\n\n\thci_register_cb(&l2cap_cb);\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\tl2cap_debugfs = debugfs_create_file(\"l2cap\", 0444, bt_debugfs,\n\t\t\t\t\t    NULL, &l2cap_debugfs_fops);\n\n\treturn 0;\n}\n\nvoid l2cap_exit(void)\n{\n\tdebugfs_remove(l2cap_debugfs);\n\thci_unregister_cb(&l2cap_cb);\n\tl2cap_cleanup_sockets();\n}\n\nmodule_param(disable_ertm, bool, 0644);\nMODULE_PARM_DESC(disable_ertm, \"Disable enhanced retransmission mode\");\n\nmodule_param(enable_ecred, bool, 0644);\nMODULE_PARM_DESC(enable_ecred, \"Enable enhanced credit flow control mode\");\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 4119}, "message": "warn: impossible condition '(scid > 65535) => (0-u16max > u16max)'"}], "macros": [], "notes": [], "path": "/src/net/bluetooth/l2cap_core.c", "reportHash": "4eb25828ba4d5117c05d2c0dc8c1b699", "checkerName": "smatch.check_signed", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
