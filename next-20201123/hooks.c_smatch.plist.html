<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/security/selinux/hooks.c", "content": "// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  NSA Security-Enhanced Linux (SELinux) security module\n *\n *  This file contains the SELinux hook function implementations.\n *\n *  Authors:  Stephen Smalley, <sds@tycho.nsa.gov>\n *\t      Chris Vance, <cvance@nai.com>\n *\t      Wayne Salamon, <wsalamon@nai.com>\n *\t      James Morris <jmorris@redhat.com>\n *\n *  Copyright (C) 2001,2002 Networks Associates Technology, Inc.\n *  Copyright (C) 2003-2008 Red Hat, Inc., James Morris <jmorris@redhat.com>\n *\t\t\t\t\t   Eric Paris <eparis@redhat.com>\n *  Copyright (C) 2004-2005 Trusted Computer Solutions, Inc.\n *\t\t\t    <dgoeddel@trustedcs.com>\n *  Copyright (C) 2006, 2007, 2009 Hewlett-Packard Development Company, L.P.\n *\tPaul Moore <paul@paul-moore.com>\n *  Copyright (C) 2007 Hitachi Software Engineering Co., Ltd.\n *\t\t       Yuichi Nakamura <ynakam@hitachisoft.jp>\n *  Copyright (C) 2016 Mellanox Technologies\n */\n\n#include <linux/init.h>\n#include <linux/kd.h>\n#include <linux/kernel.h>\n#include <linux/kernel_read_file.h>\n#include <linux/tracehook.h>\n#include <linux/errno.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/lsm_hooks.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include <linux/unistd.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/fs_parser.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/tty.h>\n#include <net/icmp.h>\n#include <net/ip.h>\t\t/* for local_port_range[] */\n#include <net/tcp.h>\t\t/* struct or_callable used in sock_rcv_skb */\n#include <net/inet_connection_sock.h>\n#include <net/net_namespace.h>\n#include <net/netlabel.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n#include <linux/atomic.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\t/* for network interface checks */\n#include <net/netlink.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/dccp.h>\n#include <linux/sctp.h>\n#include <net/sctp/structs.h>\n#include <linux/quota.h>\n#include <linux/un.h>\t\t/* for Unix socket types */\n#include <net/af_unix.h>\t/* for Unix socket types */\n#include <linux/parser.h>\n#include <linux/nfs_mount.h>\n#include <net/ipv6.h>\n#include <linux/hugetlb.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/string.h>\n#include <linux/mutex.h>\n#include <linux/posix-timers.h>\n#include <linux/syslog.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/msg.h>\n#include <linux/shm.h>\n#include <linux/bpf.h>\n#include <linux/kernfs.h>\n#include <linux/stringhash.h>\t/* for hashlen_string() */\n#include <uapi/linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/fanotify.h>\n\n#include \"avc.h\"\n#include \"objsec.h\"\n#include \"netif.h\"\n#include \"netnode.h\"\n#include \"netport.h\"\n#include \"ibpkey.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"audit.h\"\n#include \"avc_ss.h\"\n\nstruct selinux_state selinux_state;\n\n/* SECMARK reference count */\nstatic atomic_t selinux_secmark_refcount = ATOMIC_INIT(0);\n\n#ifdef CONFIG_SECURITY_SELINUX_DEVELOP\nstatic int selinux_enforcing_boot __initdata;\n\nstatic int __init enforcing_setup(char *str)\n{\n\tunsigned long enforcing;\n\tif (!kstrtoul(str, 0, &enforcing))\n\t\tselinux_enforcing_boot = enforcing ? 1 : 0;\n\treturn 1;\n}\n__setup(\"enforcing=\", enforcing_setup);\n#else\n#define selinux_enforcing_boot 1\n#endif\n\nint selinux_enabled_boot __initdata = 1;\n#ifdef CONFIG_SECURITY_SELINUX_BOOTPARAM\nstatic int __init selinux_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tif (!kstrtoul(str, 0, &enabled))\n\t\tselinux_enabled_boot = enabled ? 1 : 0;\n\treturn 1;\n}\n__setup(\"selinux=\", selinux_enabled_setup);\n#endif\n\nstatic unsigned int selinux_checkreqprot_boot =\n\tCONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE;\n\nstatic int __init checkreqprot_setup(char *str)\n{\n\tunsigned long checkreqprot;\n\n\tif (!kstrtoul(str, 0, &checkreqprot)) {\n\t\tselinux_checkreqprot_boot = checkreqprot ? 1 : 0;\n\t\tif (checkreqprot)\n\t\t\tpr_warn(\"SELinux: checkreqprot set to 1 via kernel parameter.  This is deprecated and will be rejected in a future kernel release.\\n\");\n\t}\n\treturn 1;\n}\n__setup(\"checkreqprot=\", checkreqprot_setup);\n\n/**\n * selinux_secmark_enabled - Check to see if SECMARK is currently enabled\n *\n * Description:\n * This function checks the SECMARK reference counter to see if any SECMARK\n * targets are currently configured, if the reference counter is greater than\n * zero SECMARK is considered to be enabled.  Returns true (1) if SECMARK is\n * enabled, false (0) if SECMARK is disabled.  If the always_check_network\n * policy capability is enabled, SECMARK is always considered enabled.\n *\n */\nstatic int selinux_secmark_enabled(void)\n{\n\treturn (selinux_policycap_alwaysnetwork() ||\n\t\tatomic_read(&selinux_secmark_refcount));\n}\n\n/**\n * selinux_peerlbl_enabled - Check to see if peer labeling is currently enabled\n *\n * Description:\n * This function checks if NetLabel or labeled IPSEC is enabled.  Returns true\n * (1) if any are enabled or false (0) if neither are enabled.  If the\n * always_check_network policy capability is enabled, peer labeling\n * is always considered enabled.\n *\n */\nstatic int selinux_peerlbl_enabled(void)\n{\n\treturn (selinux_policycap_alwaysnetwork() ||\n\t\tnetlbl_enabled() || selinux_xfrm_enabled());\n}\n\nstatic int selinux_netcache_avc_callback(u32 event)\n{\n\tif (event == AVC_CALLBACK_RESET) {\n\t\tsel_netif_flush();\n\t\tsel_netnode_flush();\n\t\tsel_netport_flush();\n\t\tsynchronize_net();\n\t}\n\treturn 0;\n}\n\nstatic int selinux_lsm_notifier_avc_callback(u32 event)\n{\n\tif (event == AVC_CALLBACK_RESET) {\n\t\tsel_ib_pkey_flush();\n\t\tcall_blocking_lsm_notifier(LSM_POLICY_CHANGE, NULL);\n\t}\n\n\treturn 0;\n}\n\n/*\n * initialise the security for the init task\n */\nstatic void cred_init_security(void)\n{\n\tstruct cred *cred = (struct cred *) current->real_cred;\n\tstruct task_security_struct *tsec;\n\n\ttsec = selinux_cred(cred);\n\ttsec->osid = tsec->sid = SECINITSID_KERNEL;\n}\n\n/*\n * get the security ID of a set of credentials\n */\nstatic inline u32 cred_sid(const struct cred *cred)\n{\n\tconst struct task_security_struct *tsec;\n\n\ttsec = selinux_cred(cred);\n\treturn tsec->sid;\n}\n\n/*\n * get the objective security ID of a task\n */\nstatic inline u32 task_sid(const struct task_struct *task)\n{\n\tu32 sid;\n\n\trcu_read_lock();\n\tsid = cred_sid(__task_cred(task));\n\trcu_read_unlock();\n\treturn sid;\n}\n\nstatic int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);\n\n/*\n * Try reloading inode security labels that have been marked as invalid.  The\n * @may_sleep parameter indicates when sleeping and thus reloading labels is\n * allowed; when set to false, returns -ECHILD when the label is\n * invalid.  The @dentry parameter should be set to a dentry of the inode.\n */\nstatic int __inode_security_revalidate(struct inode *inode,\n\t\t\t\t       struct dentry *dentry,\n\t\t\t\t       bool may_sleep)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\n\tmight_sleep_if(may_sleep);\n\n\tif (selinux_initialized(&selinux_state) &&\n\t    isec->initialized != LABEL_INITIALIZED) {\n\t\tif (!may_sleep)\n\t\t\treturn -ECHILD;\n\n\t\t/*\n\t\t * Try reloading the inode security label.  This will fail if\n\t\t * @opt_dentry is NULL and no dentry for this inode can be\n\t\t * found; in that case, continue using the old label.\n\t\t */\n\t\tinode_doinit_with_dentry(inode, dentry);\n\t}\n\treturn 0;\n}\n\nstatic struct inode_security_struct *inode_security_novalidate(struct inode *inode)\n{\n\treturn selinux_inode(inode);\n}\n\nstatic struct inode_security_struct *inode_security_rcu(struct inode *inode, bool rcu)\n{\n\tint error;\n\n\terror = __inode_security_revalidate(inode, NULL, !rcu);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\treturn selinux_inode(inode);\n}\n\n/*\n * Get the security label of an inode.\n */\nstatic struct inode_security_struct *inode_security(struct inode *inode)\n{\n\t__inode_security_revalidate(inode, NULL, true);\n\treturn selinux_inode(inode);\n}\n\nstatic struct inode_security_struct *backing_inode_security_novalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\treturn selinux_inode(inode);\n}\n\n/*\n * Get the security label of a dentry's backing inode.\n */\nstatic struct inode_security_struct *backing_inode_security(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\t__inode_security_revalidate(inode, dentry, true);\n\treturn selinux_inode(inode);\n}\n\nstatic void inode_free_security(struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tstruct superblock_security_struct *sbsec;\n\n\tif (!isec)\n\t\treturn;\n\tsbsec = inode->i_sb->s_security;\n\t/*\n\t * As not all inode security structures are in a list, we check for\n\t * empty list outside of the lock to make sure that we won't waste\n\t * time taking a lock doing nothing.\n\t *\n\t * The list_del_init() function can be safely called more than once.\n\t * It should not be possible for this function to be called with\n\t * concurrent list_add(), but for better safety against future changes\n\t * in the code, we use list_empty_careful() here.\n\t */\n\tif (!list_empty_careful(&isec->list)) {\n\t\tspin_lock(&sbsec->isec_lock);\n\t\tlist_del_init(&isec->list);\n\t\tspin_unlock(&sbsec->isec_lock);\n\t}\n}\n\nstatic void superblock_free_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tsb->s_security = NULL;\n\tkfree(sbsec);\n}\n\nstruct selinux_mnt_opts {\n\tconst char *fscontext, *context, *rootcontext, *defcontext;\n};\n\nstatic void selinux_free_mnt_opts(void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tkfree(opts->fscontext);\n\tkfree(opts->context);\n\tkfree(opts->rootcontext);\n\tkfree(opts->defcontext);\n\tkfree(opts);\n}\n\nenum {\n\tOpt_error = -1,\n\tOpt_context = 0,\n\tOpt_defcontext = 1,\n\tOpt_fscontext = 2,\n\tOpt_rootcontext = 3,\n\tOpt_seclabel = 4,\n};\n\n#define A(s, has_arg) {#s, sizeof(#s) - 1, Opt_##s, has_arg}\nstatic struct {\n\tconst char *name;\n\tint len;\n\tint opt;\n\tbool has_arg;\n} tokens[] = {\n\tA(context, true),\n\tA(fscontext, true),\n\tA(defcontext, true),\n\tA(rootcontext, true),\n\tA(seclabel, false),\n};\n#undef A\n\nstatic int match_opt_prefix(char *s, int l, char **arg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tokens); i++) {\n\t\tsize_t len = tokens[i].len;\n\t\tif (len > l || memcmp(s, tokens[i].name, len))\n\t\t\tcontinue;\n\t\tif (tokens[i].has_arg) {\n\t\t\tif (len == l || s[len] != '=')\n\t\t\t\tcontinue;\n\t\t\t*arg = s + len + 1;\n\t\t} else if (len != l)\n\t\t\tcontinue;\n\t\treturn tokens[i].opt;\n\t}\n\treturn Opt_error;\n}\n\n#define SEL_MOUNT_FAIL_MSG \"SELinux:  duplicate or incompatible mount options\\n\"\n\nstatic int may_context_mount_sb_relabel(u32 sid,\n\t\t\tstruct superblock_security_struct *sbsec,\n\t\t\tconst struct cred *cred)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(cred);\n\tint rc;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  tsec->sid, sbsec->sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__RELABELFROM, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  tsec->sid, sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__RELABELTO, NULL);\n\treturn rc;\n}\n\nstatic int may_context_mount_inode_relabel(u32 sid,\n\t\t\tstruct superblock_security_struct *sbsec,\n\t\t\tconst struct cred *cred)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(cred);\n\tint rc;\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  tsec->sid, sbsec->sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__RELABELFROM, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, sbsec->sid, SECCLASS_FILESYSTEM,\n\t\t\t  FILESYSTEM__ASSOCIATE, NULL);\n\treturn rc;\n}\n\nstatic int selinux_is_genfs_special_handling(struct super_block *sb)\n{\n\t/* Special handling. Genfs but also in-core setxattr handler */\n\treturn\t!strcmp(sb->s_type->name, \"sysfs\") ||\n\t\t!strcmp(sb->s_type->name, \"pstore\") ||\n\t\t!strcmp(sb->s_type->name, \"debugfs\") ||\n\t\t!strcmp(sb->s_type->name, \"tracefs\") ||\n\t\t!strcmp(sb->s_type->name, \"rootfs\") ||\n\t\t(selinux_policycap_cgroupseclabel() &&\n\t\t (!strcmp(sb->s_type->name, \"cgroup\") ||\n\t\t  !strcmp(sb->s_type->name, \"cgroup2\")));\n}\n\nstatic int selinux_is_sblabel_mnt(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\n\t/*\n\t * IMPORTANT: Double-check logic in this function when adding a new\n\t * SECURITY_FS_USE_* definition!\n\t */\n\tBUILD_BUG_ON(SECURITY_FS_USE_MAX != 7);\n\n\tswitch (sbsec->behavior) {\n\tcase SECURITY_FS_USE_XATTR:\n\tcase SECURITY_FS_USE_TRANS:\n\tcase SECURITY_FS_USE_TASK:\n\tcase SECURITY_FS_USE_NATIVE:\n\t\treturn 1;\n\n\tcase SECURITY_FS_USE_GENFS:\n\t\treturn selinux_is_genfs_special_handling(sb);\n\n\t/* Never allow relabeling on context mounts */\n\tcase SECURITY_FS_USE_MNTPOINT:\n\tcase SECURITY_FS_USE_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int sb_finish_set_opts(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tstruct dentry *root = sb->s_root;\n\tstruct inode *root_inode = d_backing_inode(root);\n\tint rc = 0;\n\n\tif (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n\t\t/* Make sure that the xattr handler exists and that no\n\t\t   error other than -ENODATA is returned by getxattr on\n\t\t   the root directory.  -ENODATA is ok, as this may be\n\t\t   the first boot of the SELinux kernel before we have\n\t\t   assigned xattr values to the filesystem. */\n\t\tif (!(root_inode->i_opflags & IOP_XATTR)) {\n\t\t\tpr_warn(\"SELinux: (dev %s, type %s) has no \"\n\t\t\t       \"xattr support\\n\", sb->s_id, sb->s_type->name);\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = __vfs_getxattr(root, root_inode, XATTR_NAME_SELINUX, NULL, 0);\n\t\tif (rc < 0 && rc != -ENODATA) {\n\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\tpr_warn(\"SELinux: (dev %s, type \"\n\t\t\t\t       \"%s) has no security xattr handler\\n\",\n\t\t\t\t       sb->s_id, sb->s_type->name);\n\t\t\telse\n\t\t\t\tpr_warn(\"SELinux: (dev %s, type \"\n\t\t\t\t       \"%s) getxattr errno %d\\n\", sb->s_id,\n\t\t\t\t       sb->s_type->name, -rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsbsec->flags |= SE_SBINITIALIZED;\n\n\t/*\n\t * Explicitly set or clear SBLABEL_MNT.  It's not sufficient to simply\n\t * leave the flag untouched because sb_clone_mnt_opts might be handing\n\t * us a superblock that needs the flag to be cleared.\n\t */\n\tif (selinux_is_sblabel_mnt(sb))\n\t\tsbsec->flags |= SBLABEL_MNT;\n\telse\n\t\tsbsec->flags &= ~SBLABEL_MNT;\n\n\t/* Initialize the root inode. */\n\trc = inode_doinit_with_dentry(root_inode, root);\n\n\t/* Initialize any other inodes associated with the superblock, e.g.\n\t   inodes created prior to initial policy load or inodes created\n\t   during get_sb by a pseudo filesystem that directly\n\t   populates itself. */\n\tspin_lock(&sbsec->isec_lock);\n\twhile (!list_empty(&sbsec->isec_head)) {\n\t\tstruct inode_security_struct *isec =\n\t\t\t\tlist_first_entry(&sbsec->isec_head,\n\t\t\t\t\t   struct inode_security_struct, list);\n\t\tstruct inode *inode = isec->inode;\n\t\tlist_del_init(&isec->list);\n\t\tspin_unlock(&sbsec->isec_lock);\n\t\tinode = igrab(inode);\n\t\tif (inode) {\n\t\t\tif (!IS_PRIVATE(inode))\n\t\t\t\tinode_doinit_with_dentry(inode, NULL);\n\t\t\tiput(inode);\n\t\t}\n\t\tspin_lock(&sbsec->isec_lock);\n\t}\n\tspin_unlock(&sbsec->isec_lock);\nout:\n\treturn rc;\n}\n\nstatic int bad_option(struct superblock_security_struct *sbsec, char flag,\n\t\t      u32 old_sid, u32 new_sid)\n{\n\tchar mnt_flags = sbsec->flags & SE_MNTMASK;\n\n\t/* check if the old mount command had the same options */\n\tif (sbsec->flags & SE_SBINITIALIZED)\n\t\tif (!(sbsec->flags & flag) ||\n\t\t    (old_sid != new_sid))\n\t\t\treturn 1;\n\n\t/* check if we were passed the same options twice,\n\t * aka someone passed context=a,context=b\n\t */\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\tif (mnt_flags & flag)\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int parse_sid(struct super_block *sb, const char *s, u32 *sid)\n{\n\tint rc = security_context_str_to_sid(&selinux_state, s,\n\t\t\t\t\t     sid, GFP_KERNEL);\n\tif (rc)\n\t\tpr_warn(\"SELinux: security_context_str_to_sid\"\n\t\t       \"(%s) failed for (dev %s, type %s) errno=%d\\n\",\n\t\t       s, sb->s_id, sb->s_type->name, rc);\n\treturn rc;\n}\n\n/*\n * Allow filesystems with binary mount data to explicitly set mount point\n * labeling information.\n */\nstatic int selinux_set_mnt_opts(struct super_block *sb,\n\t\t\t\tvoid *mnt_opts,\n\t\t\t\tunsigned long kern_flags,\n\t\t\t\tunsigned long *set_kern_flags)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tstruct dentry *root = sb->s_root;\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct inode_security_struct *root_isec;\n\tu32 fscontext_sid = 0, context_sid = 0, rootcontext_sid = 0;\n\tu32 defcontext_sid = 0;\n\tint rc = 0;\n\n\tmutex_lock(&sbsec->lock);\n\n\tif (!selinux_initialized(&selinux_state)) {\n\t\tif (!opts) {\n\t\t\t/* Defer initialization until selinux_complete_init,\n\t\t\t   after the initial policy is loaded and the security\n\t\t\t   server is ready to handle calls. */\n\t\t\tgoto out;\n\t\t}\n\t\trc = -EINVAL;\n\t\tpr_warn(\"SELinux: Unable to set superblock options \"\n\t\t\t\"before the security server is initialized\\n\");\n\t\tgoto out;\n\t}\n\tif (kern_flags && !set_kern_flags) {\n\t\t/* Specifying internal flags without providing a place to\n\t\t * place the results is not allowed */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Binary mount data FS will come through this function twice.  Once\n\t * from an explicit call and once from the generic calls from the vfs.\n\t * Since the generic VFS calls will not contain any security mount data\n\t * we need to skip the double mount verification.\n\t *\n\t * This does open a hole in which we will not notice if the first\n\t * mount using this sb set explict options and a second mount using\n\t * this sb does not set any security options.  (The first options\n\t * will be used for both mounts)\n\t */\n\tif ((sbsec->flags & SE_SBINITIALIZED) && (sb->s_type->fs_flags & FS_BINARY_MOUNTDATA)\n\t    && !opts)\n\t\tgoto out;\n\n\troot_isec = backing_inode_security_novalidate(root);\n\n\t/*\n\t * parse the mount options, check if they are valid sids.\n\t * also check if someone is trying to mount the same sb more\n\t * than once with different security options.\n\t */\n\tif (opts) {\n\t\tif (opts->fscontext) {\n\t\t\trc = parse_sid(sb, opts->fscontext, &fscontext_sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid,\n\t\t\t\t\tfscontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= FSCONTEXT_MNT;\n\t\t}\n\t\tif (opts->context) {\n\t\t\trc = parse_sid(sb, opts->context, &context_sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid,\n\t\t\t\t\tcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= CONTEXT_MNT;\n\t\t}\n\t\tif (opts->rootcontext) {\n\t\t\trc = parse_sid(sb, opts->rootcontext, &rootcontext_sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid,\n\t\t\t\t\trootcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= ROOTCONTEXT_MNT;\n\t\t}\n\t\tif (opts->defcontext) {\n\t\t\trc = parse_sid(sb, opts->defcontext, &defcontext_sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid,\n\t\t\t\t\tdefcontext_sid))\n\t\t\t\tgoto out_double_mount;\n\t\t\tsbsec->flags |= DEFCONTEXT_MNT;\n\t\t}\n\t}\n\n\tif (sbsec->flags & SE_SBINITIALIZED) {\n\t\t/* previously mounted with options, but not on this attempt? */\n\t\tif ((sbsec->flags & SE_MNTMASK) && !opts)\n\t\t\tgoto out_double_mount;\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(sb->s_type->name, \"proc\") == 0)\n\t\tsbsec->flags |= SE_SBPROC | SE_SBGENFS;\n\n\tif (!strcmp(sb->s_type->name, \"debugfs\") ||\n\t    !strcmp(sb->s_type->name, \"tracefs\") ||\n\t    !strcmp(sb->s_type->name, \"binder\") ||\n\t    !strcmp(sb->s_type->name, \"bpf\") ||\n\t    !strcmp(sb->s_type->name, \"pstore\"))\n\t\tsbsec->flags |= SE_SBGENFS;\n\n\tif (!strcmp(sb->s_type->name, \"sysfs\") ||\n\t    !strcmp(sb->s_type->name, \"cgroup\") ||\n\t    !strcmp(sb->s_type->name, \"cgroup2\"))\n\t\tsbsec->flags |= SE_SBGENFS | SE_SBGENFS_XATTR;\n\n\tif (!sbsec->behavior) {\n\t\t/*\n\t\t * Determine the labeling behavior to use for this\n\t\t * filesystem type.\n\t\t */\n\t\trc = security_fs_use(&selinux_state, sb);\n\t\tif (rc) {\n\t\t\tpr_warn(\"%s: security_fs_use(%s) returned %d\\n\",\n\t\t\t\t\t__func__, sb->s_type->name, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If this is a user namespace mount and the filesystem type is not\n\t * explicitly whitelisted, then no contexts are allowed on the command\n\t * line and security labels must be ignored.\n\t */\n\tif (sb->s_user_ns != &init_user_ns &&\n\t    strcmp(sb->s_type->name, \"tmpfs\") &&\n\t    strcmp(sb->s_type->name, \"ramfs\") &&\n\t    strcmp(sb->s_type->name, \"devpts\")) {\n\t\tif (context_sid || fscontext_sid || rootcontext_sid ||\n\t\t    defcontext_sid) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\t\tif (sbsec->behavior == SECURITY_FS_USE_XATTR) {\n\t\t\tsbsec->behavior = SECURITY_FS_USE_MNTPOINT;\n\t\t\trc = security_transition_sid(&selinux_state,\n\t\t\t\t\t\t     current_sid(),\n\t\t\t\t\t\t     current_sid(),\n\t\t\t\t\t\t     SECCLASS_FILE, NULL,\n\t\t\t\t\t\t     &sbsec->mntpoint_sid);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tgoto out_set_opts;\n\t}\n\n\t/* sets the context of the superblock for the fs being mounted. */\n\tif (fscontext_sid) {\n\t\trc = may_context_mount_sb_relabel(fscontext_sid, sbsec, cred);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tsbsec->sid = fscontext_sid;\n\t}\n\n\t/*\n\t * Switch to using mount point labeling behavior.\n\t * sets the label used on all file below the mountpoint, and will set\n\t * the superblock context if not already set.\n\t */\n\tif (kern_flags & SECURITY_LSM_NATIVE_LABELS && !context_sid) {\n\t\tsbsec->behavior = SECURITY_FS_USE_NATIVE;\n\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t}\n\n\tif (context_sid) {\n\t\tif (!fscontext_sid) {\n\t\t\trc = may_context_mount_sb_relabel(context_sid, sbsec,\n\t\t\t\t\t\t\t  cred);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tsbsec->sid = context_sid;\n\t\t} else {\n\t\t\trc = may_context_mount_inode_relabel(context_sid, sbsec,\n\t\t\t\t\t\t\t     cred);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (!rootcontext_sid)\n\t\t\trootcontext_sid = context_sid;\n\n\t\tsbsec->mntpoint_sid = context_sid;\n\t\tsbsec->behavior = SECURITY_FS_USE_MNTPOINT;\n\t}\n\n\tif (rootcontext_sid) {\n\t\trc = may_context_mount_inode_relabel(rootcontext_sid, sbsec,\n\t\t\t\t\t\t     cred);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\troot_isec->sid = rootcontext_sid;\n\t\troot_isec->initialized = LABEL_INITIALIZED;\n\t}\n\n\tif (defcontext_sid) {\n\t\tif (sbsec->behavior != SECURITY_FS_USE_XATTR &&\n\t\t\tsbsec->behavior != SECURITY_FS_USE_NATIVE) {\n\t\t\trc = -EINVAL;\n\t\t\tpr_warn(\"SELinux: defcontext option is \"\n\t\t\t       \"invalid for this filesystem type\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (defcontext_sid != sbsec->def_sid) {\n\t\t\trc = may_context_mount_inode_relabel(defcontext_sid,\n\t\t\t\t\t\t\t     sbsec, cred);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tsbsec->def_sid = defcontext_sid;\n\t}\n\nout_set_opts:\n\trc = sb_finish_set_opts(sb);\nout:\n\tmutex_unlock(&sbsec->lock);\n\treturn rc;\nout_double_mount:\n\trc = -EINVAL;\n\tpr_warn(\"SELinux: mount invalid.  Same superblock, different \"\n\t       \"security settings for (dev %s, type %s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\tgoto out;\n}\n\nstatic int selinux_cmp_sb_context(const struct super_block *oldsb,\n\t\t\t\t    const struct super_block *newsb)\n{\n\tstruct superblock_security_struct *old = oldsb->s_security;\n\tstruct superblock_security_struct *new = newsb->s_security;\n\tchar oldflags = old->flags & SE_MNTMASK;\n\tchar newflags = new->flags & SE_MNTMASK;\n\n\tif (oldflags != newflags)\n\t\tgoto mismatch;\n\tif ((oldflags & FSCONTEXT_MNT) && old->sid != new->sid)\n\t\tgoto mismatch;\n\tif ((oldflags & CONTEXT_MNT) && old->mntpoint_sid != new->mntpoint_sid)\n\t\tgoto mismatch;\n\tif ((oldflags & DEFCONTEXT_MNT) && old->def_sid != new->def_sid)\n\t\tgoto mismatch;\n\tif (oldflags & ROOTCONTEXT_MNT) {\n\t\tstruct inode_security_struct *oldroot = backing_inode_security(oldsb->s_root);\n\t\tstruct inode_security_struct *newroot = backing_inode_security(newsb->s_root);\n\t\tif (oldroot->sid != newroot->sid)\n\t\t\tgoto mismatch;\n\t}\n\treturn 0;\nmismatch:\n\tpr_warn(\"SELinux: mount invalid.  Same superblock, \"\n\t\t\t    \"different security settings for (dev %s, \"\n\t\t\t    \"type %s)\\n\", newsb->s_id, newsb->s_type->name);\n\treturn -EBUSY;\n}\n\nstatic int selinux_sb_clone_mnt_opts(const struct super_block *oldsb,\n\t\t\t\t\tstruct super_block *newsb,\n\t\t\t\t\tunsigned long kern_flags,\n\t\t\t\t\tunsigned long *set_kern_flags)\n{\n\tint rc = 0;\n\tconst struct superblock_security_struct *oldsbsec = oldsb->s_security;\n\tstruct superblock_security_struct *newsbsec = newsb->s_security;\n\n\tint set_fscontext =\t(oldsbsec->flags & FSCONTEXT_MNT);\n\tint set_context =\t(oldsbsec->flags & CONTEXT_MNT);\n\tint set_rootcontext =\t(oldsbsec->flags & ROOTCONTEXT_MNT);\n\n\t/*\n\t * if the parent was able to be mounted it clearly had no special lsm\n\t * mount options.  thus we can safely deal with this superblock later\n\t */\n\tif (!selinux_initialized(&selinux_state))\n\t\treturn 0;\n\n\t/*\n\t * Specifying internal flags without providing a place to\n\t * place the results is not allowed.\n\t */\n\tif (kern_flags && !set_kern_flags)\n\t\treturn -EINVAL;\n\n\t/* how can we clone if the old one wasn't set up?? */\n\tBUG_ON(!(oldsbsec->flags & SE_SBINITIALIZED));\n\n\t/* if fs is reusing a sb, make sure that the contexts match */\n\tif (newsbsec->flags & SE_SBINITIALIZED) {\n\t\tif ((kern_flags & SECURITY_LSM_NATIVE_LABELS) && !set_context)\n\t\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t\treturn selinux_cmp_sb_context(oldsb, newsb);\n\t}\n\n\tmutex_lock(&newsbsec->lock);\n\n\tnewsbsec->flags = oldsbsec->flags;\n\n\tnewsbsec->sid = oldsbsec->sid;\n\tnewsbsec->def_sid = oldsbsec->def_sid;\n\tnewsbsec->behavior = oldsbsec->behavior;\n\n\tif (newsbsec->behavior == SECURITY_FS_USE_NATIVE &&\n\t\t!(kern_flags & SECURITY_LSM_NATIVE_LABELS) && !set_context) {\n\t\trc = security_fs_use(&selinux_state, newsb);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (kern_flags & SECURITY_LSM_NATIVE_LABELS && !set_context) {\n\t\tnewsbsec->behavior = SECURITY_FS_USE_NATIVE;\n\t\t*set_kern_flags |= SECURITY_LSM_NATIVE_LABELS;\n\t}\n\n\tif (set_context) {\n\t\tu32 sid = oldsbsec->mntpoint_sid;\n\n\t\tif (!set_fscontext)\n\t\t\tnewsbsec->sid = sid;\n\t\tif (!set_rootcontext) {\n\t\t\tstruct inode_security_struct *newisec = backing_inode_security(newsb->s_root);\n\t\t\tnewisec->sid = sid;\n\t\t}\n\t\tnewsbsec->mntpoint_sid = sid;\n\t}\n\tif (set_rootcontext) {\n\t\tconst struct inode_security_struct *oldisec = backing_inode_security(oldsb->s_root);\n\t\tstruct inode_security_struct *newisec = backing_inode_security(newsb->s_root);\n\n\t\tnewisec->sid = oldisec->sid;\n\t}\n\n\tsb_finish_set_opts(newsb);\nout:\n\tmutex_unlock(&newsbsec->lock);\n\treturn rc;\n}\n\nstatic int selinux_add_opt(int token, const char *s, void **mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = *mnt_opts;\n\n\tif (token == Opt_seclabel)\t/* eaten and completely ignored */\n\t\treturn 0;\n\n\tif (!opts) {\n\t\topts = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);\n\t\tif (!opts)\n\t\t\treturn -ENOMEM;\n\t\t*mnt_opts = opts;\n\t}\n\tif (!s)\n\t\treturn -ENOMEM;\n\tswitch (token) {\n\tcase Opt_context:\n\t\tif (opts->context || opts->defcontext)\n\t\t\tgoto Einval;\n\t\topts->context = s;\n\t\tbreak;\n\tcase Opt_fscontext:\n\t\tif (opts->fscontext)\n\t\t\tgoto Einval;\n\t\topts->fscontext = s;\n\t\tbreak;\n\tcase Opt_rootcontext:\n\t\tif (opts->rootcontext)\n\t\t\tgoto Einval;\n\t\topts->rootcontext = s;\n\t\tbreak;\n\tcase Opt_defcontext:\n\t\tif (opts->context || opts->defcontext)\n\t\t\tgoto Einval;\n\t\topts->defcontext = s;\n\t\tbreak;\n\t}\n\treturn 0;\nEinval:\n\tpr_warn(SEL_MOUNT_FAIL_MSG);\n\treturn -EINVAL;\n}\n\nstatic int selinux_add_mnt_opt(const char *option, const char *val, int len,\n\t\t\t       void **mnt_opts)\n{\n\tint token = Opt_error;\n\tint rc, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tokens); i++) {\n\t\tif (strcmp(option, tokens[i].name) == 0) {\n\t\t\ttoken = tokens[i].opt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (token == Opt_error)\n\t\treturn -EINVAL;\n\n\tif (token != Opt_seclabel) {\n\t\tval = kmemdup_nul(val, len, GFP_KERNEL);\n\t\tif (!val) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_opt;\n\t\t}\n\t}\n\trc = selinux_add_opt(token, val, mnt_opts);\n\tif (unlikely(rc)) {\n\t\tkfree(val);\n\t\tgoto free_opt;\n\t}\n\treturn rc;\n\nfree_opt:\n\tif (*mnt_opts) {\n\t\tselinux_free_mnt_opts(*mnt_opts);\n\t\t*mnt_opts = NULL;\n\t}\n\treturn rc;\n}\n\nstatic int show_sid(struct seq_file *m, u32 sid)\n{\n\tchar *context = NULL;\n\tu32 len;\n\tint rc;\n\n\trc = security_sid_to_context(&selinux_state, sid,\n\t\t\t\t\t     &context, &len);\n\tif (!rc) {\n\t\tbool has_comma = context && strchr(context, ',');\n\n\t\tseq_putc(m, '=');\n\t\tif (has_comma)\n\t\t\tseq_putc(m, '\\\"');\n\t\tseq_escape(m, context, \"\\\"\\n\\\\\");\n\t\tif (has_comma)\n\t\t\tseq_putc(m, '\\\"');\n\t}\n\tkfree(context);\n\treturn rc;\n}\n\nstatic int selinux_sb_show_options(struct seq_file *m, struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tint rc;\n\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\n\tif (!selinux_initialized(&selinux_state))\n\t\treturn 0;\n\n\tif (sbsec->flags & FSCONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, FSCONTEXT_STR);\n\t\trc = show_sid(m, sbsec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & CONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, CONTEXT_STR);\n\t\trc = show_sid(m, sbsec->mntpoint_sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & DEFCONTEXT_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, DEFCONTEXT_STR);\n\t\trc = show_sid(m, sbsec->def_sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & ROOTCONTEXT_MNT) {\n\t\tstruct dentry *root = sb->s_root;\n\t\tstruct inode_security_struct *isec = backing_inode_security(root);\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, ROOTCONTEXT_STR);\n\t\trc = show_sid(m, isec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (sbsec->flags & SBLABEL_MNT) {\n\t\tseq_putc(m, ',');\n\t\tseq_puts(m, SECLABEL_STR);\n\t}\n\treturn 0;\n}\n\nstatic inline u16 inode_mode_to_security_class(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFSOCK:\n\t\treturn SECCLASS_SOCK_FILE;\n\tcase S_IFLNK:\n\t\treturn SECCLASS_LNK_FILE;\n\tcase S_IFREG:\n\t\treturn SECCLASS_FILE;\n\tcase S_IFBLK:\n\t\treturn SECCLASS_BLK_FILE;\n\tcase S_IFDIR:\n\t\treturn SECCLASS_DIR;\n\tcase S_IFCHR:\n\t\treturn SECCLASS_CHR_FILE;\n\tcase S_IFIFO:\n\t\treturn SECCLASS_FIFO_FILE;\n\n\t}\n\n\treturn SECCLASS_FILE;\n}\n\nstatic inline int default_protocol_stream(int protocol)\n{\n\treturn (protocol == IPPROTO_IP || protocol == IPPROTO_TCP);\n}\n\nstatic inline int default_protocol_dgram(int protocol)\n{\n\treturn (protocol == IPPROTO_IP || protocol == IPPROTO_UDP);\n}\n\nstatic inline u16 socket_type_to_security_class(int family, int type, int protocol)\n{\n\tint extsockclass = selinux_policycap_extsockclass();\n\n\tswitch (family) {\n\tcase PF_UNIX:\n\t\tswitch (type) {\n\t\tcase SOCK_STREAM:\n\t\tcase SOCK_SEQPACKET:\n\t\t\treturn SECCLASS_UNIX_STREAM_SOCKET;\n\t\tcase SOCK_DGRAM:\n\t\tcase SOCK_RAW:\n\t\t\treturn SECCLASS_UNIX_DGRAM_SOCKET;\n\t\t}\n\t\tbreak;\n\tcase PF_INET:\n\tcase PF_INET6:\n\t\tswitch (type) {\n\t\tcase SOCK_STREAM:\n\t\tcase SOCK_SEQPACKET:\n\t\t\tif (default_protocol_stream(protocol))\n\t\t\t\treturn SECCLASS_TCP_SOCKET;\n\t\t\telse if (extsockclass && protocol == IPPROTO_SCTP)\n\t\t\t\treturn SECCLASS_SCTP_SOCKET;\n\t\t\telse\n\t\t\t\treturn SECCLASS_RAWIP_SOCKET;\n\t\tcase SOCK_DGRAM:\n\t\t\tif (default_protocol_dgram(protocol))\n\t\t\t\treturn SECCLASS_UDP_SOCKET;\n\t\t\telse if (extsockclass && (protocol == IPPROTO_ICMP ||\n\t\t\t\t\t\t  protocol == IPPROTO_ICMPV6))\n\t\t\t\treturn SECCLASS_ICMP_SOCKET;\n\t\t\telse\n\t\t\t\treturn SECCLASS_RAWIP_SOCKET;\n\t\tcase SOCK_DCCP:\n\t\t\treturn SECCLASS_DCCP_SOCKET;\n\t\tdefault:\n\t\t\treturn SECCLASS_RAWIP_SOCKET;\n\t\t}\n\t\tbreak;\n\tcase PF_NETLINK:\n\t\tswitch (protocol) {\n\t\tcase NETLINK_ROUTE:\n\t\t\treturn SECCLASS_NETLINK_ROUTE_SOCKET;\n\t\tcase NETLINK_SOCK_DIAG:\n\t\t\treturn SECCLASS_NETLINK_TCPDIAG_SOCKET;\n\t\tcase NETLINK_NFLOG:\n\t\t\treturn SECCLASS_NETLINK_NFLOG_SOCKET;\n\t\tcase NETLINK_XFRM:\n\t\t\treturn SECCLASS_NETLINK_XFRM_SOCKET;\n\t\tcase NETLINK_SELINUX:\n\t\t\treturn SECCLASS_NETLINK_SELINUX_SOCKET;\n\t\tcase NETLINK_ISCSI:\n\t\t\treturn SECCLASS_NETLINK_ISCSI_SOCKET;\n\t\tcase NETLINK_AUDIT:\n\t\t\treturn SECCLASS_NETLINK_AUDIT_SOCKET;\n\t\tcase NETLINK_FIB_LOOKUP:\n\t\t\treturn SECCLASS_NETLINK_FIB_LOOKUP_SOCKET;\n\t\tcase NETLINK_CONNECTOR:\n\t\t\treturn SECCLASS_NETLINK_CONNECTOR_SOCKET;\n\t\tcase NETLINK_NETFILTER:\n\t\t\treturn SECCLASS_NETLINK_NETFILTER_SOCKET;\n\t\tcase NETLINK_DNRTMSG:\n\t\t\treturn SECCLASS_NETLINK_DNRT_SOCKET;\n\t\tcase NETLINK_KOBJECT_UEVENT:\n\t\t\treturn SECCLASS_NETLINK_KOBJECT_UEVENT_SOCKET;\n\t\tcase NETLINK_GENERIC:\n\t\t\treturn SECCLASS_NETLINK_GENERIC_SOCKET;\n\t\tcase NETLINK_SCSITRANSPORT:\n\t\t\treturn SECCLASS_NETLINK_SCSITRANSPORT_SOCKET;\n\t\tcase NETLINK_RDMA:\n\t\t\treturn SECCLASS_NETLINK_RDMA_SOCKET;\n\t\tcase NETLINK_CRYPTO:\n\t\t\treturn SECCLASS_NETLINK_CRYPTO_SOCKET;\n\t\tdefault:\n\t\t\treturn SECCLASS_NETLINK_SOCKET;\n\t\t}\n\tcase PF_PACKET:\n\t\treturn SECCLASS_PACKET_SOCKET;\n\tcase PF_KEY:\n\t\treturn SECCLASS_KEY_SOCKET;\n\tcase PF_APPLETALK:\n\t\treturn SECCLASS_APPLETALK_SOCKET;\n\t}\n\n\tif (extsockclass) {\n\t\tswitch (family) {\n\t\tcase PF_AX25:\n\t\t\treturn SECCLASS_AX25_SOCKET;\n\t\tcase PF_IPX:\n\t\t\treturn SECCLASS_IPX_SOCKET;\n\t\tcase PF_NETROM:\n\t\t\treturn SECCLASS_NETROM_SOCKET;\n\t\tcase PF_ATMPVC:\n\t\t\treturn SECCLASS_ATMPVC_SOCKET;\n\t\tcase PF_X25:\n\t\t\treturn SECCLASS_X25_SOCKET;\n\t\tcase PF_ROSE:\n\t\t\treturn SECCLASS_ROSE_SOCKET;\n\t\tcase PF_DECnet:\n\t\t\treturn SECCLASS_DECNET_SOCKET;\n\t\tcase PF_ATMSVC:\n\t\t\treturn SECCLASS_ATMSVC_SOCKET;\n\t\tcase PF_RDS:\n\t\t\treturn SECCLASS_RDS_SOCKET;\n\t\tcase PF_IRDA:\n\t\t\treturn SECCLASS_IRDA_SOCKET;\n\t\tcase PF_PPPOX:\n\t\t\treturn SECCLASS_PPPOX_SOCKET;\n\t\tcase PF_LLC:\n\t\t\treturn SECCLASS_LLC_SOCKET;\n\t\tcase PF_CAN:\n\t\t\treturn SECCLASS_CAN_SOCKET;\n\t\tcase PF_TIPC:\n\t\t\treturn SECCLASS_TIPC_SOCKET;\n\t\tcase PF_BLUETOOTH:\n\t\t\treturn SECCLASS_BLUETOOTH_SOCKET;\n\t\tcase PF_IUCV:\n\t\t\treturn SECCLASS_IUCV_SOCKET;\n\t\tcase PF_RXRPC:\n\t\t\treturn SECCLASS_RXRPC_SOCKET;\n\t\tcase PF_ISDN:\n\t\t\treturn SECCLASS_ISDN_SOCKET;\n\t\tcase PF_PHONET:\n\t\t\treturn SECCLASS_PHONET_SOCKET;\n\t\tcase PF_IEEE802154:\n\t\t\treturn SECCLASS_IEEE802154_SOCKET;\n\t\tcase PF_CAIF:\n\t\t\treturn SECCLASS_CAIF_SOCKET;\n\t\tcase PF_ALG:\n\t\t\treturn SECCLASS_ALG_SOCKET;\n\t\tcase PF_NFC:\n\t\t\treturn SECCLASS_NFC_SOCKET;\n\t\tcase PF_VSOCK:\n\t\t\treturn SECCLASS_VSOCK_SOCKET;\n\t\tcase PF_KCM:\n\t\t\treturn SECCLASS_KCM_SOCKET;\n\t\tcase PF_QIPCRTR:\n\t\t\treturn SECCLASS_QIPCRTR_SOCKET;\n\t\tcase PF_SMC:\n\t\t\treturn SECCLASS_SMC_SOCKET;\n\t\tcase PF_XDP:\n\t\t\treturn SECCLASS_XDP_SOCKET;\n#if PF_MAX > 45\n#error New address family defined, please update this function.\n#endif\n\t\t}\n\t}\n\n\treturn SECCLASS_SOCKET;\n}\n\nstatic int selinux_genfs_get_sid(struct dentry *dentry,\n\t\t\t\t u16 tclass,\n\t\t\t\t u16 flags,\n\t\t\t\t u32 *sid)\n{\n\tint rc;\n\tstruct super_block *sb = dentry->d_sb;\n\tchar *buffer, *path;\n\n\tbuffer = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tpath = dentry_path_raw(dentry, buffer, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\trc = PTR_ERR(path);\n\telse {\n\t\tif (flags & SE_SBPROC) {\n\t\t\t/* each process gets a /proc/PID/ entry. Strip off the\n\t\t\t * PID part to get a valid selinux labeling.\n\t\t\t * e.g. /proc/1/net/rpc/nfs -> /net/rpc/nfs */\n\t\t\twhile (path[1] >= '0' && path[1] <= '9') {\n\t\t\t\tpath[1] = '/';\n\t\t\t\tpath++;\n\t\t\t}\n\t\t}\n\t\trc = security_genfs_sid(&selinux_state, sb->s_type->name,\n\t\t\t\t\tpath, tclass, sid);\n\t\tif (rc == -ENOENT) {\n\t\t\t/* No match in policy, mark as unlabeled. */\n\t\t\t*sid = SECINITSID_UNLABELED;\n\t\t\trc = 0;\n\t\t}\n\t}\n\tfree_page((unsigned long)buffer);\n\treturn rc;\n}\n\nstatic int inode_doinit_use_xattr(struct inode *inode, struct dentry *dentry,\n\t\t\t\t  u32 def_sid, u32 *sid)\n{\n#define INITCONTEXTLEN 255\n\tchar *context;\n\tunsigned int len;\n\tint rc;\n\n\tlen = INITCONTEXTLEN;\n\tcontext = kmalloc(len + 1, GFP_NOFS);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tcontext[len] = '\\0';\n\trc = __vfs_getxattr(dentry, inode, XATTR_NAME_SELINUX, context, len);\n\tif (rc == -ERANGE) {\n\t\tkfree(context);\n\n\t\t/* Need a larger buffer.  Query for the right size. */\n\t\trc = __vfs_getxattr(dentry, inode, XATTR_NAME_SELINUX, NULL, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tlen = rc;\n\t\tcontext = kmalloc(len + 1, GFP_NOFS);\n\t\tif (!context)\n\t\t\treturn -ENOMEM;\n\n\t\tcontext[len] = '\\0';\n\t\trc = __vfs_getxattr(dentry, inode, XATTR_NAME_SELINUX,\n\t\t\t\t    context, len);\n\t}\n\tif (rc < 0) {\n\t\tkfree(context);\n\t\tif (rc != -ENODATA) {\n\t\t\tpr_warn(\"SELinux: %s:  getxattr returned %d for dev=%s ino=%ld\\n\",\n\t\t\t\t__func__, -rc, inode->i_sb->s_id, inode->i_ino);\n\t\t\treturn rc;\n\t\t}\n\t\t*sid = def_sid;\n\t\treturn 0;\n\t}\n\n\trc = security_context_to_sid_default(&selinux_state, context, rc, sid,\n\t\t\t\t\t     def_sid, GFP_NOFS);\n\tif (rc) {\n\t\tchar *dev = inode->i_sb->s_id;\n\t\tunsigned long ino = inode->i_ino;\n\n\t\tif (rc == -EINVAL) {\n\t\t\tpr_notice_ratelimited(\"SELinux: inode=%lu on dev=%s was found to have an invalid context=%s.  This indicates you may need to relabel the inode or the filesystem in question.\\n\",\n\t\t\t\t\t      ino, dev, context);\n\t\t} else {\n\t\t\tpr_warn(\"SELinux: %s:  context_to_sid(%s) returned %d for dev=%s ino=%ld\\n\",\n\t\t\t\t__func__, context, -rc, dev, ino);\n\t\t}\n\t}\n\tkfree(context);\n\treturn 0;\n}\n\n/* The inode's security attributes must be initialized before first use. */\nstatic int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry)\n{\n\tstruct superblock_security_struct *sbsec = NULL;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 task_sid, sid = 0;\n\tu16 sclass;\n\tstruct dentry *dentry;\n\tint rc = 0;\n\n\tif (isec->initialized == LABEL_INITIALIZED)\n\t\treturn 0;\n\n\tspin_lock(&isec->lock);\n\tif (isec->initialized == LABEL_INITIALIZED)\n\t\tgoto out_unlock;\n\n\tif (isec->sclass == SECCLASS_FILE)\n\t\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\n\tsbsec = inode->i_sb->s_security;\n\tif (!(sbsec->flags & SE_SBINITIALIZED)) {\n\t\t/* Defer initialization until selinux_complete_init,\n\t\t   after the initial policy is loaded and the security\n\t\t   server is ready to handle calls. */\n\t\tspin_lock(&sbsec->isec_lock);\n\t\tif (list_empty(&isec->list))\n\t\t\tlist_add(&isec->list, &sbsec->isec_head);\n\t\tspin_unlock(&sbsec->isec_lock);\n\t\tgoto out_unlock;\n\t}\n\n\tsclass = isec->sclass;\n\ttask_sid = isec->task_sid;\n\tsid = isec->sid;\n\tisec->initialized = LABEL_PENDING;\n\tspin_unlock(&isec->lock);\n\n\tswitch (sbsec->behavior) {\n\tcase SECURITY_FS_USE_NATIVE:\n\t\tbreak;\n\tcase SECURITY_FS_USE_XATTR:\n\t\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\t\tsid = sbsec->def_sid;\n\t\t\tbreak;\n\t\t}\n\t\t/* Need a dentry, since the xattr API requires one.\n\t\t   Life would be simpler if we could just pass the inode. */\n\t\tif (opt_dentry) {\n\t\t\t/* Called from d_instantiate or d_splice_alias. */\n\t\t\tdentry = dget(opt_dentry);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Called from selinux_complete_init, try to find a dentry.\n\t\t\t * Some filesystems really want a connected one, so try\n\t\t\t * that first.  We could split SECURITY_FS_USE_XATTR in\n\t\t\t * two, depending upon that...\n\t\t\t */\n\t\t\tdentry = d_find_alias(inode);\n\t\t\tif (!dentry)\n\t\t\t\tdentry = d_find_any_alias(inode);\n\t\t}\n\t\tif (!dentry) {\n\t\t\t/*\n\t\t\t * this is can be hit on boot when a file is accessed\n\t\t\t * before the policy is loaded.  When we load policy we\n\t\t\t * may find inodes that have no dentry on the\n\t\t\t * sbsec->isec_head list.  No reason to complain as these\n\t\t\t * will get fixed up the next time we go through\n\t\t\t * inode_doinit with a dentry, before these inodes could\n\t\t\t * be used again by userspace.\n\t\t\t */\n\t\t\tgoto out_invalid;\n\t\t}\n\n\t\trc = inode_doinit_use_xattr(inode, dentry, sbsec->def_sid,\n\t\t\t\t\t    &sid);\n\t\tdput(dentry);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SECURITY_FS_USE_TASK:\n\t\tsid = task_sid;\n\t\tbreak;\n\tcase SECURITY_FS_USE_TRANS:\n\t\t/* Default to the fs SID. */\n\t\tsid = sbsec->sid;\n\n\t\t/* Try to obtain a transition SID. */\n\t\trc = security_transition_sid(&selinux_state, task_sid, sid,\n\t\t\t\t\t     sclass, NULL, &sid);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SECURITY_FS_USE_MNTPOINT:\n\t\tsid = sbsec->mntpoint_sid;\n\t\tbreak;\n\tdefault:\n\t\t/* Default to the fs superblock SID. */\n\t\tsid = sbsec->sid;\n\n\t\tif ((sbsec->flags & SE_SBGENFS) &&\n\t\t     (!S_ISLNK(inode->i_mode) ||\n\t\t      selinux_policycap_genfs_seclabel_symlinks())) {\n\t\t\t/* We must have a dentry to determine the label on\n\t\t\t * procfs inodes */\n\t\t\tif (opt_dentry) {\n\t\t\t\t/* Called from d_instantiate or\n\t\t\t\t * d_splice_alias. */\n\t\t\t\tdentry = dget(opt_dentry);\n\t\t\t} else {\n\t\t\t\t/* Called from selinux_complete_init, try to\n\t\t\t\t * find a dentry.  Some filesystems really want\n\t\t\t\t * a connected one, so try that first.\n\t\t\t\t */\n\t\t\t\tdentry = d_find_alias(inode);\n\t\t\t\tif (!dentry)\n\t\t\t\t\tdentry = d_find_any_alias(inode);\n\t\t\t}\n\t\t\t/*\n\t\t\t * This can be hit on boot when a file is accessed\n\t\t\t * before the policy is loaded.  When we load policy we\n\t\t\t * may find inodes that have no dentry on the\n\t\t\t * sbsec->isec_head list.  No reason to complain as\n\t\t\t * these will get fixed up the next time we go through\n\t\t\t * inode_doinit() with a dentry, before these inodes\n\t\t\t * could be used again by userspace.\n\t\t\t */\n\t\t\tif (!dentry)\n\t\t\t\tgoto out_invalid;\n\t\t\trc = selinux_genfs_get_sid(dentry, sclass,\n\t\t\t\t\t\t   sbsec->flags, &sid);\n\t\t\tif (rc) {\n\t\t\t\tdput(dentry);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif ((sbsec->flags & SE_SBGENFS_XATTR) &&\n\t\t\t    (inode->i_opflags & IOP_XATTR)) {\n\t\t\t\trc = inode_doinit_use_xattr(inode, dentry,\n\t\t\t\t\t\t\t    sid, &sid);\n\t\t\t\tif (rc) {\n\t\t\t\t\tdput(dentry);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdput(dentry);\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tspin_lock(&isec->lock);\n\tif (isec->initialized == LABEL_PENDING) {\n\t\tif (rc) {\n\t\t\tisec->initialized = LABEL_INVALID;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t\tisec->sid = sid;\n\t}\n\nout_unlock:\n\tspin_unlock(&isec->lock);\n\treturn rc;\n\nout_invalid:\n\tspin_lock(&isec->lock);\n\tif (isec->initialized == LABEL_PENDING) {\n\t\tisec->initialized = LABEL_INVALID;\n\t\tisec->sid = sid;\n\t}\n\tspin_unlock(&isec->lock);\n\treturn 0;\n}\n\n/* Convert a Linux signal to an access vector. */\nstatic inline u32 signal_to_av(int sig)\n{\n\tu32 perm = 0;\n\n\tswitch (sig) {\n\tcase SIGCHLD:\n\t\t/* Commonly granted from child to parent. */\n\t\tperm = PROCESS__SIGCHLD;\n\t\tbreak;\n\tcase SIGKILL:\n\t\t/* Cannot be caught or ignored */\n\t\tperm = PROCESS__SIGKILL;\n\t\tbreak;\n\tcase SIGSTOP:\n\t\t/* Cannot be caught or ignored */\n\t\tperm = PROCESS__SIGSTOP;\n\t\tbreak;\n\tdefault:\n\t\t/* All other signals. */\n\t\tperm = PROCESS__SIGNAL;\n\t\tbreak;\n\t}\n\n\treturn perm;\n}\n\n#if CAP_LAST_CAP > 63\n#error Fix SELinux to handle capabilities > 63.\n#endif\n\n/* Check whether a task is allowed to use a capability. */\nstatic int cred_has_capability(const struct cred *cred,\n\t\t\t       int cap, unsigned int opts, bool initns)\n{\n\tstruct common_audit_data ad;\n\tstruct av_decision avd;\n\tu16 sclass;\n\tu32 sid = cred_sid(cred);\n\tu32 av = CAP_TO_MASK(cap);\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_CAP;\n\tad.u.cap = cap;\n\n\tswitch (CAP_TO_INDEX(cap)) {\n\tcase 0:\n\t\tsclass = initns ? SECCLASS_CAPABILITY : SECCLASS_CAP_USERNS;\n\t\tbreak;\n\tcase 1:\n\t\tsclass = initns ? SECCLASS_CAPABILITY2 : SECCLASS_CAP2_USERNS;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"SELinux:  out of range capability %d\\n\", cap);\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\trc = avc_has_perm_noaudit(&selinux_state,\n\t\t\t\t  sid, sid, sclass, av, 0, &avd);\n\tif (!(opts & CAP_OPT_NOAUDIT)) {\n\t\tint rc2 = avc_audit(&selinux_state,\n\t\t\t\t    sid, sid, sclass, av, &avd, rc, &ad, 0);\n\t\tif (rc2)\n\t\t\treturn rc2;\n\t}\n\treturn rc;\n}\n\n/* Check whether a task has a particular permission to an inode.\n   The 'adp' parameter is optional and allows other audit\n   data to be passed (e.g. the dentry). */\nstatic int inode_has_perm(const struct cred *cred,\n\t\t\t  struct inode *inode,\n\t\t\t  u32 perms,\n\t\t\t  struct common_audit_data *adp)\n{\n\tstruct inode_security_struct *isec;\n\tu32 sid;\n\n\tvalidate_creds(cred);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tsid = cred_sid(cred);\n\tisec = selinux_inode(inode);\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, isec->sclass, perms, adp);\n}\n\n/* Same as inode_has_perm, but pass explicit audit data containing\n   the dentry to help the auditing code to more easily generate the\n   pathname if needed. */\nstatic inline int dentry_has_perm(const struct cred *cred,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  u32 av)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\t__inode_security_revalidate(inode, dentry, true);\n\treturn inode_has_perm(cred, inode, av, &ad);\n}\n\n/* Same as inode_has_perm, but pass explicit audit data containing\n   the path to help the auditing code to more easily generate the\n   pathname if needed. */\nstatic inline int path_has_perm(const struct cred *cred,\n\t\t\t\tconst struct path *path,\n\t\t\t\tu32 av)\n{\n\tstruct inode *inode = d_backing_inode(path->dentry);\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_PATH;\n\tad.u.path = *path;\n\t__inode_security_revalidate(inode, path->dentry, true);\n\treturn inode_has_perm(cred, inode, av, &ad);\n}\n\n/* Same as path_has_perm, but uses the inode from the file struct. */\nstatic inline int file_path_has_perm(const struct cred *cred,\n\t\t\t\t     struct file *file,\n\t\t\t\t     u32 av)\n{\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\treturn inode_has_perm(cred, file_inode(file), av, &ad);\n}\n\n#ifdef CONFIG_BPF_SYSCALL\nstatic int bpf_fd_pass(struct file *file, u32 sid);\n#endif\n\n/* Check whether a task can use an open file descriptor to\n   access an inode in a given way.  Check access to the\n   descriptor itself, and then use dentry_has_perm to\n   check a particular permission to the file.\n   Access to the descriptor is implicitly granted if it\n   has the same SID as the process.  If av is zero, then\n   access to the file is not checked, e.g. for cases\n   where only the descriptor is affected like seek. */\nstatic int file_has_perm(const struct cred *cred,\n\t\t\t struct file *file,\n\t\t\t u32 av)\n{\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct inode *inode = file_inode(file);\n\tstruct common_audit_data ad;\n\tu32 sid = cred_sid(cred);\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, fsec->sid,\n\t\t\t\t  SECCLASS_FD,\n\t\t\t\t  FD__USE,\n\t\t\t\t  &ad);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_BPF_SYSCALL\n\trc = bpf_fd_pass(file, cred_sid(cred));\n\tif (rc)\n\t\treturn rc;\n#endif\n\n\t/* av is zero if only checking access to the descriptor. */\n\trc = 0;\n\tif (av)\n\t\trc = inode_has_perm(cred, inode, av, &ad);\n\nout:\n\treturn rc;\n}\n\n/*\n * Determine the label for an inode that might be unioned.\n */\nstatic int\nselinux_determine_inode_label(const struct task_security_struct *tsec,\n\t\t\t\t struct inode *dir,\n\t\t\t\t const struct qstr *name, u16 tclass,\n\t\t\t\t u32 *_new_isid)\n{\n\tconst struct superblock_security_struct *sbsec = dir->i_sb->s_security;\n\n\tif ((sbsec->flags & SE_SBINITIALIZED) &&\n\t    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {\n\t\t*_new_isid = sbsec->mntpoint_sid;\n\t} else if ((sbsec->flags & SBLABEL_MNT) &&\n\t\t   tsec->create_sid) {\n\t\t*_new_isid = tsec->create_sid;\n\t} else {\n\t\tconst struct inode_security_struct *dsec = inode_security(dir);\n\t\treturn security_transition_sid(&selinux_state, tsec->sid,\n\t\t\t\t\t       dsec->sid, tclass,\n\t\t\t\t\t       name, _new_isid);\n\t}\n\n\treturn 0;\n}\n\n/* Check whether a task can create a file. */\nstatic int may_create(struct inode *dir,\n\t\t      struct dentry *dentry,\n\t\t      u16 tclass)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct inode_security_struct *dsec;\n\tstruct superblock_security_struct *sbsec;\n\tu32 sid, newsid;\n\tstruct common_audit_data ad;\n\tint rc;\n\n\tdsec = inode_security(dir);\n\tsbsec = dir->i_sb->s_security;\n\n\tsid = tsec->sid;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, dsec->sid, SECCLASS_DIR,\n\t\t\t  DIR__ADD_NAME | DIR__SEARCH,\n\t\t\t  &ad);\n\tif (rc)\n\t\treturn rc;\n\n\trc = selinux_determine_inode_label(tsec, dir, &dentry->d_name, tclass,\n\t\t\t\t\t   &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, newsid, tclass, FILE__CREATE, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    newsid, sbsec->sid,\n\t\t\t    SECCLASS_FILESYSTEM,\n\t\t\t    FILESYSTEM__ASSOCIATE, &ad);\n}\n\n#define MAY_LINK\t0\n#define MAY_UNLINK\t1\n#define MAY_RMDIR\t2\n\n/* Check whether a task can link, unlink, or rmdir a file/directory. */\nstatic int may_link(struct inode *dir,\n\t\t    struct dentry *dentry,\n\t\t    int kind)\n\n{\n\tstruct inode_security_struct *dsec, *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tu32 av;\n\tint rc;\n\n\tdsec = inode_security(dir);\n\tisec = backing_inode_security(dentry);\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\n\tav = DIR__SEARCH;\n\tav |= (kind ? DIR__REMOVE_NAME : DIR__ADD_NAME);\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, dsec->sid, SECCLASS_DIR, av, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (kind) {\n\tcase MAY_LINK:\n\t\tav = FILE__LINK;\n\t\tbreak;\n\tcase MAY_UNLINK:\n\t\tav = FILE__UNLINK;\n\t\tbreak;\n\tcase MAY_RMDIR:\n\t\tav = DIR__RMDIR;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"SELinux: %s:  unrecognized kind %d\\n\",\n\t\t\t__func__, kind);\n\t\treturn 0;\n\t}\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid, isec->sclass, av, &ad);\n\treturn rc;\n}\n\nstatic inline int may_rename(struct inode *old_dir,\n\t\t\t     struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir,\n\t\t\t     struct dentry *new_dentry)\n{\n\tstruct inode_security_struct *old_dsec, *new_dsec, *old_isec, *new_isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tu32 av;\n\tint old_is_dir, new_is_dir;\n\tint rc;\n\n\told_dsec = inode_security(old_dir);\n\told_isec = backing_inode_security(old_dentry);\n\told_is_dir = d_is_dir(old_dentry);\n\tnew_dsec = inode_security(new_dir);\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\n\tad.u.dentry = old_dentry;\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, old_dsec->sid, SECCLASS_DIR,\n\t\t\t  DIR__REMOVE_NAME | DIR__SEARCH, &ad);\n\tif (rc)\n\t\treturn rc;\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, old_isec->sid,\n\t\t\t  old_isec->sclass, FILE__RENAME, &ad);\n\tif (rc)\n\t\treturn rc;\n\tif (old_is_dir && new_dir != old_dir) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, old_isec->sid,\n\t\t\t\t  old_isec->sclass, DIR__REPARENT, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tad.u.dentry = new_dentry;\n\tav = DIR__ADD_NAME | DIR__SEARCH;\n\tif (d_is_positive(new_dentry))\n\t\tav |= DIR__REMOVE_NAME;\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, new_dsec->sid, SECCLASS_DIR, av, &ad);\n\tif (rc)\n\t\treturn rc;\n\tif (d_is_positive(new_dentry)) {\n\t\tnew_isec = backing_inode_security(new_dentry);\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, new_isec->sid,\n\t\t\t\t  new_isec->sclass,\n\t\t\t\t  (new_is_dir ? DIR__RMDIR : FILE__UNLINK), &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n/* Check whether a task can perform a filesystem operation. */\nstatic int superblock_has_perm(const struct cred *cred,\n\t\t\t       struct super_block *sb,\n\t\t\t       u32 perms,\n\t\t\t       struct common_audit_data *ad)\n{\n\tstruct superblock_security_struct *sbsec;\n\tu32 sid = cred_sid(cred);\n\n\tsbsec = sb->s_security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, sbsec->sid, SECCLASS_FILESYSTEM, perms, ad);\n}\n\n/* Convert a Linux mode and permission mask to an access vector. */\nstatic inline u32 file_mask_to_av(int mode, int mask)\n{\n\tu32 av = 0;\n\n\tif (!S_ISDIR(mode)) {\n\t\tif (mask & MAY_EXEC)\n\t\t\tav |= FILE__EXECUTE;\n\t\tif (mask & MAY_READ)\n\t\t\tav |= FILE__READ;\n\n\t\tif (mask & MAY_APPEND)\n\t\t\tav |= FILE__APPEND;\n\t\telse if (mask & MAY_WRITE)\n\t\t\tav |= FILE__WRITE;\n\n\t} else {\n\t\tif (mask & MAY_EXEC)\n\t\t\tav |= DIR__SEARCH;\n\t\tif (mask & MAY_WRITE)\n\t\t\tav |= DIR__WRITE;\n\t\tif (mask & MAY_READ)\n\t\t\tav |= DIR__READ;\n\t}\n\n\treturn av;\n}\n\n/* Convert a Linux file to an access vector. */\nstatic inline u32 file_to_av(struct file *file)\n{\n\tu32 av = 0;\n\n\tif (file->f_mode & FMODE_READ)\n\t\tav |= FILE__READ;\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (file->f_flags & O_APPEND)\n\t\t\tav |= FILE__APPEND;\n\t\telse\n\t\t\tav |= FILE__WRITE;\n\t}\n\tif (!av) {\n\t\t/*\n\t\t * Special file opened with flags 3 for ioctl-only use.\n\t\t */\n\t\tav = FILE__IOCTL;\n\t}\n\n\treturn av;\n}\n\n/*\n * Convert a file to an access vector and include the correct\n * open permission.\n */\nstatic inline u32 open_file_to_av(struct file *file)\n{\n\tu32 av = file_to_av(file);\n\tstruct inode *inode = file_inode(file);\n\n\tif (selinux_policycap_openperm() &&\n\t    inode->i_sb->s_magic != SOCKFS_MAGIC)\n\t\tav |= FILE__OPEN;\n\n\treturn av;\n}\n\n/* Hook functions begin here. */\n\nstatic int selinux_binder_set_context_mgr(struct task_struct *mgr)\n{\n\tu32 mysid = current_sid();\n\tu32 mgrsid = task_sid(mgr);\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    mysid, mgrsid, SECCLASS_BINDER,\n\t\t\t    BINDER__SET_CONTEXT_MGR, NULL);\n}\n\nstatic int selinux_binder_transaction(struct task_struct *from,\n\t\t\t\t      struct task_struct *to)\n{\n\tu32 mysid = current_sid();\n\tu32 fromsid = task_sid(from);\n\tu32 tosid = task_sid(to);\n\tint rc;\n\n\tif (mysid != fromsid) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  mysid, fromsid, SECCLASS_BINDER,\n\t\t\t\t  BINDER__IMPERSONATE, NULL);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    fromsid, tosid, SECCLASS_BINDER, BINDER__CALL,\n\t\t\t    NULL);\n}\n\nstatic int selinux_binder_transfer_binder(struct task_struct *from,\n\t\t\t\t\t  struct task_struct *to)\n{\n\tu32 fromsid = task_sid(from);\n\tu32 tosid = task_sid(to);\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER,\n\t\t\t    NULL);\n}\n\nstatic int selinux_binder_transfer_file(struct task_struct *from,\n\t\t\t\t\tstruct task_struct *to,\n\t\t\t\t\tstruct file *file)\n{\n\tu32 sid = task_sid(to);\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode_security_struct *isec;\n\tstruct common_audit_data ad;\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_PATH;\n\tad.u.path = file->f_path;\n\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, fsec->sid,\n\t\t\t\t  SECCLASS_FD,\n\t\t\t\t  FD__USE,\n\t\t\t\t  &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n#ifdef CONFIG_BPF_SYSCALL\n\trc = bpf_fd_pass(file, sid);\n\tif (rc)\n\t\treturn rc;\n#endif\n\n\tif (unlikely(IS_PRIVATE(d_backing_inode(dentry))))\n\t\treturn 0;\n\n\tisec = backing_inode_security(dentry);\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, isec->sclass, file_to_av(file),\n\t\t\t    &ad);\n}\n\nstatic int selinux_ptrace_access_check(struct task_struct *child,\n\t\t\t\t     unsigned int mode)\n{\n\tu32 sid = current_sid();\n\tu32 csid = task_sid(child);\n\n\tif (mode & PTRACE_MODE_READ)\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    sid, csid, SECCLASS_FILE, FILE__READ, NULL);\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, csid, SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}\n\nstatic int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    task_sid(parent), current_sid(), SECCLASS_PROCESS,\n\t\t\t    PROCESS__PTRACE, NULL);\n}\n\nstatic int selinux_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t  kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(target), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETCAP, NULL);\n}\n\nstatic int selinux_capset(struct cred *new, const struct cred *old,\n\t\t\t  const kernel_cap_t *effective,\n\t\t\t  const kernel_cap_t *inheritable,\n\t\t\t  const kernel_cap_t *permitted)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    cred_sid(old), cred_sid(new), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETCAP, NULL);\n}\n\n/*\n * (This comment used to live with the selinux_task_setuid hook,\n * which was removed).\n *\n * Since setuid only affects the current process, and since the SELinux\n * controls are not based on the Linux identity attributes, SELinux does not\n * need to control this operation.  However, SELinux does control the use of\n * the CAP_SETUID and CAP_SETGID capabilities using the capable hook.\n */\n\nstatic int selinux_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t   int cap, unsigned int opts)\n{\n\treturn cred_has_capability(cred, cap, opts, ns == &init_user_ns);\n}\n\nstatic int selinux_quotactl(int cmds, int type, int id, struct super_block *sb)\n{\n\tconst struct cred *cred = current_cred();\n\tint rc = 0;\n\n\tif (!sb)\n\t\treturn 0;\n\n\tswitch (cmds) {\n\tcase Q_SYNC:\n\tcase Q_QUOTAON:\n\tcase Q_QUOTAOFF:\n\tcase Q_SETINFO:\n\tcase Q_SETQUOTA:\n\tcase Q_XQUOTAOFF:\n\tcase Q_XQUOTAON:\n\tcase Q_XSETQLIM:\n\t\trc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAMOD, NULL);\n\t\tbreak;\n\tcase Q_GETFMT:\n\tcase Q_GETINFO:\n\tcase Q_GETQUOTA:\n\tcase Q_XGETQUOTA:\n\tcase Q_XGETQSTAT:\n\tcase Q_XGETQSTATV:\n\tcase Q_XGETNEXTQUOTA:\n\t\trc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAGET, NULL);\n\t\tbreak;\n\tdefault:\n\t\trc = 0;  /* let the kernel handle invalid cmds */\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int selinux_quota_on(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__QUOTAON);\n}\n\nstatic int selinux_syslog(int type)\n{\n\tswitch (type) {\n\tcase SYSLOG_ACTION_READ_ALL:\t/* Read last kernel messages */\n\tcase SYSLOG_ACTION_SIZE_BUFFER:\t/* Return size of the log buffer */\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__SYSLOG_READ, NULL);\n\tcase SYSLOG_ACTION_CONSOLE_OFF:\t/* Disable logging to console */\n\tcase SYSLOG_ACTION_CONSOLE_ON:\t/* Enable logging to console */\n\t/* Set level of messages printed to console */\n\tcase SYSLOG_ACTION_CONSOLE_LEVEL:\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__SYSLOG_CONSOLE,\n\t\t\t\t    NULL);\n\t}\n\t/* All other syslog types */\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), SECINITSID_KERNEL,\n\t\t\t    SECCLASS_SYSTEM, SYSTEM__SYSLOG_MOD, NULL);\n}\n\n/*\n * Check that a process has enough memory to allocate a new virtual\n * mapping. 0 means there is enough memory for the allocation to\n * succeed and -ENOMEM implies there is not.\n *\n * Do not audit the selinux permission check, as this is applied to all\n * processes that allocate mappings.\n */\nstatic int selinux_vm_enough_memory(struct mm_struct *mm, long pages)\n{\n\tint rc, cap_sys_admin = 0;\n\n\trc = cred_has_capability(current_cred(), CAP_SYS_ADMIN,\n\t\t\t\t CAP_OPT_NOAUDIT, true);\n\tif (rc == 0)\n\t\tcap_sys_admin = 1;\n\n\treturn cap_sys_admin;\n}\n\n/* binprm security operations */\n\nstatic u32 ptrace_parent_sid(void)\n{\n\tu32 sid = 0;\n\tstruct task_struct *tracer;\n\n\trcu_read_lock();\n\ttracer = ptrace_parent(current);\n\tif (tracer)\n\t\tsid = task_sid(tracer);\n\trcu_read_unlock();\n\n\treturn sid;\n}\n\nstatic int check_nnp_nosuid(const struct linux_binprm *bprm,\n\t\t\t    const struct task_security_struct *old_tsec,\n\t\t\t    const struct task_security_struct *new_tsec)\n{\n\tint nnp = (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS);\n\tint nosuid = !mnt_may_suid(bprm->file->f_path.mnt);\n\tint rc;\n\tu32 av;\n\n\tif (!nnp && !nosuid)\n\t\treturn 0; /* neither NNP nor nosuid */\n\n\tif (new_tsec->sid == old_tsec->sid)\n\t\treturn 0; /* No change in credentials */\n\n\t/*\n\t * If the policy enables the nnp_nosuid_transition policy capability,\n\t * then we permit transitions under NNP or nosuid if the\n\t * policy allows the corresponding permission between\n\t * the old and new contexts.\n\t */\n\tif (selinux_policycap_nnp_nosuid_transition()) {\n\t\tav = 0;\n\t\tif (nnp)\n\t\t\tav |= PROCESS2__NNP_TRANSITION;\n\t\tif (nosuid)\n\t\t\tav |= PROCESS2__NOSUID_TRANSITION;\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  old_tsec->sid, new_tsec->sid,\n\t\t\t\t  SECCLASS_PROCESS2, av, NULL);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * We also permit NNP or nosuid transitions to bounded SIDs,\n\t * i.e. SIDs that are guaranteed to only be allowed a subset\n\t * of the permissions of the current SID.\n\t */\n\trc = security_bounded_transition(&selinux_state, old_tsec->sid,\n\t\t\t\t\t new_tsec->sid);\n\tif (!rc)\n\t\treturn 0;\n\n\t/*\n\t * On failure, preserve the errno values for NNP vs nosuid.\n\t * NNP:  Operation not permitted for caller.\n\t * nosuid:  Permission denied to file.\n\t */\n\tif (nnp)\n\t\treturn -EPERM;\n\treturn -EACCES;\n}\n\nstatic int selinux_bprm_creds_for_exec(struct linux_binprm *bprm)\n{\n\tconst struct task_security_struct *old_tsec;\n\tstruct task_security_struct *new_tsec;\n\tstruct inode_security_struct *isec;\n\tstruct common_audit_data ad;\n\tstruct inode *inode = file_inode(bprm->file);\n\tint rc;\n\n\t/* SELinux context only depends on initial program or script and not\n\t * the script interpreter */\n\n\told_tsec = selinux_cred(current_cred());\n\tnew_tsec = selinux_cred(bprm->cred);\n\tisec = inode_security(inode);\n\n\t/* Default to the current task SID. */\n\tnew_tsec->sid = old_tsec->sid;\n\tnew_tsec->osid = old_tsec->sid;\n\n\t/* Reset fs, key, and sock SIDs on execve. */\n\tnew_tsec->create_sid = 0;\n\tnew_tsec->keycreate_sid = 0;\n\tnew_tsec->sockcreate_sid = 0;\n\n\tif (old_tsec->exec_sid) {\n\t\tnew_tsec->sid = old_tsec->exec_sid;\n\t\t/* Reset exec SID on execve. */\n\t\tnew_tsec->exec_sid = 0;\n\n\t\t/* Fail on NNP or nosuid if not an allowed transition. */\n\t\trc = check_nnp_nosuid(bprm, old_tsec, new_tsec);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\t/* Check for a default transition on this program. */\n\t\trc = security_transition_sid(&selinux_state, old_tsec->sid,\n\t\t\t\t\t     isec->sid, SECCLASS_PROCESS, NULL,\n\t\t\t\t\t     &new_tsec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * Fallback to old SID on NNP or nosuid if not an allowed\n\t\t * transition.\n\t\t */\n\t\trc = check_nnp_nosuid(bprm, old_tsec, new_tsec);\n\t\tif (rc)\n\t\t\tnew_tsec->sid = old_tsec->sid;\n\t}\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = bprm->file;\n\n\tif (new_tsec->sid == old_tsec->sid) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  old_tsec->sid, isec->sid,\n\t\t\t\t  SECCLASS_FILE, FILE__EXECUTE_NO_TRANS, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\t/* Check permissions for the transition. */\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  old_tsec->sid, new_tsec->sid,\n\t\t\t\t  SECCLASS_PROCESS, PROCESS__TRANSITION, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  new_tsec->sid, isec->sid,\n\t\t\t\t  SECCLASS_FILE, FILE__ENTRYPOINT, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* Check for shared state */\n\t\tif (bprm->unsafe & LSM_UNSAFE_SHARE) {\n\t\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t\t  old_tsec->sid, new_tsec->sid,\n\t\t\t\t\t  SECCLASS_PROCESS, PROCESS__SHARE,\n\t\t\t\t\t  NULL);\n\t\t\tif (rc)\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/* Make sure that anyone attempting to ptrace over a task that\n\t\t * changes its SID has the appropriate permit */\n\t\tif (bprm->unsafe & LSM_UNSAFE_PTRACE) {\n\t\t\tu32 ptsid = ptrace_parent_sid();\n\t\t\tif (ptsid != 0) {\n\t\t\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t\t\t  ptsid, new_tsec->sid,\n\t\t\t\t\t\t  SECCLASS_PROCESS,\n\t\t\t\t\t\t  PROCESS__PTRACE, NULL);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n\n\t\t/* Clear any possibly unsafe personality bits on exec: */\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\n\t\t/* Enable secure mode for SIDs transitions unless\n\t\t   the noatsecure permission is granted between\n\t\t   the two SIDs, i.e. ahp returns 0. */\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  old_tsec->sid, new_tsec->sid,\n\t\t\t\t  SECCLASS_PROCESS, PROCESS__NOATSECURE,\n\t\t\t\t  NULL);\n\t\tbprm->secureexec |= !!rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int match_file(const void *p, struct file *file, unsigned fd)\n{\n\treturn file_has_perm(p, file, file_to_av(file)) ? fd + 1 : 0;\n}\n\n/* Derived from fs/exec.c:flush_old_files. */\nstatic inline void flush_unauthorized_files(const struct cred *cred,\n\t\t\t\t\t    struct files_struct *files)\n{\n\tstruct file *file, *devnull = NULL;\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\tunsigned n;\n\n\ttty = get_current_tty();\n\tif (tty) {\n\t\tspin_lock(&tty->files_lock);\n\t\tif (!list_empty(&tty->tty_files)) {\n\t\t\tstruct tty_file_private *file_priv;\n\n\t\t\t/* Revalidate access to controlling tty.\n\t\t\t   Use file_path_has_perm on the tty path directly\n\t\t\t   rather than using file_has_perm, as this particular\n\t\t\t   open file may belong to another process and we are\n\t\t\t   only interested in the inode-based check here. */\n\t\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t\tstruct tty_file_private, list);\n\t\t\tfile = file_priv->file;\n\t\t\tif (file_path_has_perm(cred, file, FILE__READ | FILE__WRITE))\n\t\t\t\tdrop_tty = 1;\n\t\t}\n\t\tspin_unlock(&tty->files_lock);\n\t\ttty_kref_put(tty);\n\t}\n\t/* Reset controlling tty. */\n\tif (drop_tty)\n\t\tno_tty();\n\n\t/* Revalidate access to inherited open files. */\n\tn = iterate_fd(files, 0, match_file, cred);\n\tif (!n) /* none found? */\n\t\treturn;\n\n\tdevnull = dentry_open(&selinux_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t/* replace all the matching ones with this */\n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, cred)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\n}\n\n/*\n * Prepare a process for imminent new credential changes due to exec\n */\nstatic void selinux_bprm_committing_creds(struct linux_binprm *bprm)\n{\n\tstruct task_security_struct *new_tsec;\n\tstruct rlimit *rlim, *initrlim;\n\tint rc, i;\n\n\tnew_tsec = selinux_cred(bprm->cred);\n\tif (new_tsec->sid == new_tsec->osid)\n\t\treturn;\n\n\t/* Close files for which the new task SID is not authorized. */\n\tflush_unauthorized_files(bprm->cred, current->files);\n\n\t/* Always clear parent death signal on SID transitions. */\n\tcurrent->pdeath_signal = 0;\n\n\t/* Check whether the new SID can inherit resource limits from the old\n\t * SID.  If not, reset all soft limits to the lower of the current\n\t * task's hard limit and the init task's soft limit.\n\t *\n\t * Note that the setting of hard limits (even to lower them) can be\n\t * controlled by the setrlimit check.  The inclusion of the init task's\n\t * soft limit into the computation is to avoid resetting soft limits\n\t * higher than the default soft limit for cases where the default is\n\t * lower than the hard limit, e.g. RLIMIT_CORE or RLIMIT_STACK.\n\t */\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  new_tsec->osid, new_tsec->sid, SECCLASS_PROCESS,\n\t\t\t  PROCESS__RLIMITINH, NULL);\n\tif (rc) {\n\t\t/* protect against do_prlimit() */\n\t\ttask_lock(current);\n\t\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\t\trlim = current->signal->rlim + i;\n\t\t\tinitrlim = init_task.signal->rlim + i;\n\t\t\trlim->rlim_cur = min(rlim->rlim_max, initrlim->rlim_cur);\n\t\t}\n\t\ttask_unlock(current);\n\t\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\t\tupdate_rlimit_cpu(current, rlimit(RLIMIT_CPU));\n\t}\n}\n\n/*\n * Clean up the process immediately after the installation of new credentials\n * due to exec\n */\nstatic void selinux_bprm_committed_creds(struct linux_binprm *bprm)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tu32 osid, sid;\n\tint rc;\n\n\tosid = tsec->osid;\n\tsid = tsec->sid;\n\n\tif (sid == osid)\n\t\treturn;\n\n\t/* Check whether the new SID can inherit signal state from the old SID.\n\t * If not, clear itimers to avoid subsequent signal generation and\n\t * flush and unblock signals.\n\t *\n\t * This must occur _after_ the task SID has been updated so that any\n\t * kill done after the flush will be checked against the new SID.\n\t */\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  osid, sid, SECCLASS_PROCESS, PROCESS__SIGINH, NULL);\n\tif (rc) {\n\t\tclear_itimer();\n\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (!fatal_signal_pending(current)) {\n\t\t\tflush_sigqueue(&current->pending);\n\t\t\tflush_sigqueue(&current->signal->shared_pending);\n\t\t\tflush_signal_handlers(current, 1);\n\t\t\tsigemptyset(&current->blocked);\n\t\t\trecalc_sigpending();\n\t\t}\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\t/* Wake up the parent if it is waiting so that it can recheck\n\t * wait permission to the new task SID. */\n\tread_lock(&tasklist_lock);\n\t__wake_up_parent(current, current->real_parent);\n\tread_unlock(&tasklist_lock);\n}\n\n/* superblock security operations */\n\nstatic int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\n\treturn 0;\n}\n\nstatic void selinux_sb_free_security(struct super_block *sb)\n{\n\tsuperblock_free_security(sb);\n}\n\nstatic inline int opt_len(const char *s)\n{\n\tbool open_quote = false;\n\tint len;\n\tchar c;\n\n\tfor (len = 0; (c = s[len]) != '\\0'; len++) {\n\t\tif (c == '\"')\n\t\t\topen_quote = !open_quote;\n\t\tif (c == ',' && !open_quote)\n\t\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic int selinux_sb_eat_lsm_opts(char *options, void **mnt_opts)\n{\n\tchar *from = options;\n\tchar *to = options;\n\tbool first = true;\n\tint rc;\n\n\twhile (1) {\n\t\tint len = opt_len(from);\n\t\tint token;\n\t\tchar *arg = NULL;\n\n\t\ttoken = match_opt_prefix(from, len, &arg);\n\n\t\tif (token != Opt_error) {\n\t\t\tchar *p, *q;\n\n\t\t\t/* strip quotes */\n\t\t\tif (arg) {\n\t\t\t\tfor (p = q = arg; p < from + len; p++) {\n\t\t\t\t\tchar c = *p;\n\t\t\t\t\tif (c != '\"')\n\t\t\t\t\t\t*q++ = c;\n\t\t\t\t}\n\t\t\t\targ = kmemdup_nul(arg, q - arg, GFP_KERNEL);\n\t\t\t\tif (!arg) {\n\t\t\t\t\trc = -ENOMEM;\n\t\t\t\t\tgoto free_opt;\n\t\t\t\t}\n\t\t\t}\n\t\t\trc = selinux_add_opt(token, arg, mnt_opts);\n\t\t\tif (unlikely(rc)) {\n\t\t\t\tkfree(arg);\n\t\t\t\tgoto free_opt;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!first) {\t// copy with preceding comma\n\t\t\t\tfrom--;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (to != from)\n\t\t\t\tmemmove(to, from, len);\n\t\t\tto += len;\n\t\t\tfirst = false;\n\t\t}\n\t\tif (!from[len])\n\t\t\tbreak;\n\t\tfrom += len + 1;\n\t}\n\t*to = '\\0';\n\treturn 0;\n\nfree_opt:\n\tif (*mnt_opts) {\n\t\tselinux_free_mnt_opts(*mnt_opts);\n\t\t*mnt_opts = NULL;\n\t}\n\treturn rc;\n}\n\nstatic int selinux_sb_remount(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tu32 sid;\n\tint rc;\n\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\n\tif (!opts)\n\t\treturn 0;\n\n\tif (opts->fscontext) {\n\t\trc = parse_sid(sb, opts->fscontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->context) {\n\t\trc = parse_sid(sb, opts->context, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->rootcontext) {\n\t\tstruct inode_security_struct *root_isec;\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\trc = parse_sid(sb, opts->rootcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->defcontext) {\n\t\trc = parse_sid(sb, opts->defcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\treturn 0;\n\nout_bad_option:\n\tpr_warn(\"SELinux: unable to change security options \"\n\t       \"during remount (dev %s, type=%s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\treturn -EINVAL;\n}\n\nstatic int selinux_sb_kern_mount(struct super_block *sb)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = sb->s_root;\n\treturn superblock_has_perm(cred, sb, FILESYSTEM__MOUNT, &ad);\n}\n\nstatic int selinux_sb_statfs(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry->d_sb->s_root;\n\treturn superblock_has_perm(cred, dentry->d_sb, FILESYSTEM__GETATTR, &ad);\n}\n\nstatic int selinux_mount(const char *dev_name,\n\t\t\t const struct path *path,\n\t\t\t const char *type,\n\t\t\t unsigned long flags,\n\t\t\t void *data)\n{\n\tconst struct cred *cred = current_cred();\n\n\tif (flags & MS_REMOUNT)\n\t\treturn superblock_has_perm(cred, path->dentry->d_sb,\n\t\t\t\t\t   FILESYSTEM__REMOUNT, NULL);\n\telse\n\t\treturn path_has_perm(cred, path, FILE__MOUNTON);\n}\n\nstatic int selinux_move_mount(const struct path *from_path,\n\t\t\t      const struct path *to_path)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn path_has_perm(cred, to_path, FILE__MOUNTON);\n}\n\nstatic int selinux_umount(struct vfsmount *mnt, int flags)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn superblock_has_perm(cred, mnt->mnt_sb,\n\t\t\t\t   FILESYSTEM__UNMOUNT, NULL);\n}\n\nstatic int selinux_fs_context_dup(struct fs_context *fc,\n\t\t\t\t  struct fs_context *src_fc)\n{\n\tconst struct selinux_mnt_opts *src = src_fc->security;\n\tstruct selinux_mnt_opts *opts;\n\n\tif (!src)\n\t\treturn 0;\n\n\tfc->security = kzalloc(sizeof(struct selinux_mnt_opts), GFP_KERNEL);\n\tif (!fc->security)\n\t\treturn -ENOMEM;\n\n\topts = fc->security;\n\n\tif (src->fscontext) {\n\t\topts->fscontext = kstrdup(src->fscontext, GFP_KERNEL);\n\t\tif (!opts->fscontext)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (src->context) {\n\t\topts->context = kstrdup(src->context, GFP_KERNEL);\n\t\tif (!opts->context)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (src->rootcontext) {\n\t\topts->rootcontext = kstrdup(src->rootcontext, GFP_KERNEL);\n\t\tif (!opts->rootcontext)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (src->defcontext) {\n\t\topts->defcontext = kstrdup(src->defcontext, GFP_KERNEL);\n\t\tif (!opts->defcontext)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic const struct fs_parameter_spec selinux_fs_parameters[] = {\n\tfsparam_string(CONTEXT_STR,\tOpt_context),\n\tfsparam_string(DEFCONTEXT_STR,\tOpt_defcontext),\n\tfsparam_string(FSCONTEXT_STR,\tOpt_fscontext),\n\tfsparam_string(ROOTCONTEXT_STR,\tOpt_rootcontext),\n\tfsparam_flag  (SECLABEL_STR,\tOpt_seclabel),\n\t{}\n};\n\nstatic int selinux_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t\t  struct fs_parameter *param)\n{\n\tstruct fs_parse_result result;\n\tint opt, rc;\n\n\topt = fs_parse(fc, selinux_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\trc = selinux_add_opt(opt, param->string, &fc->security);\n\tif (!rc) {\n\t\tparam->string = NULL;\n\t\trc = 1;\n\t}\n\treturn rc;\n}\n\n/* inode security operations */\n\nstatic int selinux_inode_alloc_security(struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = current_sid();\n\n\tspin_lock_init(&isec->lock);\n\tINIT_LIST_HEAD(&isec->list);\n\tisec->inode = inode;\n\tisec->sid = SECINITSID_UNLABELED;\n\tisec->sclass = SECCLASS_FILE;\n\tisec->task_sid = sid;\n\tisec->initialized = LABEL_INVALID;\n\n\treturn 0;\n}\n\nstatic void selinux_inode_free_security(struct inode *inode)\n{\n\tinode_free_security(inode);\n}\n\nstatic int selinux_dentry_init_security(struct dentry *dentry, int mode,\n\t\t\t\t\tconst struct qstr *name, void **ctx,\n\t\t\t\t\tu32 *ctxlen)\n{\n\tu32 newsid;\n\tint rc;\n\n\trc = selinux_determine_inode_label(selinux_cred(current_cred()),\n\t\t\t\t\t   d_inode(dentry->d_parent), name,\n\t\t\t\t\t   inode_mode_to_security_class(mode),\n\t\t\t\t\t   &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\treturn security_sid_to_context(&selinux_state, newsid, (char **)ctx,\n\t\t\t\t       ctxlen);\n}\n\nstatic int selinux_dentry_create_files_as(struct dentry *dentry, int mode,\n\t\t\t\t\t  struct qstr *name,\n\t\t\t\t\t  const struct cred *old,\n\t\t\t\t\t  struct cred *new)\n{\n\tu32 newsid;\n\tint rc;\n\tstruct task_security_struct *tsec;\n\n\trc = selinux_determine_inode_label(selinux_cred(old),\n\t\t\t\t\t   d_inode(dentry->d_parent), name,\n\t\t\t\t\t   inode_mode_to_security_class(mode),\n\t\t\t\t\t   &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\ttsec = selinux_cred(new);\n\ttsec->create_sid = newsid;\n\treturn 0;\n}\n\nstatic int selinux_inode_init_security(struct inode *inode, struct inode *dir,\n\t\t\t\t       const struct qstr *qstr,\n\t\t\t\t       const char **name,\n\t\t\t\t       void **value, size_t *len)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct superblock_security_struct *sbsec;\n\tu32 newsid, clen;\n\tint rc;\n\tchar *context;\n\n\tsbsec = dir->i_sb->s_security;\n\n\tnewsid = tsec->create_sid;\n\n\trc = selinux_determine_inode_label(tsec, dir, qstr,\n\t\tinode_mode_to_security_class(inode->i_mode),\n\t\t&newsid);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Possibly defer initialization to selinux_complete_init. */\n\tif (sbsec->flags & SE_SBINITIALIZED) {\n\t\tstruct inode_security_struct *isec = selinux_inode(inode);\n\t\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\t\tisec->sid = newsid;\n\t\tisec->initialized = LABEL_INITIALIZED;\n\t}\n\n\tif (!selinux_initialized(&selinux_state) ||\n\t    !(sbsec->flags & SBLABEL_MNT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (name)\n\t\t*name = XATTR_SELINUX_SUFFIX;\n\n\tif (value && len) {\n\t\trc = security_sid_to_context_force(&selinux_state, newsid,\n\t\t\t\t\t\t   &context, &clen);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\t*value = context;\n\t\t*len = clen;\n\t}\n\n\treturn 0;\n}\n\nstatic int selinux_inode_create(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn may_create(dir, dentry, SECCLASS_FILE);\n}\n\nstatic int selinux_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)\n{\n\treturn may_link(dir, old_dentry, MAY_LINK);\n}\n\nstatic int selinux_inode_unlink(struct inode *dir, struct dentry *dentry)\n{\n\treturn may_link(dir, dentry, MAY_UNLINK);\n}\n\nstatic int selinux_inode_symlink(struct inode *dir, struct dentry *dentry, const char *name)\n{\n\treturn may_create(dir, dentry, SECCLASS_LNK_FILE);\n}\n\nstatic int selinux_inode_mkdir(struct inode *dir, struct dentry *dentry, umode_t mask)\n{\n\treturn may_create(dir, dentry, SECCLASS_DIR);\n}\n\nstatic int selinux_inode_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\treturn may_link(dir, dentry, MAY_RMDIR);\n}\n\nstatic int selinux_inode_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)\n{\n\treturn may_create(dir, dentry, inode_mode_to_security_class(mode));\n}\n\nstatic int selinux_inode_rename(struct inode *old_inode, struct dentry *old_dentry,\n\t\t\t\tstruct inode *new_inode, struct dentry *new_dentry)\n{\n\treturn may_rename(old_inode, old_dentry, new_inode, new_dentry);\n}\n\nstatic int selinux_inode_readlink(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__READ);\n}\n\nstatic int selinux_inode_follow_link(struct dentry *dentry, struct inode *inode,\n\t\t\t\t     bool rcu)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec;\n\tu32 sid;\n\n\tvalidate_creds(cred);\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\tsid = cred_sid(cred);\n\tisec = inode_security_rcu(inode, rcu);\n\tif (IS_ERR(isec))\n\t\treturn PTR_ERR(isec);\n\n\treturn avc_has_perm_flags(&selinux_state,\n\t\t\t\t  sid, isec->sid, isec->sclass, FILE__READ, &ad,\n\t\t\t\t  rcu ? MAY_NOT_BLOCK : 0);\n}\n\nstatic noinline int audit_inode_permission(struct inode *inode,\n\t\t\t\t\t   u32 perms, u32 audited, u32 denied,\n\t\t\t\t\t   int result)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tint rc;\n\n\tad.type = LSM_AUDIT_DATA_INODE;\n\tad.u.inode = inode;\n\n\trc = slow_avc_audit(&selinux_state,\n\t\t\t    current_sid(), isec->sid, isec->sclass, perms,\n\t\t\t    audited, denied, result, &ad);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}\n\nstatic int selinux_inode_permission(struct inode *inode, int mask)\n{\n\tconst struct cred *cred = current_cred();\n\tu32 perms;\n\tbool from_access;\n\tbool no_block = mask & MAY_NOT_BLOCK;\n\tstruct inode_security_struct *isec;\n\tu32 sid;\n\tstruct av_decision avd;\n\tint rc, rc2;\n\tu32 audited, denied;\n\n\tfrom_access = mask & MAY_ACCESS;\n\tmask &= (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND);\n\n\t/* No permission to check.  Existence test. */\n\tif (!mask)\n\t\treturn 0;\n\n\tvalidate_creds(cred);\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tperms = file_mask_to_av(inode->i_mode, mask);\n\n\tsid = cred_sid(cred);\n\tisec = inode_security_rcu(inode, no_block);\n\tif (IS_ERR(isec))\n\t\treturn PTR_ERR(isec);\n\n\trc = avc_has_perm_noaudit(&selinux_state,\n\t\t\t\t  sid, isec->sid, isec->sclass, perms,\n\t\t\t\t  no_block ? AVC_NONBLOCKING : 0,\n\t\t\t\t  &avd);\n\taudited = avc_audit_required(perms, &avd, rc,\n\t\t\t\t     from_access ? FILE__AUDIT_ACCESS : 0,\n\t\t\t\t     &denied);\n\tif (likely(!audited))\n\t\treturn rc;\n\n\t/* fall back to ref-walk if we have to generate audit */\n\tif (no_block)\n\t\treturn -ECHILD;\n\n\trc2 = audit_inode_permission(inode, perms, audited, denied, rc);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}\n\nstatic int selinux_inode_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tunsigned int ia_valid = iattr->ia_valid;\n\t__u32 av = FILE__WRITE;\n\n\t/* ATTR_FORCE is just used for ATTR_KILL_S[UG]ID. */\n\tif (ia_valid & ATTR_FORCE) {\n\t\tia_valid &= ~(ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_MODE |\n\t\t\t      ATTR_FORCE);\n\t\tif (!ia_valid)\n\t\t\treturn 0;\n\t}\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID |\n\t\t\tATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_TIMES_SET))\n\t\treturn dentry_has_perm(cred, dentry, FILE__SETATTR);\n\n\tif (selinux_policycap_openperm() &&\n\t    inode->i_sb->s_magic != SOCKFS_MAGIC &&\n\t    (ia_valid & ATTR_SIZE) &&\n\t    !(ia_valid & ATTR_FILE))\n\t\tav |= FILE__OPEN;\n\n\treturn dentry_has_perm(cred, dentry, av);\n}\n\nstatic int selinux_inode_getattr(const struct path *path)\n{\n\treturn path_has_perm(current_cred(), path, FILE__GETATTR);\n}\n\nstatic bool has_cap_mac_admin(bool audit)\n{\n\tconst struct cred *cred = current_cred();\n\tunsigned int opts = audit ? CAP_OPT_NONE : CAP_OPT_NOAUDIT;\n\n\tif (cap_capable(cred, &init_user_ns, CAP_MAC_ADMIN, opts))\n\t\treturn false;\n\tif (cred_has_capability(cred, CAP_MAC_ADMIN, opts, true))\n\t\treturn false;\n\treturn true;\n}\n\nstatic int selinux_inode_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t  const void *value, size_t size, int flags)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct inode_security_struct *isec;\n\tstruct superblock_security_struct *sbsec;\n\tstruct common_audit_data ad;\n\tu32 newsid, sid = current_sid();\n\tint rc = 0;\n\n\tif (strcmp(name, XATTR_NAME_SELINUX)) {\n\t\trc = cap_inode_setxattr(dentry, name, value, size, flags);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* Not an attribute we recognize, so just check the\n\t\t   ordinary setattr permission. */\n\t\treturn dentry_has_perm(current_cred(), dentry, FILE__SETATTR);\n\t}\n\n\tif (!selinux_initialized(&selinux_state))\n\t\treturn (inode_owner_or_capable(inode) ? 0 : -EPERM);\n\n\tsbsec = inode->i_sb->s_security;\n\tif (!(sbsec->flags & SBLABEL_MNT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\n\tad.type = LSM_AUDIT_DATA_DENTRY;\n\tad.u.dentry = dentry;\n\n\tisec = backing_inode_security(dentry);\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid, isec->sclass,\n\t\t\t  FILE__RELABELFROM, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\trc = security_context_to_sid(&selinux_state, value, size, &newsid,\n\t\t\t\t     GFP_KERNEL);\n\tif (rc == -EINVAL) {\n\t\tif (!has_cap_mac_admin(true)) {\n\t\t\tstruct audit_buffer *ab;\n\t\t\tsize_t audit_size;\n\n\t\t\t/* We strip a nul only if it is at the end, otherwise the\n\t\t\t * context contains a nul and we should audit that */\n\t\t\tif (value) {\n\t\t\t\tconst char *str = value;\n\n\t\t\t\tif (str[size - 1] == '\\0')\n\t\t\t\t\taudit_size = size - 1;\n\t\t\t\telse\n\t\t\t\t\taudit_size = size;\n\t\t\t} else {\n\t\t\t\taudit_size = 0;\n\t\t\t}\n\t\t\tab = audit_log_start(audit_context(),\n\t\t\t\t\t     GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\t\t\taudit_log_format(ab, \"op=setxattr invalid_context=\");\n\t\t\taudit_log_n_untrustedstring(ab, value, audit_size);\n\t\t\taudit_log_end(ab);\n\n\t\t\treturn rc;\n\t\t}\n\t\trc = security_context_to_sid_force(&selinux_state, value,\n\t\t\t\t\t\t   size, &newsid);\n\t}\n\tif (rc)\n\t\treturn rc;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, newsid, isec->sclass,\n\t\t\t  FILE__RELABELTO, &ad);\n\tif (rc)\n\t\treturn rc;\n\n\trc = security_validate_transition(&selinux_state, isec->sid, newsid,\n\t\t\t\t\t  sid, isec->sclass);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    newsid,\n\t\t\t    sbsec->sid,\n\t\t\t    SECCLASS_FILESYSTEM,\n\t\t\t    FILESYSTEM__ASSOCIATE,\n\t\t\t    &ad);\n}\n\nstatic void selinux_inode_post_setxattr(struct dentry *dentry, const char *name,\n\t\t\t\t\tconst void *value, size_t size,\n\t\t\t\t\tint flags)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct inode_security_struct *isec;\n\tu32 newsid;\n\tint rc;\n\n\tif (strcmp(name, XATTR_NAME_SELINUX)) {\n\t\t/* Not an attribute we recognize, so nothing to do. */\n\t\treturn;\n\t}\n\n\tif (!selinux_initialized(&selinux_state)) {\n\t\t/* If we haven't even been initialized, then we can't validate\n\t\t * against a policy, so leave the label as invalid. It may\n\t\t * resolve to a valid label on the next revalidation try if\n\t\t * we've since initialized.\n\t\t */\n\t\treturn;\n\t}\n\n\trc = security_context_to_sid_force(&selinux_state, value, size,\n\t\t\t\t\t   &newsid);\n\tif (rc) {\n\t\tpr_err(\"SELinux:  unable to map context to SID\"\n\t\t       \"for (%s, %lu), rc=%d\\n\",\n\t\t       inode->i_sb->s_id, inode->i_ino, -rc);\n\t\treturn;\n\t}\n\n\tisec = backing_inode_security(dentry);\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = newsid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n\n\treturn;\n}\n\nstatic int selinux_inode_getxattr(struct dentry *dentry, const char *name)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__GETATTR);\n}\n\nstatic int selinux_inode_listxattr(struct dentry *dentry)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn dentry_has_perm(cred, dentry, FILE__GETATTR);\n}\n\nstatic int selinux_inode_removexattr(struct dentry *dentry, const char *name)\n{\n\tif (strcmp(name, XATTR_NAME_SELINUX)) {\n\t\tint rc = cap_inode_removexattr(dentry, name);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* Not an attribute we recognize, so just check the\n\t\t   ordinary setattr permission. */\n\t\treturn dentry_has_perm(current_cred(), dentry, FILE__SETATTR);\n\t}\n\n\tif (!selinux_initialized(&selinux_state))\n\t\treturn 0;\n\n\t/* No one is allowed to remove a SELinux security label.\n\t   You can change the label, but all data must be labeled. */\n\treturn -EACCES;\n}\n\nstatic int selinux_path_notify(const struct path *path, u64 mask,\n\t\t\t\t\t\tunsigned int obj_type)\n{\n\tint ret;\n\tu32 perm;\n\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_PATH;\n\tad.u.path = *path;\n\n\t/*\n\t * Set permission needed based on the type of mark being set.\n\t * Performs an additional check for sb watches.\n\t */\n\tswitch (obj_type) {\n\tcase FSNOTIFY_OBJ_TYPE_VFSMOUNT:\n\t\tperm = FILE__WATCH_MOUNT;\n\t\tbreak;\n\tcase FSNOTIFY_OBJ_TYPE_SB:\n\t\tperm = FILE__WATCH_SB;\n\t\tret = superblock_has_perm(current_cred(), path->dentry->d_sb,\n\t\t\t\t\t\tFILESYSTEM__WATCH, &ad);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase FSNOTIFY_OBJ_TYPE_INODE:\n\t\tperm = FILE__WATCH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* blocking watches require the file:watch_with_perm permission */\n\tif (mask & (ALL_FSNOTIFY_PERM_EVENTS))\n\t\tperm |= FILE__WATCH_WITH_PERM;\n\n\t/* watches on read-like events need the file:watch_reads permission */\n\tif (mask & (FS_ACCESS | FS_ACCESS_PERM | FS_CLOSE_NOWRITE))\n\t\tperm |= FILE__WATCH_READS;\n\n\treturn path_has_perm(current_cred(), path, perm);\n}\n\n/*\n * Copy the inode security context value to the user.\n *\n * Permission check is handled by selinux_inode_getxattr hook.\n */\nstatic int selinux_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n{\n\tu32 size;\n\tint error;\n\tchar *context = NULL;\n\tstruct inode_security_struct *isec;\n\n\t/*\n\t * If we're not initialized yet, then we can't validate contexts, so\n\t * just let vfs_getxattr fall back to using the on-disk xattr.\n\t */\n\tif (!selinux_initialized(&selinux_state) ||\n\t    strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * If the caller has CAP_MAC_ADMIN, then get the raw context\n\t * value even if it is not defined by current policy; otherwise,\n\t * use the in-core value under current policy.\n\t * Use the non-auditing forms of the permission checks since\n\t * getxattr may be called by unprivileged processes commonly\n\t * and lack of permission just means that we fall back to the\n\t * in-core context value, not a denial.\n\t */\n\tisec = inode_security(inode);\n\tif (has_cap_mac_admin(false))\n\t\terror = security_sid_to_context_force(&selinux_state,\n\t\t\t\t\t\t      isec->sid, &context,\n\t\t\t\t\t\t      &size);\n\telse\n\t\terror = security_sid_to_context(&selinux_state, isec->sid,\n\t\t\t\t\t\t&context, &size);\n\tif (error)\n\t\treturn error;\n\terror = size;\n\tif (alloc) {\n\t\t*buffer = context;\n\t\tgoto out_nofree;\n\t}\n\tkfree(context);\nout_nofree:\n\treturn error;\n}\n\nstatic int selinux_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t     const void *value, size_t size, int flags)\n{\n\tstruct inode_security_struct *isec = inode_security_novalidate(inode);\n\tstruct superblock_security_struct *sbsec = inode->i_sb->s_security;\n\tu32 newsid;\n\tint rc;\n\n\tif (strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(sbsec->flags & SBLABEL_MNT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!value || !size)\n\t\treturn -EACCES;\n\n\trc = security_context_to_sid(&selinux_state, value, size, &newsid,\n\t\t\t\t     GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = newsid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n\treturn 0;\n}\n\nstatic int selinux_inode_listsecurity(struct inode *inode, char *buffer, size_t buffer_size)\n{\n\tconst int len = sizeof(XATTR_NAME_SELINUX);\n\tif (buffer && len <= buffer_size)\n\t\tmemcpy(buffer, XATTR_NAME_SELINUX, len);\n\treturn len;\n}\n\nstatic void selinux_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tstruct inode_security_struct *isec = inode_security_novalidate(inode);\n\t*secid = isec->sid;\n}\n\nstatic int selinux_inode_copy_up(struct dentry *src, struct cred **new)\n{\n\tu32 sid;\n\tstruct task_security_struct *tsec;\n\tstruct cred *new_creds = *new;\n\n\tif (new_creds == NULL) {\n\t\tnew_creds = prepare_creds();\n\t\tif (!new_creds)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsec = selinux_cred(new_creds);\n\t/* Get label from overlay inode and set it in create_sid */\n\tselinux_inode_getsecid(d_inode(src), &sid);\n\ttsec->create_sid = sid;\n\t*new = new_creds;\n\treturn 0;\n}\n\nstatic int selinux_inode_copy_up_xattr(const char *name)\n{\n\t/* The copy_up hook above sets the initial context on an inode, but we\n\t * don't then want to overwrite it by blindly copying all the lower\n\t * xattrs up.  Instead, we have to filter out SELinux-related xattrs.\n\t */\n\tif (strcmp(name, XATTR_NAME_SELINUX) == 0)\n\t\treturn 1; /* Discard */\n\t/*\n\t * Any other attribute apart from SELINUX is not claimed, supported\n\t * by selinux.\n\t */\n\treturn -EOPNOTSUPP;\n}\n\n/* kernfs node operations */\n\nstatic int selinux_kernfs_init_security(struct kernfs_node *kn_dir,\n\t\t\t\t\tstruct kernfs_node *kn)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tu32 parent_sid, newsid, clen;\n\tint rc;\n\tchar *context;\n\n\trc = kernfs_xattr_get(kn_dir, XATTR_NAME_SELINUX, NULL, 0);\n\tif (rc == -ENODATA)\n\t\treturn 0;\n\telse if (rc < 0)\n\t\treturn rc;\n\n\tclen = (u32)rc;\n\tcontext = kmalloc(clen, GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\trc = kernfs_xattr_get(kn_dir, XATTR_NAME_SELINUX, context, clen);\n\tif (rc < 0) {\n\t\tkfree(context);\n\t\treturn rc;\n\t}\n\n\trc = security_context_to_sid(&selinux_state, context, clen, &parent_sid,\n\t\t\t\t     GFP_KERNEL);\n\tkfree(context);\n\tif (rc)\n\t\treturn rc;\n\n\tif (tsec->create_sid) {\n\t\tnewsid = tsec->create_sid;\n\t} else {\n\t\tu16 secclass = inode_mode_to_security_class(kn->mode);\n\t\tstruct qstr q;\n\n\t\tq.name = kn->name;\n\t\tq.hash_len = hashlen_string(kn_dir, kn->name);\n\n\t\trc = security_transition_sid(&selinux_state, tsec->sid,\n\t\t\t\t\t     parent_sid, secclass, &q,\n\t\t\t\t\t     &newsid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = security_sid_to_context_force(&selinux_state, newsid,\n\t\t\t\t\t   &context, &clen);\n\tif (rc)\n\t\treturn rc;\n\n\trc = kernfs_xattr_set(kn, XATTR_NAME_SELINUX, context, clen,\n\t\t\t      XATTR_CREATE);\n\tkfree(context);\n\treturn rc;\n}\n\n\n/* file security operations */\n\nstatic int selinux_revalidate_file_permission(struct file *file, int mask)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *inode = file_inode(file);\n\n\t/* file_mask_to_av won't add FILE__WRITE if MAY_APPEND is set */\n\tif ((file->f_flags & O_APPEND) && (mask & MAY_WRITE))\n\t\tmask |= MAY_APPEND;\n\n\treturn file_has_perm(cred, file,\n\t\t\t     file_mask_to_av(inode->i_mode, mask));\n}\n\nstatic int selinux_file_permission(struct file *file, int mask)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct inode_security_struct *isec;\n\tu32 sid = current_sid();\n\n\tif (!mask)\n\t\t/* No permission to check.  Existence test. */\n\t\treturn 0;\n\n\tisec = inode_security(inode);\n\tif (sid == fsec->sid && fsec->isid == isec->sid &&\n\t    fsec->pseqno == avc_policy_seqno(&selinux_state))\n\t\t/* No change since file_open check. */\n\t\treturn 0;\n\n\treturn selinux_revalidate_file_permission(file, mask);\n}\n\nstatic int selinux_file_alloc_security(struct file *file)\n{\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tu32 sid = current_sid();\n\n\tfsec->sid = sid;\n\tfsec->fown_sid = sid;\n\n\treturn 0;\n}\n\n/*\n * Check whether a task has the ioctl permission and cmd\n * operation to an inode.\n */\nstatic int ioctl_has_perm(const struct cred *cred, struct file *file,\n\t\tu32 requested, u16 cmd)\n{\n\tstruct common_audit_data ad;\n\tstruct file_security_struct *fsec = selinux_file(file);\n\tstruct inode *inode = file_inode(file);\n\tstruct inode_security_struct *isec;\n\tstruct lsm_ioctlop_audit ioctl;\n\tu32 ssid = cred_sid(cred);\n\tint rc;\n\tu8 driver = cmd >> 8;\n\tu8 xperm = cmd & 0xff;\n\n\tad.type = LSM_AUDIT_DATA_IOCTL_OP;\n\tad.u.op = &ioctl;\n\tad.u.op->cmd = cmd;\n\tad.u.op->path = file->f_path;\n\n\tif (ssid != fsec->sid) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  ssid, fsec->sid,\n\t\t\t\tSECCLASS_FD,\n\t\t\t\tFD__USE,\n\t\t\t\t&ad);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_PRIVATE(inode)))\n\t\treturn 0;\n\n\tisec = inode_security(inode);\n\trc = avc_has_extended_perms(&selinux_state,\n\t\t\t\t    ssid, isec->sid, isec->sclass,\n\t\t\t\t    requested, driver, xperm, &ad);\nout:\n\treturn rc;\n}\n\nstatic int selinux_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tconst struct cred *cred = current_cred();\n\tint error = 0;\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\tcase FIBMAP:\n\tcase FIGETBSZ:\n\tcase FS_IOC_GETFLAGS:\n\tcase FS_IOC_GETVERSION:\n\t\terror = file_has_perm(cred, file, FILE__GETATTR);\n\t\tbreak;\n\n\tcase FS_IOC_SETFLAGS:\n\tcase FS_IOC_SETVERSION:\n\t\terror = file_has_perm(cred, file, FILE__SETATTR);\n\t\tbreak;\n\n\t/* sys_ioctl() checks */\n\tcase FIONBIO:\n\tcase FIOASYNC:\n\t\terror = file_has_perm(cred, file, 0);\n\t\tbreak;\n\n\tcase KDSKBENT:\n\tcase KDSKBSENT:\n\t\terror = cred_has_capability(cred, CAP_SYS_TTY_CONFIG,\n\t\t\t\t\t    CAP_OPT_NONE, true);\n\t\tbreak;\n\n\t/* default case assumes that the command will go\n\t * to the file's ioctl() function.\n\t */\n\tdefault:\n\t\terror = ioctl_has_perm(cred, file, FILE__IOCTL, (u16) cmd);\n\t}\n\treturn error;\n}\n\nstatic int default_noexec __ro_after_init;\n\nstatic int file_map_prot_check(struct file *file, unsigned long prot, int shared)\n{\n\tconst struct cred *cred = current_cred();\n\tu32 sid = cred_sid(cred);\n\tint rc = 0;\n\n\tif (default_noexec &&\n\t    (prot & PROT_EXEC) && (!file || IS_PRIVATE(file_inode(file)) ||\n\t\t\t\t   (!shared && (prot & PROT_WRITE)))) {\n\t\t/*\n\t\t * We are making executable an anonymous mapping or a\n\t\t * private file mapping that will also be writable.\n\t\t * This has an additional check.\n\t\t */\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, sid, SECCLASS_PROCESS,\n\t\t\t\t  PROCESS__EXECMEM, NULL);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\tif (file) {\n\t\t/* read access is always possible with a mapping */\n\t\tu32 av = FILE__READ;\n\n\t\t/* write access only matters if the mapping is shared */\n\t\tif (shared && (prot & PROT_WRITE))\n\t\t\tav |= FILE__WRITE;\n\n\t\tif (prot & PROT_EXEC)\n\t\t\tav |= FILE__EXECUTE;\n\n\t\treturn file_has_perm(cred, file, av);\n\t}\n\nerror:\n\treturn rc;\n}\n\nstatic int selinux_mmap_addr(unsigned long addr)\n{\n\tint rc = 0;\n\n\tif (addr < CONFIG_LSM_MMAP_MIN_ADDR) {\n\t\tu32 sid = current_sid();\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, sid, SECCLASS_MEMPROTECT,\n\t\t\t\t  MEMPROTECT__MMAP_ZERO, NULL);\n\t}\n\n\treturn rc;\n}\n\nstatic int selinux_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t     unsigned long prot, unsigned long flags)\n{\n\tstruct common_audit_data ad;\n\tint rc;\n\n\tif (file) {\n\t\tad.type = LSM_AUDIT_DATA_FILE;\n\t\tad.u.file = file;\n\t\trc = inode_has_perm(current_cred(), file_inode(file),\n\t\t\t\t    FILE__MAP, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (checkreqprot_get(&selinux_state))\n\t\tprot = reqprot;\n\n\treturn file_map_prot_check(file, prot,\n\t\t\t\t   (flags & MAP_TYPE) == MAP_SHARED);\n}\n\nstatic int selinux_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t unsigned long reqprot,\n\t\t\t\t unsigned long prot)\n{\n\tconst struct cred *cred = current_cred();\n\tu32 sid = cred_sid(cred);\n\n\tif (checkreqprot_get(&selinux_state))\n\t\tprot = reqprot;\n\n\tif (default_noexec &&\n\t    (prot & PROT_EXEC) && !(vma->vm_flags & VM_EXEC)) {\n\t\tint rc = 0;\n\t\tif (vma->vm_start >= vma->vm_mm->start_brk &&\n\t\t    vma->vm_end <= vma->vm_mm->brk) {\n\t\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t\t  sid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t  PROCESS__EXECHEAP, NULL);\n\t\t} else if (!vma->vm_file &&\n\t\t\t   ((vma->vm_start <= vma->vm_mm->start_stack &&\n\t\t\t     vma->vm_end >= vma->vm_mm->start_stack) ||\n\t\t\t    vma_is_stack_for_current(vma))) {\n\t\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t\t  sid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t  PROCESS__EXECSTACK, NULL);\n\t\t} else if (vma->vm_file && vma->anon_vma) {\n\t\t\t/*\n\t\t\t * We are making executable a file mapping that has\n\t\t\t * had some COW done. Since pages might have been\n\t\t\t * written, check ability to execute the possibly\n\t\t\t * modified content.  This typically should only\n\t\t\t * occur for text relocations.\n\t\t\t */\n\t\t\trc = file_has_perm(cred, vma->vm_file, FILE__EXECMOD);\n\t\t}\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn file_map_prot_check(vma->vm_file, prot, vma->vm_flags&VM_SHARED);\n}\n\nstatic int selinux_file_lock(struct file *file, unsigned int cmd)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn file_has_perm(cred, file, FILE__LOCK);\n}\n\nstatic int selinux_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tconst struct cred *cred = current_cred();\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase F_SETFL:\n\t\tif ((file->f_flags & O_APPEND) && !(arg & O_APPEND)) {\n\t\t\terr = file_has_perm(cred, file, FILE__WRITE);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase F_SETOWN:\n\tcase F_SETSIG:\n\tcase F_GETFL:\n\tcase F_GETOWN:\n\tcase F_GETSIG:\n\tcase F_GETOWNER_UIDS:\n\t\t/* Just check FD__USE permission */\n\t\terr = file_has_perm(cred, file, 0);\n\t\tbreak;\n\tcase F_GETLK:\n\tcase F_SETLK:\n\tcase F_SETLKW:\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n#if BITS_PER_LONG == 32\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n#endif\n\t\terr = file_has_perm(cred, file, FILE__LOCK);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void selinux_file_set_fowner(struct file *file)\n{\n\tstruct file_security_struct *fsec;\n\n\tfsec = selinux_file(file);\n\tfsec->fown_sid = current_sid();\n}\n\nstatic int selinux_file_send_sigiotask(struct task_struct *tsk,\n\t\t\t\t       struct fown_struct *fown, int signum)\n{\n\tstruct file *file;\n\tu32 sid = task_sid(tsk);\n\tu32 perm;\n\tstruct file_security_struct *fsec;\n\n\t/* struct fown_struct is never outside the context of a struct file */\n\tfile = container_of(fown, struct file, f_owner);\n\n\tfsec = selinux_file(file);\n\n\tif (!signum)\n\t\tperm = signal_to_av(SIGIO); /* as per send_sigio_to_task */\n\telse\n\t\tperm = signal_to_av(signum);\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    fsec->fown_sid, sid,\n\t\t\t    SECCLASS_PROCESS, perm, NULL);\n}\n\nstatic int selinux_file_receive(struct file *file)\n{\n\tconst struct cred *cred = current_cred();\n\n\treturn file_has_perm(cred, file, file_to_av(file));\n}\n\nstatic int selinux_file_open(struct file *file)\n{\n\tstruct file_security_struct *fsec;\n\tstruct inode_security_struct *isec;\n\n\tfsec = selinux_file(file);\n\tisec = inode_security(file_inode(file));\n\t/*\n\t * Save inode label and policy sequence number\n\t * at open-time so that selinux_file_permission\n\t * can determine whether revalidation is necessary.\n\t * Task label is already saved in the file security\n\t * struct as its SID.\n\t */\n\tfsec->isid = isec->sid;\n\tfsec->pseqno = avc_policy_seqno(&selinux_state);\n\t/*\n\t * Since the inode label or policy seqno may have changed\n\t * between the selinux_inode_permission check and the saving\n\t * of state above, recheck that access is still permitted.\n\t * Otherwise, access might never be revalidated against the\n\t * new inode label or new policy.\n\t * This check is not redundant - do not remove.\n\t */\n\treturn file_path_has_perm(file->f_cred, file, open_file_to_av(file));\n}\n\n/* task security operations */\n\nstatic int selinux_task_alloc(struct task_struct *task,\n\t\t\t      unsigned long clone_flags)\n{\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, sid, SECCLASS_PROCESS, PROCESS__FORK, NULL);\n}\n\n/*\n * prepare a new set of credentials for modification\n */\nstatic int selinux_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\tgfp_t gfp)\n{\n\tconst struct task_security_struct *old_tsec = selinux_cred(old);\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\n\t*tsec = *old_tsec;\n\treturn 0;\n}\n\n/*\n * transfer the SELinux data to a blank set of creds\n */\nstatic void selinux_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct task_security_struct *old_tsec = selinux_cred(old);\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\n\t*tsec = *old_tsec;\n}\n\nstatic void selinux_cred_getsecid(const struct cred *c, u32 *secid)\n{\n\t*secid = cred_sid(c);\n}\n\n/*\n * set the security data for a kernel service\n * - all the creation contexts are set to unlabelled\n */\nstatic int selinux_kernel_act_as(struct cred *new, u32 secid)\n{\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\tu32 sid = current_sid();\n\tint ret;\n\n\tret = avc_has_perm(&selinux_state,\n\t\t\t   sid, secid,\n\t\t\t   SECCLASS_KERNEL_SERVICE,\n\t\t\t   KERNEL_SERVICE__USE_AS_OVERRIDE,\n\t\t\t   NULL);\n\tif (ret == 0) {\n\t\ttsec->sid = secid;\n\t\ttsec->create_sid = 0;\n\t\ttsec->keycreate_sid = 0;\n\t\ttsec->sockcreate_sid = 0;\n\t}\n\treturn ret;\n}\n\n/*\n * set the file creation context in a security record to the same as the\n * objective context of the specified inode\n */\nstatic int selinux_kernel_create_files_as(struct cred *new, struct inode *inode)\n{\n\tstruct inode_security_struct *isec = inode_security(inode);\n\tstruct task_security_struct *tsec = selinux_cred(new);\n\tu32 sid = current_sid();\n\tint ret;\n\n\tret = avc_has_perm(&selinux_state,\n\t\t\t   sid, isec->sid,\n\t\t\t   SECCLASS_KERNEL_SERVICE,\n\t\t\t   KERNEL_SERVICE__CREATE_FILES_AS,\n\t\t\t   NULL);\n\n\tif (ret == 0)\n\t\ttsec->create_sid = isec->sid;\n\treturn ret;\n}\n\nstatic int selinux_kernel_module_request(char *kmod_name)\n{\n\tstruct common_audit_data ad;\n\n\tad.type = LSM_AUDIT_DATA_KMOD;\n\tad.u.kmod_name = kmod_name;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), SECINITSID_KERNEL, SECCLASS_SYSTEM,\n\t\t\t    SYSTEM__MODULE_REQUEST, &ad);\n}\n\nstatic int selinux_kernel_module_from_file(struct file *file)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec;\n\tstruct file_security_struct *fsec;\n\tu32 sid = current_sid();\n\tint rc;\n\n\t/* init_module */\n\tif (file == NULL)\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    sid, sid, SECCLASS_SYSTEM,\n\t\t\t\t\tSYSTEM__MODULE_LOAD, NULL);\n\n\t/* finit_module */\n\n\tad.type = LSM_AUDIT_DATA_FILE;\n\tad.u.file = file;\n\n\tfsec = selinux_file(file);\n\tif (sid != fsec->sid) {\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tisec = inode_security(file_inode(file));\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, SECCLASS_SYSTEM,\n\t\t\t\tSYSTEM__MODULE_LOAD, &ad);\n}\n\nstatic int selinux_kernel_read_file(struct file *file,\n\t\t\t\t    enum kernel_read_file_id id,\n\t\t\t\t    bool contents)\n{\n\tint rc = 0;\n\n\tswitch (id) {\n\tcase READING_MODULE:\n\t\trc = selinux_kernel_module_from_file(contents ? file : NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int selinux_kernel_load_data(enum kernel_load_data_id id, bool contents)\n{\n\tint rc = 0;\n\n\tswitch (id) {\n\tcase LOADING_MODULE:\n\t\trc = selinux_kernel_module_from_file(NULL);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int selinux_task_setpgid(struct task_struct *p, pid_t pgid)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETPGID, NULL);\n}\n\nstatic int selinux_task_getpgid(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETPGID, NULL);\n}\n\nstatic int selinux_task_getsid(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSESSION, NULL);\n}\n\nstatic void selinux_task_getsecid(struct task_struct *p, u32 *secid)\n{\n\t*secid = task_sid(p);\n}\n\nstatic int selinux_task_setnice(struct task_struct *p, int nice)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_setioprio(struct task_struct *p, int ioprio)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_getioprio(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSCHED, NULL);\n}\n\nstatic int selinux_task_prlimit(const struct cred *cred, const struct cred *tcred,\n\t\t\t\tunsigned int flags)\n{\n\tu32 av = 0;\n\n\tif (!flags)\n\t\treturn 0;\n\tif (flags & LSM_PRLIMIT_WRITE)\n\t\tav |= PROCESS__SETRLIMIT;\n\tif (flags & LSM_PRLIMIT_READ)\n\t\tav |= PROCESS__GETRLIMIT;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    cred_sid(cred), cred_sid(tcred),\n\t\t\t    SECCLASS_PROCESS, av, NULL);\n}\n\nstatic int selinux_task_setrlimit(struct task_struct *p, unsigned int resource,\n\t\tstruct rlimit *new_rlim)\n{\n\tstruct rlimit *old_rlim = p->signal->rlim + resource;\n\n\t/* Control the ability to change the hard limit (whether\n\t   lowering or raising it), so that the hard limit can\n\t   later be used as a safe reset point for the soft limit\n\t   upon context transitions.  See selinux_bprm_committing_creds. */\n\tif (old_rlim->rlim_max != new_rlim->rlim_max)\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    current_sid(), task_sid(p),\n\t\t\t\t    SECCLASS_PROCESS, PROCESS__SETRLIMIT, NULL);\n\n\treturn 0;\n}\n\nstatic int selinux_task_setscheduler(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_getscheduler(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSCHED, NULL);\n}\n\nstatic int selinux_task_movememory(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}\n\nstatic int selinux_task_kill(struct task_struct *p, struct kernel_siginfo *info,\n\t\t\t\tint sig, const struct cred *cred)\n{\n\tu32 secid;\n\tu32 perm;\n\n\tif (!sig)\n\t\tperm = PROCESS__SIGNULL; /* null signal; existence test */\n\telse\n\t\tperm = signal_to_av(sig);\n\tif (!cred)\n\t\tsecid = current_sid();\n\telse\n\t\tsecid = cred_sid(cred);\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    secid, task_sid(p), SECCLASS_PROCESS, perm, NULL);\n}\n\nstatic void selinux_task_to_inode(struct task_struct *p,\n\t\t\t\t  struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = task_sid(p);\n\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}\n\n/* Returns error only if unable to parse addresses */\nstatic int selinux_parse_skb_ipv4(struct sk_buff *skb,\n\t\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tint offset, ihlen, ret = -EINVAL;\n\tstruct iphdr _iph, *ih;\n\n\toffset = skb_network_offset(skb);\n\tih = skb_header_pointer(skb, offset, sizeof(_iph), &_iph);\n\tif (ih == NULL)\n\t\tgoto out;\n\n\tihlen = ih->ihl * 4;\n\tif (ihlen < sizeof(_iph))\n\t\tgoto out;\n\n\tad->u.net->v4info.saddr = ih->saddr;\n\tad->u.net->v4info.daddr = ih->daddr;\n\tret = 0;\n\n\tif (proto)\n\t\t*proto = ih->protocol;\n\n\tswitch (ih->protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr _dccph, *dh;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\n#if IS_ENABLED(CONFIG_IP_SCTP)\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sctph, *sh;\n\n\t\tif (ntohs(ih->frag_off) & IP_OFFSET)\n\t\t\tbreak;\n\n\t\toffset += ihlen;\n\t\tsh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n/* Returns error only if unable to parse addresses */\nstatic int selinux_parse_skb_ipv6(struct sk_buff *skb,\n\t\t\tstruct common_audit_data *ad, u8 *proto)\n{\n\tu8 nexthdr;\n\tint ret = -EINVAL, offset;\n\tstruct ipv6hdr _ipv6h, *ip6;\n\t__be16 frag_off;\n\n\toffset = skb_network_offset(skb);\n\tip6 = skb_header_pointer(skb, offset, sizeof(_ipv6h), &_ipv6h);\n\tif (ip6 == NULL)\n\t\tgoto out;\n\n\tad->u.net->v6info.saddr = ip6->saddr;\n\tad->u.net->v6info.daddr = ip6->daddr;\n\tret = 0;\n\n\tnexthdr = ip6->nexthdr;\n\toffset += sizeof(_ipv6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\tif (offset < 0)\n\t\tgoto out;\n\n\tif (proto)\n\t\t*proto = nexthdr;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _tcph, *th;\n\n\t\tth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\n\t\tif (th == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = th->source;\n\t\tad->u.net->dport = th->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_UDP: {\n\t\tstruct udphdr _udph, *uh;\n\n\t\tuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\n\t\tif (uh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = uh->source;\n\t\tad->u.net->dport = uh->dest;\n\t\tbreak;\n\t}\n\n\tcase IPPROTO_DCCP: {\n\t\tstruct dccp_hdr _dccph, *dh;\n\n\t\tdh = skb_header_pointer(skb, offset, sizeof(_dccph), &_dccph);\n\t\tif (dh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = dh->dccph_sport;\n\t\tad->u.net->dport = dh->dccph_dport;\n\t\tbreak;\n\t}\n\n#if IS_ENABLED(CONFIG_IP_SCTP)\n\tcase IPPROTO_SCTP: {\n\t\tstruct sctphdr _sctph, *sh;\n\n\t\tsh = skb_header_pointer(skb, offset, sizeof(_sctph), &_sctph);\n\t\tif (sh == NULL)\n\t\t\tbreak;\n\n\t\tad->u.net->sport = sh->source;\n\t\tad->u.net->dport = sh->dest;\n\t\tbreak;\n\t}\n#endif\n\t/* includes fragments */\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n#endif /* IPV6 */\n\nstatic int selinux_parse_skb(struct sk_buff *skb, struct common_audit_data *ad,\n\t\t\t     char **_addrp, int src, u8 *proto)\n{\n\tchar *addrp;\n\tint ret;\n\n\tswitch (ad->u.net->family) {\n\tcase PF_INET:\n\t\tret = selinux_parse_skb_ipv4(skb, ad, proto);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t\taddrp = (char *)(src ? &ad->u.net->v4info.saddr :\n\t\t\t\t       &ad->u.net->v4info.daddr);\n\t\tgoto okay;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\tret = selinux_parse_skb_ipv6(skb, ad, proto);\n\t\tif (ret)\n\t\t\tgoto parse_error;\n\t\taddrp = (char *)(src ? &ad->u.net->v6info.saddr :\n\t\t\t\t       &ad->u.net->v6info.daddr);\n\t\tgoto okay;\n#endif\t/* IPV6 */\n\tdefault:\n\t\taddrp = NULL;\n\t\tgoto okay;\n\t}\n\nparse_error:\n\tpr_warn(\n\t       \"SELinux: failure in selinux_parse_skb(),\"\n\t       \" unable to parse packet\\n\");\n\treturn ret;\n\nokay:\n\tif (_addrp)\n\t\t*_addrp = addrp;\n\treturn 0;\n}\n\n/**\n * selinux_skb_peerlbl_sid - Determine the peer label of a packet\n * @skb: the packet\n * @family: protocol family\n * @sid: the packet's peer label SID\n *\n * Description:\n * Check the various different forms of network peer labeling and determine\n * the peer label/SID for the packet; most of the magic actually occurs in\n * the security server function security_net_peersid_cmp().  The function\n * returns zero if the value in @sid is valid (although it may be SECSID_NULL)\n * or -EACCES if @sid is invalid due to inconsistencies with the different\n * peer labels.\n *\n */\nstatic int selinux_skb_peerlbl_sid(struct sk_buff *skb, u16 family, u32 *sid)\n{\n\tint err;\n\tu32 xfrm_sid;\n\tu32 nlbl_sid;\n\tu32 nlbl_type;\n\n\terr = selinux_xfrm_skb_sid(skb, &xfrm_sid);\n\tif (unlikely(err))\n\t\treturn -EACCES;\n\terr = selinux_netlbl_skbuff_getsid(skb, family, &nlbl_type, &nlbl_sid);\n\tif (unlikely(err))\n\t\treturn -EACCES;\n\n\terr = security_net_peersid_resolve(&selinux_state, nlbl_sid,\n\t\t\t\t\t   nlbl_type, xfrm_sid, sid);\n\tif (unlikely(err)) {\n\t\tpr_warn(\n\t\t       \"SELinux: failure in selinux_skb_peerlbl_sid(),\"\n\t\t       \" unable to determine packet's peer label\\n\");\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\n/**\n * selinux_conn_sid - Determine the child socket label for a connection\n * @sk_sid: the parent socket's SID\n * @skb_sid: the packet's SID\n * @conn_sid: the resulting connection SID\n *\n * If @skb_sid is valid then the user:role:type information from @sk_sid is\n * combined with the MLS information from @skb_sid in order to create\n * @conn_sid.  If @skb_sid is not valid then @conn_sid is simply a copy\n * of @sk_sid.  Returns zero on success, negative values on failure.\n *\n */\nstatic int selinux_conn_sid(u32 sk_sid, u32 skb_sid, u32 *conn_sid)\n{\n\tint err = 0;\n\n\tif (skb_sid != SECSID_NULL)\n\t\terr = security_sid_mls_copy(&selinux_state, sk_sid, skb_sid,\n\t\t\t\t\t    conn_sid);\n\telse\n\t\t*conn_sid = sk_sid;\n\n\treturn err;\n}\n\n/* socket security operations */\n\nstatic int socket_sockcreate_sid(const struct task_security_struct *tsec,\n\t\t\t\t u16 secclass, u32 *socksid)\n{\n\tif (tsec->sockcreate_sid > SECSID_NULL) {\n\t\t*socksid = tsec->sockcreate_sid;\n\t\treturn 0;\n\t}\n\n\treturn security_transition_sid(&selinux_state, tsec->sid, tsec->sid,\n\t\t\t\t       secclass, NULL, socksid);\n}\n\nstatic int sock_has_perm(struct sock *sk, u32 perms)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\n\tif (sksec->sid == SECINITSID_KERNEL)\n\t\treturn 0;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->sk = sk;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), sksec->sid, sksec->sclass, perms,\n\t\t\t    &ad);\n}\n\nstatic int selinux_socket_create(int family, int type,\n\t\t\t\t int protocol, int kern)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tu32 newsid;\n\tu16 secclass;\n\tint rc;\n\n\tif (kern)\n\t\treturn 0;\n\n\tsecclass = socket_type_to_security_class(family, type, protocol);\n\trc = socket_sockcreate_sid(tsec, secclass, &newsid);\n\tif (rc)\n\t\treturn rc;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    tsec->sid, newsid, secclass, SOCKET__CREATE, NULL);\n}\n\nstatic int selinux_socket_post_create(struct socket *sock, int family,\n\t\t\t\t      int type, int protocol, int kern)\n{\n\tconst struct task_security_struct *tsec = selinux_cred(current_cred());\n\tstruct inode_security_struct *isec = inode_security_novalidate(SOCK_INODE(sock));\n\tstruct sk_security_struct *sksec;\n\tu16 sclass = socket_type_to_security_class(family, type, protocol);\n\tu32 sid = SECINITSID_KERNEL;\n\tint err = 0;\n\n\tif (!kern) {\n\t\terr = socket_sockcreate_sid(tsec, sclass, &sid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tisec->sclass = sclass;\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\n\tif (sock->sk) {\n\t\tsksec = sock->sk->sk_security;\n\t\tsksec->sclass = sclass;\n\t\tsksec->sid = sid;\n\t\t/* Allows detection of the first association on this socket */\n\t\tif (sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\t\tsksec->sctp_assoc_state = SCTP_ASSOC_UNSET;\n\n\t\terr = selinux_netlbl_socket_post_create(sock->sk, family);\n\t}\n\n\treturn err;\n}\n\nstatic int selinux_socket_socketpair(struct socket *socka,\n\t\t\t\t     struct socket *sockb)\n{\n\tstruct sk_security_struct *sksec_a = socka->sk->sk_security;\n\tstruct sk_security_struct *sksec_b = sockb->sk->sk_security;\n\n\tsksec_a->peer_sid = sksec_b->sid;\n\tsksec_b->peer_sid = sksec_a->sid;\n\n\treturn 0;\n}\n\n/* Range of port numbers used to automatically bind.\n   Need to determine whether we should perform a name_bind\n   permission check between the socket and the port number. */\n\nstatic int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 family;\n\tint err;\n\n\terr = sock_has_perm(sk, SOCKET__BIND);\n\tif (err)\n\t\tgoto out;\n\n\t/* If PF_INET or PF_INET6, check name_bind permission for the port. */\n\tfamily = sk->sk_family;\n\tif (family == PF_INET || family == PF_INET6) {\n\t\tchar *addrp;\n\t\tstruct common_audit_data ad;\n\t\tstruct lsm_network_audit net = {0,};\n\t\tstruct sockaddr_in *addr4 = NULL;\n\t\tstruct sockaddr_in6 *addr6 = NULL;\n\t\tu16 family_sa;\n\t\tunsigned short snum;\n\t\tu32 sid, node_perm;\n\n\t\t/*\n\t\t * sctp_bindx(3) calls via selinux_sctp_bind_connect()\n\t\t * that validates multiple binding addresses. Because of this\n\t\t * need to check address->sa_family as it is possible to have\n\t\t * sk->sk_family = PF_INET6 with addr->sa_family = AF_INET.\n\t\t */\n\t\tif (addrlen < offsetofend(struct sockaddr, sa_family))\n\t\t\treturn -EINVAL;\n\t\tfamily_sa = address->sa_family;\n\t\tswitch (family_sa) {\n\t\tcase AF_UNSPEC:\n\t\tcase AF_INET:\n\t\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\t\treturn -EINVAL;\n\t\t\taddr4 = (struct sockaddr_in *)address;\n\t\t\tif (family_sa == AF_UNSPEC) {\n\t\t\t\t/* see __inet_bind(), we only want to allow\n\t\t\t\t * AF_UNSPEC if the address is INADDR_ANY\n\t\t\t\t */\n\t\t\t\tif (addr4->sin_addr.s_addr != htonl(INADDR_ANY))\n\t\t\t\t\tgoto err_af;\n\t\t\t\tfamily_sa = AF_INET;\n\t\t\t}\n\t\t\tsnum = ntohs(addr4->sin_port);\n\t\t\taddrp = (char *)&addr4->sin_addr.s_addr;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tif (addrlen < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\taddr6 = (struct sockaddr_in6 *)address;\n\t\t\tsnum = ntohs(addr6->sin6_port);\n\t\t\taddrp = (char *)&addr6->sin6_addr.s6_addr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_af;\n\t\t}\n\n\t\tad.type = LSM_AUDIT_DATA_NET;\n\t\tad.u.net = &net;\n\t\tad.u.net->sport = htons(snum);\n\t\tad.u.net->family = family_sa;\n\n\t\tif (snum) {\n\t\t\tint low, high;\n\n\t\t\tinet_get_local_port_range(sock_net(sk), &low, &high);\n\n\t\t\tif (inet_port_requires_bind_service(sock_net(sk), snum) ||\n\t\t\t    snum < low || snum > high) {\n\t\t\t\terr = sel_netport_sid(sk->sk_protocol,\n\t\t\t\t\t\t      snum, &sid);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t\t\t   sksec->sid, sid,\n\t\t\t\t\t\t   sksec->sclass,\n\t\t\t\t\t\t   SOCKET__NAME_BIND, &ad);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tswitch (sksec->sclass) {\n\t\tcase SECCLASS_TCP_SOCKET:\n\t\t\tnode_perm = TCP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tcase SECCLASS_UDP_SOCKET:\n\t\t\tnode_perm = UDP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tcase SECCLASS_DCCP_SOCKET:\n\t\t\tnode_perm = DCCP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tcase SECCLASS_SCTP_SOCKET:\n\t\t\tnode_perm = SCTP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnode_perm = RAWIP_SOCKET__NODE_BIND;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = sel_netnode_sid(addrp, family_sa, &sid);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (family_sa == AF_INET)\n\t\t\tad.u.net->v4info.saddr = addr4->sin_addr.s_addr;\n\t\telse\n\t\t\tad.u.net->v6info.saddr = addr6->sin6_addr;\n\n\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t   sksec->sid, sid,\n\t\t\t\t   sksec->sclass, node_perm, &ad);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\nerr_af:\n\t/* Note that SCTP services expect -EINVAL, others -EAFNOSUPPORT. */\n\tif (sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\treturn -EINVAL;\n\treturn -EAFNOSUPPORT;\n}\n\n/* This supports connect(2) and SCTP connect services such as sctp_connectx(3)\n * and sctp_sendmsg(3) as described in Documentation/security/SCTP.rst\n */\nstatic int selinux_socket_connect_helper(struct socket *sock,\n\t\t\t\t\t struct sockaddr *address, int addrlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tint err;\n\n\terr = sock_has_perm(sk, SOCKET__CONNECT);\n\tif (err)\n\t\treturn err;\n\tif (addrlen < offsetofend(struct sockaddr, sa_family))\n\t\treturn -EINVAL;\n\n\t/* connect(AF_UNSPEC) has special handling, as it is a documented\n\t * way to disconnect the socket\n\t */\n\tif (address->sa_family == AF_UNSPEC)\n\t\treturn 0;\n\n\t/*\n\t * If a TCP, DCCP or SCTP socket, check name_connect permission\n\t * for the port.\n\t */\n\tif (sksec->sclass == SECCLASS_TCP_SOCKET ||\n\t    sksec->sclass == SECCLASS_DCCP_SOCKET ||\n\t    sksec->sclass == SECCLASS_SCTP_SOCKET) {\n\t\tstruct common_audit_data ad;\n\t\tstruct lsm_network_audit net = {0,};\n\t\tstruct sockaddr_in *addr4 = NULL;\n\t\tstruct sockaddr_in6 *addr6 = NULL;\n\t\tunsigned short snum;\n\t\tu32 sid, perm;\n\n\t\t/* sctp_connectx(3) calls via selinux_sctp_bind_connect()\n\t\t * that validates multiple connect addresses. Because of this\n\t\t * need to check address->sa_family as it is possible to have\n\t\t * sk->sk_family = PF_INET6 with addr->sa_family = AF_INET.\n\t\t */\n\t\tswitch (address->sa_family) {\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *)address;\n\t\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\t\treturn -EINVAL;\n\t\t\tsnum = ntohs(addr4->sin_port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *)address;\n\t\t\tif (addrlen < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tsnum = ntohs(addr6->sin6_port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Note that SCTP services expect -EINVAL, whereas\n\t\t\t * others expect -EAFNOSUPPORT.\n\t\t\t */\n\t\t\tif (sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\t\t\treturn -EINVAL;\n\t\t\telse\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\terr = sel_netport_sid(sk->sk_protocol, snum, &sid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tswitch (sksec->sclass) {\n\t\tcase SECCLASS_TCP_SOCKET:\n\t\t\tperm = TCP_SOCKET__NAME_CONNECT;\n\t\t\tbreak;\n\t\tcase SECCLASS_DCCP_SOCKET:\n\t\t\tperm = DCCP_SOCKET__NAME_CONNECT;\n\t\t\tbreak;\n\t\tcase SECCLASS_SCTP_SOCKET:\n\t\t\tperm = SCTP_SOCKET__NAME_CONNECT;\n\t\t\tbreak;\n\t\t}\n\n\t\tad.type = LSM_AUDIT_DATA_NET;\n\t\tad.u.net = &net;\n\t\tad.u.net->dport = htons(snum);\n\t\tad.u.net->family = address->sa_family;\n\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t   sksec->sid, sid, sksec->sclass, perm, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n/* Supports connect(2), see comments in selinux_socket_connect_helper() */\nstatic int selinux_socket_connect(struct socket *sock,\n\t\t\t\t  struct sockaddr *address, int addrlen)\n{\n\tint err;\n\tstruct sock *sk = sock->sk;\n\n\terr = selinux_socket_connect_helper(sock, address, addrlen);\n\tif (err)\n\t\treturn err;\n\n\treturn selinux_netlbl_socket_connect(sk, address);\n}\n\nstatic int selinux_socket_listen(struct socket *sock, int backlog)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__LISTEN);\n}\n\nstatic int selinux_socket_accept(struct socket *sock, struct socket *newsock)\n{\n\tint err;\n\tstruct inode_security_struct *isec;\n\tstruct inode_security_struct *newisec;\n\tu16 sclass;\n\tu32 sid;\n\n\terr = sock_has_perm(sock->sk, SOCKET__ACCEPT);\n\tif (err)\n\t\treturn err;\n\n\tisec = inode_security_novalidate(SOCK_INODE(sock));\n\tspin_lock(&isec->lock);\n\tsclass = isec->sclass;\n\tsid = isec->sid;\n\tspin_unlock(&isec->lock);\n\n\tnewisec = inode_security_novalidate(SOCK_INODE(newsock));\n\tnewisec->sclass = sclass;\n\tnewisec->sid = sid;\n\tnewisec->initialized = LABEL_INITIALIZED;\n\n\treturn 0;\n}\n\nstatic int selinux_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  int size)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__WRITE);\n}\n\nstatic int selinux_socket_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  int size, int flags)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__READ);\n}\n\nstatic int selinux_socket_getsockname(struct socket *sock)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__GETATTR);\n}\n\nstatic int selinux_socket_getpeername(struct socket *sock)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__GETATTR);\n}\n\nstatic int selinux_socket_setsockopt(struct socket *sock, int level, int optname)\n{\n\tint err;\n\n\terr = sock_has_perm(sock->sk, SOCKET__SETOPT);\n\tif (err)\n\t\treturn err;\n\n\treturn selinux_netlbl_socket_setsockopt(sock, level, optname);\n}\n\nstatic int selinux_socket_getsockopt(struct socket *sock, int level,\n\t\t\t\t     int optname)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__GETOPT);\n}\n\nstatic int selinux_socket_shutdown(struct socket *sock, int how)\n{\n\treturn sock_has_perm(sock->sk, SOCKET__SHUTDOWN);\n}\n\nstatic int selinux_socket_unix_stream_connect(struct sock *sock,\n\t\t\t\t\t      struct sock *other,\n\t\t\t\t\t      struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec_sock = sock->sk_security;\n\tstruct sk_security_struct *sksec_other = other->sk_security;\n\tstruct sk_security_struct *sksec_new = newsk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tint err;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->sk = other;\n\n\terr = avc_has_perm(&selinux_state,\n\t\t\t   sksec_sock->sid, sksec_other->sid,\n\t\t\t   sksec_other->sclass,\n\t\t\t   UNIX_STREAM_SOCKET__CONNECTTO, &ad);\n\tif (err)\n\t\treturn err;\n\n\t/* server child socket */\n\tsksec_new->peer_sid = sksec_sock->sid;\n\terr = security_sid_mls_copy(&selinux_state, sksec_other->sid,\n\t\t\t\t    sksec_sock->sid, &sksec_new->sid);\n\tif (err)\n\t\treturn err;\n\n\t/* connecting socket */\n\tsksec_sock->peer_sid = sksec_new->sid;\n\n\treturn 0;\n}\n\nstatic int selinux_socket_unix_may_send(struct socket *sock,\n\t\t\t\t\tstruct socket *other)\n{\n\tstruct sk_security_struct *ssec = sock->sk->sk_security;\n\tstruct sk_security_struct *osec = other->sk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->sk = other->sk;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    ssec->sid, osec->sid, osec->sclass, SOCKET__SENDTO,\n\t\t\t    &ad);\n}\n\nstatic int selinux_inet_sys_rcv_skb(struct net *ns, int ifindex,\n\t\t\t\t    char *addrp, u16 family, u32 peer_sid,\n\t\t\t\t    struct common_audit_data *ad)\n{\n\tint err;\n\tu32 if_sid;\n\tu32 node_sid;\n\n\terr = sel_netif_sid(ns, ifindex, &if_sid);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(&selinux_state,\n\t\t\t   peer_sid, if_sid,\n\t\t\t   SECCLASS_NETIF, NETIF__INGRESS, ad);\n\tif (err)\n\t\treturn err;\n\n\terr = sel_netnode_sid(addrp, family, &node_sid);\n\tif (err)\n\t\treturn err;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    peer_sid, node_sid,\n\t\t\t    SECCLASS_NODE, NODE__RECVFROM, ad);\n}\n\nstatic int selinux_sock_rcv_skb_compat(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       u16 family)\n{\n\tint err = 0;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu32 sk_sid = sksec->sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tchar *addrp;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->netif = skb->skb_iif;\n\tad.u.net->family = family;\n\terr = selinux_parse_skb(skb, &ad, &addrp, 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (selinux_secmark_enabled()) {\n\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t   sk_sid, skb->secmark, SECCLASS_PACKET,\n\t\t\t\t   PACKET__RECV, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = selinux_netlbl_sock_rcv_skb(sksec, skb, family, &ad);\n\tif (err)\n\t\treturn err;\n\terr = selinux_xfrm_sock_rcv_skb(sksec->sid, skb, &ad);\n\n\treturn err;\n}\n\nstatic int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 family = sk->sk_family;\n\tu32 sk_sid = sksec->sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tchar *addrp;\n\tu8 secmark_active;\n\tu8 peerlbl_active;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\t/* Handle mapped IPv4 packets arriving via IPv6 sockets */\n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\n\t/* If any sort of compatibility mode is enabled then handoff processing\n\t * to the selinux_sock_rcv_skb_compat() function to deal with the\n\t * special handling.  We do this in an attempt to keep this function\n\t * as fast and as clean as possible. */\n\tif (!selinux_policycap_netpeer())\n\t\treturn selinux_sock_rcv_skb_compat(sk, skb, family);\n\n\tsecmark_active = selinux_secmark_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn 0;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->netif = skb->skb_iif;\n\tad.u.net->family = family;\n\terr = selinux_parse_skb(skb, &ad, &addrp, 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (peerlbl_active) {\n\t\tu32 peer_sid;\n\n\t\terr = selinux_skb_peerlbl_sid(skb, family, &peer_sid);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = selinux_inet_sys_rcv_skb(sock_net(sk), skb->skb_iif,\n\t\t\t\t\t       addrp, family, peer_sid, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 0);\n\t\t\treturn err;\n\t\t}\n\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t   sk_sid, peer_sid, SECCLASS_PEER,\n\t\t\t\t   PEER__RECV, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (secmark_active) {\n\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t   sk_sid, skb->secmark, SECCLASS_PACKET,\n\t\t\t\t   PACKET__RECV, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int selinux_socket_getpeersec_stream(struct socket *sock, char __user *optval,\n\t\t\t\t\t    int __user *optlen, unsigned len)\n{\n\tint err = 0;\n\tchar *scontext;\n\tu32 scontext_len;\n\tstruct sk_security_struct *sksec = sock->sk->sk_security;\n\tu32 peer_sid = SECSID_NULL;\n\n\tif (sksec->sclass == SECCLASS_UNIX_STREAM_SOCKET ||\n\t    sksec->sclass == SECCLASS_TCP_SOCKET ||\n\t    sksec->sclass == SECCLASS_SCTP_SOCKET)\n\t\tpeer_sid = sksec->peer_sid;\n\tif (peer_sid == SECSID_NULL)\n\t\treturn -ENOPROTOOPT;\n\n\terr = security_sid_to_context(&selinux_state, peer_sid, &scontext,\n\t\t\t\t      &scontext_len);\n\tif (err)\n\t\treturn err;\n\n\tif (scontext_len > len) {\n\t\terr = -ERANGE;\n\t\tgoto out_len;\n\t}\n\n\tif (copy_to_user(optval, scontext, scontext_len))\n\t\terr = -EFAULT;\n\nout_len:\n\tif (put_user(scontext_len, optlen))\n\t\terr = -EFAULT;\n\tkfree(scontext);\n\treturn err;\n}\n\nstatic int selinux_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)\n{\n\tu32 peer_secid = SECSID_NULL;\n\tu16 family;\n\tstruct inode_security_struct *isec;\n\n\tif (skb && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\telse if (skb && skb->protocol == htons(ETH_P_IPV6))\n\t\tfamily = PF_INET6;\n\telse if (sock)\n\t\tfamily = sock->sk->sk_family;\n\telse\n\t\tgoto out;\n\n\tif (sock && family == PF_UNIX) {\n\t\tisec = inode_security_novalidate(SOCK_INODE(sock));\n\t\tpeer_secid = isec->sid;\n\t} else if (skb)\n\t\tselinux_skb_peerlbl_sid(skb, family, &peer_secid);\n\nout:\n\t*secid = peer_secid;\n\tif (peer_secid == SECSID_NULL)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int selinux_sk_alloc_security(struct sock *sk, int family, gfp_t priority)\n{\n\tstruct sk_security_struct *sksec;\n\n\tsksec = kzalloc(sizeof(*sksec), priority);\n\tif (!sksec)\n\t\treturn -ENOMEM;\n\n\tsksec->peer_sid = SECINITSID_UNLABELED;\n\tsksec->sid = SECINITSID_UNLABELED;\n\tsksec->sclass = SECCLASS_SOCKET;\n\tselinux_netlbl_sk_security_reset(sksec);\n\tsk->sk_security = sksec;\n\n\treturn 0;\n}\n\nstatic void selinux_sk_free_security(struct sock *sk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tsk->sk_security = NULL;\n\tselinux_netlbl_sk_security_free(sksec);\n\tkfree(sksec);\n}\n\nstatic void selinux_sk_clone_security(const struct sock *sk, struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\tnewsksec->sid = sksec->sid;\n\tnewsksec->peer_sid = sksec->peer_sid;\n\tnewsksec->sclass = sksec->sclass;\n\n\tselinux_netlbl_sk_security_reset(newsksec);\n}\n\nstatic void selinux_sk_getsecid(struct sock *sk, u32 *secid)\n{\n\tif (!sk)\n\t\t*secid = SECINITSID_ANY_SOCKET;\n\telse {\n\t\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\t\t*secid = sksec->sid;\n\t}\n}\n\nstatic void selinux_sock_graft(struct sock *sk, struct socket *parent)\n{\n\tstruct inode_security_struct *isec =\n\t\tinode_security_novalidate(SOCK_INODE(parent));\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (sk->sk_family == PF_INET || sk->sk_family == PF_INET6 ||\n\t    sk->sk_family == PF_UNIX)\n\t\tisec->sid = sksec->sid;\n\tsksec->sclass = isec->sclass;\n}\n\n/* Called whenever SCTP receives an INIT chunk. This happens when an incoming\n * connect(2), sctp_connectx(3) or sctp_sendmsg(3) (with no association\n * already present).\n */\nstatic int selinux_sctp_assoc_request(struct sctp_endpoint *ep,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct sk_security_struct *sksec = ep->base.sk->sk_security;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tu8 peerlbl_active;\n\tu32 peer_sid = SECINITSID_UNLABELED;\n\tu32 conn_sid;\n\tint err = 0;\n\n\tif (!selinux_policycap_extsockclass())\n\t\treturn 0;\n\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\n\tif (peerlbl_active) {\n\t\t/* This will return peer_sid = SECSID_NULL if there are\n\t\t * no peer labels, see security_net_peersid_resolve().\n\t\t */\n\t\terr = selinux_skb_peerlbl_sid(skb, ep->base.sk->sk_family,\n\t\t\t\t\t      &peer_sid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (peer_sid == SECSID_NULL)\n\t\t\tpeer_sid = SECINITSID_UNLABELED;\n\t}\n\n\tif (sksec->sctp_assoc_state == SCTP_ASSOC_UNSET) {\n\t\tsksec->sctp_assoc_state = SCTP_ASSOC_SET;\n\n\t\t/* Here as first association on socket. As the peer SID\n\t\t * was allowed by peer recv (and the netif/node checks),\n\t\t * then it is approved by policy and used as the primary\n\t\t * peer SID for getpeercon(3).\n\t\t */\n\t\tsksec->peer_sid = peer_sid;\n\t} else if  (sksec->peer_sid != peer_sid) {\n\t\t/* Other association peer SIDs are checked to enforce\n\t\t * consistency among the peer SIDs.\n\t\t */\n\t\tad.type = LSM_AUDIT_DATA_NET;\n\t\tad.u.net = &net;\n\t\tad.u.net->sk = ep->base.sk;\n\t\terr = avc_has_perm(&selinux_state,\n\t\t\t\t   sksec->peer_sid, peer_sid, sksec->sclass,\n\t\t\t\t   SCTP_SOCKET__ASSOCIATION, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Compute the MLS component for the connection and store\n\t * the information in ep. This will be used by SCTP TCP type\n\t * sockets and peeled off connections as they cause a new\n\t * socket to be generated. selinux_sctp_sk_clone() will then\n\t * plug this into the new socket.\n\t */\n\terr = selinux_conn_sid(sksec->sid, peer_sid, &conn_sid);\n\tif (err)\n\t\treturn err;\n\n\tep->secid = conn_sid;\n\tep->peer_secid = peer_sid;\n\n\t/* Set any NetLabel labels including CIPSO/CALIPSO options. */\n\treturn selinux_netlbl_sctp_assoc_request(ep, skb);\n}\n\n/* Check if sctp IPv4/IPv6 addresses are valid for binding or connecting\n * based on their @optname.\n */\nstatic int selinux_sctp_bind_connect(struct sock *sk, int optname,\n\t\t\t\t     struct sockaddr *address,\n\t\t\t\t     int addrlen)\n{\n\tint len, err = 0, walk_size = 0;\n\tvoid *addr_buf;\n\tstruct sockaddr *addr;\n\tstruct socket *sock;\n\n\tif (!selinux_policycap_extsockclass())\n\t\treturn 0;\n\n\t/* Process one or more addresses that may be IPv4 or IPv6 */\n\tsock = sk->sk_socket;\n\taddr_buf = address;\n\n\twhile (walk_size < addrlen) {\n\t\tif (walk_size + sizeof(sa_family_t) > addrlen)\n\t\t\treturn -EINVAL;\n\n\t\taddr = addr_buf;\n\t\tswitch (addr->sa_family) {\n\t\tcase AF_UNSPEC:\n\t\tcase AF_INET:\n\t\t\tlen = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tlen = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (walk_size + len > addrlen)\n\t\t\treturn -EINVAL;\n\n\t\terr = -EINVAL;\n\t\tswitch (optname) {\n\t\t/* Bind checks */\n\t\tcase SCTP_PRIMARY_ADDR:\n\t\tcase SCTP_SET_PEER_PRIMARY_ADDR:\n\t\tcase SCTP_SOCKOPT_BINDX_ADD:\n\t\t\terr = selinux_socket_bind(sock, addr, len);\n\t\t\tbreak;\n\t\t/* Connect checks */\n\t\tcase SCTP_SOCKOPT_CONNECTX:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_SENDMSG_CONNECT:\n\t\t\terr = selinux_socket_connect_helper(sock, addr, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\t/* As selinux_sctp_bind_connect() is called by the\n\t\t\t * SCTP protocol layer, the socket is already locked,\n\t\t\t * therefore selinux_netlbl_socket_connect_locked()\n\t\t\t * is called here. The situations handled are:\n\t\t\t * sctp_connectx(3), sctp_sendmsg(3), sendmsg(2),\n\t\t\t * whenever a new IP address is added or when a new\n\t\t\t * primary address is selected.\n\t\t\t * Note that an SCTP connect(2) call happens before\n\t\t\t * the SCTP protocol layer and is handled via\n\t\t\t * selinux_socket_connect().\n\t\t\t */\n\t\t\terr = selinux_netlbl_socket_connect_locked(sk, addr);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\taddr_buf += len;\n\t\twalk_size += len;\n\t}\n\n\treturn 0;\n}\n\n/* Called whenever a new socket is created by accept(2) or sctp_peeloff(3). */\nstatic void selinux_sctp_sk_clone(struct sctp_endpoint *ep, struct sock *sk,\n\t\t\t\t  struct sock *newsk)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\t/* If policy does not support SECCLASS_SCTP_SOCKET then call\n\t * the non-sctp clone version.\n\t */\n\tif (!selinux_policycap_extsockclass())\n\t\treturn selinux_sk_clone_security(sk, newsk);\n\n\tnewsksec->sid = ep->secid;\n\tnewsksec->peer_sid = ep->peer_secid;\n\tnewsksec->sclass = sksec->sclass;\n\tselinux_netlbl_sctp_sk_clone(sk, newsk);\n}\n\nstatic int selinux_inet_conn_request(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t     struct request_sock *req)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tint err;\n\tu16 family = req->rsk_ops->family;\n\tu32 connsid;\n\tu32 peersid;\n\n\terr = selinux_skb_peerlbl_sid(skb, family, &peersid);\n\tif (err)\n\t\treturn err;\n\terr = selinux_conn_sid(sksec->sid, peersid, &connsid);\n\tif (err)\n\t\treturn err;\n\treq->secid = connsid;\n\treq->peer_secid = peersid;\n\n\treturn selinux_netlbl_inet_conn_request(req, family);\n}\n\nstatic void selinux_inet_csk_clone(struct sock *newsk,\n\t\t\t\t   const struct request_sock *req)\n{\n\tstruct sk_security_struct *newsksec = newsk->sk_security;\n\n\tnewsksec->sid = req->secid;\n\tnewsksec->peer_sid = req->peer_secid;\n\t/* NOTE: Ideally, we should also get the isec->sid for the\n\t   new socket in sync, but we don't have the isec available yet.\n\t   So we will wait until sock_graft to do it, by which\n\t   time it will have been created and available. */\n\n\t/* We don't need to take any sort of lock here as we are the only\n\t * thread with access to newsksec */\n\tselinux_netlbl_inet_csk_clone(newsk, req->rsk_ops->family);\n}\n\nstatic void selinux_inet_conn_established(struct sock *sk, struct sk_buff *skb)\n{\n\tu16 family = sk->sk_family;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\t/* handle mapped IPv4 packets arriving via IPv6 sockets */\n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\n\tselinux_skb_peerlbl_sid(skb, family, &sksec->peer_sid);\n}\n\nstatic int selinux_secmark_relabel_packet(u32 sid)\n{\n\tconst struct task_security_struct *__tsec;\n\tu32 tsid;\n\n\t__tsec = selinux_cred(current_cred());\n\ttsid = __tsec->sid;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    tsid, sid, SECCLASS_PACKET, PACKET__RELABELTO,\n\t\t\t    NULL);\n}\n\nstatic void selinux_secmark_refcount_inc(void)\n{\n\tatomic_inc(&selinux_secmark_refcount);\n}\n\nstatic void selinux_secmark_refcount_dec(void)\n{\n\tatomic_dec(&selinux_secmark_refcount);\n}\n\nstatic void selinux_req_classify_flow(const struct request_sock *req,\n\t\t\t\t      struct flowi *fl)\n{\n\tfl->flowi_secid = req->secid;\n}\n\nstatic int selinux_tun_dev_alloc_security(void **security)\n{\n\tstruct tun_security_struct *tunsec;\n\n\ttunsec = kzalloc(sizeof(*tunsec), GFP_KERNEL);\n\tif (!tunsec)\n\t\treturn -ENOMEM;\n\ttunsec->sid = current_sid();\n\n\t*security = tunsec;\n\treturn 0;\n}\n\nstatic void selinux_tun_dev_free_security(void *security)\n{\n\tkfree(security);\n}\n\nstatic int selinux_tun_dev_create(void)\n{\n\tu32 sid = current_sid();\n\n\t/* we aren't taking into account the \"sockcreate\" SID since the socket\n\t * that is being created here is not a socket in the traditional sense,\n\t * instead it is a private sock, accessible only to the kernel, and\n\t * representing a wide range of network traffic spanning multiple\n\t * connections unlike traditional sockets - check the TUN driver to\n\t * get a better understanding of why this socket is special */\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, sid, SECCLASS_TUN_SOCKET, TUN_SOCKET__CREATE,\n\t\t\t    NULL);\n}\n\nstatic int selinux_tun_dev_attach_queue(void *security)\n{\n\tstruct tun_security_struct *tunsec = security;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), tunsec->sid, SECCLASS_TUN_SOCKET,\n\t\t\t    TUN_SOCKET__ATTACH_QUEUE, NULL);\n}\n\nstatic int selinux_tun_dev_attach(struct sock *sk, void *security)\n{\n\tstruct tun_security_struct *tunsec = security;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\t/* we don't currently perform any NetLabel based labeling here and it\n\t * isn't clear that we would want to do so anyway; while we could apply\n\t * labeling without the support of the TUN user the resulting labeled\n\t * traffic from the other end of the connection would almost certainly\n\t * cause confusion to the TUN user that had no idea network labeling\n\t * protocols were being used */\n\n\tsksec->sid = tunsec->sid;\n\tsksec->sclass = SECCLASS_TUN_SOCKET;\n\n\treturn 0;\n}\n\nstatic int selinux_tun_dev_open(void *security)\n{\n\tstruct tun_security_struct *tunsec = security;\n\tu32 sid = current_sid();\n\tint err;\n\n\terr = avc_has_perm(&selinux_state,\n\t\t\t   sid, tunsec->sid, SECCLASS_TUN_SOCKET,\n\t\t\t   TUN_SOCKET__RELABELFROM, NULL);\n\tif (err)\n\t\treturn err;\n\terr = avc_has_perm(&selinux_state,\n\t\t\t   sid, sid, SECCLASS_TUN_SOCKET,\n\t\t\t   TUN_SOCKET__RELABELTO, NULL);\n\tif (err)\n\t\treturn err;\n\ttunsec->sid = sid;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_NETFILTER\n\nstatic unsigned int selinux_ip_forward(struct sk_buff *skb,\n\t\t\t\t       const struct net_device *indev,\n\t\t\t\t       u16 family)\n{\n\tint err;\n\tchar *addrp;\n\tu32 peer_sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tu8 secmark_active;\n\tu8 netlbl_active;\n\tu8 peerlbl_active;\n\n\tif (!selinux_policycap_netpeer())\n\t\treturn NF_ACCEPT;\n\n\tsecmark_active = selinux_secmark_enabled();\n\tnetlbl_active = netlbl_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn NF_ACCEPT;\n\n\tif (selinux_skb_peerlbl_sid(skb, family, &peer_sid) != 0)\n\t\treturn NF_DROP;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->netif = indev->ifindex;\n\tad.u.net->family = family;\n\tif (selinux_parse_skb(skb, &ad, &addrp, 1, NULL) != 0)\n\t\treturn NF_DROP;\n\n\tif (peerlbl_active) {\n\t\terr = selinux_inet_sys_rcv_skb(dev_net(indev), indev->ifindex,\n\t\t\t\t\t       addrp, family, peer_sid, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 1);\n\t\t\treturn NF_DROP;\n\t\t}\n\t}\n\n\tif (secmark_active)\n\t\tif (avc_has_perm(&selinux_state,\n\t\t\t\t peer_sid, skb->secmark,\n\t\t\t\t SECCLASS_PACKET, PACKET__FORWARD_IN, &ad))\n\t\t\treturn NF_DROP;\n\n\tif (netlbl_active)\n\t\t/* we do this in the FORWARD path and not the POST_ROUTING\n\t\t * path because we want to make sure we apply the necessary\n\t\t * labeling before IPsec is applied so we can leverage AH\n\t\t * protection */\n\t\tif (selinux_netlbl_skbuff_setsid(skb, family, peer_sid) != 0)\n\t\t\treturn NF_DROP;\n\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int selinux_ipv4_forward(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\treturn selinux_ip_forward(skb, state->in, PF_INET);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic unsigned int selinux_ipv6_forward(void *priv,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t const struct nf_hook_state *state)\n{\n\treturn selinux_ip_forward(skb, state->in, PF_INET6);\n}\n#endif\t/* IPV6 */\n\nstatic unsigned int selinux_ip_output(struct sk_buff *skb,\n\t\t\t\t      u16 family)\n{\n\tstruct sock *sk;\n\tu32 sid;\n\n\tif (!netlbl_enabled())\n\t\treturn NF_ACCEPT;\n\n\t/* we do this in the LOCAL_OUT path and not the POST_ROUTING path\n\t * because we want to make sure we apply the necessary labeling\n\t * before IPsec is applied so we can leverage AH protection */\n\tsk = skb->sk;\n\tif (sk) {\n\t\tstruct sk_security_struct *sksec;\n\n\t\tif (sk_listener(sk))\n\t\t\t/* if the socket is the listening state then this\n\t\t\t * packet is a SYN-ACK packet which means it needs to\n\t\t\t * be labeled based on the connection/request_sock and\n\t\t\t * not the parent socket.  unfortunately, we can't\n\t\t\t * lookup the request_sock yet as it isn't queued on\n\t\t\t * the parent socket until after the SYN-ACK is sent.\n\t\t\t * the \"solution\" is to simply pass the packet as-is\n\t\t\t * as any IP option based labeling should be copied\n\t\t\t * from the initial connection request (in the IP\n\t\t\t * layer).  it is far from ideal, but until we get a\n\t\t\t * security label in the packet itself this is the\n\t\t\t * best we can do. */\n\t\t\treturn NF_ACCEPT;\n\n\t\t/* standard practice, label using the parent socket */\n\t\tsksec = sk->sk_security;\n\t\tsid = sksec->sid;\n\t} else\n\t\tsid = SECINITSID_KERNEL;\n\tif (selinux_netlbl_skbuff_setsid(skb, family, sid) != 0)\n\t\treturn NF_DROP;\n\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int selinux_ipv4_output(void *priv,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tconst struct nf_hook_state *state)\n{\n\treturn selinux_ip_output(skb, PF_INET);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic unsigned int selinux_ipv6_output(void *priv,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tconst struct nf_hook_state *state)\n{\n\treturn selinux_ip_output(skb, PF_INET6);\n}\n#endif\t/* IPV6 */\n\nstatic unsigned int selinux_ip_postroute_compat(struct sk_buff *skb,\n\t\t\t\t\t\tint ifindex,\n\t\t\t\t\t\tu16 family)\n{\n\tstruct sock *sk = skb_to_full_sk(skb);\n\tstruct sk_security_struct *sksec;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tchar *addrp;\n\tu8 proto;\n\n\tif (sk == NULL)\n\t\treturn NF_ACCEPT;\n\tsksec = sk->sk_security;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->netif = ifindex;\n\tad.u.net->family = family;\n\tif (selinux_parse_skb(skb, &ad, &addrp, 0, &proto))\n\t\treturn NF_DROP;\n\n\tif (selinux_secmark_enabled())\n\t\tif (avc_has_perm(&selinux_state,\n\t\t\t\t sksec->sid, skb->secmark,\n\t\t\t\t SECCLASS_PACKET, PACKET__SEND, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\tif (selinux_xfrm_postroute_last(sksec->sid, skb, &ad, proto))\n\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int selinux_ip_postroute(struct sk_buff *skb,\n\t\t\t\t\t const struct net_device *outdev,\n\t\t\t\t\t u16 family)\n{\n\tu32 secmark_perm;\n\tu32 peer_sid;\n\tint ifindex = outdev->ifindex;\n\tstruct sock *sk;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tchar *addrp;\n\tu8 secmark_active;\n\tu8 peerlbl_active;\n\n\t/* If any sort of compatibility mode is enabled then handoff processing\n\t * to the selinux_ip_postroute_compat() function to deal with the\n\t * special handling.  We do this in an attempt to keep this function\n\t * as fast and as clean as possible. */\n\tif (!selinux_policycap_netpeer())\n\t\treturn selinux_ip_postroute_compat(skb, ifindex, family);\n\n\tsecmark_active = selinux_secmark_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn NF_ACCEPT;\n\n\tsk = skb_to_full_sk(skb);\n\n#ifdef CONFIG_XFRM\n\t/* If skb->dst->xfrm is non-NULL then the packet is undergoing an IPsec\n\t * packet transformation so allow the packet to pass without any checks\n\t * since we'll have another chance to perform access control checks\n\t * when the packet is on it's final way out.\n\t * NOTE: there appear to be some IPv6 multicast cases where skb->dst\n\t *       is NULL, in this case go ahead and apply access control.\n\t * NOTE: if this is a local socket (skb->sk != NULL) that is in the\n\t *       TCP listening state we cannot wait until the XFRM processing\n\t *       is done as we will miss out on the SA label if we do;\n\t *       unfortunately, this means more work, but it is only once per\n\t *       connection. */\n\tif (skb_dst(skb) != NULL && skb_dst(skb)->xfrm != NULL &&\n\t    !(sk && sk_listener(sk)))\n\t\treturn NF_ACCEPT;\n#endif\n\n\tif (sk == NULL) {\n\t\t/* Without an associated socket the packet is either coming\n\t\t * from the kernel or it is being forwarded; check the packet\n\t\t * to determine which and if the packet is being forwarded\n\t\t * query the packet directly to determine the security label. */\n\t\tif (skb->skb_iif) {\n\t\t\tsecmark_perm = PACKET__FORWARD_OUT;\n\t\t\tif (selinux_skb_peerlbl_sid(skb, family, &peer_sid))\n\t\t\t\treturn NF_DROP;\n\t\t} else {\n\t\t\tsecmark_perm = PACKET__SEND;\n\t\t\tpeer_sid = SECINITSID_KERNEL;\n\t\t}\n\t} else if (sk_listener(sk)) {\n\t\t/* Locally generated packet but the associated socket is in the\n\t\t * listening state which means this is a SYN-ACK packet.  In\n\t\t * this particular case the correct security label is assigned\n\t\t * to the connection/request_sock but unfortunately we can't\n\t\t * query the request_sock as it isn't queued on the parent\n\t\t * socket until after the SYN-ACK packet is sent; the only\n\t\t * viable choice is to regenerate the label like we do in\n\t\t * selinux_inet_conn_request().  See also selinux_ip_output()\n\t\t * for similar problems. */\n\t\tu32 skb_sid;\n\t\tstruct sk_security_struct *sksec;\n\n\t\tsksec = sk->sk_security;\n\t\tif (selinux_skb_peerlbl_sid(skb, family, &skb_sid))\n\t\t\treturn NF_DROP;\n\t\t/* At this point, if the returned skb peerlbl is SECSID_NULL\n\t\t * and the packet has been through at least one XFRM\n\t\t * transformation then we must be dealing with the \"final\"\n\t\t * form of labeled IPsec packet; since we've already applied\n\t\t * all of our access controls on this packet we can safely\n\t\t * pass the packet. */\n\t\tif (skb_sid == SECSID_NULL) {\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED)\n\t\t\t\t\treturn NF_ACCEPT;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (IP6CB(skb)->flags & IP6SKB_XFRM_TRANSFORMED)\n\t\t\t\t\treturn NF_ACCEPT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\t\t\t}\n\t\t}\n\t\tif (selinux_conn_sid(sksec->sid, skb_sid, &peer_sid))\n\t\t\treturn NF_DROP;\n\t\tsecmark_perm = PACKET__SEND;\n\t} else {\n\t\t/* Locally generated packet, fetch the security label from the\n\t\t * associated socket. */\n\t\tstruct sk_security_struct *sksec = sk->sk_security;\n\t\tpeer_sid = sksec->sid;\n\t\tsecmark_perm = PACKET__SEND;\n\t}\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->netif = ifindex;\n\tad.u.net->family = family;\n\tif (selinux_parse_skb(skb, &ad, &addrp, 0, NULL))\n\t\treturn NF_DROP;\n\n\tif (secmark_active)\n\t\tif (avc_has_perm(&selinux_state,\n\t\t\t\t peer_sid, skb->secmark,\n\t\t\t\t SECCLASS_PACKET, secmark_perm, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\tif (peerlbl_active) {\n\t\tu32 if_sid;\n\t\tu32 node_sid;\n\n\t\tif (sel_netif_sid(dev_net(outdev), ifindex, &if_sid))\n\t\t\treturn NF_DROP;\n\t\tif (avc_has_perm(&selinux_state,\n\t\t\t\t peer_sid, if_sid,\n\t\t\t\t SECCLASS_NETIF, NETIF__EGRESS, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\n\t\tif (sel_netnode_sid(addrp, family, &node_sid))\n\t\t\treturn NF_DROP;\n\t\tif (avc_has_perm(&selinux_state,\n\t\t\t\t peer_sid, node_sid,\n\t\t\t\t SECCLASS_NODE, NODE__SENDTO, &ad))\n\t\t\treturn NF_DROP_ERR(-ECONNREFUSED);\n\t}\n\n\treturn NF_ACCEPT;\n}\n\nstatic unsigned int selinux_ipv4_postroute(void *priv,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const struct nf_hook_state *state)\n{\n\treturn selinux_ip_postroute(skb, state->out, PF_INET);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic unsigned int selinux_ipv6_postroute(void *priv,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const struct nf_hook_state *state)\n{\n\treturn selinux_ip_postroute(skb, state->out, PF_INET6);\n}\n#endif\t/* IPV6 */\n\n#endif\t/* CONFIG_NETFILTER */\n\nstatic int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 0;\n\tunsigned int msg_len;\n\tunsigned int data_len = skb->len;\n\tunsigned char *data = skb->data;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 sclass = sksec->sclass;\n\tu32 perm;\n\n\twhile (data_len >= nlmsg_total_size(0)) {\n\t\tnlh = (struct nlmsghdr *)data;\n\n\t\t/* NOTE: the nlmsg_len field isn't reliably set by some netlink\n\t\t *       users which means we can't reject skb's with bogus\n\t\t *       length fields; our solution is to follow what\n\t\t *       netlink_rcv_skb() does and simply skip processing at\n\t\t *       messages with length fields that are clearly junk\n\t\t */\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)\n\t\t\treturn 0;\n\n\t\trc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);\n\t\tif (rc == 0) {\n\t\t\trc = sock_has_perm(sk, perm);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t/* -EINVAL is a missing msg/perm mapping */\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t\t\" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t\t\" pid=%d comm=%s\\n\",\n\t\t\t\tsk->sk_protocol, nlh->nlmsg_type,\n\t\t\t\tsecclass_map[sclass - 1].name,\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\t\tif (enforcing_enabled(&selinux_state) &&\n\t\t\t    !security_get_allow_unknown(&selinux_state))\n\t\t\t\treturn rc;\n\t\t\trc = 0;\n\t\t} else if (rc == -ENOENT) {\n\t\t\t/* -ENOENT is a missing socket/class mapping, ignore */\n\t\t\trc = 0;\n\t\t} else {\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* move to the next message after applying netlink padding */\n\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msg_len >= data_len)\n\t\t\treturn 0;\n\t\tdata_len -= msg_len;\n\t\tdata += msg_len;\n\t}\n\n\treturn rc;\n}\n\nstatic void ipc_init_security(struct ipc_security_struct *isec, u16 sclass)\n{\n\tisec->sclass = sclass;\n\tisec->sid = current_sid();\n}\n\nstatic int ipc_has_perm(struct kern_ipc_perm *ipc_perms,\n\t\t\tu32 perms)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(ipc_perms);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = ipc_perms->key;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, isec->sclass, perms, &ad);\n}\n\nstatic int selinux_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct msg_security_struct *msec;\n\n\tmsec = selinux_msg_msg(msg);\n\tmsec->sid = SECINITSID_UNLABELED;\n\n\treturn 0;\n}\n\n/* message queue security operations */\nstatic int selinux_msg_queue_alloc_security(struct kern_ipc_perm *msq)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tint rc;\n\n\tisec = selinux_ipc(msq);\n\tipc_init_security(isec, SECCLASS_MSGQ);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t  MSGQ__CREATE, &ad);\n\treturn rc;\n}\n\nstatic int selinux_msg_queue_associate(struct kern_ipc_perm *msq, int msqflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(msq);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t    MSGQ__ASSOCIATE, &ad);\n}\n\nstatic int selinux_msg_queue_msgctl(struct kern_ipc_perm *msq, int cmd)\n{\n\tint err;\n\tint perms;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase MSG_INFO:\n\t\t/* No specific object, just general system-wide information. */\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__IPC_INFO, NULL);\n\tcase IPC_STAT:\n\tcase MSG_STAT:\n\tcase MSG_STAT_ANY:\n\t\tperms = MSGQ__GETATTR | MSGQ__ASSOCIATE;\n\t\tbreak;\n\tcase IPC_SET:\n\t\tperms = MSGQ__SETATTR;\n\t\tbreak;\n\tcase IPC_RMID:\n\t\tperms = MSGQ__DESTROY;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = ipc_has_perm(msq, perms);\n\treturn err;\n}\n\nstatic int selinux_msg_queue_msgsnd(struct kern_ipc_perm *msq, struct msg_msg *msg, int msqflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct msg_security_struct *msec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tint rc;\n\n\tisec = selinux_ipc(msq);\n\tmsec = selinux_msg_msg(msg);\n\n\t/*\n\t * First time through, need to assign label to the message\n\t */\n\tif (msec->sid == SECINITSID_UNLABELED) {\n\t\t/*\n\t\t * Compute new sid based on current process and\n\t\t * message queue this message will be stored in\n\t\t */\n\t\trc = security_transition_sid(&selinux_state, sid, isec->sid,\n\t\t\t\t\t     SECCLASS_MSG, NULL, &msec->sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\t/* Can this process write to the queue? */\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t  MSGQ__WRITE, &ad);\n\tif (!rc)\n\t\t/* Can this process send the message */\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, msec->sid, SECCLASS_MSG,\n\t\t\t\t  MSG__SEND, &ad);\n\tif (!rc)\n\t\t/* Can the message be put in the queue? */\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  msec->sid, isec->sid, SECCLASS_MSGQ,\n\t\t\t\t  MSGQ__ENQUEUE, &ad);\n\n\treturn rc;\n}\n\nstatic int selinux_msg_queue_msgrcv(struct kern_ipc_perm *msq, struct msg_msg *msg,\n\t\t\t\t    struct task_struct *target,\n\t\t\t\t    long type, int mode)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct msg_security_struct *msec;\n\tstruct common_audit_data ad;\n\tu32 sid = task_sid(target);\n\tint rc;\n\n\tisec = selinux_ipc(msq);\n\tmsec = selinux_msg_msg(msg);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = msq->key;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid,\n\t\t\t  SECCLASS_MSGQ, MSGQ__READ, &ad);\n\tif (!rc)\n\t\trc = avc_has_perm(&selinux_state,\n\t\t\t\t  sid, msec->sid,\n\t\t\t\t  SECCLASS_MSG, MSG__RECEIVE, &ad);\n\treturn rc;\n}\n\n/* Shared Memory security operations */\nstatic int selinux_shm_alloc_security(struct kern_ipc_perm *shp)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tint rc;\n\n\tisec = selinux_ipc(shp);\n\tipc_init_security(isec, SECCLASS_SHM);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = shp->key;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid, SECCLASS_SHM,\n\t\t\t  SHM__CREATE, &ad);\n\treturn rc;\n}\n\nstatic int selinux_shm_associate(struct kern_ipc_perm *shp, int shmflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(shp);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = shp->key;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, SECCLASS_SHM,\n\t\t\t    SHM__ASSOCIATE, &ad);\n}\n\n/* Note, at this point, shp is locked down */\nstatic int selinux_shm_shmctl(struct kern_ipc_perm *shp, int cmd)\n{\n\tint perms;\n\tint err;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\t\t/* No specific object, just general system-wide information. */\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__IPC_INFO, NULL);\n\tcase IPC_STAT:\n\tcase SHM_STAT:\n\tcase SHM_STAT_ANY:\n\t\tperms = SHM__GETATTR | SHM__ASSOCIATE;\n\t\tbreak;\n\tcase IPC_SET:\n\t\tperms = SHM__SETATTR;\n\t\tbreak;\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t\tperms = SHM__LOCK;\n\t\tbreak;\n\tcase IPC_RMID:\n\t\tperms = SHM__DESTROY;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = ipc_has_perm(shp, perms);\n\treturn err;\n}\n\nstatic int selinux_shm_shmat(struct kern_ipc_perm *shp,\n\t\t\t     char __user *shmaddr, int shmflg)\n{\n\tu32 perms;\n\n\tif (shmflg & SHM_RDONLY)\n\t\tperms = SHM__READ;\n\telse\n\t\tperms = SHM__READ | SHM__WRITE;\n\n\treturn ipc_has_perm(shp, perms);\n}\n\n/* Semaphore security operations */\nstatic int selinux_sem_alloc_security(struct kern_ipc_perm *sma)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tint rc;\n\n\tisec = selinux_ipc(sma);\n\tipc_init_security(isec, SECCLASS_SEM);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = sma->key;\n\n\trc = avc_has_perm(&selinux_state,\n\t\t\t  sid, isec->sid, SECCLASS_SEM,\n\t\t\t  SEM__CREATE, &ad);\n\treturn rc;\n}\n\nstatic int selinux_sem_associate(struct kern_ipc_perm *sma, int semflg)\n{\n\tstruct ipc_security_struct *isec;\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\n\tisec = selinux_ipc(sma);\n\n\tad.type = LSM_AUDIT_DATA_IPC;\n\tad.u.ipc_id = sma->key;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, isec->sid, SECCLASS_SEM,\n\t\t\t    SEM__ASSOCIATE, &ad);\n}\n\n/* Note, at this point, sma is locked down */\nstatic int selinux_sem_semctl(struct kern_ipc_perm *sma, int cmd)\n{\n\tint err;\n\tu32 perms;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\t/* No specific object, just general system-wide information. */\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    current_sid(), SECINITSID_KERNEL,\n\t\t\t\t    SECCLASS_SYSTEM, SYSTEM__IPC_INFO, NULL);\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\t\tperms = SEM__GETATTR;\n\t\tbreak;\n\tcase GETVAL:\n\tcase GETALL:\n\t\tperms = SEM__READ;\n\t\tbreak;\n\tcase SETVAL:\n\tcase SETALL:\n\t\tperms = SEM__WRITE;\n\t\tbreak;\n\tcase IPC_RMID:\n\t\tperms = SEM__DESTROY;\n\t\tbreak;\n\tcase IPC_SET:\n\t\tperms = SEM__SETATTR;\n\t\tbreak;\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\tcase SEM_STAT_ANY:\n\t\tperms = SEM__GETATTR | SEM__ASSOCIATE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = ipc_has_perm(sma, perms);\n\treturn err;\n}\n\nstatic int selinux_sem_semop(struct kern_ipc_perm *sma,\n\t\t\t     struct sembuf *sops, unsigned nsops, int alter)\n{\n\tu32 perms;\n\n\tif (alter)\n\t\tperms = SEM__READ | SEM__WRITE;\n\telse\n\t\tperms = SEM__READ;\n\n\treturn ipc_has_perm(sma, perms);\n}\n\nstatic int selinux_ipc_permission(struct kern_ipc_perm *ipcp, short flag)\n{\n\tu32 av = 0;\n\n\tav = 0;\n\tif (flag & S_IRUGO)\n\t\tav |= IPC__UNIX_READ;\n\tif (flag & S_IWUGO)\n\t\tav |= IPC__UNIX_WRITE;\n\n\tif (av == 0)\n\t\treturn 0;\n\n\treturn ipc_has_perm(ipcp, av);\n}\n\nstatic void selinux_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)\n{\n\tstruct ipc_security_struct *isec = selinux_ipc(ipcp);\n\t*secid = isec->sid;\n}\n\nstatic void selinux_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (inode)\n\t\tinode_doinit_with_dentry(inode, dentry);\n}\n\nstatic int selinux_getprocattr(struct task_struct *p,\n\t\t\t       char *name, char **value)\n{\n\tconst struct task_security_struct *__tsec;\n\tu32 sid;\n\tint error;\n\tunsigned len;\n\n\trcu_read_lock();\n\t__tsec = selinux_cred(__task_cred(p));\n\n\tif (current != p) {\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     current_sid(), __tsec->sid,\n\t\t\t\t     SECCLASS_PROCESS, PROCESS__GETATTR, NULL);\n\t\tif (error)\n\t\t\tgoto bad;\n\t}\n\n\tif (!strcmp(name, \"current\"))\n\t\tsid = __tsec->sid;\n\telse if (!strcmp(name, \"prev\"))\n\t\tsid = __tsec->osid;\n\telse if (!strcmp(name, \"exec\"))\n\t\tsid = __tsec->exec_sid;\n\telse if (!strcmp(name, \"fscreate\"))\n\t\tsid = __tsec->create_sid;\n\telse if (!strcmp(name, \"keycreate\"))\n\t\tsid = __tsec->keycreate_sid;\n\telse if (!strcmp(name, \"sockcreate\"))\n\t\tsid = __tsec->sockcreate_sid;\n\telse {\n\t\terror = -EINVAL;\n\t\tgoto bad;\n\t}\n\trcu_read_unlock();\n\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_sid_to_context(&selinux_state, sid, value, &len);\n\tif (error)\n\t\treturn error;\n\treturn len;\n\nbad:\n\trcu_read_unlock();\n\treturn error;\n}\n\nstatic int selinux_setprocattr(const char *name, void *value, size_t size)\n{\n\tstruct task_security_struct *tsec;\n\tstruct cred *new;\n\tu32 mysid = current_sid(), sid = 0, ptsid;\n\tint error;\n\tchar *str = value;\n\n\t/*\n\t * Basic control over ability to set these attributes at all.\n\t */\n\tif (!strcmp(name, \"exec\"))\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETEXEC, NULL);\n\telse if (!strcmp(name, \"fscreate\"))\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETFSCREATE, NULL);\n\telse if (!strcmp(name, \"keycreate\"))\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETKEYCREATE, NULL);\n\telse if (!strcmp(name, \"sockcreate\"))\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETSOCKCREATE, NULL);\n\telse if (!strcmp(name, \"current\"))\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     mysid, mysid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__SETCURRENT, NULL);\n\telse\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\t/* Obtain a SID for the context, if one was specified. */\n\tif (size && str[0] && str[0] != '\\n') {\n\t\tif (str[size-1] == '\\n') {\n\t\t\tstr[size-1] = 0;\n\t\t\tsize--;\n\t\t}\n\t\terror = security_context_to_sid(&selinux_state, value, size,\n\t\t\t\t\t\t&sid, GFP_KERNEL);\n\t\tif (error == -EINVAL && !strcmp(name, \"fscreate\")) {\n\t\t\tif (!has_cap_mac_admin(true)) {\n\t\t\t\tstruct audit_buffer *ab;\n\t\t\t\tsize_t audit_size;\n\n\t\t\t\t/* We strip a nul only if it is at the end, otherwise the\n\t\t\t\t * context contains a nul and we should audit that */\n\t\t\t\tif (str[size - 1] == '\\0')\n\t\t\t\t\taudit_size = size - 1;\n\t\t\t\telse\n\t\t\t\t\taudit_size = size;\n\t\t\t\tab = audit_log_start(audit_context(),\n\t\t\t\t\t\t     GFP_ATOMIC,\n\t\t\t\t\t\t     AUDIT_SELINUX_ERR);\n\t\t\t\taudit_log_format(ab, \"op=fscreate invalid_context=\");\n\t\t\t\taudit_log_n_untrustedstring(ab, value, audit_size);\n\t\t\t\taudit_log_end(ab);\n\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\terror = security_context_to_sid_force(\n\t\t\t\t\t\t      &selinux_state,\n\t\t\t\t\t\t      value, size, &sid);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* Permission checking based on the specified context is\n\t   performed during the actual operation (execve,\n\t   open/mkdir/...), when we know the full context of the\n\t   operation.  See selinux_bprm_creds_for_exec for the execve\n\t   checks and may_create for the file creation checks. The\n\t   operation will then fail if the context is not permitted. */\n\ttsec = selinux_cred(new);\n\tif (!strcmp(name, \"exec\")) {\n\t\ttsec->exec_sid = sid;\n\t} else if (!strcmp(name, \"fscreate\")) {\n\t\ttsec->create_sid = sid;\n\t} else if (!strcmp(name, \"keycreate\")) {\n\t\tif (sid) {\n\t\t\terror = avc_has_perm(&selinux_state, mysid, sid,\n\t\t\t\t\t     SECCLASS_KEY, KEY__CREATE, NULL);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\t\ttsec->keycreate_sid = sid;\n\t} else if (!strcmp(name, \"sockcreate\")) {\n\t\ttsec->sockcreate_sid = sid;\n\t} else if (!strcmp(name, \"current\")) {\n\t\terror = -EINVAL;\n\t\tif (sid == 0)\n\t\t\tgoto abort_change;\n\n\t\t/* Only allow single threaded processes to change context */\n\t\terror = -EPERM;\n\t\tif (!current_is_single_threaded()) {\n\t\t\terror = security_bounded_transition(&selinux_state,\n\t\t\t\t\t\t\t    tsec->sid, sid);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\t/* Check permissions for the transition. */\n\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t     tsec->sid, sid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__DYNTRANSITION, NULL);\n\t\tif (error)\n\t\t\tgoto abort_change;\n\n\t\t/* Check for ptracing, and update the task SID if ok.\n\t\t   Otherwise, leave SID unchanged and fail. */\n\t\tptsid = ptrace_parent_sid();\n\t\tif (ptsid != 0) {\n\t\t\terror = avc_has_perm(&selinux_state,\n\t\t\t\t\t     ptsid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t     PROCESS__PTRACE, NULL);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\ttsec->sid = sid;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto abort_change;\n\t}\n\n\tcommit_creds(new);\n\treturn size;\n\nabort_change:\n\tabort_creds(new);\n\treturn error;\n}\n\nstatic int selinux_ismaclabel(const char *name)\n{\n\treturn (strcmp(name, XATTR_SELINUX_SUFFIX) == 0);\n}\n\nstatic int selinux_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)\n{\n\treturn security_sid_to_context(&selinux_state, secid,\n\t\t\t\t       secdata, seclen);\n}\n\nstatic int selinux_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)\n{\n\treturn security_context_to_sid(&selinux_state, secdata, seclen,\n\t\t\t\t       secid, GFP_KERNEL);\n}\n\nstatic void selinux_release_secctx(char *secdata, u32 seclen)\n{\n\tkfree(secdata);\n}\n\nstatic void selinux_inode_invalidate_secctx(struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\n\tspin_lock(&isec->lock);\n\tisec->initialized = LABEL_INVALID;\n\tspin_unlock(&isec->lock);\n}\n\n/*\n *\tcalled with inode->i_mutex locked\n */\nstatic int selinux_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)\n{\n\tint rc = selinux_inode_setsecurity(inode, XATTR_SELINUX_SUFFIX,\n\t\t\t\t\t   ctx, ctxlen, 0);\n\t/* Do not return error when suppressing label (SBLABEL_MNT not set). */\n\treturn rc == -EOPNOTSUPP ? 0 : rc;\n}\n\n/*\n *\tcalled with inode->i_mutex locked\n */\nstatic int selinux_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)\n{\n\treturn __vfs_setxattr_noperm(dentry, XATTR_NAME_SELINUX, ctx, ctxlen, 0);\n}\n\nstatic int selinux_inode_getsecctx(struct inode *inode, void **ctx, u32 *ctxlen)\n{\n\tint len = 0;\n\tlen = selinux_inode_getsecurity(inode, XATTR_SELINUX_SUFFIX,\n\t\t\t\t\t\tctx, true);\n\tif (len < 0)\n\t\treturn len;\n\t*ctxlen = len;\n\treturn 0;\n}\n#ifdef CONFIG_KEYS\n\nstatic int selinux_key_alloc(struct key *k, const struct cred *cred,\n\t\t\t     unsigned long flags)\n{\n\tconst struct task_security_struct *tsec;\n\tstruct key_security_struct *ksec;\n\n\tksec = kzalloc(sizeof(struct key_security_struct), GFP_KERNEL);\n\tif (!ksec)\n\t\treturn -ENOMEM;\n\n\ttsec = selinux_cred(cred);\n\tif (tsec->keycreate_sid)\n\t\tksec->sid = tsec->keycreate_sid;\n\telse\n\t\tksec->sid = tsec->sid;\n\n\tk->security = ksec;\n\treturn 0;\n}\n\nstatic void selinux_key_free(struct key *k)\n{\n\tstruct key_security_struct *ksec = k->security;\n\n\tk->security = NULL;\n\tkfree(ksec);\n}\n\nstatic int selinux_key_permission(key_ref_t key_ref,\n\t\t\t\t  const struct cred *cred,\n\t\t\t\t  enum key_need_perm need_perm)\n{\n\tstruct key *key;\n\tstruct key_security_struct *ksec;\n\tu32 perm, sid;\n\n\tswitch (need_perm) {\n\tcase KEY_NEED_VIEW:\n\t\tperm = KEY__VIEW;\n\t\tbreak;\n\tcase KEY_NEED_READ:\n\t\tperm = KEY__READ;\n\t\tbreak;\n\tcase KEY_NEED_WRITE:\n\t\tperm = KEY__WRITE;\n\t\tbreak;\n\tcase KEY_NEED_SEARCH:\n\t\tperm = KEY__SEARCH;\n\t\tbreak;\n\tcase KEY_NEED_LINK:\n\t\tperm = KEY__LINK;\n\t\tbreak;\n\tcase KEY_NEED_SETATTR:\n\t\tperm = KEY__SETATTR;\n\t\tbreak;\n\tcase KEY_NEED_UNLINK:\n\tcase KEY_SYSADMIN_OVERRIDE:\n\tcase KEY_AUTHTOKEN_OVERRIDE:\n\tcase KEY_DEFER_PERM_CHECK:\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EPERM;\n\n\t}\n\n\tsid = cred_sid(cred);\n\tkey = key_ref_to_ptr(key_ref);\n\tksec = key->security;\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, ksec->sid, SECCLASS_KEY, perm, NULL);\n}\n\nstatic int selinux_key_getsecurity(struct key *key, char **_buffer)\n{\n\tstruct key_security_struct *ksec = key->security;\n\tchar *context = NULL;\n\tunsigned len;\n\tint rc;\n\n\trc = security_sid_to_context(&selinux_state, ksec->sid,\n\t\t\t\t     &context, &len);\n\tif (!rc)\n\t\trc = len;\n\t*_buffer = context;\n\treturn rc;\n}\n\n#ifdef CONFIG_KEY_NOTIFICATIONS\nstatic int selinux_watch_key(struct key *key)\n{\n\tstruct key_security_struct *ksec = key->security;\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, ksec->sid, SECCLASS_KEY, KEY__VIEW, NULL);\n}\n#endif\n#endif\n\n#ifdef CONFIG_SECURITY_INFINIBAND\nstatic int selinux_ib_pkey_access(void *ib_sec, u64 subnet_prefix, u16 pkey_val)\n{\n\tstruct common_audit_data ad;\n\tint err;\n\tu32 sid = 0;\n\tstruct ib_security_struct *sec = ib_sec;\n\tstruct lsm_ibpkey_audit ibpkey;\n\n\terr = sel_ib_pkey_sid(subnet_prefix, pkey_val, &sid);\n\tif (err)\n\t\treturn err;\n\n\tad.type = LSM_AUDIT_DATA_IBPKEY;\n\tibpkey.subnet_prefix = subnet_prefix;\n\tibpkey.pkey = pkey_val;\n\tad.u.ibpkey = &ibpkey;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sec->sid, sid,\n\t\t\t    SECCLASS_INFINIBAND_PKEY,\n\t\t\t    INFINIBAND_PKEY__ACCESS, &ad);\n}\n\nstatic int selinux_ib_endport_manage_subnet(void *ib_sec, const char *dev_name,\n\t\t\t\t\t    u8 port_num)\n{\n\tstruct common_audit_data ad;\n\tint err;\n\tu32 sid = 0;\n\tstruct ib_security_struct *sec = ib_sec;\n\tstruct lsm_ibendport_audit ibendport;\n\n\terr = security_ib_endport_sid(&selinux_state, dev_name, port_num,\n\t\t\t\t      &sid);\n\n\tif (err)\n\t\treturn err;\n\n\tad.type = LSM_AUDIT_DATA_IBENDPORT;\n\tstrncpy(ibendport.dev_name, dev_name, sizeof(ibendport.dev_name));\n\tibendport.port = port_num;\n\tad.u.ibendport = &ibendport;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sec->sid, sid,\n\t\t\t    SECCLASS_INFINIBAND_ENDPORT,\n\t\t\t    INFINIBAND_ENDPORT__MANAGE_SUBNET, &ad);\n}\n\nstatic int selinux_ib_alloc_security(void **ib_sec)\n{\n\tstruct ib_security_struct *sec;\n\n\tsec = kzalloc(sizeof(*sec), GFP_KERNEL);\n\tif (!sec)\n\t\treturn -ENOMEM;\n\tsec->sid = current_sid();\n\n\t*ib_sec = sec;\n\treturn 0;\n}\n\nstatic void selinux_ib_free_security(void *ib_sec)\n{\n\tkfree(ib_sec);\n}\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\nstatic int selinux_bpf(int cmd, union bpf_attr *attr,\n\t\t\t\t     unsigned int size)\n{\n\tu32 sid = current_sid();\n\tint ret;\n\n\tswitch (cmd) {\n\tcase BPF_MAP_CREATE:\n\t\tret = avc_has_perm(&selinux_state,\n\t\t\t\t   sid, sid, SECCLASS_BPF, BPF__MAP_CREATE,\n\t\t\t\t   NULL);\n\t\tbreak;\n\tcase BPF_PROG_LOAD:\n\t\tret = avc_has_perm(&selinux_state,\n\t\t\t\t   sid, sid, SECCLASS_BPF, BPF__PROG_LOAD,\n\t\t\t\t   NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 bpf_map_fmode_to_av(fmode_t fmode)\n{\n\tu32 av = 0;\n\n\tif (fmode & FMODE_READ)\n\t\tav |= BPF__MAP_READ;\n\tif (fmode & FMODE_WRITE)\n\t\tav |= BPF__MAP_WRITE;\n\treturn av;\n}\n\n/* This function will check the file pass through unix socket or binder to see\n * if it is a bpf related object. And apply correspinding checks on the bpf\n * object based on the type. The bpf maps and programs, not like other files and\n * socket, are using a shared anonymous inode inside the kernel as their inode.\n * So checking that inode cannot identify if the process have privilege to\n * access the bpf object and that's why we have to add this additional check in\n * selinux_file_receive and selinux_binder_transfer_files.\n */\nstatic int bpf_fd_pass(struct file *file, u32 sid)\n{\n\tstruct bpf_security_struct *bpfsec;\n\tstruct bpf_prog *prog;\n\tstruct bpf_map *map;\n\tint ret;\n\n\tif (file->f_op == &bpf_map_fops) {\n\t\tmap = file->private_data;\n\t\tbpfsec = map->security;\n\t\tret = avc_has_perm(&selinux_state,\n\t\t\t\t   sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t\t   bpf_map_fmode_to_av(file->f_mode), NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (file->f_op == &bpf_prog_fops) {\n\t\tprog = file->private_data;\n\t\tbpfsec = prog->aux->security;\n\t\tret = avc_has_perm(&selinux_state,\n\t\t\t\t   sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t\t   BPF__PROG_RUN, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int selinux_bpf_map(struct bpf_map *map, fmode_t fmode)\n{\n\tu32 sid = current_sid();\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = map->security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t    bpf_map_fmode_to_av(fmode), NULL);\n}\n\nstatic int selinux_bpf_prog(struct bpf_prog *prog)\n{\n\tu32 sid = current_sid();\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = prog->aux->security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, bpfsec->sid, SECCLASS_BPF,\n\t\t\t    BPF__PROG_RUN, NULL);\n}\n\nstatic int selinux_bpf_map_alloc(struct bpf_map *map)\n{\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = kzalloc(sizeof(*bpfsec), GFP_KERNEL);\n\tif (!bpfsec)\n\t\treturn -ENOMEM;\n\n\tbpfsec->sid = current_sid();\n\tmap->security = bpfsec;\n\n\treturn 0;\n}\n\nstatic void selinux_bpf_map_free(struct bpf_map *map)\n{\n\tstruct bpf_security_struct *bpfsec = map->security;\n\n\tmap->security = NULL;\n\tkfree(bpfsec);\n}\n\nstatic int selinux_bpf_prog_alloc(struct bpf_prog_aux *aux)\n{\n\tstruct bpf_security_struct *bpfsec;\n\n\tbpfsec = kzalloc(sizeof(*bpfsec), GFP_KERNEL);\n\tif (!bpfsec)\n\t\treturn -ENOMEM;\n\n\tbpfsec->sid = current_sid();\n\taux->security = bpfsec;\n\n\treturn 0;\n}\n\nstatic void selinux_bpf_prog_free(struct bpf_prog_aux *aux)\n{\n\tstruct bpf_security_struct *bpfsec = aux->security;\n\n\taux->security = NULL;\n\tkfree(bpfsec);\n}\n#endif\n\nstatic int selinux_lockdown(enum lockdown_reason what)\n{\n\tstruct common_audit_data ad;\n\tu32 sid = current_sid();\n\tint invalid_reason = (what <= LOCKDOWN_NONE) ||\n\t\t\t     (what == LOCKDOWN_INTEGRITY_MAX) ||\n\t\t\t     (what >= LOCKDOWN_CONFIDENTIALITY_MAX);\n\n\tif (WARN(invalid_reason, \"Invalid lockdown reason\")) {\n\t\taudit_log(audit_context(),\n\t\t\t  GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"lockdown_reason=invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tad.type = LSM_AUDIT_DATA_LOCKDOWN;\n\tad.u.reason = what;\n\n\tif (what <= LOCKDOWN_INTEGRITY_MAX)\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    sid, sid, SECCLASS_LOCKDOWN,\n\t\t\t\t    LOCKDOWN__INTEGRITY, &ad);\n\telse\n\t\treturn avc_has_perm(&selinux_state,\n\t\t\t\t    sid, sid, SECCLASS_LOCKDOWN,\n\t\t\t\t    LOCKDOWN__CONFIDENTIALITY, &ad);\n}\n\nstruct lsm_blob_sizes selinux_blob_sizes __lsm_ro_after_init = {\n\t.lbs_cred = sizeof(struct task_security_struct),\n\t.lbs_file = sizeof(struct file_security_struct),\n\t.lbs_inode = sizeof(struct inode_security_struct),\n\t.lbs_ipc = sizeof(struct ipc_security_struct),\n\t.lbs_msg_msg = sizeof(struct msg_security_struct),\n};\n\n#ifdef CONFIG_PERF_EVENTS\nstatic int selinux_perf_event_open(struct perf_event_attr *attr, int type)\n{\n\tu32 requested, sid = current_sid();\n\n\tif (type == PERF_SECURITY_OPEN)\n\t\trequested = PERF_EVENT__OPEN;\n\telse if (type == PERF_SECURITY_CPU)\n\t\trequested = PERF_EVENT__CPU;\n\telse if (type == PERF_SECURITY_KERNEL)\n\t\trequested = PERF_EVENT__KERNEL;\n\telse if (type == PERF_SECURITY_TRACEPOINT)\n\t\trequested = PERF_EVENT__TRACEPOINT;\n\telse\n\t\treturn -EINVAL;\n\n\treturn avc_has_perm(&selinux_state, sid, sid, SECCLASS_PERF_EVENT,\n\t\t\t    requested, NULL);\n}\n\nstatic int selinux_perf_event_alloc(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec;\n\n\tperfsec = kzalloc(sizeof(*perfsec), GFP_KERNEL);\n\tif (!perfsec)\n\t\treturn -ENOMEM;\n\n\tperfsec->sid = current_sid();\n\tevent->security = perfsec;\n\n\treturn 0;\n}\n\nstatic void selinux_perf_event_free(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec = event->security;\n\n\tevent->security = NULL;\n\tkfree(perfsec);\n}\n\nstatic int selinux_perf_event_read(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec = event->security;\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(&selinux_state, sid, perfsec->sid,\n\t\t\t    SECCLASS_PERF_EVENT, PERF_EVENT__READ, NULL);\n}\n\nstatic int selinux_perf_event_write(struct perf_event *event)\n{\n\tstruct perf_event_security_struct *perfsec = event->security;\n\tu32 sid = current_sid();\n\n\treturn avc_has_perm(&selinux_state, sid, perfsec->sid,\n\t\t\t    SECCLASS_PERF_EVENT, PERF_EVENT__WRITE, NULL);\n}\n#endif\n\n/*\n * IMPORTANT NOTE: When adding new hooks, please be careful to keep this order:\n * 1. any hooks that don't belong to (2.) or (3.) below,\n * 2. hooks that both access structures allocated by other hooks, and allocate\n *    structures that can be later accessed by other hooks (mostly \"cloning\"\n *    hooks),\n * 3. hooks that only allocate structures that can be later accessed by other\n *    hooks (\"allocating\" hooks).\n *\n * Please follow block comment delimiters in the list to keep this order.\n *\n * This ordering is needed for SELinux runtime disable to work at least somewhat\n * safely. Breaking the ordering rules above might lead to NULL pointer derefs\n * when disabling SELinux at runtime.\n */\nstatic struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(binder_set_context_mgr, selinux_binder_set_context_mgr),\n\tLSM_HOOK_INIT(binder_transaction, selinux_binder_transaction),\n\tLSM_HOOK_INIT(binder_transfer_binder, selinux_binder_transfer_binder),\n\tLSM_HOOK_INIT(binder_transfer_file, selinux_binder_transfer_file),\n\n\tLSM_HOOK_INIT(ptrace_access_check, selinux_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, selinux_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, selinux_capget),\n\tLSM_HOOK_INIT(capset, selinux_capset),\n\tLSM_HOOK_INIT(capable, selinux_capable),\n\tLSM_HOOK_INIT(quotactl, selinux_quotactl),\n\tLSM_HOOK_INIT(quota_on, selinux_quota_on),\n\tLSM_HOOK_INIT(syslog, selinux_syslog),\n\tLSM_HOOK_INIT(vm_enough_memory, selinux_vm_enough_memory),\n\n\tLSM_HOOK_INIT(netlink_send, selinux_netlink_send),\n\n\tLSM_HOOK_INIT(bprm_creds_for_exec, selinux_bprm_creds_for_exec),\n\tLSM_HOOK_INIT(bprm_committing_creds, selinux_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, selinux_bprm_committed_creds),\n\n\tLSM_HOOK_INIT(sb_free_security, selinux_sb_free_security),\n\tLSM_HOOK_INIT(sb_free_mnt_opts, selinux_free_mnt_opts),\n\tLSM_HOOK_INIT(sb_remount, selinux_sb_remount),\n\tLSM_HOOK_INIT(sb_kern_mount, selinux_sb_kern_mount),\n\tLSM_HOOK_INIT(sb_show_options, selinux_sb_show_options),\n\tLSM_HOOK_INIT(sb_statfs, selinux_sb_statfs),\n\tLSM_HOOK_INIT(sb_mount, selinux_mount),\n\tLSM_HOOK_INIT(sb_umount, selinux_umount),\n\tLSM_HOOK_INIT(sb_set_mnt_opts, selinux_set_mnt_opts),\n\tLSM_HOOK_INIT(sb_clone_mnt_opts, selinux_sb_clone_mnt_opts),\n\n\tLSM_HOOK_INIT(move_mount, selinux_move_mount),\n\n\tLSM_HOOK_INIT(dentry_init_security, selinux_dentry_init_security),\n\tLSM_HOOK_INIT(dentry_create_files_as, selinux_dentry_create_files_as),\n\n\tLSM_HOOK_INIT(inode_free_security, selinux_inode_free_security),\n\tLSM_HOOK_INIT(inode_init_security, selinux_inode_init_security),\n\tLSM_HOOK_INIT(inode_create, selinux_inode_create),\n\tLSM_HOOK_INIT(inode_link, selinux_inode_link),\n\tLSM_HOOK_INIT(inode_unlink, selinux_inode_unlink),\n\tLSM_HOOK_INIT(inode_symlink, selinux_inode_symlink),\n\tLSM_HOOK_INIT(inode_mkdir, selinux_inode_mkdir),\n\tLSM_HOOK_INIT(inode_rmdir, selinux_inode_rmdir),\n\tLSM_HOOK_INIT(inode_mknod, selinux_inode_mknod),\n\tLSM_HOOK_INIT(inode_rename, selinux_inode_rename),\n\tLSM_HOOK_INIT(inode_readlink, selinux_inode_readlink),\n\tLSM_HOOK_INIT(inode_follow_link, selinux_inode_follow_link),\n\tLSM_HOOK_INIT(inode_permission, selinux_inode_permission),\n\tLSM_HOOK_INIT(inode_setattr, selinux_inode_setattr),\n\tLSM_HOOK_INIT(inode_getattr, selinux_inode_getattr),\n\tLSM_HOOK_INIT(inode_setxattr, selinux_inode_setxattr),\n\tLSM_HOOK_INIT(inode_post_setxattr, selinux_inode_post_setxattr),\n\tLSM_HOOK_INIT(inode_getxattr, selinux_inode_getxattr),\n\tLSM_HOOK_INIT(inode_listxattr, selinux_inode_listxattr),\n\tLSM_HOOK_INIT(inode_removexattr, selinux_inode_removexattr),\n\tLSM_HOOK_INIT(inode_getsecurity, selinux_inode_getsecurity),\n\tLSM_HOOK_INIT(inode_setsecurity, selinux_inode_setsecurity),\n\tLSM_HOOK_INIT(inode_listsecurity, selinux_inode_listsecurity),\n\tLSM_HOOK_INIT(inode_getsecid, selinux_inode_getsecid),\n\tLSM_HOOK_INIT(inode_copy_up, selinux_inode_copy_up),\n\tLSM_HOOK_INIT(inode_copy_up_xattr, selinux_inode_copy_up_xattr),\n\tLSM_HOOK_INIT(path_notify, selinux_path_notify),\n\n\tLSM_HOOK_INIT(kernfs_init_security, selinux_kernfs_init_security),\n\n\tLSM_HOOK_INIT(file_permission, selinux_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),\n\tLSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),\n\tLSM_HOOK_INIT(mmap_file, selinux_mmap_file),\n\tLSM_HOOK_INIT(mmap_addr, selinux_mmap_addr),\n\tLSM_HOOK_INIT(file_mprotect, selinux_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, selinux_file_lock),\n\tLSM_HOOK_INIT(file_fcntl, selinux_file_fcntl),\n\tLSM_HOOK_INIT(file_set_fowner, selinux_file_set_fowner),\n\tLSM_HOOK_INIT(file_send_sigiotask, selinux_file_send_sigiotask),\n\tLSM_HOOK_INIT(file_receive, selinux_file_receive),\n\n\tLSM_HOOK_INIT(file_open, selinux_file_open),\n\n\tLSM_HOOK_INIT(task_alloc, selinux_task_alloc),\n\tLSM_HOOK_INIT(cred_prepare, selinux_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, selinux_cred_transfer),\n\tLSM_HOOK_INIT(cred_getsecid, selinux_cred_getsecid),\n\tLSM_HOOK_INIT(kernel_act_as, selinux_kernel_act_as),\n\tLSM_HOOK_INIT(kernel_create_files_as, selinux_kernel_create_files_as),\n\tLSM_HOOK_INIT(kernel_module_request, selinux_kernel_module_request),\n\tLSM_HOOK_INIT(kernel_load_data, selinux_kernel_load_data),\n\tLSM_HOOK_INIT(kernel_read_file, selinux_kernel_read_file),\n\tLSM_HOOK_INIT(task_setpgid, selinux_task_setpgid),\n\tLSM_HOOK_INIT(task_getpgid, selinux_task_getpgid),\n\tLSM_HOOK_INIT(task_getsid, selinux_task_getsid),\n\tLSM_HOOK_INIT(task_getsecid, selinux_task_getsecid),\n\tLSM_HOOK_INIT(task_setnice, selinux_task_setnice),\n\tLSM_HOOK_INIT(task_setioprio, selinux_task_setioprio),\n\tLSM_HOOK_INIT(task_getioprio, selinux_task_getioprio),\n\tLSM_HOOK_INIT(task_prlimit, selinux_task_prlimit),\n\tLSM_HOOK_INIT(task_setrlimit, selinux_task_setrlimit),\n\tLSM_HOOK_INIT(task_setscheduler, selinux_task_setscheduler),\n\tLSM_HOOK_INIT(task_getscheduler, selinux_task_getscheduler),\n\tLSM_HOOK_INIT(task_movememory, selinux_task_movememory),\n\tLSM_HOOK_INIT(task_kill, selinux_task_kill),\n\tLSM_HOOK_INIT(task_to_inode, selinux_task_to_inode),\n\n\tLSM_HOOK_INIT(ipc_permission, selinux_ipc_permission),\n\tLSM_HOOK_INIT(ipc_getsecid, selinux_ipc_getsecid),\n\n\tLSM_HOOK_INIT(msg_queue_associate, selinux_msg_queue_associate),\n\tLSM_HOOK_INIT(msg_queue_msgctl, selinux_msg_queue_msgctl),\n\tLSM_HOOK_INIT(msg_queue_msgsnd, selinux_msg_queue_msgsnd),\n\tLSM_HOOK_INIT(msg_queue_msgrcv, selinux_msg_queue_msgrcv),\n\n\tLSM_HOOK_INIT(shm_associate, selinux_shm_associate),\n\tLSM_HOOK_INIT(shm_shmctl, selinux_shm_shmctl),\n\tLSM_HOOK_INIT(shm_shmat, selinux_shm_shmat),\n\n\tLSM_HOOK_INIT(sem_associate, selinux_sem_associate),\n\tLSM_HOOK_INIT(sem_semctl, selinux_sem_semctl),\n\tLSM_HOOK_INIT(sem_semop, selinux_sem_semop),\n\n\tLSM_HOOK_INIT(d_instantiate, selinux_d_instantiate),\n\n\tLSM_HOOK_INIT(getprocattr, selinux_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, selinux_setprocattr),\n\n\tLSM_HOOK_INIT(ismaclabel, selinux_ismaclabel),\n\tLSM_HOOK_INIT(secctx_to_secid, selinux_secctx_to_secid),\n\tLSM_HOOK_INIT(release_secctx, selinux_release_secctx),\n\tLSM_HOOK_INIT(inode_invalidate_secctx, selinux_inode_invalidate_secctx),\n\tLSM_HOOK_INIT(inode_notifysecctx, selinux_inode_notifysecctx),\n\tLSM_HOOK_INIT(inode_setsecctx, selinux_inode_setsecctx),\n\n\tLSM_HOOK_INIT(unix_stream_connect, selinux_socket_unix_stream_connect),\n\tLSM_HOOK_INIT(unix_may_send, selinux_socket_unix_may_send),\n\n\tLSM_HOOK_INIT(socket_create, selinux_socket_create),\n\tLSM_HOOK_INIT(socket_post_create, selinux_socket_post_create),\n\tLSM_HOOK_INIT(socket_socketpair, selinux_socket_socketpair),\n\tLSM_HOOK_INIT(socket_bind, selinux_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, selinux_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, selinux_socket_listen),\n\tLSM_HOOK_INIT(socket_accept, selinux_socket_accept),\n\tLSM_HOOK_INIT(socket_sendmsg, selinux_socket_sendmsg),\n\tLSM_HOOK_INIT(socket_recvmsg, selinux_socket_recvmsg),\n\tLSM_HOOK_INIT(socket_getsockname, selinux_socket_getsockname),\n\tLSM_HOOK_INIT(socket_getpeername, selinux_socket_getpeername),\n\tLSM_HOOK_INIT(socket_getsockopt, selinux_socket_getsockopt),\n\tLSM_HOOK_INIT(socket_setsockopt, selinux_socket_setsockopt),\n\tLSM_HOOK_INIT(socket_shutdown, selinux_socket_shutdown),\n\tLSM_HOOK_INIT(socket_sock_rcv_skb, selinux_socket_sock_rcv_skb),\n\tLSM_HOOK_INIT(socket_getpeersec_stream,\n\t\t\tselinux_socket_getpeersec_stream),\n\tLSM_HOOK_INIT(socket_getpeersec_dgram, selinux_socket_getpeersec_dgram),\n\tLSM_HOOK_INIT(sk_free_security, selinux_sk_free_security),\n\tLSM_HOOK_INIT(sk_clone_security, selinux_sk_clone_security),\n\tLSM_HOOK_INIT(sk_getsecid, selinux_sk_getsecid),\n\tLSM_HOOK_INIT(sock_graft, selinux_sock_graft),\n\tLSM_HOOK_INIT(sctp_assoc_request, selinux_sctp_assoc_request),\n\tLSM_HOOK_INIT(sctp_sk_clone, selinux_sctp_sk_clone),\n\tLSM_HOOK_INIT(sctp_bind_connect, selinux_sctp_bind_connect),\n\tLSM_HOOK_INIT(inet_conn_request, selinux_inet_conn_request),\n\tLSM_HOOK_INIT(inet_csk_clone, selinux_inet_csk_clone),\n\tLSM_HOOK_INIT(inet_conn_established, selinux_inet_conn_established),\n\tLSM_HOOK_INIT(secmark_relabel_packet, selinux_secmark_relabel_packet),\n\tLSM_HOOK_INIT(secmark_refcount_inc, selinux_secmark_refcount_inc),\n\tLSM_HOOK_INIT(secmark_refcount_dec, selinux_secmark_refcount_dec),\n\tLSM_HOOK_INIT(req_classify_flow, selinux_req_classify_flow),\n\tLSM_HOOK_INIT(tun_dev_free_security, selinux_tun_dev_free_security),\n\tLSM_HOOK_INIT(tun_dev_create, selinux_tun_dev_create),\n\tLSM_HOOK_INIT(tun_dev_attach_queue, selinux_tun_dev_attach_queue),\n\tLSM_HOOK_INIT(tun_dev_attach, selinux_tun_dev_attach),\n\tLSM_HOOK_INIT(tun_dev_open, selinux_tun_dev_open),\n#ifdef CONFIG_SECURITY_INFINIBAND\n\tLSM_HOOK_INIT(ib_pkey_access, selinux_ib_pkey_access),\n\tLSM_HOOK_INIT(ib_endport_manage_subnet,\n\t\t      selinux_ib_endport_manage_subnet),\n\tLSM_HOOK_INIT(ib_free_security, selinux_ib_free_security),\n#endif\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_free_security, selinux_xfrm_policy_free),\n\tLSM_HOOK_INIT(xfrm_policy_delete_security, selinux_xfrm_policy_delete),\n\tLSM_HOOK_INIT(xfrm_state_free_security, selinux_xfrm_state_free),\n\tLSM_HOOK_INIT(xfrm_state_delete_security, selinux_xfrm_state_delete),\n\tLSM_HOOK_INIT(xfrm_policy_lookup, selinux_xfrm_policy_lookup),\n\tLSM_HOOK_INIT(xfrm_state_pol_flow_match,\n\t\t\tselinux_xfrm_state_pol_flow_match),\n\tLSM_HOOK_INIT(xfrm_decode_session, selinux_xfrm_decode_session),\n#endif\n\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_free, selinux_key_free),\n\tLSM_HOOK_INIT(key_permission, selinux_key_permission),\n\tLSM_HOOK_INIT(key_getsecurity, selinux_key_getsecurity),\n#ifdef CONFIG_KEY_NOTIFICATIONS\n\tLSM_HOOK_INIT(watch_key, selinux_watch_key),\n#endif\n#endif\n\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_known, selinux_audit_rule_known),\n\tLSM_HOOK_INIT(audit_rule_match, selinux_audit_rule_match),\n\tLSM_HOOK_INIT(audit_rule_free, selinux_audit_rule_free),\n#endif\n\n#ifdef CONFIG_BPF_SYSCALL\n\tLSM_HOOK_INIT(bpf, selinux_bpf),\n\tLSM_HOOK_INIT(bpf_map, selinux_bpf_map),\n\tLSM_HOOK_INIT(bpf_prog, selinux_bpf_prog),\n\tLSM_HOOK_INIT(bpf_map_free_security, selinux_bpf_map_free),\n\tLSM_HOOK_INIT(bpf_prog_free_security, selinux_bpf_prog_free),\n#endif\n\n#ifdef CONFIG_PERF_EVENTS\n\tLSM_HOOK_INIT(perf_event_open, selinux_perf_event_open),\n\tLSM_HOOK_INIT(perf_event_free, selinux_perf_event_free),\n\tLSM_HOOK_INIT(perf_event_read, selinux_perf_event_read),\n\tLSM_HOOK_INIT(perf_event_write, selinux_perf_event_write),\n#endif\n\n\tLSM_HOOK_INIT(locked_down, selinux_lockdown),\n\n\t/*\n\t * PUT \"CLONING\" (ACCESSING + ALLOCATING) HOOKS HERE\n\t */\n\tLSM_HOOK_INIT(fs_context_dup, selinux_fs_context_dup),\n\tLSM_HOOK_INIT(fs_context_parse_param, selinux_fs_context_parse_param),\n\tLSM_HOOK_INIT(sb_eat_lsm_opts, selinux_sb_eat_lsm_opts),\n\tLSM_HOOK_INIT(sb_add_mnt_opt, selinux_add_mnt_opt),\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_clone_security, selinux_xfrm_policy_clone),\n#endif\n\n\t/*\n\t * PUT \"ALLOCATING\" HOOKS HERE\n\t */\n\tLSM_HOOK_INIT(msg_msg_alloc_security, selinux_msg_msg_alloc_security),\n\tLSM_HOOK_INIT(msg_queue_alloc_security,\n\t\t      selinux_msg_queue_alloc_security),\n\tLSM_HOOK_INIT(shm_alloc_security, selinux_shm_alloc_security),\n\tLSM_HOOK_INIT(sb_alloc_security, selinux_sb_alloc_security),\n\tLSM_HOOK_INIT(inode_alloc_security, selinux_inode_alloc_security),\n\tLSM_HOOK_INIT(sem_alloc_security, selinux_sem_alloc_security),\n\tLSM_HOOK_INIT(secid_to_secctx, selinux_secid_to_secctx),\n\tLSM_HOOK_INIT(inode_getsecctx, selinux_inode_getsecctx),\n\tLSM_HOOK_INIT(sk_alloc_security, selinux_sk_alloc_security),\n\tLSM_HOOK_INIT(tun_dev_alloc_security, selinux_tun_dev_alloc_security),\n#ifdef CONFIG_SECURITY_INFINIBAND\n\tLSM_HOOK_INIT(ib_alloc_security, selinux_ib_alloc_security),\n#endif\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\n\tLSM_HOOK_INIT(xfrm_policy_alloc_security, selinux_xfrm_policy_alloc),\n\tLSM_HOOK_INIT(xfrm_state_alloc, selinux_xfrm_state_alloc),\n\tLSM_HOOK_INIT(xfrm_state_alloc_acquire,\n\t\t      selinux_xfrm_state_alloc_acquire),\n#endif\n#ifdef CONFIG_KEYS\n\tLSM_HOOK_INIT(key_alloc, selinux_key_alloc),\n#endif\n#ifdef CONFIG_AUDIT\n\tLSM_HOOK_INIT(audit_rule_init, selinux_audit_rule_init),\n#endif\n#ifdef CONFIG_BPF_SYSCALL\n\tLSM_HOOK_INIT(bpf_map_alloc_security, selinux_bpf_map_alloc),\n\tLSM_HOOK_INIT(bpf_prog_alloc_security, selinux_bpf_prog_alloc),\n#endif\n#ifdef CONFIG_PERF_EVENTS\n\tLSM_HOOK_INIT(perf_event_alloc, selinux_perf_event_alloc),\n#endif\n};\n\nstatic __init int selinux_init(void)\n{\n\tpr_info(\"SELinux:  Initializing.\\n\");\n\n\tmemset(&selinux_state, 0, sizeof(selinux_state));\n\tenforcing_set(&selinux_state, selinux_enforcing_boot);\n\tcheckreqprot_set(&selinux_state, selinux_checkreqprot_boot);\n\tselinux_avc_init(&selinux_state.avc);\n\tmutex_init(&selinux_state.status_lock);\n\tmutex_init(&selinux_state.policy_mutex);\n\n\t/* Set the security state for the initial task. */\n\tcred_init_security();\n\n\tdefault_noexec = !(VM_DATA_DEFAULT_FLAGS & VM_EXEC);\n\n\tavc_init();\n\n\tavtab_cache_init();\n\n\tebitmap_cache_init();\n\n\thashtab_cache_init();\n\n\tsecurity_add_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks), \"selinux\");\n\n\tif (avc_add_callback(selinux_netcache_avc_callback, AVC_CALLBACK_RESET))\n\t\tpanic(\"SELinux: Unable to register AVC netcache callback\\n\");\n\n\tif (avc_add_callback(selinux_lsm_notifier_avc_callback, AVC_CALLBACK_RESET))\n\t\tpanic(\"SELinux: Unable to register AVC LSM notifier callback\\n\");\n\n\tif (selinux_enforcing_boot)\n\t\tpr_debug(\"SELinux:  Starting in enforcing mode\\n\");\n\telse\n\t\tpr_debug(\"SELinux:  Starting in permissive mode\\n\");\n\n\tfs_validate_description(\"selinux\", selinux_fs_parameters);\n\n\treturn 0;\n}\n\nstatic void delayed_superblock_init(struct super_block *sb, void *unused)\n{\n\tselinux_set_mnt_opts(sb, NULL, 0, NULL);\n}\n\nvoid selinux_complete_init(void)\n{\n\tpr_debug(\"SELinux:  Completing initialization.\\n\");\n\n\t/* Set up any superblocks initialized prior to the policy load. */\n\tpr_debug(\"SELinux:  Setting up existing superblocks.\\n\");\n\titerate_supers(delayed_superblock_init, NULL);\n}\n\n/* SELinux requires early initialization in order to label\n   all processes and objects when they are created. */\nDEFINE_LSM(selinux) = {\n\t.name = \"selinux\",\n\t.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,\n\t.enabled = &selinux_enabled_boot,\n\t.blobs = &selinux_blob_sizes,\n\t.init = selinux_init,\n};\n\n#if defined(CONFIG_NETFILTER)\n\nstatic const struct nf_hook_ops selinux_nf_ops[] = {\n\t{\n\t\t.hook =\t\tselinux_ipv4_postroute,\n\t\t.pf =\t\tNFPROTO_IPV4,\n\t\t.hooknum =\tNF_INET_POST_ROUTING,\n\t\t.priority =\tNF_IP_PRI_SELINUX_LAST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ipv4_forward,\n\t\t.pf =\t\tNFPROTO_IPV4,\n\t\t.hooknum =\tNF_INET_FORWARD,\n\t\t.priority =\tNF_IP_PRI_SELINUX_FIRST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ipv4_output,\n\t\t.pf =\t\tNFPROTO_IPV4,\n\t\t.hooknum =\tNF_INET_LOCAL_OUT,\n\t\t.priority =\tNF_IP_PRI_SELINUX_FIRST,\n\t},\n#if IS_ENABLED(CONFIG_IPV6)\n\t{\n\t\t.hook =\t\tselinux_ipv6_postroute,\n\t\t.pf =\t\tNFPROTO_IPV6,\n\t\t.hooknum =\tNF_INET_POST_ROUTING,\n\t\t.priority =\tNF_IP6_PRI_SELINUX_LAST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ipv6_forward,\n\t\t.pf =\t\tNFPROTO_IPV6,\n\t\t.hooknum =\tNF_INET_FORWARD,\n\t\t.priority =\tNF_IP6_PRI_SELINUX_FIRST,\n\t},\n\t{\n\t\t.hook =\t\tselinux_ipv6_output,\n\t\t.pf =\t\tNFPROTO_IPV6,\n\t\t.hooknum =\tNF_INET_LOCAL_OUT,\n\t\t.priority =\tNF_IP6_PRI_SELINUX_FIRST,\n\t},\n#endif\t/* IPV6 */\n};\n\nstatic int __net_init selinux_nf_register(struct net *net)\n{\n\treturn nf_register_net_hooks(net, selinux_nf_ops,\n\t\t\t\t     ARRAY_SIZE(selinux_nf_ops));\n}\n\nstatic void __net_exit selinux_nf_unregister(struct net *net)\n{\n\tnf_unregister_net_hooks(net, selinux_nf_ops,\n\t\t\t\tARRAY_SIZE(selinux_nf_ops));\n}\n\nstatic struct pernet_operations selinux_net_ops = {\n\t.init = selinux_nf_register,\n\t.exit = selinux_nf_unregister,\n};\n\nstatic int __init selinux_nf_ip_init(void)\n{\n\tint err;\n\n\tif (!selinux_enabled_boot)\n\t\treturn 0;\n\n\tpr_debug(\"SELinux:  Registering netfilter hooks\\n\");\n\n\terr = register_pernet_subsys(&selinux_net_ops);\n\tif (err)\n\t\tpanic(\"SELinux: register_pernet_subsys: error %d\\n\", err);\n\n\treturn 0;\n}\n__initcall(selinux_nf_ip_init);\n\n#ifdef CONFIG_SECURITY_SELINUX_DISABLE\nstatic void selinux_nf_ip_exit(void)\n{\n\tpr_debug(\"SELinux:  Unregistering netfilter hooks\\n\");\n\n\tunregister_pernet_subsys(&selinux_net_ops);\n}\n#endif\n\n#else /* CONFIG_NETFILTER */\n\n#ifdef CONFIG_SECURITY_SELINUX_DISABLE\n#define selinux_nf_ip_exit()\n#endif\n\n#endif /* CONFIG_NETFILTER */\n\n#ifdef CONFIG_SECURITY_SELINUX_DISABLE\nint selinux_disable(struct selinux_state *state)\n{\n\tif (selinux_initialized(state)) {\n\t\t/* Not permitted after initial policy load. */\n\t\treturn -EINVAL;\n\t}\n\n\tif (selinux_disabled(state)) {\n\t\t/* Only do this once. */\n\t\treturn -EINVAL;\n\t}\n\n\tselinux_mark_disabled(state);\n\n\tpr_info(\"SELinux:  Disabled at runtime.\\n\");\n\n\t/*\n\t * Unregister netfilter hooks.\n\t * Must be done before security_delete_hooks() to avoid breaking\n\t * runtime disable.\n\t */\n\tselinux_nf_ip_exit();\n\n\tsecurity_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));\n\n\t/* Try to destroy the avc node cache */\n\tavc_disable();\n\n\t/* Unregister selinuxfs. */\n\texit_sel_fs();\n\n\treturn 0;\n}\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 294}, "message": "set_param_user_data: no type for 'inode->f_flags'"}], "macros": [], "notes": [], "path": "/src/security/selinux/hooks.c", "reportHash": "d60a05286139e34f5df84c25472868ec", "checkerName": "smatch.smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 294}, "message": "set_param_user_data: no type for 'inode->f_mode'"}], "macros": [], "notes": [], "path": "/src/security/selinux/hooks.c", "reportHash": "6dbe6d800e515c1e3f834b0ccecc3504", "checkerName": "smatch.smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1042}, "message": "error: we previously assumed 'context' could be null (see line 1037)"}], "macros": [], "notes": [], "path": "/src/security/selinux/hooks.c", "reportHash": "2cb291f76ed24e7e947d6000de4c8a61", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1630}, "message": "set_param_user_data: no type for 'inode->f_flags'"}], "macros": [], "notes": [], "path": "/src/security/selinux/hooks.c", "reportHash": "a69cd34405635ee6af25907fba2a1875", "checkerName": "smatch.smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 1630}, "message": "set_param_user_data: no type for 'inode->f_mode'"}], "macros": [], "notes": [], "path": "/src/security/selinux/hooks.c", "reportHash": "78debae2e5080699449d2522cc6bf748", "checkerName": "smatch.smatch_kernel_user_data", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
